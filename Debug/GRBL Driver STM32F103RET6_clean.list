
GRBL Driver STM32F103RET6_clean.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00026524  080001e8  080001e8  000101e8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000cd20  08026710  08026710  00036710  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08033430  08033430  0005044c  2**0
                  CONTENTS
  4 .ARM          00000000  08033430  08033430  0005044c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08033430  08033430  0005044c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08033430  08033430  00043430  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08033434  08033434  00043434  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000044c  20000000  08033438  00050000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001e9c  2000044c  08033884  0005044c  2**2
                  ALLOC
 10 ._user_heap_stack 00000e00  200022e8  08033884  000522e8  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  0005044c  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00050475  2**0
                  CONTENTS, READONLY
 13 .debug_info   000bef37  00000000  00000000  000504b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00008b44  00000000  00000000  0010f3ef  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001fa8  00000000  00000000  00117f38  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000018c8  00000000  00000000  00119ee0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00021498  00000000  00000000  0011b7a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0002b72d  00000000  00000000  0013cc40  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000b1098  00000000  00000000  0016836d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  000097c4  00000000  00000000  00219408  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000006c  00000000  00000000  00222bcc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e8 <__do_global_dtors_aux>:
 80001e8:	b510      	push	{r4, lr}
 80001ea:	4c05      	ldr	r4, [pc, #20]	; (8000200 <__do_global_dtors_aux+0x18>)
 80001ec:	7823      	ldrb	r3, [r4, #0]
 80001ee:	b933      	cbnz	r3, 80001fe <__do_global_dtors_aux+0x16>
 80001f0:	4b04      	ldr	r3, [pc, #16]	; (8000204 <__do_global_dtors_aux+0x1c>)
 80001f2:	b113      	cbz	r3, 80001fa <__do_global_dtors_aux+0x12>
 80001f4:	4804      	ldr	r0, [pc, #16]	; (8000208 <__do_global_dtors_aux+0x20>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	2301      	movs	r3, #1
 80001fc:	7023      	strb	r3, [r4, #0]
 80001fe:	bd10      	pop	{r4, pc}
 8000200:	2000044c 	.word	0x2000044c
 8000204:	00000000 	.word	0x00000000
 8000208:	080266f4 	.word	0x080266f4

0800020c <frame_dummy>:
 800020c:	b508      	push	{r3, lr}
 800020e:	4b03      	ldr	r3, [pc, #12]	; (800021c <frame_dummy+0x10>)
 8000210:	b11b      	cbz	r3, 800021a <frame_dummy+0xe>
 8000212:	4903      	ldr	r1, [pc, #12]	; (8000220 <frame_dummy+0x14>)
 8000214:	4803      	ldr	r0, [pc, #12]	; (8000224 <frame_dummy+0x18>)
 8000216:	f3af 8000 	nop.w
 800021a:	bd08      	pop	{r3, pc}
 800021c:	00000000 	.word	0x00000000
 8000220:	20000450 	.word	0x20000450
 8000224:	080266f4 	.word	0x080266f4

08000228 <strcmp>:
 8000228:	f810 2b01 	ldrb.w	r2, [r0], #1
 800022c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000230:	2a01      	cmp	r2, #1
 8000232:	bf28      	it	cs
 8000234:	429a      	cmpcs	r2, r3
 8000236:	d0f7      	beq.n	8000228 <strcmp>
 8000238:	1ad0      	subs	r0, r2, r3
 800023a:	4770      	bx	lr

0800023c <strlen>:
 800023c:	4603      	mov	r3, r0
 800023e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000242:	2a00      	cmp	r2, #0
 8000244:	d1fb      	bne.n	800023e <strlen+0x2>
 8000246:	1a18      	subs	r0, r3, r0
 8000248:	3801      	subs	r0, #1
 800024a:	4770      	bx	lr

0800024c <__aeabi_drsub>:
 800024c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000250:	e002      	b.n	8000258 <__adddf3>
 8000252:	bf00      	nop

08000254 <__aeabi_dsub>:
 8000254:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000258 <__adddf3>:
 8000258:	b530      	push	{r4, r5, lr}
 800025a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800025e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000262:	ea94 0f05 	teq	r4, r5
 8000266:	bf08      	it	eq
 8000268:	ea90 0f02 	teqeq	r0, r2
 800026c:	bf1f      	itttt	ne
 800026e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000272:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000276:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800027a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800027e:	f000 80e2 	beq.w	8000446 <__adddf3+0x1ee>
 8000282:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000286:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800028a:	bfb8      	it	lt
 800028c:	426d      	neglt	r5, r5
 800028e:	dd0c      	ble.n	80002aa <__adddf3+0x52>
 8000290:	442c      	add	r4, r5
 8000292:	ea80 0202 	eor.w	r2, r0, r2
 8000296:	ea81 0303 	eor.w	r3, r1, r3
 800029a:	ea82 0000 	eor.w	r0, r2, r0
 800029e:	ea83 0101 	eor.w	r1, r3, r1
 80002a2:	ea80 0202 	eor.w	r2, r0, r2
 80002a6:	ea81 0303 	eor.w	r3, r1, r3
 80002aa:	2d36      	cmp	r5, #54	; 0x36
 80002ac:	bf88      	it	hi
 80002ae:	bd30      	pophi	{r4, r5, pc}
 80002b0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002b4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002b8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002bc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002c0:	d002      	beq.n	80002c8 <__adddf3+0x70>
 80002c2:	4240      	negs	r0, r0
 80002c4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002c8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002cc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002d0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002d4:	d002      	beq.n	80002dc <__adddf3+0x84>
 80002d6:	4252      	negs	r2, r2
 80002d8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002dc:	ea94 0f05 	teq	r4, r5
 80002e0:	f000 80a7 	beq.w	8000432 <__adddf3+0x1da>
 80002e4:	f1a4 0401 	sub.w	r4, r4, #1
 80002e8:	f1d5 0e20 	rsbs	lr, r5, #32
 80002ec:	db0d      	blt.n	800030a <__adddf3+0xb2>
 80002ee:	fa02 fc0e 	lsl.w	ip, r2, lr
 80002f2:	fa22 f205 	lsr.w	r2, r2, r5
 80002f6:	1880      	adds	r0, r0, r2
 80002f8:	f141 0100 	adc.w	r1, r1, #0
 80002fc:	fa03 f20e 	lsl.w	r2, r3, lr
 8000300:	1880      	adds	r0, r0, r2
 8000302:	fa43 f305 	asr.w	r3, r3, r5
 8000306:	4159      	adcs	r1, r3
 8000308:	e00e      	b.n	8000328 <__adddf3+0xd0>
 800030a:	f1a5 0520 	sub.w	r5, r5, #32
 800030e:	f10e 0e20 	add.w	lr, lr, #32
 8000312:	2a01      	cmp	r2, #1
 8000314:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000318:	bf28      	it	cs
 800031a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800031e:	fa43 f305 	asr.w	r3, r3, r5
 8000322:	18c0      	adds	r0, r0, r3
 8000324:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000328:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800032c:	d507      	bpl.n	800033e <__adddf3+0xe6>
 800032e:	f04f 0e00 	mov.w	lr, #0
 8000332:	f1dc 0c00 	rsbs	ip, ip, #0
 8000336:	eb7e 0000 	sbcs.w	r0, lr, r0
 800033a:	eb6e 0101 	sbc.w	r1, lr, r1
 800033e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000342:	d31b      	bcc.n	800037c <__adddf3+0x124>
 8000344:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000348:	d30c      	bcc.n	8000364 <__adddf3+0x10c>
 800034a:	0849      	lsrs	r1, r1, #1
 800034c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000350:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000354:	f104 0401 	add.w	r4, r4, #1
 8000358:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800035c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000360:	f080 809a 	bcs.w	8000498 <__adddf3+0x240>
 8000364:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000368:	bf08      	it	eq
 800036a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800036e:	f150 0000 	adcs.w	r0, r0, #0
 8000372:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000376:	ea41 0105 	orr.w	r1, r1, r5
 800037a:	bd30      	pop	{r4, r5, pc}
 800037c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000380:	4140      	adcs	r0, r0
 8000382:	eb41 0101 	adc.w	r1, r1, r1
 8000386:	3c01      	subs	r4, #1
 8000388:	bf28      	it	cs
 800038a:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800038e:	d2e9      	bcs.n	8000364 <__adddf3+0x10c>
 8000390:	f091 0f00 	teq	r1, #0
 8000394:	bf04      	itt	eq
 8000396:	4601      	moveq	r1, r0
 8000398:	2000      	moveq	r0, #0
 800039a:	fab1 f381 	clz	r3, r1
 800039e:	bf08      	it	eq
 80003a0:	3320      	addeq	r3, #32
 80003a2:	f1a3 030b 	sub.w	r3, r3, #11
 80003a6:	f1b3 0220 	subs.w	r2, r3, #32
 80003aa:	da0c      	bge.n	80003c6 <__adddf3+0x16e>
 80003ac:	320c      	adds	r2, #12
 80003ae:	dd08      	ble.n	80003c2 <__adddf3+0x16a>
 80003b0:	f102 0c14 	add.w	ip, r2, #20
 80003b4:	f1c2 020c 	rsb	r2, r2, #12
 80003b8:	fa01 f00c 	lsl.w	r0, r1, ip
 80003bc:	fa21 f102 	lsr.w	r1, r1, r2
 80003c0:	e00c      	b.n	80003dc <__adddf3+0x184>
 80003c2:	f102 0214 	add.w	r2, r2, #20
 80003c6:	bfd8      	it	le
 80003c8:	f1c2 0c20 	rsble	ip, r2, #32
 80003cc:	fa01 f102 	lsl.w	r1, r1, r2
 80003d0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003d4:	bfdc      	itt	le
 80003d6:	ea41 010c 	orrle.w	r1, r1, ip
 80003da:	4090      	lslle	r0, r2
 80003dc:	1ae4      	subs	r4, r4, r3
 80003de:	bfa2      	ittt	ge
 80003e0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003e4:	4329      	orrge	r1, r5
 80003e6:	bd30      	popge	{r4, r5, pc}
 80003e8:	ea6f 0404 	mvn.w	r4, r4
 80003ec:	3c1f      	subs	r4, #31
 80003ee:	da1c      	bge.n	800042a <__adddf3+0x1d2>
 80003f0:	340c      	adds	r4, #12
 80003f2:	dc0e      	bgt.n	8000412 <__adddf3+0x1ba>
 80003f4:	f104 0414 	add.w	r4, r4, #20
 80003f8:	f1c4 0220 	rsb	r2, r4, #32
 80003fc:	fa20 f004 	lsr.w	r0, r0, r4
 8000400:	fa01 f302 	lsl.w	r3, r1, r2
 8000404:	ea40 0003 	orr.w	r0, r0, r3
 8000408:	fa21 f304 	lsr.w	r3, r1, r4
 800040c:	ea45 0103 	orr.w	r1, r5, r3
 8000410:	bd30      	pop	{r4, r5, pc}
 8000412:	f1c4 040c 	rsb	r4, r4, #12
 8000416:	f1c4 0220 	rsb	r2, r4, #32
 800041a:	fa20 f002 	lsr.w	r0, r0, r2
 800041e:	fa01 f304 	lsl.w	r3, r1, r4
 8000422:	ea40 0003 	orr.w	r0, r0, r3
 8000426:	4629      	mov	r1, r5
 8000428:	bd30      	pop	{r4, r5, pc}
 800042a:	fa21 f004 	lsr.w	r0, r1, r4
 800042e:	4629      	mov	r1, r5
 8000430:	bd30      	pop	{r4, r5, pc}
 8000432:	f094 0f00 	teq	r4, #0
 8000436:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800043a:	bf06      	itte	eq
 800043c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000440:	3401      	addeq	r4, #1
 8000442:	3d01      	subne	r5, #1
 8000444:	e74e      	b.n	80002e4 <__adddf3+0x8c>
 8000446:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800044a:	bf18      	it	ne
 800044c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000450:	d029      	beq.n	80004a6 <__adddf3+0x24e>
 8000452:	ea94 0f05 	teq	r4, r5
 8000456:	bf08      	it	eq
 8000458:	ea90 0f02 	teqeq	r0, r2
 800045c:	d005      	beq.n	800046a <__adddf3+0x212>
 800045e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000462:	bf04      	itt	eq
 8000464:	4619      	moveq	r1, r3
 8000466:	4610      	moveq	r0, r2
 8000468:	bd30      	pop	{r4, r5, pc}
 800046a:	ea91 0f03 	teq	r1, r3
 800046e:	bf1e      	ittt	ne
 8000470:	2100      	movne	r1, #0
 8000472:	2000      	movne	r0, #0
 8000474:	bd30      	popne	{r4, r5, pc}
 8000476:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800047a:	d105      	bne.n	8000488 <__adddf3+0x230>
 800047c:	0040      	lsls	r0, r0, #1
 800047e:	4149      	adcs	r1, r1
 8000480:	bf28      	it	cs
 8000482:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000486:	bd30      	pop	{r4, r5, pc}
 8000488:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800048c:	bf3c      	itt	cc
 800048e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000492:	bd30      	popcc	{r4, r5, pc}
 8000494:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000498:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800049c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004a0:	f04f 0000 	mov.w	r0, #0
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004aa:	bf1a      	itte	ne
 80004ac:	4619      	movne	r1, r3
 80004ae:	4610      	movne	r0, r2
 80004b0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004b4:	bf1c      	itt	ne
 80004b6:	460b      	movne	r3, r1
 80004b8:	4602      	movne	r2, r0
 80004ba:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004be:	bf06      	itte	eq
 80004c0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004c4:	ea91 0f03 	teqeq	r1, r3
 80004c8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	bf00      	nop

080004d0 <__aeabi_ui2d>:
 80004d0:	f090 0f00 	teq	r0, #0
 80004d4:	bf04      	itt	eq
 80004d6:	2100      	moveq	r1, #0
 80004d8:	4770      	bxeq	lr
 80004da:	b530      	push	{r4, r5, lr}
 80004dc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004e0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004e4:	f04f 0500 	mov.w	r5, #0
 80004e8:	f04f 0100 	mov.w	r1, #0
 80004ec:	e750      	b.n	8000390 <__adddf3+0x138>
 80004ee:	bf00      	nop

080004f0 <__aeabi_i2d>:
 80004f0:	f090 0f00 	teq	r0, #0
 80004f4:	bf04      	itt	eq
 80004f6:	2100      	moveq	r1, #0
 80004f8:	4770      	bxeq	lr
 80004fa:	b530      	push	{r4, r5, lr}
 80004fc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000500:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000504:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000508:	bf48      	it	mi
 800050a:	4240      	negmi	r0, r0
 800050c:	f04f 0100 	mov.w	r1, #0
 8000510:	e73e      	b.n	8000390 <__adddf3+0x138>
 8000512:	bf00      	nop

08000514 <__aeabi_f2d>:
 8000514:	0042      	lsls	r2, r0, #1
 8000516:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800051a:	ea4f 0131 	mov.w	r1, r1, rrx
 800051e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000522:	bf1f      	itttt	ne
 8000524:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000528:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800052c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000530:	4770      	bxne	lr
 8000532:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8000536:	bf08      	it	eq
 8000538:	4770      	bxeq	lr
 800053a:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 800053e:	bf04      	itt	eq
 8000540:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000544:	4770      	bxeq	lr
 8000546:	b530      	push	{r4, r5, lr}
 8000548:	f44f 7460 	mov.w	r4, #896	; 0x380
 800054c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000550:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000554:	e71c      	b.n	8000390 <__adddf3+0x138>
 8000556:	bf00      	nop

08000558 <__aeabi_ul2d>:
 8000558:	ea50 0201 	orrs.w	r2, r0, r1
 800055c:	bf08      	it	eq
 800055e:	4770      	bxeq	lr
 8000560:	b530      	push	{r4, r5, lr}
 8000562:	f04f 0500 	mov.w	r5, #0
 8000566:	e00a      	b.n	800057e <__aeabi_l2d+0x16>

08000568 <__aeabi_l2d>:
 8000568:	ea50 0201 	orrs.w	r2, r0, r1
 800056c:	bf08      	it	eq
 800056e:	4770      	bxeq	lr
 8000570:	b530      	push	{r4, r5, lr}
 8000572:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000576:	d502      	bpl.n	800057e <__aeabi_l2d+0x16>
 8000578:	4240      	negs	r0, r0
 800057a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800057e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000582:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000586:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800058a:	f43f aed8 	beq.w	800033e <__adddf3+0xe6>
 800058e:	f04f 0203 	mov.w	r2, #3
 8000592:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000596:	bf18      	it	ne
 8000598:	3203      	addne	r2, #3
 800059a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800059e:	bf18      	it	ne
 80005a0:	3203      	addne	r2, #3
 80005a2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005a6:	f1c2 0320 	rsb	r3, r2, #32
 80005aa:	fa00 fc03 	lsl.w	ip, r0, r3
 80005ae:	fa20 f002 	lsr.w	r0, r0, r2
 80005b2:	fa01 fe03 	lsl.w	lr, r1, r3
 80005b6:	ea40 000e 	orr.w	r0, r0, lr
 80005ba:	fa21 f102 	lsr.w	r1, r1, r2
 80005be:	4414      	add	r4, r2
 80005c0:	e6bd      	b.n	800033e <__adddf3+0xe6>
 80005c2:	bf00      	nop

080005c4 <__aeabi_dmul>:
 80005c4:	b570      	push	{r4, r5, r6, lr}
 80005c6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005ca:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005ce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005d2:	bf1d      	ittte	ne
 80005d4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005d8:	ea94 0f0c 	teqne	r4, ip
 80005dc:	ea95 0f0c 	teqne	r5, ip
 80005e0:	f000 f8de 	bleq	80007a0 <__aeabi_dmul+0x1dc>
 80005e4:	442c      	add	r4, r5
 80005e6:	ea81 0603 	eor.w	r6, r1, r3
 80005ea:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80005ee:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80005f2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80005f6:	bf18      	it	ne
 80005f8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80005fc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000600:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000604:	d038      	beq.n	8000678 <__aeabi_dmul+0xb4>
 8000606:	fba0 ce02 	umull	ip, lr, r0, r2
 800060a:	f04f 0500 	mov.w	r5, #0
 800060e:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000612:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000616:	fbe0 e503 	umlal	lr, r5, r0, r3
 800061a:	f04f 0600 	mov.w	r6, #0
 800061e:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000622:	f09c 0f00 	teq	ip, #0
 8000626:	bf18      	it	ne
 8000628:	f04e 0e01 	orrne.w	lr, lr, #1
 800062c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000630:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000634:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000638:	d204      	bcs.n	8000644 <__aeabi_dmul+0x80>
 800063a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800063e:	416d      	adcs	r5, r5
 8000640:	eb46 0606 	adc.w	r6, r6, r6
 8000644:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000648:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800064c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000650:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000654:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000658:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800065c:	bf88      	it	hi
 800065e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000662:	d81e      	bhi.n	80006a2 <__aeabi_dmul+0xde>
 8000664:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000668:	bf08      	it	eq
 800066a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800066e:	f150 0000 	adcs.w	r0, r0, #0
 8000672:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000676:	bd70      	pop	{r4, r5, r6, pc}
 8000678:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800067c:	ea46 0101 	orr.w	r1, r6, r1
 8000680:	ea40 0002 	orr.w	r0, r0, r2
 8000684:	ea81 0103 	eor.w	r1, r1, r3
 8000688:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800068c:	bfc2      	ittt	gt
 800068e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000692:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000696:	bd70      	popgt	{r4, r5, r6, pc}
 8000698:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800069c:	f04f 0e00 	mov.w	lr, #0
 80006a0:	3c01      	subs	r4, #1
 80006a2:	f300 80ab 	bgt.w	80007fc <__aeabi_dmul+0x238>
 80006a6:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006aa:	bfde      	ittt	le
 80006ac:	2000      	movle	r0, #0
 80006ae:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006b2:	bd70      	pople	{r4, r5, r6, pc}
 80006b4:	f1c4 0400 	rsb	r4, r4, #0
 80006b8:	3c20      	subs	r4, #32
 80006ba:	da35      	bge.n	8000728 <__aeabi_dmul+0x164>
 80006bc:	340c      	adds	r4, #12
 80006be:	dc1b      	bgt.n	80006f8 <__aeabi_dmul+0x134>
 80006c0:	f104 0414 	add.w	r4, r4, #20
 80006c4:	f1c4 0520 	rsb	r5, r4, #32
 80006c8:	fa00 f305 	lsl.w	r3, r0, r5
 80006cc:	fa20 f004 	lsr.w	r0, r0, r4
 80006d0:	fa01 f205 	lsl.w	r2, r1, r5
 80006d4:	ea40 0002 	orr.w	r0, r0, r2
 80006d8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80006dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80006e0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006e4:	fa21 f604 	lsr.w	r6, r1, r4
 80006e8:	eb42 0106 	adc.w	r1, r2, r6
 80006ec:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006f0:	bf08      	it	eq
 80006f2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006f6:	bd70      	pop	{r4, r5, r6, pc}
 80006f8:	f1c4 040c 	rsb	r4, r4, #12
 80006fc:	f1c4 0520 	rsb	r5, r4, #32
 8000700:	fa00 f304 	lsl.w	r3, r0, r4
 8000704:	fa20 f005 	lsr.w	r0, r0, r5
 8000708:	fa01 f204 	lsl.w	r2, r1, r4
 800070c:	ea40 0002 	orr.w	r0, r0, r2
 8000710:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000714:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000718:	f141 0100 	adc.w	r1, r1, #0
 800071c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000720:	bf08      	it	eq
 8000722:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000726:	bd70      	pop	{r4, r5, r6, pc}
 8000728:	f1c4 0520 	rsb	r5, r4, #32
 800072c:	fa00 f205 	lsl.w	r2, r0, r5
 8000730:	ea4e 0e02 	orr.w	lr, lr, r2
 8000734:	fa20 f304 	lsr.w	r3, r0, r4
 8000738:	fa01 f205 	lsl.w	r2, r1, r5
 800073c:	ea43 0302 	orr.w	r3, r3, r2
 8000740:	fa21 f004 	lsr.w	r0, r1, r4
 8000744:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000748:	fa21 f204 	lsr.w	r2, r1, r4
 800074c:	ea20 0002 	bic.w	r0, r0, r2
 8000750:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000754:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000758:	bf08      	it	eq
 800075a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800075e:	bd70      	pop	{r4, r5, r6, pc}
 8000760:	f094 0f00 	teq	r4, #0
 8000764:	d10f      	bne.n	8000786 <__aeabi_dmul+0x1c2>
 8000766:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800076a:	0040      	lsls	r0, r0, #1
 800076c:	eb41 0101 	adc.w	r1, r1, r1
 8000770:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000774:	bf08      	it	eq
 8000776:	3c01      	subeq	r4, #1
 8000778:	d0f7      	beq.n	800076a <__aeabi_dmul+0x1a6>
 800077a:	ea41 0106 	orr.w	r1, r1, r6
 800077e:	f095 0f00 	teq	r5, #0
 8000782:	bf18      	it	ne
 8000784:	4770      	bxne	lr
 8000786:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800078a:	0052      	lsls	r2, r2, #1
 800078c:	eb43 0303 	adc.w	r3, r3, r3
 8000790:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000794:	bf08      	it	eq
 8000796:	3d01      	subeq	r5, #1
 8000798:	d0f7      	beq.n	800078a <__aeabi_dmul+0x1c6>
 800079a:	ea43 0306 	orr.w	r3, r3, r6
 800079e:	4770      	bx	lr
 80007a0:	ea94 0f0c 	teq	r4, ip
 80007a4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007a8:	bf18      	it	ne
 80007aa:	ea95 0f0c 	teqne	r5, ip
 80007ae:	d00c      	beq.n	80007ca <__aeabi_dmul+0x206>
 80007b0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007b4:	bf18      	it	ne
 80007b6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007ba:	d1d1      	bne.n	8000760 <__aeabi_dmul+0x19c>
 80007bc:	ea81 0103 	eor.w	r1, r1, r3
 80007c0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007c4:	f04f 0000 	mov.w	r0, #0
 80007c8:	bd70      	pop	{r4, r5, r6, pc}
 80007ca:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007ce:	bf06      	itte	eq
 80007d0:	4610      	moveq	r0, r2
 80007d2:	4619      	moveq	r1, r3
 80007d4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007d8:	d019      	beq.n	800080e <__aeabi_dmul+0x24a>
 80007da:	ea94 0f0c 	teq	r4, ip
 80007de:	d102      	bne.n	80007e6 <__aeabi_dmul+0x222>
 80007e0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80007e4:	d113      	bne.n	800080e <__aeabi_dmul+0x24a>
 80007e6:	ea95 0f0c 	teq	r5, ip
 80007ea:	d105      	bne.n	80007f8 <__aeabi_dmul+0x234>
 80007ec:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80007f0:	bf1c      	itt	ne
 80007f2:	4610      	movne	r0, r2
 80007f4:	4619      	movne	r1, r3
 80007f6:	d10a      	bne.n	800080e <__aeabi_dmul+0x24a>
 80007f8:	ea81 0103 	eor.w	r1, r1, r3
 80007fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000800:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000804:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000808:	f04f 0000 	mov.w	r0, #0
 800080c:	bd70      	pop	{r4, r5, r6, pc}
 800080e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000812:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000816:	bd70      	pop	{r4, r5, r6, pc}

08000818 <__aeabi_ddiv>:
 8000818:	b570      	push	{r4, r5, r6, lr}
 800081a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800081e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000822:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000826:	bf1d      	ittte	ne
 8000828:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800082c:	ea94 0f0c 	teqne	r4, ip
 8000830:	ea95 0f0c 	teqne	r5, ip
 8000834:	f000 f8a7 	bleq	8000986 <__aeabi_ddiv+0x16e>
 8000838:	eba4 0405 	sub.w	r4, r4, r5
 800083c:	ea81 0e03 	eor.w	lr, r1, r3
 8000840:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000844:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000848:	f000 8088 	beq.w	800095c <__aeabi_ddiv+0x144>
 800084c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000850:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000854:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000858:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800085c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000860:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000864:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000868:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800086c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000870:	429d      	cmp	r5, r3
 8000872:	bf08      	it	eq
 8000874:	4296      	cmpeq	r6, r2
 8000876:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800087a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800087e:	d202      	bcs.n	8000886 <__aeabi_ddiv+0x6e>
 8000880:	085b      	lsrs	r3, r3, #1
 8000882:	ea4f 0232 	mov.w	r2, r2, rrx
 8000886:	1ab6      	subs	r6, r6, r2
 8000888:	eb65 0503 	sbc.w	r5, r5, r3
 800088c:	085b      	lsrs	r3, r3, #1
 800088e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000892:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000896:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800089a:	ebb6 0e02 	subs.w	lr, r6, r2
 800089e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008a2:	bf22      	ittt	cs
 80008a4:	1ab6      	subcs	r6, r6, r2
 80008a6:	4675      	movcs	r5, lr
 80008a8:	ea40 000c 	orrcs.w	r0, r0, ip
 80008ac:	085b      	lsrs	r3, r3, #1
 80008ae:	ea4f 0232 	mov.w	r2, r2, rrx
 80008b2:	ebb6 0e02 	subs.w	lr, r6, r2
 80008b6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ba:	bf22      	ittt	cs
 80008bc:	1ab6      	subcs	r6, r6, r2
 80008be:	4675      	movcs	r5, lr
 80008c0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008c4:	085b      	lsrs	r3, r3, #1
 80008c6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ca:	ebb6 0e02 	subs.w	lr, r6, r2
 80008ce:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008d2:	bf22      	ittt	cs
 80008d4:	1ab6      	subcs	r6, r6, r2
 80008d6:	4675      	movcs	r5, lr
 80008d8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	ebb6 0e02 	subs.w	lr, r6, r2
 80008e6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ea:	bf22      	ittt	cs
 80008ec:	1ab6      	subcs	r6, r6, r2
 80008ee:	4675      	movcs	r5, lr
 80008f0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80008f4:	ea55 0e06 	orrs.w	lr, r5, r6
 80008f8:	d018      	beq.n	800092c <__aeabi_ddiv+0x114>
 80008fa:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80008fe:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000902:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000906:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800090a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800090e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000912:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000916:	d1c0      	bne.n	800089a <__aeabi_ddiv+0x82>
 8000918:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800091c:	d10b      	bne.n	8000936 <__aeabi_ddiv+0x11e>
 800091e:	ea41 0100 	orr.w	r1, r1, r0
 8000922:	f04f 0000 	mov.w	r0, #0
 8000926:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800092a:	e7b6      	b.n	800089a <__aeabi_ddiv+0x82>
 800092c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000930:	bf04      	itt	eq
 8000932:	4301      	orreq	r1, r0
 8000934:	2000      	moveq	r0, #0
 8000936:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800093a:	bf88      	it	hi
 800093c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000940:	f63f aeaf 	bhi.w	80006a2 <__aeabi_dmul+0xde>
 8000944:	ebb5 0c03 	subs.w	ip, r5, r3
 8000948:	bf04      	itt	eq
 800094a:	ebb6 0c02 	subseq.w	ip, r6, r2
 800094e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000952:	f150 0000 	adcs.w	r0, r0, #0
 8000956:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800095a:	bd70      	pop	{r4, r5, r6, pc}
 800095c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000960:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000964:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000968:	bfc2      	ittt	gt
 800096a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800096e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000972:	bd70      	popgt	{r4, r5, r6, pc}
 8000974:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000978:	f04f 0e00 	mov.w	lr, #0
 800097c:	3c01      	subs	r4, #1
 800097e:	e690      	b.n	80006a2 <__aeabi_dmul+0xde>
 8000980:	ea45 0e06 	orr.w	lr, r5, r6
 8000984:	e68d      	b.n	80006a2 <__aeabi_dmul+0xde>
 8000986:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800098a:	ea94 0f0c 	teq	r4, ip
 800098e:	bf08      	it	eq
 8000990:	ea95 0f0c 	teqeq	r5, ip
 8000994:	f43f af3b 	beq.w	800080e <__aeabi_dmul+0x24a>
 8000998:	ea94 0f0c 	teq	r4, ip
 800099c:	d10a      	bne.n	80009b4 <__aeabi_ddiv+0x19c>
 800099e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009a2:	f47f af34 	bne.w	800080e <__aeabi_dmul+0x24a>
 80009a6:	ea95 0f0c 	teq	r5, ip
 80009aa:	f47f af25 	bne.w	80007f8 <__aeabi_dmul+0x234>
 80009ae:	4610      	mov	r0, r2
 80009b0:	4619      	mov	r1, r3
 80009b2:	e72c      	b.n	800080e <__aeabi_dmul+0x24a>
 80009b4:	ea95 0f0c 	teq	r5, ip
 80009b8:	d106      	bne.n	80009c8 <__aeabi_ddiv+0x1b0>
 80009ba:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009be:	f43f aefd 	beq.w	80007bc <__aeabi_dmul+0x1f8>
 80009c2:	4610      	mov	r0, r2
 80009c4:	4619      	mov	r1, r3
 80009c6:	e722      	b.n	800080e <__aeabi_dmul+0x24a>
 80009c8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009cc:	bf18      	it	ne
 80009ce:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009d2:	f47f aec5 	bne.w	8000760 <__aeabi_dmul+0x19c>
 80009d6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009da:	f47f af0d 	bne.w	80007f8 <__aeabi_dmul+0x234>
 80009de:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80009e2:	f47f aeeb 	bne.w	80007bc <__aeabi_dmul+0x1f8>
 80009e6:	e712      	b.n	800080e <__aeabi_dmul+0x24a>

080009e8 <__gedf2>:
 80009e8:	f04f 3cff 	mov.w	ip, #4294967295
 80009ec:	e006      	b.n	80009fc <__cmpdf2+0x4>
 80009ee:	bf00      	nop

080009f0 <__ledf2>:
 80009f0:	f04f 0c01 	mov.w	ip, #1
 80009f4:	e002      	b.n	80009fc <__cmpdf2+0x4>
 80009f6:	bf00      	nop

080009f8 <__cmpdf2>:
 80009f8:	f04f 0c01 	mov.w	ip, #1
 80009fc:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a00:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a04:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a08:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a0c:	bf18      	it	ne
 8000a0e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a12:	d01b      	beq.n	8000a4c <__cmpdf2+0x54>
 8000a14:	b001      	add	sp, #4
 8000a16:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a1a:	bf0c      	ite	eq
 8000a1c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a20:	ea91 0f03 	teqne	r1, r3
 8000a24:	bf02      	ittt	eq
 8000a26:	ea90 0f02 	teqeq	r0, r2
 8000a2a:	2000      	moveq	r0, #0
 8000a2c:	4770      	bxeq	lr
 8000a2e:	f110 0f00 	cmn.w	r0, #0
 8000a32:	ea91 0f03 	teq	r1, r3
 8000a36:	bf58      	it	pl
 8000a38:	4299      	cmppl	r1, r3
 8000a3a:	bf08      	it	eq
 8000a3c:	4290      	cmpeq	r0, r2
 8000a3e:	bf2c      	ite	cs
 8000a40:	17d8      	asrcs	r0, r3, #31
 8000a42:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a46:	f040 0001 	orr.w	r0, r0, #1
 8000a4a:	4770      	bx	lr
 8000a4c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a54:	d102      	bne.n	8000a5c <__cmpdf2+0x64>
 8000a56:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000a5a:	d107      	bne.n	8000a6c <__cmpdf2+0x74>
 8000a5c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a64:	d1d6      	bne.n	8000a14 <__cmpdf2+0x1c>
 8000a66:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000a6a:	d0d3      	beq.n	8000a14 <__cmpdf2+0x1c>
 8000a6c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000a70:	4770      	bx	lr
 8000a72:	bf00      	nop

08000a74 <__aeabi_cdrcmple>:
 8000a74:	4684      	mov	ip, r0
 8000a76:	4610      	mov	r0, r2
 8000a78:	4662      	mov	r2, ip
 8000a7a:	468c      	mov	ip, r1
 8000a7c:	4619      	mov	r1, r3
 8000a7e:	4663      	mov	r3, ip
 8000a80:	e000      	b.n	8000a84 <__aeabi_cdcmpeq>
 8000a82:	bf00      	nop

08000a84 <__aeabi_cdcmpeq>:
 8000a84:	b501      	push	{r0, lr}
 8000a86:	f7ff ffb7 	bl	80009f8 <__cmpdf2>
 8000a8a:	2800      	cmp	r0, #0
 8000a8c:	bf48      	it	mi
 8000a8e:	f110 0f00 	cmnmi.w	r0, #0
 8000a92:	bd01      	pop	{r0, pc}

08000a94 <__aeabi_dcmpeq>:
 8000a94:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000a98:	f7ff fff4 	bl	8000a84 <__aeabi_cdcmpeq>
 8000a9c:	bf0c      	ite	eq
 8000a9e:	2001      	moveq	r0, #1
 8000aa0:	2000      	movne	r0, #0
 8000aa2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000aa6:	bf00      	nop

08000aa8 <__aeabi_dcmplt>:
 8000aa8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000aac:	f7ff ffea 	bl	8000a84 <__aeabi_cdcmpeq>
 8000ab0:	bf34      	ite	cc
 8000ab2:	2001      	movcc	r0, #1
 8000ab4:	2000      	movcs	r0, #0
 8000ab6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000aba:	bf00      	nop

08000abc <__aeabi_dcmple>:
 8000abc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ac0:	f7ff ffe0 	bl	8000a84 <__aeabi_cdcmpeq>
 8000ac4:	bf94      	ite	ls
 8000ac6:	2001      	movls	r0, #1
 8000ac8:	2000      	movhi	r0, #0
 8000aca:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ace:	bf00      	nop

08000ad0 <__aeabi_dcmpge>:
 8000ad0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ad4:	f7ff ffce 	bl	8000a74 <__aeabi_cdrcmple>
 8000ad8:	bf94      	ite	ls
 8000ada:	2001      	movls	r0, #1
 8000adc:	2000      	movhi	r0, #0
 8000ade:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ae2:	bf00      	nop

08000ae4 <__aeabi_dcmpgt>:
 8000ae4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ae8:	f7ff ffc4 	bl	8000a74 <__aeabi_cdrcmple>
 8000aec:	bf34      	ite	cc
 8000aee:	2001      	movcc	r0, #1
 8000af0:	2000      	movcs	r0, #0
 8000af2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000af6:	bf00      	nop

08000af8 <__aeabi_d2f>:
 8000af8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000afc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000b00:	bf24      	itt	cs
 8000b02:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000b06:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000b0a:	d90d      	bls.n	8000b28 <__aeabi_d2f+0x30>
 8000b0c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000b10:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000b14:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000b18:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000b1c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000b20:	bf08      	it	eq
 8000b22:	f020 0001 	biceq.w	r0, r0, #1
 8000b26:	4770      	bx	lr
 8000b28:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000b2c:	d121      	bne.n	8000b72 <__aeabi_d2f+0x7a>
 8000b2e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000b32:	bfbc      	itt	lt
 8000b34:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000b38:	4770      	bxlt	lr
 8000b3a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b3e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000b42:	f1c2 0218 	rsb	r2, r2, #24
 8000b46:	f1c2 0c20 	rsb	ip, r2, #32
 8000b4a:	fa10 f30c 	lsls.w	r3, r0, ip
 8000b4e:	fa20 f002 	lsr.w	r0, r0, r2
 8000b52:	bf18      	it	ne
 8000b54:	f040 0001 	orrne.w	r0, r0, #1
 8000b58:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b5c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000b60:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000b64:	ea40 000c 	orr.w	r0, r0, ip
 8000b68:	fa23 f302 	lsr.w	r3, r3, r2
 8000b6c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000b70:	e7cc      	b.n	8000b0c <__aeabi_d2f+0x14>
 8000b72:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b76:	d107      	bne.n	8000b88 <__aeabi_d2f+0x90>
 8000b78:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b7c:	bf1e      	ittt	ne
 8000b7e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b82:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b86:	4770      	bxne	lr
 8000b88:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b8c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b90:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b94:	4770      	bx	lr
 8000b96:	bf00      	nop

08000b98 <__aeabi_frsub>:
 8000b98:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000b9c:	e002      	b.n	8000ba4 <__addsf3>
 8000b9e:	bf00      	nop

08000ba0 <__aeabi_fsub>:
 8000ba0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000ba4 <__addsf3>:
 8000ba4:	0042      	lsls	r2, r0, #1
 8000ba6:	bf1f      	itttt	ne
 8000ba8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000bac:	ea92 0f03 	teqne	r2, r3
 8000bb0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000bb4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000bb8:	d06a      	beq.n	8000c90 <__addsf3+0xec>
 8000bba:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000bbe:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000bc2:	bfc1      	itttt	gt
 8000bc4:	18d2      	addgt	r2, r2, r3
 8000bc6:	4041      	eorgt	r1, r0
 8000bc8:	4048      	eorgt	r0, r1
 8000bca:	4041      	eorgt	r1, r0
 8000bcc:	bfb8      	it	lt
 8000bce:	425b      	neglt	r3, r3
 8000bd0:	2b19      	cmp	r3, #25
 8000bd2:	bf88      	it	hi
 8000bd4:	4770      	bxhi	lr
 8000bd6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000bda:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000bde:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000be2:	bf18      	it	ne
 8000be4:	4240      	negne	r0, r0
 8000be6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000bea:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000bee:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000bf2:	bf18      	it	ne
 8000bf4:	4249      	negne	r1, r1
 8000bf6:	ea92 0f03 	teq	r2, r3
 8000bfa:	d03f      	beq.n	8000c7c <__addsf3+0xd8>
 8000bfc:	f1a2 0201 	sub.w	r2, r2, #1
 8000c00:	fa41 fc03 	asr.w	ip, r1, r3
 8000c04:	eb10 000c 	adds.w	r0, r0, ip
 8000c08:	f1c3 0320 	rsb	r3, r3, #32
 8000c0c:	fa01 f103 	lsl.w	r1, r1, r3
 8000c10:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c14:	d502      	bpl.n	8000c1c <__addsf3+0x78>
 8000c16:	4249      	negs	r1, r1
 8000c18:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000c1c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000c20:	d313      	bcc.n	8000c4a <__addsf3+0xa6>
 8000c22:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c26:	d306      	bcc.n	8000c36 <__addsf3+0x92>
 8000c28:	0840      	lsrs	r0, r0, #1
 8000c2a:	ea4f 0131 	mov.w	r1, r1, rrx
 8000c2e:	f102 0201 	add.w	r2, r2, #1
 8000c32:	2afe      	cmp	r2, #254	; 0xfe
 8000c34:	d251      	bcs.n	8000cda <__addsf3+0x136>
 8000c36:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000c3a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000c3e:	bf08      	it	eq
 8000c40:	f020 0001 	biceq.w	r0, r0, #1
 8000c44:	ea40 0003 	orr.w	r0, r0, r3
 8000c48:	4770      	bx	lr
 8000c4a:	0049      	lsls	r1, r1, #1
 8000c4c:	eb40 0000 	adc.w	r0, r0, r0
 8000c50:	3a01      	subs	r2, #1
 8000c52:	bf28      	it	cs
 8000c54:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000c58:	d2ed      	bcs.n	8000c36 <__addsf3+0x92>
 8000c5a:	fab0 fc80 	clz	ip, r0
 8000c5e:	f1ac 0c08 	sub.w	ip, ip, #8
 8000c62:	ebb2 020c 	subs.w	r2, r2, ip
 8000c66:	fa00 f00c 	lsl.w	r0, r0, ip
 8000c6a:	bfaa      	itet	ge
 8000c6c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000c70:	4252      	neglt	r2, r2
 8000c72:	4318      	orrge	r0, r3
 8000c74:	bfbc      	itt	lt
 8000c76:	40d0      	lsrlt	r0, r2
 8000c78:	4318      	orrlt	r0, r3
 8000c7a:	4770      	bx	lr
 8000c7c:	f092 0f00 	teq	r2, #0
 8000c80:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000c84:	bf06      	itte	eq
 8000c86:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000c8a:	3201      	addeq	r2, #1
 8000c8c:	3b01      	subne	r3, #1
 8000c8e:	e7b5      	b.n	8000bfc <__addsf3+0x58>
 8000c90:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000c94:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000c98:	bf18      	it	ne
 8000c9a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c9e:	d021      	beq.n	8000ce4 <__addsf3+0x140>
 8000ca0:	ea92 0f03 	teq	r2, r3
 8000ca4:	d004      	beq.n	8000cb0 <__addsf3+0x10c>
 8000ca6:	f092 0f00 	teq	r2, #0
 8000caa:	bf08      	it	eq
 8000cac:	4608      	moveq	r0, r1
 8000cae:	4770      	bx	lr
 8000cb0:	ea90 0f01 	teq	r0, r1
 8000cb4:	bf1c      	itt	ne
 8000cb6:	2000      	movne	r0, #0
 8000cb8:	4770      	bxne	lr
 8000cba:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000cbe:	d104      	bne.n	8000cca <__addsf3+0x126>
 8000cc0:	0040      	lsls	r0, r0, #1
 8000cc2:	bf28      	it	cs
 8000cc4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000cc8:	4770      	bx	lr
 8000cca:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000cce:	bf3c      	itt	cc
 8000cd0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000cd4:	4770      	bxcc	lr
 8000cd6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000cda:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000cde:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ce2:	4770      	bx	lr
 8000ce4:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000ce8:	bf16      	itet	ne
 8000cea:	4608      	movne	r0, r1
 8000cec:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000cf0:	4601      	movne	r1, r0
 8000cf2:	0242      	lsls	r2, r0, #9
 8000cf4:	bf06      	itte	eq
 8000cf6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000cfa:	ea90 0f01 	teqeq	r0, r1
 8000cfe:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000d02:	4770      	bx	lr

08000d04 <__aeabi_ui2f>:
 8000d04:	f04f 0300 	mov.w	r3, #0
 8000d08:	e004      	b.n	8000d14 <__aeabi_i2f+0x8>
 8000d0a:	bf00      	nop

08000d0c <__aeabi_i2f>:
 8000d0c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000d10:	bf48      	it	mi
 8000d12:	4240      	negmi	r0, r0
 8000d14:	ea5f 0c00 	movs.w	ip, r0
 8000d18:	bf08      	it	eq
 8000d1a:	4770      	bxeq	lr
 8000d1c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000d20:	4601      	mov	r1, r0
 8000d22:	f04f 0000 	mov.w	r0, #0
 8000d26:	e01c      	b.n	8000d62 <__aeabi_l2f+0x2a>

08000d28 <__aeabi_ul2f>:
 8000d28:	ea50 0201 	orrs.w	r2, r0, r1
 8000d2c:	bf08      	it	eq
 8000d2e:	4770      	bxeq	lr
 8000d30:	f04f 0300 	mov.w	r3, #0
 8000d34:	e00a      	b.n	8000d4c <__aeabi_l2f+0x14>
 8000d36:	bf00      	nop

08000d38 <__aeabi_l2f>:
 8000d38:	ea50 0201 	orrs.w	r2, r0, r1
 8000d3c:	bf08      	it	eq
 8000d3e:	4770      	bxeq	lr
 8000d40:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000d44:	d502      	bpl.n	8000d4c <__aeabi_l2f+0x14>
 8000d46:	4240      	negs	r0, r0
 8000d48:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d4c:	ea5f 0c01 	movs.w	ip, r1
 8000d50:	bf02      	ittt	eq
 8000d52:	4684      	moveq	ip, r0
 8000d54:	4601      	moveq	r1, r0
 8000d56:	2000      	moveq	r0, #0
 8000d58:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000d5c:	bf08      	it	eq
 8000d5e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000d62:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000d66:	fabc f28c 	clz	r2, ip
 8000d6a:	3a08      	subs	r2, #8
 8000d6c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000d70:	db10      	blt.n	8000d94 <__aeabi_l2f+0x5c>
 8000d72:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d76:	4463      	add	r3, ip
 8000d78:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d7c:	f1c2 0220 	rsb	r2, r2, #32
 8000d80:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000d84:	fa20 f202 	lsr.w	r2, r0, r2
 8000d88:	eb43 0002 	adc.w	r0, r3, r2
 8000d8c:	bf08      	it	eq
 8000d8e:	f020 0001 	biceq.w	r0, r0, #1
 8000d92:	4770      	bx	lr
 8000d94:	f102 0220 	add.w	r2, r2, #32
 8000d98:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d9c:	f1c2 0220 	rsb	r2, r2, #32
 8000da0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000da4:	fa21 f202 	lsr.w	r2, r1, r2
 8000da8:	eb43 0002 	adc.w	r0, r3, r2
 8000dac:	bf08      	it	eq
 8000dae:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000db2:	4770      	bx	lr

08000db4 <__aeabi_fmul>:
 8000db4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000db8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000dbc:	bf1e      	ittt	ne
 8000dbe:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000dc2:	ea92 0f0c 	teqne	r2, ip
 8000dc6:	ea93 0f0c 	teqne	r3, ip
 8000dca:	d06f      	beq.n	8000eac <__aeabi_fmul+0xf8>
 8000dcc:	441a      	add	r2, r3
 8000dce:	ea80 0c01 	eor.w	ip, r0, r1
 8000dd2:	0240      	lsls	r0, r0, #9
 8000dd4:	bf18      	it	ne
 8000dd6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000dda:	d01e      	beq.n	8000e1a <__aeabi_fmul+0x66>
 8000ddc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000de0:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000de4:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000de8:	fba0 3101 	umull	r3, r1, r0, r1
 8000dec:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000df0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000df4:	bf3e      	ittt	cc
 8000df6:	0049      	lslcc	r1, r1, #1
 8000df8:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000dfc:	005b      	lslcc	r3, r3, #1
 8000dfe:	ea40 0001 	orr.w	r0, r0, r1
 8000e02:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000e06:	2afd      	cmp	r2, #253	; 0xfd
 8000e08:	d81d      	bhi.n	8000e46 <__aeabi_fmul+0x92>
 8000e0a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000e0e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000e12:	bf08      	it	eq
 8000e14:	f020 0001 	biceq.w	r0, r0, #1
 8000e18:	4770      	bx	lr
 8000e1a:	f090 0f00 	teq	r0, #0
 8000e1e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000e22:	bf08      	it	eq
 8000e24:	0249      	lsleq	r1, r1, #9
 8000e26:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000e2a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000e2e:	3a7f      	subs	r2, #127	; 0x7f
 8000e30:	bfc2      	ittt	gt
 8000e32:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000e36:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000e3a:	4770      	bxgt	lr
 8000e3c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000e40:	f04f 0300 	mov.w	r3, #0
 8000e44:	3a01      	subs	r2, #1
 8000e46:	dc5d      	bgt.n	8000f04 <__aeabi_fmul+0x150>
 8000e48:	f112 0f19 	cmn.w	r2, #25
 8000e4c:	bfdc      	itt	le
 8000e4e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000e52:	4770      	bxle	lr
 8000e54:	f1c2 0200 	rsb	r2, r2, #0
 8000e58:	0041      	lsls	r1, r0, #1
 8000e5a:	fa21 f102 	lsr.w	r1, r1, r2
 8000e5e:	f1c2 0220 	rsb	r2, r2, #32
 8000e62:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e66:	ea5f 0031 	movs.w	r0, r1, rrx
 8000e6a:	f140 0000 	adc.w	r0, r0, #0
 8000e6e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000e72:	bf08      	it	eq
 8000e74:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e78:	4770      	bx	lr
 8000e7a:	f092 0f00 	teq	r2, #0
 8000e7e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000e82:	bf02      	ittt	eq
 8000e84:	0040      	lsleq	r0, r0, #1
 8000e86:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000e8a:	3a01      	subeq	r2, #1
 8000e8c:	d0f9      	beq.n	8000e82 <__aeabi_fmul+0xce>
 8000e8e:	ea40 000c 	orr.w	r0, r0, ip
 8000e92:	f093 0f00 	teq	r3, #0
 8000e96:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000e9a:	bf02      	ittt	eq
 8000e9c:	0049      	lsleq	r1, r1, #1
 8000e9e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000ea2:	3b01      	subeq	r3, #1
 8000ea4:	d0f9      	beq.n	8000e9a <__aeabi_fmul+0xe6>
 8000ea6:	ea41 010c 	orr.w	r1, r1, ip
 8000eaa:	e78f      	b.n	8000dcc <__aeabi_fmul+0x18>
 8000eac:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000eb0:	ea92 0f0c 	teq	r2, ip
 8000eb4:	bf18      	it	ne
 8000eb6:	ea93 0f0c 	teqne	r3, ip
 8000eba:	d00a      	beq.n	8000ed2 <__aeabi_fmul+0x11e>
 8000ebc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000ec0:	bf18      	it	ne
 8000ec2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000ec6:	d1d8      	bne.n	8000e7a <__aeabi_fmul+0xc6>
 8000ec8:	ea80 0001 	eor.w	r0, r0, r1
 8000ecc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000ed0:	4770      	bx	lr
 8000ed2:	f090 0f00 	teq	r0, #0
 8000ed6:	bf17      	itett	ne
 8000ed8:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000edc:	4608      	moveq	r0, r1
 8000ede:	f091 0f00 	teqne	r1, #0
 8000ee2:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000ee6:	d014      	beq.n	8000f12 <__aeabi_fmul+0x15e>
 8000ee8:	ea92 0f0c 	teq	r2, ip
 8000eec:	d101      	bne.n	8000ef2 <__aeabi_fmul+0x13e>
 8000eee:	0242      	lsls	r2, r0, #9
 8000ef0:	d10f      	bne.n	8000f12 <__aeabi_fmul+0x15e>
 8000ef2:	ea93 0f0c 	teq	r3, ip
 8000ef6:	d103      	bne.n	8000f00 <__aeabi_fmul+0x14c>
 8000ef8:	024b      	lsls	r3, r1, #9
 8000efa:	bf18      	it	ne
 8000efc:	4608      	movne	r0, r1
 8000efe:	d108      	bne.n	8000f12 <__aeabi_fmul+0x15e>
 8000f00:	ea80 0001 	eor.w	r0, r0, r1
 8000f04:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000f08:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f0c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f10:	4770      	bx	lr
 8000f12:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f16:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000f1a:	4770      	bx	lr

08000f1c <__aeabi_fdiv>:
 8000f1c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000f20:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000f24:	bf1e      	ittt	ne
 8000f26:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000f2a:	ea92 0f0c 	teqne	r2, ip
 8000f2e:	ea93 0f0c 	teqne	r3, ip
 8000f32:	d069      	beq.n	8001008 <__aeabi_fdiv+0xec>
 8000f34:	eba2 0203 	sub.w	r2, r2, r3
 8000f38:	ea80 0c01 	eor.w	ip, r0, r1
 8000f3c:	0249      	lsls	r1, r1, #9
 8000f3e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000f42:	d037      	beq.n	8000fb4 <__aeabi_fdiv+0x98>
 8000f44:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000f48:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000f4c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000f50:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000f54:	428b      	cmp	r3, r1
 8000f56:	bf38      	it	cc
 8000f58:	005b      	lslcc	r3, r3, #1
 8000f5a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000f5e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000f62:	428b      	cmp	r3, r1
 8000f64:	bf24      	itt	cs
 8000f66:	1a5b      	subcs	r3, r3, r1
 8000f68:	ea40 000c 	orrcs.w	r0, r0, ip
 8000f6c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000f70:	bf24      	itt	cs
 8000f72:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000f76:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000f7a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000f7e:	bf24      	itt	cs
 8000f80:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000f84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000f88:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000f8c:	bf24      	itt	cs
 8000f8e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000f92:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000f96:	011b      	lsls	r3, r3, #4
 8000f98:	bf18      	it	ne
 8000f9a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000f9e:	d1e0      	bne.n	8000f62 <__aeabi_fdiv+0x46>
 8000fa0:	2afd      	cmp	r2, #253	; 0xfd
 8000fa2:	f63f af50 	bhi.w	8000e46 <__aeabi_fmul+0x92>
 8000fa6:	428b      	cmp	r3, r1
 8000fa8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000fac:	bf08      	it	eq
 8000fae:	f020 0001 	biceq.w	r0, r0, #1
 8000fb2:	4770      	bx	lr
 8000fb4:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000fb8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000fbc:	327f      	adds	r2, #127	; 0x7f
 8000fbe:	bfc2      	ittt	gt
 8000fc0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000fc4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000fc8:	4770      	bxgt	lr
 8000fca:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000fce:	f04f 0300 	mov.w	r3, #0
 8000fd2:	3a01      	subs	r2, #1
 8000fd4:	e737      	b.n	8000e46 <__aeabi_fmul+0x92>
 8000fd6:	f092 0f00 	teq	r2, #0
 8000fda:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000fde:	bf02      	ittt	eq
 8000fe0:	0040      	lsleq	r0, r0, #1
 8000fe2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000fe6:	3a01      	subeq	r2, #1
 8000fe8:	d0f9      	beq.n	8000fde <__aeabi_fdiv+0xc2>
 8000fea:	ea40 000c 	orr.w	r0, r0, ip
 8000fee:	f093 0f00 	teq	r3, #0
 8000ff2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000ff6:	bf02      	ittt	eq
 8000ff8:	0049      	lsleq	r1, r1, #1
 8000ffa:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000ffe:	3b01      	subeq	r3, #1
 8001000:	d0f9      	beq.n	8000ff6 <__aeabi_fdiv+0xda>
 8001002:	ea41 010c 	orr.w	r1, r1, ip
 8001006:	e795      	b.n	8000f34 <__aeabi_fdiv+0x18>
 8001008:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 800100c:	ea92 0f0c 	teq	r2, ip
 8001010:	d108      	bne.n	8001024 <__aeabi_fdiv+0x108>
 8001012:	0242      	lsls	r2, r0, #9
 8001014:	f47f af7d 	bne.w	8000f12 <__aeabi_fmul+0x15e>
 8001018:	ea93 0f0c 	teq	r3, ip
 800101c:	f47f af70 	bne.w	8000f00 <__aeabi_fmul+0x14c>
 8001020:	4608      	mov	r0, r1
 8001022:	e776      	b.n	8000f12 <__aeabi_fmul+0x15e>
 8001024:	ea93 0f0c 	teq	r3, ip
 8001028:	d104      	bne.n	8001034 <__aeabi_fdiv+0x118>
 800102a:	024b      	lsls	r3, r1, #9
 800102c:	f43f af4c 	beq.w	8000ec8 <__aeabi_fmul+0x114>
 8001030:	4608      	mov	r0, r1
 8001032:	e76e      	b.n	8000f12 <__aeabi_fmul+0x15e>
 8001034:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8001038:	bf18      	it	ne
 800103a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 800103e:	d1ca      	bne.n	8000fd6 <__aeabi_fdiv+0xba>
 8001040:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8001044:	f47f af5c 	bne.w	8000f00 <__aeabi_fmul+0x14c>
 8001048:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 800104c:	f47f af3c 	bne.w	8000ec8 <__aeabi_fmul+0x114>
 8001050:	e75f      	b.n	8000f12 <__aeabi_fmul+0x15e>
 8001052:	bf00      	nop

08001054 <__gesf2>:
 8001054:	f04f 3cff 	mov.w	ip, #4294967295
 8001058:	e006      	b.n	8001068 <__cmpsf2+0x4>
 800105a:	bf00      	nop

0800105c <__lesf2>:
 800105c:	f04f 0c01 	mov.w	ip, #1
 8001060:	e002      	b.n	8001068 <__cmpsf2+0x4>
 8001062:	bf00      	nop

08001064 <__cmpsf2>:
 8001064:	f04f 0c01 	mov.w	ip, #1
 8001068:	f84d cd04 	str.w	ip, [sp, #-4]!
 800106c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8001070:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001074:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001078:	bf18      	it	ne
 800107a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800107e:	d011      	beq.n	80010a4 <__cmpsf2+0x40>
 8001080:	b001      	add	sp, #4
 8001082:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8001086:	bf18      	it	ne
 8001088:	ea90 0f01 	teqne	r0, r1
 800108c:	bf58      	it	pl
 800108e:	ebb2 0003 	subspl.w	r0, r2, r3
 8001092:	bf88      	it	hi
 8001094:	17c8      	asrhi	r0, r1, #31
 8001096:	bf38      	it	cc
 8001098:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 800109c:	bf18      	it	ne
 800109e:	f040 0001 	orrne.w	r0, r0, #1
 80010a2:	4770      	bx	lr
 80010a4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80010a8:	d102      	bne.n	80010b0 <__cmpsf2+0x4c>
 80010aa:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80010ae:	d105      	bne.n	80010bc <__cmpsf2+0x58>
 80010b0:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80010b4:	d1e4      	bne.n	8001080 <__cmpsf2+0x1c>
 80010b6:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80010ba:	d0e1      	beq.n	8001080 <__cmpsf2+0x1c>
 80010bc:	f85d 0b04 	ldr.w	r0, [sp], #4
 80010c0:	4770      	bx	lr
 80010c2:	bf00      	nop

080010c4 <__aeabi_cfrcmple>:
 80010c4:	4684      	mov	ip, r0
 80010c6:	4608      	mov	r0, r1
 80010c8:	4661      	mov	r1, ip
 80010ca:	e7ff      	b.n	80010cc <__aeabi_cfcmpeq>

080010cc <__aeabi_cfcmpeq>:
 80010cc:	b50f      	push	{r0, r1, r2, r3, lr}
 80010ce:	f7ff ffc9 	bl	8001064 <__cmpsf2>
 80010d2:	2800      	cmp	r0, #0
 80010d4:	bf48      	it	mi
 80010d6:	f110 0f00 	cmnmi.w	r0, #0
 80010da:	bd0f      	pop	{r0, r1, r2, r3, pc}

080010dc <__aeabi_fcmpeq>:
 80010dc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010e0:	f7ff fff4 	bl	80010cc <__aeabi_cfcmpeq>
 80010e4:	bf0c      	ite	eq
 80010e6:	2001      	moveq	r0, #1
 80010e8:	2000      	movne	r0, #0
 80010ea:	f85d fb08 	ldr.w	pc, [sp], #8
 80010ee:	bf00      	nop

080010f0 <__aeabi_fcmplt>:
 80010f0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010f4:	f7ff ffea 	bl	80010cc <__aeabi_cfcmpeq>
 80010f8:	bf34      	ite	cc
 80010fa:	2001      	movcc	r0, #1
 80010fc:	2000      	movcs	r0, #0
 80010fe:	f85d fb08 	ldr.w	pc, [sp], #8
 8001102:	bf00      	nop

08001104 <__aeabi_fcmple>:
 8001104:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001108:	f7ff ffe0 	bl	80010cc <__aeabi_cfcmpeq>
 800110c:	bf94      	ite	ls
 800110e:	2001      	movls	r0, #1
 8001110:	2000      	movhi	r0, #0
 8001112:	f85d fb08 	ldr.w	pc, [sp], #8
 8001116:	bf00      	nop

08001118 <__aeabi_fcmpge>:
 8001118:	f84d ed08 	str.w	lr, [sp, #-8]!
 800111c:	f7ff ffd2 	bl	80010c4 <__aeabi_cfrcmple>
 8001120:	bf94      	ite	ls
 8001122:	2001      	movls	r0, #1
 8001124:	2000      	movhi	r0, #0
 8001126:	f85d fb08 	ldr.w	pc, [sp], #8
 800112a:	bf00      	nop

0800112c <__aeabi_fcmpgt>:
 800112c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001130:	f7ff ffc8 	bl	80010c4 <__aeabi_cfrcmple>
 8001134:	bf34      	ite	cc
 8001136:	2001      	movcc	r0, #1
 8001138:	2000      	movcs	r0, #0
 800113a:	f85d fb08 	ldr.w	pc, [sp], #8
 800113e:	bf00      	nop

08001140 <__aeabi_fcmpun>:
 8001140:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8001144:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001148:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 800114c:	d102      	bne.n	8001154 <__aeabi_fcmpun+0x14>
 800114e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8001152:	d108      	bne.n	8001166 <__aeabi_fcmpun+0x26>
 8001154:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001158:	d102      	bne.n	8001160 <__aeabi_fcmpun+0x20>
 800115a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 800115e:	d102      	bne.n	8001166 <__aeabi_fcmpun+0x26>
 8001160:	f04f 0000 	mov.w	r0, #0
 8001164:	4770      	bx	lr
 8001166:	f04f 0001 	mov.w	r0, #1
 800116a:	4770      	bx	lr

0800116c <__aeabi_f2iz>:
 800116c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8001170:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8001174:	d30f      	bcc.n	8001196 <__aeabi_f2iz+0x2a>
 8001176:	f04f 039e 	mov.w	r3, #158	; 0x9e
 800117a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 800117e:	d90d      	bls.n	800119c <__aeabi_f2iz+0x30>
 8001180:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8001184:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001188:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 800118c:	fa23 f002 	lsr.w	r0, r3, r2
 8001190:	bf18      	it	ne
 8001192:	4240      	negne	r0, r0
 8001194:	4770      	bx	lr
 8001196:	f04f 0000 	mov.w	r0, #0
 800119a:	4770      	bx	lr
 800119c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80011a0:	d101      	bne.n	80011a6 <__aeabi_f2iz+0x3a>
 80011a2:	0242      	lsls	r2, r0, #9
 80011a4:	d105      	bne.n	80011b2 <__aeabi_f2iz+0x46>
 80011a6:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80011aa:	bf08      	it	eq
 80011ac:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80011b0:	4770      	bx	lr
 80011b2:	f04f 0000 	mov.w	r0, #0
 80011b6:	4770      	bx	lr

080011b8 <__aeabi_f2uiz>:
 80011b8:	0042      	lsls	r2, r0, #1
 80011ba:	d20e      	bcs.n	80011da <__aeabi_f2uiz+0x22>
 80011bc:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80011c0:	d30b      	bcc.n	80011da <__aeabi_f2uiz+0x22>
 80011c2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80011c6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80011ca:	d409      	bmi.n	80011e0 <__aeabi_f2uiz+0x28>
 80011cc:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80011d0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80011d4:	fa23 f002 	lsr.w	r0, r3, r2
 80011d8:	4770      	bx	lr
 80011da:	f04f 0000 	mov.w	r0, #0
 80011de:	4770      	bx	lr
 80011e0:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80011e4:	d101      	bne.n	80011ea <__aeabi_f2uiz+0x32>
 80011e6:	0242      	lsls	r2, r0, #9
 80011e8:	d102      	bne.n	80011f0 <__aeabi_f2uiz+0x38>
 80011ea:	f04f 30ff 	mov.w	r0, #4294967295
 80011ee:	4770      	bx	lr
 80011f0:	f04f 0000 	mov.w	r0, #0
 80011f4:	4770      	bx	lr
 80011f6:	bf00      	nop

080011f8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80011f8:	b580      	push	{r7, lr}
 80011fa:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80011fc:	f000 fa94 	bl	8001728 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8001200:	f000 f807 	bl	8001212 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8001204:	f000 f874 	bl	80012f0 <MX_GPIO_Init>
  //MX_SDIO_SD_Init();
  MX_USART1_UART_Init();
 8001208:	f000 f848 	bl	800129c <MX_USART1_UART_Init>
  /* USER CODE BEGIN 2 */
  grbl_enter();
 800120c:	f00a fbf0 	bl	800b9f0 <grbl_enter>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8001210:	e7fe      	b.n	8001210 <main+0x18>

08001212 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001212:	b580      	push	{r7, lr}
 8001214:	b090      	sub	sp, #64	; 0x40
 8001216:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001218:	f107 0318 	add.w	r3, r7, #24
 800121c:	2228      	movs	r2, #40	; 0x28
 800121e:	2100      	movs	r1, #0
 8001220:	4618      	mov	r0, r3
 8001222:	f022 fcf8 	bl	8023c16 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001226:	1d3b      	adds	r3, r7, #4
 8001228:	2200      	movs	r2, #0
 800122a:	601a      	str	r2, [r3, #0]
 800122c:	605a      	str	r2, [r3, #4]
 800122e:	609a      	str	r2, [r3, #8]
 8001230:	60da      	str	r2, [r3, #12]
 8001232:	611a      	str	r2, [r3, #16]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001234:	2301      	movs	r3, #1
 8001236:	61bb      	str	r3, [r7, #24]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001238:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800123c:	61fb      	str	r3, [r7, #28]
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 800123e:	2300      	movs	r3, #0
 8001240:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8001242:	2301      	movs	r3, #1
 8001244:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001246:	2302      	movs	r3, #2
 8001248:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800124a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800124e:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8001250:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
 8001254:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001256:	f107 0318 	add.w	r3, r7, #24
 800125a:	4618      	mov	r0, r3
 800125c:	f000 fda0 	bl	8001da0 <HAL_RCC_OscConfig>
 8001260:	4603      	mov	r3, r0
 8001262:	2b00      	cmp	r3, #0
 8001264:	d001      	beq.n	800126a <SystemClock_Config+0x58>
  {
    Error_Handler();
 8001266:	f000 f8d7 	bl	8001418 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800126a:	230f      	movs	r3, #15
 800126c:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800126e:	2302      	movs	r3, #2
 8001270:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001272:	2300      	movs	r3, #0
 8001274:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8001276:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800127a:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800127c:	2300      	movs	r3, #0
 800127e:	617b      	str	r3, [r7, #20]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8001280:	1d3b      	adds	r3, r7, #4
 8001282:	2102      	movs	r1, #2
 8001284:	4618      	mov	r0, r3
 8001286:	f001 f80d 	bl	80022a4 <HAL_RCC_ClockConfig>
 800128a:	4603      	mov	r3, r0
 800128c:	2b00      	cmp	r3, #0
 800128e:	d001      	beq.n	8001294 <SystemClock_Config+0x82>
  {
    Error_Handler();
 8001290:	f000 f8c2 	bl	8001418 <Error_Handler>
  }
}
 8001294:	bf00      	nop
 8001296:	3740      	adds	r7, #64	; 0x40
 8001298:	46bd      	mov	sp, r7
 800129a:	bd80      	pop	{r7, pc}

0800129c <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 800129c:	b580      	push	{r7, lr}
 800129e:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 80012a0:	4b11      	ldr	r3, [pc, #68]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012a2:	4a12      	ldr	r2, [pc, #72]	; (80012ec <MX_USART1_UART_Init+0x50>)
 80012a4:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 80012a6:	4b10      	ldr	r3, [pc, #64]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012a8:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80012ac:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80012ae:	4b0e      	ldr	r3, [pc, #56]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012b0:	2200      	movs	r2, #0
 80012b2:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80012b4:	4b0c      	ldr	r3, [pc, #48]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012b6:	2200      	movs	r2, #0
 80012b8:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80012ba:	4b0b      	ldr	r3, [pc, #44]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012bc:	2200      	movs	r2, #0
 80012be:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80012c0:	4b09      	ldr	r3, [pc, #36]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012c2:	220c      	movs	r2, #12
 80012c4:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80012c6:	4b08      	ldr	r3, [pc, #32]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012c8:	2200      	movs	r2, #0
 80012ca:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80012cc:	4b06      	ldr	r3, [pc, #24]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012ce:	2200      	movs	r2, #0
 80012d0:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80012d2:	4805      	ldr	r0, [pc, #20]	; (80012e8 <MX_USART1_UART_Init+0x4c>)
 80012d4:	f001 f9f8 	bl	80026c8 <HAL_UART_Init>
 80012d8:	4603      	mov	r3, r0
 80012da:	2b00      	cmp	r3, #0
 80012dc:	d001      	beq.n	80012e2 <MX_USART1_UART_Init+0x46>
  {
    Error_Handler();
 80012de:	f000 f89b 	bl	8001418 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80012e2:	bf00      	nop
 80012e4:	bd80      	pop	{r7, pc}
 80012e6:	bf00      	nop
 80012e8:	20000468 	.word	0x20000468
 80012ec:	40013800 	.word	0x40013800

080012f0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80012f0:	b580      	push	{r7, lr}
 80012f2:	b088      	sub	sp, #32
 80012f4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80012f6:	f107 0310 	add.w	r3, r7, #16
 80012fa:	2200      	movs	r2, #0
 80012fc:	601a      	str	r2, [r3, #0]
 80012fe:	605a      	str	r2, [r3, #4]
 8001300:	609a      	str	r2, [r3, #8]
 8001302:	60da      	str	r2, [r3, #12]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8001304:	4b3f      	ldr	r3, [pc, #252]	; (8001404 <MX_GPIO_Init+0x114>)
 8001306:	699b      	ldr	r3, [r3, #24]
 8001308:	4a3e      	ldr	r2, [pc, #248]	; (8001404 <MX_GPIO_Init+0x114>)
 800130a:	f043 0320 	orr.w	r3, r3, #32
 800130e:	6193      	str	r3, [r2, #24]
 8001310:	4b3c      	ldr	r3, [pc, #240]	; (8001404 <MX_GPIO_Init+0x114>)
 8001312:	699b      	ldr	r3, [r3, #24]
 8001314:	f003 0320 	and.w	r3, r3, #32
 8001318:	60fb      	str	r3, [r7, #12]
 800131a:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800131c:	4b39      	ldr	r3, [pc, #228]	; (8001404 <MX_GPIO_Init+0x114>)
 800131e:	699b      	ldr	r3, [r3, #24]
 8001320:	4a38      	ldr	r2, [pc, #224]	; (8001404 <MX_GPIO_Init+0x114>)
 8001322:	f043 0310 	orr.w	r3, r3, #16
 8001326:	6193      	str	r3, [r2, #24]
 8001328:	4b36      	ldr	r3, [pc, #216]	; (8001404 <MX_GPIO_Init+0x114>)
 800132a:	699b      	ldr	r3, [r3, #24]
 800132c:	f003 0310 	and.w	r3, r3, #16
 8001330:	60bb      	str	r3, [r7, #8]
 8001332:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001334:	4b33      	ldr	r3, [pc, #204]	; (8001404 <MX_GPIO_Init+0x114>)
 8001336:	699b      	ldr	r3, [r3, #24]
 8001338:	4a32      	ldr	r2, [pc, #200]	; (8001404 <MX_GPIO_Init+0x114>)
 800133a:	f043 0304 	orr.w	r3, r3, #4
 800133e:	6193      	str	r3, [r2, #24]
 8001340:	4b30      	ldr	r3, [pc, #192]	; (8001404 <MX_GPIO_Init+0x114>)
 8001342:	699b      	ldr	r3, [r3, #24]
 8001344:	f003 0304 	and.w	r3, r3, #4
 8001348:	607b      	str	r3, [r7, #4]
 800134a:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800134c:	4b2d      	ldr	r3, [pc, #180]	; (8001404 <MX_GPIO_Init+0x114>)
 800134e:	699b      	ldr	r3, [r3, #24]
 8001350:	4a2c      	ldr	r2, [pc, #176]	; (8001404 <MX_GPIO_Init+0x114>)
 8001352:	f043 0308 	orr.w	r3, r3, #8
 8001356:	6193      	str	r3, [r2, #24]
 8001358:	4b2a      	ldr	r3, [pc, #168]	; (8001404 <MX_GPIO_Init+0x114>)
 800135a:	699b      	ldr	r3, [r3, #24]
 800135c:	f003 0308 	and.w	r3, r3, #8
 8001360:	603b      	str	r3, [r7, #0]
 8001362:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);
 8001364:	2200      	movs	r2, #0
 8001366:	210c      	movs	r1, #12
 8001368:	4827      	ldr	r0, [pc, #156]	; (8001408 <MX_GPIO_Init+0x118>)
 800136a:	f000 fd01 	bl	8001d70 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_4|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9, GPIO_PIN_RESET);
 800136e:	2200      	movs	r2, #0
 8001370:	f44f 7164 	mov.w	r1, #912	; 0x390
 8001374:	4825      	ldr	r0, [pc, #148]	; (800140c <MX_GPIO_Init+0x11c>)
 8001376:	f000 fcfb 	bl	8001d70 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PC2 PC3 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 800137a:	230c      	movs	r3, #12
 800137c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800137e:	2301      	movs	r3, #1
 8001380:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001382:	2300      	movs	r3, #0
 8001384:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001386:	2302      	movs	r3, #2
 8001388:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800138a:	f107 0310 	add.w	r3, r7, #16
 800138e:	4619      	mov	r1, r3
 8001390:	481d      	ldr	r0, [pc, #116]	; (8001408 <MX_GPIO_Init+0x118>)
 8001392:	f000 fb59 	bl	8001a48 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA4 PA5 PA6 PA7 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8001396:	23f0      	movs	r3, #240	; 0xf0
 8001398:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800139a:	2300      	movs	r3, #0
 800139c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800139e:	2300      	movs	r3, #0
 80013a0:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80013a2:	f107 0310 	add.w	r3, r7, #16
 80013a6:	4619      	mov	r1, r3
 80013a8:	4819      	ldr	r0, [pc, #100]	; (8001410 <MX_GPIO_Init+0x120>)
 80013aa:	f000 fb4d 	bl	8001a48 <HAL_GPIO_Init>

  /*Configure GPIO pins : PC4 PC5 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 80013ae:	2330      	movs	r3, #48	; 0x30
 80013b0:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80013b2:	2300      	movs	r3, #0
 80013b4:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80013b6:	2300      	movs	r3, #0
 80013b8:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80013ba:	f107 0310 	add.w	r3, r7, #16
 80013be:	4619      	mov	r1, r3
 80013c0:	4811      	ldr	r0, [pc, #68]	; (8001408 <MX_GPIO_Init+0x118>)
 80013c2:	f000 fb41 	bl	8001a48 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB3 PB5 PB6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5|GPIO_PIN_6;
 80013c6:	2368      	movs	r3, #104	; 0x68
 80013c8:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80013ca:	4b12      	ldr	r3, [pc, #72]	; (8001414 <MX_GPIO_Init+0x124>)
 80013cc:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80013ce:	2300      	movs	r3, #0
 80013d0:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80013d2:	f107 0310 	add.w	r3, r7, #16
 80013d6:	4619      	mov	r1, r3
 80013d8:	480c      	ldr	r0, [pc, #48]	; (800140c <MX_GPIO_Init+0x11c>)
 80013da:	f000 fb35 	bl	8001a48 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB4 PB7 PB8 PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9;
 80013de:	f44f 7364 	mov.w	r3, #912	; 0x390
 80013e2:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80013e4:	2301      	movs	r3, #1
 80013e6:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80013e8:	2300      	movs	r3, #0
 80013ea:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80013ec:	2302      	movs	r3, #2
 80013ee:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80013f0:	f107 0310 	add.w	r3, r7, #16
 80013f4:	4619      	mov	r1, r3
 80013f6:	4805      	ldr	r0, [pc, #20]	; (800140c <MX_GPIO_Init+0x11c>)
 80013f8:	f000 fb26 	bl	8001a48 <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 80013fc:	bf00      	nop
 80013fe:	3720      	adds	r7, #32
 8001400:	46bd      	mov	sp, r7
 8001402:	bd80      	pop	{r7, pc}
 8001404:	40021000 	.word	0x40021000
 8001408:	40011000 	.word	0x40011000
 800140c:	40010c00 	.word	0x40010c00
 8001410:	40010800 	.word	0x40010800
 8001414:	10110000 	.word	0x10110000

08001418 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8001418:	b480      	push	{r7}
 800141a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800141c:	b672      	cpsid	i
}
 800141e:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001420:	e7fe      	b.n	8001420 <Error_Handler+0x8>
	...

08001424 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001424:	b480      	push	{r7}
 8001426:	b083      	sub	sp, #12
 8001428:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 800142a:	4b0e      	ldr	r3, [pc, #56]	; (8001464 <HAL_MspInit+0x40>)
 800142c:	699b      	ldr	r3, [r3, #24]
 800142e:	4a0d      	ldr	r2, [pc, #52]	; (8001464 <HAL_MspInit+0x40>)
 8001430:	f043 0301 	orr.w	r3, r3, #1
 8001434:	6193      	str	r3, [r2, #24]
 8001436:	4b0b      	ldr	r3, [pc, #44]	; (8001464 <HAL_MspInit+0x40>)
 8001438:	699b      	ldr	r3, [r3, #24]
 800143a:	f003 0301 	and.w	r3, r3, #1
 800143e:	607b      	str	r3, [r7, #4]
 8001440:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001442:	4b08      	ldr	r3, [pc, #32]	; (8001464 <HAL_MspInit+0x40>)
 8001444:	69db      	ldr	r3, [r3, #28]
 8001446:	4a07      	ldr	r2, [pc, #28]	; (8001464 <HAL_MspInit+0x40>)
 8001448:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800144c:	61d3      	str	r3, [r2, #28]
 800144e:	4b05      	ldr	r3, [pc, #20]	; (8001464 <HAL_MspInit+0x40>)
 8001450:	69db      	ldr	r3, [r3, #28]
 8001452:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001456:	603b      	str	r3, [r7, #0]
 8001458:	683b      	ldr	r3, [r7, #0]
  //__HAL_AFIO_REMAP_SWJ_DISABLE();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800145a:	bf00      	nop
 800145c:	370c      	adds	r7, #12
 800145e:	46bd      	mov	sp, r7
 8001460:	bc80      	pop	{r7}
 8001462:	4770      	bx	lr
 8001464:	40021000 	.word	0x40021000

08001468 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001468:	b580      	push	{r7, lr}
 800146a:	b088      	sub	sp, #32
 800146c:	af00      	add	r7, sp, #0
 800146e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001470:	f107 0310 	add.w	r3, r7, #16
 8001474:	2200      	movs	r2, #0
 8001476:	601a      	str	r2, [r3, #0]
 8001478:	605a      	str	r2, [r3, #4]
 800147a:	609a      	str	r2, [r3, #8]
 800147c:	60da      	str	r2, [r3, #12]
  if(huart->Instance==USART1)
 800147e:	687b      	ldr	r3, [r7, #4]
 8001480:	681b      	ldr	r3, [r3, #0]
 8001482:	4a1c      	ldr	r2, [pc, #112]	; (80014f4 <HAL_UART_MspInit+0x8c>)
 8001484:	4293      	cmp	r3, r2
 8001486:	d131      	bne.n	80014ec <HAL_UART_MspInit+0x84>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8001488:	4b1b      	ldr	r3, [pc, #108]	; (80014f8 <HAL_UART_MspInit+0x90>)
 800148a:	699b      	ldr	r3, [r3, #24]
 800148c:	4a1a      	ldr	r2, [pc, #104]	; (80014f8 <HAL_UART_MspInit+0x90>)
 800148e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001492:	6193      	str	r3, [r2, #24]
 8001494:	4b18      	ldr	r3, [pc, #96]	; (80014f8 <HAL_UART_MspInit+0x90>)
 8001496:	699b      	ldr	r3, [r3, #24]
 8001498:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800149c:	60fb      	str	r3, [r7, #12]
 800149e:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80014a0:	4b15      	ldr	r3, [pc, #84]	; (80014f8 <HAL_UART_MspInit+0x90>)
 80014a2:	699b      	ldr	r3, [r3, #24]
 80014a4:	4a14      	ldr	r2, [pc, #80]	; (80014f8 <HAL_UART_MspInit+0x90>)
 80014a6:	f043 0304 	orr.w	r3, r3, #4
 80014aa:	6193      	str	r3, [r2, #24]
 80014ac:	4b12      	ldr	r3, [pc, #72]	; (80014f8 <HAL_UART_MspInit+0x90>)
 80014ae:	699b      	ldr	r3, [r3, #24]
 80014b0:	f003 0304 	and.w	r3, r3, #4
 80014b4:	60bb      	str	r3, [r7, #8]
 80014b6:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 80014b8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80014bc:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80014be:	2302      	movs	r3, #2
 80014c0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80014c2:	2303      	movs	r3, #3
 80014c4:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80014c6:	f107 0310 	add.w	r3, r7, #16
 80014ca:	4619      	mov	r1, r3
 80014cc:	480b      	ldr	r0, [pc, #44]	; (80014fc <HAL_UART_MspInit+0x94>)
 80014ce:	f000 fabb 	bl	8001a48 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 80014d2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80014d6:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80014d8:	2300      	movs	r3, #0
 80014da:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014dc:	2300      	movs	r3, #0
 80014de:	61bb      	str	r3, [r7, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80014e0:	f107 0310 	add.w	r3, r7, #16
 80014e4:	4619      	mov	r1, r3
 80014e6:	4805      	ldr	r0, [pc, #20]	; (80014fc <HAL_UART_MspInit+0x94>)
 80014e8:	f000 faae 	bl	8001a48 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 80014ec:	bf00      	nop
 80014ee:	3720      	adds	r7, #32
 80014f0:	46bd      	mov	sp, r7
 80014f2:	bd80      	pop	{r7, pc}
 80014f4:	40013800 	.word	0x40013800
 80014f8:	40021000 	.word	0x40021000
 80014fc:	40010800 	.word	0x40010800

08001500 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001500:	b480      	push	{r7}
 8001502:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001504:	e7fe      	b.n	8001504 <NMI_Handler+0x4>

08001506 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001506:	b480      	push	{r7}
 8001508:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800150a:	e7fe      	b.n	800150a <HardFault_Handler+0x4>

0800150c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800150c:	b480      	push	{r7}
 800150e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001510:	e7fe      	b.n	8001510 <MemManage_Handler+0x4>

08001512 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001512:	b480      	push	{r7}
 8001514:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001516:	e7fe      	b.n	8001516 <BusFault_Handler+0x4>

08001518 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001518:	b480      	push	{r7}
 800151a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800151c:	e7fe      	b.n	800151c <UsageFault_Handler+0x4>

0800151e <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800151e:	b480      	push	{r7}
 8001520:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8001522:	bf00      	nop
 8001524:	46bd      	mov	sp, r7
 8001526:	bc80      	pop	{r7}
 8001528:	4770      	bx	lr

0800152a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800152a:	b480      	push	{r7}
 800152c:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800152e:	bf00      	nop
 8001530:	46bd      	mov	sp, r7
 8001532:	bc80      	pop	{r7}
 8001534:	4770      	bx	lr

08001536 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001536:	b480      	push	{r7}
 8001538:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800153a:	bf00      	nop
 800153c:	46bd      	mov	sp, r7
 800153e:	bc80      	pop	{r7}
 8001540:	4770      	bx	lr

08001542 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001542:	b580      	push	{r7, lr}
 8001544:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001546:	f003 f927 	bl	8004798 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800154a:	bf00      	nop
 800154c:	bd80      	pop	{r7, pc}

0800154e <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 800154e:	b480      	push	{r7}
 8001550:	af00      	add	r7, sp, #0
  return 1;
 8001552:	2301      	movs	r3, #1
}
 8001554:	4618      	mov	r0, r3
 8001556:	46bd      	mov	sp, r7
 8001558:	bc80      	pop	{r7}
 800155a:	4770      	bx	lr

0800155c <_kill>:

int _kill(int pid, int sig)
{
 800155c:	b580      	push	{r7, lr}
 800155e:	b082      	sub	sp, #8
 8001560:	af00      	add	r7, sp, #0
 8001562:	6078      	str	r0, [r7, #4]
 8001564:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8001566:	f022 fc7d 	bl	8023e64 <__errno>
 800156a:	4603      	mov	r3, r0
 800156c:	2216      	movs	r2, #22
 800156e:	601a      	str	r2, [r3, #0]
  return -1;
 8001570:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001574:	4618      	mov	r0, r3
 8001576:	3708      	adds	r7, #8
 8001578:	46bd      	mov	sp, r7
 800157a:	bd80      	pop	{r7, pc}

0800157c <_exit>:

void _exit (int status)
{
 800157c:	b580      	push	{r7, lr}
 800157e:	b082      	sub	sp, #8
 8001580:	af00      	add	r7, sp, #0
 8001582:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 8001584:	f04f 31ff 	mov.w	r1, #4294967295
 8001588:	6878      	ldr	r0, [r7, #4]
 800158a:	f7ff ffe7 	bl	800155c <_kill>
  while (1) {}    /* Make sure we hang here */
 800158e:	e7fe      	b.n	800158e <_exit+0x12>

08001590 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8001590:	b580      	push	{r7, lr}
 8001592:	b086      	sub	sp, #24
 8001594:	af00      	add	r7, sp, #0
 8001596:	60f8      	str	r0, [r7, #12]
 8001598:	60b9      	str	r1, [r7, #8]
 800159a:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 800159c:	2300      	movs	r3, #0
 800159e:	617b      	str	r3, [r7, #20]
 80015a0:	e00a      	b.n	80015b8 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 80015a2:	f3af 8000 	nop.w
 80015a6:	4601      	mov	r1, r0
 80015a8:	68bb      	ldr	r3, [r7, #8]
 80015aa:	1c5a      	adds	r2, r3, #1
 80015ac:	60ba      	str	r2, [r7, #8]
 80015ae:	b2ca      	uxtb	r2, r1
 80015b0:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80015b2:	697b      	ldr	r3, [r7, #20]
 80015b4:	3301      	adds	r3, #1
 80015b6:	617b      	str	r3, [r7, #20]
 80015b8:	697a      	ldr	r2, [r7, #20]
 80015ba:	687b      	ldr	r3, [r7, #4]
 80015bc:	429a      	cmp	r2, r3
 80015be:	dbf0      	blt.n	80015a2 <_read+0x12>
  }

  return len;
 80015c0:	687b      	ldr	r3, [r7, #4]
}
 80015c2:	4618      	mov	r0, r3
 80015c4:	3718      	adds	r7, #24
 80015c6:	46bd      	mov	sp, r7
 80015c8:	bd80      	pop	{r7, pc}

080015ca <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80015ca:	b580      	push	{r7, lr}
 80015cc:	b086      	sub	sp, #24
 80015ce:	af00      	add	r7, sp, #0
 80015d0:	60f8      	str	r0, [r7, #12]
 80015d2:	60b9      	str	r1, [r7, #8]
 80015d4:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80015d6:	2300      	movs	r3, #0
 80015d8:	617b      	str	r3, [r7, #20]
 80015da:	e009      	b.n	80015f0 <_write+0x26>
  {
    __io_putchar(*ptr++);
 80015dc:	68bb      	ldr	r3, [r7, #8]
 80015de:	1c5a      	adds	r2, r3, #1
 80015e0:	60ba      	str	r2, [r7, #8]
 80015e2:	781b      	ldrb	r3, [r3, #0]
 80015e4:	4618      	mov	r0, r3
 80015e6:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80015ea:	697b      	ldr	r3, [r7, #20]
 80015ec:	3301      	adds	r3, #1
 80015ee:	617b      	str	r3, [r7, #20]
 80015f0:	697a      	ldr	r2, [r7, #20]
 80015f2:	687b      	ldr	r3, [r7, #4]
 80015f4:	429a      	cmp	r2, r3
 80015f6:	dbf1      	blt.n	80015dc <_write+0x12>
  }
  return len;
 80015f8:	687b      	ldr	r3, [r7, #4]
}
 80015fa:	4618      	mov	r0, r3
 80015fc:	3718      	adds	r7, #24
 80015fe:	46bd      	mov	sp, r7
 8001600:	bd80      	pop	{r7, pc}

08001602 <_close>:

int _close(int file)
{
 8001602:	b480      	push	{r7}
 8001604:	b083      	sub	sp, #12
 8001606:	af00      	add	r7, sp, #0
 8001608:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 800160a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800160e:	4618      	mov	r0, r3
 8001610:	370c      	adds	r7, #12
 8001612:	46bd      	mov	sp, r7
 8001614:	bc80      	pop	{r7}
 8001616:	4770      	bx	lr

08001618 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8001618:	b480      	push	{r7}
 800161a:	b083      	sub	sp, #12
 800161c:	af00      	add	r7, sp, #0
 800161e:	6078      	str	r0, [r7, #4]
 8001620:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8001622:	683b      	ldr	r3, [r7, #0]
 8001624:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001628:	605a      	str	r2, [r3, #4]
  return 0;
 800162a:	2300      	movs	r3, #0
}
 800162c:	4618      	mov	r0, r3
 800162e:	370c      	adds	r7, #12
 8001630:	46bd      	mov	sp, r7
 8001632:	bc80      	pop	{r7}
 8001634:	4770      	bx	lr

08001636 <_isatty>:

int _isatty(int file)
{
 8001636:	b480      	push	{r7}
 8001638:	b083      	sub	sp, #12
 800163a:	af00      	add	r7, sp, #0
 800163c:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 800163e:	2301      	movs	r3, #1
}
 8001640:	4618      	mov	r0, r3
 8001642:	370c      	adds	r7, #12
 8001644:	46bd      	mov	sp, r7
 8001646:	bc80      	pop	{r7}
 8001648:	4770      	bx	lr

0800164a <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800164a:	b480      	push	{r7}
 800164c:	b085      	sub	sp, #20
 800164e:	af00      	add	r7, sp, #0
 8001650:	60f8      	str	r0, [r7, #12]
 8001652:	60b9      	str	r1, [r7, #8]
 8001654:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 8001656:	2300      	movs	r3, #0
}
 8001658:	4618      	mov	r0, r3
 800165a:	3714      	adds	r7, #20
 800165c:	46bd      	mov	sp, r7
 800165e:	bc80      	pop	{r7}
 8001660:	4770      	bx	lr
	...

08001664 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001664:	b580      	push	{r7, lr}
 8001666:	b086      	sub	sp, #24
 8001668:	af00      	add	r7, sp, #0
 800166a:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800166c:	4a14      	ldr	r2, [pc, #80]	; (80016c0 <_sbrk+0x5c>)
 800166e:	4b15      	ldr	r3, [pc, #84]	; (80016c4 <_sbrk+0x60>)
 8001670:	1ad3      	subs	r3, r2, r3
 8001672:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001674:	697b      	ldr	r3, [r7, #20]
 8001676:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001678:	4b13      	ldr	r3, [pc, #76]	; (80016c8 <_sbrk+0x64>)
 800167a:	681b      	ldr	r3, [r3, #0]
 800167c:	2b00      	cmp	r3, #0
 800167e:	d102      	bne.n	8001686 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8001680:	4b11      	ldr	r3, [pc, #68]	; (80016c8 <_sbrk+0x64>)
 8001682:	4a12      	ldr	r2, [pc, #72]	; (80016cc <_sbrk+0x68>)
 8001684:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001686:	4b10      	ldr	r3, [pc, #64]	; (80016c8 <_sbrk+0x64>)
 8001688:	681a      	ldr	r2, [r3, #0]
 800168a:	687b      	ldr	r3, [r7, #4]
 800168c:	4413      	add	r3, r2
 800168e:	693a      	ldr	r2, [r7, #16]
 8001690:	429a      	cmp	r2, r3
 8001692:	d207      	bcs.n	80016a4 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8001694:	f022 fbe6 	bl	8023e64 <__errno>
 8001698:	4603      	mov	r3, r0
 800169a:	220c      	movs	r2, #12
 800169c:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 800169e:	f04f 33ff 	mov.w	r3, #4294967295
 80016a2:	e009      	b.n	80016b8 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80016a4:	4b08      	ldr	r3, [pc, #32]	; (80016c8 <_sbrk+0x64>)
 80016a6:	681b      	ldr	r3, [r3, #0]
 80016a8:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80016aa:	4b07      	ldr	r3, [pc, #28]	; (80016c8 <_sbrk+0x64>)
 80016ac:	681a      	ldr	r2, [r3, #0]
 80016ae:	687b      	ldr	r3, [r7, #4]
 80016b0:	4413      	add	r3, r2
 80016b2:	4a05      	ldr	r2, [pc, #20]	; (80016c8 <_sbrk+0x64>)
 80016b4:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80016b6:	68fb      	ldr	r3, [r7, #12]
}
 80016b8:	4618      	mov	r0, r3
 80016ba:	3718      	adds	r7, #24
 80016bc:	46bd      	mov	sp, r7
 80016be:	bd80      	pop	{r7, pc}
 80016c0:	20010000 	.word	0x20010000
 80016c4:	00000400 	.word	0x00000400
 80016c8:	200004ac 	.word	0x200004ac
 80016cc:	200022e8 	.word	0x200022e8

080016d0 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 80016d0:	b480      	push	{r7}
 80016d2:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 80016d4:	bf00      	nop
 80016d6:	46bd      	mov	sp, r7
 80016d8:	bc80      	pop	{r7}
 80016da:	4770      	bx	lr

080016dc <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Call the clock system initialization function.*/
    bl  SystemInit
 80016dc:	f7ff fff8 	bl	80016d0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80016e0:	480b      	ldr	r0, [pc, #44]	; (8001710 <LoopFillZerobss+0xe>)
  ldr r1, =_edata
 80016e2:	490c      	ldr	r1, [pc, #48]	; (8001714 <LoopFillZerobss+0x12>)
  ldr r2, =_sidata
 80016e4:	4a0c      	ldr	r2, [pc, #48]	; (8001718 <LoopFillZerobss+0x16>)
  movs r3, #0
 80016e6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80016e8:	e002      	b.n	80016f0 <LoopCopyDataInit>

080016ea <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80016ea:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80016ec:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80016ee:	3304      	adds	r3, #4

080016f0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80016f0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80016f2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80016f4:	d3f9      	bcc.n	80016ea <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80016f6:	4a09      	ldr	r2, [pc, #36]	; (800171c <LoopFillZerobss+0x1a>)
  ldr r4, =_ebss
 80016f8:	4c09      	ldr	r4, [pc, #36]	; (8001720 <LoopFillZerobss+0x1e>)
  movs r3, #0
 80016fa:	2300      	movs	r3, #0
  b LoopFillZerobss
 80016fc:	e001      	b.n	8001702 <LoopFillZerobss>

080016fe <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80016fe:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001700:	3204      	adds	r2, #4

08001702 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001702:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001704:	d3fb      	bcc.n	80016fe <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001706:	f022 fbb3 	bl	8023e70 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800170a:	f7ff fd75 	bl	80011f8 <main>
  bx lr
 800170e:	4770      	bx	lr
  ldr r0, =_sdata
 8001710:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001714:	2000044c 	.word	0x2000044c
  ldr r2, =_sidata
 8001718:	08033438 	.word	0x08033438
  ldr r2, =_sbss
 800171c:	2000044c 	.word	0x2000044c
  ldr r4, =_ebss
 8001720:	200022e8 	.word	0x200022e8

08001724 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001724:	e7fe      	b.n	8001724 <ADC1_2_IRQHandler>
	...

08001728 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001728:	b580      	push	{r7, lr}
 800172a:	af00      	add	r7, sp, #0
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800172c:	4b08      	ldr	r3, [pc, #32]	; (8001750 <HAL_Init+0x28>)
 800172e:	681b      	ldr	r3, [r3, #0]
 8001730:	4a07      	ldr	r2, [pc, #28]	; (8001750 <HAL_Init+0x28>)
 8001732:	f043 0310 	orr.w	r3, r3, #16
 8001736:	6013      	str	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001738:	2003      	movs	r0, #3
 800173a:	f000 f935 	bl	80019a8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800173e:	200f      	movs	r0, #15
 8001740:	f000 f808 	bl	8001754 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8001744:	f7ff fe6e 	bl	8001424 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001748:	2300      	movs	r3, #0
}
 800174a:	4618      	mov	r0, r3
 800174c:	bd80      	pop	{r7, pc}
 800174e:	bf00      	nop
 8001750:	40022000 	.word	0x40022000

08001754 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001754:	b580      	push	{r7, lr}
 8001756:	b082      	sub	sp, #8
 8001758:	af00      	add	r7, sp, #0
 800175a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800175c:	4b12      	ldr	r3, [pc, #72]	; (80017a8 <HAL_InitTick+0x54>)
 800175e:	681a      	ldr	r2, [r3, #0]
 8001760:	4b12      	ldr	r3, [pc, #72]	; (80017ac <HAL_InitTick+0x58>)
 8001762:	781b      	ldrb	r3, [r3, #0]
 8001764:	4619      	mov	r1, r3
 8001766:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800176a:	fbb3 f3f1 	udiv	r3, r3, r1
 800176e:	fbb2 f3f3 	udiv	r3, r2, r3
 8001772:	4618      	mov	r0, r3
 8001774:	f000 f95b 	bl	8001a2e <HAL_SYSTICK_Config>
 8001778:	4603      	mov	r3, r0
 800177a:	2b00      	cmp	r3, #0
 800177c:	d001      	beq.n	8001782 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800177e:	2301      	movs	r3, #1
 8001780:	e00e      	b.n	80017a0 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001782:	687b      	ldr	r3, [r7, #4]
 8001784:	2b0f      	cmp	r3, #15
 8001786:	d80a      	bhi.n	800179e <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001788:	2200      	movs	r2, #0
 800178a:	6879      	ldr	r1, [r7, #4]
 800178c:	f04f 30ff 	mov.w	r0, #4294967295
 8001790:	f000 f915 	bl	80019be <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8001794:	4a06      	ldr	r2, [pc, #24]	; (80017b0 <HAL_InitTick+0x5c>)
 8001796:	687b      	ldr	r3, [r7, #4]
 8001798:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800179a:	2300      	movs	r3, #0
 800179c:	e000      	b.n	80017a0 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800179e:	2301      	movs	r3, #1
}
 80017a0:	4618      	mov	r0, r3
 80017a2:	3708      	adds	r7, #8
 80017a4:	46bd      	mov	sp, r7
 80017a6:	bd80      	pop	{r7, pc}
 80017a8:	20000000 	.word	0x20000000
 80017ac:	20000008 	.word	0x20000008
 80017b0:	20000004 	.word	0x20000004

080017b4 <HAL_GetTick>:
  * @note  This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80017b4:	b480      	push	{r7}
 80017b6:	af00      	add	r7, sp, #0
  return uwTick;
 80017b8:	4b02      	ldr	r3, [pc, #8]	; (80017c4 <HAL_GetTick+0x10>)
 80017ba:	681b      	ldr	r3, [r3, #0]
}
 80017bc:	4618      	mov	r0, r3
 80017be:	46bd      	mov	sp, r7
 80017c0:	bc80      	pop	{r7}
 80017c2:	4770      	bx	lr
 80017c4:	200004b0 	.word	0x200004b0

080017c8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80017c8:	b480      	push	{r7}
 80017ca:	b085      	sub	sp, #20
 80017cc:	af00      	add	r7, sp, #0
 80017ce:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80017d0:	687b      	ldr	r3, [r7, #4]
 80017d2:	f003 0307 	and.w	r3, r3, #7
 80017d6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80017d8:	4b0c      	ldr	r3, [pc, #48]	; (800180c <__NVIC_SetPriorityGrouping+0x44>)
 80017da:	68db      	ldr	r3, [r3, #12]
 80017dc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80017de:	68ba      	ldr	r2, [r7, #8]
 80017e0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80017e4:	4013      	ands	r3, r2
 80017e6:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 80017e8:	68fb      	ldr	r3, [r7, #12]
 80017ea:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80017ec:	68bb      	ldr	r3, [r7, #8]
 80017ee:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80017f0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80017f4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80017f8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80017fa:	4a04      	ldr	r2, [pc, #16]	; (800180c <__NVIC_SetPriorityGrouping+0x44>)
 80017fc:	68bb      	ldr	r3, [r7, #8]
 80017fe:	60d3      	str	r3, [r2, #12]
}
 8001800:	bf00      	nop
 8001802:	3714      	adds	r7, #20
 8001804:	46bd      	mov	sp, r7
 8001806:	bc80      	pop	{r7}
 8001808:	4770      	bx	lr
 800180a:	bf00      	nop
 800180c:	e000ed00 	.word	0xe000ed00

08001810 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001810:	b480      	push	{r7}
 8001812:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001814:	4b04      	ldr	r3, [pc, #16]	; (8001828 <__NVIC_GetPriorityGrouping+0x18>)
 8001816:	68db      	ldr	r3, [r3, #12]
 8001818:	0a1b      	lsrs	r3, r3, #8
 800181a:	f003 0307 	and.w	r3, r3, #7
}
 800181e:	4618      	mov	r0, r3
 8001820:	46bd      	mov	sp, r7
 8001822:	bc80      	pop	{r7}
 8001824:	4770      	bx	lr
 8001826:	bf00      	nop
 8001828:	e000ed00 	.word	0xe000ed00

0800182c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800182c:	b480      	push	{r7}
 800182e:	b083      	sub	sp, #12
 8001830:	af00      	add	r7, sp, #0
 8001832:	4603      	mov	r3, r0
 8001834:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001836:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800183a:	2b00      	cmp	r3, #0
 800183c:	db0b      	blt.n	8001856 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800183e:	79fb      	ldrb	r3, [r7, #7]
 8001840:	f003 021f 	and.w	r2, r3, #31
 8001844:	4906      	ldr	r1, [pc, #24]	; (8001860 <__NVIC_EnableIRQ+0x34>)
 8001846:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800184a:	095b      	lsrs	r3, r3, #5
 800184c:	2001      	movs	r0, #1
 800184e:	fa00 f202 	lsl.w	r2, r0, r2
 8001852:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8001856:	bf00      	nop
 8001858:	370c      	adds	r7, #12
 800185a:	46bd      	mov	sp, r7
 800185c:	bc80      	pop	{r7}
 800185e:	4770      	bx	lr
 8001860:	e000e100 	.word	0xe000e100

08001864 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8001864:	b480      	push	{r7}
 8001866:	b083      	sub	sp, #12
 8001868:	af00      	add	r7, sp, #0
 800186a:	4603      	mov	r3, r0
 800186c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800186e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001872:	2b00      	cmp	r3, #0
 8001874:	db12      	blt.n	800189c <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001876:	79fb      	ldrb	r3, [r7, #7]
 8001878:	f003 021f 	and.w	r2, r3, #31
 800187c:	490a      	ldr	r1, [pc, #40]	; (80018a8 <__NVIC_DisableIRQ+0x44>)
 800187e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001882:	095b      	lsrs	r3, r3, #5
 8001884:	2001      	movs	r0, #1
 8001886:	fa00 f202 	lsl.w	r2, r0, r2
 800188a:	3320      	adds	r3, #32
 800188c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001890:	f3bf 8f4f 	dsb	sy
}
 8001894:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8001896:	f3bf 8f6f 	isb	sy
}
 800189a:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 800189c:	bf00      	nop
 800189e:	370c      	adds	r7, #12
 80018a0:	46bd      	mov	sp, r7
 80018a2:	bc80      	pop	{r7}
 80018a4:	4770      	bx	lr
 80018a6:	bf00      	nop
 80018a8:	e000e100 	.word	0xe000e100

080018ac <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80018ac:	b480      	push	{r7}
 80018ae:	b083      	sub	sp, #12
 80018b0:	af00      	add	r7, sp, #0
 80018b2:	4603      	mov	r3, r0
 80018b4:	6039      	str	r1, [r7, #0]
 80018b6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80018b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80018bc:	2b00      	cmp	r3, #0
 80018be:	db0a      	blt.n	80018d6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018c0:	683b      	ldr	r3, [r7, #0]
 80018c2:	b2da      	uxtb	r2, r3
 80018c4:	490c      	ldr	r1, [pc, #48]	; (80018f8 <__NVIC_SetPriority+0x4c>)
 80018c6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80018ca:	0112      	lsls	r2, r2, #4
 80018cc:	b2d2      	uxtb	r2, r2
 80018ce:	440b      	add	r3, r1
 80018d0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80018d4:	e00a      	b.n	80018ec <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018d6:	683b      	ldr	r3, [r7, #0]
 80018d8:	b2da      	uxtb	r2, r3
 80018da:	4908      	ldr	r1, [pc, #32]	; (80018fc <__NVIC_SetPriority+0x50>)
 80018dc:	79fb      	ldrb	r3, [r7, #7]
 80018de:	f003 030f 	and.w	r3, r3, #15
 80018e2:	3b04      	subs	r3, #4
 80018e4:	0112      	lsls	r2, r2, #4
 80018e6:	b2d2      	uxtb	r2, r2
 80018e8:	440b      	add	r3, r1
 80018ea:	761a      	strb	r2, [r3, #24]
}
 80018ec:	bf00      	nop
 80018ee:	370c      	adds	r7, #12
 80018f0:	46bd      	mov	sp, r7
 80018f2:	bc80      	pop	{r7}
 80018f4:	4770      	bx	lr
 80018f6:	bf00      	nop
 80018f8:	e000e100 	.word	0xe000e100
 80018fc:	e000ed00 	.word	0xe000ed00

08001900 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001900:	b480      	push	{r7}
 8001902:	b089      	sub	sp, #36	; 0x24
 8001904:	af00      	add	r7, sp, #0
 8001906:	60f8      	str	r0, [r7, #12]
 8001908:	60b9      	str	r1, [r7, #8]
 800190a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800190c:	68fb      	ldr	r3, [r7, #12]
 800190e:	f003 0307 	and.w	r3, r3, #7
 8001912:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001914:	69fb      	ldr	r3, [r7, #28]
 8001916:	f1c3 0307 	rsb	r3, r3, #7
 800191a:	2b04      	cmp	r3, #4
 800191c:	bf28      	it	cs
 800191e:	2304      	movcs	r3, #4
 8001920:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001922:	69fb      	ldr	r3, [r7, #28]
 8001924:	3304      	adds	r3, #4
 8001926:	2b06      	cmp	r3, #6
 8001928:	d902      	bls.n	8001930 <NVIC_EncodePriority+0x30>
 800192a:	69fb      	ldr	r3, [r7, #28]
 800192c:	3b03      	subs	r3, #3
 800192e:	e000      	b.n	8001932 <NVIC_EncodePriority+0x32>
 8001930:	2300      	movs	r3, #0
 8001932:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001934:	f04f 32ff 	mov.w	r2, #4294967295
 8001938:	69bb      	ldr	r3, [r7, #24]
 800193a:	fa02 f303 	lsl.w	r3, r2, r3
 800193e:	43da      	mvns	r2, r3
 8001940:	68bb      	ldr	r3, [r7, #8]
 8001942:	401a      	ands	r2, r3
 8001944:	697b      	ldr	r3, [r7, #20]
 8001946:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001948:	f04f 31ff 	mov.w	r1, #4294967295
 800194c:	697b      	ldr	r3, [r7, #20]
 800194e:	fa01 f303 	lsl.w	r3, r1, r3
 8001952:	43d9      	mvns	r1, r3
 8001954:	687b      	ldr	r3, [r7, #4]
 8001956:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001958:	4313      	orrs	r3, r2
         );
}
 800195a:	4618      	mov	r0, r3
 800195c:	3724      	adds	r7, #36	; 0x24
 800195e:	46bd      	mov	sp, r7
 8001960:	bc80      	pop	{r7}
 8001962:	4770      	bx	lr

08001964 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001964:	b580      	push	{r7, lr}
 8001966:	b082      	sub	sp, #8
 8001968:	af00      	add	r7, sp, #0
 800196a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800196c:	687b      	ldr	r3, [r7, #4]
 800196e:	3b01      	subs	r3, #1
 8001970:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8001974:	d301      	bcc.n	800197a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001976:	2301      	movs	r3, #1
 8001978:	e00f      	b.n	800199a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800197a:	4a0a      	ldr	r2, [pc, #40]	; (80019a4 <SysTick_Config+0x40>)
 800197c:	687b      	ldr	r3, [r7, #4]
 800197e:	3b01      	subs	r3, #1
 8001980:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8001982:	210f      	movs	r1, #15
 8001984:	f04f 30ff 	mov.w	r0, #4294967295
 8001988:	f7ff ff90 	bl	80018ac <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800198c:	4b05      	ldr	r3, [pc, #20]	; (80019a4 <SysTick_Config+0x40>)
 800198e:	2200      	movs	r2, #0
 8001990:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001992:	4b04      	ldr	r3, [pc, #16]	; (80019a4 <SysTick_Config+0x40>)
 8001994:	2207      	movs	r2, #7
 8001996:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001998:	2300      	movs	r3, #0
}
 800199a:	4618      	mov	r0, r3
 800199c:	3708      	adds	r7, #8
 800199e:	46bd      	mov	sp, r7
 80019a0:	bd80      	pop	{r7, pc}
 80019a2:	bf00      	nop
 80019a4:	e000e010 	.word	0xe000e010

080019a8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80019a8:	b580      	push	{r7, lr}
 80019aa:	b082      	sub	sp, #8
 80019ac:	af00      	add	r7, sp, #0
 80019ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80019b0:	6878      	ldr	r0, [r7, #4]
 80019b2:	f7ff ff09 	bl	80017c8 <__NVIC_SetPriorityGrouping>
}
 80019b6:	bf00      	nop
 80019b8:	3708      	adds	r7, #8
 80019ba:	46bd      	mov	sp, r7
 80019bc:	bd80      	pop	{r7, pc}

080019be <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80019be:	b580      	push	{r7, lr}
 80019c0:	b086      	sub	sp, #24
 80019c2:	af00      	add	r7, sp, #0
 80019c4:	4603      	mov	r3, r0
 80019c6:	60b9      	str	r1, [r7, #8]
 80019c8:	607a      	str	r2, [r7, #4]
 80019ca:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 80019cc:	2300      	movs	r3, #0
 80019ce:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 80019d0:	f7ff ff1e 	bl	8001810 <__NVIC_GetPriorityGrouping>
 80019d4:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80019d6:	687a      	ldr	r2, [r7, #4]
 80019d8:	68b9      	ldr	r1, [r7, #8]
 80019da:	6978      	ldr	r0, [r7, #20]
 80019dc:	f7ff ff90 	bl	8001900 <NVIC_EncodePriority>
 80019e0:	4602      	mov	r2, r0
 80019e2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80019e6:	4611      	mov	r1, r2
 80019e8:	4618      	mov	r0, r3
 80019ea:	f7ff ff5f 	bl	80018ac <__NVIC_SetPriority>
}
 80019ee:	bf00      	nop
 80019f0:	3718      	adds	r7, #24
 80019f2:	46bd      	mov	sp, r7
 80019f4:	bd80      	pop	{r7, pc}

080019f6 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f10xxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80019f6:	b580      	push	{r7, lr}
 80019f8:	b082      	sub	sp, #8
 80019fa:	af00      	add	r7, sp, #0
 80019fc:	4603      	mov	r3, r0
 80019fe:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8001a00:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001a04:	4618      	mov	r0, r3
 8001a06:	f7ff ff11 	bl	800182c <__NVIC_EnableIRQ>
}
 8001a0a:	bf00      	nop
 8001a0c:	3708      	adds	r7, #8
 8001a0e:	46bd      	mov	sp, r7
 8001a10:	bd80      	pop	{r7, pc}

08001a12 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f10xxx.h))  
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8001a12:	b580      	push	{r7, lr}
 8001a14:	b082      	sub	sp, #8
 8001a16:	af00      	add	r7, sp, #0
 8001a18:	4603      	mov	r3, r0
 8001a1a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8001a1c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001a20:	4618      	mov	r0, r3
 8001a22:	f7ff ff1f 	bl	8001864 <__NVIC_DisableIRQ>
}
 8001a26:	bf00      	nop
 8001a28:	3708      	adds	r7, #8
 8001a2a:	46bd      	mov	sp, r7
 8001a2c:	bd80      	pop	{r7, pc}

08001a2e <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8001a2e:	b580      	push	{r7, lr}
 8001a30:	b082      	sub	sp, #8
 8001a32:	af00      	add	r7, sp, #0
 8001a34:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8001a36:	6878      	ldr	r0, [r7, #4]
 8001a38:	f7ff ff94 	bl	8001964 <SysTick_Config>
 8001a3c:	4603      	mov	r3, r0
}
 8001a3e:	4618      	mov	r0, r3
 8001a40:	3708      	adds	r7, #8
 8001a42:	46bd      	mov	sp, r7
 8001a44:	bd80      	pop	{r7, pc}
	...

08001a48 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001a48:	b480      	push	{r7}
 8001a4a:	b08b      	sub	sp, #44	; 0x2c
 8001a4c:	af00      	add	r7, sp, #0
 8001a4e:	6078      	str	r0, [r7, #4]
 8001a50:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8001a52:	2300      	movs	r3, #0
 8001a54:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t ioposition;
  uint32_t iocurrent;
  uint32_t temp;
  uint32_t config = 0x00u;
 8001a56:	2300      	movs	r3, #0
 8001a58:	623b      	str	r3, [r7, #32]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001a5a:	e179      	b.n	8001d50 <HAL_GPIO_Init+0x308>
  {
    /* Get the IO position */
    ioposition = (0x01uL << position);
 8001a5c:	2201      	movs	r2, #1
 8001a5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001a60:	fa02 f303 	lsl.w	r3, r2, r3
 8001a64:	61fb      	str	r3, [r7, #28]

    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001a66:	683b      	ldr	r3, [r7, #0]
 8001a68:	681b      	ldr	r3, [r3, #0]
 8001a6a:	69fa      	ldr	r2, [r7, #28]
 8001a6c:	4013      	ands	r3, r2
 8001a6e:	61bb      	str	r3, [r7, #24]

    if (iocurrent == ioposition)
 8001a70:	69ba      	ldr	r2, [r7, #24]
 8001a72:	69fb      	ldr	r3, [r7, #28]
 8001a74:	429a      	cmp	r2, r3
 8001a76:	f040 8168 	bne.w	8001d4a <HAL_GPIO_Init+0x302>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 8001a7a:	683b      	ldr	r3, [r7, #0]
 8001a7c:	685b      	ldr	r3, [r3, #4]
 8001a7e:	4a96      	ldr	r2, [pc, #600]	; (8001cd8 <HAL_GPIO_Init+0x290>)
 8001a80:	4293      	cmp	r3, r2
 8001a82:	d05e      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
 8001a84:	4a94      	ldr	r2, [pc, #592]	; (8001cd8 <HAL_GPIO_Init+0x290>)
 8001a86:	4293      	cmp	r3, r2
 8001a88:	d875      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001a8a:	4a94      	ldr	r2, [pc, #592]	; (8001cdc <HAL_GPIO_Init+0x294>)
 8001a8c:	4293      	cmp	r3, r2
 8001a8e:	d058      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
 8001a90:	4a92      	ldr	r2, [pc, #584]	; (8001cdc <HAL_GPIO_Init+0x294>)
 8001a92:	4293      	cmp	r3, r2
 8001a94:	d86f      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001a96:	4a92      	ldr	r2, [pc, #584]	; (8001ce0 <HAL_GPIO_Init+0x298>)
 8001a98:	4293      	cmp	r3, r2
 8001a9a:	d052      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
 8001a9c:	4a90      	ldr	r2, [pc, #576]	; (8001ce0 <HAL_GPIO_Init+0x298>)
 8001a9e:	4293      	cmp	r3, r2
 8001aa0:	d869      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001aa2:	4a90      	ldr	r2, [pc, #576]	; (8001ce4 <HAL_GPIO_Init+0x29c>)
 8001aa4:	4293      	cmp	r3, r2
 8001aa6:	d04c      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
 8001aa8:	4a8e      	ldr	r2, [pc, #568]	; (8001ce4 <HAL_GPIO_Init+0x29c>)
 8001aaa:	4293      	cmp	r3, r2
 8001aac:	d863      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001aae:	4a8e      	ldr	r2, [pc, #568]	; (8001ce8 <HAL_GPIO_Init+0x2a0>)
 8001ab0:	4293      	cmp	r3, r2
 8001ab2:	d046      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
 8001ab4:	4a8c      	ldr	r2, [pc, #560]	; (8001ce8 <HAL_GPIO_Init+0x2a0>)
 8001ab6:	4293      	cmp	r3, r2
 8001ab8:	d85d      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001aba:	2b12      	cmp	r3, #18
 8001abc:	d82a      	bhi.n	8001b14 <HAL_GPIO_Init+0xcc>
 8001abe:	2b12      	cmp	r3, #18
 8001ac0:	d859      	bhi.n	8001b76 <HAL_GPIO_Init+0x12e>
 8001ac2:	a201      	add	r2, pc, #4	; (adr r2, 8001ac8 <HAL_GPIO_Init+0x80>)
 8001ac4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001ac8:	08001b43 	.word	0x08001b43
 8001acc:	08001b1d 	.word	0x08001b1d
 8001ad0:	08001b2f 	.word	0x08001b2f
 8001ad4:	08001b71 	.word	0x08001b71
 8001ad8:	08001b77 	.word	0x08001b77
 8001adc:	08001b77 	.word	0x08001b77
 8001ae0:	08001b77 	.word	0x08001b77
 8001ae4:	08001b77 	.word	0x08001b77
 8001ae8:	08001b77 	.word	0x08001b77
 8001aec:	08001b77 	.word	0x08001b77
 8001af0:	08001b77 	.word	0x08001b77
 8001af4:	08001b77 	.word	0x08001b77
 8001af8:	08001b77 	.word	0x08001b77
 8001afc:	08001b77 	.word	0x08001b77
 8001b00:	08001b77 	.word	0x08001b77
 8001b04:	08001b77 	.word	0x08001b77
 8001b08:	08001b77 	.word	0x08001b77
 8001b0c:	08001b25 	.word	0x08001b25
 8001b10:	08001b39 	.word	0x08001b39
 8001b14:	4a75      	ldr	r2, [pc, #468]	; (8001cec <HAL_GPIO_Init+0x2a4>)
 8001b16:	4293      	cmp	r3, r2
 8001b18:	d013      	beq.n	8001b42 <HAL_GPIO_Init+0xfa>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
          break;

        /* Parameters are checked with assert_param */
        default:
          break;
 8001b1a:	e02c      	b.n	8001b76 <HAL_GPIO_Init+0x12e>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8001b1c:	683b      	ldr	r3, [r7, #0]
 8001b1e:	68db      	ldr	r3, [r3, #12]
 8001b20:	623b      	str	r3, [r7, #32]
          break;
 8001b22:	e029      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001b24:	683b      	ldr	r3, [r7, #0]
 8001b26:	68db      	ldr	r3, [r3, #12]
 8001b28:	3304      	adds	r3, #4
 8001b2a:	623b      	str	r3, [r7, #32]
          break;
 8001b2c:	e024      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8001b2e:	683b      	ldr	r3, [r7, #0]
 8001b30:	68db      	ldr	r3, [r3, #12]
 8001b32:	3308      	adds	r3, #8
 8001b34:	623b      	str	r3, [r7, #32]
          break;
 8001b36:	e01f      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8001b38:	683b      	ldr	r3, [r7, #0]
 8001b3a:	68db      	ldr	r3, [r3, #12]
 8001b3c:	330c      	adds	r3, #12
 8001b3e:	623b      	str	r3, [r7, #32]
          break;
 8001b40:	e01a      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8001b42:	683b      	ldr	r3, [r7, #0]
 8001b44:	689b      	ldr	r3, [r3, #8]
 8001b46:	2b00      	cmp	r3, #0
 8001b48:	d102      	bne.n	8001b50 <HAL_GPIO_Init+0x108>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8001b4a:	2304      	movs	r3, #4
 8001b4c:	623b      	str	r3, [r7, #32]
          break;
 8001b4e:	e013      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001b50:	683b      	ldr	r3, [r7, #0]
 8001b52:	689b      	ldr	r3, [r3, #8]
 8001b54:	2b01      	cmp	r3, #1
 8001b56:	d105      	bne.n	8001b64 <HAL_GPIO_Init+0x11c>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001b58:	2308      	movs	r3, #8
 8001b5a:	623b      	str	r3, [r7, #32]
            GPIOx->BSRR = ioposition;
 8001b5c:	687b      	ldr	r3, [r7, #4]
 8001b5e:	69fa      	ldr	r2, [r7, #28]
 8001b60:	611a      	str	r2, [r3, #16]
          break;
 8001b62:	e009      	b.n	8001b78 <HAL_GPIO_Init+0x130>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001b64:	2308      	movs	r3, #8
 8001b66:	623b      	str	r3, [r7, #32]
            GPIOx->BRR = ioposition;
 8001b68:	687b      	ldr	r3, [r7, #4]
 8001b6a:	69fa      	ldr	r2, [r7, #28]
 8001b6c:	615a      	str	r2, [r3, #20]
          break;
 8001b6e:	e003      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8001b70:	2300      	movs	r3, #0
 8001b72:	623b      	str	r3, [r7, #32]
          break;
 8001b74:	e000      	b.n	8001b78 <HAL_GPIO_Init+0x130>
          break;
 8001b76:	bf00      	nop
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001b78:	69bb      	ldr	r3, [r7, #24]
 8001b7a:	2bff      	cmp	r3, #255	; 0xff
 8001b7c:	d801      	bhi.n	8001b82 <HAL_GPIO_Init+0x13a>
 8001b7e:	687b      	ldr	r3, [r7, #4]
 8001b80:	e001      	b.n	8001b86 <HAL_GPIO_Init+0x13e>
 8001b82:	687b      	ldr	r3, [r7, #4]
 8001b84:	3304      	adds	r3, #4
 8001b86:	617b      	str	r3, [r7, #20]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8001b88:	69bb      	ldr	r3, [r7, #24]
 8001b8a:	2bff      	cmp	r3, #255	; 0xff
 8001b8c:	d802      	bhi.n	8001b94 <HAL_GPIO_Init+0x14c>
 8001b8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b90:	009b      	lsls	r3, r3, #2
 8001b92:	e002      	b.n	8001b9a <HAL_GPIO_Init+0x152>
 8001b94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b96:	3b08      	subs	r3, #8
 8001b98:	009b      	lsls	r3, r3, #2
 8001b9a:	613b      	str	r3, [r7, #16]

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8001b9c:	697b      	ldr	r3, [r7, #20]
 8001b9e:	681a      	ldr	r2, [r3, #0]
 8001ba0:	210f      	movs	r1, #15
 8001ba2:	693b      	ldr	r3, [r7, #16]
 8001ba4:	fa01 f303 	lsl.w	r3, r1, r3
 8001ba8:	43db      	mvns	r3, r3
 8001baa:	401a      	ands	r2, r3
 8001bac:	6a39      	ldr	r1, [r7, #32]
 8001bae:	693b      	ldr	r3, [r7, #16]
 8001bb0:	fa01 f303 	lsl.w	r3, r1, r3
 8001bb4:	431a      	orrs	r2, r3
 8001bb6:	697b      	ldr	r3, [r7, #20]
 8001bb8:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001bba:	683b      	ldr	r3, [r7, #0]
 8001bbc:	685b      	ldr	r3, [r3, #4]
 8001bbe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001bc2:	2b00      	cmp	r3, #0
 8001bc4:	f000 80c1 	beq.w	8001d4a <HAL_GPIO_Init+0x302>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001bc8:	4b49      	ldr	r3, [pc, #292]	; (8001cf0 <HAL_GPIO_Init+0x2a8>)
 8001bca:	699b      	ldr	r3, [r3, #24]
 8001bcc:	4a48      	ldr	r2, [pc, #288]	; (8001cf0 <HAL_GPIO_Init+0x2a8>)
 8001bce:	f043 0301 	orr.w	r3, r3, #1
 8001bd2:	6193      	str	r3, [r2, #24]
 8001bd4:	4b46      	ldr	r3, [pc, #280]	; (8001cf0 <HAL_GPIO_Init+0x2a8>)
 8001bd6:	699b      	ldr	r3, [r3, #24]
 8001bd8:	f003 0301 	and.w	r3, r3, #1
 8001bdc:	60bb      	str	r3, [r7, #8]
 8001bde:	68bb      	ldr	r3, [r7, #8]
        temp = AFIO->EXTICR[position >> 2u];
 8001be0:	4a44      	ldr	r2, [pc, #272]	; (8001cf4 <HAL_GPIO_Init+0x2ac>)
 8001be2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001be4:	089b      	lsrs	r3, r3, #2
 8001be6:	3302      	adds	r3, #2
 8001be8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001bec:	60fb      	str	r3, [r7, #12]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001bee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001bf0:	f003 0303 	and.w	r3, r3, #3
 8001bf4:	009b      	lsls	r3, r3, #2
 8001bf6:	220f      	movs	r2, #15
 8001bf8:	fa02 f303 	lsl.w	r3, r2, r3
 8001bfc:	43db      	mvns	r3, r3
 8001bfe:	68fa      	ldr	r2, [r7, #12]
 8001c00:	4013      	ands	r3, r2
 8001c02:	60fb      	str	r3, [r7, #12]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001c04:	687b      	ldr	r3, [r7, #4]
 8001c06:	4a3c      	ldr	r2, [pc, #240]	; (8001cf8 <HAL_GPIO_Init+0x2b0>)
 8001c08:	4293      	cmp	r3, r2
 8001c0a:	d01f      	beq.n	8001c4c <HAL_GPIO_Init+0x204>
 8001c0c:	687b      	ldr	r3, [r7, #4]
 8001c0e:	4a3b      	ldr	r2, [pc, #236]	; (8001cfc <HAL_GPIO_Init+0x2b4>)
 8001c10:	4293      	cmp	r3, r2
 8001c12:	d019      	beq.n	8001c48 <HAL_GPIO_Init+0x200>
 8001c14:	687b      	ldr	r3, [r7, #4]
 8001c16:	4a3a      	ldr	r2, [pc, #232]	; (8001d00 <HAL_GPIO_Init+0x2b8>)
 8001c18:	4293      	cmp	r3, r2
 8001c1a:	d013      	beq.n	8001c44 <HAL_GPIO_Init+0x1fc>
 8001c1c:	687b      	ldr	r3, [r7, #4]
 8001c1e:	4a39      	ldr	r2, [pc, #228]	; (8001d04 <HAL_GPIO_Init+0x2bc>)
 8001c20:	4293      	cmp	r3, r2
 8001c22:	d00d      	beq.n	8001c40 <HAL_GPIO_Init+0x1f8>
 8001c24:	687b      	ldr	r3, [r7, #4]
 8001c26:	4a38      	ldr	r2, [pc, #224]	; (8001d08 <HAL_GPIO_Init+0x2c0>)
 8001c28:	4293      	cmp	r3, r2
 8001c2a:	d007      	beq.n	8001c3c <HAL_GPIO_Init+0x1f4>
 8001c2c:	687b      	ldr	r3, [r7, #4]
 8001c2e:	4a37      	ldr	r2, [pc, #220]	; (8001d0c <HAL_GPIO_Init+0x2c4>)
 8001c30:	4293      	cmp	r3, r2
 8001c32:	d101      	bne.n	8001c38 <HAL_GPIO_Init+0x1f0>
 8001c34:	2305      	movs	r3, #5
 8001c36:	e00a      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c38:	2306      	movs	r3, #6
 8001c3a:	e008      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c3c:	2304      	movs	r3, #4
 8001c3e:	e006      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c40:	2303      	movs	r3, #3
 8001c42:	e004      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c44:	2302      	movs	r3, #2
 8001c46:	e002      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c48:	2301      	movs	r3, #1
 8001c4a:	e000      	b.n	8001c4e <HAL_GPIO_Init+0x206>
 8001c4c:	2300      	movs	r3, #0
 8001c4e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001c50:	f002 0203 	and.w	r2, r2, #3
 8001c54:	0092      	lsls	r2, r2, #2
 8001c56:	4093      	lsls	r3, r2
 8001c58:	68fa      	ldr	r2, [r7, #12]
 8001c5a:	4313      	orrs	r3, r2
 8001c5c:	60fb      	str	r3, [r7, #12]
        AFIO->EXTICR[position >> 2u] = temp;
 8001c5e:	4925      	ldr	r1, [pc, #148]	; (8001cf4 <HAL_GPIO_Init+0x2ac>)
 8001c60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001c62:	089b      	lsrs	r3, r3, #2
 8001c64:	3302      	adds	r3, #2
 8001c66:	68fa      	ldr	r2, [r7, #12]
 8001c68:	f841 2023 	str.w	r2, [r1, r3, lsl #2]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001c6c:	683b      	ldr	r3, [r7, #0]
 8001c6e:	685b      	ldr	r3, [r3, #4]
 8001c70:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001c74:	2b00      	cmp	r3, #0
 8001c76:	d006      	beq.n	8001c86 <HAL_GPIO_Init+0x23e>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 8001c78:	4b25      	ldr	r3, [pc, #148]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001c7a:	681a      	ldr	r2, [r3, #0]
 8001c7c:	4924      	ldr	r1, [pc, #144]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001c7e:	69bb      	ldr	r3, [r7, #24]
 8001c80:	4313      	orrs	r3, r2
 8001c82:	600b      	str	r3, [r1, #0]
 8001c84:	e006      	b.n	8001c94 <HAL_GPIO_Init+0x24c>
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8001c86:	4b22      	ldr	r3, [pc, #136]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001c88:	681a      	ldr	r2, [r3, #0]
 8001c8a:	69bb      	ldr	r3, [r7, #24]
 8001c8c:	43db      	mvns	r3, r3
 8001c8e:	4920      	ldr	r1, [pc, #128]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001c90:	4013      	ands	r3, r2
 8001c92:	600b      	str	r3, [r1, #0]
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001c94:	683b      	ldr	r3, [r7, #0]
 8001c96:	685b      	ldr	r3, [r3, #4]
 8001c98:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001c9c:	2b00      	cmp	r3, #0
 8001c9e:	d006      	beq.n	8001cae <HAL_GPIO_Init+0x266>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 8001ca0:	4b1b      	ldr	r3, [pc, #108]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001ca2:	685a      	ldr	r2, [r3, #4]
 8001ca4:	491a      	ldr	r1, [pc, #104]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001ca6:	69bb      	ldr	r3, [r7, #24]
 8001ca8:	4313      	orrs	r3, r2
 8001caa:	604b      	str	r3, [r1, #4]
 8001cac:	e006      	b.n	8001cbc <HAL_GPIO_Init+0x274>
        }
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8001cae:	4b18      	ldr	r3, [pc, #96]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001cb0:	685a      	ldr	r2, [r3, #4]
 8001cb2:	69bb      	ldr	r3, [r7, #24]
 8001cb4:	43db      	mvns	r3, r3
 8001cb6:	4916      	ldr	r1, [pc, #88]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001cb8:	4013      	ands	r3, r2
 8001cba:	604b      	str	r3, [r1, #4]
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001cbc:	683b      	ldr	r3, [r7, #0]
 8001cbe:	685b      	ldr	r3, [r3, #4]
 8001cc0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001cc4:	2b00      	cmp	r3, #0
 8001cc6:	d025      	beq.n	8001d14 <HAL_GPIO_Init+0x2cc>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 8001cc8:	4b11      	ldr	r3, [pc, #68]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001cca:	689a      	ldr	r2, [r3, #8]
 8001ccc:	4910      	ldr	r1, [pc, #64]	; (8001d10 <HAL_GPIO_Init+0x2c8>)
 8001cce:	69bb      	ldr	r3, [r7, #24]
 8001cd0:	4313      	orrs	r3, r2
 8001cd2:	608b      	str	r3, [r1, #8]
 8001cd4:	e025      	b.n	8001d22 <HAL_GPIO_Init+0x2da>
 8001cd6:	bf00      	nop
 8001cd8:	10320000 	.word	0x10320000
 8001cdc:	10310000 	.word	0x10310000
 8001ce0:	10220000 	.word	0x10220000
 8001ce4:	10210000 	.word	0x10210000
 8001ce8:	10120000 	.word	0x10120000
 8001cec:	10110000 	.word	0x10110000
 8001cf0:	40021000 	.word	0x40021000
 8001cf4:	40010000 	.word	0x40010000
 8001cf8:	40010800 	.word	0x40010800
 8001cfc:	40010c00 	.word	0x40010c00
 8001d00:	40011000 	.word	0x40011000
 8001d04:	40011400 	.word	0x40011400
 8001d08:	40011800 	.word	0x40011800
 8001d0c:	40011c00 	.word	0x40011c00
 8001d10:	40010400 	.word	0x40010400
        }
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 8001d14:	4b15      	ldr	r3, [pc, #84]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d16:	689a      	ldr	r2, [r3, #8]
 8001d18:	69bb      	ldr	r3, [r7, #24]
 8001d1a:	43db      	mvns	r3, r3
 8001d1c:	4913      	ldr	r1, [pc, #76]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d1e:	4013      	ands	r3, r2
 8001d20:	608b      	str	r3, [r1, #8]
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001d22:	683b      	ldr	r3, [r7, #0]
 8001d24:	685b      	ldr	r3, [r3, #4]
 8001d26:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001d2a:	2b00      	cmp	r3, #0
 8001d2c:	d006      	beq.n	8001d3c <HAL_GPIO_Init+0x2f4>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 8001d2e:	4b0f      	ldr	r3, [pc, #60]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d30:	68da      	ldr	r2, [r3, #12]
 8001d32:	490e      	ldr	r1, [pc, #56]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d34:	69bb      	ldr	r3, [r7, #24]
 8001d36:	4313      	orrs	r3, r2
 8001d38:	60cb      	str	r3, [r1, #12]
 8001d3a:	e006      	b.n	8001d4a <HAL_GPIO_Init+0x302>
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8001d3c:	4b0b      	ldr	r3, [pc, #44]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d3e:	68da      	ldr	r2, [r3, #12]
 8001d40:	69bb      	ldr	r3, [r7, #24]
 8001d42:	43db      	mvns	r3, r3
 8001d44:	4909      	ldr	r1, [pc, #36]	; (8001d6c <HAL_GPIO_Init+0x324>)
 8001d46:	4013      	ands	r3, r2
 8001d48:	60cb      	str	r3, [r1, #12]
        }
      }
    }

	position++;
 8001d4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001d4c:	3301      	adds	r3, #1
 8001d4e:	627b      	str	r3, [r7, #36]	; 0x24
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001d50:	683b      	ldr	r3, [r7, #0]
 8001d52:	681a      	ldr	r2, [r3, #0]
 8001d54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001d56:	fa22 f303 	lsr.w	r3, r2, r3
 8001d5a:	2b00      	cmp	r3, #0
 8001d5c:	f47f ae7e 	bne.w	8001a5c <HAL_GPIO_Init+0x14>
  }
}
 8001d60:	bf00      	nop
 8001d62:	bf00      	nop
 8001d64:	372c      	adds	r7, #44	; 0x2c
 8001d66:	46bd      	mov	sp, r7
 8001d68:	bc80      	pop	{r7}
 8001d6a:	4770      	bx	lr
 8001d6c:	40010400 	.word	0x40010400

08001d70 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001d70:	b480      	push	{r7}
 8001d72:	b083      	sub	sp, #12
 8001d74:	af00      	add	r7, sp, #0
 8001d76:	6078      	str	r0, [r7, #4]
 8001d78:	460b      	mov	r3, r1
 8001d7a:	807b      	strh	r3, [r7, #2]
 8001d7c:	4613      	mov	r3, r2
 8001d7e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8001d80:	787b      	ldrb	r3, [r7, #1]
 8001d82:	2b00      	cmp	r3, #0
 8001d84:	d003      	beq.n	8001d8e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001d86:	887a      	ldrh	r2, [r7, #2]
 8001d88:	687b      	ldr	r3, [r7, #4]
 8001d8a:	611a      	str	r2, [r3, #16]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
  }
}
 8001d8c:	e003      	b.n	8001d96 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 8001d8e:	887b      	ldrh	r3, [r7, #2]
 8001d90:	041a      	lsls	r2, r3, #16
 8001d92:	687b      	ldr	r3, [r7, #4]
 8001d94:	611a      	str	r2, [r3, #16]
}
 8001d96:	bf00      	nop
 8001d98:	370c      	adds	r7, #12
 8001d9a:	46bd      	mov	sp, r7
 8001d9c:	bc80      	pop	{r7}
 8001d9e:	4770      	bx	lr

08001da0 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001da0:	b580      	push	{r7, lr}
 8001da2:	b086      	sub	sp, #24
 8001da4:	af00      	add	r7, sp, #0
 8001da6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8001da8:	687b      	ldr	r3, [r7, #4]
 8001daa:	2b00      	cmp	r3, #0
 8001dac:	d101      	bne.n	8001db2 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8001dae:	2301      	movs	r3, #1
 8001db0:	e272      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001db2:	687b      	ldr	r3, [r7, #4]
 8001db4:	681b      	ldr	r3, [r3, #0]
 8001db6:	f003 0301 	and.w	r3, r3, #1
 8001dba:	2b00      	cmp	r3, #0
 8001dbc:	f000 8087 	beq.w	8001ece <HAL_RCC_OscConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8001dc0:	4b92      	ldr	r3, [pc, #584]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001dc2:	685b      	ldr	r3, [r3, #4]
 8001dc4:	f003 030c 	and.w	r3, r3, #12
 8001dc8:	2b04      	cmp	r3, #4
 8001dca:	d00c      	beq.n	8001de6 <HAL_RCC_OscConfig+0x46>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8001dcc:	4b8f      	ldr	r3, [pc, #572]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001dce:	685b      	ldr	r3, [r3, #4]
 8001dd0:	f003 030c 	and.w	r3, r3, #12
 8001dd4:	2b08      	cmp	r3, #8
 8001dd6:	d112      	bne.n	8001dfe <HAL_RCC_OscConfig+0x5e>
 8001dd8:	4b8c      	ldr	r3, [pc, #560]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001dda:	685b      	ldr	r3, [r3, #4]
 8001ddc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001de0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001de4:	d10b      	bne.n	8001dfe <HAL_RCC_OscConfig+0x5e>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001de6:	4b89      	ldr	r3, [pc, #548]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001de8:	681b      	ldr	r3, [r3, #0]
 8001dea:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001dee:	2b00      	cmp	r3, #0
 8001df0:	d06c      	beq.n	8001ecc <HAL_RCC_OscConfig+0x12c>
 8001df2:	687b      	ldr	r3, [r7, #4]
 8001df4:	685b      	ldr	r3, [r3, #4]
 8001df6:	2b00      	cmp	r3, #0
 8001df8:	d168      	bne.n	8001ecc <HAL_RCC_OscConfig+0x12c>
      {
        return HAL_ERROR;
 8001dfa:	2301      	movs	r3, #1
 8001dfc:	e24c      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001dfe:	687b      	ldr	r3, [r7, #4]
 8001e00:	685b      	ldr	r3, [r3, #4]
 8001e02:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001e06:	d106      	bne.n	8001e16 <HAL_RCC_OscConfig+0x76>
 8001e08:	4b80      	ldr	r3, [pc, #512]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e0a:	681b      	ldr	r3, [r3, #0]
 8001e0c:	4a7f      	ldr	r2, [pc, #508]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e0e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001e12:	6013      	str	r3, [r2, #0]
 8001e14:	e02e      	b.n	8001e74 <HAL_RCC_OscConfig+0xd4>
 8001e16:	687b      	ldr	r3, [r7, #4]
 8001e18:	685b      	ldr	r3, [r3, #4]
 8001e1a:	2b00      	cmp	r3, #0
 8001e1c:	d10c      	bne.n	8001e38 <HAL_RCC_OscConfig+0x98>
 8001e1e:	4b7b      	ldr	r3, [pc, #492]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e20:	681b      	ldr	r3, [r3, #0]
 8001e22:	4a7a      	ldr	r2, [pc, #488]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e24:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001e28:	6013      	str	r3, [r2, #0]
 8001e2a:	4b78      	ldr	r3, [pc, #480]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e2c:	681b      	ldr	r3, [r3, #0]
 8001e2e:	4a77      	ldr	r2, [pc, #476]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e30:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001e34:	6013      	str	r3, [r2, #0]
 8001e36:	e01d      	b.n	8001e74 <HAL_RCC_OscConfig+0xd4>
 8001e38:	687b      	ldr	r3, [r7, #4]
 8001e3a:	685b      	ldr	r3, [r3, #4]
 8001e3c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001e40:	d10c      	bne.n	8001e5c <HAL_RCC_OscConfig+0xbc>
 8001e42:	4b72      	ldr	r3, [pc, #456]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e44:	681b      	ldr	r3, [r3, #0]
 8001e46:	4a71      	ldr	r2, [pc, #452]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e48:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001e4c:	6013      	str	r3, [r2, #0]
 8001e4e:	4b6f      	ldr	r3, [pc, #444]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e50:	681b      	ldr	r3, [r3, #0]
 8001e52:	4a6e      	ldr	r2, [pc, #440]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e54:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001e58:	6013      	str	r3, [r2, #0]
 8001e5a:	e00b      	b.n	8001e74 <HAL_RCC_OscConfig+0xd4>
 8001e5c:	4b6b      	ldr	r3, [pc, #428]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e5e:	681b      	ldr	r3, [r3, #0]
 8001e60:	4a6a      	ldr	r2, [pc, #424]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e62:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001e66:	6013      	str	r3, [r2, #0]
 8001e68:	4b68      	ldr	r3, [pc, #416]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e6a:	681b      	ldr	r3, [r3, #0]
 8001e6c:	4a67      	ldr	r2, [pc, #412]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e6e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001e72:	6013      	str	r3, [r2, #0]


      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001e74:	687b      	ldr	r3, [r7, #4]
 8001e76:	685b      	ldr	r3, [r3, #4]
 8001e78:	2b00      	cmp	r3, #0
 8001e7a:	d013      	beq.n	8001ea4 <HAL_RCC_OscConfig+0x104>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001e7c:	f7ff fc9a 	bl	80017b4 <HAL_GetTick>
 8001e80:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e82:	e008      	b.n	8001e96 <HAL_RCC_OscConfig+0xf6>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001e84:	f7ff fc96 	bl	80017b4 <HAL_GetTick>
 8001e88:	4602      	mov	r2, r0
 8001e8a:	693b      	ldr	r3, [r7, #16]
 8001e8c:	1ad3      	subs	r3, r2, r3
 8001e8e:	2b64      	cmp	r3, #100	; 0x64
 8001e90:	d901      	bls.n	8001e96 <HAL_RCC_OscConfig+0xf6>
          {
            return HAL_TIMEOUT;
 8001e92:	2303      	movs	r3, #3
 8001e94:	e200      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e96:	4b5d      	ldr	r3, [pc, #372]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001e98:	681b      	ldr	r3, [r3, #0]
 8001e9a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001e9e:	2b00      	cmp	r3, #0
 8001ea0:	d0f0      	beq.n	8001e84 <HAL_RCC_OscConfig+0xe4>
 8001ea2:	e014      	b.n	8001ece <HAL_RCC_OscConfig+0x12e>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001ea4:	f7ff fc86 	bl	80017b4 <HAL_GetTick>
 8001ea8:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001eaa:	e008      	b.n	8001ebe <HAL_RCC_OscConfig+0x11e>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001eac:	f7ff fc82 	bl	80017b4 <HAL_GetTick>
 8001eb0:	4602      	mov	r2, r0
 8001eb2:	693b      	ldr	r3, [r7, #16]
 8001eb4:	1ad3      	subs	r3, r2, r3
 8001eb6:	2b64      	cmp	r3, #100	; 0x64
 8001eb8:	d901      	bls.n	8001ebe <HAL_RCC_OscConfig+0x11e>
          {
            return HAL_TIMEOUT;
 8001eba:	2303      	movs	r3, #3
 8001ebc:	e1ec      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001ebe:	4b53      	ldr	r3, [pc, #332]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001ec0:	681b      	ldr	r3, [r3, #0]
 8001ec2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001ec6:	2b00      	cmp	r3, #0
 8001ec8:	d1f0      	bne.n	8001eac <HAL_RCC_OscConfig+0x10c>
 8001eca:	e000      	b.n	8001ece <HAL_RCC_OscConfig+0x12e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001ecc:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001ece:	687b      	ldr	r3, [r7, #4]
 8001ed0:	681b      	ldr	r3, [r3, #0]
 8001ed2:	f003 0302 	and.w	r3, r3, #2
 8001ed6:	2b00      	cmp	r3, #0
 8001ed8:	d063      	beq.n	8001fa2 <HAL_RCC_OscConfig+0x202>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8001eda:	4b4c      	ldr	r3, [pc, #304]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001edc:	685b      	ldr	r3, [r3, #4]
 8001ede:	f003 030c 	and.w	r3, r3, #12
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	d00b      	beq.n	8001efe <HAL_RCC_OscConfig+0x15e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8001ee6:	4b49      	ldr	r3, [pc, #292]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001ee8:	685b      	ldr	r3, [r3, #4]
 8001eea:	f003 030c 	and.w	r3, r3, #12
 8001eee:	2b08      	cmp	r3, #8
 8001ef0:	d11c      	bne.n	8001f2c <HAL_RCC_OscConfig+0x18c>
 8001ef2:	4b46      	ldr	r3, [pc, #280]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001ef4:	685b      	ldr	r3, [r3, #4]
 8001ef6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001efa:	2b00      	cmp	r3, #0
 8001efc:	d116      	bne.n	8001f2c <HAL_RCC_OscConfig+0x18c>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001efe:	4b43      	ldr	r3, [pc, #268]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f00:	681b      	ldr	r3, [r3, #0]
 8001f02:	f003 0302 	and.w	r3, r3, #2
 8001f06:	2b00      	cmp	r3, #0
 8001f08:	d005      	beq.n	8001f16 <HAL_RCC_OscConfig+0x176>
 8001f0a:	687b      	ldr	r3, [r7, #4]
 8001f0c:	691b      	ldr	r3, [r3, #16]
 8001f0e:	2b01      	cmp	r3, #1
 8001f10:	d001      	beq.n	8001f16 <HAL_RCC_OscConfig+0x176>
      {
        return HAL_ERROR;
 8001f12:	2301      	movs	r3, #1
 8001f14:	e1c0      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001f16:	4b3d      	ldr	r3, [pc, #244]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f18:	681b      	ldr	r3, [r3, #0]
 8001f1a:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8001f1e:	687b      	ldr	r3, [r7, #4]
 8001f20:	695b      	ldr	r3, [r3, #20]
 8001f22:	00db      	lsls	r3, r3, #3
 8001f24:	4939      	ldr	r1, [pc, #228]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f26:	4313      	orrs	r3, r2
 8001f28:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001f2a:	e03a      	b.n	8001fa2 <HAL_RCC_OscConfig+0x202>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001f2c:	687b      	ldr	r3, [r7, #4]
 8001f2e:	691b      	ldr	r3, [r3, #16]
 8001f30:	2b00      	cmp	r3, #0
 8001f32:	d020      	beq.n	8001f76 <HAL_RCC_OscConfig+0x1d6>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001f34:	4b36      	ldr	r3, [pc, #216]	; (8002010 <HAL_RCC_OscConfig+0x270>)
 8001f36:	2201      	movs	r2, #1
 8001f38:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001f3a:	f7ff fc3b 	bl	80017b4 <HAL_GetTick>
 8001f3e:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f40:	e008      	b.n	8001f54 <HAL_RCC_OscConfig+0x1b4>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001f42:	f7ff fc37 	bl	80017b4 <HAL_GetTick>
 8001f46:	4602      	mov	r2, r0
 8001f48:	693b      	ldr	r3, [r7, #16]
 8001f4a:	1ad3      	subs	r3, r2, r3
 8001f4c:	2b02      	cmp	r3, #2
 8001f4e:	d901      	bls.n	8001f54 <HAL_RCC_OscConfig+0x1b4>
          {
            return HAL_TIMEOUT;
 8001f50:	2303      	movs	r3, #3
 8001f52:	e1a1      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f54:	4b2d      	ldr	r3, [pc, #180]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f56:	681b      	ldr	r3, [r3, #0]
 8001f58:	f003 0302 	and.w	r3, r3, #2
 8001f5c:	2b00      	cmp	r3, #0
 8001f5e:	d0f0      	beq.n	8001f42 <HAL_RCC_OscConfig+0x1a2>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001f60:	4b2a      	ldr	r3, [pc, #168]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f62:	681b      	ldr	r3, [r3, #0]
 8001f64:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8001f68:	687b      	ldr	r3, [r7, #4]
 8001f6a:	695b      	ldr	r3, [r3, #20]
 8001f6c:	00db      	lsls	r3, r3, #3
 8001f6e:	4927      	ldr	r1, [pc, #156]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f70:	4313      	orrs	r3, r2
 8001f72:	600b      	str	r3, [r1, #0]
 8001f74:	e015      	b.n	8001fa2 <HAL_RCC_OscConfig+0x202>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001f76:	4b26      	ldr	r3, [pc, #152]	; (8002010 <HAL_RCC_OscConfig+0x270>)
 8001f78:	2200      	movs	r2, #0
 8001f7a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001f7c:	f7ff fc1a 	bl	80017b4 <HAL_GetTick>
 8001f80:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001f82:	e008      	b.n	8001f96 <HAL_RCC_OscConfig+0x1f6>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001f84:	f7ff fc16 	bl	80017b4 <HAL_GetTick>
 8001f88:	4602      	mov	r2, r0
 8001f8a:	693b      	ldr	r3, [r7, #16]
 8001f8c:	1ad3      	subs	r3, r2, r3
 8001f8e:	2b02      	cmp	r3, #2
 8001f90:	d901      	bls.n	8001f96 <HAL_RCC_OscConfig+0x1f6>
          {
            return HAL_TIMEOUT;
 8001f92:	2303      	movs	r3, #3
 8001f94:	e180      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001f96:	4b1d      	ldr	r3, [pc, #116]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001f98:	681b      	ldr	r3, [r3, #0]
 8001f9a:	f003 0302 	and.w	r3, r3, #2
 8001f9e:	2b00      	cmp	r3, #0
 8001fa0:	d1f0      	bne.n	8001f84 <HAL_RCC_OscConfig+0x1e4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001fa2:	687b      	ldr	r3, [r7, #4]
 8001fa4:	681b      	ldr	r3, [r3, #0]
 8001fa6:	f003 0308 	and.w	r3, r3, #8
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	d03a      	beq.n	8002024 <HAL_RCC_OscConfig+0x284>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001fae:	687b      	ldr	r3, [r7, #4]
 8001fb0:	699b      	ldr	r3, [r3, #24]
 8001fb2:	2b00      	cmp	r3, #0
 8001fb4:	d019      	beq.n	8001fea <HAL_RCC_OscConfig+0x24a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001fb6:	4b17      	ldr	r3, [pc, #92]	; (8002014 <HAL_RCC_OscConfig+0x274>)
 8001fb8:	2201      	movs	r2, #1
 8001fba:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001fbc:	f7ff fbfa 	bl	80017b4 <HAL_GetTick>
 8001fc0:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001fc2:	e008      	b.n	8001fd6 <HAL_RCC_OscConfig+0x236>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001fc4:	f7ff fbf6 	bl	80017b4 <HAL_GetTick>
 8001fc8:	4602      	mov	r2, r0
 8001fca:	693b      	ldr	r3, [r7, #16]
 8001fcc:	1ad3      	subs	r3, r2, r3
 8001fce:	2b02      	cmp	r3, #2
 8001fd0:	d901      	bls.n	8001fd6 <HAL_RCC_OscConfig+0x236>
        {
          return HAL_TIMEOUT;
 8001fd2:	2303      	movs	r3, #3
 8001fd4:	e160      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001fd6:	4b0d      	ldr	r3, [pc, #52]	; (800200c <HAL_RCC_OscConfig+0x26c>)
 8001fd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fda:	f003 0302 	and.w	r3, r3, #2
 8001fde:	2b00      	cmp	r3, #0
 8001fe0:	d0f0      	beq.n	8001fc4 <HAL_RCC_OscConfig+0x224>
        }
      }
      /*  To have a fully stabilized clock in the specified range, a software delay of 1ms
          should be added.*/
      RCC_Delay(1);
 8001fe2:	2001      	movs	r0, #1
 8001fe4:	f000 fad8 	bl	8002598 <RCC_Delay>
 8001fe8:	e01c      	b.n	8002024 <HAL_RCC_OscConfig+0x284>
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001fea:	4b0a      	ldr	r3, [pc, #40]	; (8002014 <HAL_RCC_OscConfig+0x274>)
 8001fec:	2200      	movs	r2, #0
 8001fee:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001ff0:	f7ff fbe0 	bl	80017b4 <HAL_GetTick>
 8001ff4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001ff6:	e00f      	b.n	8002018 <HAL_RCC_OscConfig+0x278>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001ff8:	f7ff fbdc 	bl	80017b4 <HAL_GetTick>
 8001ffc:	4602      	mov	r2, r0
 8001ffe:	693b      	ldr	r3, [r7, #16]
 8002000:	1ad3      	subs	r3, r2, r3
 8002002:	2b02      	cmp	r3, #2
 8002004:	d908      	bls.n	8002018 <HAL_RCC_OscConfig+0x278>
        {
          return HAL_TIMEOUT;
 8002006:	2303      	movs	r3, #3
 8002008:	e146      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
 800200a:	bf00      	nop
 800200c:	40021000 	.word	0x40021000
 8002010:	42420000 	.word	0x42420000
 8002014:	42420480 	.word	0x42420480
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002018:	4b92      	ldr	r3, [pc, #584]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 800201a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800201c:	f003 0302 	and.w	r3, r3, #2
 8002020:	2b00      	cmp	r3, #0
 8002022:	d1e9      	bne.n	8001ff8 <HAL_RCC_OscConfig+0x258>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002024:	687b      	ldr	r3, [r7, #4]
 8002026:	681b      	ldr	r3, [r3, #0]
 8002028:	f003 0304 	and.w	r3, r3, #4
 800202c:	2b00      	cmp	r3, #0
 800202e:	f000 80a6 	beq.w	800217e <HAL_RCC_OscConfig+0x3de>
  {
    FlagStatus       pwrclkchanged = RESET;
 8002032:	2300      	movs	r3, #0
 8002034:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002036:	4b8b      	ldr	r3, [pc, #556]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002038:	69db      	ldr	r3, [r3, #28]
 800203a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800203e:	2b00      	cmp	r3, #0
 8002040:	d10d      	bne.n	800205e <HAL_RCC_OscConfig+0x2be>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8002042:	4b88      	ldr	r3, [pc, #544]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002044:	69db      	ldr	r3, [r3, #28]
 8002046:	4a87      	ldr	r2, [pc, #540]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002048:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800204c:	61d3      	str	r3, [r2, #28]
 800204e:	4b85      	ldr	r3, [pc, #532]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002050:	69db      	ldr	r3, [r3, #28]
 8002052:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002056:	60bb      	str	r3, [r7, #8]
 8002058:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800205a:	2301      	movs	r3, #1
 800205c:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800205e:	4b82      	ldr	r3, [pc, #520]	; (8002268 <HAL_RCC_OscConfig+0x4c8>)
 8002060:	681b      	ldr	r3, [r3, #0]
 8002062:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002066:	2b00      	cmp	r3, #0
 8002068:	d118      	bne.n	800209c <HAL_RCC_OscConfig+0x2fc>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800206a:	4b7f      	ldr	r3, [pc, #508]	; (8002268 <HAL_RCC_OscConfig+0x4c8>)
 800206c:	681b      	ldr	r3, [r3, #0]
 800206e:	4a7e      	ldr	r2, [pc, #504]	; (8002268 <HAL_RCC_OscConfig+0x4c8>)
 8002070:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002074:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002076:	f7ff fb9d 	bl	80017b4 <HAL_GetTick>
 800207a:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800207c:	e008      	b.n	8002090 <HAL_RCC_OscConfig+0x2f0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800207e:	f7ff fb99 	bl	80017b4 <HAL_GetTick>
 8002082:	4602      	mov	r2, r0
 8002084:	693b      	ldr	r3, [r7, #16]
 8002086:	1ad3      	subs	r3, r2, r3
 8002088:	2b64      	cmp	r3, #100	; 0x64
 800208a:	d901      	bls.n	8002090 <HAL_RCC_OscConfig+0x2f0>
        {
          return HAL_TIMEOUT;
 800208c:	2303      	movs	r3, #3
 800208e:	e103      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002090:	4b75      	ldr	r3, [pc, #468]	; (8002268 <HAL_RCC_OscConfig+0x4c8>)
 8002092:	681b      	ldr	r3, [r3, #0]
 8002094:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002098:	2b00      	cmp	r3, #0
 800209a:	d0f0      	beq.n	800207e <HAL_RCC_OscConfig+0x2de>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800209c:	687b      	ldr	r3, [r7, #4]
 800209e:	68db      	ldr	r3, [r3, #12]
 80020a0:	2b01      	cmp	r3, #1
 80020a2:	d106      	bne.n	80020b2 <HAL_RCC_OscConfig+0x312>
 80020a4:	4b6f      	ldr	r3, [pc, #444]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020a6:	6a1b      	ldr	r3, [r3, #32]
 80020a8:	4a6e      	ldr	r2, [pc, #440]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020aa:	f043 0301 	orr.w	r3, r3, #1
 80020ae:	6213      	str	r3, [r2, #32]
 80020b0:	e02d      	b.n	800210e <HAL_RCC_OscConfig+0x36e>
 80020b2:	687b      	ldr	r3, [r7, #4]
 80020b4:	68db      	ldr	r3, [r3, #12]
 80020b6:	2b00      	cmp	r3, #0
 80020b8:	d10c      	bne.n	80020d4 <HAL_RCC_OscConfig+0x334>
 80020ba:	4b6a      	ldr	r3, [pc, #424]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020bc:	6a1b      	ldr	r3, [r3, #32]
 80020be:	4a69      	ldr	r2, [pc, #420]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020c0:	f023 0301 	bic.w	r3, r3, #1
 80020c4:	6213      	str	r3, [r2, #32]
 80020c6:	4b67      	ldr	r3, [pc, #412]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020c8:	6a1b      	ldr	r3, [r3, #32]
 80020ca:	4a66      	ldr	r2, [pc, #408]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020cc:	f023 0304 	bic.w	r3, r3, #4
 80020d0:	6213      	str	r3, [r2, #32]
 80020d2:	e01c      	b.n	800210e <HAL_RCC_OscConfig+0x36e>
 80020d4:	687b      	ldr	r3, [r7, #4]
 80020d6:	68db      	ldr	r3, [r3, #12]
 80020d8:	2b05      	cmp	r3, #5
 80020da:	d10c      	bne.n	80020f6 <HAL_RCC_OscConfig+0x356>
 80020dc:	4b61      	ldr	r3, [pc, #388]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020de:	6a1b      	ldr	r3, [r3, #32]
 80020e0:	4a60      	ldr	r2, [pc, #384]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020e2:	f043 0304 	orr.w	r3, r3, #4
 80020e6:	6213      	str	r3, [r2, #32]
 80020e8:	4b5e      	ldr	r3, [pc, #376]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020ea:	6a1b      	ldr	r3, [r3, #32]
 80020ec:	4a5d      	ldr	r2, [pc, #372]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020ee:	f043 0301 	orr.w	r3, r3, #1
 80020f2:	6213      	str	r3, [r2, #32]
 80020f4:	e00b      	b.n	800210e <HAL_RCC_OscConfig+0x36e>
 80020f6:	4b5b      	ldr	r3, [pc, #364]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020f8:	6a1b      	ldr	r3, [r3, #32]
 80020fa:	4a5a      	ldr	r2, [pc, #360]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80020fc:	f023 0301 	bic.w	r3, r3, #1
 8002100:	6213      	str	r3, [r2, #32]
 8002102:	4b58      	ldr	r3, [pc, #352]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002104:	6a1b      	ldr	r3, [r3, #32]
 8002106:	4a57      	ldr	r2, [pc, #348]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002108:	f023 0304 	bic.w	r3, r3, #4
 800210c:	6213      	str	r3, [r2, #32]
    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800210e:	687b      	ldr	r3, [r7, #4]
 8002110:	68db      	ldr	r3, [r3, #12]
 8002112:	2b00      	cmp	r3, #0
 8002114:	d015      	beq.n	8002142 <HAL_RCC_OscConfig+0x3a2>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002116:	f7ff fb4d 	bl	80017b4 <HAL_GetTick>
 800211a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800211c:	e00a      	b.n	8002134 <HAL_RCC_OscConfig+0x394>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800211e:	f7ff fb49 	bl	80017b4 <HAL_GetTick>
 8002122:	4602      	mov	r2, r0
 8002124:	693b      	ldr	r3, [r7, #16]
 8002126:	1ad3      	subs	r3, r2, r3
 8002128:	f241 3288 	movw	r2, #5000	; 0x1388
 800212c:	4293      	cmp	r3, r2
 800212e:	d901      	bls.n	8002134 <HAL_RCC_OscConfig+0x394>
        {
          return HAL_TIMEOUT;
 8002130:	2303      	movs	r3, #3
 8002132:	e0b1      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002134:	4b4b      	ldr	r3, [pc, #300]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002136:	6a1b      	ldr	r3, [r3, #32]
 8002138:	f003 0302 	and.w	r3, r3, #2
 800213c:	2b00      	cmp	r3, #0
 800213e:	d0ee      	beq.n	800211e <HAL_RCC_OscConfig+0x37e>
 8002140:	e014      	b.n	800216c <HAL_RCC_OscConfig+0x3cc>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002142:	f7ff fb37 	bl	80017b4 <HAL_GetTick>
 8002146:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002148:	e00a      	b.n	8002160 <HAL_RCC_OscConfig+0x3c0>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800214a:	f7ff fb33 	bl	80017b4 <HAL_GetTick>
 800214e:	4602      	mov	r2, r0
 8002150:	693b      	ldr	r3, [r7, #16]
 8002152:	1ad3      	subs	r3, r2, r3
 8002154:	f241 3288 	movw	r2, #5000	; 0x1388
 8002158:	4293      	cmp	r3, r2
 800215a:	d901      	bls.n	8002160 <HAL_RCC_OscConfig+0x3c0>
        {
          return HAL_TIMEOUT;
 800215c:	2303      	movs	r3, #3
 800215e:	e09b      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002160:	4b40      	ldr	r3, [pc, #256]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002162:	6a1b      	ldr	r3, [r3, #32]
 8002164:	f003 0302 	and.w	r3, r3, #2
 8002168:	2b00      	cmp	r3, #0
 800216a:	d1ee      	bne.n	800214a <HAL_RCC_OscConfig+0x3aa>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 800216c:	7dfb      	ldrb	r3, [r7, #23]
 800216e:	2b01      	cmp	r3, #1
 8002170:	d105      	bne.n	800217e <HAL_RCC_OscConfig+0x3de>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8002172:	4b3c      	ldr	r3, [pc, #240]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002174:	69db      	ldr	r3, [r3, #28]
 8002176:	4a3b      	ldr	r2, [pc, #236]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 8002178:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800217c:	61d3      	str	r3, [r2, #28]

#endif /* RCC_CR_PLL2ON */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800217e:	687b      	ldr	r3, [r7, #4]
 8002180:	69db      	ldr	r3, [r3, #28]
 8002182:	2b00      	cmp	r3, #0
 8002184:	f000 8087 	beq.w	8002296 <HAL_RCC_OscConfig+0x4f6>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002188:	4b36      	ldr	r3, [pc, #216]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 800218a:	685b      	ldr	r3, [r3, #4]
 800218c:	f003 030c 	and.w	r3, r3, #12
 8002190:	2b08      	cmp	r3, #8
 8002192:	d061      	beq.n	8002258 <HAL_RCC_OscConfig+0x4b8>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002194:	687b      	ldr	r3, [r7, #4]
 8002196:	69db      	ldr	r3, [r3, #28]
 8002198:	2b02      	cmp	r3, #2
 800219a:	d146      	bne.n	800222a <HAL_RCC_OscConfig+0x48a>
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800219c:	4b33      	ldr	r3, [pc, #204]	; (800226c <HAL_RCC_OscConfig+0x4cc>)
 800219e:	2200      	movs	r2, #0
 80021a0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80021a2:	f7ff fb07 	bl	80017b4 <HAL_GetTick>
 80021a6:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80021a8:	e008      	b.n	80021bc <HAL_RCC_OscConfig+0x41c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80021aa:	f7ff fb03 	bl	80017b4 <HAL_GetTick>
 80021ae:	4602      	mov	r2, r0
 80021b0:	693b      	ldr	r3, [r7, #16]
 80021b2:	1ad3      	subs	r3, r2, r3
 80021b4:	2b02      	cmp	r3, #2
 80021b6:	d901      	bls.n	80021bc <HAL_RCC_OscConfig+0x41c>
          {
            return HAL_TIMEOUT;
 80021b8:	2303      	movs	r3, #3
 80021ba:	e06d      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80021bc:	4b29      	ldr	r3, [pc, #164]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80021be:	681b      	ldr	r3, [r3, #0]
 80021c0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d1f0      	bne.n	80021aa <HAL_RCC_OscConfig+0x40a>
          }
        }

        /* Configure the HSE prediv factor --------------------------------*/
        /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 80021c8:	687b      	ldr	r3, [r7, #4]
 80021ca:	6a1b      	ldr	r3, [r3, #32]
 80021cc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80021d0:	d108      	bne.n	80021e4 <HAL_RCC_OscConfig+0x444>
          /* Set PREDIV1 source */
          SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
#endif /* RCC_CFGR2_PREDIV1SRC */

          /* Set PREDIV1 Value */
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 80021d2:	4b24      	ldr	r3, [pc, #144]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80021d4:	685b      	ldr	r3, [r3, #4]
 80021d6:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
 80021da:	687b      	ldr	r3, [r7, #4]
 80021dc:	689b      	ldr	r3, [r3, #8]
 80021de:	4921      	ldr	r1, [pc, #132]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80021e0:	4313      	orrs	r3, r2
 80021e2:	604b      	str	r3, [r1, #4]
        }

        /* Configure the main PLL clock source and multiplication factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80021e4:	4b1f      	ldr	r3, [pc, #124]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80021e6:	685b      	ldr	r3, [r3, #4]
 80021e8:	f423 1274 	bic.w	r2, r3, #3997696	; 0x3d0000
 80021ec:	687b      	ldr	r3, [r7, #4]
 80021ee:	6a19      	ldr	r1, [r3, #32]
 80021f0:	687b      	ldr	r3, [r7, #4]
 80021f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80021f4:	430b      	orrs	r3, r1
 80021f6:	491b      	ldr	r1, [pc, #108]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 80021f8:	4313      	orrs	r3, r2
 80021fa:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLMUL);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80021fc:	4b1b      	ldr	r3, [pc, #108]	; (800226c <HAL_RCC_OscConfig+0x4cc>)
 80021fe:	2201      	movs	r2, #1
 8002200:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002202:	f7ff fad7 	bl	80017b4 <HAL_GetTick>
 8002206:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8002208:	e008      	b.n	800221c <HAL_RCC_OscConfig+0x47c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800220a:	f7ff fad3 	bl	80017b4 <HAL_GetTick>
 800220e:	4602      	mov	r2, r0
 8002210:	693b      	ldr	r3, [r7, #16]
 8002212:	1ad3      	subs	r3, r2, r3
 8002214:	2b02      	cmp	r3, #2
 8002216:	d901      	bls.n	800221c <HAL_RCC_OscConfig+0x47c>
          {
            return HAL_TIMEOUT;
 8002218:	2303      	movs	r3, #3
 800221a:	e03d      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800221c:	4b11      	ldr	r3, [pc, #68]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 800221e:	681b      	ldr	r3, [r3, #0]
 8002220:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002224:	2b00      	cmp	r3, #0
 8002226:	d0f0      	beq.n	800220a <HAL_RCC_OscConfig+0x46a>
 8002228:	e035      	b.n	8002296 <HAL_RCC_OscConfig+0x4f6>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800222a:	4b10      	ldr	r3, [pc, #64]	; (800226c <HAL_RCC_OscConfig+0x4cc>)
 800222c:	2200      	movs	r2, #0
 800222e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002230:	f7ff fac0 	bl	80017b4 <HAL_GetTick>
 8002234:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002236:	e008      	b.n	800224a <HAL_RCC_OscConfig+0x4aa>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002238:	f7ff fabc 	bl	80017b4 <HAL_GetTick>
 800223c:	4602      	mov	r2, r0
 800223e:	693b      	ldr	r3, [r7, #16]
 8002240:	1ad3      	subs	r3, r2, r3
 8002242:	2b02      	cmp	r3, #2
 8002244:	d901      	bls.n	800224a <HAL_RCC_OscConfig+0x4aa>
          {
            return HAL_TIMEOUT;
 8002246:	2303      	movs	r3, #3
 8002248:	e026      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800224a:	4b06      	ldr	r3, [pc, #24]	; (8002264 <HAL_RCC_OscConfig+0x4c4>)
 800224c:	681b      	ldr	r3, [r3, #0]
 800224e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002252:	2b00      	cmp	r3, #0
 8002254:	d1f0      	bne.n	8002238 <HAL_RCC_OscConfig+0x498>
 8002256:	e01e      	b.n	8002296 <HAL_RCC_OscConfig+0x4f6>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	69db      	ldr	r3, [r3, #28]
 800225c:	2b01      	cmp	r3, #1
 800225e:	d107      	bne.n	8002270 <HAL_RCC_OscConfig+0x4d0>
      {
        return HAL_ERROR;
 8002260:	2301      	movs	r3, #1
 8002262:	e019      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
 8002264:	40021000 	.word	0x40021000
 8002268:	40007000 	.word	0x40007000
 800226c:	42420060 	.word	0x42420060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 8002270:	4b0b      	ldr	r3, [pc, #44]	; (80022a0 <HAL_RCC_OscConfig+0x500>)
 8002272:	685b      	ldr	r3, [r3, #4]
 8002274:	60fb      	str	r3, [r7, #12]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002276:	68fb      	ldr	r3, [r7, #12]
 8002278:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
 800227c:	687b      	ldr	r3, [r7, #4]
 800227e:	6a1b      	ldr	r3, [r3, #32]
 8002280:	429a      	cmp	r2, r3
 8002282:	d106      	bne.n	8002292 <HAL_RCC_OscConfig+0x4f2>
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 8002284:	68fb      	ldr	r3, [r7, #12]
 8002286:	f403 1270 	and.w	r2, r3, #3932160	; 0x3c0000
 800228a:	687b      	ldr	r3, [r7, #4]
 800228c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800228e:	429a      	cmp	r2, r3
 8002290:	d001      	beq.n	8002296 <HAL_RCC_OscConfig+0x4f6>
        {
          return HAL_ERROR;
 8002292:	2301      	movs	r3, #1
 8002294:	e000      	b.n	8002298 <HAL_RCC_OscConfig+0x4f8>
        }
      }
    }
  }

  return HAL_OK;
 8002296:	2300      	movs	r3, #0
}
 8002298:	4618      	mov	r0, r3
 800229a:	3718      	adds	r7, #24
 800229c:	46bd      	mov	sp, r7
 800229e:	bd80      	pop	{r7, pc}
 80022a0:	40021000 	.word	0x40021000

080022a4 <HAL_RCC_ClockConfig>:
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80022a4:	b580      	push	{r7, lr}
 80022a6:	b084      	sub	sp, #16
 80022a8:	af00      	add	r7, sp, #0
 80022aa:	6078      	str	r0, [r7, #4]
 80022ac:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	2b00      	cmp	r3, #0
 80022b2:	d101      	bne.n	80022b8 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 80022b4:	2301      	movs	r3, #1
 80022b6:	e0d0      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
  must be correctly programmed according to the frequency of the CPU clock
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80022b8:	4b6a      	ldr	r3, [pc, #424]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80022ba:	681b      	ldr	r3, [r3, #0]
 80022bc:	f003 0307 	and.w	r3, r3, #7
 80022c0:	683a      	ldr	r2, [r7, #0]
 80022c2:	429a      	cmp	r2, r3
 80022c4:	d910      	bls.n	80022e8 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80022c6:	4b67      	ldr	r3, [pc, #412]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80022c8:	681b      	ldr	r3, [r3, #0]
 80022ca:	f023 0207 	bic.w	r2, r3, #7
 80022ce:	4965      	ldr	r1, [pc, #404]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80022d0:	683b      	ldr	r3, [r7, #0]
 80022d2:	4313      	orrs	r3, r2
 80022d4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80022d6:	4b63      	ldr	r3, [pc, #396]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80022d8:	681b      	ldr	r3, [r3, #0]
 80022da:	f003 0307 	and.w	r3, r3, #7
 80022de:	683a      	ldr	r2, [r7, #0]
 80022e0:	429a      	cmp	r2, r3
 80022e2:	d001      	beq.n	80022e8 <HAL_RCC_ClockConfig+0x44>
  {
    return HAL_ERROR;
 80022e4:	2301      	movs	r3, #1
 80022e6:	e0b8      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
  }
}

#endif /* FLASH_ACR_LATENCY */
/*-------------------------- HCLK Configuration --------------------------*/
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80022e8:	687b      	ldr	r3, [r7, #4]
 80022ea:	681b      	ldr	r3, [r3, #0]
 80022ec:	f003 0302 	and.w	r3, r3, #2
 80022f0:	2b00      	cmp	r3, #0
 80022f2:	d020      	beq.n	8002336 <HAL_RCC_ClockConfig+0x92>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
    a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	681b      	ldr	r3, [r3, #0]
 80022f8:	f003 0304 	and.w	r3, r3, #4
 80022fc:	2b00      	cmp	r3, #0
 80022fe:	d005      	beq.n	800230c <HAL_RCC_ClockConfig+0x68>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002300:	4b59      	ldr	r3, [pc, #356]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002302:	685b      	ldr	r3, [r3, #4]
 8002304:	4a58      	ldr	r2, [pc, #352]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002306:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
 800230a:	6053      	str	r3, [r2, #4]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800230c:	687b      	ldr	r3, [r7, #4]
 800230e:	681b      	ldr	r3, [r3, #0]
 8002310:	f003 0308 	and.w	r3, r3, #8
 8002314:	2b00      	cmp	r3, #0
 8002316:	d005      	beq.n	8002324 <HAL_RCC_ClockConfig+0x80>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002318:	4b53      	ldr	r3, [pc, #332]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800231a:	685b      	ldr	r3, [r3, #4]
 800231c:	4a52      	ldr	r2, [pc, #328]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800231e:	f443 5360 	orr.w	r3, r3, #14336	; 0x3800
 8002322:	6053      	str	r3, [r2, #4]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002324:	4b50      	ldr	r3, [pc, #320]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002326:	685b      	ldr	r3, [r3, #4]
 8002328:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800232c:	687b      	ldr	r3, [r7, #4]
 800232e:	689b      	ldr	r3, [r3, #8]
 8002330:	494d      	ldr	r1, [pc, #308]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002332:	4313      	orrs	r3, r2
 8002334:	604b      	str	r3, [r1, #4]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002336:	687b      	ldr	r3, [r7, #4]
 8002338:	681b      	ldr	r3, [r3, #0]
 800233a:	f003 0301 	and.w	r3, r3, #1
 800233e:	2b00      	cmp	r3, #0
 8002340:	d040      	beq.n	80023c4 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002342:	687b      	ldr	r3, [r7, #4]
 8002344:	685b      	ldr	r3, [r3, #4]
 8002346:	2b01      	cmp	r3, #1
 8002348:	d107      	bne.n	800235a <HAL_RCC_ClockConfig+0xb6>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800234a:	4b47      	ldr	r3, [pc, #284]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800234c:	681b      	ldr	r3, [r3, #0]
 800234e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002352:	2b00      	cmp	r3, #0
 8002354:	d115      	bne.n	8002382 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8002356:	2301      	movs	r3, #1
 8002358:	e07f      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800235a:	687b      	ldr	r3, [r7, #4]
 800235c:	685b      	ldr	r3, [r3, #4]
 800235e:	2b02      	cmp	r3, #2
 8002360:	d107      	bne.n	8002372 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002362:	4b41      	ldr	r3, [pc, #260]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002364:	681b      	ldr	r3, [r3, #0]
 8002366:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800236a:	2b00      	cmp	r3, #0
 800236c:	d109      	bne.n	8002382 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800236e:	2301      	movs	r3, #1
 8002370:	e073      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002372:	4b3d      	ldr	r3, [pc, #244]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002374:	681b      	ldr	r3, [r3, #0]
 8002376:	f003 0302 	and.w	r3, r3, #2
 800237a:	2b00      	cmp	r3, #0
 800237c:	d101      	bne.n	8002382 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800237e:	2301      	movs	r3, #1
 8002380:	e06b      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002382:	4b39      	ldr	r3, [pc, #228]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002384:	685b      	ldr	r3, [r3, #4]
 8002386:	f023 0203 	bic.w	r2, r3, #3
 800238a:	687b      	ldr	r3, [r7, #4]
 800238c:	685b      	ldr	r3, [r3, #4]
 800238e:	4936      	ldr	r1, [pc, #216]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002390:	4313      	orrs	r3, r2
 8002392:	604b      	str	r3, [r1, #4]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8002394:	f7ff fa0e 	bl	80017b4 <HAL_GetTick>
 8002398:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800239a:	e00a      	b.n	80023b2 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800239c:	f7ff fa0a 	bl	80017b4 <HAL_GetTick>
 80023a0:	4602      	mov	r2, r0
 80023a2:	68fb      	ldr	r3, [r7, #12]
 80023a4:	1ad3      	subs	r3, r2, r3
 80023a6:	f241 3288 	movw	r2, #5000	; 0x1388
 80023aa:	4293      	cmp	r3, r2
 80023ac:	d901      	bls.n	80023b2 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 80023ae:	2303      	movs	r3, #3
 80023b0:	e053      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80023b2:	4b2d      	ldr	r3, [pc, #180]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 80023b4:	685b      	ldr	r3, [r3, #4]
 80023b6:	f003 020c 	and.w	r2, r3, #12
 80023ba:	687b      	ldr	r3, [r7, #4]
 80023bc:	685b      	ldr	r3, [r3, #4]
 80023be:	009b      	lsls	r3, r3, #2
 80023c0:	429a      	cmp	r2, r3
 80023c2:	d1eb      	bne.n	800239c <HAL_RCC_ClockConfig+0xf8>
    }
  }

#if defined(FLASH_ACR_LATENCY)
  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80023c4:	4b27      	ldr	r3, [pc, #156]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80023c6:	681b      	ldr	r3, [r3, #0]
 80023c8:	f003 0307 	and.w	r3, r3, #7
 80023cc:	683a      	ldr	r2, [r7, #0]
 80023ce:	429a      	cmp	r2, r3
 80023d0:	d210      	bcs.n	80023f4 <HAL_RCC_ClockConfig+0x150>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80023d2:	4b24      	ldr	r3, [pc, #144]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80023d4:	681b      	ldr	r3, [r3, #0]
 80023d6:	f023 0207 	bic.w	r2, r3, #7
 80023da:	4922      	ldr	r1, [pc, #136]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80023dc:	683b      	ldr	r3, [r7, #0]
 80023de:	4313      	orrs	r3, r2
 80023e0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80023e2:	4b20      	ldr	r3, [pc, #128]	; (8002464 <HAL_RCC_ClockConfig+0x1c0>)
 80023e4:	681b      	ldr	r3, [r3, #0]
 80023e6:	f003 0307 	and.w	r3, r3, #7
 80023ea:	683a      	ldr	r2, [r7, #0]
 80023ec:	429a      	cmp	r2, r3
 80023ee:	d001      	beq.n	80023f4 <HAL_RCC_ClockConfig+0x150>
  {
    return HAL_ERROR;
 80023f0:	2301      	movs	r3, #1
 80023f2:	e032      	b.n	800245a <HAL_RCC_ClockConfig+0x1b6>
  }
}
#endif /* FLASH_ACR_LATENCY */

/*-------------------------- PCLK1 Configuration ---------------------------*/
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80023f4:	687b      	ldr	r3, [r7, #4]
 80023f6:	681b      	ldr	r3, [r3, #0]
 80023f8:	f003 0304 	and.w	r3, r3, #4
 80023fc:	2b00      	cmp	r3, #0
 80023fe:	d008      	beq.n	8002412 <HAL_RCC_ClockConfig+0x16e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002400:	4b19      	ldr	r3, [pc, #100]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002402:	685b      	ldr	r3, [r3, #4]
 8002404:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8002408:	687b      	ldr	r3, [r7, #4]
 800240a:	68db      	ldr	r3, [r3, #12]
 800240c:	4916      	ldr	r1, [pc, #88]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800240e:	4313      	orrs	r3, r2
 8002410:	604b      	str	r3, [r1, #4]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002412:	687b      	ldr	r3, [r7, #4]
 8002414:	681b      	ldr	r3, [r3, #0]
 8002416:	f003 0308 	and.w	r3, r3, #8
 800241a:	2b00      	cmp	r3, #0
 800241c:	d009      	beq.n	8002432 <HAL_RCC_ClockConfig+0x18e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800241e:	4b12      	ldr	r3, [pc, #72]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 8002420:	685b      	ldr	r3, [r3, #4]
 8002422:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8002426:	687b      	ldr	r3, [r7, #4]
 8002428:	691b      	ldr	r3, [r3, #16]
 800242a:	00db      	lsls	r3, r3, #3
 800242c:	490e      	ldr	r1, [pc, #56]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800242e:	4313      	orrs	r3, r2
 8002430:	604b      	str	r3, [r1, #4]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002432:	f000 f821 	bl	8002478 <HAL_RCC_GetSysClockFreq>
 8002436:	4602      	mov	r2, r0
 8002438:	4b0b      	ldr	r3, [pc, #44]	; (8002468 <HAL_RCC_ClockConfig+0x1c4>)
 800243a:	685b      	ldr	r3, [r3, #4]
 800243c:	091b      	lsrs	r3, r3, #4
 800243e:	f003 030f 	and.w	r3, r3, #15
 8002442:	490a      	ldr	r1, [pc, #40]	; (800246c <HAL_RCC_ClockConfig+0x1c8>)
 8002444:	5ccb      	ldrb	r3, [r1, r3]
 8002446:	fa22 f303 	lsr.w	r3, r2, r3
 800244a:	4a09      	ldr	r2, [pc, #36]	; (8002470 <HAL_RCC_ClockConfig+0x1cc>)
 800244c:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
 800244e:	4b09      	ldr	r3, [pc, #36]	; (8002474 <HAL_RCC_ClockConfig+0x1d0>)
 8002450:	681b      	ldr	r3, [r3, #0]
 8002452:	4618      	mov	r0, r3
 8002454:	f7ff f97e 	bl	8001754 <HAL_InitTick>

  return HAL_OK;
 8002458:	2300      	movs	r3, #0
}
 800245a:	4618      	mov	r0, r3
 800245c:	3710      	adds	r7, #16
 800245e:	46bd      	mov	sp, r7
 8002460:	bd80      	pop	{r7, pc}
 8002462:	bf00      	nop
 8002464:	40022000 	.word	0x40022000
 8002468:	40021000 	.word	0x40021000
 800246c:	08030940 	.word	0x08030940
 8002470:	20000000 	.word	0x20000000
 8002474:	20000004 	.word	0x20000004

08002478 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8002478:	b490      	push	{r4, r7}
 800247a:	b08a      	sub	sp, #40	; 0x28
 800247c:	af00      	add	r7, sp, #0
#if defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 800247e:	4b29      	ldr	r3, [pc, #164]	; (8002524 <HAL_RCC_GetSysClockFreq+0xac>)
 8002480:	1d3c      	adds	r4, r7, #4
 8002482:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002484:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
#if defined(RCC_CFGR2_PREDIV1)
  const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002488:	f240 2301 	movw	r3, #513	; 0x201
 800248c:	803b      	strh	r3, [r7, #0]
#endif /*RCC_CFGR2_PREDIV1*/

#endif
  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
 800248e:	2300      	movs	r3, #0
 8002490:	61fb      	str	r3, [r7, #28]
 8002492:	2300      	movs	r3, #0
 8002494:	61bb      	str	r3, [r7, #24]
 8002496:	2300      	movs	r3, #0
 8002498:	627b      	str	r3, [r7, #36]	; 0x24
 800249a:	2300      	movs	r3, #0
 800249c:	617b      	str	r3, [r7, #20]
  uint32_t sysclockfreq = 0U;
 800249e:	2300      	movs	r3, #0
 80024a0:	623b      	str	r3, [r7, #32]
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0U, pll2mul = 0U;
#endif /*RCC_CFGR2_PREDIV1SRC*/

  tmpreg = RCC->CFGR;
 80024a2:	4b21      	ldr	r3, [pc, #132]	; (8002528 <HAL_RCC_GetSysClockFreq+0xb0>)
 80024a4:	685b      	ldr	r3, [r3, #4]
 80024a6:	61fb      	str	r3, [r7, #28]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80024a8:	69fb      	ldr	r3, [r7, #28]
 80024aa:	f003 030c 	and.w	r3, r3, #12
 80024ae:	2b04      	cmp	r3, #4
 80024b0:	d002      	beq.n	80024b8 <HAL_RCC_GetSysClockFreq+0x40>
 80024b2:	2b08      	cmp	r3, #8
 80024b4:	d003      	beq.n	80024be <HAL_RCC_GetSysClockFreq+0x46>
 80024b6:	e02b      	b.n	8002510 <HAL_RCC_GetSysClockFreq+0x98>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80024b8:	4b1c      	ldr	r3, [pc, #112]	; (800252c <HAL_RCC_GetSysClockFreq+0xb4>)
 80024ba:	623b      	str	r3, [r7, #32]
      break;
 80024bc:	e02b      	b.n	8002516 <HAL_RCC_GetSysClockFreq+0x9e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 80024be:	69fb      	ldr	r3, [r7, #28]
 80024c0:	0c9b      	lsrs	r3, r3, #18
 80024c2:	f003 030f 	and.w	r3, r3, #15
 80024c6:	3328      	adds	r3, #40	; 0x28
 80024c8:	443b      	add	r3, r7
 80024ca:	f813 3c24 	ldrb.w	r3, [r3, #-36]
 80024ce:	617b      	str	r3, [r7, #20]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80024d0:	69fb      	ldr	r3, [r7, #28]
 80024d2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80024d6:	2b00      	cmp	r3, #0
 80024d8:	d012      	beq.n	8002500 <HAL_RCC_GetSysClockFreq+0x88>
      {
#if defined(RCC_CFGR2_PREDIV1)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
#else
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 80024da:	4b13      	ldr	r3, [pc, #76]	; (8002528 <HAL_RCC_GetSysClockFreq+0xb0>)
 80024dc:	685b      	ldr	r3, [r3, #4]
 80024de:	0c5b      	lsrs	r3, r3, #17
 80024e0:	f003 0301 	and.w	r3, r3, #1
 80024e4:	3328      	adds	r3, #40	; 0x28
 80024e6:	443b      	add	r3, r7
 80024e8:	f813 3c28 	ldrb.w	r3, [r3, #-40]
 80024ec:	61bb      	str	r3, [r7, #24]
        {
          pllclk = pllclk / 2;
        }
#else
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 80024ee:	697b      	ldr	r3, [r7, #20]
 80024f0:	4a0e      	ldr	r2, [pc, #56]	; (800252c <HAL_RCC_GetSysClockFreq+0xb4>)
 80024f2:	fb03 f202 	mul.w	r2, r3, r2
 80024f6:	69bb      	ldr	r3, [r7, #24]
 80024f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80024fc:	627b      	str	r3, [r7, #36]	; 0x24
 80024fe:	e004      	b.n	800250a <HAL_RCC_GetSysClockFreq+0x92>
#endif /*RCC_CFGR2_PREDIV1SRC*/
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8002500:	697b      	ldr	r3, [r7, #20]
 8002502:	4a0b      	ldr	r2, [pc, #44]	; (8002530 <HAL_RCC_GetSysClockFreq+0xb8>)
 8002504:	fb02 f303 	mul.w	r3, r2, r3
 8002508:	627b      	str	r3, [r7, #36]	; 0x24
      }
      sysclockfreq = pllclk;
 800250a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800250c:	623b      	str	r3, [r7, #32]
      break;
 800250e:	e002      	b.n	8002516 <HAL_RCC_GetSysClockFreq+0x9e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    default: /* HSI used as system clock */
    {
      sysclockfreq = HSI_VALUE;
 8002510:	4b06      	ldr	r3, [pc, #24]	; (800252c <HAL_RCC_GetSysClockFreq+0xb4>)
 8002512:	623b      	str	r3, [r7, #32]
      break;
 8002514:	bf00      	nop
    }
  }
  return sysclockfreq;
 8002516:	6a3b      	ldr	r3, [r7, #32]
}
 8002518:	4618      	mov	r0, r3
 800251a:	3728      	adds	r7, #40	; 0x28
 800251c:	46bd      	mov	sp, r7
 800251e:	bc90      	pop	{r4, r7}
 8002520:	4770      	bx	lr
 8002522:	bf00      	nop
 8002524:	08026710 	.word	0x08026710
 8002528:	40021000 	.word	0x40021000
 800252c:	007a1200 	.word	0x007a1200
 8002530:	003d0900 	.word	0x003d0900

08002534 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002534:	b480      	push	{r7}
 8002536:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8002538:	4b02      	ldr	r3, [pc, #8]	; (8002544 <HAL_RCC_GetHCLKFreq+0x10>)
 800253a:	681b      	ldr	r3, [r3, #0]
}
 800253c:	4618      	mov	r0, r3
 800253e:	46bd      	mov	sp, r7
 8002540:	bc80      	pop	{r7}
 8002542:	4770      	bx	lr
 8002544:	20000000 	.word	0x20000000

08002548 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8002548:	b580      	push	{r7, lr}
 800254a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800254c:	f7ff fff2 	bl	8002534 <HAL_RCC_GetHCLKFreq>
 8002550:	4602      	mov	r2, r0
 8002552:	4b05      	ldr	r3, [pc, #20]	; (8002568 <HAL_RCC_GetPCLK1Freq+0x20>)
 8002554:	685b      	ldr	r3, [r3, #4]
 8002556:	0a1b      	lsrs	r3, r3, #8
 8002558:	f003 0307 	and.w	r3, r3, #7
 800255c:	4903      	ldr	r1, [pc, #12]	; (800256c <HAL_RCC_GetPCLK1Freq+0x24>)
 800255e:	5ccb      	ldrb	r3, [r1, r3]
 8002560:	fa22 f303 	lsr.w	r3, r2, r3
}
 8002564:	4618      	mov	r0, r3
 8002566:	bd80      	pop	{r7, pc}
 8002568:	40021000 	.word	0x40021000
 800256c:	08030950 	.word	0x08030950

08002570 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8002570:	b580      	push	{r7, lr}
 8002572:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002574:	f7ff ffde 	bl	8002534 <HAL_RCC_GetHCLKFreq>
 8002578:	4602      	mov	r2, r0
 800257a:	4b05      	ldr	r3, [pc, #20]	; (8002590 <HAL_RCC_GetPCLK2Freq+0x20>)
 800257c:	685b      	ldr	r3, [r3, #4]
 800257e:	0adb      	lsrs	r3, r3, #11
 8002580:	f003 0307 	and.w	r3, r3, #7
 8002584:	4903      	ldr	r1, [pc, #12]	; (8002594 <HAL_RCC_GetPCLK2Freq+0x24>)
 8002586:	5ccb      	ldrb	r3, [r1, r3]
 8002588:	fa22 f303 	lsr.w	r3, r2, r3
}
 800258c:	4618      	mov	r0, r3
 800258e:	bd80      	pop	{r7, pc}
 8002590:	40021000 	.word	0x40021000
 8002594:	08030950 	.word	0x08030950

08002598 <RCC_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
 8002598:	b480      	push	{r7}
 800259a:	b085      	sub	sp, #20
 800259c:	af00      	add	r7, sp, #0
 800259e:	6078      	str	r0, [r7, #4]
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 80025a0:	4b0a      	ldr	r3, [pc, #40]	; (80025cc <RCC_Delay+0x34>)
 80025a2:	681b      	ldr	r3, [r3, #0]
 80025a4:	4a0a      	ldr	r2, [pc, #40]	; (80025d0 <RCC_Delay+0x38>)
 80025a6:	fba2 2303 	umull	r2, r3, r2, r3
 80025aa:	0a5b      	lsrs	r3, r3, #9
 80025ac:	687a      	ldr	r2, [r7, #4]
 80025ae:	fb02 f303 	mul.w	r3, r2, r3
 80025b2:	60fb      	str	r3, [r7, #12]
  do
  {
    __NOP();
 80025b4:	bf00      	nop
  }
  while (Delay --);
 80025b6:	68fb      	ldr	r3, [r7, #12]
 80025b8:	1e5a      	subs	r2, r3, #1
 80025ba:	60fa      	str	r2, [r7, #12]
 80025bc:	2b00      	cmp	r3, #0
 80025be:	d1f9      	bne.n	80025b4 <RCC_Delay+0x1c>
}
 80025c0:	bf00      	nop
 80025c2:	bf00      	nop
 80025c4:	3714      	adds	r7, #20
 80025c6:	46bd      	mov	sp, r7
 80025c8:	bc80      	pop	{r7}
 80025ca:	4770      	bx	lr
 80025cc:	20000000 	.word	0x20000000
 80025d0:	10624dd3 	.word	0x10624dd3

080025d4 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80025d4:	b480      	push	{r7}
 80025d6:	b085      	sub	sp, #20
 80025d8:	af00      	add	r7, sp, #0
 80025da:	6078      	str	r0, [r7, #4]
 80025dc:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80025de:	687b      	ldr	r3, [r7, #4]
 80025e0:	681b      	ldr	r3, [r3, #0]
 80025e2:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80025e4:	687b      	ldr	r3, [r7, #4]
 80025e6:	4a33      	ldr	r2, [pc, #204]	; (80026b4 <TIM_Base_SetConfig+0xe0>)
 80025e8:	4293      	cmp	r3, r2
 80025ea:	d013      	beq.n	8002614 <TIM_Base_SetConfig+0x40>
 80025ec:	687b      	ldr	r3, [r7, #4]
 80025ee:	4a32      	ldr	r2, [pc, #200]	; (80026b8 <TIM_Base_SetConfig+0xe4>)
 80025f0:	4293      	cmp	r3, r2
 80025f2:	d00f      	beq.n	8002614 <TIM_Base_SetConfig+0x40>
 80025f4:	687b      	ldr	r3, [r7, #4]
 80025f6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80025fa:	d00b      	beq.n	8002614 <TIM_Base_SetConfig+0x40>
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	4a2f      	ldr	r2, [pc, #188]	; (80026bc <TIM_Base_SetConfig+0xe8>)
 8002600:	4293      	cmp	r3, r2
 8002602:	d007      	beq.n	8002614 <TIM_Base_SetConfig+0x40>
 8002604:	687b      	ldr	r3, [r7, #4]
 8002606:	4a2e      	ldr	r2, [pc, #184]	; (80026c0 <TIM_Base_SetConfig+0xec>)
 8002608:	4293      	cmp	r3, r2
 800260a:	d003      	beq.n	8002614 <TIM_Base_SetConfig+0x40>
 800260c:	687b      	ldr	r3, [r7, #4]
 800260e:	4a2d      	ldr	r2, [pc, #180]	; (80026c4 <TIM_Base_SetConfig+0xf0>)
 8002610:	4293      	cmp	r3, r2
 8002612:	d108      	bne.n	8002626 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002614:	68fb      	ldr	r3, [r7, #12]
 8002616:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800261a:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800261c:	683b      	ldr	r3, [r7, #0]
 800261e:	685b      	ldr	r3, [r3, #4]
 8002620:	68fa      	ldr	r2, [r7, #12]
 8002622:	4313      	orrs	r3, r2
 8002624:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	4a22      	ldr	r2, [pc, #136]	; (80026b4 <TIM_Base_SetConfig+0xe0>)
 800262a:	4293      	cmp	r3, r2
 800262c:	d013      	beq.n	8002656 <TIM_Base_SetConfig+0x82>
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	4a21      	ldr	r2, [pc, #132]	; (80026b8 <TIM_Base_SetConfig+0xe4>)
 8002632:	4293      	cmp	r3, r2
 8002634:	d00f      	beq.n	8002656 <TIM_Base_SetConfig+0x82>
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800263c:	d00b      	beq.n	8002656 <TIM_Base_SetConfig+0x82>
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	4a1e      	ldr	r2, [pc, #120]	; (80026bc <TIM_Base_SetConfig+0xe8>)
 8002642:	4293      	cmp	r3, r2
 8002644:	d007      	beq.n	8002656 <TIM_Base_SetConfig+0x82>
 8002646:	687b      	ldr	r3, [r7, #4]
 8002648:	4a1d      	ldr	r2, [pc, #116]	; (80026c0 <TIM_Base_SetConfig+0xec>)
 800264a:	4293      	cmp	r3, r2
 800264c:	d003      	beq.n	8002656 <TIM_Base_SetConfig+0x82>
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	4a1c      	ldr	r2, [pc, #112]	; (80026c4 <TIM_Base_SetConfig+0xf0>)
 8002652:	4293      	cmp	r3, r2
 8002654:	d108      	bne.n	8002668 <TIM_Base_SetConfig+0x94>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8002656:	68fb      	ldr	r3, [r7, #12]
 8002658:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800265c:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800265e:	683b      	ldr	r3, [r7, #0]
 8002660:	68db      	ldr	r3, [r3, #12]
 8002662:	68fa      	ldr	r2, [r7, #12]
 8002664:	4313      	orrs	r3, r2
 8002666:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002668:	68fb      	ldr	r3, [r7, #12]
 800266a:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 800266e:	683b      	ldr	r3, [r7, #0]
 8002670:	695b      	ldr	r3, [r3, #20]
 8002672:	4313      	orrs	r3, r2
 8002674:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8002676:	687b      	ldr	r3, [r7, #4]
 8002678:	68fa      	ldr	r2, [r7, #12]
 800267a:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800267c:	683b      	ldr	r3, [r7, #0]
 800267e:	689a      	ldr	r2, [r3, #8]
 8002680:	687b      	ldr	r3, [r7, #4]
 8002682:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8002684:	683b      	ldr	r3, [r7, #0]
 8002686:	681a      	ldr	r2, [r3, #0]
 8002688:	687b      	ldr	r3, [r7, #4]
 800268a:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800268c:	687b      	ldr	r3, [r7, #4]
 800268e:	4a09      	ldr	r2, [pc, #36]	; (80026b4 <TIM_Base_SetConfig+0xe0>)
 8002690:	4293      	cmp	r3, r2
 8002692:	d003      	beq.n	800269c <TIM_Base_SetConfig+0xc8>
 8002694:	687b      	ldr	r3, [r7, #4]
 8002696:	4a08      	ldr	r2, [pc, #32]	; (80026b8 <TIM_Base_SetConfig+0xe4>)
 8002698:	4293      	cmp	r3, r2
 800269a:	d103      	bne.n	80026a4 <TIM_Base_SetConfig+0xd0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800269c:	683b      	ldr	r3, [r7, #0]
 800269e:	691a      	ldr	r2, [r3, #16]
 80026a0:	687b      	ldr	r3, [r7, #4]
 80026a2:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80026a4:	687b      	ldr	r3, [r7, #4]
 80026a6:	2201      	movs	r2, #1
 80026a8:	615a      	str	r2, [r3, #20]
}
 80026aa:	bf00      	nop
 80026ac:	3714      	adds	r7, #20
 80026ae:	46bd      	mov	sp, r7
 80026b0:	bc80      	pop	{r7}
 80026b2:	4770      	bx	lr
 80026b4:	40012c00 	.word	0x40012c00
 80026b8:	40013400 	.word	0x40013400
 80026bc:	40000400 	.word	0x40000400
 80026c0:	40000800 	.word	0x40000800
 80026c4:	40000c00 	.word	0x40000c00

080026c8 <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80026c8:	b580      	push	{r7, lr}
 80026ca:	b082      	sub	sp, #8
 80026cc:	af00      	add	r7, sp, #0
 80026ce:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80026d0:	687b      	ldr	r3, [r7, #4]
 80026d2:	2b00      	cmp	r3, #0
 80026d4:	d101      	bne.n	80026da <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80026d6:	2301      	movs	r3, #1
 80026d8:	e03f      	b.n	800275a <HAL_UART_Init+0x92>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart->gState == HAL_UART_STATE_RESET)
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80026e0:	b2db      	uxtb	r3, r3
 80026e2:	2b00      	cmp	r3, #0
 80026e4:	d106      	bne.n	80026f4 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	2200      	movs	r2, #0
 80026ea:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80026ee:	6878      	ldr	r0, [r7, #4]
 80026f0:	f7fe feba 	bl	8001468 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80026f4:	687b      	ldr	r3, [r7, #4]
 80026f6:	2224      	movs	r2, #36	; 0x24
 80026f8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 80026fc:	687b      	ldr	r3, [r7, #4]
 80026fe:	681b      	ldr	r3, [r3, #0]
 8002700:	68da      	ldr	r2, [r3, #12]
 8002702:	687b      	ldr	r3, [r7, #4]
 8002704:	681b      	ldr	r3, [r3, #0]
 8002706:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800270a:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 800270c:	6878      	ldr	r0, [r7, #4]
 800270e:	f000 f829 	bl	8002764 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002712:	687b      	ldr	r3, [r7, #4]
 8002714:	681b      	ldr	r3, [r3, #0]
 8002716:	691a      	ldr	r2, [r3, #16]
 8002718:	687b      	ldr	r3, [r7, #4]
 800271a:	681b      	ldr	r3, [r3, #0]
 800271c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002720:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002722:	687b      	ldr	r3, [r7, #4]
 8002724:	681b      	ldr	r3, [r3, #0]
 8002726:	695a      	ldr	r2, [r3, #20]
 8002728:	687b      	ldr	r3, [r7, #4]
 800272a:	681b      	ldr	r3, [r3, #0]
 800272c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002730:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8002732:	687b      	ldr	r3, [r7, #4]
 8002734:	681b      	ldr	r3, [r3, #0]
 8002736:	68da      	ldr	r2, [r3, #12]
 8002738:	687b      	ldr	r3, [r7, #4]
 800273a:	681b      	ldr	r3, [r3, #0]
 800273c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002740:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	2200      	movs	r2, #0
 8002746:	641a      	str	r2, [r3, #64]	; 0x40
  huart->gState = HAL_UART_STATE_READY;
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	2220      	movs	r2, #32
 800274c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  huart->RxState = HAL_UART_STATE_READY;
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	2220      	movs	r2, #32
 8002754:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

  return HAL_OK;
 8002758:	2300      	movs	r3, #0
}
 800275a:	4618      	mov	r0, r3
 800275c:	3708      	adds	r7, #8
 800275e:	46bd      	mov	sp, r7
 8002760:	bd80      	pop	{r7, pc}
	...

08002764 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002764:	b580      	push	{r7, lr}
 8002766:	b084      	sub	sp, #16
 8002768:	af00      	add	r7, sp, #0
 800276a:	6078      	str	r0, [r7, #4]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800276c:	687b      	ldr	r3, [r7, #4]
 800276e:	681b      	ldr	r3, [r3, #0]
 8002770:	691b      	ldr	r3, [r3, #16]
 8002772:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8002776:	687b      	ldr	r3, [r7, #4]
 8002778:	68da      	ldr	r2, [r3, #12]
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	681b      	ldr	r3, [r3, #0]
 800277e:	430a      	orrs	r2, r1
 8002780:	611a      	str	r2, [r3, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002782:	687b      	ldr	r3, [r7, #4]
 8002784:	689a      	ldr	r2, [r3, #8]
 8002786:	687b      	ldr	r3, [r7, #4]
 8002788:	691b      	ldr	r3, [r3, #16]
 800278a:	431a      	orrs	r2, r3
 800278c:	687b      	ldr	r3, [r7, #4]
 800278e:	695b      	ldr	r3, [r3, #20]
 8002790:	4313      	orrs	r3, r2
 8002792:	60bb      	str	r3, [r7, #8]
  MODIFY_REG(huart->Instance->CR1,
 8002794:	687b      	ldr	r3, [r7, #4]
 8002796:	681b      	ldr	r3, [r3, #0]
 8002798:	68db      	ldr	r3, [r3, #12]
 800279a:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 800279e:	f023 030c 	bic.w	r3, r3, #12
 80027a2:	687a      	ldr	r2, [r7, #4]
 80027a4:	6812      	ldr	r2, [r2, #0]
 80027a6:	68b9      	ldr	r1, [r7, #8]
 80027a8:	430b      	orrs	r3, r1
 80027aa:	60d3      	str	r3, [r2, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 80027ac:	687b      	ldr	r3, [r7, #4]
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	695b      	ldr	r3, [r3, #20]
 80027b2:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 80027b6:	687b      	ldr	r3, [r7, #4]
 80027b8:	699a      	ldr	r2, [r3, #24]
 80027ba:	687b      	ldr	r3, [r7, #4]
 80027bc:	681b      	ldr	r3, [r3, #0]
 80027be:	430a      	orrs	r2, r1
 80027c0:	615a      	str	r2, [r3, #20]


  if(huart->Instance == USART1)
 80027c2:	687b      	ldr	r3, [r7, #4]
 80027c4:	681b      	ldr	r3, [r3, #0]
 80027c6:	4a2c      	ldr	r2, [pc, #176]	; (8002878 <UART_SetConfig+0x114>)
 80027c8:	4293      	cmp	r3, r2
 80027ca:	d103      	bne.n	80027d4 <UART_SetConfig+0x70>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
 80027cc:	f7ff fed0 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 80027d0:	60f8      	str	r0, [r7, #12]
 80027d2:	e002      	b.n	80027da <UART_SetConfig+0x76>
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 80027d4:	f7ff feb8 	bl	8002548 <HAL_RCC_GetPCLK1Freq>
 80027d8:	60f8      	str	r0, [r7, #12]
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 80027da:	68fa      	ldr	r2, [r7, #12]
 80027dc:	4613      	mov	r3, r2
 80027de:	009b      	lsls	r3, r3, #2
 80027e0:	4413      	add	r3, r2
 80027e2:	009a      	lsls	r2, r3, #2
 80027e4:	441a      	add	r2, r3
 80027e6:	687b      	ldr	r3, [r7, #4]
 80027e8:	685b      	ldr	r3, [r3, #4]
 80027ea:	009b      	lsls	r3, r3, #2
 80027ec:	fbb2 f3f3 	udiv	r3, r2, r3
 80027f0:	4a22      	ldr	r2, [pc, #136]	; (800287c <UART_SetConfig+0x118>)
 80027f2:	fba2 2303 	umull	r2, r3, r2, r3
 80027f6:	095b      	lsrs	r3, r3, #5
 80027f8:	0119      	lsls	r1, r3, #4
 80027fa:	68fa      	ldr	r2, [r7, #12]
 80027fc:	4613      	mov	r3, r2
 80027fe:	009b      	lsls	r3, r3, #2
 8002800:	4413      	add	r3, r2
 8002802:	009a      	lsls	r2, r3, #2
 8002804:	441a      	add	r2, r3
 8002806:	687b      	ldr	r3, [r7, #4]
 8002808:	685b      	ldr	r3, [r3, #4]
 800280a:	009b      	lsls	r3, r3, #2
 800280c:	fbb2 f2f3 	udiv	r2, r2, r3
 8002810:	4b1a      	ldr	r3, [pc, #104]	; (800287c <UART_SetConfig+0x118>)
 8002812:	fba3 0302 	umull	r0, r3, r3, r2
 8002816:	095b      	lsrs	r3, r3, #5
 8002818:	2064      	movs	r0, #100	; 0x64
 800281a:	fb00 f303 	mul.w	r3, r0, r3
 800281e:	1ad3      	subs	r3, r2, r3
 8002820:	011b      	lsls	r3, r3, #4
 8002822:	3332      	adds	r3, #50	; 0x32
 8002824:	4a15      	ldr	r2, [pc, #84]	; (800287c <UART_SetConfig+0x118>)
 8002826:	fba2 2303 	umull	r2, r3, r2, r3
 800282a:	095b      	lsrs	r3, r3, #5
 800282c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002830:	4419      	add	r1, r3
 8002832:	68fa      	ldr	r2, [r7, #12]
 8002834:	4613      	mov	r3, r2
 8002836:	009b      	lsls	r3, r3, #2
 8002838:	4413      	add	r3, r2
 800283a:	009a      	lsls	r2, r3, #2
 800283c:	441a      	add	r2, r3
 800283e:	687b      	ldr	r3, [r7, #4]
 8002840:	685b      	ldr	r3, [r3, #4]
 8002842:	009b      	lsls	r3, r3, #2
 8002844:	fbb2 f2f3 	udiv	r2, r2, r3
 8002848:	4b0c      	ldr	r3, [pc, #48]	; (800287c <UART_SetConfig+0x118>)
 800284a:	fba3 0302 	umull	r0, r3, r3, r2
 800284e:	095b      	lsrs	r3, r3, #5
 8002850:	2064      	movs	r0, #100	; 0x64
 8002852:	fb00 f303 	mul.w	r3, r0, r3
 8002856:	1ad3      	subs	r3, r2, r3
 8002858:	011b      	lsls	r3, r3, #4
 800285a:	3332      	adds	r3, #50	; 0x32
 800285c:	4a07      	ldr	r2, [pc, #28]	; (800287c <UART_SetConfig+0x118>)
 800285e:	fba2 2303 	umull	r2, r3, r2, r3
 8002862:	095b      	lsrs	r3, r3, #5
 8002864:	f003 020f 	and.w	r2, r3, #15
 8002868:	687b      	ldr	r3, [r7, #4]
 800286a:	681b      	ldr	r3, [r3, #0]
 800286c:	440a      	add	r2, r1
 800286e:	609a      	str	r2, [r3, #8]
#endif /* USART_CR1_OVER8 */
}
 8002870:	bf00      	nop
 8002872:	3710      	adds	r7, #16
 8002874:	46bd      	mov	sp, r7
 8002876:	bd80      	pop	{r7, pc}
 8002878:	40013800 	.word	0x40013800
 800287c:	51eb851f 	.word	0x51eb851f

08002880 <__enable_irq>:
{
 8002880:	b480      	push	{r7}
 8002882:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsie i" : : : "memory");
 8002884:	b662      	cpsie	i
}
 8002886:	bf00      	nop
 8002888:	46bd      	mov	sp, r7
 800288a:	bc80      	pop	{r7}
 800288c:	4770      	bx	lr

0800288e <__disable_irq>:
{
 800288e:	b480      	push	{r7}
 8002890:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8002892:	b672      	cpsid	i
}
 8002894:	bf00      	nop
 8002896:	46bd      	mov	sp, r7
 8002898:	bc80      	pop	{r7}
 800289a:	4770      	bx	lr

0800289c <__NVIC_EnableIRQ>:
{
 800289c:	b480      	push	{r7}
 800289e:	b083      	sub	sp, #12
 80028a0:	af00      	add	r7, sp, #0
 80028a2:	4603      	mov	r3, r0
 80028a4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80028a6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80028aa:	2b00      	cmp	r3, #0
 80028ac:	db0b      	blt.n	80028c6 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80028ae:	79fb      	ldrb	r3, [r7, #7]
 80028b0:	f003 021f 	and.w	r2, r3, #31
 80028b4:	4906      	ldr	r1, [pc, #24]	; (80028d0 <__NVIC_EnableIRQ+0x34>)
 80028b6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80028ba:	095b      	lsrs	r3, r3, #5
 80028bc:	2001      	movs	r0, #1
 80028be:	fa00 f202 	lsl.w	r2, r0, r2
 80028c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80028c6:	bf00      	nop
 80028c8:	370c      	adds	r7, #12
 80028ca:	46bd      	mov	sp, r7
 80028cc:	bc80      	pop	{r7}
 80028ce:	4770      	bx	lr
 80028d0:	e000e100 	.word	0xe000e100

080028d4 <__NVIC_SetPriority>:
{
 80028d4:	b480      	push	{r7}
 80028d6:	b083      	sub	sp, #12
 80028d8:	af00      	add	r7, sp, #0
 80028da:	4603      	mov	r3, r0
 80028dc:	6039      	str	r1, [r7, #0]
 80028de:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80028e0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80028e4:	2b00      	cmp	r3, #0
 80028e6:	db0a      	blt.n	80028fe <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80028e8:	683b      	ldr	r3, [r7, #0]
 80028ea:	b2da      	uxtb	r2, r3
 80028ec:	490c      	ldr	r1, [pc, #48]	; (8002920 <__NVIC_SetPriority+0x4c>)
 80028ee:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80028f2:	0112      	lsls	r2, r2, #4
 80028f4:	b2d2      	uxtb	r2, r2
 80028f6:	440b      	add	r3, r1
 80028f8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80028fc:	e00a      	b.n	8002914 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80028fe:	683b      	ldr	r3, [r7, #0]
 8002900:	b2da      	uxtb	r2, r3
 8002902:	4908      	ldr	r1, [pc, #32]	; (8002924 <__NVIC_SetPriority+0x50>)
 8002904:	79fb      	ldrb	r3, [r7, #7]
 8002906:	f003 030f 	and.w	r3, r3, #15
 800290a:	3b04      	subs	r3, #4
 800290c:	0112      	lsls	r2, r2, #4
 800290e:	b2d2      	uxtb	r2, r2
 8002910:	440b      	add	r3, r1
 8002912:	761a      	strb	r2, [r3, #24]
}
 8002914:	bf00      	nop
 8002916:	370c      	adds	r7, #12
 8002918:	46bd      	mov	sp, r7
 800291a:	bc80      	pop	{r7}
 800291c:	4770      	bx	lr
 800291e:	bf00      	nop
 8002920:	e000e100 	.word	0xe000e100
 8002924:	e000ed00 	.word	0xe000ed00

08002928 <motor_iterator>:
#ifndef N_GANGED
#define N_GANGED 0
#endif

static void motor_iterator (motor_iterator_callback_ptr callback)
{
 8002928:	b580      	push	{r7, lr}
 800292a:	b084      	sub	sp, #16
 800292c:	af00      	add	r7, sp, #0
 800292e:	6078      	str	r0, [r7, #4]
    motor_map_t motor;

    if(callback) for(motor.id = 0; motor.id < N_AXIS + N_GANGED; motor.id++)
 8002930:	687b      	ldr	r3, [r7, #4]
 8002932:	2b00      	cmp	r3, #0
 8002934:	d011      	beq.n	800295a <motor_iterator+0x32>
 8002936:	2300      	movs	r3, #0
 8002938:	733b      	strb	r3, [r7, #12]
 800293a:	e00b      	b.n	8002954 <motor_iterator+0x2c>
    {
        if(motor.id < N_AXIS)
 800293c:	7b3b      	ldrb	r3, [r7, #12]
 800293e:	2b02      	cmp	r3, #2
 8002940:	d801      	bhi.n	8002946 <motor_iterator+0x1e>
            motor.axis = motor.id;
 8002942:	7b3b      	ldrb	r3, [r7, #12]
 8002944:	737b      	strb	r3, [r7, #13]
            case Z2_MOTOR:
                motor.axis = Z_AXIS;
                break;
#endif
        }
        callback(motor);
 8002946:	687b      	ldr	r3, [r7, #4]
 8002948:	68f8      	ldr	r0, [r7, #12]
 800294a:	4798      	blx	r3
    if(callback) for(motor.id = 0; motor.id < N_AXIS + N_GANGED; motor.id++)
 800294c:	7b3b      	ldrb	r3, [r7, #12]
 800294e:	3301      	adds	r3, #1
 8002950:	b2db      	uxtb	r3, r3
 8002952:	733b      	strb	r3, [r7, #12]
 8002954:	7b3b      	ldrb	r3, [r7, #12]
 8002956:	2b02      	cmp	r3, #2
 8002958:	d9f0      	bls.n	800293c <motor_iterator+0x14>
    }
}
 800295a:	bf00      	nop
 800295c:	3710      	adds	r7, #16
 800295e:	46bd      	mov	sp, r7
 8002960:	bd80      	pop	{r7, pc}

08002962 <get_limits_cap>:

static limit_signals_t get_limits_cap (void)
{
 8002962:	b480      	push	{r7}
 8002964:	b083      	sub	sp, #12
 8002966:	af00      	add	r7, sp, #0
    limit_signals_t limits = {0};
 8002968:	2300      	movs	r3, #0
 800296a:	603b      	str	r3, [r7, #0]

#if X_LIMIT_BIT
    limits.min.x = On;
 800296c:	783b      	ldrb	r3, [r7, #0]
 800296e:	f043 0301 	orr.w	r3, r3, #1
 8002972:	703b      	strb	r3, [r7, #0]
#endif
#if Y_LIMIT_BIT
    limits.min.y = On;
 8002974:	783b      	ldrb	r3, [r7, #0]
 8002976:	f043 0302 	orr.w	r3, r3, #2
 800297a:	703b      	strb	r3, [r7, #0]
#endif
#if Z_LIMIT_BIT
    limits.min.z = On;
 800297c:	783b      	ldrb	r3, [r7, #0]
 800297e:	f043 0304 	orr.w	r3, r3, #4
 8002982:	703b      	strb	r3, [r7, #0]
#endif
#if V_LIMIT_BIT_MAX
    limits.max.v = On;
#endif

    return limits;
 8002984:	683b      	ldr	r3, [r7, #0]
 8002986:	607b      	str	r3, [r7, #4]
 8002988:	2300      	movs	r3, #0
 800298a:	793a      	ldrb	r2, [r7, #4]
 800298c:	f362 0307 	bfi	r3, r2, #0, #8
 8002990:	797a      	ldrb	r2, [r7, #5]
 8002992:	f362 230f 	bfi	r3, r2, #8, #8
 8002996:	79ba      	ldrb	r2, [r7, #6]
 8002998:	f362 4317 	bfi	r3, r2, #16, #8
 800299c:	79fa      	ldrb	r2, [r7, #7]
 800299e:	f362 631f 	bfi	r3, r2, #24, #8
}
 80029a2:	4618      	mov	r0, r3
 80029a4:	370c      	adds	r7, #12
 80029a6:	46bd      	mov	sp, r7
 80029a8:	bc80      	pop	{r7}
 80029aa:	4770      	bx	lr

080029ac <get_home_cap>:

static home_signals_t get_home_cap (void)
{
 80029ac:	b480      	push	{r7}
 80029ae:	b083      	sub	sp, #12
 80029b0:	af00      	add	r7, sp, #0
    home_signals_t home = {0};
 80029b2:	2300      	movs	r3, #0
 80029b4:	803b      	strh	r3, [r7, #0]
    home.secondary.z = On;
#endif

#endif // HOME_MASK

    return home;
 80029b6:	883b      	ldrh	r3, [r7, #0]
 80029b8:	80bb      	strh	r3, [r7, #4]
 80029ba:	2300      	movs	r3, #0
 80029bc:	793a      	ldrb	r2, [r7, #4]
 80029be:	f362 0307 	bfi	r3, r2, #0, #8
 80029c2:	797a      	ldrb	r2, [r7, #5]
 80029c4:	f362 230f 	bfi	r3, r2, #8, #8
}
 80029c8:	4618      	mov	r0, r3
 80029ca:	370c      	adds	r7, #12
 80029cc:	46bd      	mov	sp, r7
 80029ce:	bc80      	pop	{r7}
 80029d0:	4770      	bx	lr
	...

080029d4 <stepdirmap_init>:
#if (STEP_OUTMODE == GPIO_MAP) || (DIRECTION_OUTMODE == GPIO_MAP)

#define USE_STEPDIR_MAP 1

static void stepdirmap_init (settings_t *settings)
{
 80029d4:	b480      	push	{r7}
 80029d6:	b085      	sub	sp, #20
 80029d8:	af00      	add	r7, sp, #0
 80029da:	6078      	str	r0, [r7, #4]
    uint_fast8_t i;

#if STEP_OUTMODE == GPIO_MAP

    i = sizeof(step_outmap) / sizeof(uint32_t);
 80029dc:	2308      	movs	r3, #8
 80029de:	60fb      	str	r3, [r7, #12]
    do {
        i--;
 80029e0:	68fb      	ldr	r3, [r7, #12]
 80029e2:	3b01      	subs	r3, #1
 80029e4:	60fb      	str	r3, [r7, #12]
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80029e6:	687b      	ldr	r3, [r7, #4]
 80029e8:	f893 30e8 	ldrb.w	r3, [r3, #232]	; 0xe8
 80029ec:	461a      	mov	r2, r3
 80029ee:	68fb      	ldr	r3, [r7, #12]
 80029f0:	4053      	eors	r3, r2
 80029f2:	4a08      	ldr	r2, [pc, #32]	; (8002a14 <stepdirmap_init+0x40>)
 80029f4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80029f8:	4907      	ldr	r1, [pc, #28]	; (8002a18 <stepdirmap_init+0x44>)
 80029fa:	68fb      	ldr	r3, [r7, #12]
 80029fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    } while(i);
 8002a00:	68fb      	ldr	r3, [r7, #12]
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d1ec      	bne.n	80029e0 <stepdirmap_init+0xc>
    do {
        i--;
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
    } while(i);
#endif
}
 8002a06:	bf00      	nop
 8002a08:	bf00      	nop
 8002a0a:	3714      	adds	r7, #20
 8002a0c:	46bd      	mov	sp, r7
 8002a0e:	bc80      	pop	{r7}
 8002a10:	4770      	bx	lr
 8002a12:	bf00      	nop
 8002a14:	08030958 	.word	0x08030958
 8002a18:	200004b4 	.word	0x200004b4

08002a1c <driver_delay>:


void disk_timerproc (void);

static void driver_delay (uint32_t ms, void (*callback)(void))
{
 8002a1c:	b590      	push	{r4, r7, lr}
 8002a1e:	b083      	sub	sp, #12
 8002a20:	af00      	add	r7, sp, #0
 8002a22:	6078      	str	r0, [r7, #4]
 8002a24:	6039      	str	r1, [r7, #0]
    if((delay.ms = ms) > 0) {
 8002a26:	687b      	ldr	r3, [r7, #4]
 8002a28:	4a16      	ldr	r2, [pc, #88]	; (8002a84 <driver_delay+0x68>)
 8002a2a:	6013      	str	r3, [r2, #0]
 8002a2c:	2b00      	cmp	r3, #0
 8002a2e:	d01f      	beq.n	8002a70 <driver_delay+0x54>
        // Restart systick...
        SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 8002a30:	4b15      	ldr	r3, [pc, #84]	; (8002a88 <driver_delay+0x6c>)
 8002a32:	681b      	ldr	r3, [r3, #0]
 8002a34:	4a14      	ldr	r2, [pc, #80]	; (8002a88 <driver_delay+0x6c>)
 8002a36:	f023 0301 	bic.w	r3, r3, #1
 8002a3a:	6013      	str	r3, [r2, #0]
        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
 8002a3c:	4b12      	ldr	r3, [pc, #72]	; (8002a88 <driver_delay+0x6c>)
 8002a3e:	681b      	ldr	r3, [r3, #0]
 8002a40:	4a11      	ldr	r2, [pc, #68]	; (8002a88 <driver_delay+0x6c>)
 8002a42:	f043 0301 	orr.w	r3, r3, #1
 8002a46:	6013      	str	r3, [r2, #0]
        if(!(delay.callback = callback)) {
 8002a48:	4a0e      	ldr	r2, [pc, #56]	; (8002a84 <driver_delay+0x68>)
 8002a4a:	683b      	ldr	r3, [r7, #0]
 8002a4c:	6053      	str	r3, [r2, #4]
 8002a4e:	4b0d      	ldr	r3, [pc, #52]	; (8002a84 <driver_delay+0x68>)
 8002a50:	685b      	ldr	r3, [r3, #4]
 8002a52:	2b00      	cmp	r3, #0
 8002a54:	d111      	bne.n	8002a7a <driver_delay+0x5e>
            while(delay.ms)
 8002a56:	e006      	b.n	8002a66 <driver_delay+0x4a>
                grbl.on_execute_delay(state_get());
 8002a58:	4b0c      	ldr	r3, [pc, #48]	; (8002a8c <driver_delay+0x70>)
 8002a5a:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
 8002a5c:	f01a ff30 	bl	801d8c0 <state_get>
 8002a60:	4603      	mov	r3, r0
 8002a62:	4618      	mov	r0, r3
 8002a64:	47a0      	blx	r4
            while(delay.ms)
 8002a66:	4b07      	ldr	r3, [pc, #28]	; (8002a84 <driver_delay+0x68>)
 8002a68:	681b      	ldr	r3, [r3, #0]
 8002a6a:	2b00      	cmp	r3, #0
 8002a6c:	d1f4      	bne.n	8002a58 <driver_delay+0x3c>
        }
    } else if(callback)
        callback();
}
 8002a6e:	e004      	b.n	8002a7a <driver_delay+0x5e>
    } else if(callback)
 8002a70:	683b      	ldr	r3, [r7, #0]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d001      	beq.n	8002a7a <driver_delay+0x5e>
        callback();
 8002a76:	683b      	ldr	r3, [r7, #0]
 8002a78:	4798      	blx	r3
}
 8002a7a:	bf00      	nop
 8002a7c:	370c      	adds	r7, #12
 8002a7e:	46bd      	mov	sp, r7
 8002a80:	bd90      	pop	{r4, r7, pc}
 8002a82:	bf00      	nop
 8002a84:	20000214 	.word	0x20000214
 8002a88:	e000e010 	.word	0xe000e010
 8002a8c:	20000dd4 	.word	0x20000dd4

08002a90 <stepperEnable>:

// Enable/disable stepper motors
static void stepperEnable (axes_signals_t enable)
{
 8002a90:	b480      	push	{r7}
 8002a92:	b083      	sub	sp, #12
 8002a94:	af00      	add	r7, sp, #0
 8002a96:	7138      	strb	r0, [r7, #4]
    enable.mask ^= settings.steppers.enable_invert.mask;
 8002a98:	793a      	ldrb	r2, [r7, #4]
 8002a9a:	4b08      	ldr	r3, [pc, #32]	; (8002abc <stepperEnable+0x2c>)
 8002a9c:	f893 30eb 	ldrb.w	r3, [r3, #235]	; 0xeb
 8002aa0:	4053      	eors	r3, r2
 8002aa2:	b2db      	uxtb	r3, r3
 8002aa4:	713b      	strb	r3, [r7, #4]
#if !TRINAMIC_MOTOR_ENABLE
  #ifdef STEPPERS_ENABLE_PORT
    DIGITAL_OUT(STEPPERS_ENABLE_PORT, STEPPERS_ENABLE_PIN, enable.x);
 8002aa6:	793b      	ldrb	r3, [r7, #4]
 8002aa8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002aac:	b2da      	uxtb	r2, r3
 8002aae:	4b04      	ldr	r3, [pc, #16]	; (8002ac0 <stepperEnable+0x30>)
 8002ab0:	701a      	strb	r2, [r3, #0]
   #ifdef C_ENABLE_PORT
    DIGITAL_OUT(C_ENABLE_PORT, C_ENABLE_PIN, enable.c);
   #endif
  #endif
#endif
}
 8002ab2:	bf00      	nop
 8002ab4:	370c      	adds	r7, #12
 8002ab6:	46bd      	mov	sp, r7
 8002ab8:	bc80      	pop	{r7}
 8002aba:	4770      	bx	lr
 8002abc:	2000147c 	.word	0x2000147c
 8002ac0:	4222018c 	.word	0x4222018c

08002ac4 <stepperWakeUp>:

// Starts stepper driver ISR timer and forces a stepper driver interrupt callback
static void stepperWakeUp (void)
{
 8002ac4:	b580      	push	{r7, lr}
 8002ac6:	af00      	add	r7, sp, #0
    stepperEnable((axes_signals_t){AXES_BITMASK});
 8002ac8:	2307      	movs	r3, #7
 8002aca:	4618      	mov	r0, r3
 8002acc:	f7ff ffe0 	bl	8002a90 <stepperEnable>

    STEPPER_TIMER->ARR = hal.f_step_timer / 500; // ~2ms delay to allow drivers time to wake up.
 8002ad0:	4b0d      	ldr	r3, [pc, #52]	; (8002b08 <stepperWakeUp+0x44>)
 8002ad2:	69db      	ldr	r3, [r3, #28]
 8002ad4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002ad8:	490c      	ldr	r1, [pc, #48]	; (8002b0c <stepperWakeUp+0x48>)
 8002ada:	fba1 1303 	umull	r1, r3, r1, r3
 8002ade:	095b      	lsrs	r3, r3, #5
 8002ae0:	62d3      	str	r3, [r2, #44]	; 0x2c
    STEPPER_TIMER->EGR = TIM_EGR_UG;
 8002ae2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ae6:	2201      	movs	r2, #1
 8002ae8:	615a      	str	r2, [r3, #20]
    STEPPER_TIMER->SR = ~TIM_SR_UIF;
 8002aea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002aee:	f06f 0201 	mvn.w	r2, #1
 8002af2:	611a      	str	r2, [r3, #16]
    STEPPER_TIMER->CR1 |= TIM_CR1_CEN;
 8002af4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002af8:	681b      	ldr	r3, [r3, #0]
 8002afa:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002afe:	f043 0301 	orr.w	r3, r3, #1
 8002b02:	6013      	str	r3, [r2, #0]
}
 8002b04:	bf00      	nop
 8002b06:	bd80      	pop	{r7, pc}
 8002b08:	20000ed0 	.word	0x20000ed0
 8002b0c:	10624dd3 	.word	0x10624dd3

08002b10 <stepperGoIdle>:

// Disables stepper driver interrupts
static void stepperGoIdle (bool clear_signals)
{
 8002b10:	b480      	push	{r7}
 8002b12:	b083      	sub	sp, #12
 8002b14:	af00      	add	r7, sp, #0
 8002b16:	4603      	mov	r3, r0
 8002b18:	71fb      	strb	r3, [r7, #7]
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 8002b1a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b1e:	681b      	ldr	r3, [r3, #0]
 8002b20:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002b24:	f023 0301 	bic.w	r3, r3, #1
 8002b28:	6013      	str	r3, [r2, #0]
    STEPPER_TIMER->CNT = 0;
 8002b2a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b2e:	2200      	movs	r2, #0
 8002b30:	625a      	str	r2, [r3, #36]	; 0x24
}
 8002b32:	bf00      	nop
 8002b34:	370c      	adds	r7, #12
 8002b36:	46bd      	mov	sp, r7
 8002b38:	bc80      	pop	{r7}
 8002b3a:	4770      	bx	lr

08002b3c <stepperCyclesPerTickPrescaled>:

// Sets up stepper driver interrupt timeout, "Normal" version
static void stepperCyclesPerTickPrescaled (uint32_t cycles_per_tick)
{
 8002b3c:	b480      	push	{r7}
 8002b3e:	b083      	sub	sp, #12
 8002b40:	af00      	add	r7, sp, #0
 8002b42:	6078      	str	r0, [r7, #4]
    // Set timer prescaling for normal step generation
    if (cycles_per_tick < (1UL << 16)) { // < 65536  (1.1ms @ 72MHz)
 8002b44:	687b      	ldr	r3, [r7, #4]
 8002b46:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002b4a:	d204      	bcs.n	8002b56 <stepperCyclesPerTickPrescaled+0x1a>
        STEPPER_TIMER->PSC = 0; // DIV 1
 8002b4c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b50:	2200      	movs	r2, #0
 8002b52:	629a      	str	r2, [r3, #40]	; 0x28
 8002b54:	e012      	b.n	8002b7c <stepperCyclesPerTickPrescaled+0x40>
    } else if (cycles_per_tick < (1UL << 19)) { // < 524288 (8.8ms @ 72MHz)
 8002b56:	687b      	ldr	r3, [r7, #4]
 8002b58:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8002b5c:	d207      	bcs.n	8002b6e <stepperCyclesPerTickPrescaled+0x32>
        STEPPER_TIMER->PSC = 7; // DIV 8
 8002b5e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b62:	2207      	movs	r2, #7
 8002b64:	629a      	str	r2, [r3, #40]	; 0x28
        cycles_per_tick = cycles_per_tick >> 3;
 8002b66:	687b      	ldr	r3, [r7, #4]
 8002b68:	08db      	lsrs	r3, r3, #3
 8002b6a:	607b      	str	r3, [r7, #4]
 8002b6c:	e006      	b.n	8002b7c <stepperCyclesPerTickPrescaled+0x40>
    } else {
        STEPPER_TIMER->PSC = 63; // DIV64
 8002b6e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b72:	223f      	movs	r2, #63	; 0x3f
 8002b74:	629a      	str	r2, [r3, #40]	; 0x28
        cycles_per_tick = cycles_per_tick >> 6;
 8002b76:	687b      	ldr	r3, [r7, #4]
 8002b78:	099b      	lsrs	r3, r3, #6
 8002b7a:	607b      	str	r3, [r7, #4]
    }
    STEPPER_TIMER->ARR = (uint16_t)(cycles_per_tick - 1);
 8002b7c:	687b      	ldr	r3, [r7, #4]
 8002b7e:	b29b      	uxth	r3, r3
 8002b80:	3b01      	subs	r3, #1
 8002b82:	b29a      	uxth	r2, r3
 8002b84:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002b88:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8002b8a:	bf00      	nop
 8002b8c:	370c      	adds	r7, #12
 8002b8e:	46bd      	mov	sp, r7
 8002b90:	bc80      	pop	{r7}
 8002b92:	4770      	bx	lr

08002b94 <stepperPulseStart>:
#endif
}

// Sets stepper direction and pulse pins and starts a step pulse.
static void stepperPulseStart (stepper_t *stepper)
{
 8002b94:	b480      	push	{r7}
 8002b96:	b085      	sub	sp, #20
 8002b98:	af00      	add	r7, sp, #0
 8002b9a:	6078      	str	r0, [r7, #4]
    if(stepper->dir_change)
 8002b9c:	687b      	ldr	r3, [r7, #4]
 8002b9e:	7b5b      	ldrb	r3, [r3, #13]
 8002ba0:	2b00      	cmp	r3, #0
 8002ba2:	d01c      	beq.n	8002bde <stepperPulseStart+0x4a>
 8002ba4:	687b      	ldr	r3, [r7, #4]
 8002ba6:	7bdb      	ldrb	r3, [r3, #15]
 8002ba8:	723b      	strb	r3, [r7, #8]
    dir_outbits.mask ^= settings.steppers.dir_invert.mask;
 8002baa:	7a3a      	ldrb	r2, [r7, #8]
 8002bac:	4b1d      	ldr	r3, [pc, #116]	; (8002c24 <stepperPulseStart+0x90>)
 8002bae:	f893 30e9 	ldrb.w	r3, [r3, #233]	; 0xe9
 8002bb2:	4053      	eors	r3, r2
 8002bb4:	b2db      	uxtb	r3, r3
 8002bb6:	723b      	strb	r3, [r7, #8]
    DIGITAL_OUT(X_DIRECTION_PORT, X_DIRECTION_PIN, dir_outbits.x);
 8002bb8:	7a3b      	ldrb	r3, [r7, #8]
 8002bba:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002bbe:	b2da      	uxtb	r2, r3
 8002bc0:	4b19      	ldr	r3, [pc, #100]	; (8002c28 <stepperPulseStart+0x94>)
 8002bc2:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Y_DIRECTION_PORT, Y_DIRECTION_PIN, dir_outbits.y);
 8002bc4:	7a3b      	ldrb	r3, [r7, #8]
 8002bc6:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8002bca:	b2da      	uxtb	r2, r3
 8002bcc:	4b17      	ldr	r3, [pc, #92]	; (8002c2c <stepperPulseStart+0x98>)
 8002bce:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Z_DIRECTION_PORT, Z_DIRECTION_PIN, dir_outbits.z);
 8002bd0:	7a3b      	ldrb	r3, [r7, #8]
 8002bd2:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8002bd6:	b2da      	uxtb	r2, r3
 8002bd8:	4b15      	ldr	r3, [pc, #84]	; (8002c30 <stepperPulseStart+0x9c>)
 8002bda:	701a      	strb	r2, [r3, #0]
}
 8002bdc:	bf00      	nop
        stepperSetDirOutputs(stepper->dir_outbits);

    if(stepper->step_outbits.value) {
 8002bde:	687b      	ldr	r3, [r7, #4]
 8002be0:	7b9b      	ldrb	r3, [r3, #14]
 8002be2:	2b00      	cmp	r3, #0
 8002be4:	d018      	beq.n	8002c18 <stepperPulseStart+0x84>
 8002be6:	687b      	ldr	r3, [r7, #4]
 8002be8:	7b9b      	ldrb	r3, [r3, #14]
 8002bea:	733b      	strb	r3, [r7, #12]
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8002bec:	4b11      	ldr	r3, [pc, #68]	; (8002c34 <stepperPulseStart+0xa0>)
 8002bee:	68db      	ldr	r3, [r3, #12]
 8002bf0:	f423 7228 	bic.w	r2, r3, #672	; 0x2a0
 8002bf4:	7b3b      	ldrb	r3, [r7, #12]
 8002bf6:	4619      	mov	r1, r3
 8002bf8:	4b0f      	ldr	r3, [pc, #60]	; (8002c38 <stepperPulseStart+0xa4>)
 8002bfa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8002bfe:	490d      	ldr	r1, [pc, #52]	; (8002c34 <stepperPulseStart+0xa0>)
 8002c00:	4313      	orrs	r3, r2
 8002c02:	60cb      	str	r3, [r1, #12]
}
 8002c04:	bf00      	nop
        stepperSetStepOutputs(stepper->step_outbits);
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8002c06:	4b0d      	ldr	r3, [pc, #52]	; (8002c3c <stepperPulseStart+0xa8>)
 8002c08:	2201      	movs	r2, #1
 8002c0a:	615a      	str	r2, [r3, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 8002c0c:	4b0b      	ldr	r3, [pc, #44]	; (8002c3c <stepperPulseStart+0xa8>)
 8002c0e:	681b      	ldr	r3, [r3, #0]
 8002c10:	4a0a      	ldr	r2, [pc, #40]	; (8002c3c <stepperPulseStart+0xa8>)
 8002c12:	f043 0301 	orr.w	r3, r3, #1
 8002c16:	6013      	str	r3, [r2, #0]
    }
}
 8002c18:	bf00      	nop
 8002c1a:	3714      	adds	r7, #20
 8002c1c:	46bd      	mov	sp, r7
 8002c1e:	bc80      	pop	{r7}
 8002c20:	4770      	bx	lr
 8002c22:	bf00      	nop
 8002c24:	2000147c 	.word	0x2000147c
 8002c28:	42220188 	.word	0x42220188
 8002c2c:	422181a0 	.word	0x422181a0
 8002c30:	42218198 	.word	0x42218198
 8002c34:	40010c00 	.word	0x40010c00
 8002c38:	200004b4 	.word	0x200004b4
 8002c3c:	40000400 	.word	0x40000400

08002c40 <stepperPulseStartDelayed>:

// Start a stepper pulse, delay version.
// Note: delay is only added when there is a direction change and a pulse to be output.
static void stepperPulseStartDelayed (stepper_t *stepper)
{
 8002c40:	b480      	push	{r7}
 8002c42:	b085      	sub	sp, #20
 8002c44:	af00      	add	r7, sp, #0
 8002c46:	6078      	str	r0, [r7, #4]
    if(stepper->dir_change) {
 8002c48:	687b      	ldr	r3, [r7, #4]
 8002c4a:	7b5b      	ldrb	r3, [r3, #13]
 8002c4c:	2b00      	cmp	r3, #0
 8002c4e:	d032      	beq.n	8002cb6 <stepperPulseStartDelayed+0x76>
 8002c50:	687b      	ldr	r3, [r7, #4]
 8002c52:	7bdb      	ldrb	r3, [r3, #15]
 8002c54:	723b      	strb	r3, [r7, #8]
    dir_outbits.mask ^= settings.steppers.dir_invert.mask;
 8002c56:	7a3a      	ldrb	r2, [r7, #8]
 8002c58:	4b28      	ldr	r3, [pc, #160]	; (8002cfc <stepperPulseStartDelayed+0xbc>)
 8002c5a:	f893 30e9 	ldrb.w	r3, [r3, #233]	; 0xe9
 8002c5e:	4053      	eors	r3, r2
 8002c60:	b2db      	uxtb	r3, r3
 8002c62:	723b      	strb	r3, [r7, #8]
    DIGITAL_OUT(X_DIRECTION_PORT, X_DIRECTION_PIN, dir_outbits.x);
 8002c64:	7a3b      	ldrb	r3, [r7, #8]
 8002c66:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002c6a:	b2da      	uxtb	r2, r3
 8002c6c:	4b24      	ldr	r3, [pc, #144]	; (8002d00 <stepperPulseStartDelayed+0xc0>)
 8002c6e:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Y_DIRECTION_PORT, Y_DIRECTION_PIN, dir_outbits.y);
 8002c70:	7a3b      	ldrb	r3, [r7, #8]
 8002c72:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8002c76:	b2da      	uxtb	r2, r3
 8002c78:	4b22      	ldr	r3, [pc, #136]	; (8002d04 <stepperPulseStartDelayed+0xc4>)
 8002c7a:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Z_DIRECTION_PORT, Z_DIRECTION_PIN, dir_outbits.z);
 8002c7c:	7a3b      	ldrb	r3, [r7, #8]
 8002c7e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8002c82:	b2da      	uxtb	r2, r3
 8002c84:	4b20      	ldr	r3, [pc, #128]	; (8002d08 <stepperPulseStartDelayed+0xc8>)
 8002c86:	701a      	strb	r2, [r3, #0]
}
 8002c88:	bf00      	nop

        stepperSetDirOutputs(stepper->dir_outbits);

        if(stepper->step_outbits.value) {
 8002c8a:	687b      	ldr	r3, [r7, #4]
 8002c8c:	7b9b      	ldrb	r3, [r3, #14]
 8002c8e:	2b00      	cmp	r3, #0
 8002c90:	d02f      	beq.n	8002cf2 <stepperPulseStartDelayed+0xb2>
            next_step_outbits = stepper->step_outbits; // Store out_bits
 8002c92:	4a1e      	ldr	r2, [pc, #120]	; (8002d0c <stepperPulseStartDelayed+0xcc>)
 8002c94:	687b      	ldr	r3, [r7, #4]
 8002c96:	7b9b      	ldrb	r3, [r3, #14]
 8002c98:	7013      	strb	r3, [r2, #0]
            PULSE_TIMER->ARR = pulse_delay;
 8002c9a:	4a1d      	ldr	r2, [pc, #116]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002c9c:	4b1d      	ldr	r3, [pc, #116]	; (8002d14 <stepperPulseStartDelayed+0xd4>)
 8002c9e:	681b      	ldr	r3, [r3, #0]
 8002ca0:	62d3      	str	r3, [r2, #44]	; 0x2c
            PULSE_TIMER->EGR = TIM_EGR_UG;
 8002ca2:	4b1b      	ldr	r3, [pc, #108]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002ca4:	2201      	movs	r2, #1
 8002ca6:	615a      	str	r2, [r3, #20]
            PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 8002ca8:	4b19      	ldr	r3, [pc, #100]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002caa:	681b      	ldr	r3, [r3, #0]
 8002cac:	4a18      	ldr	r2, [pc, #96]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002cae:	f043 0301 	orr.w	r3, r3, #1
 8002cb2:	6013      	str	r3, [r2, #0]
        }

        return;
 8002cb4:	e01d      	b.n	8002cf2 <stepperPulseStartDelayed+0xb2>
    }

    if(stepper->step_outbits.value) {
 8002cb6:	687b      	ldr	r3, [r7, #4]
 8002cb8:	7b9b      	ldrb	r3, [r3, #14]
 8002cba:	2b00      	cmp	r3, #0
 8002cbc:	d01a      	beq.n	8002cf4 <stepperPulseStartDelayed+0xb4>
 8002cbe:	687b      	ldr	r3, [r7, #4]
 8002cc0:	7b9b      	ldrb	r3, [r3, #14]
 8002cc2:	733b      	strb	r3, [r7, #12]
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8002cc4:	4b14      	ldr	r3, [pc, #80]	; (8002d18 <stepperPulseStartDelayed+0xd8>)
 8002cc6:	68db      	ldr	r3, [r3, #12]
 8002cc8:	f423 7228 	bic.w	r2, r3, #672	; 0x2a0
 8002ccc:	7b3b      	ldrb	r3, [r7, #12]
 8002cce:	4619      	mov	r1, r3
 8002cd0:	4b12      	ldr	r3, [pc, #72]	; (8002d1c <stepperPulseStartDelayed+0xdc>)
 8002cd2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8002cd6:	4910      	ldr	r1, [pc, #64]	; (8002d18 <stepperPulseStartDelayed+0xd8>)
 8002cd8:	4313      	orrs	r3, r2
 8002cda:	60cb      	str	r3, [r1, #12]
}
 8002cdc:	bf00      	nop
        stepperSetStepOutputs(stepper->step_outbits);
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8002cde:	4b0c      	ldr	r3, [pc, #48]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002ce0:	2201      	movs	r2, #1
 8002ce2:	615a      	str	r2, [r3, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 8002ce4:	4b0a      	ldr	r3, [pc, #40]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002ce6:	681b      	ldr	r3, [r3, #0]
 8002ce8:	4a09      	ldr	r2, [pc, #36]	; (8002d10 <stepperPulseStartDelayed+0xd0>)
 8002cea:	f043 0301 	orr.w	r3, r3, #1
 8002cee:	6013      	str	r3, [r2, #0]
 8002cf0:	e000      	b.n	8002cf4 <stepperPulseStartDelayed+0xb4>
        return;
 8002cf2:	bf00      	nop
    }
}
 8002cf4:	3714      	adds	r7, #20
 8002cf6:	46bd      	mov	sp, r7
 8002cf8:	bc80      	pop	{r7}
 8002cfa:	4770      	bx	lr
 8002cfc:	2000147c 	.word	0x2000147c
 8002d00:	42220188 	.word	0x42220188
 8002d04:	422181a0 	.word	0x422181a0
 8002d08:	42218198 	.word	0x42218198
 8002d0c:	2000054c 	.word	0x2000054c
 8002d10:	40000400 	.word	0x40000400
 8002d14:	200004d8 	.word	0x200004d8
 8002d18:	40010c00 	.word	0x40010c00
 8002d1c:	200004b4 	.word	0x200004b4

08002d20 <limitsEnable>:

// Enable/disable limit pins interrupt
static void limitsEnable (bool on, axes_signals_t homing_cycle)
{
 8002d20:	b580      	push	{r7, lr}
 8002d22:	b088      	sub	sp, #32
 8002d24:	af00      	add	r7, sp, #0
 8002d26:	4603      	mov	r3, r0
 8002d28:	7139      	strb	r1, [r7, #4]
 8002d2a:	71fb      	strb	r3, [r7, #7]
    bool disable = !on;
 8002d2c:	79fb      	ldrb	r3, [r7, #7]
 8002d2e:	2b00      	cmp	r3, #0
 8002d30:	bf14      	ite	ne
 8002d32:	2301      	movne	r3, #1
 8002d34:	2300      	moveq	r3, #0
 8002d36:	b2db      	uxtb	r3, r3
 8002d38:	f083 0301 	eor.w	r3, r3, #1
 8002d3c:	b2db      	uxtb	r3, r3
 8002d3e:	77fb      	strb	r3, [r7, #31]
 8002d40:	7ffb      	ldrb	r3, [r7, #31]
 8002d42:	f003 0301 	and.w	r3, r3, #1
 8002d46:	77fb      	strb	r3, [r7, #31]
    axes_signals_t pin;
    input_signal_t *limit;
    uint_fast8_t idx = limit_inputs.n_pins;
 8002d48:	4b26      	ldr	r3, [pc, #152]	; (8002de4 <limitsEnable+0xc4>)
 8002d4a:	781b      	ldrb	r3, [r3, #0]
 8002d4c:	61bb      	str	r3, [r7, #24]
    limit_signals_t homing_source = xbar_get_homing_source_from_cycle(homing_cycle);
 8002d4e:	7938      	ldrb	r0, [r7, #4]
 8002d50:	f002 fd48 	bl	80057e4 <xbar_get_homing_source_from_cycle>
 8002d54:	4603      	mov	r3, r0
 8002d56:	60fb      	str	r3, [r7, #12]

    do {
        limit = &limit_inputs.pins.inputs[--idx];
 8002d58:	4b22      	ldr	r3, [pc, #136]	; (8002de4 <limitsEnable+0xc4>)
 8002d5a:	6859      	ldr	r1, [r3, #4]
 8002d5c:	69bb      	ldr	r3, [r7, #24]
 8002d5e:	3b01      	subs	r3, #1
 8002d60:	61bb      	str	r3, [r7, #24]
 8002d62:	69ba      	ldr	r2, [r7, #24]
 8002d64:	4613      	mov	r3, r2
 8002d66:	00db      	lsls	r3, r3, #3
 8002d68:	4413      	add	r3, r2
 8002d6a:	009b      	lsls	r3, r3, #2
 8002d6c:	440b      	add	r3, r1
 8002d6e:	617b      	str	r3, [r7, #20]
        if(on && homing_cycle.mask) {
 8002d70:	79fb      	ldrb	r3, [r7, #7]
 8002d72:	2b00      	cmp	r3, #0
 8002d74:	d022      	beq.n	8002dbc <limitsEnable+0x9c>
 8002d76:	793b      	ldrb	r3, [r7, #4]
 8002d78:	2b00      	cmp	r3, #0
 8002d7a:	d01f      	beq.n	8002dbc <limitsEnable+0x9c>
            pin = xbar_fn_to_axismask(limit->id);
 8002d7c:	697b      	ldr	r3, [r7, #20]
 8002d7e:	781b      	ldrb	r3, [r3, #0]
 8002d80:	4618      	mov	r0, r3
 8002d82:	f002 fca7 	bl	80056d4 <xbar_fn_to_axismask>
 8002d86:	4603      	mov	r3, r0
 8002d88:	743b      	strb	r3, [r7, #16]
            disable = limit->group == PinGroup_Limit ? (pin.mask & homing_source.min.mask) : (pin.mask & homing_source.max.mask);
 8002d8a:	697b      	ldr	r3, [r7, #20]
 8002d8c:	691b      	ldr	r3, [r3, #16]
 8002d8e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002d92:	d109      	bne.n	8002da8 <limitsEnable+0x88>
 8002d94:	7c3a      	ldrb	r2, [r7, #16]
 8002d96:	7b3b      	ldrb	r3, [r7, #12]
 8002d98:	4013      	ands	r3, r2
 8002d9a:	b2db      	uxtb	r3, r3
 8002d9c:	2b00      	cmp	r3, #0
 8002d9e:	bf14      	ite	ne
 8002da0:	2301      	movne	r3, #1
 8002da2:	2300      	moveq	r3, #0
 8002da4:	b2db      	uxtb	r3, r3
 8002da6:	e008      	b.n	8002dba <limitsEnable+0x9a>
 8002da8:	7c3a      	ldrb	r2, [r7, #16]
 8002daa:	7b7b      	ldrb	r3, [r7, #13]
 8002dac:	4013      	ands	r3, r2
 8002dae:	b2db      	uxtb	r3, r3
 8002db0:	2b00      	cmp	r3, #0
 8002db2:	bf14      	ite	ne
 8002db4:	2301      	movne	r3, #1
 8002db6:	2300      	moveq	r3, #0
 8002db8:	b2db      	uxtb	r3, r3
 8002dba:	77fb      	strb	r3, [r7, #31]
        }
        gpio_irq_enable(limit, disable ? IRQ_Mode_None : limit->irq_mode);
 8002dbc:	7ffb      	ldrb	r3, [r7, #31]
 8002dbe:	2b00      	cmp	r3, #0
 8002dc0:	d001      	beq.n	8002dc6 <limitsEnable+0xa6>
 8002dc2:	2300      	movs	r3, #0
 8002dc4:	e001      	b.n	8002dca <limitsEnable+0xaa>
 8002dc6:	697b      	ldr	r3, [r7, #20]
 8002dc8:	7d9b      	ldrb	r3, [r3, #22]
 8002dca:	4619      	mov	r1, r3
 8002dcc:	6978      	ldr	r0, [r7, #20]
 8002dce:	f000 fbd5 	bl	800357c <gpio_irq_enable>
    } while(idx);
 8002dd2:	69bb      	ldr	r3, [r7, #24]
 8002dd4:	2b00      	cmp	r3, #0
 8002dd6:	d1bf      	bne.n	8002d58 <limitsEnable+0x38>
}
 8002dd8:	bf00      	nop
 8002dda:	bf00      	nop
 8002ddc:	3720      	adds	r7, #32
 8002dde:	46bd      	mov	sp, r7
 8002de0:	bd80      	pop	{r7, pc}
 8002de2:	bf00      	nop
 8002de4:	20000544 	.word	0x20000544

08002de8 <limitsGetState>:


// Returns limit state as an axes_signals_t variable.
// Each bitfield bit indicates an axis limit, where triggered is 1 and not triggered is 0.
inline static limit_signals_t limitsGetState (void)
{
 8002de8:	b480      	push	{r7}
 8002dea:	b085      	sub	sp, #20
 8002dec:	af00      	add	r7, sp, #0
    limit_signals_t signals = {0};
 8002dee:	2300      	movs	r3, #0
 8002df0:	607b      	str	r3, [r7, #4]

    signals.min.mask = settings.limits.invert.mask;
 8002df2:	4b25      	ldr	r3, [pc, #148]	; (8002e88 <limitsGetState+0xa0>)
 8002df4:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 8002df8:	713b      	strb	r3, [r7, #4]
  #endif
  #ifdef C_LIMIT_PIN
    signals.min.c = DIGITAL_IN(C_LIMIT_PORT, C_LIMIT_PIN);
  #endif
#elif LIMIT_INMODE == GPIO_MAP
    uint32_t bits = LIMIT_PORT->IDR;
 8002dfa:	4b24      	ldr	r3, [pc, #144]	; (8002e8c <limitsGetState+0xa4>)
 8002dfc:	689b      	ldr	r3, [r3, #8]
 8002dfe:	60fb      	str	r3, [r7, #12]
    signals.min.x = !!(bits & X_LIMIT_BIT);
 8002e00:	68fb      	ldr	r3, [r7, #12]
 8002e02:	f003 0320 	and.w	r3, r3, #32
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	bf14      	ite	ne
 8002e0a:	2301      	movne	r3, #1
 8002e0c:	2300      	moveq	r3, #0
 8002e0e:	b2da      	uxtb	r2, r3
 8002e10:	793b      	ldrb	r3, [r7, #4]
 8002e12:	f362 0300 	bfi	r3, r2, #0, #1
 8002e16:	713b      	strb	r3, [r7, #4]
    signals.min.y = !!(bits & Y_LIMIT_BIT);
 8002e18:	68fb      	ldr	r3, [r7, #12]
 8002e1a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002e1e:	2b00      	cmp	r3, #0
 8002e20:	bf14      	ite	ne
 8002e22:	2301      	movne	r3, #1
 8002e24:	2300      	moveq	r3, #0
 8002e26:	b2da      	uxtb	r2, r3
 8002e28:	793b      	ldrb	r3, [r7, #4]
 8002e2a:	f362 0341 	bfi	r3, r2, #1, #1
 8002e2e:	713b      	strb	r3, [r7, #4]
    signals.min.z = !!(bits & Z_LIMIT_BIT);
 8002e30:	68fb      	ldr	r3, [r7, #12]
 8002e32:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002e36:	2b00      	cmp	r3, #0
 8002e38:	bf14      	ite	ne
 8002e3a:	2301      	movne	r3, #1
 8002e3c:	2300      	moveq	r3, #0
 8002e3e:	b2da      	uxtb	r2, r3
 8002e40:	793b      	ldrb	r3, [r7, #4]
 8002e42:	f362 0382 	bfi	r3, r2, #2, #1
 8002e46:	713b      	strb	r3, [r7, #4]
#endif
#ifdef Z_LIMIT_PIN_MAX
    signals.max.z = DIGITAL_IN(Z_LIMIT_PORT_MAX, Z_LIMIT_PIN_MAX);
#endif

    if (settings.limits.invert.mask) {
 8002e48:	4b0f      	ldr	r3, [pc, #60]	; (8002e88 <limitsGetState+0xa0>)
 8002e4a:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 8002e4e:	2b00      	cmp	r3, #0
 8002e50:	d006      	beq.n	8002e60 <limitsGetState+0x78>
        signals.min.value ^= settings.limits.invert.mask;
 8002e52:	793a      	ldrb	r2, [r7, #4]
 8002e54:	4b0c      	ldr	r3, [pc, #48]	; (8002e88 <limitsGetState+0xa0>)
 8002e56:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 8002e5a:	4053      	eors	r3, r2
 8002e5c:	b2db      	uxtb	r3, r3
 8002e5e:	713b      	strb	r3, [r7, #4]
#ifdef MAX_LIMIT_SWITCHES
        signals.max.value ^= settings.limits.invert.mask;
#endif
    }

    return signals;
 8002e60:	687b      	ldr	r3, [r7, #4]
 8002e62:	60bb      	str	r3, [r7, #8]
 8002e64:	2300      	movs	r3, #0
 8002e66:	7a3a      	ldrb	r2, [r7, #8]
 8002e68:	f362 0307 	bfi	r3, r2, #0, #8
 8002e6c:	7a7a      	ldrb	r2, [r7, #9]
 8002e6e:	f362 230f 	bfi	r3, r2, #8, #8
 8002e72:	7aba      	ldrb	r2, [r7, #10]
 8002e74:	f362 4317 	bfi	r3, r2, #16, #8
 8002e78:	7afa      	ldrb	r2, [r7, #11]
 8002e7a:	f362 631f 	bfi	r3, r2, #24, #8
}
 8002e7e:	4618      	mov	r0, r3
 8002e80:	3714      	adds	r7, #20
 8002e82:	46bd      	mov	sp, r7
 8002e84:	bc80      	pop	{r7}
 8002e86:	4770      	bx	lr
 8002e88:	2000147c 	.word	0x2000147c
 8002e8c:	40010800 	.word	0x40010800

08002e90 <systemGetState>:

// Returns system state as a control_signals_t variable.
// Each bitfield bit indicates a control signal, where triggered is 1 and not triggered is 0.
static control_signals_t systemGetState (void)
{
 8002e90:	b480      	push	{r7}
 8002e92:	b083      	sub	sp, #12
 8002e94:	af00      	add	r7, sp, #0
    control_signals_t signals;

    signals.value = settings.control_invert.mask;
 8002e96:	4b18      	ldr	r3, [pc, #96]	; (8002ef8 <systemGetState+0x68>)
 8002e98:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 8002e9c:	80bb      	strh	r3, [r7, #4]
    signals.cycle_start = (bits & CYCLE_START_BIT) != 0;
 #ifdef SAFETY_DOOR_PIN
    signals.safety_door_ajar = (bits & SAFETY_DOOR_BIT) != 0;
 #endif
#else
    signals.value = (uint8_t)((CONTROL_PORT->IDR & CONTROL_MASK) >> CONTROL_INMODE);
 8002e9e:	4b17      	ldr	r3, [pc, #92]	; (8002efc <systemGetState+0x6c>)
 8002ea0:	689b      	ldr	r3, [r3, #8]
 8002ea2:	095b      	lsrs	r3, r3, #5
 8002ea4:	b2db      	uxtb	r3, r3
 8002ea6:	b29b      	uxth	r3, r3
 8002ea8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002eac:	b29b      	uxth	r3, r3
 8002eae:	80bb      	strh	r3, [r7, #4]
 #ifdef SAFETY_DOOR_PIN
 	signals.safety_door_ajar = settings.control_invert.safety_door_ajar;
 #endif
 #if ESTOP_ENABLE
    signals.e_stop = signals.reset;
 8002eb0:	793b      	ldrb	r3, [r7, #4]
 8002eb2:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002eb6:	b2da      	uxtb	r2, r3
 8002eb8:	793b      	ldrb	r3, [r7, #4]
 8002eba:	f362 1386 	bfi	r3, r2, #6, #1
 8002ebe:	713b      	strb	r3, [r7, #4]
    signals.reset = settings.control_invert.reset;
 8002ec0:	4b0d      	ldr	r3, [pc, #52]	; (8002ef8 <systemGetState+0x68>)
 8002ec2:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 8002ec6:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002eca:	b2da      	uxtb	r2, r3
 8002ecc:	793b      	ldrb	r3, [r7, #4]
 8002ece:	f362 0300 	bfi	r3, r2, #0, #1
 8002ed2:	713b      	strb	r3, [r7, #4]
 #endif
#endif

    if(settings.control_invert.mask)
 8002ed4:	4b08      	ldr	r3, [pc, #32]	; (8002ef8 <systemGetState+0x68>)
 8002ed6:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d006      	beq.n	8002eec <systemGetState+0x5c>
        signals.value ^= settings.control_invert.mask;
 8002ede:	88ba      	ldrh	r2, [r7, #4]
 8002ee0:	4b05      	ldr	r3, [pc, #20]	; (8002ef8 <systemGetState+0x68>)
 8002ee2:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 8002ee6:	4053      	eors	r3, r2
 8002ee8:	b29b      	uxth	r3, r3
 8002eea:	80bb      	strh	r3, [r7, #4]

    return signals;
 8002eec:	88bb      	ldrh	r3, [r7, #4]
}
 8002eee:	4618      	mov	r0, r3
 8002ef0:	370c      	adds	r7, #12
 8002ef2:	46bd      	mov	sp, r7
 8002ef4:	bc80      	pop	{r7}
 8002ef6:	4770      	bx	lr
 8002ef8:	2000147c 	.word	0x2000147c
 8002efc:	40010c00 	.word	0x40010c00

08002f00 <probeConfigure>:

// Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
static void probeConfigure (bool is_probe_away, bool probing)
{
 8002f00:	b480      	push	{r7}
 8002f02:	b083      	sub	sp, #12
 8002f04:	af00      	add	r7, sp, #0
 8002f06:	4603      	mov	r3, r0
 8002f08:	460a      	mov	r2, r1
 8002f0a:	71fb      	strb	r3, [r7, #7]
 8002f0c:	4613      	mov	r3, r2
 8002f0e:	71bb      	strb	r3, [r7, #6]
    probe.triggered = Off;
 8002f10:	4a16      	ldr	r2, [pc, #88]	; (8002f6c <probeConfigure+0x6c>)
 8002f12:	7813      	ldrb	r3, [r2, #0]
 8002f14:	f36f 0300 	bfc	r3, #0, #1
 8002f18:	7013      	strb	r3, [r2, #0]
    probe.is_probing = probing;
 8002f1a:	4a14      	ldr	r2, [pc, #80]	; (8002f6c <probeConfigure+0x6c>)
 8002f1c:	7813      	ldrb	r3, [r2, #0]
 8002f1e:	79b9      	ldrb	r1, [r7, #6]
 8002f20:	f361 03c3 	bfi	r3, r1, #3, #1
 8002f24:	7013      	strb	r3, [r2, #0]
    probe.inverted = is_probe_away ? !settings.probe.invert_probe_pin : settings.probe.invert_probe_pin;
 8002f26:	79fb      	ldrb	r3, [r7, #7]
 8002f28:	2b00      	cmp	r3, #0
 8002f2a:	d00e      	beq.n	8002f4a <probeConfigure+0x4a>
 8002f2c:	4b10      	ldr	r3, [pc, #64]	; (8002f70 <probeConfigure+0x70>)
 8002f2e:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 8002f32:	f003 0301 	and.w	r3, r3, #1
 8002f36:	b2db      	uxtb	r3, r3
 8002f38:	2b00      	cmp	r3, #0
 8002f3a:	bf0c      	ite	eq
 8002f3c:	2301      	moveq	r3, #1
 8002f3e:	2300      	movne	r3, #0
 8002f40:	b2db      	uxtb	r3, r3
 8002f42:	f003 0301 	and.w	r3, r3, #1
 8002f46:	b2da      	uxtb	r2, r3
 8002f48:	e005      	b.n	8002f56 <probeConfigure+0x56>
 8002f4a:	4b09      	ldr	r3, [pc, #36]	; (8002f70 <probeConfigure+0x70>)
 8002f4c:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 8002f50:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002f54:	b2da      	uxtb	r2, r3
 8002f56:	4905      	ldr	r1, [pc, #20]	; (8002f6c <probeConfigure+0x6c>)
 8002f58:	780b      	ldrb	r3, [r1, #0]
 8002f5a:	f362 0382 	bfi	r3, r2, #2, #1
 8002f5e:	700b      	strb	r3, [r1, #0]
}
 8002f60:	bf00      	nop
 8002f62:	370c      	adds	r7, #12
 8002f64:	46bd      	mov	sp, r7
 8002f66:	bc80      	pop	{r7}
 8002f68:	4770      	bx	lr
 8002f6a:	bf00      	nop
 8002f6c:	2000021c 	.word	0x2000021c
 8002f70:	2000147c 	.word	0x2000147c

08002f74 <probeGetState>:

// Returns the probe connected and triggered pin states.
static probe_state_t probeGetState (void)
{
 8002f74:	b480      	push	{r7}
 8002f76:	b083      	sub	sp, #12
 8002f78:	af00      	add	r7, sp, #0
    probe_state_t state = {0};
 8002f7a:	2300      	movs	r3, #0
 8002f7c:	713b      	strb	r3, [r7, #4]

    state.connected = probe.connected;
 8002f7e:	4b14      	ldr	r3, [pc, #80]	; (8002fd0 <probeGetState+0x5c>)
 8002f80:	781b      	ldrb	r3, [r3, #0]
 8002f82:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8002f86:	b2da      	uxtb	r2, r3
 8002f88:	793b      	ldrb	r3, [r7, #4]
 8002f8a:	f362 0341 	bfi	r3, r2, #1, #1
 8002f8e:	713b      	strb	r3, [r7, #4]
    state.triggered = !!(PROBE_PORT->IDR & PROBE_BIT) ^ probe.inverted;
 8002f90:	4b10      	ldr	r3, [pc, #64]	; (8002fd4 <probeGetState+0x60>)
 8002f92:	689b      	ldr	r3, [r3, #8]
 8002f94:	f003 0320 	and.w	r3, r3, #32
 8002f98:	2b00      	cmp	r3, #0
 8002f9a:	bf14      	ite	ne
 8002f9c:	2301      	movne	r3, #1
 8002f9e:	2300      	moveq	r3, #0
 8002fa0:	b2db      	uxtb	r3, r3
 8002fa2:	b25a      	sxtb	r2, r3
 8002fa4:	4b0a      	ldr	r3, [pc, #40]	; (8002fd0 <probeGetState+0x5c>)
 8002fa6:	781b      	ldrb	r3, [r3, #0]
 8002fa8:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8002fac:	b2db      	uxtb	r3, r3
 8002fae:	b25b      	sxtb	r3, r3
 8002fb0:	4053      	eors	r3, r2
 8002fb2:	b25b      	sxtb	r3, r3
 8002fb4:	f003 0301 	and.w	r3, r3, #1
 8002fb8:	b2da      	uxtb	r2, r3
 8002fba:	793b      	ldrb	r3, [r7, #4]
 8002fbc:	f362 0300 	bfi	r3, r2, #0, #1
 8002fc0:	713b      	strb	r3, [r7, #4]

    return state;
 8002fc2:	793b      	ldrb	r3, [r7, #4]
}
 8002fc4:	4618      	mov	r0, r3
 8002fc6:	370c      	adds	r7, #12
 8002fc8:	46bd      	mov	sp, r7
 8002fca:	bc80      	pop	{r7}
 8002fcc:	4770      	bx	lr
 8002fce:	bf00      	nop
 8002fd0:	2000021c 	.word	0x2000021c
 8002fd4:	40011000 	.word	0x40011000

08002fd8 <spindle_off>:
#if DRIVER_SPINDLE_ENABLE

// Static spindle (off, on cw & on ccw)

inline static void spindle_off (void)
{
 8002fd8:	b480      	push	{r7}
 8002fda:	af00      	add	r7, sp, #0
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 8002fdc:	4b05      	ldr	r3, [pc, #20]	; (8002ff4 <spindle_off+0x1c>)
 8002fde:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 8002fe2:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8002fe6:	b2da      	uxtb	r2, r3
 8002fe8:	4b03      	ldr	r3, [pc, #12]	; (8002ff8 <spindle_off+0x20>)
 8002fea:	701a      	strb	r2, [r3, #0]
}
 8002fec:	bf00      	nop
 8002fee:	46bd      	mov	sp, r7
 8002ff0:	bc80      	pop	{r7}
 8002ff2:	4770      	bx	lr
 8002ff4:	2000147c 	.word	0x2000147c
 8002ff8:	42218184 	.word	0x42218184

08002ffc <spindle_on>:

inline static void spindle_on (void)
{
 8002ffc:	b480      	push	{r7}
 8002ffe:	af00      	add	r7, sp, #0
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = !settings.spindle.invert.on;
 8003000:	4b08      	ldr	r3, [pc, #32]	; (8003024 <spindle_on+0x28>)
 8003002:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 8003006:	f003 0301 	and.w	r3, r3, #1
 800300a:	b2db      	uxtb	r3, r3
 800300c:	2b00      	cmp	r3, #0
 800300e:	bf0c      	ite	eq
 8003010:	2301      	moveq	r3, #1
 8003012:	2300      	movne	r3, #0
 8003014:	b2da      	uxtb	r2, r3
 8003016:	4b04      	ldr	r3, [pc, #16]	; (8003028 <spindle_on+0x2c>)
 8003018:	701a      	strb	r2, [r3, #0]
}
 800301a:	bf00      	nop
 800301c:	46bd      	mov	sp, r7
 800301e:	bc80      	pop	{r7}
 8003020:	4770      	bx	lr
 8003022:	bf00      	nop
 8003024:	2000147c 	.word	0x2000147c
 8003028:	42218184 	.word	0x42218184

0800302c <spindle_dir>:

inline static void spindle_dir (bool ccw)
{
 800302c:	b480      	push	{r7}
 800302e:	b083      	sub	sp, #12
 8003030:	af00      	add	r7, sp, #0
 8003032:	4603      	mov	r3, r0
 8003034:	71fb      	strb	r3, [r7, #7]
#ifdef SPINDLE_DIRECTION_PIN
    BITBAND_PERI(SPINDLE_DIRECTION_PORT->ODR, SPINDLE_DIRECTION_PIN) = ccw ^ settings.spindle.invert.ccw;
 8003036:	79fb      	ldrb	r3, [r7, #7]
 8003038:	4a07      	ldr	r2, [pc, #28]	; (8003058 <spindle_dir+0x2c>)
 800303a:	f892 20e6 	ldrb.w	r2, [r2, #230]	; 0xe6
 800303e:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8003042:	b2d2      	uxtb	r2, r2
 8003044:	4611      	mov	r1, r2
 8003046:	4a05      	ldr	r2, [pc, #20]	; (800305c <spindle_dir+0x30>)
 8003048:	404b      	eors	r3, r1
 800304a:	b2db      	uxtb	r3, r3
 800304c:	7013      	strb	r3, [r2, #0]
#else
    UNUSED(ccw);
#endif
}
 800304e:	bf00      	nop
 8003050:	370c      	adds	r7, #12
 8003052:	46bd      	mov	sp, r7
 8003054:	bc80      	pop	{r7}
 8003056:	4770      	bx	lr
 8003058:	2000147c 	.word	0x2000147c
 800305c:	42218190 	.word	0x42218190

08003060 <spindleSetState>:

// Start or stop spindle
static void spindleSetState (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 8003060:	b580      	push	{r7, lr}
 8003062:	b084      	sub	sp, #16
 8003064:	af00      	add	r7, sp, #0
 8003066:	60f8      	str	r0, [r7, #12]
 8003068:	7239      	strb	r1, [r7, #8]
 800306a:	607a      	str	r2, [r7, #4]
    UNUSED(spindle);

    if(!state.on)
 800306c:	7a3b      	ldrb	r3, [r7, #8]
 800306e:	f003 0301 	and.w	r3, r3, #1
 8003072:	b2db      	uxtb	r3, r3
 8003074:	2b00      	cmp	r3, #0
 8003076:	d102      	bne.n	800307e <spindleSetState+0x1e>
        spindle_off();
 8003078:	f7ff ffae 	bl	8002fd8 <spindle_off>
    else {
        spindle_dir(state.ccw);
        spindle_on();
    }
}
 800307c:	e00d      	b.n	800309a <spindleSetState+0x3a>
        spindle_dir(state.ccw);
 800307e:	7a3b      	ldrb	r3, [r7, #8]
 8003080:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8003084:	b2db      	uxtb	r3, r3
 8003086:	2b00      	cmp	r3, #0
 8003088:	bf14      	ite	ne
 800308a:	2301      	movne	r3, #1
 800308c:	2300      	moveq	r3, #0
 800308e:	b2db      	uxtb	r3, r3
 8003090:	4618      	mov	r0, r3
 8003092:	f7ff ffcb 	bl	800302c <spindle_dir>
        spindle_on();
 8003096:	f7ff ffb1 	bl	8002ffc <spindle_on>
}
 800309a:	bf00      	nop
 800309c:	3710      	adds	r7, #16
 800309e:	46bd      	mov	sp, r7
 80030a0:	bd80      	pop	{r7, pc}
	...

080030a4 <spindleSetSpeed>:

// Variable spindle control functions

// Sets spindle speed
static void spindleSetSpeed (spindle_ptrs_t *spindle, uint_fast16_t pwm_value)
{
 80030a4:	b580      	push	{r7, lr}
 80030a6:	b082      	sub	sp, #8
 80030a8:	af00      	add	r7, sp, #0
 80030aa:	6078      	str	r0, [r7, #4]
 80030ac:	6039      	str	r1, [r7, #0]
    if (pwm_value == pwm(spindle)->off_value) {
 80030ae:	687b      	ldr	r3, [r7, #4]
 80030b0:	68db      	ldr	r3, [r3, #12]
 80030b2:	68db      	ldr	r3, [r3, #12]
 80030b4:	683a      	ldr	r2, [r7, #0]
 80030b6:	429a      	cmp	r2, r3
 80030b8:	d134      	bne.n	8003124 <spindleSetSpeed+0x80>
        pwmEnabled = false;
 80030ba:	4b2c      	ldr	r3, [pc, #176]	; (800316c <spindleSetSpeed+0xc8>)
 80030bc:	2200      	movs	r2, #0
 80030be:	701a      	strb	r2, [r3, #0]
        if(pwm(spindle)->settings->flags.enable_rpm_controlled) {
 80030c0:	687b      	ldr	r3, [r7, #4]
 80030c2:	68db      	ldr	r3, [r3, #12]
 80030c4:	685b      	ldr	r3, [r3, #4]
 80030c6:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 80030ca:	f003 0301 	and.w	r3, r3, #1
 80030ce:	b2db      	uxtb	r3, r3
 80030d0:	2b00      	cmp	r3, #0
 80030d2:	d00b      	beq.n	80030ec <spindleSetSpeed+0x48>
            if(pwm(spindle)->cloned)
 80030d4:	687b      	ldr	r3, [r7, #4]
 80030d6:	68db      	ldr	r3, [r3, #12]
 80030d8:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80030dc:	2b00      	cmp	r3, #0
 80030de:	d003      	beq.n	80030e8 <spindleSetSpeed+0x44>
                spindle_dir(false);
 80030e0:	2000      	movs	r0, #0
 80030e2:	f7ff ffa3 	bl	800302c <spindle_dir>
 80030e6:	e001      	b.n	80030ec <spindleSetSpeed+0x48>
            else
                spindle_off();
 80030e8:	f7ff ff76 	bl	8002fd8 <spindle_off>
        }
        if(pwm(spindle)->always_on) {
 80030ec:	687b      	ldr	r3, [r7, #4]
 80030ee:	68db      	ldr	r3, [r3, #12]
 80030f0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80030f4:	2b00      	cmp	r3, #0
 80030f6:	d00e      	beq.n	8003116 <spindleSetSpeed+0x72>
            SPINDLE_PWM_TIMER_CCR = pwm(spindle)->off_value;
 80030f8:	687b      	ldr	r3, [r7, #4]
 80030fa:	68db      	ldr	r3, [r3, #12]
 80030fc:	4a1c      	ldr	r2, [pc, #112]	; (8003170 <spindleSetSpeed+0xcc>)
 80030fe:	68db      	ldr	r3, [r3, #12]
 8003100:	6353      	str	r3, [r2, #52]	; 0x34
#if SPINDLE_PWM_TIMER_N == 1
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 8003102:	4b1b      	ldr	r3, [pc, #108]	; (8003170 <spindleSetSpeed+0xcc>)
 8003104:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003106:	4a1a      	ldr	r2, [pc, #104]	; (8003170 <spindleSetSpeed+0xcc>)
 8003108:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800310c:	6453      	str	r3, [r2, #68]	; 0x44
#endif
            SPINDLE_PWM_TIMER_CCR = pwm_value;
 800310e:	4a18      	ldr	r2, [pc, #96]	; (8003170 <spindleSetSpeed+0xcc>)
 8003110:	683b      	ldr	r3, [r7, #0]
 8003112:	6353      	str	r3, [r2, #52]	; 0x34
        SPINDLE_PWM_TIMER_CCR = pwm_value;
#if SPINDLE_PWM_TIMER_N == 1
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
#endif
    }
}
 8003114:	e025      	b.n	8003162 <spindleSetSpeed+0xbe>
            SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
 8003116:	4b16      	ldr	r3, [pc, #88]	; (8003170 <spindleSetSpeed+0xcc>)
 8003118:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800311a:	4a15      	ldr	r2, [pc, #84]	; (8003170 <spindleSetSpeed+0xcc>)
 800311c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003120:	6453      	str	r3, [r2, #68]	; 0x44
}
 8003122:	e01e      	b.n	8003162 <spindleSetSpeed+0xbe>
        if(!pwmEnabled) {
 8003124:	4b11      	ldr	r3, [pc, #68]	; (800316c <spindleSetSpeed+0xc8>)
 8003126:	781b      	ldrb	r3, [r3, #0]
 8003128:	f083 0301 	eor.w	r3, r3, #1
 800312c:	b2db      	uxtb	r3, r3
 800312e:	2b00      	cmp	r3, #0
 8003130:	d00e      	beq.n	8003150 <spindleSetSpeed+0xac>
            if(pwm(spindle)->cloned)
 8003132:	687b      	ldr	r3, [r7, #4]
 8003134:	68db      	ldr	r3, [r3, #12]
 8003136:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800313a:	2b00      	cmp	r3, #0
 800313c:	d003      	beq.n	8003146 <spindleSetSpeed+0xa2>
                spindle_dir(true);
 800313e:	2001      	movs	r0, #1
 8003140:	f7ff ff74 	bl	800302c <spindle_dir>
 8003144:	e001      	b.n	800314a <spindleSetSpeed+0xa6>
                spindle_on();
 8003146:	f7ff ff59 	bl	8002ffc <spindle_on>
            pwmEnabled = true;
 800314a:	4b08      	ldr	r3, [pc, #32]	; (800316c <spindleSetSpeed+0xc8>)
 800314c:	2201      	movs	r2, #1
 800314e:	701a      	strb	r2, [r3, #0]
        SPINDLE_PWM_TIMER_CCR = pwm_value;
 8003150:	4a07      	ldr	r2, [pc, #28]	; (8003170 <spindleSetSpeed+0xcc>)
 8003152:	683b      	ldr	r3, [r7, #0]
 8003154:	6353      	str	r3, [r2, #52]	; 0x34
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 8003156:	4b06      	ldr	r3, [pc, #24]	; (8003170 <spindleSetSpeed+0xcc>)
 8003158:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800315a:	4a05      	ldr	r2, [pc, #20]	; (8003170 <spindleSetSpeed+0xcc>)
 800315c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003160:	6453      	str	r3, [r2, #68]	; 0x44
}
 8003162:	bf00      	nop
 8003164:	3708      	adds	r7, #8
 8003166:	46bd      	mov	sp, r7
 8003168:	bd80      	pop	{r7, pc}
 800316a:	bf00      	nop
 800316c:	200004e1 	.word	0x200004e1
 8003170:	40012c00 	.word	0x40012c00

08003174 <spindleGetPWM>:

static uint_fast16_t spindleGetPWM (spindle_ptrs_t *spindle, float rpm)
{
 8003174:	b580      	push	{r7, lr}
 8003176:	b082      	sub	sp, #8
 8003178:	af00      	add	r7, sp, #0
 800317a:	6078      	str	r0, [r7, #4]
 800317c:	6039      	str	r1, [r7, #0]
    return pwm(spindle)->compute_value(pwm(spindle), rpm, false);
 800317e:	687b      	ldr	r3, [r7, #4]
 8003180:	68db      	ldr	r3, [r3, #12]
 8003182:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003184:	687a      	ldr	r2, [r7, #4]
 8003186:	68d0      	ldr	r0, [r2, #12]
 8003188:	2200      	movs	r2, #0
 800318a:	6839      	ldr	r1, [r7, #0]
 800318c:	4798      	blx	r3
 800318e:	4603      	mov	r3, r0
}
 8003190:	4618      	mov	r0, r3
 8003192:	3708      	adds	r7, #8
 8003194:	46bd      	mov	sp, r7
 8003196:	bd80      	pop	{r7, pc}

08003198 <spindleSetStateVariable>:

// Start or stop spindle
static void spindleSetStateVariable (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 8003198:	b580      	push	{r7, lr}
 800319a:	b084      	sub	sp, #16
 800319c:	af00      	add	r7, sp, #0
 800319e:	60f8      	str	r0, [r7, #12]
 80031a0:	7239      	strb	r1, [r7, #8]
 80031a2:	607a      	str	r2, [r7, #4]
#ifdef SPINDLE_DIRECTION_PIN
    if(state.on || pwm(spindle)->cloned)
 80031a4:	7a3b      	ldrb	r3, [r7, #8]
 80031a6:	f003 0301 	and.w	r3, r3, #1
 80031aa:	b2db      	uxtb	r3, r3
 80031ac:	2b00      	cmp	r3, #0
 80031ae:	d105      	bne.n	80031bc <spindleSetStateVariable+0x24>
 80031b0:	68fb      	ldr	r3, [r7, #12]
 80031b2:	68db      	ldr	r3, [r3, #12]
 80031b4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80031b8:	2b00      	cmp	r3, #0
 80031ba:	d00b      	beq.n	80031d4 <spindleSetStateVariable+0x3c>
        spindle_dir(state.ccw);
 80031bc:	7a3b      	ldrb	r3, [r7, #8]
 80031be:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80031c2:	b2db      	uxtb	r3, r3
 80031c4:	2b00      	cmp	r3, #0
 80031c6:	bf14      	ite	ne
 80031c8:	2301      	movne	r3, #1
 80031ca:	2300      	moveq	r3, #0
 80031cc:	b2db      	uxtb	r3, r3
 80031ce:	4618      	mov	r0, r3
 80031d0:	f7ff ff2c 	bl	800302c <spindle_dir>
#endif
    if(!pwm(spindle)->settings->flags.enable_rpm_controlled) {
 80031d4:	68fb      	ldr	r3, [r7, #12]
 80031d6:	68db      	ldr	r3, [r3, #12]
 80031d8:	685b      	ldr	r3, [r3, #4]
 80031da:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 80031de:	f003 0301 	and.w	r3, r3, #1
 80031e2:	b2db      	uxtb	r3, r3
 80031e4:	2b00      	cmp	r3, #0
 80031e6:	d10a      	bne.n	80031fe <spindleSetStateVariable+0x66>
        if(state.on)
 80031e8:	7a3b      	ldrb	r3, [r7, #8]
 80031ea:	f003 0301 	and.w	r3, r3, #1
 80031ee:	b2db      	uxtb	r3, r3
 80031f0:	2b00      	cmp	r3, #0
 80031f2:	d002      	beq.n	80031fa <spindleSetStateVariable+0x62>
            spindle_on();
 80031f4:	f7ff ff02 	bl	8002ffc <spindle_on>
 80031f8:	e001      	b.n	80031fe <spindleSetStateVariable+0x66>
        else
            spindle_off();
 80031fa:	f7ff feed 	bl	8002fd8 <spindle_off>
    }

    spindleSetSpeed(spindle, state.on || (state.ccw && pwm(spindle)->cloned)
 80031fe:	7a3b      	ldrb	r3, [r7, #8]
 8003200:	f003 0301 	and.w	r3, r3, #1
 8003204:	b2db      	uxtb	r3, r3
 8003206:	2b00      	cmp	r3, #0
 8003208:	d10b      	bne.n	8003222 <spindleSetStateVariable+0x8a>
 800320a:	7a3b      	ldrb	r3, [r7, #8]
 800320c:	f003 0302 	and.w	r3, r3, #2
 8003210:	b2db      	uxtb	r3, r3
 8003212:	2b00      	cmp	r3, #0
 8003214:	d00f      	beq.n	8003236 <spindleSetStateVariable+0x9e>
 8003216:	68fb      	ldr	r3, [r7, #12]
 8003218:	68db      	ldr	r3, [r3, #12]
 800321a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800321e:	2b00      	cmp	r3, #0
 8003220:	d009      	beq.n	8003236 <spindleSetStateVariable+0x9e>
                              ? pwm(spindle)->compute_value(pwm(spindle), rpm, false)
 8003222:	68fb      	ldr	r3, [r7, #12]
 8003224:	68db      	ldr	r3, [r3, #12]
 8003226:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003228:	68fa      	ldr	r2, [r7, #12]
 800322a:	68d0      	ldr	r0, [r2, #12]
 800322c:	2200      	movs	r2, #0
 800322e:	6879      	ldr	r1, [r7, #4]
 8003230:	4798      	blx	r3
 8003232:	4603      	mov	r3, r0
    spindleSetSpeed(spindle, state.on || (state.ccw && pwm(spindle)->cloned)
 8003234:	e002      	b.n	800323c <spindleSetStateVariable+0xa4>
                              : pwm(spindle)->off_value);
 8003236:	68fb      	ldr	r3, [r7, #12]
 8003238:	68db      	ldr	r3, [r3, #12]
    spindleSetSpeed(spindle, state.on || (state.ccw && pwm(spindle)->cloned)
 800323a:	68db      	ldr	r3, [r3, #12]
 800323c:	4619      	mov	r1, r3
 800323e:	68f8      	ldr	r0, [r7, #12]
 8003240:	f7ff ff30 	bl	80030a4 <spindleSetSpeed>
}
 8003244:	bf00      	nop
 8003246:	3710      	adds	r7, #16
 8003248:	46bd      	mov	sp, r7
 800324a:	bd80      	pop	{r7, pc}

0800324c <spindleConfig>:

bool spindleConfig (spindle_ptrs_t *spindle)
{
 800324c:	b580      	push	{r7, lr}
 800324e:	b08a      	sub	sp, #40	; 0x28
 8003250:	af00      	add	r7, sp, #0
 8003252:	6078      	str	r0, [r7, #4]
    if(spindle == NULL)
 8003254:	687b      	ldr	r3, [r7, #4]
 8003256:	2b00      	cmp	r3, #0
 8003258:	d101      	bne.n	800325e <spindleConfig+0x12>
        return false;
 800325a:	2300      	movs	r3, #0
 800325c:	e0a5      	b.n	80033aa <spindleConfig+0x15e>

    uint32_t prescaler = 1;
 800325e:	2301      	movs	r3, #1
 8003260:	627b      	str	r3, [r7, #36]	; 0x24

    if(spindle_precompute_pwm_values(spindle, &spindle_pwm, &settings.spindle, SystemCoreClock)) {
 8003262:	4b54      	ldr	r3, [pc, #336]	; (80033b4 <spindleConfig+0x168>)
 8003264:	681b      	ldr	r3, [r3, #0]
 8003266:	4a54      	ldr	r2, [pc, #336]	; (80033b8 <spindleConfig+0x16c>)
 8003268:	4954      	ldr	r1, [pc, #336]	; (80033bc <spindleConfig+0x170>)
 800326a:	6878      	ldr	r0, [r7, #4]
 800326c:	f01a f81a 	bl	801d2a4 <spindle_precompute_pwm_values>
 8003270:	4603      	mov	r3, r0
 8003272:	2b00      	cmp	r3, #0
 8003274:	d07b      	beq.n	800336e <spindleConfig+0x122>

        while(spindle_pwm.period > 65534) {
 8003276:	e00c      	b.n	8003292 <spindleConfig+0x46>
            prescaler++;
 8003278:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800327a:	3301      	adds	r3, #1
 800327c:	627b      	str	r3, [r7, #36]	; 0x24
            spindle_precompute_pwm_values(spindle, &spindle_pwm, &settings.spindle, SystemCoreClock / prescaler);
 800327e:	4b4d      	ldr	r3, [pc, #308]	; (80033b4 <spindleConfig+0x168>)
 8003280:	681a      	ldr	r2, [r3, #0]
 8003282:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003284:	fbb2 f3f3 	udiv	r3, r2, r3
 8003288:	4a4b      	ldr	r2, [pc, #300]	; (80033b8 <spindleConfig+0x16c>)
 800328a:	494c      	ldr	r1, [pc, #304]	; (80033bc <spindleConfig+0x170>)
 800328c:	6878      	ldr	r0, [r7, #4]
 800328e:	f01a f809 	bl	801d2a4 <spindle_precompute_pwm_values>
        while(spindle_pwm.period > 65534) {
 8003292:	4b4a      	ldr	r3, [pc, #296]	; (80033bc <spindleConfig+0x170>)
 8003294:	689b      	ldr	r3, [r3, #8]
 8003296:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800329a:	4293      	cmp	r3, r2
 800329c:	d8ec      	bhi.n	8003278 <spindleConfig+0x2c>
        }

        spindle->set_state = spindleSetStateVariable;
 800329e:	687b      	ldr	r3, [r7, #4]
 80032a0:	4a47      	ldr	r2, [pc, #284]	; (80033c0 <spindleConfig+0x174>)
 80032a2:	621a      	str	r2, [r3, #32]

        SPINDLE_PWM_TIMER->CR1 &= ~TIM_CR1_CEN;
 80032a4:	4b47      	ldr	r3, [pc, #284]	; (80033c4 <spindleConfig+0x178>)
 80032a6:	681b      	ldr	r3, [r3, #0]
 80032a8:	4a46      	ldr	r2, [pc, #280]	; (80033c4 <spindleConfig+0x178>)
 80032aa:	f023 0301 	bic.w	r3, r3, #1
 80032ae:	6013      	str	r3, [r2, #0]

        TIM_Base_InitTypeDef timerInitStructure = {
 80032b0:	f107 030c 	add.w	r3, r7, #12
 80032b4:	2200      	movs	r2, #0
 80032b6:	601a      	str	r2, [r3, #0]
 80032b8:	605a      	str	r2, [r3, #4]
 80032ba:	609a      	str	r2, [r3, #8]
 80032bc:	60da      	str	r2, [r3, #12]
 80032be:	611a      	str	r2, [r3, #16]
 80032c0:	615a      	str	r2, [r3, #20]
            .Prescaler = prescaler - 1,
 80032c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80032c4:	3b01      	subs	r3, #1
        TIM_Base_InitTypeDef timerInitStructure = {
 80032c6:	60fb      	str	r3, [r7, #12]
            .CounterMode = TIM_COUNTERMODE_UP,
            .Period = spindle_pwm.period - 1,
 80032c8:	4b3c      	ldr	r3, [pc, #240]	; (80033bc <spindleConfig+0x170>)
 80032ca:	689b      	ldr	r3, [r3, #8]
 80032cc:	3b01      	subs	r3, #1
        TIM_Base_InitTypeDef timerInitStructure = {
 80032ce:	617b      	str	r3, [r7, #20]
            .ClockDivision = TIM_CLOCKDIVISION_DIV1,
            .RepetitionCounter = 0
        };

        TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 80032d0:	f107 030c 	add.w	r3, r7, #12
 80032d4:	4619      	mov	r1, r3
 80032d6:	483b      	ldr	r0, [pc, #236]	; (80033c4 <spindleConfig+0x178>)
 80032d8:	f7ff f97c 	bl	80025d4 <TIM_Base_SetConfig>

        SPINDLE_PWM_TIMER->CCER &= ~SPINDLE_PWM_CCER_EN;
 80032dc:	4b39      	ldr	r3, [pc, #228]	; (80033c4 <spindleConfig+0x178>)
 80032de:	6a1b      	ldr	r3, [r3, #32]
 80032e0:	4a38      	ldr	r2, [pc, #224]	; (80033c4 <spindleConfig+0x178>)
 80032e2:	f023 0301 	bic.w	r3, r3, #1
 80032e6:	6213      	str	r3, [r2, #32]
        SPINDLE_PWM_TIMER_CCMR &= ~SPINDLE_PWM_CCMR_OCM_CLR;
 80032e8:	4b36      	ldr	r3, [pc, #216]	; (80033c4 <spindleConfig+0x178>)
 80032ea:	699b      	ldr	r3, [r3, #24]
 80032ec:	4a35      	ldr	r2, [pc, #212]	; (80033c4 <spindleConfig+0x178>)
 80032ee:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 80032f2:	6193      	str	r3, [r2, #24]
        SPINDLE_PWM_TIMER_CCMR |= SPINDLE_PWM_CCMR_OCM_SET;
 80032f4:	4b33      	ldr	r3, [pc, #204]	; (80033c4 <spindleConfig+0x178>)
 80032f6:	699b      	ldr	r3, [r3, #24]
 80032f8:	4a32      	ldr	r2, [pc, #200]	; (80033c4 <spindleConfig+0x178>)
 80032fa:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 80032fe:	6193      	str	r3, [r2, #24]
        SPINDLE_PWM_TIMER_CCR = 0;
 8003300:	4b30      	ldr	r3, [pc, #192]	; (80033c4 <spindleConfig+0x178>)
 8003302:	2200      	movs	r2, #0
 8003304:	635a      	str	r2, [r3, #52]	; 0x34
#if SPINDLE_PWM_TIMER_N == 1
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_OSSR|TIM_BDTR_OSSI;
 8003306:	4b2f      	ldr	r3, [pc, #188]	; (80033c4 <spindleConfig+0x178>)
 8003308:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800330a:	4a2e      	ldr	r2, [pc, #184]	; (80033c4 <spindleConfig+0x178>)
 800330c:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 8003310:	6453      	str	r3, [r2, #68]	; 0x44
#endif
        if(settings.spindle.invert.pwm) {
 8003312:	4b2d      	ldr	r3, [pc, #180]	; (80033c8 <spindleConfig+0x17c>)
 8003314:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 8003318:	f003 0304 	and.w	r3, r3, #4
 800331c:	b2db      	uxtb	r3, r3
 800331e:	2b00      	cmp	r3, #0
 8003320:	d00c      	beq.n	800333c <spindleConfig+0xf0>
            SPINDLE_PWM_TIMER->CCER |= SPINDLE_PWM_CCER_POL;
 8003322:	4b28      	ldr	r3, [pc, #160]	; (80033c4 <spindleConfig+0x178>)
 8003324:	6a1b      	ldr	r3, [r3, #32]
 8003326:	4a27      	ldr	r2, [pc, #156]	; (80033c4 <spindleConfig+0x178>)
 8003328:	f043 0302 	orr.w	r3, r3, #2
 800332c:	6213      	str	r3, [r2, #32]
            SPINDLE_PWM_TIMER->CR2 |= SPINDLE_PWM_CR2_OIS;
 800332e:	4b25      	ldr	r3, [pc, #148]	; (80033c4 <spindleConfig+0x178>)
 8003330:	685b      	ldr	r3, [r3, #4]
 8003332:	4a24      	ldr	r2, [pc, #144]	; (80033c4 <spindleConfig+0x178>)
 8003334:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003338:	6053      	str	r3, [r2, #4]
 800333a:	e00b      	b.n	8003354 <spindleConfig+0x108>
        } else {
            SPINDLE_PWM_TIMER->CCER &= ~SPINDLE_PWM_CCER_POL;
 800333c:	4b21      	ldr	r3, [pc, #132]	; (80033c4 <spindleConfig+0x178>)
 800333e:	6a1b      	ldr	r3, [r3, #32]
 8003340:	4a20      	ldr	r2, [pc, #128]	; (80033c4 <spindleConfig+0x178>)
 8003342:	f023 0302 	bic.w	r3, r3, #2
 8003346:	6213      	str	r3, [r2, #32]
            SPINDLE_PWM_TIMER->CR2 &= ~SPINDLE_PWM_CR2_OIS;
 8003348:	4b1e      	ldr	r3, [pc, #120]	; (80033c4 <spindleConfig+0x178>)
 800334a:	685b      	ldr	r3, [r3, #4]
 800334c:	4a1d      	ldr	r2, [pc, #116]	; (80033c4 <spindleConfig+0x178>)
 800334e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003352:	6053      	str	r3, [r2, #4]
        }
        SPINDLE_PWM_TIMER->CCER |= SPINDLE_PWM_CCER_EN;
 8003354:	4b1b      	ldr	r3, [pc, #108]	; (80033c4 <spindleConfig+0x178>)
 8003356:	6a1b      	ldr	r3, [r3, #32]
 8003358:	4a1a      	ldr	r2, [pc, #104]	; (80033c4 <spindleConfig+0x178>)
 800335a:	f043 0301 	orr.w	r3, r3, #1
 800335e:	6213      	str	r3, [r2, #32]
        SPINDLE_PWM_TIMER->CR1 |= TIM_CR1_CEN;
 8003360:	4b18      	ldr	r3, [pc, #96]	; (80033c4 <spindleConfig+0x178>)
 8003362:	681b      	ldr	r3, [r3, #0]
 8003364:	4a17      	ldr	r2, [pc, #92]	; (80033c4 <spindleConfig+0x178>)
 8003366:	f043 0301 	orr.w	r3, r3, #1
 800336a:	6013      	str	r3, [r2, #0]
 800336c:	e00e      	b.n	800338c <spindleConfig+0x140>

    } else {
        if(pwmEnabled)
 800336e:	4b17      	ldr	r3, [pc, #92]	; (80033cc <spindleConfig+0x180>)
 8003370:	781b      	ldrb	r3, [r3, #0]
 8003372:	2b00      	cmp	r3, #0
 8003374:	d007      	beq.n	8003386 <spindleConfig+0x13a>
            spindle->set_state(spindle, (spindle_state_t){0}, 0.0f);
 8003376:	687b      	ldr	r3, [r7, #4]
 8003378:	6a1b      	ldr	r3, [r3, #32]
 800337a:	2200      	movs	r2, #0
 800337c:	4611      	mov	r1, r2
 800337e:	f04f 0200 	mov.w	r2, #0
 8003382:	6878      	ldr	r0, [r7, #4]
 8003384:	4798      	blx	r3
        spindle->set_state = spindleSetState;
 8003386:	687b      	ldr	r3, [r7, #4]
 8003388:	4a11      	ldr	r2, [pc, #68]	; (80033d0 <spindleConfig+0x184>)
 800338a:	621a      	str	r2, [r3, #32]
    }

    spindle_update_caps(spindle, spindle->cap.variable ? &spindle_pwm : NULL);
 800338c:	687b      	ldr	r3, [r7, #4]
 800338e:	7a9b      	ldrb	r3, [r3, #10]
 8003390:	f003 0301 	and.w	r3, r3, #1
 8003394:	b2db      	uxtb	r3, r3
 8003396:	2b00      	cmp	r3, #0
 8003398:	d001      	beq.n	800339e <spindleConfig+0x152>
 800339a:	4b08      	ldr	r3, [pc, #32]	; (80033bc <spindleConfig+0x170>)
 800339c:	e000      	b.n	80033a0 <spindleConfig+0x154>
 800339e:	2300      	movs	r3, #0
 80033a0:	4619      	mov	r1, r3
 80033a2:	6878      	ldr	r0, [r7, #4]
 80033a4:	f019 fa30 	bl	801c808 <spindle_update_caps>

    return true;
 80033a8:	2301      	movs	r3, #1
}
 80033aa:	4618      	mov	r0, r3
 80033ac:	3728      	adds	r7, #40	; 0x28
 80033ae:	46bd      	mov	sp, r7
 80033b0:	bd80      	pop	{r7, pc}
 80033b2:	bf00      	nop
 80033b4:	20000000 	.word	0x20000000
 80033b8:	200014f0 	.word	0x200014f0
 80033bc:	200004e4 	.word	0x200004e4
 80033c0:	08003199 	.word	0x08003199
 80033c4:	40012c00 	.word	0x40012c00
 80033c8:	2000147c 	.word	0x2000147c
 80033cc:	200004e1 	.word	0x200004e1
 80033d0:	08003061 	.word	0x08003061

080033d4 <spindleGetState>:

#endif // DRIVER_SPINDLE_PWM_ENABLE

// Returns spindle state in a spindle_state_t variable
static spindle_state_t spindleGetState (spindle_ptrs_t *spindle)
{
 80033d4:	b480      	push	{r7}
 80033d6:	b085      	sub	sp, #20
 80033d8:	af00      	add	r7, sp, #0
 80033da:	6078      	str	r0, [r7, #4]
    spindle_state_t state = { settings.spindle.invert.mask };
 80033dc:	4b15      	ldr	r3, [pc, #84]	; (8003434 <spindleGetState+0x60>)
 80033de:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 80033e2:	733b      	strb	r3, [r7, #12]

    UNUSED(spindle);

    state.on = (SPINDLE_ENABLE_PORT->IDR & SPINDLE_ENABLE_BIT) != 0;
 80033e4:	4b14      	ldr	r3, [pc, #80]	; (8003438 <spindleGetState+0x64>)
 80033e6:	689b      	ldr	r3, [r3, #8]
 80033e8:	f003 0302 	and.w	r3, r3, #2
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	bf14      	ite	ne
 80033f0:	2301      	movne	r3, #1
 80033f2:	2300      	moveq	r3, #0
 80033f4:	b2da      	uxtb	r2, r3
 80033f6:	7b3b      	ldrb	r3, [r7, #12]
 80033f8:	f362 0300 	bfi	r3, r2, #0, #1
 80033fc:	733b      	strb	r3, [r7, #12]
#ifdef SPINDLE_DIRECTION_PIN
    state.ccw = (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 80033fe:	4b0e      	ldr	r3, [pc, #56]	; (8003438 <spindleGetState+0x64>)
 8003400:	689b      	ldr	r3, [r3, #8]
 8003402:	f003 0310 	and.w	r3, r3, #16
 8003406:	2b00      	cmp	r3, #0
 8003408:	bf14      	ite	ne
 800340a:	2301      	movne	r3, #1
 800340c:	2300      	moveq	r3, #0
 800340e:	b2da      	uxtb	r2, r3
 8003410:	7b3b      	ldrb	r3, [r7, #12]
 8003412:	f362 0341 	bfi	r3, r2, #1, #1
 8003416:	733b      	strb	r3, [r7, #12]
#endif
    state.value ^= settings.spindle.invert.mask;
 8003418:	7b3a      	ldrb	r2, [r7, #12]
 800341a:	4b06      	ldr	r3, [pc, #24]	; (8003434 <spindleGetState+0x60>)
 800341c:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 8003420:	4053      	eors	r3, r2
 8003422:	b2db      	uxtb	r3, r3
 8003424:	733b      	strb	r3, [r7, #12]

    return state;
 8003426:	7b3b      	ldrb	r3, [r7, #12]
}
 8003428:	4618      	mov	r0, r3
 800342a:	3714      	adds	r7, #20
 800342c:	46bd      	mov	sp, r7
 800342e:	bc80      	pop	{r7}
 8003430:	4770      	bx	lr
 8003432:	bf00      	nop
 8003434:	2000147c 	.word	0x2000147c
 8003438:	40010c00 	.word	0x40010c00

0800343c <coolantSetState>:

#endif // DRIVER_SPINDLE_ENABLE

// Start/stop coolant (and mist if enabled)
static void coolantSetState (coolant_state_t mode)
{
 800343c:	b480      	push	{r7}
 800343e:	b083      	sub	sp, #12
 8003440:	af00      	add	r7, sp, #0
 8003442:	7138      	strb	r0, [r7, #4]
    mode.value ^= settings.coolant_invert.mask;
 8003444:	793a      	ldrb	r2, [r7, #4]
 8003446:	4b0b      	ldr	r3, [pc, #44]	; (8003474 <coolantSetState+0x38>)
 8003448:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 800344c:	4053      	eors	r3, r2
 800344e:	b2db      	uxtb	r3, r3
 8003450:	713b      	strb	r3, [r7, #4]
    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = mode.flood;
 8003452:	793b      	ldrb	r3, [r7, #4]
 8003454:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8003458:	b2da      	uxtb	r2, r3
 800345a:	4b07      	ldr	r3, [pc, #28]	; (8003478 <coolantSetState+0x3c>)
 800345c:	701a      	strb	r2, [r3, #0]
#ifdef COOLANT_MIST_PIN
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = mode.mist;
 800345e:	793b      	ldrb	r3, [r7, #4]
 8003460:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8003464:	b2da      	uxtb	r2, r3
 8003466:	4b05      	ldr	r3, [pc, #20]	; (800347c <coolantSetState+0x40>)
 8003468:	701a      	strb	r2, [r3, #0]
#endif
}
 800346a:	bf00      	nop
 800346c:	370c      	adds	r7, #12
 800346e:	46bd      	mov	sp, r7
 8003470:	bc80      	pop	{r7}
 8003472:	4770      	bx	lr
 8003474:	2000147c 	.word	0x2000147c
 8003478:	42218180 	.word	0x42218180
 800347c:	42218184 	.word	0x42218184

08003480 <coolantGetState>:

// Returns coolant state in a coolant_state_t variable
static coolant_state_t coolantGetState (void)
{
 8003480:	b480      	push	{r7}
 8003482:	b083      	sub	sp, #12
 8003484:	af00      	add	r7, sp, #0
    coolant_state_t state;

    state.mask = settings.coolant_invert.mask;
 8003486:	4b15      	ldr	r3, [pc, #84]	; (80034dc <coolantGetState+0x5c>)
 8003488:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 800348c:	713b      	strb	r3, [r7, #4]
    state.flood = (COOLANT_FLOOD_PORT->IDR & COOLANT_FLOOD_BIT) != 0;
 800348e:	4b14      	ldr	r3, [pc, #80]	; (80034e0 <coolantGetState+0x60>)
 8003490:	689b      	ldr	r3, [r3, #8]
 8003492:	f003 0301 	and.w	r3, r3, #1
 8003496:	2b00      	cmp	r3, #0
 8003498:	bf14      	ite	ne
 800349a:	2301      	movne	r3, #1
 800349c:	2300      	moveq	r3, #0
 800349e:	b2da      	uxtb	r2, r3
 80034a0:	793b      	ldrb	r3, [r7, #4]
 80034a2:	f362 0300 	bfi	r3, r2, #0, #1
 80034a6:	713b      	strb	r3, [r7, #4]
#ifdef COOLANT_MIST_PIN
    state.mist  = (COOLANT_MIST_PORT->IDR & COOLANT_MIST_BIT) != 0;
 80034a8:	4b0d      	ldr	r3, [pc, #52]	; (80034e0 <coolantGetState+0x60>)
 80034aa:	689b      	ldr	r3, [r3, #8]
 80034ac:	f003 0302 	and.w	r3, r3, #2
 80034b0:	2b00      	cmp	r3, #0
 80034b2:	bf14      	ite	ne
 80034b4:	2301      	movne	r3, #1
 80034b6:	2300      	moveq	r3, #0
 80034b8:	b2da      	uxtb	r2, r3
 80034ba:	793b      	ldrb	r3, [r7, #4]
 80034bc:	f362 0341 	bfi	r3, r2, #1, #1
 80034c0:	713b      	strb	r3, [r7, #4]
#endif
    state.value ^= settings.coolant_invert.mask;
 80034c2:	793a      	ldrb	r2, [r7, #4]
 80034c4:	4b05      	ldr	r3, [pc, #20]	; (80034dc <coolantGetState+0x5c>)
 80034c6:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 80034ca:	4053      	eors	r3, r2
 80034cc:	b2db      	uxtb	r3, r3
 80034ce:	713b      	strb	r3, [r7, #4]

    return state;
 80034d0:	793b      	ldrb	r3, [r7, #4]
}
 80034d2:	4618      	mov	r0, r3
 80034d4:	370c      	adds	r7, #12
 80034d6:	46bd      	mov	sp, r7
 80034d8:	bc80      	pop	{r7}
 80034da:	4770      	bx	lr
 80034dc:	2000147c 	.word	0x2000147c
 80034e0:	40010c00 	.word	0x40010c00

080034e4 <bitsSetAtomic>:

// Helper functions for setting/clearing/inverting individual bits atomically (uninterruptable)
static void bitsSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
 80034e4:	b480      	push	{r7}
 80034e6:	b083      	sub	sp, #12
 80034e8:	af00      	add	r7, sp, #0
 80034ea:	6078      	str	r0, [r7, #4]
 80034ec:	6039      	str	r1, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 80034ee:	b672      	cpsid	i
}
 80034f0:	bf00      	nop
    __disable_irq();
    *ptr |= bits;
 80034f2:	687b      	ldr	r3, [r7, #4]
 80034f4:	681a      	ldr	r2, [r3, #0]
 80034f6:	683b      	ldr	r3, [r7, #0]
 80034f8:	431a      	orrs	r2, r3
 80034fa:	687b      	ldr	r3, [r7, #4]
 80034fc:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80034fe:	b662      	cpsie	i
}
 8003500:	bf00      	nop
    __enable_irq();
}
 8003502:	bf00      	nop
 8003504:	370c      	adds	r7, #12
 8003506:	46bd      	mov	sp, r7
 8003508:	bc80      	pop	{r7}
 800350a:	4770      	bx	lr

0800350c <bitsClearAtomic>:

static uint_fast16_t bitsClearAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
 800350c:	b480      	push	{r7}
 800350e:	b085      	sub	sp, #20
 8003510:	af00      	add	r7, sp, #0
 8003512:	6078      	str	r0, [r7, #4]
 8003514:	6039      	str	r1, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8003516:	b672      	cpsid	i
}
 8003518:	bf00      	nop
    __disable_irq();
    uint_fast16_t prev = *ptr;
 800351a:	687b      	ldr	r3, [r7, #4]
 800351c:	681b      	ldr	r3, [r3, #0]
 800351e:	60fb      	str	r3, [r7, #12]
    *ptr &= ~bits;
 8003520:	687b      	ldr	r3, [r7, #4]
 8003522:	681a      	ldr	r2, [r3, #0]
 8003524:	683b      	ldr	r3, [r7, #0]
 8003526:	43db      	mvns	r3, r3
 8003528:	401a      	ands	r2, r3
 800352a:	687b      	ldr	r3, [r7, #4]
 800352c:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800352e:	b662      	cpsie	i
}
 8003530:	bf00      	nop
    __enable_irq();
    return prev;
 8003532:	68fb      	ldr	r3, [r7, #12]
}
 8003534:	4618      	mov	r0, r3
 8003536:	3714      	adds	r7, #20
 8003538:	46bd      	mov	sp, r7
 800353a:	bc80      	pop	{r7}
 800353c:	4770      	bx	lr

0800353e <valueSetAtomic>:

static uint_fast16_t valueSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t value)
{
 800353e:	b480      	push	{r7}
 8003540:	b085      	sub	sp, #20
 8003542:	af00      	add	r7, sp, #0
 8003544:	6078      	str	r0, [r7, #4]
 8003546:	6039      	str	r1, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8003548:	b672      	cpsid	i
}
 800354a:	bf00      	nop
    __disable_irq();
    uint_fast16_t prev = *ptr;
 800354c:	687b      	ldr	r3, [r7, #4]
 800354e:	681b      	ldr	r3, [r3, #0]
 8003550:	60fb      	str	r3, [r7, #12]
    *ptr = value;
 8003552:	687b      	ldr	r3, [r7, #4]
 8003554:	683a      	ldr	r2, [r7, #0]
 8003556:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8003558:	b662      	cpsie	i
}
 800355a:	bf00      	nop
    __enable_irq();
    return prev;
 800355c:	68fb      	ldr	r3, [r7, #12]
}
 800355e:	4618      	mov	r0, r3
 8003560:	3714      	adds	r7, #20
 8003562:	46bd      	mov	sp, r7
 8003564:	bc80      	pop	{r7}
 8003566:	4770      	bx	lr

08003568 <getElapsedTicks>:
}

#endif

static uint32_t getElapsedTicks (void)
{
 8003568:	b480      	push	{r7}
 800356a:	af00      	add	r7, sp, #0
    return uwTick;
 800356c:	4b02      	ldr	r3, [pc, #8]	; (8003578 <getElapsedTicks+0x10>)
 800356e:	681b      	ldr	r3, [r3, #0]
}
 8003570:	4618      	mov	r0, r3
 8003572:	46bd      	mov	sp, r7
 8003574:	bc80      	pop	{r7}
 8003576:	4770      	bx	lr
 8003578:	200004b0 	.word	0x200004b0

0800357c <gpio_irq_enable>:

void gpio_irq_enable (const input_signal_t *input, pin_irq_mode_t irq_mode)
{
 800357c:	b480      	push	{r7}
 800357e:	b083      	sub	sp, #12
 8003580:	af00      	add	r7, sp, #0
 8003582:	6078      	str	r0, [r7, #4]
 8003584:	460b      	mov	r3, r1
 8003586:	70fb      	strb	r3, [r7, #3]
    if(irq_mode == IRQ_Mode_Rising) {
 8003588:	78fb      	ldrb	r3, [r7, #3]
 800358a:	2b01      	cmp	r3, #1
 800358c:	d10f      	bne.n	80035ae <gpio_irq_enable+0x32>
        EXTI->RTSR |= input->bit;
 800358e:	4b26      	ldr	r3, [pc, #152]	; (8003628 <gpio_irq_enable+0xac>)
 8003590:	689a      	ldr	r2, [r3, #8]
 8003592:	687b      	ldr	r3, [r7, #4]
 8003594:	68db      	ldr	r3, [r3, #12]
 8003596:	4924      	ldr	r1, [pc, #144]	; (8003628 <gpio_irq_enable+0xac>)
 8003598:	4313      	orrs	r3, r2
 800359a:	608b      	str	r3, [r1, #8]
        EXTI->FTSR &= ~input->bit;
 800359c:	4b22      	ldr	r3, [pc, #136]	; (8003628 <gpio_irq_enable+0xac>)
 800359e:	68da      	ldr	r2, [r3, #12]
 80035a0:	687b      	ldr	r3, [r7, #4]
 80035a2:	68db      	ldr	r3, [r3, #12]
 80035a4:	43db      	mvns	r3, r3
 80035a6:	4920      	ldr	r1, [pc, #128]	; (8003628 <gpio_irq_enable+0xac>)
 80035a8:	4013      	ands	r3, r2
 80035aa:	60cb      	str	r3, [r1, #12]
 80035ac:	e02c      	b.n	8003608 <gpio_irq_enable+0x8c>
    } else if(irq_mode == IRQ_Mode_Falling) {
 80035ae:	78fb      	ldrb	r3, [r7, #3]
 80035b0:	2b02      	cmp	r3, #2
 80035b2:	d10f      	bne.n	80035d4 <gpio_irq_enable+0x58>
        EXTI->RTSR &= ~input->bit;
 80035b4:	4b1c      	ldr	r3, [pc, #112]	; (8003628 <gpio_irq_enable+0xac>)
 80035b6:	689a      	ldr	r2, [r3, #8]
 80035b8:	687b      	ldr	r3, [r7, #4]
 80035ba:	68db      	ldr	r3, [r3, #12]
 80035bc:	43db      	mvns	r3, r3
 80035be:	491a      	ldr	r1, [pc, #104]	; (8003628 <gpio_irq_enable+0xac>)
 80035c0:	4013      	ands	r3, r2
 80035c2:	608b      	str	r3, [r1, #8]
        EXTI->FTSR |= input->bit;
 80035c4:	4b18      	ldr	r3, [pc, #96]	; (8003628 <gpio_irq_enable+0xac>)
 80035c6:	68da      	ldr	r2, [r3, #12]
 80035c8:	687b      	ldr	r3, [r7, #4]
 80035ca:	68db      	ldr	r3, [r3, #12]
 80035cc:	4916      	ldr	r1, [pc, #88]	; (8003628 <gpio_irq_enable+0xac>)
 80035ce:	4313      	orrs	r3, r2
 80035d0:	60cb      	str	r3, [r1, #12]
 80035d2:	e019      	b.n	8003608 <gpio_irq_enable+0x8c>
    } else if(irq_mode == IRQ_Mode_Change) {
 80035d4:	78fb      	ldrb	r3, [r7, #3]
 80035d6:	2b04      	cmp	r3, #4
 80035d8:	d10e      	bne.n	80035f8 <gpio_irq_enable+0x7c>
        EXTI->RTSR |= input->bit;
 80035da:	4b13      	ldr	r3, [pc, #76]	; (8003628 <gpio_irq_enable+0xac>)
 80035dc:	689a      	ldr	r2, [r3, #8]
 80035de:	687b      	ldr	r3, [r7, #4]
 80035e0:	68db      	ldr	r3, [r3, #12]
 80035e2:	4911      	ldr	r1, [pc, #68]	; (8003628 <gpio_irq_enable+0xac>)
 80035e4:	4313      	orrs	r3, r2
 80035e6:	608b      	str	r3, [r1, #8]
        EXTI->FTSR |= input->bit;
 80035e8:	4b0f      	ldr	r3, [pc, #60]	; (8003628 <gpio_irq_enable+0xac>)
 80035ea:	68da      	ldr	r2, [r3, #12]
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	68db      	ldr	r3, [r3, #12]
 80035f0:	490d      	ldr	r1, [pc, #52]	; (8003628 <gpio_irq_enable+0xac>)
 80035f2:	4313      	orrs	r3, r2
 80035f4:	60cb      	str	r3, [r1, #12]
 80035f6:	e007      	b.n	8003608 <gpio_irq_enable+0x8c>
    } else
        EXTI->IMR &= ~input->bit;   // Disable pin interrupt
 80035f8:	4b0b      	ldr	r3, [pc, #44]	; (8003628 <gpio_irq_enable+0xac>)
 80035fa:	681a      	ldr	r2, [r3, #0]
 80035fc:	687b      	ldr	r3, [r7, #4]
 80035fe:	68db      	ldr	r3, [r3, #12]
 8003600:	43db      	mvns	r3, r3
 8003602:	4909      	ldr	r1, [pc, #36]	; (8003628 <gpio_irq_enable+0xac>)
 8003604:	4013      	ands	r3, r2
 8003606:	600b      	str	r3, [r1, #0]

    if(irq_mode != IRQ_Mode_None)
 8003608:	78fb      	ldrb	r3, [r7, #3]
 800360a:	2b00      	cmp	r3, #0
 800360c:	d006      	beq.n	800361c <gpio_irq_enable+0xa0>
        EXTI->IMR |= input->bit;    // Enable pin interrupt
 800360e:	4b06      	ldr	r3, [pc, #24]	; (8003628 <gpio_irq_enable+0xac>)
 8003610:	681a      	ldr	r2, [r3, #0]
 8003612:	687b      	ldr	r3, [r7, #4]
 8003614:	68db      	ldr	r3, [r3, #12]
 8003616:	4904      	ldr	r1, [pc, #16]	; (8003628 <gpio_irq_enable+0xac>)
 8003618:	4313      	orrs	r3, r2
 800361a:	600b      	str	r3, [r1, #0]
}
 800361c:	bf00      	nop
 800361e:	370c      	adds	r7, #12
 8003620:	46bd      	mov	sp, r7
 8003622:	bc80      	pop	{r7}
 8003624:	4770      	bx	lr
 8003626:	bf00      	nop
 8003628:	40010400 	.word	0x40010400

0800362c <settings_changed>:

// Configures peripherals when settings are initialized or changed
void settings_changed (settings_t *settings, settings_changed_flags_t changed)
{
 800362c:	b580      	push	{r7, lr}
 800362e:	b08e      	sub	sp, #56	; 0x38
 8003630:	af00      	add	r7, sp, #0
 8003632:	6078      	str	r0, [r7, #4]
 8003634:	7039      	strb	r1, [r7, #0]
#if USE_STEPDIR_MAP
    stepdirmap_init (settings);
 8003636:	6878      	ldr	r0, [r7, #4]
 8003638:	f7ff f9cc 	bl	80029d4 <stepdirmap_init>
#endif

    stepperSetStepOutputs((axes_signals_t){0});
 800363c:	2300      	movs	r3, #0
 800363e:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8003642:	4bbb      	ldr	r3, [pc, #748]	; (8003930 <settings_changed+0x304>)
 8003644:	68db      	ldr	r3, [r3, #12]
 8003646:	f423 7228 	bic.w	r2, r3, #672	; 0x2a0
 800364a:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 800364e:	4619      	mov	r1, r3
 8003650:	4bb8      	ldr	r3, [pc, #736]	; (8003934 <settings_changed+0x308>)
 8003652:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8003656:	49b6      	ldr	r1, [pc, #728]	; (8003930 <settings_changed+0x304>)
 8003658:	4313      	orrs	r3, r2
 800365a:	60cb      	str	r3, [r1, #12]
}
 800365c:	bf00      	nop
    stepperSetDirOutputs((axes_signals_t){0});
 800365e:	2300      	movs	r3, #0
 8003660:	f887 3020 	strb.w	r3, [r7, #32]
    dir_outbits.mask ^= settings.steppers.dir_invert.mask;
 8003664:	f897 2020 	ldrb.w	r2, [r7, #32]
 8003668:	4bb3      	ldr	r3, [pc, #716]	; (8003938 <settings_changed+0x30c>)
 800366a:	f893 30e9 	ldrb.w	r3, [r3, #233]	; 0xe9
 800366e:	4053      	eors	r3, r2
 8003670:	b2db      	uxtb	r3, r3
 8003672:	f887 3020 	strb.w	r3, [r7, #32]
    DIGITAL_OUT(X_DIRECTION_PORT, X_DIRECTION_PIN, dir_outbits.x);
 8003676:	f897 3020 	ldrb.w	r3, [r7, #32]
 800367a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800367e:	b2da      	uxtb	r2, r3
 8003680:	4bae      	ldr	r3, [pc, #696]	; (800393c <settings_changed+0x310>)
 8003682:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Y_DIRECTION_PORT, Y_DIRECTION_PIN, dir_outbits.y);
 8003684:	f897 3020 	ldrb.w	r3, [r7, #32]
 8003688:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800368c:	b2da      	uxtb	r2, r3
 800368e:	4bac      	ldr	r3, [pc, #688]	; (8003940 <settings_changed+0x314>)
 8003690:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Z_DIRECTION_PORT, Z_DIRECTION_PIN, dir_outbits.z);
 8003692:	f897 3020 	ldrb.w	r3, [r7, #32]
 8003696:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800369a:	b2da      	uxtb	r2, r3
 800369c:	4ba9      	ldr	r3, [pc, #676]	; (8003944 <settings_changed+0x318>)
 800369e:	701a      	strb	r2, [r3, #0]
}
 80036a0:	bf00      	nop

#ifdef SQUARING_ENABLED
    hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
#endif

    if(IOInitDone) {
 80036a2:	4ba9      	ldr	r3, [pc, #676]	; (8003948 <settings_changed+0x31c>)
 80036a4:	781b      	ldrb	r3, [r3, #0]
 80036a6:	2b00      	cmp	r3, #0
 80036a8:	f000 82b7 	beq.w	8003c1a <settings_changed+0x5ee>

        GPIO_InitTypeDef GPIO_Init = {
 80036ac:	f107 0310 	add.w	r3, r7, #16
 80036b0:	2200      	movs	r2, #0
 80036b2:	601a      	str	r2, [r3, #0]
 80036b4:	605a      	str	r2, [r3, #4]
 80036b6:	609a      	str	r2, [r3, #8]
 80036b8:	60da      	str	r2, [r3, #12]
 80036ba:	2303      	movs	r3, #3
 80036bc:	61fb      	str	r3, [r7, #28]
            .Speed = GPIO_SPEED_FREQ_HIGH
        };

#if DRIVER_SPINDLE_PWM_ENABLE
        if(changed.spindle) {
 80036be:	783b      	ldrb	r3, [r7, #0]
 80036c0:	f003 0301 	and.w	r3, r3, #1
 80036c4:	b2db      	uxtb	r3, r3
 80036c6:	2b00      	cmp	r3, #0
 80036c8:	d019      	beq.n	80036fe <settings_changed+0xd2>
            spindleConfig(spindle_get_hal(spindle_id, SpindleHAL_Configured));
 80036ca:	4ba0      	ldr	r3, [pc, #640]	; (800394c <settings_changed+0x320>)
 80036cc:	f993 3000 	ldrsb.w	r3, [r3]
 80036d0:	2101      	movs	r1, #1
 80036d2:	4618      	mov	r0, r3
 80036d4:	f018 ffdc 	bl	801c690 <spindle_get_hal>
 80036d8:	4603      	mov	r3, r0
 80036da:	4618      	mov	r0, r3
 80036dc:	f7ff fdb6 	bl	800324c <spindleConfig>
            if(spindle_id == spindle_get_default())
 80036e0:	f019 f848 	bl	801c774 <spindle_get_default>
 80036e4:	4603      	mov	r3, r0
 80036e6:	461a      	mov	r2, r3
 80036e8:	4b98      	ldr	r3, [pc, #608]	; (800394c <settings_changed+0x320>)
 80036ea:	f993 3000 	ldrsb.w	r3, [r3]
 80036ee:	429a      	cmp	r2, r3
 80036f0:	d105      	bne.n	80036fe <settings_changed+0xd2>
                spindle_select(spindle_id);
 80036f2:	4b96      	ldr	r3, [pc, #600]	; (800394c <settings_changed+0x320>)
 80036f4:	f993 3000 	ldrsb.w	r3, [r3]
 80036f8:	4618      	mov	r0, r3
 80036fa:	f018 ff95 	bl	801c628 <spindle_select>
        }
#endif // DRIVER_SPINDLE_PWM_ENABLE

        pulse_length = (uint32_t)(10.0f * (settings->steppers.pulse_microseconds - STEP_PULSE_LATENCY)) - 1;
 80036fe:	687b      	ldr	r3, [r7, #4]
 8003700:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8003704:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8003708:	4618      	mov	r0, r3
 800370a:	f7fd fa49 	bl	8000ba0 <__aeabi_fsub>
 800370e:	4603      	mov	r3, r0
 8003710:	498f      	ldr	r1, [pc, #572]	; (8003950 <settings_changed+0x324>)
 8003712:	4618      	mov	r0, r3
 8003714:	f7fd fb4e 	bl	8000db4 <__aeabi_fmul>
 8003718:	4603      	mov	r3, r0
 800371a:	4618      	mov	r0, r3
 800371c:	f7fd fd4c 	bl	80011b8 <__aeabi_f2uiz>
 8003720:	4603      	mov	r3, r0
 8003722:	3b01      	subs	r3, #1
 8003724:	4a8b      	ldr	r2, [pc, #556]	; (8003954 <settings_changed+0x328>)
 8003726:	6013      	str	r3, [r2, #0]

        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds > 0.0f) {
 8003728:	4b8b      	ldr	r3, [pc, #556]	; (8003958 <settings_changed+0x32c>)
 800372a:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800372e:	f003 0304 	and.w	r3, r3, #4
 8003732:	b2db      	uxtb	r3, r3
 8003734:	2b00      	cmp	r3, #0
 8003736:	d035      	beq.n	80037a4 <settings_changed+0x178>
 8003738:	687b      	ldr	r3, [r7, #4]
 800373a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800373e:	f04f 0100 	mov.w	r1, #0
 8003742:	4618      	mov	r0, r3
 8003744:	f7fd fcf2 	bl	800112c <__aeabi_fcmpgt>
 8003748:	4603      	mov	r3, r0
 800374a:	2b00      	cmp	r3, #0
 800374c:	d02a      	beq.n	80037a4 <settings_changed+0x178>
            pulse_delay = (uint32_t)(10.0f * (settings->steppers.pulse_delay_microseconds - 1.1f));
 800374e:	687b      	ldr	r3, [r7, #4]
 8003750:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8003754:	4981      	ldr	r1, [pc, #516]	; (800395c <settings_changed+0x330>)
 8003756:	4618      	mov	r0, r3
 8003758:	f7fd fa22 	bl	8000ba0 <__aeabi_fsub>
 800375c:	4603      	mov	r3, r0
 800375e:	497c      	ldr	r1, [pc, #496]	; (8003950 <settings_changed+0x324>)
 8003760:	4618      	mov	r0, r3
 8003762:	f7fd fb27 	bl	8000db4 <__aeabi_fmul>
 8003766:	4603      	mov	r3, r0
 8003768:	4618      	mov	r0, r3
 800376a:	f7fd fd25 	bl	80011b8 <__aeabi_f2uiz>
 800376e:	4603      	mov	r3, r0
 8003770:	4a7b      	ldr	r2, [pc, #492]	; (8003960 <settings_changed+0x334>)
 8003772:	6013      	str	r3, [r2, #0]
            if(pulse_delay < 2)
 8003774:	4b7a      	ldr	r3, [pc, #488]	; (8003960 <settings_changed+0x334>)
 8003776:	681b      	ldr	r3, [r3, #0]
 8003778:	2b01      	cmp	r3, #1
 800377a:	d803      	bhi.n	8003784 <settings_changed+0x158>
                pulse_delay = 2;
 800377c:	4b78      	ldr	r3, [pc, #480]	; (8003960 <settings_changed+0x334>)
 800377e:	2202      	movs	r2, #2
 8003780:	601a      	str	r2, [r3, #0]
 8003782:	e00a      	b.n	800379a <settings_changed+0x16e>
            else if(pulse_delay == pulse_length)
 8003784:	4b76      	ldr	r3, [pc, #472]	; (8003960 <settings_changed+0x334>)
 8003786:	681a      	ldr	r2, [r3, #0]
 8003788:	4b72      	ldr	r3, [pc, #456]	; (8003954 <settings_changed+0x328>)
 800378a:	681b      	ldr	r3, [r3, #0]
 800378c:	429a      	cmp	r2, r3
 800378e:	d104      	bne.n	800379a <settings_changed+0x16e>
                pulse_delay++;
 8003790:	4b73      	ldr	r3, [pc, #460]	; (8003960 <settings_changed+0x334>)
 8003792:	681b      	ldr	r3, [r3, #0]
 8003794:	3301      	adds	r3, #1
 8003796:	4a72      	ldr	r2, [pc, #456]	; (8003960 <settings_changed+0x334>)
 8003798:	6013      	str	r3, [r2, #0]
            hal.stepper.pulse_start = &stepperPulseStartDelayed;
 800379a:	4b6f      	ldr	r3, [pc, #444]	; (8003958 <settings_changed+0x32c>)
 800379c:	4a71      	ldr	r2, [pc, #452]	; (8003964 <settings_changed+0x338>)
 800379e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 80037a2:	e006      	b.n	80037b2 <settings_changed+0x186>
        } else {
            pulse_delay = 0;
 80037a4:	4b6e      	ldr	r3, [pc, #440]	; (8003960 <settings_changed+0x334>)
 80037a6:	2200      	movs	r2, #0
 80037a8:	601a      	str	r2, [r3, #0]
            hal.stepper.pulse_start = &stepperPulseStart;
 80037aa:	4b6b      	ldr	r3, [pc, #428]	; (8003958 <settings_changed+0x32c>)
 80037ac:	4a6e      	ldr	r2, [pc, #440]	; (8003968 <settings_changed+0x33c>)
 80037ae:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        }

        PULSE_TIMER->ARR = pulse_length;
 80037b2:	4a6e      	ldr	r2, [pc, #440]	; (800396c <settings_changed+0x340>)
 80037b4:	4b67      	ldr	r3, [pc, #412]	; (8003954 <settings_changed+0x328>)
 80037b6:	681b      	ldr	r3, [r3, #0]
 80037b8:	62d3      	str	r3, [r2, #44]	; 0x2c
        PULSE_TIMER->EGR = TIM_EGR_UG;
 80037ba:	4b6c      	ldr	r3, [pc, #432]	; (800396c <settings_changed+0x340>)
 80037bc:	2201      	movs	r2, #1
 80037be:	615a      	str	r2, [r3, #20]
#endif
#if (DRIVER_IRQMASK|AUXINPUT_MASK) & (1<<4)
        HAL_NVIC_DisableIRQ(EXTI4_IRQn);
#endif
#if (DRIVER_IRQMASK|AUXINPUT_MASK) & 0x03E0
        HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);
 80037c0:	2017      	movs	r0, #23
 80037c2:	f7fe f926 	bl	8001a12 <HAL_NVIC_DisableIRQ>
#endif
#if (DRIVER_IRQMASK|AUXINPUT_MASK) & 0xFC00
        HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 80037c6:	2028      	movs	r0, #40	; 0x28
 80037c8:	f7fe f923 	bl	8001a12 <HAL_NVIC_DisableIRQ>
#endif

        bool pullup;
        uint32_t i = sizeof(inputpin) / sizeof(input_signal_t);
 80037cc:	2307      	movs	r3, #7
 80037ce:	633b      	str	r3, [r7, #48]	; 0x30
        input_signal_t *input;

        control_signals_t control_fei;
        control_fei.mask = settings->control_disable_pullup.mask ^ settings->control_invert.mask;
 80037d0:	687b      	ldr	r3, [r7, #4]
 80037d2:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 80037d6:	687b      	ldr	r3, [r7, #4]
 80037d8:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80037dc:	4053      	eors	r3, r2
 80037de:	b29b      	uxth	r3, r3
 80037e0:	81bb      	strh	r3, [r7, #12]

        axes_signals_t limit_fei;
        limit_fei.mask = settings->limits.disable_pullup.mask ^ settings->limits.invert.mask;
 80037e2:	687b      	ldr	r3, [r7, #4]
 80037e4:	f893 2126 	ldrb.w	r2, [r3, #294]	; 0x126
 80037e8:	687b      	ldr	r3, [r7, #4]
 80037ea:	f893 3125 	ldrb.w	r3, [r3, #293]	; 0x125
 80037ee:	4053      	eors	r3, r2
 80037f0:	b2db      	uxtb	r3, r3
 80037f2:	723b      	strb	r3, [r7, #8]

        do {

            pullup = false;
 80037f4:	2300      	movs	r3, #0
 80037f6:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            input = &inputpin[--i];
 80037fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80037fc:	3b01      	subs	r3, #1
 80037fe:	633b      	str	r3, [r7, #48]	; 0x30
 8003800:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003802:	4613      	mov	r3, r2
 8003804:	00db      	lsls	r3, r3, #3
 8003806:	4413      	add	r3, r2
 8003808:	009b      	lsls	r3, r3, #2
 800380a:	4a59      	ldr	r2, [pc, #356]	; (8003970 <settings_changed+0x344>)
 800380c:	4413      	add	r3, r2
 800380e:	62fb      	str	r3, [r7, #44]	; 0x2c
            input->irq_mode = IRQ_Mode_None;
 8003810:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003812:	2200      	movs	r2, #0
 8003814:	759a      	strb	r2, [r3, #22]
            input->bit = 1 << input->pin;
 8003816:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003818:	7a1b      	ldrb	r3, [r3, #8]
 800381a:	461a      	mov	r2, r3
 800381c:	2301      	movs	r3, #1
 800381e:	4093      	lsls	r3, r2
 8003820:	461a      	mov	r2, r3
 8003822:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003824:	60da      	str	r2, [r3, #12]

            switch(input->id) {
 8003826:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003828:	781b      	ldrb	r3, [r3, #0]
 800382a:	2b31      	cmp	r3, #49	; 0x31
 800382c:	f200 819c 	bhi.w	8003b68 <settings_changed+0x53c>
 8003830:	a201      	add	r2, pc, #4	; (adr r2, 8003838 <settings_changed+0x20c>)
 8003832:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003836:	bf00      	nop
 8003838:	08003a05 	.word	0x08003a05
 800383c:	08003b69 	.word	0x08003b69
 8003840:	08003975 	.word	0x08003975
 8003844:	080039a5 	.word	0x080039a5
 8003848:	080039d5 	.word	0x080039d5
 800384c:	08003b69 	.word	0x08003b69
 8003850:	08003901 	.word	0x08003901
 8003854:	08003b69 	.word	0x08003b69
 8003858:	08003b69 	.word	0x08003b69
 800385c:	08003b69 	.word	0x08003b69
 8003860:	08003b69 	.word	0x08003b69
 8003864:	08003b3f 	.word	0x08003b3f
 8003868:	08003a1f 	.word	0x08003a1f
 800386c:	08003a1f 	.word	0x08003a1f
 8003870:	08003a1f 	.word	0x08003a1f
 8003874:	08003b69 	.word	0x08003b69
 8003878:	08003a4f 	.word	0x08003a4f
 800387c:	08003a4f 	.word	0x08003a4f
 8003880:	08003a4f 	.word	0x08003a4f
 8003884:	08003b69 	.word	0x08003b69
 8003888:	08003a7f 	.word	0x08003a7f
 800388c:	08003a7f 	.word	0x08003a7f
 8003890:	08003a7f 	.word	0x08003a7f
 8003894:	08003b69 	.word	0x08003b69
 8003898:	08003aaf 	.word	0x08003aaf
 800389c:	08003aaf 	.word	0x08003aaf
 80038a0:	08003b69 	.word	0x08003b69
 80038a4:	08003adf 	.word	0x08003adf
 80038a8:	08003adf 	.word	0x08003adf
 80038ac:	08003b69 	.word	0x08003b69
 80038b0:	08003b0f 	.word	0x08003b0f
 80038b4:	08003b0f 	.word	0x08003b0f
 80038b8:	08003b69 	.word	0x08003b69
 80038bc:	08003b69 	.word	0x08003b69
 80038c0:	08003b69 	.word	0x08003b69
 80038c4:	08003b69 	.word	0x08003b69
 80038c8:	08003b69 	.word	0x08003b69
 80038cc:	08003b69 	.word	0x08003b69
 80038d0:	08003b69 	.word	0x08003b69
 80038d4:	08003b69 	.word	0x08003b69
 80038d8:	08003b69 	.word	0x08003b69
 80038dc:	08003b69 	.word	0x08003b69
 80038e0:	08003b69 	.word	0x08003b69
 80038e4:	08003b4d 	.word	0x08003b4d
 80038e8:	08003b69 	.word	0x08003b69
 80038ec:	08003b69 	.word	0x08003b69
 80038f0:	08003b69 	.word	0x08003b69
 80038f4:	08003b69 	.word	0x08003b69
 80038f8:	08003b69 	.word	0x08003b69
 80038fc:	08003b5b 	.word	0x08003b5b

#if ESTOP_ENABLE
                case Input_EStop:
                    pullup = !settings->control_disable_pullup.e_stop;
 8003900:	687b      	ldr	r3, [r7, #4]
 8003902:	f893 306e 	ldrb.w	r3, [r3, #110]	; 0x6e
 8003906:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800390a:	b2db      	uxtb	r3, r3
 800390c:	2b00      	cmp	r3, #0
 800390e:	bf0c      	ite	eq
 8003910:	2301      	moveq	r3, #1
 8003912:	2300      	movne	r3, #0
 8003914:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = control_fei.e_stop ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003918:	7b3b      	ldrb	r3, [r7, #12]
 800391a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800391e:	b2db      	uxtb	r3, r3
 8003920:	2b00      	cmp	r3, #0
 8003922:	d001      	beq.n	8003928 <settings_changed+0x2fc>
 8003924:	2202      	movs	r2, #2
 8003926:	e000      	b.n	800392a <settings_changed+0x2fe>
 8003928:	2201      	movs	r2, #1
 800392a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800392c:	759a      	strb	r2, [r3, #22]
                    break;
 800392e:	e11c      	b.n	8003b6a <settings_changed+0x53e>
 8003930:	40010c00 	.word	0x40010c00
 8003934:	200004b4 	.word	0x200004b4
 8003938:	2000147c 	.word	0x2000147c
 800393c:	42220188 	.word	0x42220188
 8003940:	422181a0 	.word	0x422181a0
 8003944:	42218198 	.word	0x42218198
 8003948:	200004e0 	.word	0x200004e0
 800394c:	20000210 	.word	0x20000210
 8003950:	41200000 	.word	0x41200000
 8003954:	200004d4 	.word	0x200004d4
 8003958:	20000ed0 	.word	0x20000ed0
 800395c:	3f8ccccd 	.word	0x3f8ccccd
 8003960:	200004d8 	.word	0x200004d8
 8003964:	08002c41 	.word	0x08002c41
 8003968:	08002b95 	.word	0x08002b95
 800396c:	40000400 	.word	0x40000400
 8003970:	2000000c 	.word	0x2000000c
                    pullup = !settings->control_disable_pullup.reset;
                    input->irq_mode = control_fei.reset ? IRQ_Mode_Falling : IRQ_Mode_Rising;
                    break;
#endif
                case Input_FeedHold:
                    pullup = !settings->control_disable_pullup.feed_hold;
 8003974:	687b      	ldr	r3, [r7, #4]
 8003976:	f893 306e 	ldrb.w	r3, [r3, #110]	; 0x6e
 800397a:	f003 0302 	and.w	r3, r3, #2
 800397e:	b2db      	uxtb	r3, r3
 8003980:	2b00      	cmp	r3, #0
 8003982:	bf0c      	ite	eq
 8003984:	2301      	moveq	r3, #1
 8003986:	2300      	movne	r3, #0
 8003988:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = control_fei.feed_hold ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 800398c:	7b3b      	ldrb	r3, [r7, #12]
 800398e:	f003 0302 	and.w	r3, r3, #2
 8003992:	b2db      	uxtb	r3, r3
 8003994:	2b00      	cmp	r3, #0
 8003996:	d001      	beq.n	800399c <settings_changed+0x370>
 8003998:	2202      	movs	r2, #2
 800399a:	e000      	b.n	800399e <settings_changed+0x372>
 800399c:	2201      	movs	r2, #1
 800399e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80039a0:	759a      	strb	r2, [r3, #22]
                    break;
 80039a2:	e0e2      	b.n	8003b6a <settings_changed+0x53e>

                case Input_CycleStart:
                    pullup = !settings->control_disable_pullup.cycle_start;
 80039a4:	687b      	ldr	r3, [r7, #4]
 80039a6:	f893 306e 	ldrb.w	r3, [r3, #110]	; 0x6e
 80039aa:	f003 0304 	and.w	r3, r3, #4
 80039ae:	b2db      	uxtb	r3, r3
 80039b0:	2b00      	cmp	r3, #0
 80039b2:	bf0c      	ite	eq
 80039b4:	2301      	moveq	r3, #1
 80039b6:	2300      	movne	r3, #0
 80039b8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = control_fei.cycle_start ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 80039bc:	7b3b      	ldrb	r3, [r7, #12]
 80039be:	f003 0304 	and.w	r3, r3, #4
 80039c2:	b2db      	uxtb	r3, r3
 80039c4:	2b00      	cmp	r3, #0
 80039c6:	d001      	beq.n	80039cc <settings_changed+0x3a0>
 80039c8:	2202      	movs	r2, #2
 80039ca:	e000      	b.n	80039ce <settings_changed+0x3a2>
 80039cc:	2201      	movs	r2, #1
 80039ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80039d0:	759a      	strb	r2, [r3, #22]
                    break;
 80039d2:	e0ca      	b.n	8003b6a <settings_changed+0x53e>

                case Input_SafetyDoor:
                    pullup = !settings->control_disable_pullup.safety_door_ajar;
 80039d4:	687b      	ldr	r3, [r7, #4]
 80039d6:	f893 306e 	ldrb.w	r3, [r3, #110]	; 0x6e
 80039da:	f003 0308 	and.w	r3, r3, #8
 80039de:	b2db      	uxtb	r3, r3
 80039e0:	2b00      	cmp	r3, #0
 80039e2:	bf0c      	ite	eq
 80039e4:	2301      	moveq	r3, #1
 80039e6:	2300      	movne	r3, #0
 80039e8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = control_fei.safety_door_ajar ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 80039ec:	7b3b      	ldrb	r3, [r7, #12]
 80039ee:	f003 0308 	and.w	r3, r3, #8
 80039f2:	b2db      	uxtb	r3, r3
 80039f4:	2b00      	cmp	r3, #0
 80039f6:	d001      	beq.n	80039fc <settings_changed+0x3d0>
 80039f8:	2202      	movs	r2, #2
 80039fa:	e000      	b.n	80039fe <settings_changed+0x3d2>
 80039fc:	2201      	movs	r2, #1
 80039fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003a00:	759a      	strb	r2, [r3, #22]
                    break;
 8003a02:	e0b2      	b.n	8003b6a <settings_changed+0x53e>

                case Input_Probe:
                    pullup = hal.driver_cap.probe_pull_up;
 8003a04:	4b8f      	ldr	r3, [pc, #572]	; (8003c44 <settings_changed+0x618>)
 8003a06:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8003a0a:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8003a0e:	b2db      	uxtb	r3, r3
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	bf14      	ite	ne
 8003a14:	2301      	movne	r3, #1
 8003a16:	2300      	moveq	r3, #0
 8003a18:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    break;
 8003a1c:	e0a5      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitX:
                case Input_LimitX_2:
                case Input_LimitX_Max:
                    pullup = !settings->limits.disable_pullup.x;
 8003a1e:	687b      	ldr	r3, [r7, #4]
 8003a20:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003a24:	f003 0301 	and.w	r3, r3, #1
 8003a28:	b2db      	uxtb	r3, r3
 8003a2a:	2b00      	cmp	r3, #0
 8003a2c:	bf0c      	ite	eq
 8003a2e:	2301      	moveq	r3, #1
 8003a30:	2300      	movne	r3, #0
 8003a32:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.x ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003a36:	7a3b      	ldrb	r3, [r7, #8]
 8003a38:	f003 0301 	and.w	r3, r3, #1
 8003a3c:	b2db      	uxtb	r3, r3
 8003a3e:	2b00      	cmp	r3, #0
 8003a40:	d001      	beq.n	8003a46 <settings_changed+0x41a>
 8003a42:	2202      	movs	r2, #2
 8003a44:	e000      	b.n	8003a48 <settings_changed+0x41c>
 8003a46:	2201      	movs	r2, #1
 8003a48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003a4a:	759a      	strb	r2, [r3, #22]
                    break;
 8003a4c:	e08d      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitY:
                case Input_LimitY_2:
                case Input_LimitY_Max:
                    pullup = !settings->limits.disable_pullup.y;
 8003a4e:	687b      	ldr	r3, [r7, #4]
 8003a50:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003a54:	f003 0302 	and.w	r3, r3, #2
 8003a58:	b2db      	uxtb	r3, r3
 8003a5a:	2b00      	cmp	r3, #0
 8003a5c:	bf0c      	ite	eq
 8003a5e:	2301      	moveq	r3, #1
 8003a60:	2300      	movne	r3, #0
 8003a62:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.y ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003a66:	7a3b      	ldrb	r3, [r7, #8]
 8003a68:	f003 0302 	and.w	r3, r3, #2
 8003a6c:	b2db      	uxtb	r3, r3
 8003a6e:	2b00      	cmp	r3, #0
 8003a70:	d001      	beq.n	8003a76 <settings_changed+0x44a>
 8003a72:	2202      	movs	r2, #2
 8003a74:	e000      	b.n	8003a78 <settings_changed+0x44c>
 8003a76:	2201      	movs	r2, #1
 8003a78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003a7a:	759a      	strb	r2, [r3, #22]
                    break;
 8003a7c:	e075      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitZ:
                case Input_LimitZ_2:
                case Input_LimitZ_Max:
                    pullup = !settings->limits.disable_pullup.z;
 8003a7e:	687b      	ldr	r3, [r7, #4]
 8003a80:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003a84:	f003 0304 	and.w	r3, r3, #4
 8003a88:	b2db      	uxtb	r3, r3
 8003a8a:	2b00      	cmp	r3, #0
 8003a8c:	bf0c      	ite	eq
 8003a8e:	2301      	moveq	r3, #1
 8003a90:	2300      	movne	r3, #0
 8003a92:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.z ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003a96:	7a3b      	ldrb	r3, [r7, #8]
 8003a98:	f003 0304 	and.w	r3, r3, #4
 8003a9c:	b2db      	uxtb	r3, r3
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	d001      	beq.n	8003aa6 <settings_changed+0x47a>
 8003aa2:	2202      	movs	r2, #2
 8003aa4:	e000      	b.n	8003aa8 <settings_changed+0x47c>
 8003aa6:	2201      	movs	r2, #1
 8003aa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003aaa:	759a      	strb	r2, [r3, #22]
                    break;
 8003aac:	e05d      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitA:
                case Input_LimitA_Max:
                    pullup = !settings->limits.disable_pullup.a;
 8003aae:	687b      	ldr	r3, [r7, #4]
 8003ab0:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003ab4:	f003 0308 	and.w	r3, r3, #8
 8003ab8:	b2db      	uxtb	r3, r3
 8003aba:	2b00      	cmp	r3, #0
 8003abc:	bf0c      	ite	eq
 8003abe:	2301      	moveq	r3, #1
 8003ac0:	2300      	movne	r3, #0
 8003ac2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.a ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003ac6:	7a3b      	ldrb	r3, [r7, #8]
 8003ac8:	f003 0308 	and.w	r3, r3, #8
 8003acc:	b2db      	uxtb	r3, r3
 8003ace:	2b00      	cmp	r3, #0
 8003ad0:	d001      	beq.n	8003ad6 <settings_changed+0x4aa>
 8003ad2:	2202      	movs	r2, #2
 8003ad4:	e000      	b.n	8003ad8 <settings_changed+0x4ac>
 8003ad6:	2201      	movs	r2, #1
 8003ad8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003ada:	759a      	strb	r2, [r3, #22]
                    break;
 8003adc:	e045      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitB:
                case Input_LimitB_Max:
                    pullup = !settings->limits.disable_pullup.b;
 8003ade:	687b      	ldr	r3, [r7, #4]
 8003ae0:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003ae4:	f003 0310 	and.w	r3, r3, #16
 8003ae8:	b2db      	uxtb	r3, r3
 8003aea:	2b00      	cmp	r3, #0
 8003aec:	bf0c      	ite	eq
 8003aee:	2301      	moveq	r3, #1
 8003af0:	2300      	movne	r3, #0
 8003af2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.b ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003af6:	7a3b      	ldrb	r3, [r7, #8]
 8003af8:	f003 0310 	and.w	r3, r3, #16
 8003afc:	b2db      	uxtb	r3, r3
 8003afe:	2b00      	cmp	r3, #0
 8003b00:	d001      	beq.n	8003b06 <settings_changed+0x4da>
 8003b02:	2202      	movs	r2, #2
 8003b04:	e000      	b.n	8003b08 <settings_changed+0x4dc>
 8003b06:	2201      	movs	r2, #1
 8003b08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b0a:	759a      	strb	r2, [r3, #22]
                    break;
 8003b0c:	e02d      	b.n	8003b6a <settings_changed+0x53e>

                case Input_LimitC:
                case Input_LimitC_Max:
                    pullup = !settings->limits.disable_pullup.c;
 8003b0e:	687b      	ldr	r3, [r7, #4]
 8003b10:	f893 3126 	ldrb.w	r3, [r3, #294]	; 0x126
 8003b14:	f003 0320 	and.w	r3, r3, #32
 8003b18:	b2db      	uxtb	r3, r3
 8003b1a:	2b00      	cmp	r3, #0
 8003b1c:	bf0c      	ite	eq
 8003b1e:	2301      	moveq	r3, #1
 8003b20:	2300      	movne	r3, #0
 8003b22:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = limit_fei.c ? IRQ_Mode_Falling : IRQ_Mode_Rising;
 8003b26:	7a3b      	ldrb	r3, [r7, #8]
 8003b28:	f003 0320 	and.w	r3, r3, #32
 8003b2c:	b2db      	uxtb	r3, r3
 8003b2e:	2b00      	cmp	r3, #0
 8003b30:	d001      	beq.n	8003b36 <settings_changed+0x50a>
 8003b32:	2202      	movs	r2, #2
 8003b34:	e000      	b.n	8003b38 <settings_changed+0x50c>
 8003b36:	2201      	movs	r2, #1
 8003b38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b3a:	759a      	strb	r2, [r3, #22]
                    break;
 8003b3c:	e015      	b.n	8003b6a <settings_changed+0x53e>

                case Input_MPGSelect:
                    pullup = true;
 8003b3e:	2301      	movs	r3, #1
 8003b40:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = IRQ_Mode_Change;
 8003b44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b46:	2204      	movs	r2, #4
 8003b48:	759a      	strb	r2, [r3, #22]
                    break;
 8003b4a:	e00e      	b.n	8003b6a <settings_changed+0x53e>

                case Input_I2CStrobe:
                    pullup = true;
 8003b4c:	2301      	movs	r3, #1
 8003b4e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = IRQ_Mode_Change;
 8003b52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b54:	2204      	movs	r2, #4
 8003b56:	759a      	strb	r2, [r3, #22]
                    break;
 8003b58:	e007      	b.n	8003b6a <settings_changed+0x53e>

                case Input_SpindleIndex:
                    pullup = true;
 8003b5a:	2301      	movs	r3, #1
 8003b5c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    input->irq_mode = IRQ_Mode_Falling;
 8003b60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b62:	2202      	movs	r2, #2
 8003b64:	759a      	strb	r2, [r3, #22]
                    break;
 8003b66:	e000      	b.n	8003b6a <settings_changed+0x53e>

                default:
                    break;
 8003b68:	bf00      	nop
                }
            }

#endif

            GPIO_Init.Pin = 1 << input->pin;
 8003b6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b6c:	7a1b      	ldrb	r3, [r3, #8]
 8003b6e:	461a      	mov	r2, r3
 8003b70:	2301      	movs	r3, #1
 8003b72:	4093      	lsls	r3, r2
 8003b74:	613b      	str	r3, [r7, #16]
            GPIO_Init.Pull = pullup ? GPIO_PULLUP : GPIO_PULLDOWN;
 8003b76:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8003b7a:	2b00      	cmp	r3, #0
 8003b7c:	d001      	beq.n	8003b82 <settings_changed+0x556>
 8003b7e:	2301      	movs	r3, #1
 8003b80:	e000      	b.n	8003b84 <settings_changed+0x558>
 8003b82:	2302      	movs	r3, #2
 8003b84:	61bb      	str	r3, [r7, #24]

            switch(input->irq_mode) {
 8003b86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003b88:	7d9b      	ldrb	r3, [r3, #22]
 8003b8a:	2b04      	cmp	r3, #4
 8003b8c:	d00c      	beq.n	8003ba8 <settings_changed+0x57c>
 8003b8e:	2b04      	cmp	r3, #4
 8003b90:	dc0d      	bgt.n	8003bae <settings_changed+0x582>
 8003b92:	2b01      	cmp	r3, #1
 8003b94:	d002      	beq.n	8003b9c <settings_changed+0x570>
 8003b96:	2b02      	cmp	r3, #2
 8003b98:	d003      	beq.n	8003ba2 <settings_changed+0x576>
 8003b9a:	e008      	b.n	8003bae <settings_changed+0x582>
                case IRQ_Mode_Rising:
                    GPIO_Init.Mode = GPIO_MODE_IT_RISING;
 8003b9c:	4b2a      	ldr	r3, [pc, #168]	; (8003c48 <settings_changed+0x61c>)
 8003b9e:	617b      	str	r3, [r7, #20]
                    break;
 8003ba0:	e008      	b.n	8003bb4 <settings_changed+0x588>
                case IRQ_Mode_Falling:
                    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
 8003ba2:	4b2a      	ldr	r3, [pc, #168]	; (8003c4c <settings_changed+0x620>)
 8003ba4:	617b      	str	r3, [r7, #20]
                    break;
 8003ba6:	e005      	b.n	8003bb4 <settings_changed+0x588>
                case IRQ_Mode_Change:
                    GPIO_Init.Mode = GPIO_MODE_IT_RISING_FALLING;
 8003ba8:	4b29      	ldr	r3, [pc, #164]	; (8003c50 <settings_changed+0x624>)
 8003baa:	617b      	str	r3, [r7, #20]
                    break;
 8003bac:	e002      	b.n	8003bb4 <settings_changed+0x588>
                default:
                    GPIO_Init.Mode = GPIO_MODE_INPUT;
 8003bae:	2300      	movs	r3, #0
 8003bb0:	617b      	str	r3, [r7, #20]
                    break;
 8003bb2:	bf00      	nop
            }
            HAL_GPIO_Init(input->port, &GPIO_Init);
 8003bb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003bb6:	685b      	ldr	r3, [r3, #4]
 8003bb8:	f107 0210 	add.w	r2, r7, #16
 8003bbc:	4611      	mov	r1, r2
 8003bbe:	4618      	mov	r0, r3
 8003bc0:	f7fd ff42 	bl	8001a48 <HAL_GPIO_Init>

            input->debounce = false;
 8003bc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003bc6:	2200      	movs	r2, #0
 8003bc8:	755a      	strb	r2, [r3, #21]

        } while(i);
 8003bca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003bcc:	2b00      	cmp	r3, #0
 8003bce:	f47f ae11 	bne.w	80037f4 <settings_changed+0x1c8>

        uint32_t irq_mask = DRIVER_IRQMASK|aux_irq;
 8003bd2:	4b20      	ldr	r3, [pc, #128]	; (8003c54 <settings_changed+0x628>)
 8003bd4:	681b      	ldr	r3, [r3, #0]
 8003bd6:	f443 43e1 	orr.w	r3, r3, #28800	; 0x7080
 8003bda:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8003bde:	62bb      	str	r3, [r7, #40]	; 0x28

        __HAL_GPIO_EXTI_CLEAR_IT(irq_mask);
 8003be0:	4a1d      	ldr	r2, [pc, #116]	; (8003c58 <settings_changed+0x62c>)
 8003be2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003be4:	6153      	str	r3, [r2, #20]
            HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 2);
            HAL_NVIC_EnableIRQ(EXTI4_IRQn);
        }
#endif
#if (DRIVER_IRQMASK|AUXINPUT_MASK) & 0x03E0
        if(irq_mask & 0x03E0) {
 8003be6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003be8:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 8003bec:	2b00      	cmp	r3, #0
 8003bee:	d007      	beq.n	8003c00 <settings_changed+0x5d4>
            HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 2);
 8003bf0:	2202      	movs	r2, #2
 8003bf2:	2100      	movs	r1, #0
 8003bf4:	2017      	movs	r0, #23
 8003bf6:	f7fd fee2 	bl	80019be <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8003bfa:	2017      	movs	r0, #23
 8003bfc:	f7fd fefb 	bl	80019f6 <HAL_NVIC_EnableIRQ>
        }
#endif
#if (DRIVER_IRQMASK|AUXINPUT_MASK) & 0xFC00
        if(irq_mask & 0xFC00) {
 8003c00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003c02:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8003c06:	2b00      	cmp	r3, #0
 8003c08:	d007      	beq.n	8003c1a <settings_changed+0x5ee>
            HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 2);
 8003c0a:	2202      	movs	r2, #2
 8003c0c:	2100      	movs	r1, #0
 8003c0e:	2028      	movs	r0, #40	; 0x28
 8003c10:	f7fd fed5 	bl	80019be <HAL_NVIC_SetPriority>
            HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8003c14:	2028      	movs	r0, #40	; 0x28
 8003c16:	f7fd feee 	bl	80019f6 <HAL_NVIC_EnableIRQ>
        }
#endif
    }

    hal.limits.enable(settings->limits.flags.hard_enabled, (axes_signals_t){0});
 8003c1a:	4b0a      	ldr	r3, [pc, #40]	; (8003c44 <settings_changed+0x618>)
 8003c1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003c1e:	687a      	ldr	r2, [r7, #4]
 8003c20:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 8003c24:	f3c2 0200 	ubfx	r2, r2, #0, #1
 8003c28:	b2d2      	uxtb	r2, r2
 8003c2a:	2a00      	cmp	r2, #0
 8003c2c:	bf14      	ite	ne
 8003c2e:	2201      	movne	r2, #1
 8003c30:	2200      	moveq	r2, #0
 8003c32:	b2d2      	uxtb	r2, r2
 8003c34:	2100      	movs	r1, #0
 8003c36:	4610      	mov	r0, r2
 8003c38:	4798      	blx	r3
}
 8003c3a:	bf00      	nop
 8003c3c:	3738      	adds	r7, #56	; 0x38
 8003c3e:	46bd      	mov	sp, r7
 8003c40:	bd80      	pop	{r7, pc}
 8003c42:	bf00      	nop
 8003c44:	20000ed0 	.word	0x20000ed0
 8003c48:	10110000 	.word	0x10110000
 8003c4c:	10210000 	.word	0x10210000
 8003c50:	10310000 	.word	0x10310000
 8003c54:	200004dc 	.word	0x200004dc
 8003c58:	40010400 	.word	0x40010400

08003c5c <port2char>:

static char *port2char (GPIO_TypeDef *port)
{
 8003c5c:	b480      	push	{r7}
 8003c5e:	b083      	sub	sp, #12
 8003c60:	af00      	add	r7, sp, #0
 8003c62:	6078      	str	r0, [r7, #4]
    static char name[3] = "P?";

    name[1] = 'A' + GPIO_GET_INDEX(port);
 8003c64:	687b      	ldr	r3, [r7, #4]
 8003c66:	4a16      	ldr	r2, [pc, #88]	; (8003cc0 <port2char+0x64>)
 8003c68:	4293      	cmp	r3, r2
 8003c6a:	d01f      	beq.n	8003cac <port2char+0x50>
 8003c6c:	687b      	ldr	r3, [r7, #4]
 8003c6e:	4a15      	ldr	r2, [pc, #84]	; (8003cc4 <port2char+0x68>)
 8003c70:	4293      	cmp	r3, r2
 8003c72:	d019      	beq.n	8003ca8 <port2char+0x4c>
 8003c74:	687b      	ldr	r3, [r7, #4]
 8003c76:	4a14      	ldr	r2, [pc, #80]	; (8003cc8 <port2char+0x6c>)
 8003c78:	4293      	cmp	r3, r2
 8003c7a:	d013      	beq.n	8003ca4 <port2char+0x48>
 8003c7c:	687b      	ldr	r3, [r7, #4]
 8003c7e:	4a13      	ldr	r2, [pc, #76]	; (8003ccc <port2char+0x70>)
 8003c80:	4293      	cmp	r3, r2
 8003c82:	d00d      	beq.n	8003ca0 <port2char+0x44>
 8003c84:	687b      	ldr	r3, [r7, #4]
 8003c86:	4a12      	ldr	r2, [pc, #72]	; (8003cd0 <port2char+0x74>)
 8003c88:	4293      	cmp	r3, r2
 8003c8a:	d007      	beq.n	8003c9c <port2char+0x40>
 8003c8c:	687b      	ldr	r3, [r7, #4]
 8003c8e:	4a11      	ldr	r2, [pc, #68]	; (8003cd4 <port2char+0x78>)
 8003c90:	4293      	cmp	r3, r2
 8003c92:	d101      	bne.n	8003c98 <port2char+0x3c>
 8003c94:	2346      	movs	r3, #70	; 0x46
 8003c96:	e00a      	b.n	8003cae <port2char+0x52>
 8003c98:	2347      	movs	r3, #71	; 0x47
 8003c9a:	e008      	b.n	8003cae <port2char+0x52>
 8003c9c:	2345      	movs	r3, #69	; 0x45
 8003c9e:	e006      	b.n	8003cae <port2char+0x52>
 8003ca0:	2344      	movs	r3, #68	; 0x44
 8003ca2:	e004      	b.n	8003cae <port2char+0x52>
 8003ca4:	2343      	movs	r3, #67	; 0x43
 8003ca6:	e002      	b.n	8003cae <port2char+0x52>
 8003ca8:	2342      	movs	r3, #66	; 0x42
 8003caa:	e000      	b.n	8003cae <port2char+0x52>
 8003cac:	2341      	movs	r3, #65	; 0x41
 8003cae:	4a0a      	ldr	r2, [pc, #40]	; (8003cd8 <port2char+0x7c>)
 8003cb0:	7053      	strb	r3, [r2, #1]

    return name;
 8003cb2:	4b09      	ldr	r3, [pc, #36]	; (8003cd8 <port2char+0x7c>)
}
 8003cb4:	4618      	mov	r0, r3
 8003cb6:	370c      	adds	r7, #12
 8003cb8:	46bd      	mov	sp, r7
 8003cba:	bc80      	pop	{r7}
 8003cbc:	4770      	bx	lr
 8003cbe:	bf00      	nop
 8003cc0:	40010800 	.word	0x40010800
 8003cc4:	40010c00 	.word	0x40010c00
 8003cc8:	40011000 	.word	0x40011000
 8003ccc:	40011400 	.word	0x40011400
 8003cd0:	40011800 	.word	0x40011800
 8003cd4:	40011c00 	.word	0x40011c00
 8003cd8:	20000220 	.word	0x20000220

08003cdc <enumeratePins>:

static void enumeratePins (bool low_level, pin_info_ptr pin_info, void *data)
{
 8003cdc:	b580      	push	{r7, lr}
 8003cde:	b086      	sub	sp, #24
 8003ce0:	af00      	add	r7, sp, #0
 8003ce2:	4603      	mov	r3, r0
 8003ce4:	60b9      	str	r1, [r7, #8]
 8003ce6:	607a      	str	r2, [r7, #4]
 8003ce8:	73fb      	strb	r3, [r7, #15]
    static xbar_t pin = {0};
    uint32_t i = sizeof(inputpin) / sizeof(input_signal_t);
 8003cea:	2307      	movs	r3, #7
 8003cec:	617b      	str	r3, [r7, #20]

    pin.mode.input = On;
 8003cee:	4a71      	ldr	r2, [pc, #452]	; (8003eb4 <enumeratePins+0x1d8>)
 8003cf0:	7e13      	ldrb	r3, [r2, #24]
 8003cf2:	f043 0301 	orr.w	r3, r3, #1
 8003cf6:	7613      	strb	r3, [r2, #24]

    for(i = 0; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 8003cf8:	2300      	movs	r3, #0
 8003cfa:	617b      	str	r3, [r7, #20]
 8003cfc:	e05a      	b.n	8003db4 <enumeratePins+0xd8>
        pin.pin = inputpin[i].pin;
 8003cfe:	496e      	ldr	r1, [pc, #440]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d00:	697a      	ldr	r2, [r7, #20]
 8003d02:	4613      	mov	r3, r2
 8003d04:	00db      	lsls	r3, r3, #3
 8003d06:	4413      	add	r3, r2
 8003d08:	009b      	lsls	r3, r3, #2
 8003d0a:	440b      	add	r3, r1
 8003d0c:	3308      	adds	r3, #8
 8003d0e:	781b      	ldrb	r3, [r3, #0]
 8003d10:	461a      	mov	r2, r3
 8003d12:	4b68      	ldr	r3, [pc, #416]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d14:	611a      	str	r2, [r3, #16]
        pin.function = inputpin[i].id;
 8003d16:	4968      	ldr	r1, [pc, #416]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d18:	697a      	ldr	r2, [r7, #20]
 8003d1a:	4613      	mov	r3, r2
 8003d1c:	00db      	lsls	r3, r3, #3
 8003d1e:	4413      	add	r3, r2
 8003d20:	009b      	lsls	r3, r3, #2
 8003d22:	440b      	add	r3, r1
 8003d24:	781a      	ldrb	r2, [r3, #0]
 8003d26:	4b63      	ldr	r3, [pc, #396]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d28:	701a      	strb	r2, [r3, #0]
        pin.group = inputpin[i].group;
 8003d2a:	4963      	ldr	r1, [pc, #396]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d2c:	697a      	ldr	r2, [r7, #20]
 8003d2e:	4613      	mov	r3, r2
 8003d30:	00db      	lsls	r3, r3, #3
 8003d32:	4413      	add	r3, r2
 8003d34:	009b      	lsls	r3, r3, #2
 8003d36:	440b      	add	r3, r1
 8003d38:	3310      	adds	r3, #16
 8003d3a:	681b      	ldr	r3, [r3, #0]
 8003d3c:	4a5d      	ldr	r2, [pc, #372]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d3e:	6053      	str	r3, [r2, #4]
        pin.port = low_level ? (void *)inputpin[i].port : (void *)port2char(inputpin[i].port);
 8003d40:	7bfb      	ldrb	r3, [r7, #15]
 8003d42:	2b00      	cmp	r3, #0
 8003d44:	d009      	beq.n	8003d5a <enumeratePins+0x7e>
 8003d46:	495c      	ldr	r1, [pc, #368]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d48:	697a      	ldr	r2, [r7, #20]
 8003d4a:	4613      	mov	r3, r2
 8003d4c:	00db      	lsls	r3, r3, #3
 8003d4e:	4413      	add	r3, r2
 8003d50:	009b      	lsls	r3, r3, #2
 8003d52:	440b      	add	r3, r1
 8003d54:	3304      	adds	r3, #4
 8003d56:	681b      	ldr	r3, [r3, #0]
 8003d58:	e00c      	b.n	8003d74 <enumeratePins+0x98>
 8003d5a:	4957      	ldr	r1, [pc, #348]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d5c:	697a      	ldr	r2, [r7, #20]
 8003d5e:	4613      	mov	r3, r2
 8003d60:	00db      	lsls	r3, r3, #3
 8003d62:	4413      	add	r3, r2
 8003d64:	009b      	lsls	r3, r3, #2
 8003d66:	440b      	add	r3, r1
 8003d68:	3304      	adds	r3, #4
 8003d6a:	681b      	ldr	r3, [r3, #0]
 8003d6c:	4618      	mov	r0, r3
 8003d6e:	f7ff ff75 	bl	8003c5c <port2char>
 8003d72:	4603      	mov	r3, r0
 8003d74:	4a4f      	ldr	r2, [pc, #316]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d76:	6093      	str	r3, [r2, #8]
        pin.description = inputpin[i].description;
 8003d78:	494f      	ldr	r1, [pc, #316]	; (8003eb8 <enumeratePins+0x1dc>)
 8003d7a:	697a      	ldr	r2, [r7, #20]
 8003d7c:	4613      	mov	r3, r2
 8003d7e:	00db      	lsls	r3, r3, #3
 8003d80:	4413      	add	r3, r2
 8003d82:	009b      	lsls	r3, r3, #2
 8003d84:	440b      	add	r3, r1
 8003d86:	3320      	adds	r3, #32
 8003d88:	681b      	ldr	r3, [r3, #0]
 8003d8a:	4a4a      	ldr	r2, [pc, #296]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d8c:	60d3      	str	r3, [r2, #12]
        pin.mode.pwm = pin.group == PinGroup_SpindlePWM;
 8003d8e:	4b49      	ldr	r3, [pc, #292]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d90:	685b      	ldr	r3, [r3, #4]
 8003d92:	2b01      	cmp	r3, #1
 8003d94:	bf0c      	ite	eq
 8003d96:	2301      	moveq	r3, #1
 8003d98:	2300      	movne	r3, #0
 8003d9a:	b2d9      	uxtb	r1, r3
 8003d9c:	4a45      	ldr	r2, [pc, #276]	; (8003eb4 <enumeratePins+0x1d8>)
 8003d9e:	7e53      	ldrb	r3, [r2, #25]
 8003da0:	f361 0382 	bfi	r3, r1, #2, #1
 8003da4:	7653      	strb	r3, [r2, #25]

        pin_info(&pin, data);
 8003da6:	68bb      	ldr	r3, [r7, #8]
 8003da8:	6879      	ldr	r1, [r7, #4]
 8003daa:	4842      	ldr	r0, [pc, #264]	; (8003eb4 <enumeratePins+0x1d8>)
 8003dac:	4798      	blx	r3
    for(i = 0; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 8003dae:	697b      	ldr	r3, [r7, #20]
 8003db0:	3301      	adds	r3, #1
 8003db2:	617b      	str	r3, [r7, #20]
 8003db4:	697b      	ldr	r3, [r7, #20]
 8003db6:	2b06      	cmp	r3, #6
 8003db8:	d9a1      	bls.n	8003cfe <enumeratePins+0x22>
    };

    pin.mode.mask = 0;
 8003dba:	4b3e      	ldr	r3, [pc, #248]	; (8003eb4 <enumeratePins+0x1d8>)
 8003dbc:	2200      	movs	r2, #0
 8003dbe:	831a      	strh	r2, [r3, #24]
    pin.mode.output = On;
 8003dc0:	4a3c      	ldr	r2, [pc, #240]	; (8003eb4 <enumeratePins+0x1d8>)
 8003dc2:	7e13      	ldrb	r3, [r2, #24]
 8003dc4:	f043 0302 	orr.w	r3, r3, #2
 8003dc8:	7613      	strb	r3, [r2, #24]

    for(i = 0; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 8003dca:	2300      	movs	r3, #0
 8003dcc:	617b      	str	r3, [r7, #20]
 8003dce:	e04e      	b.n	8003e6e <enumeratePins+0x192>
        pin.pin = outputpin[i].pin;
 8003dd0:	493a      	ldr	r1, [pc, #232]	; (8003ebc <enumeratePins+0x1e0>)
 8003dd2:	697a      	ldr	r2, [r7, #20]
 8003dd4:	4613      	mov	r3, r2
 8003dd6:	005b      	lsls	r3, r3, #1
 8003dd8:	4413      	add	r3, r2
 8003dda:	00db      	lsls	r3, r3, #3
 8003ddc:	440b      	add	r3, r1
 8003dde:	3308      	adds	r3, #8
 8003de0:	781b      	ldrb	r3, [r3, #0]
 8003de2:	461a      	mov	r2, r3
 8003de4:	4b33      	ldr	r3, [pc, #204]	; (8003eb4 <enumeratePins+0x1d8>)
 8003de6:	611a      	str	r2, [r3, #16]
        pin.function = outputpin[i].id;
 8003de8:	4934      	ldr	r1, [pc, #208]	; (8003ebc <enumeratePins+0x1e0>)
 8003dea:	697a      	ldr	r2, [r7, #20]
 8003dec:	4613      	mov	r3, r2
 8003dee:	005b      	lsls	r3, r3, #1
 8003df0:	4413      	add	r3, r2
 8003df2:	00db      	lsls	r3, r3, #3
 8003df4:	440b      	add	r3, r1
 8003df6:	781a      	ldrb	r2, [r3, #0]
 8003df8:	4b2e      	ldr	r3, [pc, #184]	; (8003eb4 <enumeratePins+0x1d8>)
 8003dfa:	701a      	strb	r2, [r3, #0]
        pin.group = outputpin[i].group;
 8003dfc:	492f      	ldr	r1, [pc, #188]	; (8003ebc <enumeratePins+0x1e0>)
 8003dfe:	697a      	ldr	r2, [r7, #20]
 8003e00:	4613      	mov	r3, r2
 8003e02:	005b      	lsls	r3, r3, #1
 8003e04:	4413      	add	r3, r2
 8003e06:	00db      	lsls	r3, r3, #3
 8003e08:	440b      	add	r3, r1
 8003e0a:	330c      	adds	r3, #12
 8003e0c:	681b      	ldr	r3, [r3, #0]
 8003e0e:	4a29      	ldr	r2, [pc, #164]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e10:	6053      	str	r3, [r2, #4]
        pin.port = low_level ? (void *)outputpin[i].port : (void *)port2char(outputpin[i].port);
 8003e12:	7bfb      	ldrb	r3, [r7, #15]
 8003e14:	2b00      	cmp	r3, #0
 8003e16:	d009      	beq.n	8003e2c <enumeratePins+0x150>
 8003e18:	4928      	ldr	r1, [pc, #160]	; (8003ebc <enumeratePins+0x1e0>)
 8003e1a:	697a      	ldr	r2, [r7, #20]
 8003e1c:	4613      	mov	r3, r2
 8003e1e:	005b      	lsls	r3, r3, #1
 8003e20:	4413      	add	r3, r2
 8003e22:	00db      	lsls	r3, r3, #3
 8003e24:	440b      	add	r3, r1
 8003e26:	3304      	adds	r3, #4
 8003e28:	681b      	ldr	r3, [r3, #0]
 8003e2a:	e00c      	b.n	8003e46 <enumeratePins+0x16a>
 8003e2c:	4923      	ldr	r1, [pc, #140]	; (8003ebc <enumeratePins+0x1e0>)
 8003e2e:	697a      	ldr	r2, [r7, #20]
 8003e30:	4613      	mov	r3, r2
 8003e32:	005b      	lsls	r3, r3, #1
 8003e34:	4413      	add	r3, r2
 8003e36:	00db      	lsls	r3, r3, #3
 8003e38:	440b      	add	r3, r1
 8003e3a:	3304      	adds	r3, #4
 8003e3c:	681b      	ldr	r3, [r3, #0]
 8003e3e:	4618      	mov	r0, r3
 8003e40:	f7ff ff0c 	bl	8003c5c <port2char>
 8003e44:	4603      	mov	r3, r0
 8003e46:	4a1b      	ldr	r2, [pc, #108]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e48:	6093      	str	r3, [r2, #8]
        pin.description = outputpin[i].description;
 8003e4a:	491c      	ldr	r1, [pc, #112]	; (8003ebc <enumeratePins+0x1e0>)
 8003e4c:	697a      	ldr	r2, [r7, #20]
 8003e4e:	4613      	mov	r3, r2
 8003e50:	005b      	lsls	r3, r3, #1
 8003e52:	4413      	add	r3, r2
 8003e54:	00db      	lsls	r3, r3, #3
 8003e56:	440b      	add	r3, r1
 8003e58:	3314      	adds	r3, #20
 8003e5a:	681b      	ldr	r3, [r3, #0]
 8003e5c:	4a15      	ldr	r2, [pc, #84]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e5e:	60d3      	str	r3, [r2, #12]

        pin_info(&pin, data);
 8003e60:	68bb      	ldr	r3, [r7, #8]
 8003e62:	6879      	ldr	r1, [r7, #4]
 8003e64:	4813      	ldr	r0, [pc, #76]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e66:	4798      	blx	r3
    for(i = 0; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 8003e68:	697b      	ldr	r3, [r7, #20]
 8003e6a:	3301      	adds	r3, #1
 8003e6c:	617b      	str	r3, [r7, #20]
 8003e6e:	697b      	ldr	r3, [r7, #20]
 8003e70:	2b0a      	cmp	r3, #10
 8003e72:	d9ad      	bls.n	8003dd0 <enumeratePins+0xf4>
    } while((ppin = ppin->next));

#endif

#if DRIVER_SPINDLE_PWM_ENABLE
    pin.pin = SPINDLE_PWM_PIN;
 8003e74:	4b0f      	ldr	r3, [pc, #60]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e76:	2208      	movs	r2, #8
 8003e78:	611a      	str	r2, [r3, #16]
    pin.function = Output_SpindlePWM;
 8003e7a:	4b0e      	ldr	r3, [pc, #56]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e7c:	2272      	movs	r2, #114	; 0x72
 8003e7e:	701a      	strb	r2, [r3, #0]
    pin.group = PinGroup_SpindlePWM;
 8003e80:	4b0c      	ldr	r3, [pc, #48]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e82:	2201      	movs	r2, #1
 8003e84:	605a      	str	r2, [r3, #4]
    pin.port = low_level ? (void *)SPINDLE_PWM_PORT : (void *)port2char(SPINDLE_PWM_PORT);
 8003e86:	7bfb      	ldrb	r3, [r7, #15]
 8003e88:	2b00      	cmp	r3, #0
 8003e8a:	d104      	bne.n	8003e96 <enumeratePins+0x1ba>
 8003e8c:	480c      	ldr	r0, [pc, #48]	; (8003ec0 <enumeratePins+0x1e4>)
 8003e8e:	f7ff fee5 	bl	8003c5c <port2char>
 8003e92:	4603      	mov	r3, r0
 8003e94:	e000      	b.n	8003e98 <enumeratePins+0x1bc>
 8003e96:	4b0a      	ldr	r3, [pc, #40]	; (8003ec0 <enumeratePins+0x1e4>)
 8003e98:	4a06      	ldr	r2, [pc, #24]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e9a:	6093      	str	r3, [r2, #8]
    pin.description = NULL;
 8003e9c:	4b05      	ldr	r3, [pc, #20]	; (8003eb4 <enumeratePins+0x1d8>)
 8003e9e:	2200      	movs	r2, #0
 8003ea0:	60da      	str	r2, [r3, #12]
    pin_info(&pin, data);
 8003ea2:	68bb      	ldr	r3, [r7, #8]
 8003ea4:	6879      	ldr	r1, [r7, #4]
 8003ea6:	4803      	ldr	r0, [pc, #12]	; (8003eb4 <enumeratePins+0x1d8>)
 8003ea8:	4798      	blx	r3
#endif
}
 8003eaa:	bf00      	nop
 8003eac:	3718      	adds	r7, #24
 8003eae:	46bd      	mov	sp, r7
 8003eb0:	bd80      	pop	{r7, pc}
 8003eb2:	bf00      	nop
 8003eb4:	20000558 	.word	0x20000558
 8003eb8:	2000000c 	.word	0x2000000c
 8003ebc:	20000108 	.word	0x20000108
 8003ec0:	40010800 	.word	0x40010800

08003ec4 <jtag_enable>:
}

#endif

static status_code_t jtag_enable (uint_fast16_t state, char *line)
{
 8003ec4:	b580      	push	{r7, lr}
 8003ec6:	b084      	sub	sp, #16
 8003ec8:	af00      	add	r7, sp, #0
 8003eca:	6078      	str	r0, [r7, #4]
 8003ecc:	6039      	str	r1, [r7, #0]
    if(!strcmp(line, "$PGM")) {
 8003ece:	4913      	ldr	r1, [pc, #76]	; (8003f1c <jtag_enable+0x58>)
 8003ed0:	6838      	ldr	r0, [r7, #0]
 8003ed2:	f7fc f9a9 	bl	8000228 <strcmp>
 8003ed6:	4603      	mov	r3, r0
 8003ed8:	2b00      	cmp	r3, #0
 8003eda:	d10e      	bne.n	8003efa <jtag_enable+0x36>
        __HAL_AFIO_REMAP_SWJ_ENABLE();
 8003edc:	4b10      	ldr	r3, [pc, #64]	; (8003f20 <jtag_enable+0x5c>)
 8003ede:	685b      	ldr	r3, [r3, #4]
 8003ee0:	60fb      	str	r3, [r7, #12]
 8003ee2:	68fb      	ldr	r3, [r7, #12]
 8003ee4:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8003ee8:	60fb      	str	r3, [r7, #12]
 8003eea:	4a0d      	ldr	r2, [pc, #52]	; (8003f20 <jtag_enable+0x5c>)
 8003eec:	68fb      	ldr	r3, [r7, #12]
 8003eee:	6053      	str	r3, [r2, #4]
        on_unknown_sys_command = NULL;
 8003ef0:	4b0c      	ldr	r3, [pc, #48]	; (8003f24 <jtag_enable+0x60>)
 8003ef2:	2200      	movs	r2, #0
 8003ef4:	601a      	str	r2, [r3, #0]
        return Status_OK;
 8003ef6:	2300      	movs	r3, #0
 8003ef8:	e00b      	b.n	8003f12 <jtag_enable+0x4e>
    }

    return on_unknown_sys_command ? on_unknown_sys_command(state, line) : Status_Unhandled;
 8003efa:	4b0a      	ldr	r3, [pc, #40]	; (8003f24 <jtag_enable+0x60>)
 8003efc:	681b      	ldr	r3, [r3, #0]
 8003efe:	2b00      	cmp	r3, #0
 8003f00:	d006      	beq.n	8003f10 <jtag_enable+0x4c>
 8003f02:	4b08      	ldr	r3, [pc, #32]	; (8003f24 <jtag_enable+0x60>)
 8003f04:	681b      	ldr	r3, [r3, #0]
 8003f06:	6839      	ldr	r1, [r7, #0]
 8003f08:	6878      	ldr	r0, [r7, #4]
 8003f0a:	4798      	blx	r3
 8003f0c:	4603      	mov	r3, r0
 8003f0e:	e000      	b.n	8003f12 <jtag_enable+0x4e>
 8003f10:	2354      	movs	r3, #84	; 0x54
}
 8003f12:	4618      	mov	r0, r3
 8003f14:	3710      	adds	r7, #16
 8003f16:	46bd      	mov	sp, r7
 8003f18:	bd80      	pop	{r7, pc}
 8003f1a:	bf00      	nop
 8003f1c:	08026ccc 	.word	0x08026ccc
 8003f20:	40010000 	.word	0x40010000
 8003f24:	20000550 	.word	0x20000550

08003f28 <driver_setup>:

// Initializes MCU peripherals for Grbl use
static bool driver_setup (settings_t *settings)
{
 8003f28:	b580      	push	{r7, lr}
 8003f2a:	b08c      	sub	sp, #48	; 0x30
 8003f2c:	af00      	add	r7, sp, #0
 8003f2e:	6078      	str	r0, [r7, #4]
  //    Interrupt_disableSleepOnIsrExit();

    PULSE_TIMER_CLKEN();
 8003f30:	4b4a      	ldr	r3, [pc, #296]	; (800405c <driver_setup+0x134>)
 8003f32:	69db      	ldr	r3, [r3, #28]
 8003f34:	4a49      	ldr	r2, [pc, #292]	; (800405c <driver_setup+0x134>)
 8003f36:	f043 0302 	orr.w	r3, r3, #2
 8003f3a:	61d3      	str	r3, [r2, #28]
 8003f3c:	4b47      	ldr	r3, [pc, #284]	; (800405c <driver_setup+0x134>)
 8003f3e:	69db      	ldr	r3, [r3, #28]
 8003f40:	f003 0302 	and.w	r3, r3, #2
 8003f44:	617b      	str	r3, [r7, #20]
 8003f46:	697b      	ldr	r3, [r7, #20]
    STEPPER_TIMER_CLKEN();
 8003f48:	4b44      	ldr	r3, [pc, #272]	; (800405c <driver_setup+0x134>)
 8003f4a:	69db      	ldr	r3, [r3, #28]
 8003f4c:	4a43      	ldr	r2, [pc, #268]	; (800405c <driver_setup+0x134>)
 8003f4e:	f043 0301 	orr.w	r3, r3, #1
 8003f52:	61d3      	str	r3, [r2, #28]
 8003f54:	4b41      	ldr	r3, [pc, #260]	; (800405c <driver_setup+0x134>)
 8003f56:	69db      	ldr	r3, [r3, #28]
 8003f58:	f003 0301 	and.w	r3, r3, #1
 8003f5c:	613b      	str	r3, [r7, #16]
 8003f5e:	693b      	ldr	r3, [r7, #16]
    DEBOUNCE_TIMER_CLKEN();
 8003f60:	4b3e      	ldr	r3, [pc, #248]	; (800405c <driver_setup+0x134>)
 8003f62:	69db      	ldr	r3, [r3, #28]
 8003f64:	4a3d      	ldr	r2, [pc, #244]	; (800405c <driver_setup+0x134>)
 8003f66:	f043 0304 	orr.w	r3, r3, #4
 8003f6a:	61d3      	str	r3, [r2, #28]
 8003f6c:	4b3b      	ldr	r3, [pc, #236]	; (800405c <driver_setup+0x134>)
 8003f6e:	69db      	ldr	r3, [r3, #28]
 8003f70:	f003 0304 	and.w	r3, r3, #4
 8003f74:	60fb      	str	r3, [r7, #12]
 8003f76:	68fb      	ldr	r3, [r7, #12]

    GPIO_InitTypeDef GPIO_Init = {
 8003f78:	f107 031c 	add.w	r3, r7, #28
 8003f7c:	2200      	movs	r2, #0
 8003f7e:	601a      	str	r2, [r3, #0]
 8003f80:	605a      	str	r2, [r3, #4]
 8003f82:	609a      	str	r2, [r3, #8]
 8003f84:	60da      	str	r2, [r3, #12]
 8003f86:	2301      	movs	r3, #1
 8003f88:	623b      	str	r3, [r7, #32]
 8003f8a:	2303      	movs	r3, #3
 8003f8c:	62bb      	str	r3, [r7, #40]	; 0x28
    /*************************
     *  Output signals init  *
     *************************/

    uint32_t i;
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 8003f8e:	2300      	movs	r3, #0
 8003f90:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003f92:	e07b      	b.n	800408c <driver_setup+0x164>

        if(outputpin[i].group == PinGroup_MotorChipSelect ||
 8003f94:	4932      	ldr	r1, [pc, #200]	; (8004060 <driver_setup+0x138>)
 8003f96:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003f98:	4613      	mov	r3, r2
 8003f9a:	005b      	lsls	r3, r3, #1
 8003f9c:	4413      	add	r3, r2
 8003f9e:	00db      	lsls	r3, r3, #3
 8003fa0:	440b      	add	r3, r1
 8003fa2:	330c      	adds	r3, #12
 8003fa4:	681b      	ldr	r3, [r3, #0]
 8003fa6:	2b0d      	cmp	r3, #13
 8003fa8:	d01f      	beq.n	8003fea <driver_setup+0xc2>
            outputpin[i].group == PinGroup_MotorUART ||
 8003faa:	492d      	ldr	r1, [pc, #180]	; (8004060 <driver_setup+0x138>)
 8003fac:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003fae:	4613      	mov	r3, r2
 8003fb0:	005b      	lsls	r3, r3, #1
 8003fb2:	4413      	add	r3, r2
 8003fb4:	00db      	lsls	r3, r3, #3
 8003fb6:	440b      	add	r3, r1
 8003fb8:	330c      	adds	r3, #12
 8003fba:	681b      	ldr	r3, [r3, #0]
        if(outputpin[i].group == PinGroup_MotorChipSelect ||
 8003fbc:	2b0e      	cmp	r3, #14
 8003fbe:	d014      	beq.n	8003fea <driver_setup+0xc2>
             outputpin[i].id == Output_SPICS ||
 8003fc0:	4927      	ldr	r1, [pc, #156]	; (8004060 <driver_setup+0x138>)
 8003fc2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003fc4:	4613      	mov	r3, r2
 8003fc6:	005b      	lsls	r3, r3, #1
 8003fc8:	4413      	add	r3, r2
 8003fca:	00db      	lsls	r3, r3, #3
 8003fcc:	440b      	add	r3, r1
 8003fce:	781b      	ldrb	r3, [r3, #0]
            outputpin[i].group == PinGroup_MotorUART ||
 8003fd0:	2b7a      	cmp	r3, #122	; 0x7a
 8003fd2:	d00a      	beq.n	8003fea <driver_setup+0xc2>
              outputpin[i].group == PinGroup_StepperEnable)
 8003fd4:	4922      	ldr	r1, [pc, #136]	; (8004060 <driver_setup+0x138>)
 8003fd6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003fd8:	4613      	mov	r3, r2
 8003fda:	005b      	lsls	r3, r3, #1
 8003fdc:	4413      	add	r3, r2
 8003fde:	00db      	lsls	r3, r3, #3
 8003fe0:	440b      	add	r3, r1
 8003fe2:	330c      	adds	r3, #12
 8003fe4:	681b      	ldr	r3, [r3, #0]
             outputpin[i].id == Output_SPICS ||
 8003fe6:	2b06      	cmp	r3, #6
 8003fe8:	d11b      	bne.n	8004022 <driver_setup+0xfa>
            DIGITAL_OUT(outputpin[i].port, outputpin[i].pin, 1);
 8003fea:	491d      	ldr	r1, [pc, #116]	; (8004060 <driver_setup+0x138>)
 8003fec:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003fee:	4613      	mov	r3, r2
 8003ff0:	005b      	lsls	r3, r3, #1
 8003ff2:	4413      	add	r3, r2
 8003ff4:	00db      	lsls	r3, r3, #3
 8003ff6:	440b      	add	r3, r1
 8003ff8:	3304      	adds	r3, #4
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	330c      	adds	r3, #12
 8003ffe:	f103 4342 	add.w	r3, r3, #3254779904	; 0xc2000000
 8004002:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 8004006:	0159      	lsls	r1, r3, #5
 8004008:	4815      	ldr	r0, [pc, #84]	; (8004060 <driver_setup+0x138>)
 800400a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800400c:	4613      	mov	r3, r2
 800400e:	005b      	lsls	r3, r3, #1
 8004010:	4413      	add	r3, r2
 8004012:	00db      	lsls	r3, r3, #3
 8004014:	4403      	add	r3, r0
 8004016:	3308      	adds	r3, #8
 8004018:	781b      	ldrb	r3, [r3, #0]
 800401a:	009b      	lsls	r3, r3, #2
 800401c:	440b      	add	r3, r1
 800401e:	2201      	movs	r2, #1
 8004020:	701a      	strb	r2, [r3, #0]

        GPIO_Init.Pin = 1 << outputpin[i].pin;
 8004022:	490f      	ldr	r1, [pc, #60]	; (8004060 <driver_setup+0x138>)
 8004024:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004026:	4613      	mov	r3, r2
 8004028:	005b      	lsls	r3, r3, #1
 800402a:	4413      	add	r3, r2
 800402c:	00db      	lsls	r3, r3, #3
 800402e:	440b      	add	r3, r1
 8004030:	3308      	adds	r3, #8
 8004032:	781b      	ldrb	r3, [r3, #0]
 8004034:	461a      	mov	r2, r3
 8004036:	2301      	movs	r3, #1
 8004038:	4093      	lsls	r3, r2
 800403a:	61fb      	str	r3, [r7, #28]
        GPIO_Init.Mode = outputpin[i].mode.open_drain ? GPIO_MODE_OUTPUT_OD : GPIO_MODE_OUTPUT_PP;
 800403c:	4908      	ldr	r1, [pc, #32]	; (8004060 <driver_setup+0x138>)
 800403e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004040:	4613      	mov	r3, r2
 8004042:	005b      	lsls	r3, r3, #1
 8004044:	4413      	add	r3, r2
 8004046:	00db      	lsls	r3, r3, #3
 8004048:	440b      	add	r3, r1
 800404a:	3310      	adds	r3, #16
 800404c:	781b      	ldrb	r3, [r3, #0]
 800404e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8004052:	b2db      	uxtb	r3, r3
 8004054:	2b00      	cmp	r3, #0
 8004056:	d005      	beq.n	8004064 <driver_setup+0x13c>
 8004058:	2311      	movs	r3, #17
 800405a:	e004      	b.n	8004066 <driver_setup+0x13e>
 800405c:	40021000 	.word	0x40021000
 8004060:	20000108 	.word	0x20000108
 8004064:	2301      	movs	r3, #1
 8004066:	623b      	str	r3, [r7, #32]
        HAL_GPIO_Init(outputpin[i].port, &GPIO_Init);
 8004068:	4978      	ldr	r1, [pc, #480]	; (800424c <driver_setup+0x324>)
 800406a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800406c:	4613      	mov	r3, r2
 800406e:	005b      	lsls	r3, r3, #1
 8004070:	4413      	add	r3, r2
 8004072:	00db      	lsls	r3, r3, #3
 8004074:	440b      	add	r3, r1
 8004076:	3304      	adds	r3, #4
 8004078:	681b      	ldr	r3, [r3, #0]
 800407a:	f107 021c 	add.w	r2, r7, #28
 800407e:	4611      	mov	r1, r2
 8004080:	4618      	mov	r0, r3
 8004082:	f7fd fce1 	bl	8001a48 <HAL_GPIO_Init>
    for(i = 0 ; i < sizeof(outputpin) / sizeof(output_signal_t); i++) {
 8004086:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004088:	3301      	adds	r3, #1
 800408a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800408c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800408e:	2b0a      	cmp	r3, #10
 8004090:	d980      	bls.n	8003f94 <driver_setup+0x6c>
    }

 // Stepper init

    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 8004092:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004096:	681b      	ldr	r3, [r3, #0]
 8004098:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800409c:	f023 0301 	bic.w	r3, r3, #1
 80040a0:	6013      	str	r3, [r2, #0]
    STEPPER_TIMER->SR &= ~TIM_SR_UIF;
 80040a2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80040a6:	691b      	ldr	r3, [r3, #16]
 80040a8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80040ac:	f023 0301 	bic.w	r3, r3, #1
 80040b0:	6113      	str	r3, [r2, #16]
    STEPPER_TIMER->CNT = 0;
 80040b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80040b6:	2200      	movs	r2, #0
 80040b8:	625a      	str	r2, [r3, #36]	; 0x24
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;
 80040ba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80040be:	68db      	ldr	r3, [r3, #12]
 80040c0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80040c4:	f043 0301 	orr.w	r3, r3, #1
 80040c8:	60d3      	str	r3, [r2, #12]

    NVIC_SetPriority(STEPPER_TIMER_IRQn, 1);
 80040ca:	2101      	movs	r1, #1
 80040cc:	201c      	movs	r0, #28
 80040ce:	f7fe fc01 	bl	80028d4 <__NVIC_SetPriority>
    NVIC_EnableIRQ(STEPPER_TIMER_IRQn);
 80040d2:	201c      	movs	r0, #28
 80040d4:	f7fe fbe2 	bl	800289c <__NVIC_EnableIRQ>

    // Single-shot 0.1 us per tick
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 80040d8:	4b5d      	ldr	r3, [pc, #372]	; (8004250 <driver_setup+0x328>)
 80040da:	681b      	ldr	r3, [r3, #0]
 80040dc:	4a5c      	ldr	r2, [pc, #368]	; (8004250 <driver_setup+0x328>)
 80040de:	f443 7327 	orr.w	r3, r3, #668	; 0x29c
 80040e2:	6013      	str	r3, [r2, #0]
    PULSE_TIMER->PSC = hal.f_step_timer / 10000000UL - 1;
 80040e4:	4b5b      	ldr	r3, [pc, #364]	; (8004254 <driver_setup+0x32c>)
 80040e6:	69db      	ldr	r3, [r3, #28]
 80040e8:	4a5b      	ldr	r2, [pc, #364]	; (8004258 <driver_setup+0x330>)
 80040ea:	fba2 2303 	umull	r2, r3, r2, r3
 80040ee:	0d9b      	lsrs	r3, r3, #22
 80040f0:	4a57      	ldr	r2, [pc, #348]	; (8004250 <driver_setup+0x328>)
 80040f2:	3b01      	subs	r3, #1
 80040f4:	6293      	str	r3, [r2, #40]	; 0x28
    PULSE_TIMER->SR &= ~(TIM_SR_UIF|TIM_SR_CC1IF);
 80040f6:	4b56      	ldr	r3, [pc, #344]	; (8004250 <driver_setup+0x328>)
 80040f8:	691b      	ldr	r3, [r3, #16]
 80040fa:	4a55      	ldr	r2, [pc, #340]	; (8004250 <driver_setup+0x328>)
 80040fc:	f023 0303 	bic.w	r3, r3, #3
 8004100:	6113      	str	r3, [r2, #16]
    PULSE_TIMER->CNT = 0;
 8004102:	4b53      	ldr	r3, [pc, #332]	; (8004250 <driver_setup+0x328>)
 8004104:	2200      	movs	r2, #0
 8004106:	625a      	str	r2, [r3, #36]	; 0x24
    PULSE_TIMER->DIER |= TIM_DIER_UIE;
 8004108:	4b51      	ldr	r3, [pc, #324]	; (8004250 <driver_setup+0x328>)
 800410a:	68db      	ldr	r3, [r3, #12]
 800410c:	4a50      	ldr	r2, [pc, #320]	; (8004250 <driver_setup+0x328>)
 800410e:	f043 0301 	orr.w	r3, r3, #1
 8004112:	60d3      	str	r3, [r2, #12]

    NVIC_SetPriority(PULSE_TIMER_IRQn, 0);
 8004114:	2100      	movs	r1, #0
 8004116:	201d      	movs	r0, #29
 8004118:	f7fe fbdc 	bl	80028d4 <__NVIC_SetPriority>
    NVIC_EnableIRQ(PULSE_TIMER_IRQn);
 800411c:	201d      	movs	r0, #29
 800411e:	f7fe fbbd 	bl	800289c <__NVIC_EnableIRQ>

 // Limit pins init

    if (settings->limits.flags.hard_enabled)
 8004122:	687b      	ldr	r3, [r7, #4]
 8004124:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8004128:	f003 0301 	and.w	r3, r3, #1
 800412c:	b2db      	uxtb	r3, r3
 800412e:	2b00      	cmp	r3, #0
 8004130:	d004      	beq.n	800413c <driver_setup+0x214>
        HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0x02, 0x02);
 8004132:	2202      	movs	r2, #2
 8004134:	2102      	movs	r1, #2
 8004136:	2028      	movs	r0, #40	; 0x28
 8004138:	f7fd fc41 	bl	80019be <HAL_NVIC_SetPriority>

 // Control pins init

    if(hal.driver_cap.software_debounce) {
 800413c:	4b45      	ldr	r3, [pc, #276]	; (8004254 <driver_setup+0x32c>)
 800413e:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8004142:	f003 0302 	and.w	r3, r3, #2
 8004146:	b2db      	uxtb	r3, r3
 8004148:	2b00      	cmp	r3, #0
 800414a:	d021      	beq.n	8004190 <driver_setup+0x268>
        // Single-shot 0.1 ms per tick
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 800414c:	4b43      	ldr	r3, [pc, #268]	; (800425c <driver_setup+0x334>)
 800414e:	681b      	ldr	r3, [r3, #0]
 8004150:	4a42      	ldr	r2, [pc, #264]	; (800425c <driver_setup+0x334>)
 8004152:	f443 7327 	orr.w	r3, r3, #668	; 0x29c
 8004156:	6013      	str	r3, [r2, #0]
        DEBOUNCE_TIMER->PSC = hal.f_step_timer / 10000UL - 1;
 8004158:	4b3e      	ldr	r3, [pc, #248]	; (8004254 <driver_setup+0x32c>)
 800415a:	69db      	ldr	r3, [r3, #28]
 800415c:	4a40      	ldr	r2, [pc, #256]	; (8004260 <driver_setup+0x338>)
 800415e:	fba2 2303 	umull	r2, r3, r2, r3
 8004162:	0b5b      	lsrs	r3, r3, #13
 8004164:	4a3d      	ldr	r2, [pc, #244]	; (800425c <driver_setup+0x334>)
 8004166:	3b01      	subs	r3, #1
 8004168:	6293      	str	r3, [r2, #40]	; 0x28
        DEBOUNCE_TIMER->SR &= ~TIM_SR_UIF;
 800416a:	4b3c      	ldr	r3, [pc, #240]	; (800425c <driver_setup+0x334>)
 800416c:	691b      	ldr	r3, [r3, #16]
 800416e:	4a3b      	ldr	r2, [pc, #236]	; (800425c <driver_setup+0x334>)
 8004170:	f023 0301 	bic.w	r3, r3, #1
 8004174:	6113      	str	r3, [r2, #16]
        DEBOUNCE_TIMER->ARR = 400; // 40 ms timeout
 8004176:	4b39      	ldr	r3, [pc, #228]	; (800425c <driver_setup+0x334>)
 8004178:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800417c:	62da      	str	r2, [r3, #44]	; 0x2c
        DEBOUNCE_TIMER->DIER |= TIM_DIER_UIE;
 800417e:	4b37      	ldr	r3, [pc, #220]	; (800425c <driver_setup+0x334>)
 8004180:	68db      	ldr	r3, [r3, #12]
 8004182:	4a36      	ldr	r2, [pc, #216]	; (800425c <driver_setup+0x334>)
 8004184:	f043 0301 	orr.w	r3, r3, #1
 8004188:	60d3      	str	r3, [r2, #12]

        HAL_NVIC_EnableIRQ(DEBOUNCE_TIMER_IRQn); // Enable debounce interrupt
 800418a:	201e      	movs	r0, #30
 800418c:	f7fd fc33 	bl	80019f6 <HAL_NVIC_EnableIRQ>

 // Spindle init

#if DRIVER_SPINDLE_PWM_ENABLE

    SPINDLE_PWM_CLOCK_ENA();
 8004190:	4b34      	ldr	r3, [pc, #208]	; (8004264 <driver_setup+0x33c>)
 8004192:	699b      	ldr	r3, [r3, #24]
 8004194:	4a33      	ldr	r2, [pc, #204]	; (8004264 <driver_setup+0x33c>)
 8004196:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800419a:	6193      	str	r3, [r2, #24]
 800419c:	4b31      	ldr	r3, [pc, #196]	; (8004264 <driver_setup+0x33c>)
 800419e:	699b      	ldr	r3, [r3, #24]
 80041a0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80041a4:	60bb      	str	r3, [r7, #8]
 80041a6:	68bb      	ldr	r3, [r7, #8]

#if SPINDLE_PWM_AF_REMAP
    AFIO->MAPR |= (SPINDLE_PWM_AF_REMAP << (4 + 2 * SPINDLE_PWM_TIMER_N));
#endif

    GPIO_Init.Pin = 1 << SPINDLE_PWM_PIN;
 80041a8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80041ac:	61fb      	str	r3, [r7, #28]
    GPIO_Init.Mode = GPIO_MODE_AF_PP;
 80041ae:	2302      	movs	r3, #2
 80041b0:	623b      	str	r3, [r7, #32]
    HAL_GPIO_Init(SPINDLE_PWM_PORT, &GPIO_Init);
 80041b2:	f107 031c 	add.w	r3, r7, #28
 80041b6:	4619      	mov	r1, r3
 80041b8:	482b      	ldr	r0, [pc, #172]	; (8004268 <driver_setup+0x340>)
 80041ba:	f7fd fc45 	bl	8001a48 <HAL_GPIO_Init>

#endif // DRIVER_SPINDLE_PWM_ENABLE

 // Coolant init (??)

    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = 1;
 80041be:	4b2b      	ldr	r3, [pc, #172]	; (800426c <driver_setup+0x344>)
 80041c0:	2201      	movs	r2, #1
 80041c2:	701a      	strb	r2, [r3, #0]
    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = 0;
 80041c4:	4b29      	ldr	r3, [pc, #164]	; (800426c <driver_setup+0x344>)
 80041c6:	2200      	movs	r2, #0
 80041c8:	701a      	strb	r2, [r3, #0]

#ifdef COOLANT_MIST_PIN
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = 1;
 80041ca:	4b29      	ldr	r3, [pc, #164]	; (8004270 <driver_setup+0x348>)
 80041cc:	2201      	movs	r2, #1
 80041ce:	701a      	strb	r2, [r3, #0]
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = 0;
 80041d0:	4b27      	ldr	r3, [pc, #156]	; (8004270 <driver_setup+0x348>)
 80041d2:	2200      	movs	r2, #0
 80041d4:	701a      	strb	r2, [r3, #0]

    sdcard_init();

#endif

    on_unknown_sys_command = grbl.on_unknown_sys_command;
 80041d6:	4b27      	ldr	r3, [pc, #156]	; (8004274 <driver_setup+0x34c>)
 80041d8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80041dc:	4a26      	ldr	r2, [pc, #152]	; (8004278 <driver_setup+0x350>)
 80041de:	6013      	str	r3, [r2, #0]
    grbl.on_unknown_sys_command = jtag_enable;
 80041e0:	4b24      	ldr	r3, [pc, #144]	; (8004274 <driver_setup+0x34c>)
 80041e2:	4a26      	ldr	r2, [pc, #152]	; (800427c <driver_setup+0x354>)
 80041e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

    IOInitDone = settings->version == 22;
 80041e8:	687b      	ldr	r3, [r7, #4]
 80041ea:	681b      	ldr	r3, [r3, #0]
 80041ec:	2b16      	cmp	r3, #22
 80041ee:	bf0c      	ite	eq
 80041f0:	2301      	moveq	r3, #1
 80041f2:	2300      	movne	r3, #0
 80041f4:	b2da      	uxtb	r2, r3
 80041f6:	4b22      	ldr	r3, [pc, #136]	; (8004280 <driver_setup+0x358>)
 80041f8:	701a      	strb	r2, [r3, #0]

    hal.settings_changed(settings, (settings_changed_flags_t){0});
 80041fa:	4b16      	ldr	r3, [pc, #88]	; (8004254 <driver_setup+0x32c>)
 80041fc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8004200:	2200      	movs	r2, #0
 8004202:	4611      	mov	r1, r2
 8004204:	6878      	ldr	r0, [r7, #4]
 8004206:	4798      	blx	r3

    stepperSetDirOutputs((axes_signals_t){0});
 8004208:	2300      	movs	r3, #0
 800420a:	763b      	strb	r3, [r7, #24]
    dir_outbits.mask ^= settings.steppers.dir_invert.mask;
 800420c:	7e3a      	ldrb	r2, [r7, #24]
 800420e:	4b1d      	ldr	r3, [pc, #116]	; (8004284 <driver_setup+0x35c>)
 8004210:	f893 30e9 	ldrb.w	r3, [r3, #233]	; 0xe9
 8004214:	4053      	eors	r3, r2
 8004216:	b2db      	uxtb	r3, r3
 8004218:	763b      	strb	r3, [r7, #24]
    DIGITAL_OUT(X_DIRECTION_PORT, X_DIRECTION_PIN, dir_outbits.x);
 800421a:	7e3b      	ldrb	r3, [r7, #24]
 800421c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8004220:	b2da      	uxtb	r2, r3
 8004222:	4b19      	ldr	r3, [pc, #100]	; (8004288 <driver_setup+0x360>)
 8004224:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Y_DIRECTION_PORT, Y_DIRECTION_PIN, dir_outbits.y);
 8004226:	7e3b      	ldrb	r3, [r7, #24]
 8004228:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800422c:	b2da      	uxtb	r2, r3
 800422e:	4b17      	ldr	r3, [pc, #92]	; (800428c <driver_setup+0x364>)
 8004230:	701a      	strb	r2, [r3, #0]
    DIGITAL_OUT(Z_DIRECTION_PORT, Z_DIRECTION_PIN, dir_outbits.z);
 8004232:	7e3b      	ldrb	r3, [r7, #24]
 8004234:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8004238:	b2da      	uxtb	r2, r3
 800423a:	4b15      	ldr	r3, [pc, #84]	; (8004290 <driver_setup+0x368>)
 800423c:	701a      	strb	r2, [r3, #0]
}
 800423e:	bf00      	nop

    return IOInitDone;
 8004240:	4b0f      	ldr	r3, [pc, #60]	; (8004280 <driver_setup+0x358>)
 8004242:	781b      	ldrb	r3, [r3, #0]
}
 8004244:	4618      	mov	r0, r3
 8004246:	3730      	adds	r7, #48	; 0x30
 8004248:	46bd      	mov	sp, r7
 800424a:	bd80      	pop	{r7, pc}
 800424c:	20000108 	.word	0x20000108
 8004250:	40000400 	.word	0x40000400
 8004254:	20000ed0 	.word	0x20000ed0
 8004258:	6b5fca6b 	.word	0x6b5fca6b
 800425c:	40000800 	.word	0x40000800
 8004260:	d1b71759 	.word	0xd1b71759
 8004264:	40021000 	.word	0x40021000
 8004268:	40010800 	.word	0x40010800
 800426c:	42218180 	.word	0x42218180
 8004270:	42218184 	.word	0x42218184
 8004274:	20000dd4 	.word	0x20000dd4
 8004278:	20000550 	.word	0x20000550
 800427c:	08003ec5 	.word	0x08003ec5
 8004280:	200004e0 	.word	0x200004e0
 8004284:	2000147c 	.word	0x2000147c
 8004288:	42220188 	.word	0x42220188
 800428c:	422181a0 	.word	0x422181a0
 8004290:	42218198 	.word	0x42218198

08004294 <driver_init>:

// Initialize HAL pointers, setup serial comms and enable EEPROM
// NOTE: Grbl is not yet configured (from EEPROM data), driver_setup() will be called when done

bool driver_init (void)
{
 8004294:	b590      	push	{r4, r7, lr}
 8004296:	b085      	sub	sp, #20
 8004298:	af00      	add	r7, sp, #0

#ifdef I2C_PORT
    i2c_init();
#endif

    __HAL_AFIO_REMAP_SWJ_NOJTAG();
 800429a:	4b88      	ldr	r3, [pc, #544]	; (80044bc <driver_init+0x228>)
 800429c:	685b      	ldr	r3, [r3, #4]
 800429e:	60bb      	str	r3, [r7, #8]
 80042a0:	68bb      	ldr	r3, [r7, #8]
 80042a2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 80042a6:	60bb      	str	r3, [r7, #8]
 80042a8:	68bb      	ldr	r3, [r7, #8]
 80042aa:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80042ae:	60bb      	str	r3, [r7, #8]
 80042b0:	4a82      	ldr	r2, [pc, #520]	; (80044bc <driver_init+0x228>)
 80042b2:	68bb      	ldr	r3, [r7, #8]
 80042b4:	6053      	str	r3, [r2, #4]

#ifndef STM32F103xB
    hal.info = "STM32F103RE";
 80042b6:	4b82      	ldr	r3, [pc, #520]	; (80044c0 <driver_init+0x22c>)
 80042b8:	4a82      	ldr	r2, [pc, #520]	; (80044c4 <driver_init+0x230>)
 80042ba:	605a      	str	r2, [r3, #4]
#else
    hal.info = "STM32F103CB";
#endif
    hal.driver_version = "231217";
 80042bc:	4b80      	ldr	r3, [pc, #512]	; (80044c0 <driver_init+0x22c>)
 80042be:	4a82      	ldr	r2, [pc, #520]	; (80044c8 <driver_init+0x234>)
 80042c0:	609a      	str	r2, [r3, #8]
    hal.driver_url = GRBL_URL "/STM32F1xx";
 80042c2:	4b7f      	ldr	r3, [pc, #508]	; (80044c0 <driver_init+0x22c>)
 80042c4:	4a81      	ldr	r2, [pc, #516]	; (80044cc <driver_init+0x238>)
 80042c6:	611a      	str	r2, [r3, #16]
#ifdef BOARD_NAME
    hal.board = BOARD_NAME;
 80042c8:	4b7d      	ldr	r3, [pc, #500]	; (80044c0 <driver_init+0x22c>)
 80042ca:	4a81      	ldr	r2, [pc, #516]	; (80044d0 <driver_init+0x23c>)
 80042cc:	615a      	str	r2, [r3, #20]
#endif
    hal.driver_setup = driver_setup;
 80042ce:	4b7c      	ldr	r3, [pc, #496]	; (80044c0 <driver_init+0x22c>)
 80042d0:	4a80      	ldr	r2, [pc, #512]	; (80044d4 <driver_init+0x240>)
 80042d2:	635a      	str	r2, [r3, #52]	; 0x34
    hal.f_step_timer = SystemCoreClock;
 80042d4:	4b80      	ldr	r3, [pc, #512]	; (80044d8 <driver_init+0x244>)
 80042d6:	681b      	ldr	r3, [r3, #0]
 80042d8:	4a79      	ldr	r2, [pc, #484]	; (80044c0 <driver_init+0x22c>)
 80042da:	61d3      	str	r3, [r2, #28]
    hal.rx_buffer_size = RX_BUFFER_SIZE;
 80042dc:	4b78      	ldr	r3, [pc, #480]	; (80044c0 <driver_init+0x22c>)
 80042de:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80042e2:	625a      	str	r2, [r3, #36]	; 0x24
    hal.delay_ms = &driver_delay;
 80042e4:	4b76      	ldr	r3, [pc, #472]	; (80044c0 <driver_init+0x22c>)
 80042e6:	4a7d      	ldr	r2, [pc, #500]	; (80044dc <driver_init+0x248>)
 80042e8:	639a      	str	r2, [r3, #56]	; 0x38
    hal.settings_changed = settings_changed;
 80042ea:	4b75      	ldr	r3, [pc, #468]	; (80044c0 <driver_init+0x22c>)
 80042ec:	4a7c      	ldr	r2, [pc, #496]	; (80044e0 <driver_init+0x24c>)
 80042ee:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

    hal.stepper.wake_up = stepperWakeUp;
 80042f2:	4b73      	ldr	r3, [pc, #460]	; (80044c0 <driver_init+0x22c>)
 80042f4:	4a7b      	ldr	r2, [pc, #492]	; (80044e4 <driver_init+0x250>)
 80042f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    hal.stepper.go_idle = stepperGoIdle;
 80042fa:	4b71      	ldr	r3, [pc, #452]	; (80044c0 <driver_init+0x22c>)
 80042fc:	4a7a      	ldr	r2, [pc, #488]	; (80044e8 <driver_init+0x254>)
 80042fe:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    hal.stepper.enable = stepperEnable;
 8004302:	4b6f      	ldr	r3, [pc, #444]	; (80044c0 <driver_init+0x22c>)
 8004304:	4a79      	ldr	r2, [pc, #484]	; (80044ec <driver_init+0x258>)
 8004306:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    hal.stepper.cycles_per_tick = stepperCyclesPerTickPrescaled;
 800430a:	4b6d      	ldr	r3, [pc, #436]	; (80044c0 <driver_init+0x22c>)
 800430c:	4a78      	ldr	r2, [pc, #480]	; (80044f0 <driver_init+0x25c>)
 800430e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    hal.stepper.pulse_start = stepperPulseStart;
 8004312:	4b6b      	ldr	r3, [pc, #428]	; (80044c0 <driver_init+0x22c>)
 8004314:	4a77      	ldr	r2, [pc, #476]	; (80044f4 <driver_init+0x260>)
 8004316:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    hal.stepper.motor_iterator = motor_iterator;
 800431a:	4b69      	ldr	r3, [pc, #420]	; (80044c0 <driver_init+0x22c>)
 800431c:	4a76      	ldr	r2, [pc, #472]	; (80044f8 <driver_init+0x264>)
 800431e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
#endif
#ifdef SQUARING_ENABLED
    hal.stepper.disable_motors = StepperDisableMotors;
#endif

    hal.limits.enable = limitsEnable;
 8004322:	4b67      	ldr	r3, [pc, #412]	; (80044c0 <driver_init+0x22c>)
 8004324:	4a75      	ldr	r2, [pc, #468]	; (80044fc <driver_init+0x268>)
 8004326:	655a      	str	r2, [r3, #84]	; 0x54
    hal.limits.get_state = limitsGetState;
 8004328:	4b65      	ldr	r3, [pc, #404]	; (80044c0 <driver_init+0x22c>)
 800432a:	4a75      	ldr	r2, [pc, #468]	; (8004500 <driver_init+0x26c>)
 800432c:	659a      	str	r2, [r3, #88]	; 0x58

    hal.coolant.set_state = coolantSetState;
 800432e:	4b64      	ldr	r3, [pc, #400]	; (80044c0 <driver_init+0x22c>)
 8004330:	4a74      	ldr	r2, [pc, #464]	; (8004504 <driver_init+0x270>)
 8004332:	671a      	str	r2, [r3, #112]	; 0x70
    hal.coolant.get_state = coolantGetState;
 8004334:	4b62      	ldr	r3, [pc, #392]	; (80044c0 <driver_init+0x22c>)
 8004336:	4a74      	ldr	r2, [pc, #464]	; (8004508 <driver_init+0x274>)
 8004338:	675a      	str	r2, [r3, #116]	; 0x74

#ifdef PROBE_PIN
    hal.probe.get_state = probeGetState;
 800433a:	4b61      	ldr	r3, [pc, #388]	; (80044c0 <driver_init+0x22c>)
 800433c:	4a73      	ldr	r2, [pc, #460]	; (800450c <driver_init+0x278>)
 800433e:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    hal.probe.configure = probeConfigure;
 8004342:	4b5f      	ldr	r3, [pc, #380]	; (80044c0 <driver_init+0x22c>)
 8004344:	4a72      	ldr	r2, [pc, #456]	; (8004510 <driver_init+0x27c>)
 8004346:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
        }
    };

 #endif

    spindle_id = spindle_register(&spindle, DRIVER_SPINDLE_NAME);
 800434a:	4972      	ldr	r1, [pc, #456]	; (8004514 <driver_init+0x280>)
 800434c:	4872      	ldr	r0, [pc, #456]	; (8004518 <driver_init+0x284>)
 800434e:	f018 f8dd 	bl	801c50c <spindle_register>
 8004352:	4603      	mov	r3, r0
 8004354:	461a      	mov	r2, r3
 8004356:	4b71      	ldr	r3, [pc, #452]	; (800451c <driver_init+0x288>)
 8004358:	701a      	strb	r2, [r3, #0]

#endif // DRIVER_SPINDLE_ENABLE

    hal.control.get_state = systemGetState;
 800435a:	4b59      	ldr	r3, [pc, #356]	; (80044c0 <driver_init+0x22c>)
 800435c:	4a70      	ldr	r2, [pc, #448]	; (8004520 <driver_init+0x28c>)
 800435e:	669a      	str	r2, [r3, #104]	; 0x68

    hal.irq_enable = __enable_irq;
 8004360:	4b57      	ldr	r3, [pc, #348]	; (80044c0 <driver_init+0x22c>)
 8004362:	4a70      	ldr	r2, [pc, #448]	; (8004524 <driver_init+0x290>)
 8004364:	649a      	str	r2, [r3, #72]	; 0x48
    hal.irq_disable = __disable_irq;
 8004366:	4b56      	ldr	r3, [pc, #344]	; (80044c0 <driver_init+0x22c>)
 8004368:	4a6f      	ldr	r2, [pc, #444]	; (8004528 <driver_init+0x294>)
 800436a:	64da      	str	r2, [r3, #76]	; 0x4c
#if I2C_STROBE_ENABLE
    hal.irq_claim = irq_claim;
#endif
    hal.set_bits_atomic = bitsSetAtomic;
 800436c:	4b54      	ldr	r3, [pc, #336]	; (80044c0 <driver_init+0x22c>)
 800436e:	4a6f      	ldr	r2, [pc, #444]	; (800452c <driver_init+0x298>)
 8004370:	63da      	str	r2, [r3, #60]	; 0x3c
    hal.clear_bits_atomic = bitsClearAtomic;
 8004372:	4b53      	ldr	r3, [pc, #332]	; (80044c0 <driver_init+0x22c>)
 8004374:	4a6e      	ldr	r2, [pc, #440]	; (8004530 <driver_init+0x29c>)
 8004376:	641a      	str	r2, [r3, #64]	; 0x40
    hal.set_value_atomic = valueSetAtomic;
 8004378:	4b51      	ldr	r3, [pc, #324]	; (80044c0 <driver_init+0x22c>)
 800437a:	4a6e      	ldr	r2, [pc, #440]	; (8004534 <driver_init+0x2a0>)
 800437c:	645a      	str	r2, [r3, #68]	; 0x44
    hal.get_elapsed_ticks = getElapsedTicks;
 800437e:	4b50      	ldr	r3, [pc, #320]	; (80044c0 <driver_init+0x22c>)
 8004380:	4a6d      	ldr	r2, [pc, #436]	; (8004538 <driver_init+0x2a4>)
 8004382:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    hal.enumerate_pins = enumeratePins;
 8004386:	4b4e      	ldr	r3, [pc, #312]	; (80044c0 <driver_init+0x22c>)
 8004388:	4a6c      	ldr	r2, [pc, #432]	; (800453c <driver_init+0x2a8>)
 800438a:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170

#ifdef STM32F103xE
  #if USB_SERIAL_CDC
    stream_connect(usbInit());
  #else
    stream_connect(serialInit(115200));
 800438e:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 8004392:	f001 f89f 	bl	80054d4 <serialInit>
 8004396:	4603      	mov	r3, r0
 8004398:	4618      	mov	r0, r3
 800439a:	f01c fa15 	bl	80207c8 <stream_connect>
#elif FLASH_ENABLE
    hal.nvs.type = NVS_Flash;
    hal.nvs.memcpy_from_flash = memcpy_from_flash;
    hal.nvs.memcpy_to_flash = memcpy_to_flash;
#else
    hal.nvs.type = NVS_None;
 800439e:	4b48      	ldr	r3, [pc, #288]	; (80044c0 <driver_init+0x22c>)
 80043a0:	2200      	movs	r2, #0
 80043a2:	f883 2144 	strb.w	r2, [r3, #324]	; 0x144
#endif

  // driver capabilities, used for announcing and negotiating (with Grbl) driver functionality

#if ESTOP_ENABLE
    hal.signals_cap.e_stop = On;
 80043a6:	4a46      	ldr	r2, [pc, #280]	; (80044c0 <driver_init+0x22c>)
 80043a8:	f892 31ac 	ldrb.w	r3, [r2, #428]	; 0x1ac
 80043ac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80043b0:	f882 31ac 	strb.w	r3, [r2, #428]	; 0x1ac
    hal.signals_cap.reset = Off;
 80043b4:	4a42      	ldr	r2, [pc, #264]	; (80044c0 <driver_init+0x22c>)
 80043b6:	f892 31ac 	ldrb.w	r3, [r2, #428]	; 0x1ac
 80043ba:	f36f 0300 	bfc	r3, #0, #1
 80043be:	f882 31ac 	strb.w	r3, [r2, #428]	; 0x1ac
#endif
#ifdef SAFETY_DOOR_PIN
    hal.signals_cap.safety_door_ajar = On;
#endif
    hal.limits_cap = get_limits_cap();
 80043c2:	4c3f      	ldr	r4, [pc, #252]	; (80044c0 <driver_init+0x22c>)
 80043c4:	f7fe facd 	bl	8002962 <get_limits_cap>
 80043c8:	4603      	mov	r3, r0
 80043ca:	461a      	mov	r2, r3
 80043cc:	f884 21ae 	strb.w	r2, [r4, #430]	; 0x1ae
 80043d0:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80043d4:	f884 21af 	strb.w	r2, [r4, #431]	; 0x1af
 80043d8:	f3c3 4207 	ubfx	r2, r3, #16, #8
 80043dc:	f884 21b0 	strb.w	r2, [r4, #432]	; 0x1b0
 80043e0:	f3c3 6307 	ubfx	r3, r3, #24, #8
 80043e4:	f884 31b1 	strb.w	r3, [r4, #433]	; 0x1b1
    hal.home_cap = get_home_cap();
 80043e8:	4c35      	ldr	r4, [pc, #212]	; (80044c0 <driver_init+0x22c>)
 80043ea:	f7fe fadf 	bl	80029ac <get_home_cap>
 80043ee:	4603      	mov	r3, r0
 80043f0:	f8a4 31b2 	strh.w	r3, [r4, #434]	; 0x1b2
    hal.driver_cap.mist_control = On;
 80043f4:	4a32      	ldr	r2, [pc, #200]	; (80044c0 <driver_init+0x22c>)
 80043f6:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 80043fa:	f043 0301 	orr.w	r3, r3, #1
 80043fe:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.software_debounce = On;
 8004402:	4a2f      	ldr	r2, [pc, #188]	; (80044c0 <driver_init+0x22c>)
 8004404:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 8004408:	f043 0302 	orr.w	r3, r3, #2
 800440c:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.step_pulse_delay = On;
 8004410:	4a2b      	ldr	r2, [pc, #172]	; (80044c0 <driver_init+0x22c>)
 8004412:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 8004416:	f043 0304 	orr.w	r3, r3, #4
 800441a:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.amass_level = 3;
 800441e:	4a28      	ldr	r2, [pc, #160]	; (80044c0 <driver_init+0x22c>)
 8004420:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 8004424:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8004428:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.control_pull_up = On;
 800442c:	4a24      	ldr	r2, [pc, #144]	; (80044c0 <driver_init+0x22c>)
 800442e:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 8004432:	f043 0310 	orr.w	r3, r3, #16
 8004436:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.limits_pull_up = On;
 800443a:	4a21      	ldr	r2, [pc, #132]	; (80044c0 <driver_init+0x22c>)
 800443c:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 8004440:	f043 0308 	orr.w	r3, r3, #8
 8004444:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
    hal.driver_cap.probe_pull_up = On;
 8004448:	4a1d      	ldr	r2, [pc, #116]	; (80044c0 <driver_init+0x22c>)
 800444a:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 800444e:	f043 0320 	orr.w	r3, r3, #32
 8004452:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
#else

    uint32_t i;
    input_signal_t *input;

    for(i = 0 ; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 8004456:	2300      	movs	r3, #0
 8004458:	60fb      	str	r3, [r7, #12]
 800445a:	e01d      	b.n	8004498 <driver_init+0x204>
        input = &inputpin[i];
 800445c:	68fa      	ldr	r2, [r7, #12]
 800445e:	4613      	mov	r3, r2
 8004460:	00db      	lsls	r3, r3, #3
 8004462:	4413      	add	r3, r2
 8004464:	009b      	lsls	r3, r3, #2
 8004466:	4a36      	ldr	r2, [pc, #216]	; (8004540 <driver_init+0x2ac>)
 8004468:	4413      	add	r3, r2
 800446a:	607b      	str	r3, [r7, #4]
        if(input->group & (PinGroup_Limit|PinGroup_LimitMax)) {
 800446c:	687b      	ldr	r3, [r7, #4]
 800446e:	691b      	ldr	r3, [r3, #16]
 8004470:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8004474:	2b00      	cmp	r3, #0
 8004476:	d00c      	beq.n	8004492 <driver_init+0x1fe>
            if(limit_inputs.pins.inputs == NULL)
 8004478:	4b32      	ldr	r3, [pc, #200]	; (8004544 <driver_init+0x2b0>)
 800447a:	685b      	ldr	r3, [r3, #4]
 800447c:	2b00      	cmp	r3, #0
 800447e:	d102      	bne.n	8004486 <driver_init+0x1f2>
                limit_inputs.pins.inputs = input;
 8004480:	4a30      	ldr	r2, [pc, #192]	; (8004544 <driver_init+0x2b0>)
 8004482:	687b      	ldr	r3, [r7, #4]
 8004484:	6053      	str	r3, [r2, #4]
            limit_inputs.n_pins++;
 8004486:	4b2f      	ldr	r3, [pc, #188]	; (8004544 <driver_init+0x2b0>)
 8004488:	781b      	ldrb	r3, [r3, #0]
 800448a:	3301      	adds	r3, #1
 800448c:	b2da      	uxtb	r2, r3
 800448e:	4b2d      	ldr	r3, [pc, #180]	; (8004544 <driver_init+0x2b0>)
 8004490:	701a      	strb	r2, [r3, #0]
    for(i = 0 ; i < sizeof(inputpin) / sizeof(input_signal_t); i++) {
 8004492:	68fb      	ldr	r3, [r7, #12]
 8004494:	3301      	adds	r3, #1
 8004496:	60fb      	str	r3, [r7, #12]
 8004498:	68fb      	ldr	r3, [r7, #12]
 800449a:	2b06      	cmp	r3, #6
 800449c:	d9de      	bls.n	800445c <driver_init+0x1c8>
    fans_init();
#endif

#if OPENPNP_ENABLE
    extern void openpnp_init (void);
    openpnp_init();
 800449e:	f000 fd87 	bl	8004fb0 <openpnp_init>
    extern void embroidery_init (void);
    embroidery_init();
#endif

    extern void my_plugin_init (void);
    my_plugin_init();
 80044a2:	f00b f99d 	bl	800f7e0 <my_plugin_init>

#include "grbl/plugins_init.h"

    // No need to move version check before init.
    // Compiler will fail any signature mismatch for existing entries.
    return hal.version == 10;
 80044a6:	4b06      	ldr	r3, [pc, #24]	; (80044c0 <driver_init+0x22c>)
 80044a8:	681b      	ldr	r3, [r3, #0]
 80044aa:	2b0a      	cmp	r3, #10
 80044ac:	bf0c      	ite	eq
 80044ae:	2301      	moveq	r3, #1
 80044b0:	2300      	movne	r3, #0
 80044b2:	b2db      	uxtb	r3, r3
}
 80044b4:	4618      	mov	r0, r3
 80044b6:	3714      	adds	r7, #20
 80044b8:	46bd      	mov	sp, r7
 80044ba:	bd90      	pop	{r4, r7, pc}
 80044bc:	40010000 	.word	0x40010000
 80044c0:	20000ed0 	.word	0x20000ed0
 80044c4:	08026cd4 	.word	0x08026cd4
 80044c8:	08026ce0 	.word	0x08026ce0
 80044cc:	08026ce8 	.word	0x08026ce8
 80044d0:	08026d10 	.word	0x08026d10
 80044d4:	08003f29 	.word	0x08003f29
 80044d8:	20000000 	.word	0x20000000
 80044dc:	08002a1d 	.word	0x08002a1d
 80044e0:	0800362d 	.word	0x0800362d
 80044e4:	08002ac5 	.word	0x08002ac5
 80044e8:	08002b11 	.word	0x08002b11
 80044ec:	08002a91 	.word	0x08002a91
 80044f0:	08002b3d 	.word	0x08002b3d
 80044f4:	08002b95 	.word	0x08002b95
 80044f8:	08002929 	.word	0x08002929
 80044fc:	08002d21 	.word	0x08002d21
 8004500:	08002de9 	.word	0x08002de9
 8004504:	0800343d 	.word	0x0800343d
 8004508:	08003481 	.word	0x08003481
 800450c:	08002f75 	.word	0x08002f75
 8004510:	08002f01 	.word	0x08002f01
 8004514:	08026d1c 	.word	0x08026d1c
 8004518:	08030978 	.word	0x08030978
 800451c:	20000210 	.word	0x20000210
 8004520:	08002e91 	.word	0x08002e91
 8004524:	08002881 	.word	0x08002881
 8004528:	0800288f 	.word	0x0800288f
 800452c:	080034e5 	.word	0x080034e5
 8004530:	0800350d 	.word	0x0800350d
 8004534:	0800353f 	.word	0x0800353f
 8004538:	08003569 	.word	0x08003569
 800453c:	08003cdd 	.word	0x08003cdd
 8004540:	2000000c 	.word	0x2000000c
 8004544:	20000544 	.word	0x20000544

08004548 <TIM2_IRQHandler>:

/* interrupt handlers */

// Main stepper driver
void STEPPER_TIMER_IRQHandler (void)
{
 8004548:	b580      	push	{r7, lr}
 800454a:	af00      	add	r7, sp, #0
    if ((STEPPER_TIMER->SR & TIM_SR_UIF) != 0)                  // check interrupt source
 800454c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004550:	691b      	ldr	r3, [r3, #16]
 8004552:	f003 0301 	and.w	r3, r3, #1
 8004556:	2b00      	cmp	r3, #0
 8004558:	d008      	beq.n	800456c <TIM2_IRQHandler+0x24>
    {
        STEPPER_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag
 800455a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800455e:	f06f 0201 	mvn.w	r2, #1
 8004562:	611a      	str	r2, [r3, #16]
        hal.stepper.interrupt_callback();
 8004564:	4b02      	ldr	r3, [pc, #8]	; (8004570 <TIM2_IRQHandler+0x28>)
 8004566:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800456a:	4798      	blx	r3
    }
}
 800456c:	bf00      	nop
 800456e:	bd80      	pop	{r7, pc}
 8004570:	20000ed0 	.word	0x20000ed0

08004574 <TIM3_IRQHandler>:

// This interrupt is enabled when Grbl sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
void PULSE_TIMER_IRQHandler (void)
{
 8004574:	b480      	push	{r7}
 8004576:	b083      	sub	sp, #12
 8004578:	af00      	add	r7, sp, #0
    PULSE_TIMER->SR &= ~TIM_SR_UIF;                 // Clear UIF flag
 800457a:	4b1f      	ldr	r3, [pc, #124]	; (80045f8 <TIM3_IRQHandler+0x84>)
 800457c:	691b      	ldr	r3, [r3, #16]
 800457e:	4a1e      	ldr	r2, [pc, #120]	; (80045f8 <TIM3_IRQHandler+0x84>)
 8004580:	f023 0301 	bic.w	r3, r3, #1
 8004584:	6113      	str	r3, [r2, #16]

    if (PULSE_TIMER->ARR == pulse_delay)            // Delayed step pulse?
 8004586:	4b1c      	ldr	r3, [pc, #112]	; (80045f8 <TIM3_IRQHandler+0x84>)
 8004588:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800458a:	4b1c      	ldr	r3, [pc, #112]	; (80045fc <TIM3_IRQHandler+0x88>)
 800458c:	681b      	ldr	r3, [r3, #0]
 800458e:	429a      	cmp	r2, r3
 8004590:	d11d      	bne.n	80045ce <TIM3_IRQHandler+0x5a>
    {
        PULSE_TIMER->ARR = pulse_length;
 8004592:	4a19      	ldr	r2, [pc, #100]	; (80045f8 <TIM3_IRQHandler+0x84>)
 8004594:	4b1a      	ldr	r3, [pc, #104]	; (8004600 <TIM3_IRQHandler+0x8c>)
 8004596:	681b      	ldr	r3, [r3, #0]
 8004598:	62d3      	str	r3, [r2, #44]	; 0x2c
 800459a:	4b1a      	ldr	r3, [pc, #104]	; (8004604 <TIM3_IRQHandler+0x90>)
 800459c:	781b      	ldrb	r3, [r3, #0]
 800459e:	713b      	strb	r3, [r7, #4]
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80045a0:	4b19      	ldr	r3, [pc, #100]	; (8004608 <TIM3_IRQHandler+0x94>)
 80045a2:	68db      	ldr	r3, [r3, #12]
 80045a4:	f423 7228 	bic.w	r2, r3, #672	; 0x2a0
 80045a8:	793b      	ldrb	r3, [r7, #4]
 80045aa:	4619      	mov	r1, r3
 80045ac:	4b17      	ldr	r3, [pc, #92]	; (800460c <TIM3_IRQHandler+0x98>)
 80045ae:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80045b2:	4915      	ldr	r1, [pc, #84]	; (8004608 <TIM3_IRQHandler+0x94>)
 80045b4:	4313      	orrs	r3, r2
 80045b6:	60cb      	str	r3, [r1, #12]
}
 80045b8:	bf00      	nop
        stepperSetStepOutputs(next_step_outbits);   // begin step pulse
        PULSE_TIMER->EGR = TIM_EGR_UG;
 80045ba:	4b0f      	ldr	r3, [pc, #60]	; (80045f8 <TIM3_IRQHandler+0x84>)
 80045bc:	2201      	movs	r2, #1
 80045be:	615a      	str	r2, [r3, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 80045c0:	4b0d      	ldr	r3, [pc, #52]	; (80045f8 <TIM3_IRQHandler+0x84>)
 80045c2:	681b      	ldr	r3, [r3, #0]
 80045c4:	4a0c      	ldr	r2, [pc, #48]	; (80045f8 <TIM3_IRQHandler+0x84>)
 80045c6:	f043 0301 	orr.w	r3, r3, #1
 80045ca:	6013      	str	r3, [r2, #0]
    } else
        stepperSetStepOutputs((axes_signals_t){0}); // end step pulse
}
 80045cc:	e00e      	b.n	80045ec <TIM3_IRQHandler+0x78>
        stepperSetStepOutputs((axes_signals_t){0}); // end step pulse
 80045ce:	2300      	movs	r3, #0
 80045d0:	703b      	strb	r3, [r7, #0]
    STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80045d2:	4b0d      	ldr	r3, [pc, #52]	; (8004608 <TIM3_IRQHandler+0x94>)
 80045d4:	68db      	ldr	r3, [r3, #12]
 80045d6:	f423 7228 	bic.w	r2, r3, #672	; 0x2a0
 80045da:	783b      	ldrb	r3, [r7, #0]
 80045dc:	4619      	mov	r1, r3
 80045de:	4b0b      	ldr	r3, [pc, #44]	; (800460c <TIM3_IRQHandler+0x98>)
 80045e0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80045e4:	4908      	ldr	r1, [pc, #32]	; (8004608 <TIM3_IRQHandler+0x94>)
 80045e6:	4313      	orrs	r3, r2
 80045e8:	60cb      	str	r3, [r1, #12]
}
 80045ea:	bf00      	nop
}
 80045ec:	bf00      	nop
 80045ee:	370c      	adds	r7, #12
 80045f0:	46bd      	mov	sp, r7
 80045f2:	bc80      	pop	{r7}
 80045f4:	4770      	bx	lr
 80045f6:	bf00      	nop
 80045f8:	40000400 	.word	0x40000400
 80045fc:	200004d8 	.word	0x200004d8
 8004600:	200004d4 	.word	0x200004d4
 8004604:	2000054c 	.word	0x2000054c
 8004608:	40010c00 	.word	0x40010c00
 800460c:	200004b4 	.word	0x200004b4

08004610 <debounce_start>:

static inline bool debounce_start (void)
{
 8004610:	b480      	push	{r7}
 8004612:	af00      	add	r7, sp, #0
    if(hal.driver_cap.software_debounce) {
 8004614:	4b0f      	ldr	r3, [pc, #60]	; (8004654 <debounce_start+0x44>)
 8004616:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800461a:	f003 0302 	and.w	r3, r3, #2
 800461e:	b2db      	uxtb	r3, r3
 8004620:	2b00      	cmp	r3, #0
 8004622:	d008      	beq.n	8004636 <debounce_start+0x26>
        DEBOUNCE_TIMER->EGR = TIM_EGR_UG;
 8004624:	4b0c      	ldr	r3, [pc, #48]	; (8004658 <debounce_start+0x48>)
 8004626:	2201      	movs	r2, #1
 8004628:	615a      	str	r2, [r3, #20]
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_CEN; // Start debounce timer (40ms)
 800462a:	4b0b      	ldr	r3, [pc, #44]	; (8004658 <debounce_start+0x48>)
 800462c:	681b      	ldr	r3, [r3, #0]
 800462e:	4a0a      	ldr	r2, [pc, #40]	; (8004658 <debounce_start+0x48>)
 8004630:	f043 0301 	orr.w	r3, r3, #1
 8004634:	6013      	str	r3, [r2, #0]
    }

    return hal.driver_cap.software_debounce;
 8004636:	4b07      	ldr	r3, [pc, #28]	; (8004654 <debounce_start+0x44>)
 8004638:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800463c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8004640:	b2db      	uxtb	r3, r3
 8004642:	2b00      	cmp	r3, #0
 8004644:	bf14      	ite	ne
 8004646:	2301      	movne	r3, #1
 8004648:	2300      	moveq	r3, #0
 800464a:	b2db      	uxtb	r3, r3
}
 800464c:	4618      	mov	r0, r3
 800464e:	46bd      	mov	sp, r7
 8004650:	bc80      	pop	{r7}
 8004652:	4770      	bx	lr
 8004654:	20000ed0 	.word	0x20000ed0
 8004658:	40000800 	.word	0x40000800

0800465c <TIM4_IRQHandler>:

// Debounce timer interrupt handler
void DEBOUNCE_TIMER_IRQHandler (void)
{
 800465c:	b580      	push	{r7, lr}
 800465e:	b082      	sub	sp, #8
 8004660:	af00      	add	r7, sp, #0
    DEBOUNCE_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag;
 8004662:	4b1e      	ldr	r3, [pc, #120]	; (80046dc <TIM4_IRQHandler+0x80>)
 8004664:	f06f 0201 	mvn.w	r2, #1
 8004668:	611a      	str	r2, [r3, #16]

    if(debounce.limits) {
 800466a:	4b1d      	ldr	r3, [pc, #116]	; (80046e0 <TIM4_IRQHandler+0x84>)
 800466c:	781b      	ldrb	r3, [r3, #0]
 800466e:	f003 0301 	and.w	r3, r3, #1
 8004672:	b2db      	uxtb	r3, r3
 8004674:	2b00      	cmp	r3, #0
 8004676:	d013      	beq.n	80046a0 <TIM4_IRQHandler+0x44>
        debounce.limits = Off;
 8004678:	4a19      	ldr	r2, [pc, #100]	; (80046e0 <TIM4_IRQHandler+0x84>)
 800467a:	7813      	ldrb	r3, [r2, #0]
 800467c:	f36f 0300 	bfc	r3, #0, #1
 8004680:	7013      	strb	r3, [r2, #0]
        limit_signals_t state = limitsGetState();
 8004682:	f7fe fbb1 	bl	8002de8 <limitsGetState>
 8004686:	4603      	mov	r3, r0
 8004688:	607b      	str	r3, [r7, #4]
        if(limit_signals_merge(state).value) //TODO: add check for limit switches having same state as when limit_isr were invoked?
 800468a:	6878      	ldr	r0, [r7, #4]
 800468c:	f007 fc60 	bl	800bf50 <limit_signals_merge>
 8004690:	4603      	mov	r3, r0
 8004692:	b2db      	uxtb	r3, r3
 8004694:	2b00      	cmp	r3, #0
 8004696:	d003      	beq.n	80046a0 <TIM4_IRQHandler+0x44>
            hal.limits.interrupt_callback(state);
 8004698:	4b12      	ldr	r3, [pc, #72]	; (80046e4 <TIM4_IRQHandler+0x88>)
 800469a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800469c:	6878      	ldr	r0, [r7, #4]
 800469e:	4798      	blx	r3
    }

    if(debounce.door) {
 80046a0:	4b0f      	ldr	r3, [pc, #60]	; (80046e0 <TIM4_IRQHandler+0x84>)
 80046a2:	781b      	ldrb	r3, [r3, #0]
 80046a4:	f003 0302 	and.w	r3, r3, #2
 80046a8:	b2db      	uxtb	r3, r3
 80046aa:	2b00      	cmp	r3, #0
 80046ac:	d012      	beq.n	80046d4 <TIM4_IRQHandler+0x78>
        debounce.door = Off;
 80046ae:	4a0c      	ldr	r2, [pc, #48]	; (80046e0 <TIM4_IRQHandler+0x84>)
 80046b0:	7813      	ldrb	r3, [r2, #0]
 80046b2:	f36f 0341 	bfc	r3, #1, #1
 80046b6:	7013      	strb	r3, [r2, #0]
        control_signals_t state = systemGetState();
 80046b8:	f7fe fbea 	bl	8002e90 <systemGetState>
 80046bc:	4603      	mov	r3, r0
 80046be:	803b      	strh	r3, [r7, #0]
        if(state.safety_door_ajar)
 80046c0:	783b      	ldrb	r3, [r7, #0]
 80046c2:	f003 0308 	and.w	r3, r3, #8
 80046c6:	b2db      	uxtb	r3, r3
 80046c8:	2b00      	cmp	r3, #0
 80046ca:	d003      	beq.n	80046d4 <TIM4_IRQHandler+0x78>
            hal.control.interrupt_callback(state);
 80046cc:	4b05      	ldr	r3, [pc, #20]	; (80046e4 <TIM4_IRQHandler+0x88>)
 80046ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80046d0:	8838      	ldrh	r0, [r7, #0]
 80046d2:	4798      	blx	r3
    }
}
 80046d4:	bf00      	nop
 80046d6:	3708      	adds	r7, #8
 80046d8:	46bd      	mov	sp, r7
 80046da:	bd80      	pop	{r7, pc}
 80046dc:	40000800 	.word	0x40000800
 80046e0:	20000554 	.word	0x20000554
 80046e4:	20000ed0 	.word	0x20000ed0

080046e8 <EXTI9_5_IRQHandler>:
#endif

#if ((DRIVER_IRQMASK|PROBE_IRQ_BIT|AUXINPUT_MASK) & 0x03E0)

void EXTI9_5_IRQHandler(void)
{
 80046e8:	b590      	push	{r4, r7, lr}
 80046ea:	b083      	sub	sp, #12
 80046ec:	af00      	add	r7, sp, #0
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(0x03E0);
 80046ee:	4b16      	ldr	r3, [pc, #88]	; (8004748 <EXTI9_5_IRQHandler+0x60>)
 80046f0:	695b      	ldr	r3, [r3, #20]
 80046f2:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
 80046f6:	607b      	str	r3, [r7, #4]

    if(ifg) {
 80046f8:	687b      	ldr	r3, [r7, #4]
 80046fa:	2b00      	cmp	r3, #0
 80046fc:	d01f      	beq.n	800473e <EXTI9_5_IRQHandler+0x56>
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 80046fe:	4a12      	ldr	r2, [pc, #72]	; (8004748 <EXTI9_5_IRQHandler+0x60>)
 8004700:	687b      	ldr	r3, [r7, #4]
 8004702:	6153      	str	r3, [r2, #20]
  #endif
            hal.control.interrupt_callback(systemGetState());
        }
#endif
#if LIMIT_MASK & 0x03E0
        if(ifg & LIMIT_MASK) {
 8004704:	687b      	ldr	r3, [r7, #4]
 8004706:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 800470a:	2b00      	cmp	r3, #0
 800470c:	d017      	beq.n	800473e <EXTI9_5_IRQHandler+0x56>
            if(!(debounce.limits = debounce_start()))
 800470e:	f7ff ff7f 	bl	8004610 <debounce_start>
 8004712:	4603      	mov	r3, r0
 8004714:	4619      	mov	r1, r3
 8004716:	4a0d      	ldr	r2, [pc, #52]	; (800474c <EXTI9_5_IRQHandler+0x64>)
 8004718:	7813      	ldrb	r3, [r2, #0]
 800471a:	f361 0300 	bfi	r3, r1, #0, #1
 800471e:	7013      	strb	r3, [r2, #0]
 8004720:	4b0a      	ldr	r3, [pc, #40]	; (800474c <EXTI9_5_IRQHandler+0x64>)
 8004722:	781b      	ldrb	r3, [r3, #0]
 8004724:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8004728:	b2db      	uxtb	r3, r3
 800472a:	2b00      	cmp	r3, #0
 800472c:	d107      	bne.n	800473e <EXTI9_5_IRQHandler+0x56>
                hal.limits.interrupt_callback(limitsGetState());
 800472e:	4b08      	ldr	r3, [pc, #32]	; (8004750 <EXTI9_5_IRQHandler+0x68>)
 8004730:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
 8004732:	f7fe fb59 	bl	8002de8 <limitsGetState>
 8004736:	4603      	mov	r3, r0
 8004738:	603b      	str	r3, [r7, #0]
 800473a:	6838      	ldr	r0, [r7, #0]
 800473c:	47a0      	blx	r4
#if AUXINPUT_MASK & 0x03E0
        if(ifg & aux_irq)
            ioports_event(ifg & aux_irq);
#endif
    }
}
 800473e:	bf00      	nop
 8004740:	370c      	adds	r7, #12
 8004742:	46bd      	mov	sp, r7
 8004744:	bd90      	pop	{r4, r7, pc}
 8004746:	bf00      	nop
 8004748:	40010400 	.word	0x40010400
 800474c:	20000554 	.word	0x20000554
 8004750:	20000ed0 	.word	0x20000ed0

08004754 <EXTI15_10_IRQHandler>:
#endif

#if (DRIVER_IRQMASK|PROBE_IRQ_BIT|AUXINPUT_MASK) & (0xFC00)

void EXTI15_10_IRQHandler(void)
{
 8004754:	b590      	push	{r4, r7, lr}
 8004756:	b083      	sub	sp, #12
 8004758:	af00      	add	r7, sp, #0
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(0xFC00);
 800475a:	4b0d      	ldr	r3, [pc, #52]	; (8004790 <EXTI15_10_IRQHandler+0x3c>)
 800475c:	695b      	ldr	r3, [r3, #20]
 800475e:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8004762:	607b      	str	r3, [r7, #4]

    if(ifg) {
 8004764:	687b      	ldr	r3, [r7, #4]
 8004766:	2b00      	cmp	r3, #0
 8004768:	d00e      	beq.n	8004788 <EXTI15_10_IRQHandler+0x34>
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 800476a:	4a09      	ldr	r2, [pc, #36]	; (8004790 <EXTI15_10_IRQHandler+0x3c>)
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	6153      	str	r3, [r2, #20]
#if SPI_IRQ_BIT & 0xFC00
        if((ifg & SPI_IRQ_BIT) && spi_irq.callback)
            spi_irq.callback(0, DIGITAL_IN(SPI_IRQ_PORT, SPI_IRQ_PIN) == 0);
#endif
#if CONTROL_MASK & 0xFC00
        if(ifg & CONTROL_MASK) {
 8004770:	687b      	ldr	r3, [r7, #4]
 8004772:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
 8004776:	2b00      	cmp	r3, #0
 8004778:	d006      	beq.n	8004788 <EXTI15_10_IRQHandler+0x34>
  #if SAFETY_DOOR_BIT & 0xFC00
            if(!(ifg & SAFETY_DOOR_BIT) || !(debounce.door = debounce_start()))
  #endif
            hal.control.interrupt_callback(systemGetState());
 800477a:	4b06      	ldr	r3, [pc, #24]	; (8004794 <EXTI15_10_IRQHandler+0x40>)
 800477c:	6edc      	ldr	r4, [r3, #108]	; 0x6c
 800477e:	f7fe fb87 	bl	8002e90 <systemGetState>
 8004782:	4603      	mov	r3, r0
 8004784:	4618      	mov	r0, r3
 8004786:	47a0      	blx	r4
#if AUXINPUT_MASK & 0xFC00
        if(ifg & aux_irq)
            ioports_event(ifg & aux_irq);
#endif
    }
}
 8004788:	bf00      	nop
 800478a:	370c      	adds	r7, #12
 800478c:	46bd      	mov	sp, r7
 800478e:	bd90      	pop	{r4, r7, pc}
 8004790:	40010400 	.word	0x40010400
 8004794:	20000ed0 	.word	0x20000ed0

08004798 <HAL_IncTick>:

#endif

// Interrupt handler for 1 ms interval timer
void HAL_IncTick(void)
{
 8004798:	b580      	push	{r7, lr}
 800479a:	af00      	add	r7, sp, #0
    if(!(--fatfs_ticks)) {
        disk_timerproc();
        fatfs_ticks = 10;
    }
#endif
    uwTick += uwTickFreq;
 800479c:	4b0f      	ldr	r3, [pc, #60]	; (80047dc <HAL_IncTick+0x44>)
 800479e:	781b      	ldrb	r3, [r3, #0]
 80047a0:	461a      	mov	r2, r3
 80047a2:	4b0f      	ldr	r3, [pc, #60]	; (80047e0 <HAL_IncTick+0x48>)
 80047a4:	681b      	ldr	r3, [r3, #0]
 80047a6:	4413      	add	r3, r2
 80047a8:	4a0d      	ldr	r2, [pc, #52]	; (80047e0 <HAL_IncTick+0x48>)
 80047aa:	6013      	str	r3, [r2, #0]

    if(delay.ms && !(--delay.ms) && delay.callback) {
 80047ac:	4b0d      	ldr	r3, [pc, #52]	; (80047e4 <HAL_IncTick+0x4c>)
 80047ae:	681b      	ldr	r3, [r3, #0]
 80047b0:	2b00      	cmp	r3, #0
 80047b2:	d010      	beq.n	80047d6 <HAL_IncTick+0x3e>
 80047b4:	4b0b      	ldr	r3, [pc, #44]	; (80047e4 <HAL_IncTick+0x4c>)
 80047b6:	681b      	ldr	r3, [r3, #0]
 80047b8:	3b01      	subs	r3, #1
 80047ba:	4a0a      	ldr	r2, [pc, #40]	; (80047e4 <HAL_IncTick+0x4c>)
 80047bc:	6013      	str	r3, [r2, #0]
 80047be:	2b00      	cmp	r3, #0
 80047c0:	d109      	bne.n	80047d6 <HAL_IncTick+0x3e>
 80047c2:	4b08      	ldr	r3, [pc, #32]	; (80047e4 <HAL_IncTick+0x4c>)
 80047c4:	685b      	ldr	r3, [r3, #4]
 80047c6:	2b00      	cmp	r3, #0
 80047c8:	d005      	beq.n	80047d6 <HAL_IncTick+0x3e>
        delay.callback();
 80047ca:	4b06      	ldr	r3, [pc, #24]	; (80047e4 <HAL_IncTick+0x4c>)
 80047cc:	685b      	ldr	r3, [r3, #4]
 80047ce:	4798      	blx	r3
        delay.callback = NULL;
 80047d0:	4b04      	ldr	r3, [pc, #16]	; (80047e4 <HAL_IncTick+0x4c>)
 80047d2:	2200      	movs	r2, #0
 80047d4:	605a      	str	r2, [r3, #4]
    }
}
 80047d6:	bf00      	nop
 80047d8:	bd80      	pop	{r7, pc}
 80047da:	bf00      	nop
 80047dc:	20000008 	.word	0x20000008
 80047e0:	200004b0 	.word	0x200004b0
 80047e4:	20000214 	.word	0x20000214

080047e8 <userMCodeCheck>:
static user_mcode_ptrs_t user_mcode;
static on_report_options_ptr on_report_options;
static uint8_t tport;

static user_mcode_t userMCodeCheck (user_mcode_t mcode)
{
 80047e8:	b580      	push	{r7, lr}
 80047ea:	b082      	sub	sp, #8
 80047ec:	af00      	add	r7, sp, #0
 80047ee:	4603      	mov	r3, r0
 80047f0:	80fb      	strh	r3, [r7, #6]
    return mcode == OpenPNP_SetPinState || mcode == OpenPNP_GetADCReading || mcode == OpenPNP_GetCurrentPosition || mcode == OpenPNP_FirmwareInfo ||
             mcode == OpenPNP_SetAcceleration || mcode == OpenPNP_FinishMoves || mcode == OpenPNP_SettingsReset
            ? mcode
            : (user_mcode.check ? user_mcode.check(mcode) : UserMCode_Ignore);
 80047f2:	88fb      	ldrh	r3, [r7, #6]
 80047f4:	2b2a      	cmp	r3, #42	; 0x2a
 80047f6:	d020      	beq.n	800483a <userMCodeCheck+0x52>
    return mcode == OpenPNP_SetPinState || mcode == OpenPNP_GetADCReading || mcode == OpenPNP_GetCurrentPosition || mcode == OpenPNP_FirmwareInfo ||
 80047f8:	88fb      	ldrh	r3, [r7, #6]
 80047fa:	2b69      	cmp	r3, #105	; 0x69
 80047fc:	d01d      	beq.n	800483a <userMCodeCheck+0x52>
 80047fe:	88fb      	ldrh	r3, [r7, #6]
 8004800:	2b72      	cmp	r3, #114	; 0x72
 8004802:	d01a      	beq.n	800483a <userMCodeCheck+0x52>
 8004804:	88fb      	ldrh	r3, [r7, #6]
 8004806:	2b73      	cmp	r3, #115	; 0x73
 8004808:	d017      	beq.n	800483a <userMCodeCheck+0x52>
 800480a:	88fb      	ldrh	r3, [r7, #6]
 800480c:	2bcc      	cmp	r3, #204	; 0xcc
 800480e:	d014      	beq.n	800483a <userMCodeCheck+0x52>
             mcode == OpenPNP_SetAcceleration || mcode == OpenPNP_FinishMoves || mcode == OpenPNP_SettingsReset
 8004810:	88fb      	ldrh	r3, [r7, #6]
 8004812:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 8004816:	d010      	beq.n	800483a <userMCodeCheck+0x52>
 8004818:	88fb      	ldrh	r3, [r7, #6]
 800481a:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 800481e:	d00c      	beq.n	800483a <userMCodeCheck+0x52>
            : (user_mcode.check ? user_mcode.check(mcode) : UserMCode_Ignore);
 8004820:	4b08      	ldr	r3, [pc, #32]	; (8004844 <userMCodeCheck+0x5c>)
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	2b00      	cmp	r3, #0
 8004826:	d006      	beq.n	8004836 <userMCodeCheck+0x4e>
 8004828:	4b06      	ldr	r3, [pc, #24]	; (8004844 <userMCodeCheck+0x5c>)
 800482a:	681b      	ldr	r3, [r3, #0]
 800482c:	88fa      	ldrh	r2, [r7, #6]
 800482e:	4610      	mov	r0, r2
 8004830:	4798      	blx	r3
 8004832:	4603      	mov	r3, r0
 8004834:	e002      	b.n	800483c <userMCodeCheck+0x54>
 8004836:	2300      	movs	r3, #0
 8004838:	e000      	b.n	800483c <userMCodeCheck+0x54>
 800483a:	88fb      	ldrh	r3, [r7, #6]
}
 800483c:	4618      	mov	r0, r3
 800483e:	3708      	adds	r7, #8
 8004840:	46bd      	mov	sp, r7
 8004842:	bd80      	pop	{r7, pc}
 8004844:	20000584 	.word	0x20000584

08004848 <userMCodeValidate>:

static status_code_t userMCodeValidate (parser_block_t *gc_block, parameter_words_t *deprecated)
{
 8004848:	b580      	push	{r7, lr}
 800484a:	b084      	sub	sp, #16
 800484c:	af00      	add	r7, sp, #0
 800484e:	6078      	str	r0, [r7, #4]
 8004850:	6039      	str	r1, [r7, #0]
    status_code_t state = Status_GcodeValueWordMissing;
 8004852:	231c      	movs	r3, #28
 8004854:	73fb      	strb	r3, [r7, #15]

    UNUSED(deprecated);

    switch(gc_block->user_mcode) {
 8004856:	687b      	ldr	r3, [r7, #4]
 8004858:	885b      	ldrh	r3, [r3, #2]
 800485a:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 800485e:	f000 8130 	beq.w	8004ac2 <userMCodeValidate+0x27a>
 8004862:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 8004866:	f300 812f 	bgt.w	8004ac8 <userMCodeValidate+0x280>
 800486a:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 800486e:	f000 8128 	beq.w	8004ac2 <userMCodeValidate+0x27a>
 8004872:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 8004876:	f300 8127 	bgt.w	8004ac8 <userMCodeValidate+0x280>
 800487a:	2bcc      	cmp	r3, #204	; 0xcc
 800487c:	f000 80b4 	beq.w	80049e8 <userMCodeValidate+0x1a0>
 8004880:	2bcc      	cmp	r3, #204	; 0xcc
 8004882:	f300 8121 	bgt.w	8004ac8 <userMCodeValidate+0x280>
 8004886:	2b73      	cmp	r3, #115	; 0x73
 8004888:	f000 811b 	beq.w	8004ac2 <userMCodeValidate+0x27a>
 800488c:	2b73      	cmp	r3, #115	; 0x73
 800488e:	f300 811b 	bgt.w	8004ac8 <userMCodeValidate+0x280>
 8004892:	2b72      	cmp	r3, #114	; 0x72
 8004894:	f000 8091 	beq.w	80049ba <userMCodeValidate+0x172>
 8004898:	2b72      	cmp	r3, #114	; 0x72
 800489a:	f300 8115 	bgt.w	8004ac8 <userMCodeValidate+0x280>
 800489e:	2b2a      	cmp	r3, #42	; 0x2a
 80048a0:	d002      	beq.n	80048a8 <userMCodeValidate+0x60>
 80048a2:	2b69      	cmp	r3, #105	; 0x69
 80048a4:	d06b      	beq.n	800497e <userMCodeValidate+0x136>
 80048a6:	e10f      	b.n	8004ac8 <userMCodeValidate+0x280>

        case OpenPNP_SetPinState:
            if(gc_block->words.p && gc_block->words.s) {
 80048a8:	687b      	ldr	r3, [r7, #4]
 80048aa:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80048ae:	f003 0301 	and.w	r3, r3, #1
 80048b2:	b2db      	uxtb	r3, r3
 80048b4:	2b00      	cmp	r3, #0
 80048b6:	f000 810a 	beq.w	8004ace <userMCodeValidate+0x286>
 80048ba:	687b      	ldr	r3, [r7, #4]
 80048bc:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80048c0:	f003 0308 	and.w	r3, r3, #8
 80048c4:	b2db      	uxtb	r3, r3
 80048c6:	2b00      	cmp	r3, #0
 80048c8:	f000 8101 	beq.w	8004ace <userMCodeValidate+0x286>

                if(gc_block->words.p && isnan(gc_block->values.p))
 80048cc:	687b      	ldr	r3, [r7, #4]
 80048ce:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80048d2:	f003 0301 	and.w	r3, r3, #1
 80048d6:	b2db      	uxtb	r3, r3
 80048d8:	2b00      	cmp	r3, #0
 80048da:	d00a      	beq.n	80048f2 <userMCodeValidate+0xaa>
 80048dc:	687b      	ldr	r3, [r7, #4]
 80048de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80048e0:	4619      	mov	r1, r3
 80048e2:	4618      	mov	r0, r3
 80048e4:	f7fc fc2c 	bl	8001140 <__aeabi_fcmpun>
 80048e8:	4603      	mov	r3, r0
 80048ea:	2b00      	cmp	r3, #0
 80048ec:	d001      	beq.n	80048f2 <userMCodeValidate+0xaa>
                    state = Status_BadNumberFormat;
 80048ee:	2302      	movs	r3, #2
 80048f0:	73fb      	strb	r3, [r7, #15]

                if(gc_block->words.s && isnan(gc_block->values.s))
 80048f2:	687b      	ldr	r3, [r7, #4]
 80048f4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80048f8:	f003 0308 	and.w	r3, r3, #8
 80048fc:	b2db      	uxtb	r3, r3
 80048fe:	2b00      	cmp	r3, #0
 8004900:	d00a      	beq.n	8004918 <userMCodeValidate+0xd0>
 8004902:	687b      	ldr	r3, [r7, #4]
 8004904:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004906:	4619      	mov	r1, r3
 8004908:	4618      	mov	r0, r3
 800490a:	f7fc fc19 	bl	8001140 <__aeabi_fcmpun>
 800490e:	4603      	mov	r3, r0
 8004910:	2b00      	cmp	r3, #0
 8004912:	d001      	beq.n	8004918 <userMCodeValidate+0xd0>
                    state = Status_BadNumberFormat;
 8004914:	2302      	movs	r3, #2
 8004916:	73fb      	strb	r3, [r7, #15]

                if(state != Status_BadNumberFormat) {
 8004918:	7bfb      	ldrb	r3, [r7, #15]
 800491a:	2b02      	cmp	r3, #2
 800491c:	f000 80d7 	beq.w	8004ace <userMCodeValidate+0x286>
                    if(gc_block->values.p <= 255.0f && (uint8_t)gc_block->values.p < hal.port.num_digital_out) {
 8004920:	687b      	ldr	r3, [r7, #4]
 8004922:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004924:	4976      	ldr	r1, [pc, #472]	; (8004b00 <userMCodeValidate+0x2b8>)
 8004926:	4618      	mov	r0, r3
 8004928:	f7fc fbec 	bl	8001104 <__aeabi_fcmple>
 800492c:	4603      	mov	r3, r0
 800492e:	2b00      	cmp	r3, #0
 8004930:	d022      	beq.n	8004978 <userMCodeValidate+0x130>
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004936:	4618      	mov	r0, r3
 8004938:	f7fc fc3e 	bl	80011b8 <__aeabi_f2uiz>
 800493c:	4603      	mov	r3, r0
 800493e:	b2da      	uxtb	r2, r3
 8004940:	4b70      	ldr	r3, [pc, #448]	; (8004b04 <userMCodeValidate+0x2bc>)
 8004942:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8004946:	429a      	cmp	r2, r3
 8004948:	d216      	bcs.n	8004978 <userMCodeValidate+0x130>
                        gc_block->words.p = gc_block->words.s = Off;
 800494a:	687a      	ldr	r2, [r7, #4]
 800494c:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8004950:	f36f 03c3 	bfc	r3, #3, #1
 8004954:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8004958:	687b      	ldr	r3, [r7, #4]
 800495a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800495e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8004962:	b2d9      	uxtb	r1, r3
 8004964:	687a      	ldr	r2, [r7, #4]
 8004966:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 800496a:	f361 0300 	bfi	r3, r1, #0, #1
 800496e:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                        state = Status_OK;
 8004972:	2300      	movs	r3, #0
 8004974:	73fb      	strb	r3, [r7, #15]
                    } else
                        state = Status_InvalidStatement;
                }
            }
            break;
 8004976:	e0aa      	b.n	8004ace <userMCodeValidate+0x286>
                        state = Status_InvalidStatement;
 8004978:	2303      	movs	r3, #3
 800497a:	73fb      	strb	r3, [r7, #15]
            break;
 800497c:	e0a7      	b.n	8004ace <userMCodeValidate+0x286>

        case OpenPNP_GetADCReading:
            if(gc_block->words.t) {
 800497e:	687b      	ldr	r3, [r7, #4]
 8004980:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004984:	f003 0310 	and.w	r3, r3, #16
 8004988:	b2db      	uxtb	r3, r3
 800498a:	2b00      	cmp	r3, #0
 800498c:	f000 80a1 	beq.w	8004ad2 <userMCodeValidate+0x28a>
                if(gc_block->values.t < hal.port.num_analog_in) {
 8004990:	687b      	ldr	r3, [r7, #4]
 8004992:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004996:	4a5b      	ldr	r2, [pc, #364]	; (8004b04 <userMCodeValidate+0x2bc>)
 8004998:	f892 2116 	ldrb.w	r2, [r2, #278]	; 0x116
 800499c:	4293      	cmp	r3, r2
 800499e:	d209      	bcs.n	80049b4 <userMCodeValidate+0x16c>
                    gc_block->words.t = Off;
 80049a0:	687a      	ldr	r2, [r7, #4]
 80049a2:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80049a6:	f36f 1304 	bfc	r3, #4, #1
 80049aa:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                    state = Status_OK;
 80049ae:	2300      	movs	r3, #0
 80049b0:	73fb      	strb	r3, [r7, #15]
                } else
                    state = Status_InvalidStatement;
            }
            break;
 80049b2:	e08e      	b.n	8004ad2 <userMCodeValidate+0x28a>
                    state = Status_InvalidStatement;
 80049b4:	2303      	movs	r3, #3
 80049b6:	73fb      	strb	r3, [r7, #15]
            break;
 80049b8:	e08b      	b.n	8004ad2 <userMCodeValidate+0x28a>

        case OpenPNP_GetCurrentPosition:
            gc_block->words.d = gc_block->words.r = Off;
 80049ba:	687a      	ldr	r2, [r7, #4]
 80049bc:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80049c0:	f36f 0382 	bfc	r3, #2, #1
 80049c4:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80049c8:	687b      	ldr	r3, [r7, #4]
 80049ca:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80049ce:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80049d2:	b2d9      	uxtb	r1, r3
 80049d4:	687a      	ldr	r2, [r7, #4]
 80049d6:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 80049da:	f361 13c7 	bfi	r3, r1, #7, #1
 80049de:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
            state = Status_OK;
 80049e2:	2300      	movs	r3, #0
 80049e4:	73fb      	strb	r3, [r7, #15]
            break;
 80049e6:	e077      	b.n	8004ad8 <userMCodeValidate+0x290>

        case OpenPNP_SetAcceleration:
            if(gc_block->words.p && isnan(gc_block->values.p))
 80049e8:	687b      	ldr	r3, [r7, #4]
 80049ea:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80049ee:	f003 0301 	and.w	r3, r3, #1
 80049f2:	b2db      	uxtb	r3, r3
 80049f4:	2b00      	cmp	r3, #0
 80049f6:	d00a      	beq.n	8004a0e <userMCodeValidate+0x1c6>
 80049f8:	687b      	ldr	r3, [r7, #4]
 80049fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80049fc:	4619      	mov	r1, r3
 80049fe:	4618      	mov	r0, r3
 8004a00:	f7fc fb9e 	bl	8001140 <__aeabi_fcmpun>
 8004a04:	4603      	mov	r3, r0
 8004a06:	2b00      	cmp	r3, #0
 8004a08:	d001      	beq.n	8004a0e <userMCodeValidate+0x1c6>
                state = Status_BadNumberFormat;
 8004a0a:	2302      	movs	r3, #2
 8004a0c:	73fb      	strb	r3, [r7, #15]

            if(gc_block->words.r && isnan(gc_block->values.r))
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004a14:	f003 0304 	and.w	r3, r3, #4
 8004a18:	b2db      	uxtb	r3, r3
 8004a1a:	2b00      	cmp	r3, #0
 8004a1c:	d00a      	beq.n	8004a34 <userMCodeValidate+0x1ec>
 8004a1e:	687b      	ldr	r3, [r7, #4]
 8004a20:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004a22:	4619      	mov	r1, r3
 8004a24:	4618      	mov	r0, r3
 8004a26:	f7fc fb8b 	bl	8001140 <__aeabi_fcmpun>
 8004a2a:	4603      	mov	r3, r0
 8004a2c:	2b00      	cmp	r3, #0
 8004a2e:	d001      	beq.n	8004a34 <userMCodeValidate+0x1ec>
                state = Status_BadNumberFormat;
 8004a30:	2302      	movs	r3, #2
 8004a32:	73fb      	strb	r3, [r7, #15]

            if(gc_block->words.s && isnan(gc_block->values.s))
 8004a34:	687b      	ldr	r3, [r7, #4]
 8004a36:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004a3a:	f003 0308 	and.w	r3, r3, #8
 8004a3e:	b2db      	uxtb	r3, r3
 8004a40:	2b00      	cmp	r3, #0
 8004a42:	d00a      	beq.n	8004a5a <userMCodeValidate+0x212>
 8004a44:	687b      	ldr	r3, [r7, #4]
 8004a46:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004a48:	4619      	mov	r1, r3
 8004a4a:	4618      	mov	r0, r3
 8004a4c:	f7fc fb78 	bl	8001140 <__aeabi_fcmpun>
 8004a50:	4603      	mov	r3, r0
 8004a52:	2b00      	cmp	r3, #0
 8004a54:	d001      	beq.n	8004a5a <userMCodeValidate+0x212>
                state = Status_BadNumberFormat;
 8004a56:	2302      	movs	r3, #2
 8004a58:	73fb      	strb	r3, [r7, #15]

            if(state != Status_BadNumberFormat) {
 8004a5a:	7bfb      	ldrb	r3, [r7, #15]
 8004a5c:	2b02      	cmp	r3, #2
 8004a5e:	d03a      	beq.n	8004ad6 <userMCodeValidate+0x28e>
                gc_block->words.p = gc_block->words.r = gc_block->words.s = gc_block->words.t = Off;
 8004a60:	687a      	ldr	r2, [r7, #4]
 8004a62:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8004a66:	f36f 1304 	bfc	r3, #4, #1
 8004a6a:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8004a6e:	687b      	ldr	r3, [r7, #4]
 8004a70:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004a74:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8004a78:	b2d9      	uxtb	r1, r3
 8004a7a:	687a      	ldr	r2, [r7, #4]
 8004a7c:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8004a80:	f361 03c3 	bfi	r3, r1, #3, #1
 8004a84:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8004a88:	687b      	ldr	r3, [r7, #4]
 8004a8a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004a8e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8004a92:	b2d9      	uxtb	r1, r3
 8004a94:	687a      	ldr	r2, [r7, #4]
 8004a96:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8004a9a:	f361 0382 	bfi	r3, r1, #2, #1
 8004a9e:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8004aa2:	687b      	ldr	r3, [r7, #4]
 8004aa4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004aa8:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8004aac:	b2d9      	uxtb	r1, r3
 8004aae:	687a      	ldr	r2, [r7, #4]
 8004ab0:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8004ab4:	f361 0300 	bfi	r3, r1, #0, #1
 8004ab8:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                // TODO: add validation
                state = Status_OK;
 8004abc:	2300      	movs	r3, #0
 8004abe:	73fb      	strb	r3, [r7, #15]
            }
            break;
 8004ac0:	e009      	b.n	8004ad6 <userMCodeValidate+0x28e>

        case OpenPNP_FirmwareInfo:
        case OpenPNP_FinishMoves:
        case OpenPNP_SettingsReset:
            state = Status_OK;
 8004ac2:	2300      	movs	r3, #0
 8004ac4:	73fb      	strb	r3, [r7, #15]
            break;
 8004ac6:	e007      	b.n	8004ad8 <userMCodeValidate+0x290>

        default:
            state = Status_Unhandled;
 8004ac8:	2354      	movs	r3, #84	; 0x54
 8004aca:	73fb      	strb	r3, [r7, #15]
            break;
 8004acc:	e004      	b.n	8004ad8 <userMCodeValidate+0x290>
            break;
 8004ace:	bf00      	nop
 8004ad0:	e002      	b.n	8004ad8 <userMCodeValidate+0x290>
            break;
 8004ad2:	bf00      	nop
 8004ad4:	e000      	b.n	8004ad8 <userMCodeValidate+0x290>
            break;
 8004ad6:	bf00      	nop
    }

    return state == Status_Unhandled && user_mcode.validate ? user_mcode.validate(gc_block, deprecated) : state;
 8004ad8:	7bfb      	ldrb	r3, [r7, #15]
 8004ada:	2b54      	cmp	r3, #84	; 0x54
 8004adc:	d10a      	bne.n	8004af4 <userMCodeValidate+0x2ac>
 8004ade:	4b0a      	ldr	r3, [pc, #40]	; (8004b08 <userMCodeValidate+0x2c0>)
 8004ae0:	685b      	ldr	r3, [r3, #4]
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	d006      	beq.n	8004af4 <userMCodeValidate+0x2ac>
 8004ae6:	4b08      	ldr	r3, [pc, #32]	; (8004b08 <userMCodeValidate+0x2c0>)
 8004ae8:	685b      	ldr	r3, [r3, #4]
 8004aea:	6839      	ldr	r1, [r7, #0]
 8004aec:	6878      	ldr	r0, [r7, #4]
 8004aee:	4798      	blx	r3
 8004af0:	4603      	mov	r3, r0
 8004af2:	e000      	b.n	8004af6 <userMCodeValidate+0x2ae>
 8004af4:	7bfb      	ldrb	r3, [r7, #15]
}
 8004af6:	4618      	mov	r0, r3
 8004af8:	3710      	adds	r7, #16
 8004afa:	46bd      	mov	sp, r7
 8004afc:	bd80      	pop	{r7, pc}
 8004afe:	bf00      	nop
 8004b00:	437f0000 	.word	0x437f0000
 8004b04:	20000ed0 	.word	0x20000ed0
 8004b08:	20000584 	.word	0x20000584

08004b0c <report_position>:

static void report_position (bool real, bool detailed)
{
 8004b0c:	b590      	push	{r4, r7, lr}
 8004b0e:	b099      	sub	sp, #100	; 0x64
 8004b10:	af00      	add	r7, sp, #0
 8004b12:	4603      	mov	r3, r0
 8004b14:	460a      	mov	r2, r1
 8004b16:	71fb      	strb	r3, [r7, #7]
 8004b18:	4613      	mov	r3, r2
 8004b1a:	71bb      	strb	r3, [r7, #6]
    uint_fast8_t idx;
    int32_t current_position[N_AXIS];
    float print_position[N_AXIS];
    char buf[(STRLEN_COORDVALUE + 4) * N_AXIS];

    if(real || detailed) {
 8004b1c:	79fb      	ldrb	r3, [r7, #7]
 8004b1e:	2b00      	cmp	r3, #0
 8004b20:	d102      	bne.n	8004b28 <report_position+0x1c>
 8004b22:	79bb      	ldrb	r3, [r7, #6]
 8004b24:	2b00      	cmp	r3, #0
 8004b26:	d012      	beq.n	8004b4e <report_position+0x42>
        memcpy(current_position, sys.position, sizeof(sys.position));
 8004b28:	4a75      	ldr	r2, [pc, #468]	; (8004d00 <report_position+0x1f4>)
 8004b2a:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8004b2e:	3288      	adds	r2, #136	; 0x88
 8004b30:	ca07      	ldmia	r2, {r0, r1, r2}
 8004b32:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    if(real)
 8004b36:	79fb      	ldrb	r3, [r7, #7]
 8004b38:	2b00      	cmp	r3, #0
 8004b3a:	d00f      	beq.n	8004b5c <report_position+0x50>
        system_convert_array_steps_to_mpos(print_position, current_position);
 8004b3c:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8004b40:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8004b44:	4611      	mov	r1, r2
 8004b46:	4618      	mov	r0, r3
 8004b48:	f01d f962 	bl	8021e10 <system_convert_array_steps_to_mpos>
    if(real)
 8004b4c:	e006      	b.n	8004b5c <report_position+0x50>
    } else
        memcpy(print_position, gc_state.position, sizeof(print_position));
 8004b4e:	4a6d      	ldr	r2, [pc, #436]	; (8004d04 <report_position+0x1f8>)
 8004b50:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8004b54:	325c      	adds	r2, #92	; 0x5c
 8004b56:	ca07      	ldmia	r2, {r0, r1, r2}
 8004b58:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    *buf = '\0';
 8004b5c:	2300      	movs	r3, #0
 8004b5e:	733b      	strb	r3, [r7, #12]
    for (idx = 0; idx < N_AXIS; idx++) {
 8004b60:	2300      	movs	r3, #0
 8004b62:	65fb      	str	r3, [r7, #92]	; 0x5c
 8004b64:	e053      	b.n	8004c0e <report_position+0x102>
        print_position[idx] -= gc_get_offset(idx);
 8004b66:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8004b68:	f000 ff38 	bl	80059dc <gc_get_offset>
 8004b6c:	4602      	mov	r2, r0
 8004b6e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004b70:	009b      	lsls	r3, r3, #2
 8004b72:	3360      	adds	r3, #96	; 0x60
 8004b74:	443b      	add	r3, r7
 8004b76:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8004b7a:	4611      	mov	r1, r2
 8004b7c:	4618      	mov	r0, r3
 8004b7e:	f7fc f80f 	bl	8000ba0 <__aeabi_fsub>
 8004b82:	4603      	mov	r3, r0
 8004b84:	461a      	mov	r2, r3
 8004b86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004b88:	009b      	lsls	r3, r3, #2
 8004b8a:	3360      	adds	r3, #96	; 0x60
 8004b8c:	443b      	add	r3, r7
 8004b8e:	f843 2c1c 	str.w	r2, [r3, #-28]
        strcat(buf, axis_letter[idx]);
 8004b92:	4a5d      	ldr	r2, [pc, #372]	; (8004d08 <report_position+0x1fc>)
 8004b94:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004b96:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004b9a:	f107 030c 	add.w	r3, r7, #12
 8004b9e:	4611      	mov	r1, r2
 8004ba0:	4618      	mov	r0, r3
 8004ba2:	f01f f840 	bl	8023c26 <strcat>
        strcat(buf, ":");
 8004ba6:	f107 030c 	add.w	r3, r7, #12
 8004baa:	4618      	mov	r0, r3
 8004bac:	f7fb fb46 	bl	800023c <strlen>
 8004bb0:	4603      	mov	r3, r0
 8004bb2:	461a      	mov	r2, r3
 8004bb4:	f107 030c 	add.w	r3, r7, #12
 8004bb8:	4413      	add	r3, r2
 8004bba:	4954      	ldr	r1, [pc, #336]	; (8004d0c <report_position+0x200>)
 8004bbc:	461a      	mov	r2, r3
 8004bbe:	460b      	mov	r3, r1
 8004bc0:	881b      	ldrh	r3, [r3, #0]
 8004bc2:	8013      	strh	r3, [r2, #0]
        strcat(buf, ftoa(print_position[idx], N_DECIMAL_COORDVALUE_MM)); // always mm and 3 decimals?
 8004bc4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004bc6:	009b      	lsls	r3, r3, #2
 8004bc8:	3360      	adds	r3, #96	; 0x60
 8004bca:	443b      	add	r3, r7
 8004bcc:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8004bd0:	2103      	movs	r1, #3
 8004bd2:	4618      	mov	r0, r3
 8004bd4:	f00b fb96 	bl	8010304 <ftoa>
 8004bd8:	4602      	mov	r2, r0
 8004bda:	f107 030c 	add.w	r3, r7, #12
 8004bde:	4611      	mov	r1, r2
 8004be0:	4618      	mov	r0, r3
 8004be2:	f01f f820 	bl	8023c26 <strcat>
        strcat(buf, idx == N_AXIS - 1 ? (detailed ? " " : ASCII_EOL) : " ");
 8004be6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004be8:	2b02      	cmp	r3, #2
 8004bea:	d106      	bne.n	8004bfa <report_position+0xee>
 8004bec:	79bb      	ldrb	r3, [r7, #6]
 8004bee:	2b00      	cmp	r3, #0
 8004bf0:	d001      	beq.n	8004bf6 <report_position+0xea>
 8004bf2:	4b47      	ldr	r3, [pc, #284]	; (8004d10 <report_position+0x204>)
 8004bf4:	e002      	b.n	8004bfc <report_position+0xf0>
 8004bf6:	4b47      	ldr	r3, [pc, #284]	; (8004d14 <report_position+0x208>)
 8004bf8:	e000      	b.n	8004bfc <report_position+0xf0>
 8004bfa:	4b45      	ldr	r3, [pc, #276]	; (8004d10 <report_position+0x204>)
 8004bfc:	f107 020c 	add.w	r2, r7, #12
 8004c00:	4619      	mov	r1, r3
 8004c02:	4610      	mov	r0, r2
 8004c04:	f01f f80f 	bl	8023c26 <strcat>
    for (idx = 0; idx < N_AXIS; idx++) {
 8004c08:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c0a:	3301      	adds	r3, #1
 8004c0c:	65fb      	str	r3, [r7, #92]	; 0x5c
 8004c0e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c10:	2b02      	cmp	r3, #2
 8004c12:	d9a8      	bls.n	8004b66 <report_position+0x5a>
    }

    hal.stream.write(buf);
 8004c14:	4b40      	ldr	r3, [pc, #256]	; (8004d18 <report_position+0x20c>)
 8004c16:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004c1a:	f107 020c 	add.w	r2, r7, #12
 8004c1e:	4610      	mov	r0, r2
 8004c20:	4798      	blx	r3

    if(detailed) {
 8004c22:	79bb      	ldrb	r3, [r7, #6]
 8004c24:	2b00      	cmp	r3, #0
 8004c26:	d066      	beq.n	8004cf6 <report_position+0x1ea>

        *buf = '\0';
 8004c28:	2300      	movs	r3, #0
 8004c2a:	733b      	strb	r3, [r7, #12]
        hal.stream.write("Count ");
 8004c2c:	4b3a      	ldr	r3, [pc, #232]	; (8004d18 <report_position+0x20c>)
 8004c2e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004c32:	483a      	ldr	r0, [pc, #232]	; (8004d1c <report_position+0x210>)
 8004c34:	4798      	blx	r3

        for (idx = 0; idx < N_AXIS; idx++) {
 8004c36:	2300      	movs	r3, #0
 8004c38:	65fb      	str	r3, [r7, #92]	; 0x5c
 8004c3a:	e052      	b.n	8004ce2 <report_position+0x1d6>
            print_position[idx] -= gc_get_offset(idx);
 8004c3c:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8004c3e:	f000 fecd 	bl	80059dc <gc_get_offset>
 8004c42:	4602      	mov	r2, r0
 8004c44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c46:	009b      	lsls	r3, r3, #2
 8004c48:	3360      	adds	r3, #96	; 0x60
 8004c4a:	443b      	add	r3, r7
 8004c4c:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8004c50:	4611      	mov	r1, r2
 8004c52:	4618      	mov	r0, r3
 8004c54:	f7fb ffa4 	bl	8000ba0 <__aeabi_fsub>
 8004c58:	4603      	mov	r3, r0
 8004c5a:	461a      	mov	r2, r3
 8004c5c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c5e:	009b      	lsls	r3, r3, #2
 8004c60:	3360      	adds	r3, #96	; 0x60
 8004c62:	443b      	add	r3, r7
 8004c64:	f843 2c1c 	str.w	r2, [r3, #-28]
            strcat(buf, axis_letter[idx]);
 8004c68:	4a27      	ldr	r2, [pc, #156]	; (8004d08 <report_position+0x1fc>)
 8004c6a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c6c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8004c70:	f107 030c 	add.w	r3, r7, #12
 8004c74:	4611      	mov	r1, r2
 8004c76:	4618      	mov	r0, r3
 8004c78:	f01e ffd5 	bl	8023c26 <strcat>
            strcat(buf, ":");
 8004c7c:	f107 030c 	add.w	r3, r7, #12
 8004c80:	4618      	mov	r0, r3
 8004c82:	f7fb fadb 	bl	800023c <strlen>
 8004c86:	4603      	mov	r3, r0
 8004c88:	461a      	mov	r2, r3
 8004c8a:	f107 030c 	add.w	r3, r7, #12
 8004c8e:	4413      	add	r3, r2
 8004c90:	491e      	ldr	r1, [pc, #120]	; (8004d0c <report_position+0x200>)
 8004c92:	461a      	mov	r2, r3
 8004c94:	460b      	mov	r3, r1
 8004c96:	881b      	ldrh	r3, [r3, #0]
 8004c98:	8013      	strh	r3, [r2, #0]
            itoa(current_position[idx], strchr(buf, '\0'), 10);
 8004c9a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004c9c:	009b      	lsls	r3, r3, #2
 8004c9e:	3360      	adds	r3, #96	; 0x60
 8004ca0:	443b      	add	r3, r7
 8004ca2:	f853 4c10 	ldr.w	r4, [r3, #-16]
 8004ca6:	f107 030c 	add.w	r3, r7, #12
 8004caa:	4618      	mov	r0, r3
 8004cac:	f7fb fac6 	bl	800023c <strlen>
 8004cb0:	4603      	mov	r3, r0
 8004cb2:	461a      	mov	r2, r3
 8004cb4:	f107 030c 	add.w	r3, r7, #12
 8004cb8:	4413      	add	r3, r2
 8004cba:	220a      	movs	r2, #10
 8004cbc:	4619      	mov	r1, r3
 8004cbe:	4620      	mov	r0, r4
 8004cc0:	f01e fbf8 	bl	80234b4 <itoa>
            strcat(buf, idx == N_AXIS - 1 ? ASCII_EOL : " ");
 8004cc4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004cc6:	2b02      	cmp	r3, #2
 8004cc8:	d101      	bne.n	8004cce <report_position+0x1c2>
 8004cca:	4a12      	ldr	r2, [pc, #72]	; (8004d14 <report_position+0x208>)
 8004ccc:	e000      	b.n	8004cd0 <report_position+0x1c4>
 8004cce:	4a10      	ldr	r2, [pc, #64]	; (8004d10 <report_position+0x204>)
 8004cd0:	f107 030c 	add.w	r3, r7, #12
 8004cd4:	4611      	mov	r1, r2
 8004cd6:	4618      	mov	r0, r3
 8004cd8:	f01e ffa5 	bl	8023c26 <strcat>
        for (idx = 0; idx < N_AXIS; idx++) {
 8004cdc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004cde:	3301      	adds	r3, #1
 8004ce0:	65fb      	str	r3, [r7, #92]	; 0x5c
 8004ce2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8004ce4:	2b02      	cmp	r3, #2
 8004ce6:	d9a9      	bls.n	8004c3c <report_position+0x130>
        }

        hal.stream.write(buf);
 8004ce8:	4b0b      	ldr	r3, [pc, #44]	; (8004d18 <report_position+0x20c>)
 8004cea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004cee:	f107 020c 	add.w	r2, r7, #12
 8004cf2:	4610      	mov	r0, r2
 8004cf4:	4798      	blx	r3
    }
}
 8004cf6:	bf00      	nop
 8004cf8:	3764      	adds	r7, #100	; 0x64
 8004cfa:	46bd      	mov	sp, r7
 8004cfc:	bd90      	pop	{r4, r7, pc}
 8004cfe:	bf00      	nop
 8004d00:	20000d3c 	.word	0x20000d3c
 8004d04:	20000bb0 	.word	0x20000bb0
 8004d08:	0803102c 	.word	0x0803102c
 8004d0c:	080272cc 	.word	0x080272cc
 8004d10:	080272d0 	.word	0x080272d0
 8004d14:	080272d4 	.word	0x080272d4
 8004d18:	20000ed0 	.word	0x20000ed0
 8004d1c:	080272d8 	.word	0x080272d8

08004d20 <report_temperature>:

static void report_temperature (sys_state_t state)
{
 8004d20:	b590      	push	{r4, r7, lr}
 8004d22:	b085      	sub	sp, #20
 8004d24:	af00      	add	r7, sp, #0
 8004d26:	6078      	str	r0, [r7, #4]
    int32_t v = hal.port.wait_on_input(false, tport, WaitMode_Immediate, 0.0f);
 8004d28:	4b07      	ldr	r3, [pc, #28]	; (8004d48 <report_temperature+0x28>)
 8004d2a:	f8d3 4120 	ldr.w	r4, [r3, #288]	; 0x120
 8004d2e:	4b07      	ldr	r3, [pc, #28]	; (8004d4c <report_temperature+0x2c>)
 8004d30:	7819      	ldrb	r1, [r3, #0]
 8004d32:	f04f 0300 	mov.w	r3, #0
 8004d36:	2200      	movs	r2, #0
 8004d38:	2000      	movs	r0, #0
 8004d3a:	47a0      	blx	r4
 8004d3c:	60f8      	str	r0, [r7, #12]
    // format output -> T:21.17 /0.0000 B:21.04 /0.0000 @:0 B@:0
}
 8004d3e:	bf00      	nop
 8004d40:	3714      	adds	r7, #20
 8004d42:	46bd      	mov	sp, r7
 8004d44:	bd90      	pop	{r4, r7, pc}
 8004d46:	bf00      	nop
 8004d48:	20000ed0 	.word	0x20000ed0
 8004d4c:	20000594 	.word	0x20000594

08004d50 <userMCodeExecute>:

static void userMCodeExecute (uint_fast16_t state, parser_block_t *gc_block)
{
 8004d50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004d52:	b087      	sub	sp, #28
 8004d54:	af00      	add	r7, sp, #0
 8004d56:	6078      	str	r0, [r7, #4]
 8004d58:	6039      	str	r1, [r7, #0]
    bool handled = true;
 8004d5a:	2301      	movs	r3, #1
 8004d5c:	75fb      	strb	r3, [r7, #23]

    if (state != STATE_CHECK_MODE)
 8004d5e:	687b      	ldr	r3, [r7, #4]
 8004d60:	2b02      	cmp	r3, #2
 8004d62:	f000 80dd 	beq.w	8004f20 <userMCodeExecute+0x1d0>
      switch(gc_block->user_mcode) {
 8004d66:	683b      	ldr	r3, [r7, #0]
 8004d68:	885b      	ldrh	r3, [r3, #2]
 8004d6a:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 8004d6e:	f000 80c2 	beq.w	8004ef6 <userMCodeExecute+0x1a6>
 8004d72:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 8004d76:	f300 80d0 	bgt.w	8004f1a <userMCodeExecute+0x1ca>
 8004d7a:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 8004d7e:	f000 80b7 	beq.w	8004ef0 <userMCodeExecute+0x1a0>
 8004d82:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 8004d86:	f300 80c8 	bgt.w	8004f1a <userMCodeExecute+0x1ca>
 8004d8a:	2bcc      	cmp	r3, #204	; 0xcc
 8004d8c:	d076      	beq.n	8004e7c <userMCodeExecute+0x12c>
 8004d8e:	2bcc      	cmp	r3, #204	; 0xcc
 8004d90:	f300 80c3 	bgt.w	8004f1a <userMCodeExecute+0x1ca>
 8004d94:	2b73      	cmp	r3, #115	; 0x73
 8004d96:	d04e      	beq.n	8004e36 <userMCodeExecute+0xe6>
 8004d98:	2b73      	cmp	r3, #115	; 0x73
 8004d9a:	f300 80be 	bgt.w	8004f1a <userMCodeExecute+0x1ca>
 8004d9e:	2b72      	cmp	r3, #114	; 0x72
 8004da0:	d02e      	beq.n	8004e00 <userMCodeExecute+0xb0>
 8004da2:	2b72      	cmp	r3, #114	; 0x72
 8004da4:	f300 80b9 	bgt.w	8004f1a <userMCodeExecute+0x1ca>
 8004da8:	2b2a      	cmp	r3, #42	; 0x2a
 8004daa:	d002      	beq.n	8004db2 <userMCodeExecute+0x62>
 8004dac:	2b69      	cmp	r3, #105	; 0x69
 8004dae:	d01d      	beq.n	8004dec <userMCodeExecute+0x9c>
 8004db0:	e0b3      	b.n	8004f1a <userMCodeExecute+0x1ca>

        case OpenPNP_SetPinState:
            hal.port.digital_out(gc_block->values.p, gc_block->values.s != 0.0f);
 8004db2:	4b65      	ldr	r3, [pc, #404]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004db4:	f8d3 4118 	ldr.w	r4, [r3, #280]	; 0x118
 8004db8:	683b      	ldr	r3, [r7, #0]
 8004dba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004dbc:	4618      	mov	r0, r3
 8004dbe:	f7fc f9fb 	bl	80011b8 <__aeabi_f2uiz>
 8004dc2:	4603      	mov	r3, r0
 8004dc4:	b2dd      	uxtb	r5, r3
 8004dc6:	683b      	ldr	r3, [r7, #0]
 8004dc8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004dca:	2201      	movs	r2, #1
 8004dcc:	4616      	mov	r6, r2
 8004dce:	f04f 0100 	mov.w	r1, #0
 8004dd2:	4618      	mov	r0, r3
 8004dd4:	f7fc f982 	bl	80010dc <__aeabi_fcmpeq>
 8004dd8:	4603      	mov	r3, r0
 8004dda:	2b00      	cmp	r3, #0
 8004ddc:	d001      	beq.n	8004de2 <userMCodeExecute+0x92>
 8004dde:	2300      	movs	r3, #0
 8004de0:	461e      	mov	r6, r3
 8004de2:	b2f3      	uxtb	r3, r6
 8004de4:	4619      	mov	r1, r3
 8004de6:	4628      	mov	r0, r5
 8004de8:	47a0      	blx	r4
            break;
 8004dea:	e099      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_GetADCReading: // Request temperature report
            tport = gc_block->values.t;
 8004dec:	683b      	ldr	r3, [r7, #0]
 8004dee:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004df2:	b2da      	uxtb	r2, r3
 8004df4:	4b55      	ldr	r3, [pc, #340]	; (8004f4c <userMCodeExecute+0x1fc>)
 8004df6:	701a      	strb	r2, [r3, #0]
            protocol_enqueue_rt_command(report_temperature);
 8004df8:	4855      	ldr	r0, [pc, #340]	; (8004f50 <userMCodeExecute+0x200>)
 8004dfa:	f00e fff7 	bl	8013dec <protocol_enqueue_rt_command>
            break;
 8004dfe:	e08f      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_GetCurrentPosition:
            report_position(gc_block->words.r, gc_block->words.d);
 8004e00:	683b      	ldr	r3, [r7, #0]
 8004e02:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004e06:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8004e0a:	b2db      	uxtb	r3, r3
 8004e0c:	2b00      	cmp	r3, #0
 8004e0e:	bf14      	ite	ne
 8004e10:	2301      	movne	r3, #1
 8004e12:	2300      	moveq	r3, #0
 8004e14:	b2da      	uxtb	r2, r3
 8004e16:	683b      	ldr	r3, [r7, #0]
 8004e18:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8004e1c:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8004e20:	b2db      	uxtb	r3, r3
 8004e22:	2b00      	cmp	r3, #0
 8004e24:	bf14      	ite	ne
 8004e26:	2301      	movne	r3, #1
 8004e28:	2300      	moveq	r3, #0
 8004e2a:	b2db      	uxtb	r3, r3
 8004e2c:	4619      	mov	r1, r3
 8004e2e:	4610      	mov	r0, r2
 8004e30:	f7ff fe6c 	bl	8004b0c <report_position>
            break;
 8004e34:	e074      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_FirmwareInfo:
            hal.stream.write("FIRMWARE_NAME:grblHAL ");
 8004e36:	4b44      	ldr	r3, [pc, #272]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e38:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004e3c:	4845      	ldr	r0, [pc, #276]	; (8004f54 <userMCodeExecute+0x204>)
 8004e3e:	4798      	blx	r3
            hal.stream.write("FIRMWARE_URL:https%3A//github.com/grblHAL ");
 8004e40:	4b41      	ldr	r3, [pc, #260]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e42:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004e46:	4844      	ldr	r0, [pc, #272]	; (8004f58 <userMCodeExecute+0x208>)
 8004e48:	4798      	blx	r3
            hal.stream.write("FIRMWARE_VERSION:" GRBL_VERSION " ");
 8004e4a:	4b3f      	ldr	r3, [pc, #252]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e4c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004e50:	4842      	ldr	r0, [pc, #264]	; (8004f5c <userMCodeExecute+0x20c>)
 8004e52:	4798      	blx	r3
            hal.stream.write("FIRMWARE_BUILD:");
 8004e54:	4b3c      	ldr	r3, [pc, #240]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e56:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004e5a:	4841      	ldr	r0, [pc, #260]	; (8004f60 <userMCodeExecute+0x210>)
 8004e5c:	4798      	blx	r3
            hal.stream.write(uitoa(GRBL_BUILD));
 8004e5e:	4b3a      	ldr	r3, [pc, #232]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e60:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8004e64:	483f      	ldr	r0, [pc, #252]	; (8004f64 <userMCodeExecute+0x214>)
 8004e66:	f00b fa11 	bl	801028c <uitoa>
 8004e6a:	4603      	mov	r3, r0
 8004e6c:	4618      	mov	r0, r3
 8004e6e:	47a0      	blx	r4
            hal.stream.write(ASCII_EOL);
 8004e70:	4b35      	ldr	r3, [pc, #212]	; (8004f48 <userMCodeExecute+0x1f8>)
 8004e72:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004e76:	483c      	ldr	r0, [pc, #240]	; (8004f68 <userMCodeExecute+0x218>)
 8004e78:	4798      	blx	r3
            break;
 8004e7a:	e051      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_SetAcceleration: // Set acceleration
            {
                uint_fast8_t idx = N_AXIS;
 8004e7c:	2303      	movs	r3, #3
 8004e7e:	613b      	str	r3, [r7, #16]

                protocol_buffer_synchronize();
 8004e80:	f00d ff3e 	bl	8012d00 <protocol_buffer_synchronize>
                do {
                    idx--;
 8004e84:	693b      	ldr	r3, [r7, #16]
 8004e86:	3b01      	subs	r3, #1
 8004e88:	613b      	str	r3, [r7, #16]
                    if(gc_block->words.s || idx == X_AXIS || idx == Y_AXIS)
 8004e8a:	683b      	ldr	r3, [r7, #0]
 8004e8c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004e90:	f003 0308 	and.w	r3, r3, #8
 8004e94:	b2db      	uxtb	r3, r3
 8004e96:	2b00      	cmp	r3, #0
 8004e98:	d105      	bne.n	8004ea6 <userMCodeExecute+0x156>
 8004e9a:	693b      	ldr	r3, [r7, #16]
 8004e9c:	2b00      	cmp	r3, #0
 8004e9e:	d002      	beq.n	8004ea6 <userMCodeExecute+0x156>
 8004ea0:	693b      	ldr	r3, [r7, #16]
 8004ea2:	2b01      	cmp	r3, #1
 8004ea4:	d118      	bne.n	8004ed8 <userMCodeExecute+0x188>
                        settings_override_acceleration(idx, gc_block->words.s ? gc_block->values.s : gc_block->values.t);
 8004ea6:	693b      	ldr	r3, [r7, #16]
 8004ea8:	b2dc      	uxtb	r4, r3
 8004eaa:	683b      	ldr	r3, [r7, #0]
 8004eac:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004eb0:	f003 0308 	and.w	r3, r3, #8
 8004eb4:	b2db      	uxtb	r3, r3
 8004eb6:	2b00      	cmp	r3, #0
 8004eb8:	d002      	beq.n	8004ec0 <userMCodeExecute+0x170>
 8004eba:	683b      	ldr	r3, [r7, #0]
 8004ebc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004ebe:	e006      	b.n	8004ece <userMCodeExecute+0x17e>
 8004ec0:	683b      	ldr	r3, [r7, #0]
 8004ec2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004ec6:	4618      	mov	r0, r3
 8004ec8:	f7fb ff1c 	bl	8000d04 <__aeabi_ui2f>
 8004ecc:	4603      	mov	r3, r0
 8004ece:	4619      	mov	r1, r3
 8004ed0:	4620      	mov	r0, r4
 8004ed2:	f013 fecd 	bl	8018c70 <settings_override_acceleration>
 8004ed6:	e007      	b.n	8004ee8 <userMCodeExecute+0x198>
                    else
                        settings_override_acceleration(idx, gc_block->values.p);
 8004ed8:	693b      	ldr	r3, [r7, #16]
 8004eda:	b2da      	uxtb	r2, r3
 8004edc:	683b      	ldr	r3, [r7, #0]
 8004ede:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004ee0:	4619      	mov	r1, r3
 8004ee2:	4610      	mov	r0, r2
 8004ee4:	f013 fec4 	bl	8018c70 <settings_override_acceleration>
                } while(idx);
 8004ee8:	693b      	ldr	r3, [r7, #16]
 8004eea:	2b00      	cmp	r3, #0
 8004eec:	d1ca      	bne.n	8004e84 <userMCodeExecute+0x134>
            }
            break;
 8004eee:	e017      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_FinishMoves: // Wait for buffered motions to complete
            protocol_buffer_synchronize();
 8004ef0:	f00d ff06 	bl	8012d00 <protocol_buffer_synchronize>
            break;
 8004ef4:	e014      	b.n	8004f20 <userMCodeExecute+0x1d0>

        case OpenPNP_SettingsReset: // Restore acceleration to configured values
            {
                uint_fast8_t idx = N_AXIS;
 8004ef6:	2303      	movs	r3, #3
 8004ef8:	60fb      	str	r3, [r7, #12]

                protocol_buffer_synchronize();
 8004efa:	f00d ff01 	bl	8012d00 <protocol_buffer_synchronize>
                do {
                    settings_override_acceleration(--idx, 0.0f);
 8004efe:	68fb      	ldr	r3, [r7, #12]
 8004f00:	3b01      	subs	r3, #1
 8004f02:	60fb      	str	r3, [r7, #12]
 8004f04:	68fb      	ldr	r3, [r7, #12]
 8004f06:	b2db      	uxtb	r3, r3
 8004f08:	f04f 0100 	mov.w	r1, #0
 8004f0c:	4618      	mov	r0, r3
 8004f0e:	f013 feaf 	bl	8018c70 <settings_override_acceleration>
                } while(idx);
 8004f12:	68fb      	ldr	r3, [r7, #12]
 8004f14:	2b00      	cmp	r3, #0
 8004f16:	d1f2      	bne.n	8004efe <userMCodeExecute+0x1ae>
            }
            break;
 8004f18:	e002      	b.n	8004f20 <userMCodeExecute+0x1d0>

        default:
            handled = false;
 8004f1a:	2300      	movs	r3, #0
 8004f1c:	75fb      	strb	r3, [r7, #23]
            break;
 8004f1e:	bf00      	nop
    }

    if(!handled && user_mcode.execute)
 8004f20:	7dfb      	ldrb	r3, [r7, #23]
 8004f22:	f083 0301 	eor.w	r3, r3, #1
 8004f26:	b2db      	uxtb	r3, r3
 8004f28:	2b00      	cmp	r3, #0
 8004f2a:	d008      	beq.n	8004f3e <userMCodeExecute+0x1ee>
 8004f2c:	4b0f      	ldr	r3, [pc, #60]	; (8004f6c <userMCodeExecute+0x21c>)
 8004f2e:	689b      	ldr	r3, [r3, #8]
 8004f30:	2b00      	cmp	r3, #0
 8004f32:	d004      	beq.n	8004f3e <userMCodeExecute+0x1ee>
        user_mcode.execute(state, gc_block);
 8004f34:	4b0d      	ldr	r3, [pc, #52]	; (8004f6c <userMCodeExecute+0x21c>)
 8004f36:	689b      	ldr	r3, [r3, #8]
 8004f38:	6839      	ldr	r1, [r7, #0]
 8004f3a:	6878      	ldr	r0, [r7, #4]
 8004f3c:	4798      	blx	r3
}
 8004f3e:	bf00      	nop
 8004f40:	371c      	adds	r7, #28
 8004f42:	46bd      	mov	sp, r7
 8004f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f46:	bf00      	nop
 8004f48:	20000ed0 	.word	0x20000ed0
 8004f4c:	20000594 	.word	0x20000594
 8004f50:	08004d21 	.word	0x08004d21
 8004f54:	080272e0 	.word	0x080272e0
 8004f58:	080272f8 	.word	0x080272f8
 8004f5c:	08027324 	.word	0x08027324
 8004f60:	0802733c 	.word	0x0802733c
 8004f64:	0134b436 	.word	0x0134b436
 8004f68:	080272d4 	.word	0x080272d4
 8004f6c:	20000584 	.word	0x20000584

08004f70 <onReportOptions>:

static void onReportOptions (bool newopt)
{
 8004f70:	b580      	push	{r7, lr}
 8004f72:	b082      	sub	sp, #8
 8004f74:	af00      	add	r7, sp, #0
 8004f76:	4603      	mov	r3, r0
 8004f78:	71fb      	strb	r3, [r7, #7]
    on_report_options(newopt);
 8004f7a:	4b0a      	ldr	r3, [pc, #40]	; (8004fa4 <onReportOptions+0x34>)
 8004f7c:	681b      	ldr	r3, [r3, #0]
 8004f7e:	79fa      	ldrb	r2, [r7, #7]
 8004f80:	4610      	mov	r0, r2
 8004f82:	4798      	blx	r3

    if(!newopt)
 8004f84:	79fb      	ldrb	r3, [r7, #7]
 8004f86:	f083 0301 	eor.w	r3, r3, #1
 8004f8a:	b2db      	uxtb	r3, r3
 8004f8c:	2b00      	cmp	r3, #0
 8004f8e:	d004      	beq.n	8004f9a <onReportOptions+0x2a>
        hal.stream.write("[PLUGIN:OpenPNP v0.02]" ASCII_EOL);
 8004f90:	4b05      	ldr	r3, [pc, #20]	; (8004fa8 <onReportOptions+0x38>)
 8004f92:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8004f96:	4805      	ldr	r0, [pc, #20]	; (8004fac <onReportOptions+0x3c>)
 8004f98:	4798      	blx	r3
}
 8004f9a:	bf00      	nop
 8004f9c:	3708      	adds	r7, #8
 8004f9e:	46bd      	mov	sp, r7
 8004fa0:	bd80      	pop	{r7, pc}
 8004fa2:	bf00      	nop
 8004fa4:	20000590 	.word	0x20000590
 8004fa8:	20000ed0 	.word	0x20000ed0
 8004fac:	0802734c 	.word	0x0802734c

08004fb0 <openpnp_init>:

void openpnp_init (void)
{
 8004fb0:	b490      	push	{r4, r7}
 8004fb2:	af00      	add	r7, sp, #0
    memcpy(&user_mcode, &hal.user_mcode, sizeof(user_mcode_ptrs_t));
 8004fb4:	4a0f      	ldr	r2, [pc, #60]	; (8004ff4 <openpnp_init+0x44>)
 8004fb6:	4b10      	ldr	r3, [pc, #64]	; (8004ff8 <openpnp_init+0x48>)
 8004fb8:	4614      	mov	r4, r2
 8004fba:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 8004fbe:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8004fc2:	e884 0007 	stmia.w	r4, {r0, r1, r2}

    hal.user_mcode.check = userMCodeCheck;
 8004fc6:	4b0c      	ldr	r3, [pc, #48]	; (8004ff8 <openpnp_init+0x48>)
 8004fc8:	4a0c      	ldr	r2, [pc, #48]	; (8004ffc <openpnp_init+0x4c>)
 8004fca:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    hal.user_mcode.validate = userMCodeValidate;
 8004fce:	4b0a      	ldr	r3, [pc, #40]	; (8004ff8 <openpnp_init+0x48>)
 8004fd0:	4a0b      	ldr	r2, [pc, #44]	; (8005000 <openpnp_init+0x50>)
 8004fd2:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
    hal.user_mcode.execute = userMCodeExecute;
 8004fd6:	4b08      	ldr	r3, [pc, #32]	; (8004ff8 <openpnp_init+0x48>)
 8004fd8:	4a0a      	ldr	r2, [pc, #40]	; (8005004 <openpnp_init+0x54>)
 8004fda:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190

    on_report_options = grbl.on_report_options;
 8004fde:	4b0a      	ldr	r3, [pc, #40]	; (8005008 <openpnp_init+0x58>)
 8004fe0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004fe2:	4a0a      	ldr	r2, [pc, #40]	; (800500c <openpnp_init+0x5c>)
 8004fe4:	6013      	str	r3, [r2, #0]
    grbl.on_report_options = onReportOptions;
 8004fe6:	4b08      	ldr	r3, [pc, #32]	; (8005008 <openpnp_init+0x58>)
 8004fe8:	4a09      	ldr	r2, [pc, #36]	; (8005010 <openpnp_init+0x60>)
 8004fea:	655a      	str	r2, [r3, #84]	; 0x54
}
 8004fec:	bf00      	nop
 8004fee:	46bd      	mov	sp, r7
 8004ff0:	bc90      	pop	{r4, r7}
 8004ff2:	4770      	bx	lr
 8004ff4:	20000584 	.word	0x20000584
 8004ff8:	20000ed0 	.word	0x20000ed0
 8004ffc:	080047e9 	.word	0x080047e9
 8005000:	08004849 	.word	0x08004849
 8005004:	08004d51 	.word	0x08004d51
 8005008:	20000dd4 	.word	0x20000dd4
 800500c:	20000590 	.word	0x20000590
 8005010:	08004f71 	.word	0x08004f71

08005014 <serialClaimPort>:
}

#if SERIAL_PORT || SERIAL1_PORT

static bool serialClaimPort (uint8_t instance)
{
 8005014:	b480      	push	{r7}
 8005016:	b085      	sub	sp, #20
 8005018:	af00      	add	r7, sp, #0
 800501a:	4603      	mov	r3, r0
 800501c:	71fb      	strb	r3, [r7, #7]
    bool ok = false;
 800501e:	2300      	movs	r3, #0
 8005020:	73fb      	strb	r3, [r7, #15]
    uint_fast8_t idx = sizeof(serial) / sizeof(io_stream_properties_t);
 8005022:	2301      	movs	r3, #1
 8005024:	60bb      	str	r3, [r7, #8]

    do {
        if(serial[--idx].instance == instance) {
 8005026:	68bb      	ldr	r3, [r7, #8]
 8005028:	3b01      	subs	r3, #1
 800502a:	60bb      	str	r3, [r7, #8]
 800502c:	4a1d      	ldr	r2, [pc, #116]	; (80050a4 <serialClaimPort+0x90>)
 800502e:	68bb      	ldr	r3, [r7, #8]
 8005030:	00db      	lsls	r3, r3, #3
 8005032:	4413      	add	r3, r2
 8005034:	785b      	ldrb	r3, [r3, #1]
 8005036:	79fa      	ldrb	r2, [r7, #7]
 8005038:	429a      	cmp	r2, r3
 800503a:	d127      	bne.n	800508c <serialClaimPort+0x78>
            if((ok = serial[idx].flags.claimable && !serial[idx].flags.claimed))
 800503c:	4a19      	ldr	r2, [pc, #100]	; (80050a4 <serialClaimPort+0x90>)
 800503e:	68bb      	ldr	r3, [r7, #8]
 8005040:	00db      	lsls	r3, r3, #3
 8005042:	4413      	add	r3, r2
 8005044:	789b      	ldrb	r3, [r3, #2]
 8005046:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800504a:	b2db      	uxtb	r3, r3
 800504c:	2b00      	cmp	r3, #0
 800504e:	d00b      	beq.n	8005068 <serialClaimPort+0x54>
 8005050:	4a14      	ldr	r2, [pc, #80]	; (80050a4 <serialClaimPort+0x90>)
 8005052:	68bb      	ldr	r3, [r7, #8]
 8005054:	00db      	lsls	r3, r3, #3
 8005056:	4413      	add	r3, r2
 8005058:	789b      	ldrb	r3, [r3, #2]
 800505a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800505e:	b2db      	uxtb	r3, r3
 8005060:	2b00      	cmp	r3, #0
 8005062:	d101      	bne.n	8005068 <serialClaimPort+0x54>
 8005064:	2301      	movs	r3, #1
 8005066:	e000      	b.n	800506a <serialClaimPort+0x56>
 8005068:	2300      	movs	r3, #0
 800506a:	73fb      	strb	r3, [r7, #15]
 800506c:	7bfb      	ldrb	r3, [r7, #15]
 800506e:	f003 0301 	and.w	r3, r3, #1
 8005072:	73fb      	strb	r3, [r7, #15]
 8005074:	7bfb      	ldrb	r3, [r7, #15]
 8005076:	2b00      	cmp	r3, #0
 8005078:	d00c      	beq.n	8005094 <serialClaimPort+0x80>
                serial[idx].flags.claimed = On;
 800507a:	4a0a      	ldr	r2, [pc, #40]	; (80050a4 <serialClaimPort+0x90>)
 800507c:	68bb      	ldr	r3, [r7, #8]
 800507e:	00db      	lsls	r3, r3, #3
 8005080:	4413      	add	r3, r2
 8005082:	789a      	ldrb	r2, [r3, #2]
 8005084:	f042 0204 	orr.w	r2, r2, #4
 8005088:	709a      	strb	r2, [r3, #2]
            break;
 800508a:	e003      	b.n	8005094 <serialClaimPort+0x80>
        }

    } while(idx);
 800508c:	68bb      	ldr	r3, [r7, #8]
 800508e:	2b00      	cmp	r3, #0
 8005090:	d1c9      	bne.n	8005026 <serialClaimPort+0x12>
 8005092:	e000      	b.n	8005096 <serialClaimPort+0x82>
            break;
 8005094:	bf00      	nop

    return ok;
 8005096:	7bfb      	ldrb	r3, [r7, #15]
}
 8005098:	4618      	mov	r0, r3
 800509a:	3714      	adds	r7, #20
 800509c:	46bd      	mov	sp, r7
 800509e:	bc80      	pop	{r7}
 80050a0:	4770      	bx	lr
 80050a2:	bf00      	nop
 80050a4:	20000228 	.word	0x20000228

080050a8 <serialRxFree>:

//
// Returns number of free characters in serial input buffer
//
static uint16_t serialRxFree (void)
{
 80050a8:	b480      	push	{r7}
 80050aa:	b083      	sub	sp, #12
 80050ac:	af00      	add	r7, sp, #0
    uint16_t tail = rxbuf.tail, head = rxbuf.head;
 80050ae:	4b0d      	ldr	r3, [pc, #52]	; (80050e4 <serialRxFree+0x3c>)
 80050b0:	685b      	ldr	r3, [r3, #4]
 80050b2:	80fb      	strh	r3, [r7, #6]
 80050b4:	4b0b      	ldr	r3, [pc, #44]	; (80050e4 <serialRxFree+0x3c>)
 80050b6:	681b      	ldr	r3, [r3, #0]
 80050b8:	80bb      	strh	r3, [r7, #4]

    return RX_BUFFER_SIZE - BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 80050ba:	88ba      	ldrh	r2, [r7, #4]
 80050bc:	88fb      	ldrh	r3, [r7, #6]
 80050be:	429a      	cmp	r2, r3
 80050c0:	d307      	bcc.n	80050d2 <serialRxFree+0x2a>
 80050c2:	88fa      	ldrh	r2, [r7, #6]
 80050c4:	88bb      	ldrh	r3, [r7, #4]
 80050c6:	1ad3      	subs	r3, r2, r3
 80050c8:	b29b      	uxth	r3, r3
 80050ca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80050ce:	b29b      	uxth	r3, r3
 80050d0:	e003      	b.n	80050da <serialRxFree+0x32>
 80050d2:	88fa      	ldrh	r2, [r7, #6]
 80050d4:	88bb      	ldrh	r3, [r7, #4]
 80050d6:	1ad3      	subs	r3, r2, r3
 80050d8:	b29b      	uxth	r3, r3
}
 80050da:	4618      	mov	r0, r3
 80050dc:	370c      	adds	r7, #12
 80050de:	46bd      	mov	sp, r7
 80050e0:	bc80      	pop	{r7}
 80050e2:	4770      	bx	lr
 80050e4:	20000598 	.word	0x20000598

080050e8 <serialRxCount>:

//
// Returns number of characters in serial input buffer
//
static uint16_t serialRxCount (void)
{
 80050e8:	b480      	push	{r7}
 80050ea:	b083      	sub	sp, #12
 80050ec:	af00      	add	r7, sp, #0
    uint32_t tail = rxbuf.tail, head = rxbuf.head;
 80050ee:	4b0f      	ldr	r3, [pc, #60]	; (800512c <serialRxCount+0x44>)
 80050f0:	685b      	ldr	r3, [r3, #4]
 80050f2:	607b      	str	r3, [r7, #4]
 80050f4:	4b0d      	ldr	r3, [pc, #52]	; (800512c <serialRxCount+0x44>)
 80050f6:	681b      	ldr	r3, [r3, #0]
 80050f8:	603b      	str	r3, [r7, #0]

    return BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 80050fa:	683a      	ldr	r2, [r7, #0]
 80050fc:	687b      	ldr	r3, [r7, #4]
 80050fe:	429a      	cmp	r2, r3
 8005100:	d306      	bcc.n	8005110 <serialRxCount+0x28>
 8005102:	683b      	ldr	r3, [r7, #0]
 8005104:	b29a      	uxth	r2, r3
 8005106:	687b      	ldr	r3, [r7, #4]
 8005108:	b29b      	uxth	r3, r3
 800510a:	1ad3      	subs	r3, r2, r3
 800510c:	b29b      	uxth	r3, r3
 800510e:	e008      	b.n	8005122 <serialRxCount+0x3a>
 8005110:	683b      	ldr	r3, [r7, #0]
 8005112:	b29a      	uxth	r2, r3
 8005114:	687b      	ldr	r3, [r7, #4]
 8005116:	b29b      	uxth	r3, r3
 8005118:	1ad3      	subs	r3, r2, r3
 800511a:	b29b      	uxth	r3, r3
 800511c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8005120:	b29b      	uxth	r3, r3
}
 8005122:	4618      	mov	r0, r3
 8005124:	370c      	adds	r7, #12
 8005126:	46bd      	mov	sp, r7
 8005128:	bc80      	pop	{r7}
 800512a:	4770      	bx	lr
 800512c:	20000598 	.word	0x20000598

08005130 <serialRxFlush>:

//
// Flushes the serial input buffer
//
void serialRxFlush (void)
{
 8005130:	b480      	push	{r7}
 8005132:	af00      	add	r7, sp, #0
    rxbuf.tail = rxbuf.head;
 8005134:	4b03      	ldr	r3, [pc, #12]	; (8005144 <serialRxFlush+0x14>)
 8005136:	681b      	ldr	r3, [r3, #0]
 8005138:	4a02      	ldr	r2, [pc, #8]	; (8005144 <serialRxFlush+0x14>)
 800513a:	6053      	str	r3, [r2, #4]
}
 800513c:	bf00      	nop
 800513e:	46bd      	mov	sp, r7
 8005140:	bc80      	pop	{r7}
 8005142:	4770      	bx	lr
 8005144:	20000598 	.word	0x20000598

08005148 <serialRxCancel>:

//
// Flushes and adds a CAN character to the serial input buffer
//
static void serialRxCancel (void)
{
 8005148:	b480      	push	{r7}
 800514a:	af00      	add	r7, sp, #0
    rxbuf.data[rxbuf.head] = ASCII_CAN;
 800514c:	4b0a      	ldr	r3, [pc, #40]	; (8005178 <serialRxCancel+0x30>)
 800514e:	681b      	ldr	r3, [r3, #0]
 8005150:	4a09      	ldr	r2, [pc, #36]	; (8005178 <serialRxCancel+0x30>)
 8005152:	4413      	add	r3, r2
 8005154:	2218      	movs	r2, #24
 8005156:	72da      	strb	r2, [r3, #11]
    rxbuf.tail = rxbuf.head;
 8005158:	4b07      	ldr	r3, [pc, #28]	; (8005178 <serialRxCancel+0x30>)
 800515a:	681b      	ldr	r3, [r3, #0]
 800515c:	4a06      	ldr	r2, [pc, #24]	; (8005178 <serialRxCancel+0x30>)
 800515e:	6053      	str	r3, [r2, #4]
    rxbuf.head = BUFNEXT(rxbuf.head, rxbuf);
 8005160:	4b05      	ldr	r3, [pc, #20]	; (8005178 <serialRxCancel+0x30>)
 8005162:	681b      	ldr	r3, [r3, #0]
 8005164:	3301      	adds	r3, #1
 8005166:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800516a:	4a03      	ldr	r2, [pc, #12]	; (8005178 <serialRxCancel+0x30>)
 800516c:	6013      	str	r3, [r2, #0]
}
 800516e:	bf00      	nop
 8005170:	46bd      	mov	sp, r7
 8005172:	bc80      	pop	{r7}
 8005174:	4770      	bx	lr
 8005176:	bf00      	nop
 8005178:	20000598 	.word	0x20000598

0800517c <serialPutC>:

//
// Writes a character to the serial output stream
//
static bool serialPutC (const char c)
{
 800517c:	b580      	push	{r7, lr}
 800517e:	b084      	sub	sp, #16
 8005180:	af00      	add	r7, sp, #0
 8005182:	4603      	mov	r3, r0
 8005184:	71fb      	strb	r3, [r7, #7]
    uint16_t next_head = BUFNEXT(txbuf.head, txbuf);    // Get pointer to next free slot in buffer
 8005186:	4b17      	ldr	r3, [pc, #92]	; (80051e4 <serialPutC+0x68>)
 8005188:	681b      	ldr	r3, [r3, #0]
 800518a:	b29b      	uxth	r3, r3
 800518c:	3301      	adds	r3, #1
 800518e:	b29b      	uxth	r3, r3
 8005190:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005194:	81fb      	strh	r3, [r7, #14]

    while(txbuf.tail == next_head) {                    // While TX buffer full
 8005196:	e00b      	b.n	80051b0 <serialPutC+0x34>
        if(!hal.stream_blocking_callback())             // check if blocking for space,
 8005198:	4b13      	ldr	r3, [pc, #76]	; (80051e8 <serialPutC+0x6c>)
 800519a:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800519e:	4798      	blx	r3
 80051a0:	4603      	mov	r3, r0
 80051a2:	f083 0301 	eor.w	r3, r3, #1
 80051a6:	b2db      	uxtb	r3, r3
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	d001      	beq.n	80051b0 <serialPutC+0x34>
            return false;                               // exit if not (leaves TX buffer in an inconsistent state)
 80051ac:	2300      	movs	r3, #0
 80051ae:	e014      	b.n	80051da <serialPutC+0x5e>
    while(txbuf.tail == next_head) {                    // While TX buffer full
 80051b0:	4b0c      	ldr	r3, [pc, #48]	; (80051e4 <serialPutC+0x68>)
 80051b2:	685a      	ldr	r2, [r3, #4]
 80051b4:	89fb      	ldrh	r3, [r7, #14]
 80051b6:	429a      	cmp	r2, r3
 80051b8:	d0ee      	beq.n	8005198 <serialPutC+0x1c>
    }

    txbuf.data[txbuf.head] = c;                         // Add data to buffer,
 80051ba:	4b0a      	ldr	r3, [pc, #40]	; (80051e4 <serialPutC+0x68>)
 80051bc:	681b      	ldr	r3, [r3, #0]
 80051be:	4a09      	ldr	r2, [pc, #36]	; (80051e4 <serialPutC+0x68>)
 80051c0:	4413      	add	r3, r2
 80051c2:	79fa      	ldrb	r2, [r7, #7]
 80051c4:	721a      	strb	r2, [r3, #8]
    txbuf.head = next_head;                             // update head pointer and
 80051c6:	89fb      	ldrh	r3, [r7, #14]
 80051c8:	4a06      	ldr	r2, [pc, #24]	; (80051e4 <serialPutC+0x68>)
 80051ca:	6013      	str	r3, [r2, #0]
    USART->CR1 |= USART_CR1_TXEIE;                     // enable TX interrupts
 80051cc:	4b07      	ldr	r3, [pc, #28]	; (80051ec <serialPutC+0x70>)
 80051ce:	68db      	ldr	r3, [r3, #12]
 80051d0:	4a06      	ldr	r2, [pc, #24]	; (80051ec <serialPutC+0x70>)
 80051d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80051d6:	60d3      	str	r3, [r2, #12]

    return true;
 80051d8:	2301      	movs	r3, #1
}
 80051da:	4618      	mov	r0, r3
 80051dc:	3710      	adds	r7, #16
 80051de:	46bd      	mov	sp, r7
 80051e0:	bd80      	pop	{r7, pc}
 80051e2:	bf00      	nop
 80051e4:	200009a4 	.word	0x200009a4
 80051e8:	20000ed0 	.word	0x20000ed0
 80051ec:	40013800 	.word	0x40013800

080051f0 <serialWriteS>:

//
// Writes a null terminated string to the serial output stream, blocks if buffer full
//
static void serialWriteS (const char *s)
{
 80051f0:	b580      	push	{r7, lr}
 80051f2:	b084      	sub	sp, #16
 80051f4:	af00      	add	r7, sp, #0
 80051f6:	6078      	str	r0, [r7, #4]
    char c, *ptr = (char *)s;
 80051f8:	687b      	ldr	r3, [r7, #4]
 80051fa:	60fb      	str	r3, [r7, #12]

    while((c = *ptr++) != '\0')
 80051fc:	e003      	b.n	8005206 <serialWriteS+0x16>
        serialPutC(c);
 80051fe:	7afb      	ldrb	r3, [r7, #11]
 8005200:	4618      	mov	r0, r3
 8005202:	f7ff ffbb 	bl	800517c <serialPutC>
    while((c = *ptr++) != '\0')
 8005206:	68fb      	ldr	r3, [r7, #12]
 8005208:	1c5a      	adds	r2, r3, #1
 800520a:	60fa      	str	r2, [r7, #12]
 800520c:	781b      	ldrb	r3, [r3, #0]
 800520e:	72fb      	strb	r3, [r7, #11]
 8005210:	7afb      	ldrb	r3, [r7, #11]
 8005212:	2b00      	cmp	r3, #0
 8005214:	d1f3      	bne.n	80051fe <serialWriteS+0xe>
}
 8005216:	bf00      	nop
 8005218:	bf00      	nop
 800521a:	3710      	adds	r7, #16
 800521c:	46bd      	mov	sp, r7
 800521e:	bd80      	pop	{r7, pc}

08005220 <serialWrite>:
//
// Writes a number of characters from string to the serial output stream followed by EOL, blocks if buffer full
//

static void serialWrite(const char *s, uint16_t length)
{
 8005220:	b580      	push	{r7, lr}
 8005222:	b084      	sub	sp, #16
 8005224:	af00      	add	r7, sp, #0
 8005226:	6078      	str	r0, [r7, #4]
 8005228:	460b      	mov	r3, r1
 800522a:	807b      	strh	r3, [r7, #2]
    char *ptr = (char *)s;
 800522c:	687b      	ldr	r3, [r7, #4]
 800522e:	60fb      	str	r3, [r7, #12]

    while(length--)
 8005230:	e006      	b.n	8005240 <serialWrite+0x20>
        serialPutC(*ptr++);
 8005232:	68fb      	ldr	r3, [r7, #12]
 8005234:	1c5a      	adds	r2, r3, #1
 8005236:	60fa      	str	r2, [r7, #12]
 8005238:	781b      	ldrb	r3, [r3, #0]
 800523a:	4618      	mov	r0, r3
 800523c:	f7ff ff9e 	bl	800517c <serialPutC>
    while(length--)
 8005240:	887b      	ldrh	r3, [r7, #2]
 8005242:	1e5a      	subs	r2, r3, #1
 8005244:	807a      	strh	r2, [r7, #2]
 8005246:	2b00      	cmp	r3, #0
 8005248:	d1f3      	bne.n	8005232 <serialWrite+0x12>
}
 800524a:	bf00      	nop
 800524c:	bf00      	nop
 800524e:	3710      	adds	r7, #16
 8005250:	46bd      	mov	sp, r7
 8005252:	bd80      	pop	{r7, pc}

08005254 <serialTxFlush>:

//
// Flushes the serial output buffer
//
static void serialTxFlush (void)
{
 8005254:	b480      	push	{r7}
 8005256:	af00      	add	r7, sp, #0
    USART->CR1 &= ~USART_CR1_TXEIE;     // Disable TX interrupts
 8005258:	4b06      	ldr	r3, [pc, #24]	; (8005274 <serialTxFlush+0x20>)
 800525a:	68db      	ldr	r3, [r3, #12]
 800525c:	4a05      	ldr	r2, [pc, #20]	; (8005274 <serialTxFlush+0x20>)
 800525e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005262:	60d3      	str	r3, [r2, #12]
    txbuf.tail = txbuf.head;
 8005264:	4b04      	ldr	r3, [pc, #16]	; (8005278 <serialTxFlush+0x24>)
 8005266:	681b      	ldr	r3, [r3, #0]
 8005268:	4a03      	ldr	r2, [pc, #12]	; (8005278 <serialTxFlush+0x24>)
 800526a:	6053      	str	r3, [r2, #4]
}
 800526c:	bf00      	nop
 800526e:	46bd      	mov	sp, r7
 8005270:	bc80      	pop	{r7}
 8005272:	4770      	bx	lr
 8005274:	40013800 	.word	0x40013800
 8005278:	200009a4 	.word	0x200009a4

0800527c <serialTxCount>:

//
// Returns number of characters pending transmission
//
static uint16_t serialTxCount (void)
{
 800527c:	b480      	push	{r7}
 800527e:	b083      	sub	sp, #12
 8005280:	af00      	add	r7, sp, #0
    uint32_t tail = txbuf.tail, head = txbuf.head;
 8005282:	4b15      	ldr	r3, [pc, #84]	; (80052d8 <serialTxCount+0x5c>)
 8005284:	685b      	ldr	r3, [r3, #4]
 8005286:	607b      	str	r3, [r7, #4]
 8005288:	4b13      	ldr	r3, [pc, #76]	; (80052d8 <serialTxCount+0x5c>)
 800528a:	681b      	ldr	r3, [r3, #0]
 800528c:	603b      	str	r3, [r7, #0]

    return BUFCOUNT(head, tail, TX_BUFFER_SIZE) + (USART->SR & USART_SR_TC ? 0 : 1);
 800528e:	683a      	ldr	r2, [r7, #0]
 8005290:	687b      	ldr	r3, [r7, #4]
 8005292:	429a      	cmp	r2, r3
 8005294:	d306      	bcc.n	80052a4 <serialTxCount+0x28>
 8005296:	683b      	ldr	r3, [r7, #0]
 8005298:	b29a      	uxth	r2, r3
 800529a:	687b      	ldr	r3, [r7, #4]
 800529c:	b29b      	uxth	r3, r3
 800529e:	1ad3      	subs	r3, r2, r3
 80052a0:	b29b      	uxth	r3, r3
 80052a2:	e008      	b.n	80052b6 <serialTxCount+0x3a>
 80052a4:	683b      	ldr	r3, [r7, #0]
 80052a6:	b29a      	uxth	r2, r3
 80052a8:	687b      	ldr	r3, [r7, #4]
 80052aa:	b29b      	uxth	r3, r3
 80052ac:	1ad3      	subs	r3, r2, r3
 80052ae:	b29b      	uxth	r3, r3
 80052b0:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80052b4:	b29b      	uxth	r3, r3
 80052b6:	4a09      	ldr	r2, [pc, #36]	; (80052dc <serialTxCount+0x60>)
 80052b8:	6812      	ldr	r2, [r2, #0]
 80052ba:	f002 0240 	and.w	r2, r2, #64	; 0x40
 80052be:	2a00      	cmp	r2, #0
 80052c0:	bf0c      	ite	eq
 80052c2:	2201      	moveq	r2, #1
 80052c4:	2200      	movne	r2, #0
 80052c6:	b2d2      	uxtb	r2, r2
 80052c8:	b292      	uxth	r2, r2
 80052ca:	4413      	add	r3, r2
 80052cc:	b29b      	uxth	r3, r3
}
 80052ce:	4618      	mov	r0, r3
 80052d0:	370c      	adds	r7, #12
 80052d2:	46bd      	mov	sp, r7
 80052d4:	bc80      	pop	{r7}
 80052d6:	4770      	bx	lr
 80052d8:	200009a4 	.word	0x200009a4
 80052dc:	40013800 	.word	0x40013800

080052e0 <serialGetC>:

//
// serialGetC - returns -1 if no data available
//
static int16_t serialGetC (void)
{
 80052e0:	b480      	push	{r7}
 80052e2:	b083      	sub	sp, #12
 80052e4:	af00      	add	r7, sp, #0
    uint_fast16_t tail = rxbuf.tail;    // Get buffer pointer
 80052e6:	4b0f      	ldr	r3, [pc, #60]	; (8005324 <serialGetC+0x44>)
 80052e8:	685b      	ldr	r3, [r3, #4]
 80052ea:	607b      	str	r3, [r7, #4]

    if(tail == rxbuf.head)
 80052ec:	4b0d      	ldr	r3, [pc, #52]	; (8005324 <serialGetC+0x44>)
 80052ee:	681b      	ldr	r3, [r3, #0]
 80052f0:	687a      	ldr	r2, [r7, #4]
 80052f2:	429a      	cmp	r2, r3
 80052f4:	d102      	bne.n	80052fc <serialGetC+0x1c>
        return -1; // no data available
 80052f6:	f04f 33ff 	mov.w	r3, #4294967295
 80052fa:	e00d      	b.n	8005318 <serialGetC+0x38>

    char data = rxbuf.data[tail];       // Get next character
 80052fc:	4a09      	ldr	r2, [pc, #36]	; (8005324 <serialGetC+0x44>)
 80052fe:	687b      	ldr	r3, [r7, #4]
 8005300:	4413      	add	r3, r2
 8005302:	330b      	adds	r3, #11
 8005304:	781b      	ldrb	r3, [r3, #0]
 8005306:	70fb      	strb	r3, [r7, #3]
    rxbuf.tail = BUFNEXT(tail, rxbuf);  // and update pointer
 8005308:	687b      	ldr	r3, [r7, #4]
 800530a:	3301      	adds	r3, #1
 800530c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8005310:	4a04      	ldr	r2, [pc, #16]	; (8005324 <serialGetC+0x44>)
 8005312:	6053      	str	r3, [r2, #4]

    return (int16_t)data;
 8005314:	78fb      	ldrb	r3, [r7, #3]
 8005316:	b21b      	sxth	r3, r3
}
 8005318:	4618      	mov	r0, r3
 800531a:	370c      	adds	r7, #12
 800531c:	46bd      	mov	sp, r7
 800531e:	bc80      	pop	{r7}
 8005320:	4770      	bx	lr
 8005322:	bf00      	nop
 8005324:	20000598 	.word	0x20000598

08005328 <serialSuspendInput>:

static bool serialSuspendInput (bool suspend)
{
 8005328:	b580      	push	{r7, lr}
 800532a:	b082      	sub	sp, #8
 800532c:	af00      	add	r7, sp, #0
 800532e:	4603      	mov	r3, r0
 8005330:	71fb      	strb	r3, [r7, #7]
    return stream_rx_suspend(&rxbuf, suspend);
 8005332:	79fb      	ldrb	r3, [r7, #7]
 8005334:	4619      	mov	r1, r3
 8005336:	4804      	ldr	r0, [pc, #16]	; (8005348 <serialSuspendInput+0x20>)
 8005338:	f01a ff6a 	bl	8020210 <stream_rx_suspend>
 800533c:	4603      	mov	r3, r0
}
 800533e:	4618      	mov	r0, r3
 8005340:	3708      	adds	r7, #8
 8005342:	46bd      	mov	sp, r7
 8005344:	bd80      	pop	{r7, pc}
 8005346:	bf00      	nop
 8005348:	20000598 	.word	0x20000598

0800534c <serialSetBaudRate>:

static bool serialSetBaudRate (uint32_t baud_rate)
{
 800534c:	b5b0      	push	{r4, r5, r7, lr}
 800534e:	b082      	sub	sp, #8
 8005350:	af00      	add	r7, sp, #0
 8005352:	6078      	str	r0, [r7, #4]
    USART->CR1 = USART_CR1_RE|USART_CR1_TE;
 8005354:	4b3a      	ldr	r3, [pc, #232]	; (8005440 <serialSetBaudRate+0xf4>)
 8005356:	220c      	movs	r2, #12
 8005358:	60da      	str	r2, [r3, #12]
    USART->BRR = UART_BRR_SAMPLING16(USART_CLK(), baud_rate);
 800535a:	f7fd f909 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 800535e:	4602      	mov	r2, r0
 8005360:	4613      	mov	r3, r2
 8005362:	009b      	lsls	r3, r3, #2
 8005364:	4413      	add	r3, r2
 8005366:	009a      	lsls	r2, r3, #2
 8005368:	441a      	add	r2, r3
 800536a:	687b      	ldr	r3, [r7, #4]
 800536c:	009b      	lsls	r3, r3, #2
 800536e:	fbb2 f3f3 	udiv	r3, r2, r3
 8005372:	4a34      	ldr	r2, [pc, #208]	; (8005444 <serialSetBaudRate+0xf8>)
 8005374:	fba2 2303 	umull	r2, r3, r2, r3
 8005378:	095b      	lsrs	r3, r3, #5
 800537a:	011c      	lsls	r4, r3, #4
 800537c:	f7fd f8f8 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 8005380:	4602      	mov	r2, r0
 8005382:	4613      	mov	r3, r2
 8005384:	009b      	lsls	r3, r3, #2
 8005386:	4413      	add	r3, r2
 8005388:	009a      	lsls	r2, r3, #2
 800538a:	441a      	add	r2, r3
 800538c:	687b      	ldr	r3, [r7, #4]
 800538e:	009b      	lsls	r3, r3, #2
 8005390:	fbb2 f5f3 	udiv	r5, r2, r3
 8005394:	f7fd f8ec 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 8005398:	4602      	mov	r2, r0
 800539a:	4613      	mov	r3, r2
 800539c:	009b      	lsls	r3, r3, #2
 800539e:	4413      	add	r3, r2
 80053a0:	009a      	lsls	r2, r3, #2
 80053a2:	441a      	add	r2, r3
 80053a4:	687b      	ldr	r3, [r7, #4]
 80053a6:	009b      	lsls	r3, r3, #2
 80053a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80053ac:	4a25      	ldr	r2, [pc, #148]	; (8005444 <serialSetBaudRate+0xf8>)
 80053ae:	fba2 2303 	umull	r2, r3, r2, r3
 80053b2:	095b      	lsrs	r3, r3, #5
 80053b4:	2264      	movs	r2, #100	; 0x64
 80053b6:	fb02 f303 	mul.w	r3, r2, r3
 80053ba:	1aeb      	subs	r3, r5, r3
 80053bc:	011b      	lsls	r3, r3, #4
 80053be:	3332      	adds	r3, #50	; 0x32
 80053c0:	4a20      	ldr	r2, [pc, #128]	; (8005444 <serialSetBaudRate+0xf8>)
 80053c2:	fba2 2303 	umull	r2, r3, r2, r3
 80053c6:	095b      	lsrs	r3, r3, #5
 80053c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80053cc:	441c      	add	r4, r3
 80053ce:	f7fd f8cf 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 80053d2:	4602      	mov	r2, r0
 80053d4:	4613      	mov	r3, r2
 80053d6:	009b      	lsls	r3, r3, #2
 80053d8:	4413      	add	r3, r2
 80053da:	009a      	lsls	r2, r3, #2
 80053dc:	441a      	add	r2, r3
 80053de:	687b      	ldr	r3, [r7, #4]
 80053e0:	009b      	lsls	r3, r3, #2
 80053e2:	fbb2 f5f3 	udiv	r5, r2, r3
 80053e6:	f7fd f8c3 	bl	8002570 <HAL_RCC_GetPCLK2Freq>
 80053ea:	4602      	mov	r2, r0
 80053ec:	4613      	mov	r3, r2
 80053ee:	009b      	lsls	r3, r3, #2
 80053f0:	4413      	add	r3, r2
 80053f2:	009a      	lsls	r2, r3, #2
 80053f4:	441a      	add	r2, r3
 80053f6:	687b      	ldr	r3, [r7, #4]
 80053f8:	009b      	lsls	r3, r3, #2
 80053fa:	fbb2 f3f3 	udiv	r3, r2, r3
 80053fe:	4a11      	ldr	r2, [pc, #68]	; (8005444 <serialSetBaudRate+0xf8>)
 8005400:	fba2 2303 	umull	r2, r3, r2, r3
 8005404:	095b      	lsrs	r3, r3, #5
 8005406:	2264      	movs	r2, #100	; 0x64
 8005408:	fb02 f303 	mul.w	r3, r2, r3
 800540c:	1aeb      	subs	r3, r5, r3
 800540e:	011b      	lsls	r3, r3, #4
 8005410:	3332      	adds	r3, #50	; 0x32
 8005412:	4a0c      	ldr	r2, [pc, #48]	; (8005444 <serialSetBaudRate+0xf8>)
 8005414:	fba2 2303 	umull	r2, r3, r2, r3
 8005418:	095b      	lsrs	r3, r3, #5
 800541a:	f003 030f 	and.w	r3, r3, #15
 800541e:	4a08      	ldr	r2, [pc, #32]	; (8005440 <serialSetBaudRate+0xf4>)
 8005420:	4423      	add	r3, r4
 8005422:	6093      	str	r3, [r2, #8]
    USART->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 8005424:	4b06      	ldr	r3, [pc, #24]	; (8005440 <serialSetBaudRate+0xf4>)
 8005426:	68db      	ldr	r3, [r3, #12]
 8005428:	4a05      	ldr	r2, [pc, #20]	; (8005440 <serialSetBaudRate+0xf4>)
 800542a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800542e:	f043 0320 	orr.w	r3, r3, #32
 8005432:	60d3      	str	r3, [r2, #12]

    return true;
 8005434:	2301      	movs	r3, #1
}
 8005436:	4618      	mov	r0, r3
 8005438:	3708      	adds	r7, #8
 800543a:	46bd      	mov	sp, r7
 800543c:	bdb0      	pop	{r4, r5, r7, pc}
 800543e:	bf00      	nop
 8005440:	40013800 	.word	0x40013800
 8005444:	51eb851f 	.word	0x51eb851f

08005448 <serialDisable>:

static bool serialDisable (bool disable)
{
 8005448:	b480      	push	{r7}
 800544a:	b083      	sub	sp, #12
 800544c:	af00      	add	r7, sp, #0
 800544e:	4603      	mov	r3, r0
 8005450:	71fb      	strb	r3, [r7, #7]
    if(disable)
 8005452:	79fb      	ldrb	r3, [r7, #7]
 8005454:	2b00      	cmp	r3, #0
 8005456:	d006      	beq.n	8005466 <serialDisable+0x1e>
        USART->CR1 &= ~USART_CR1_RXNEIE;
 8005458:	4b09      	ldr	r3, [pc, #36]	; (8005480 <serialDisable+0x38>)
 800545a:	68db      	ldr	r3, [r3, #12]
 800545c:	4a08      	ldr	r2, [pc, #32]	; (8005480 <serialDisable+0x38>)
 800545e:	f023 0320 	bic.w	r3, r3, #32
 8005462:	60d3      	str	r3, [r2, #12]
 8005464:	e005      	b.n	8005472 <serialDisable+0x2a>
    else
        USART->CR1 |= USART_CR1_RXNEIE;
 8005466:	4b06      	ldr	r3, [pc, #24]	; (8005480 <serialDisable+0x38>)
 8005468:	68db      	ldr	r3, [r3, #12]
 800546a:	4a05      	ldr	r2, [pc, #20]	; (8005480 <serialDisable+0x38>)
 800546c:	f043 0320 	orr.w	r3, r3, #32
 8005470:	60d3      	str	r3, [r2, #12]

    return true;
 8005472:	2301      	movs	r3, #1
}
 8005474:	4618      	mov	r0, r3
 8005476:	370c      	adds	r7, #12
 8005478:	46bd      	mov	sp, r7
 800547a:	bc80      	pop	{r7}
 800547c:	4770      	bx	lr
 800547e:	bf00      	nop
 8005480:	40013800 	.word	0x40013800

08005484 <serialEnqueueRtCommand>:

static bool serialEnqueueRtCommand (char c)
{
 8005484:	b580      	push	{r7, lr}
 8005486:	b082      	sub	sp, #8
 8005488:	af00      	add	r7, sp, #0
 800548a:	4603      	mov	r3, r0
 800548c:	71fb      	strb	r3, [r7, #7]
    return enqueue_realtime_command(c);
 800548e:	4b05      	ldr	r3, [pc, #20]	; (80054a4 <serialEnqueueRtCommand+0x20>)
 8005490:	681b      	ldr	r3, [r3, #0]
 8005492:	79fa      	ldrb	r2, [r7, #7]
 8005494:	4610      	mov	r0, r2
 8005496:	4798      	blx	r3
 8005498:	4603      	mov	r3, r0
}
 800549a:	4618      	mov	r0, r3
 800549c:	3708      	adds	r7, #8
 800549e:	46bd      	mov	sp, r7
 80054a0:	bd80      	pop	{r7, pc}
 80054a2:	bf00      	nop
 80054a4:	20000224 	.word	0x20000224

080054a8 <serialSetRtHandler>:

static enqueue_realtime_command_ptr serialSetRtHandler (enqueue_realtime_command_ptr handler)
{
 80054a8:	b480      	push	{r7}
 80054aa:	b085      	sub	sp, #20
 80054ac:	af00      	add	r7, sp, #0
 80054ae:	6078      	str	r0, [r7, #4]
    enqueue_realtime_command_ptr prev = enqueue_realtime_command;
 80054b0:	4b07      	ldr	r3, [pc, #28]	; (80054d0 <serialSetRtHandler+0x28>)
 80054b2:	681b      	ldr	r3, [r3, #0]
 80054b4:	60fb      	str	r3, [r7, #12]

    if(handler)
 80054b6:	687b      	ldr	r3, [r7, #4]
 80054b8:	2b00      	cmp	r3, #0
 80054ba:	d002      	beq.n	80054c2 <serialSetRtHandler+0x1a>
        enqueue_realtime_command = handler;
 80054bc:	4a04      	ldr	r2, [pc, #16]	; (80054d0 <serialSetRtHandler+0x28>)
 80054be:	687b      	ldr	r3, [r7, #4]
 80054c0:	6013      	str	r3, [r2, #0]

    return prev;
 80054c2:	68fb      	ldr	r3, [r7, #12]
}
 80054c4:	4618      	mov	r0, r3
 80054c6:	3714      	adds	r7, #20
 80054c8:	46bd      	mov	sp, r7
 80054ca:	bc80      	pop	{r7}
 80054cc:	4770      	bx	lr
 80054ce:	bf00      	nop
 80054d0:	20000224 	.word	0x20000224

080054d4 <serialInit>:

#ifndef STM32F103xE
static
#endif
const io_stream_t *serialInit (uint32_t baud_rate)
{
 80054d4:	b580      	push	{r7, lr}
 80054d6:	b088      	sub	sp, #32
 80054d8:	af00      	add	r7, sp, #0
 80054da:	6078      	str	r0, [r7, #4]
        .set_baud_rate = serialSetBaudRate,
        .suspend_read = serialSuspendInput,
        .set_enqueue_rt_handler = serialSetRtHandler
    };

    if(!serialClaimPort(stream.instance))
 80054dc:	4b24      	ldr	r3, [pc, #144]	; (8005570 <serialInit+0x9c>)
 80054de:	785b      	ldrb	r3, [r3, #1]
 80054e0:	4618      	mov	r0, r3
 80054e2:	f7ff fd97 	bl	8005014 <serialClaimPort>
 80054e6:	4603      	mov	r3, r0
 80054e8:	f083 0301 	eor.w	r3, r3, #1
 80054ec:	b2db      	uxtb	r3, r3
 80054ee:	2b00      	cmp	r3, #0
 80054f0:	d001      	beq.n	80054f6 <serialInit+0x22>
        return NULL;
 80054f2:	2300      	movs	r3, #0
 80054f4:	e038      	b.n	8005568 <serialInit+0x94>

    USART_CLK_ENABLE();
 80054f6:	4b1f      	ldr	r3, [pc, #124]	; (8005574 <serialInit+0xa0>)
 80054f8:	699b      	ldr	r3, [r3, #24]
 80054fa:	4a1e      	ldr	r2, [pc, #120]	; (8005574 <serialInit+0xa0>)
 80054fc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005500:	6193      	str	r3, [r2, #24]
 8005502:	4b1c      	ldr	r3, [pc, #112]	; (8005574 <serialInit+0xa0>)
 8005504:	699b      	ldr	r3, [r3, #24]
 8005506:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800550a:	60fb      	str	r3, [r7, #12]
 800550c:	68fb      	ldr	r3, [r7, #12]

    GPIO_InitTypeDef GPIO_InitStructure = {
 800550e:	f107 0310 	add.w	r3, r7, #16
 8005512:	2200      	movs	r2, #0
 8005514:	601a      	str	r2, [r3, #0]
 8005516:	605a      	str	r2, [r3, #4]
 8005518:	609a      	str	r2, [r3, #8]
 800551a:	60da      	str	r2, [r3, #12]
 800551c:	2302      	movs	r3, #2
 800551e:	617b      	str	r3, [r7, #20]
 8005520:	2303      	movs	r3, #3
 8005522:	61fb      	str	r3, [r7, #28]
        .Speed = GPIO_SPEED_FREQ_HIGH
    };

#if SERIAL_PORT == 1

    GPIO_InitStructure.Pin = GPIO_PIN_9;
 8005524:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005528:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 800552a:	f107 0310 	add.w	r3, r7, #16
 800552e:	4619      	mov	r1, r3
 8005530:	4811      	ldr	r0, [pc, #68]	; (8005578 <serialInit+0xa4>)
 8005532:	f7fc fa89 	bl	8001a48 <HAL_GPIO_Init>

    GPIO_InitStructure.Pin = GPIO_PIN_10;
 8005536:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800553a:	613b      	str	r3, [r7, #16]
    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
 800553c:	2300      	movs	r3, #0
 800553e:	617b      	str	r3, [r7, #20]
    GPIO_InitStructure.Pull = GPIO_NOPULL;
 8005540:	2300      	movs	r3, #0
 8005542:	61bb      	str	r3, [r7, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005544:	f107 0310 	add.w	r3, r7, #16
 8005548:	4619      	mov	r1, r3
 800554a:	480b      	ldr	r0, [pc, #44]	; (8005578 <serialInit+0xa4>)
 800554c:	f7fc fa7c 	bl	8001a48 <HAL_GPIO_Init>
    GPIO_InitStructure.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);

#endif

    serialSetBaudRate(baud_rate);
 8005550:	6878      	ldr	r0, [r7, #4]
 8005552:	f7ff fefb 	bl	800534c <serialSetBaudRate>

    HAL_NVIC_SetPriority(USART_IRQ, 0, 0);
 8005556:	2200      	movs	r2, #0
 8005558:	2100      	movs	r1, #0
 800555a:	2025      	movs	r0, #37	; 0x25
 800555c:	f7fc fa2f 	bl	80019be <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART_IRQ);
 8005560:	2025      	movs	r0, #37	; 0x25
 8005562:	f7fc fa48 	bl	80019f6 <HAL_NVIC_EnableIRQ>

    return &stream;
 8005566:	4b02      	ldr	r3, [pc, #8]	; (8005570 <serialInit+0x9c>)
}
 8005568:	4618      	mov	r0, r3
 800556a:	3720      	adds	r7, #32
 800556c:	46bd      	mov	sp, r7
 800556e:	bd80      	pop	{r7, pc}
 8005570:	080309b8 	.word	0x080309b8
 8005574:	40021000 	.word	0x40021000
 8005578:	40010800 	.word	0x40010800

0800557c <USART1_IRQHandler>:

void USART_IRQHandler (void)
{
 800557c:	b580      	push	{r7, lr}
 800557e:	b082      	sub	sp, #8
 8005580:	af00      	add	r7, sp, #0
    if(USART->SR & USART_SR_RXNE) {
 8005582:	4b2d      	ldr	r3, [pc, #180]	; (8005638 <USART1_IRQHandler+0xbc>)
 8005584:	681b      	ldr	r3, [r3, #0]
 8005586:	f003 0320 	and.w	r3, r3, #32
 800558a:	2b00      	cmp	r3, #0
 800558c:	d027      	beq.n	80055de <USART1_IRQHandler+0x62>
        char data = USART->DR;
 800558e:	4b2a      	ldr	r3, [pc, #168]	; (8005638 <USART1_IRQHandler+0xbc>)
 8005590:	685b      	ldr	r3, [r3, #4]
 8005592:	71fb      	strb	r3, [r7, #7]
        if(!enqueue_realtime_command(data)) {                   // Check and strip realtime commands...
 8005594:	4b29      	ldr	r3, [pc, #164]	; (800563c <USART1_IRQHandler+0xc0>)
 8005596:	681b      	ldr	r3, [r3, #0]
 8005598:	79fa      	ldrb	r2, [r7, #7]
 800559a:	4610      	mov	r0, r2
 800559c:	4798      	blx	r3
 800559e:	4603      	mov	r3, r0
 80055a0:	f083 0301 	eor.w	r3, r3, #1
 80055a4:	b2db      	uxtb	r3, r3
 80055a6:	2b00      	cmp	r3, #0
 80055a8:	d019      	beq.n	80055de <USART1_IRQHandler+0x62>
            uint16_t next_head = BUFNEXT(rxbuf.head, rxbuf);    // Get and increment buffer pointer
 80055aa:	4b25      	ldr	r3, [pc, #148]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055ac:	681b      	ldr	r3, [r3, #0]
 80055ae:	b29b      	uxth	r3, r3
 80055b0:	3301      	adds	r3, #1
 80055b2:	b29b      	uxth	r3, r3
 80055b4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80055b8:	80bb      	strh	r3, [r7, #4]
            if(next_head == rxbuf.tail)                         // If buffer full
 80055ba:	88ba      	ldrh	r2, [r7, #4]
 80055bc:	4b20      	ldr	r3, [pc, #128]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055be:	685b      	ldr	r3, [r3, #4]
 80055c0:	429a      	cmp	r2, r3
 80055c2:	d103      	bne.n	80055cc <USART1_IRQHandler+0x50>
                rxbuf.overflow = 1;                             // flag overflow
 80055c4:	4b1e      	ldr	r3, [pc, #120]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055c6:	2201      	movs	r2, #1
 80055c8:	725a      	strb	r2, [r3, #9]
 80055ca:	e008      	b.n	80055de <USART1_IRQHandler+0x62>
            else {
                rxbuf.data[rxbuf.head] = data;                  // if not add data to buffer
 80055cc:	4b1c      	ldr	r3, [pc, #112]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055ce:	681b      	ldr	r3, [r3, #0]
 80055d0:	4a1b      	ldr	r2, [pc, #108]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055d2:	4413      	add	r3, r2
 80055d4:	79fa      	ldrb	r2, [r7, #7]
 80055d6:	72da      	strb	r2, [r3, #11]
                rxbuf.head = next_head;                         // and update pointer
 80055d8:	88bb      	ldrh	r3, [r7, #4]
 80055da:	4a19      	ldr	r2, [pc, #100]	; (8005640 <USART1_IRQHandler+0xc4>)
 80055dc:	6013      	str	r3, [r2, #0]
            }
        }
    }

    if((USART->SR & USART_SR_TXE) && (USART->CR1 & USART_CR1_TXEIE)) {
 80055de:	4b16      	ldr	r3, [pc, #88]	; (8005638 <USART1_IRQHandler+0xbc>)
 80055e0:	681b      	ldr	r3, [r3, #0]
 80055e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80055e6:	2b00      	cmp	r3, #0
 80055e8:	d022      	beq.n	8005630 <USART1_IRQHandler+0xb4>
 80055ea:	4b13      	ldr	r3, [pc, #76]	; (8005638 <USART1_IRQHandler+0xbc>)
 80055ec:	68db      	ldr	r3, [r3, #12]
 80055ee:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d01c      	beq.n	8005630 <USART1_IRQHandler+0xb4>
        uint_fast16_t tail = txbuf.tail;            // Get buffer pointer
 80055f6:	4b13      	ldr	r3, [pc, #76]	; (8005644 <USART1_IRQHandler+0xc8>)
 80055f8:	685b      	ldr	r3, [r3, #4]
 80055fa:	603b      	str	r3, [r7, #0]
        USART->DR = txbuf.data[tail];               // Send next character
 80055fc:	4a11      	ldr	r2, [pc, #68]	; (8005644 <USART1_IRQHandler+0xc8>)
 80055fe:	683b      	ldr	r3, [r7, #0]
 8005600:	4413      	add	r3, r2
 8005602:	3308      	adds	r3, #8
 8005604:	781a      	ldrb	r2, [r3, #0]
 8005606:	4b0c      	ldr	r3, [pc, #48]	; (8005638 <USART1_IRQHandler+0xbc>)
 8005608:	605a      	str	r2, [r3, #4]
        txbuf.tail = tail = BUFNEXT(tail, txbuf);   // and increment pointer
 800560a:	683b      	ldr	r3, [r7, #0]
 800560c:	3301      	adds	r3, #1
 800560e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005612:	603b      	str	r3, [r7, #0]
 8005614:	4a0b      	ldr	r2, [pc, #44]	; (8005644 <USART1_IRQHandler+0xc8>)
 8005616:	683b      	ldr	r3, [r7, #0]
 8005618:	6053      	str	r3, [r2, #4]
        if(tail == txbuf.head)                      // If buffer empty then
 800561a:	4b0a      	ldr	r3, [pc, #40]	; (8005644 <USART1_IRQHandler+0xc8>)
 800561c:	681b      	ldr	r3, [r3, #0]
 800561e:	683a      	ldr	r2, [r7, #0]
 8005620:	429a      	cmp	r2, r3
 8005622:	d105      	bne.n	8005630 <USART1_IRQHandler+0xb4>
            USART->CR1 &= ~USART_CR1_TXEIE;         // disable UART TX interrupt
 8005624:	4b04      	ldr	r3, [pc, #16]	; (8005638 <USART1_IRQHandler+0xbc>)
 8005626:	68db      	ldr	r3, [r3, #12]
 8005628:	4a03      	ldr	r2, [pc, #12]	; (8005638 <USART1_IRQHandler+0xbc>)
 800562a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800562e:	60d3      	str	r3, [r2, #12]
   }
}
 8005630:	bf00      	nop
 8005632:	3708      	adds	r7, #8
 8005634:	46bd      	mov	sp, r7
 8005636:	bd80      	pop	{r7, pc}
 8005638:	40013800 	.word	0x40013800
 800563c:	20000224 	.word	0x20000224
 8005640:	20000598 	.word	0x20000598
 8005644:	200009a4 	.word	0x200009a4

08005648 <alarms_get_details>:
    alarms->next = details;
    alarms = details;
}

alarm_details_t *alarms_get_details (void)
{
 8005648:	b480      	push	{r7}
 800564a:	af00      	add	r7, sp, #0
    return &details;
 800564c:	4b02      	ldr	r3, [pc, #8]	; (8005658 <alarms_get_details+0x10>)
}
 800564e:	4618      	mov	r0, r3
 8005650:	46bd      	mov	sp, r7
 8005652:	bc80      	pop	{r7}
 8005654:	4770      	bx	lr
 8005656:	bf00      	nop
 8005658:	20000230 	.word	0x20000230

0800565c <coolant_set_state>:
// Main program only. Immediately sets flood coolant running state and also mist coolant,
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state (coolant_state_t mode)
{
 800565c:	b580      	push	{r7, lr}
 800565e:	b082      	sub	sp, #8
 8005660:	af00      	add	r7, sp, #0
 8005662:	7138      	strb	r0, [r7, #4]
    if (!ABORTED) { // Block during abort.
 8005664:	4b0c      	ldr	r3, [pc, #48]	; (8005698 <coolant_set_state+0x3c>)
 8005666:	781b      	ldrb	r3, [r3, #0]
 8005668:	f083 0301 	eor.w	r3, r3, #1
 800566c:	b2db      	uxtb	r3, r3
 800566e:	2b00      	cmp	r3, #0
 8005670:	d00d      	beq.n	800568e <coolant_set_state+0x32>
 8005672:	4b09      	ldr	r3, [pc, #36]	; (8005698 <coolant_set_state+0x3c>)
 8005674:	785b      	ldrb	r3, [r3, #1]
 8005676:	f083 0301 	eor.w	r3, r3, #1
 800567a:	b2db      	uxtb	r3, r3
 800567c:	2b00      	cmp	r3, #0
 800567e:	d006      	beq.n	800568e <coolant_set_state+0x32>
        hal.coolant.set_state(mode);
 8005680:	4b06      	ldr	r3, [pc, #24]	; (800569c <coolant_set_state+0x40>)
 8005682:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005684:	7938      	ldrb	r0, [r7, #4]
 8005686:	4798      	blx	r3
        system_add_rt_report(Report_Coolant); // Set to report change immediately
 8005688:	2020      	movs	r0, #32
 800568a:	f01c fc87 	bl	8021f9c <system_add_rt_report>
    }
}
 800568e:	bf00      	nop
 8005690:	3708      	adds	r7, #8
 8005692:	46bd      	mov	sp, r7
 8005694:	bd80      	pop	{r7, pc}
 8005696:	bf00      	nop
 8005698:	20000d3c 	.word	0x20000d3c
 800569c:	20000ed0 	.word	0x20000ed0

080056a0 <coolant_sync>:

// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails
// if an abort or check-mode is active.
bool coolant_sync (coolant_state_t mode)
{
 80056a0:	b580      	push	{r7, lr}
 80056a2:	b084      	sub	sp, #16
 80056a4:	af00      	add	r7, sp, #0
 80056a6:	7138      	strb	r0, [r7, #4]
    bool ok = true;
 80056a8:	2301      	movs	r3, #1
 80056aa:	73fb      	strb	r3, [r7, #15]
    if (state_get() != STATE_CHECK_MODE) {
 80056ac:	f018 f908 	bl	801d8c0 <state_get>
 80056b0:	4603      	mov	r3, r0
 80056b2:	2b02      	cmp	r3, #2
 80056b4:	d009      	beq.n	80056ca <coolant_sync+0x2a>
        if((ok = protocol_buffer_synchronize())) // Ensure coolant changes state when specified in program.
 80056b6:	f00d fb23 	bl	8012d00 <protocol_buffer_synchronize>
 80056ba:	4603      	mov	r3, r0
 80056bc:	73fb      	strb	r3, [r7, #15]
 80056be:	7bfb      	ldrb	r3, [r7, #15]
 80056c0:	2b00      	cmp	r3, #0
 80056c2:	d002      	beq.n	80056ca <coolant_sync+0x2a>
            coolant_set_state(mode);
 80056c4:	7938      	ldrb	r0, [r7, #4]
 80056c6:	f7ff ffc9 	bl	800565c <coolant_set_state>
    }

    return ok;
 80056ca:	7bfb      	ldrb	r3, [r7, #15]
}
 80056cc:	4618      	mov	r0, r3
 80056ce:	3710      	adds	r7, #16
 80056d0:	46bd      	mov	sp, r7
 80056d2:	bd80      	pop	{r7, pc}

080056d4 <xbar_fn_to_axismask>:
#include "hal.h"

static limit_signals_t home_source = {0};

axes_signals_t xbar_fn_to_axismask (pin_function_t fn)
{
 80056d4:	b480      	push	{r7}
 80056d6:	b085      	sub	sp, #20
 80056d8:	af00      	add	r7, sp, #0
 80056da:	4603      	mov	r3, r0
 80056dc:	71fb      	strb	r3, [r7, #7]
    axes_signals_t mask = {0};
 80056de:	2300      	movs	r3, #0
 80056e0:	733b      	strb	r3, [r7, #12]

    switch(fn) {
 80056e2:	79fb      	ldrb	r3, [r7, #7]
 80056e4:	2b17      	cmp	r3, #23
 80056e6:	dc19      	bgt.n	800571c <xbar_fn_to_axismask+0x48>
 80056e8:	2b14      	cmp	r3, #20
 80056ea:	da12      	bge.n	8005712 <xbar_fn_to_axismask+0x3e>
 80056ec:	2b0f      	cmp	r3, #15
 80056ee:	dc02      	bgt.n	80056f6 <xbar_fn_to_axismask+0x22>
 80056f0:	2b0c      	cmp	r3, #12
 80056f2:	da04      	bge.n	80056fe <xbar_fn_to_axismask+0x2a>
            mask.v = On;
            break;
#endif

        default:
            break;
 80056f4:	e012      	b.n	800571c <xbar_fn_to_axismask+0x48>
 80056f6:	3b10      	subs	r3, #16
    switch(fn) {
 80056f8:	2b03      	cmp	r3, #3
 80056fa:	d80f      	bhi.n	800571c <xbar_fn_to_axismask+0x48>
 80056fc:	e004      	b.n	8005708 <xbar_fn_to_axismask+0x34>
            mask.x = On;
 80056fe:	7b3b      	ldrb	r3, [r7, #12]
 8005700:	f043 0301 	orr.w	r3, r3, #1
 8005704:	733b      	strb	r3, [r7, #12]
            break;
 8005706:	e00a      	b.n	800571e <xbar_fn_to_axismask+0x4a>
            mask.y = On;
 8005708:	7b3b      	ldrb	r3, [r7, #12]
 800570a:	f043 0302 	orr.w	r3, r3, #2
 800570e:	733b      	strb	r3, [r7, #12]
            break;
 8005710:	e005      	b.n	800571e <xbar_fn_to_axismask+0x4a>
            mask.z = On;
 8005712:	7b3b      	ldrb	r3, [r7, #12]
 8005714:	f043 0304 	orr.w	r3, r3, #4
 8005718:	733b      	strb	r3, [r7, #12]
            break;
 800571a:	e000      	b.n	800571e <xbar_fn_to_axismask+0x4a>
            break;
 800571c:	bf00      	nop
    }

    return mask;
 800571e:	7b3b      	ldrb	r3, [r7, #12]
}
 8005720:	4618      	mov	r0, r3
 8005722:	3714      	adds	r7, #20
 8005724:	46bd      	mov	sp, r7
 8005726:	bc80      	pop	{r7}
 8005728:	4770      	bx	lr
	...

0800572c <xbar_set_homing_source>:

// Sets limit signals used by homing when home signals are not available.
// For internal use, called by settings.c when homing direction mask is changed.
void xbar_set_homing_source (void)
{
 800572c:	b480      	push	{r7}
 800572e:	af00      	add	r7, sp, #0
    if(hal.home_cap.a.mask == 0) {
 8005730:	4b1c      	ldr	r3, [pc, #112]	; (80057a4 <xbar_set_homing_source+0x78>)
 8005732:	f893 31b2 	ldrb.w	r3, [r3, #434]	; 0x1b2
 8005736:	2b00      	cmp	r3, #0
 8005738:	d12f      	bne.n	800579a <xbar_set_homing_source+0x6e>
        home_source.max.mask = hal.limits_cap.max.mask & ((~settings.homing.dir_mask.mask) & AXES_BITMASK);
 800573a:	4b1a      	ldr	r3, [pc, #104]	; (80057a4 <xbar_set_homing_source+0x78>)
 800573c:	f893 21af 	ldrb.w	r2, [r3, #431]	; 0x1af
 8005740:	4b19      	ldr	r3, [pc, #100]	; (80057a8 <xbar_set_homing_source+0x7c>)
 8005742:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 8005746:	43db      	mvns	r3, r3
 8005748:	b2db      	uxtb	r3, r3
 800574a:	4013      	ands	r3, r2
 800574c:	b2db      	uxtb	r3, r3
 800574e:	f003 0307 	and.w	r3, r3, #7
 8005752:	b2da      	uxtb	r2, r3
 8005754:	4b15      	ldr	r3, [pc, #84]	; (80057ac <xbar_set_homing_source+0x80>)
 8005756:	705a      	strb	r2, [r3, #1]
        home_source.min.mask = (~home_source.max.mask) & AXES_BITMASK;
 8005758:	4b14      	ldr	r3, [pc, #80]	; (80057ac <xbar_set_homing_source+0x80>)
 800575a:	785b      	ldrb	r3, [r3, #1]
 800575c:	43db      	mvns	r3, r3
 800575e:	b2db      	uxtb	r3, r3
 8005760:	f003 0307 	and.w	r3, r3, #7
 8005764:	b2da      	uxtb	r2, r3
 8005766:	4b11      	ldr	r3, [pc, #68]	; (80057ac <xbar_set_homing_source+0x80>)
 8005768:	701a      	strb	r2, [r3, #0]
        home_source.max2.mask = hal.limits_cap.max2.mask & ((~settings.homing.dir_mask.mask) & AXES_BITMASK);
 800576a:	4b0e      	ldr	r3, [pc, #56]	; (80057a4 <xbar_set_homing_source+0x78>)
 800576c:	f893 21b1 	ldrb.w	r2, [r3, #433]	; 0x1b1
 8005770:	4b0d      	ldr	r3, [pc, #52]	; (80057a8 <xbar_set_homing_source+0x7c>)
 8005772:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 8005776:	43db      	mvns	r3, r3
 8005778:	b2db      	uxtb	r3, r3
 800577a:	4013      	ands	r3, r2
 800577c:	b2db      	uxtb	r3, r3
 800577e:	f003 0307 	and.w	r3, r3, #7
 8005782:	b2da      	uxtb	r2, r3
 8005784:	4b09      	ldr	r3, [pc, #36]	; (80057ac <xbar_set_homing_source+0x80>)
 8005786:	70da      	strb	r2, [r3, #3]
        home_source.min2.mask = (~home_source.max2.mask) & AXES_BITMASK;
 8005788:	4b08      	ldr	r3, [pc, #32]	; (80057ac <xbar_set_homing_source+0x80>)
 800578a:	78db      	ldrb	r3, [r3, #3]
 800578c:	43db      	mvns	r3, r3
 800578e:	b2db      	uxtb	r3, r3
 8005790:	f003 0307 	and.w	r3, r3, #7
 8005794:	b2da      	uxtb	r2, r3
 8005796:	4b05      	ldr	r3, [pc, #20]	; (80057ac <xbar_set_homing_source+0x80>)
 8005798:	709a      	strb	r2, [r3, #2]
    }
}
 800579a:	bf00      	nop
 800579c:	46bd      	mov	sp, r7
 800579e:	bc80      	pop	{r7}
 80057a0:	4770      	bx	lr
 80057a2:	bf00      	nop
 80057a4:	20000ed0 	.word	0x20000ed0
 80057a8:	2000147c 	.word	0x2000147c
 80057ac:	20000bac 	.word	0x20000bac

080057b0 <xbar_get_homing_source>:

// Returns limit signals used by homing when home signals are not available.
limit_signals_t xbar_get_homing_source (void)
{
 80057b0:	b480      	push	{r7}
 80057b2:	b083      	sub	sp, #12
 80057b4:	af00      	add	r7, sp, #0
    return home_source;
 80057b6:	4b0a      	ldr	r3, [pc, #40]	; (80057e0 <xbar_get_homing_source+0x30>)
 80057b8:	681b      	ldr	r3, [r3, #0]
 80057ba:	607b      	str	r3, [r7, #4]
 80057bc:	2300      	movs	r3, #0
 80057be:	793a      	ldrb	r2, [r7, #4]
 80057c0:	f362 0307 	bfi	r3, r2, #0, #8
 80057c4:	797a      	ldrb	r2, [r7, #5]
 80057c6:	f362 230f 	bfi	r3, r2, #8, #8
 80057ca:	79ba      	ldrb	r2, [r7, #6]
 80057cc:	f362 4317 	bfi	r3, r2, #16, #8
 80057d0:	79fa      	ldrb	r2, [r7, #7]
 80057d2:	f362 631f 	bfi	r3, r2, #24, #8
}
 80057d6:	4618      	mov	r0, r3
 80057d8:	370c      	adds	r7, #12
 80057da:	46bd      	mov	sp, r7
 80057dc:	bc80      	pop	{r7}
 80057de:	4770      	bx	lr
 80057e0:	20000bac 	.word	0x20000bac

080057e4 <xbar_get_homing_source_from_cycle>:

// Returns limit signals used by homing cycle when home signals are not available.
limit_signals_t xbar_get_homing_source_from_cycle (axes_signals_t homing_cycle)
{
 80057e4:	b480      	push	{r7}
 80057e6:	b085      	sub	sp, #20
 80057e8:	af00      	add	r7, sp, #0
 80057ea:	7138      	strb	r0, [r7, #4]
    limit_signals_t source = home_source;
 80057ec:	4b1c      	ldr	r3, [pc, #112]	; (8005860 <xbar_get_homing_source_from_cycle+0x7c>)
 80057ee:	681b      	ldr	r3, [r3, #0]
 80057f0:	60bb      	str	r3, [r7, #8]

    if(hal.home_cap.a.mask == 0) {
 80057f2:	4b1c      	ldr	r3, [pc, #112]	; (8005864 <xbar_get_homing_source_from_cycle+0x80>)
 80057f4:	f893 31b2 	ldrb.w	r3, [r3, #434]	; 0x1b2
 80057f8:	2b00      	cmp	r3, #0
 80057fa:	d11d      	bne.n	8005838 <xbar_get_homing_source_from_cycle+0x54>
        source.min.mask &= homing_cycle.mask;
 80057fc:	7a3a      	ldrb	r2, [r7, #8]
 80057fe:	793b      	ldrb	r3, [r7, #4]
 8005800:	4013      	ands	r3, r2
 8005802:	b2db      	uxtb	r3, r3
 8005804:	723b      	strb	r3, [r7, #8]
        source.min2.mask &= homing_cycle.mask;
 8005806:	7aba      	ldrb	r2, [r7, #10]
 8005808:	793b      	ldrb	r3, [r7, #4]
 800580a:	4013      	ands	r3, r2
 800580c:	b2db      	uxtb	r3, r3
 800580e:	72bb      	strb	r3, [r7, #10]
        source.min.mask |= source.min2.mask;
 8005810:	7a3a      	ldrb	r2, [r7, #8]
 8005812:	7abb      	ldrb	r3, [r7, #10]
 8005814:	4313      	orrs	r3, r2
 8005816:	b2db      	uxtb	r3, r3
 8005818:	723b      	strb	r3, [r7, #8]
        source.max.mask &= homing_cycle.mask;
 800581a:	7a7a      	ldrb	r2, [r7, #9]
 800581c:	793b      	ldrb	r3, [r7, #4]
 800581e:	4013      	ands	r3, r2
 8005820:	b2db      	uxtb	r3, r3
 8005822:	727b      	strb	r3, [r7, #9]
        source.max2.mask &= homing_cycle.mask;
 8005824:	7afa      	ldrb	r2, [r7, #11]
 8005826:	793b      	ldrb	r3, [r7, #4]
 8005828:	4013      	ands	r3, r2
 800582a:	b2db      	uxtb	r3, r3
 800582c:	72fb      	strb	r3, [r7, #11]
        source.max.mask |= source.max2.mask;
 800582e:	7a7a      	ldrb	r2, [r7, #9]
 8005830:	7afb      	ldrb	r3, [r7, #11]
 8005832:	4313      	orrs	r3, r2
 8005834:	b2db      	uxtb	r3, r3
 8005836:	727b      	strb	r3, [r7, #9]
    }

    return source;
 8005838:	68bb      	ldr	r3, [r7, #8]
 800583a:	60fb      	str	r3, [r7, #12]
 800583c:	2300      	movs	r3, #0
 800583e:	7b3a      	ldrb	r2, [r7, #12]
 8005840:	f362 0307 	bfi	r3, r2, #0, #8
 8005844:	7b7a      	ldrb	r2, [r7, #13]
 8005846:	f362 230f 	bfi	r3, r2, #8, #8
 800584a:	7bba      	ldrb	r2, [r7, #14]
 800584c:	f362 4317 	bfi	r3, r2, #16, #8
 8005850:	7bfa      	ldrb	r2, [r7, #15]
 8005852:	f362 631f 	bfi	r3, r2, #24, #8
}
 8005856:	4618      	mov	r0, r3
 8005858:	3714      	adds	r7, #20
 800585a:	46bd      	mov	sp, r7
 800585c:	bc80      	pop	{r7}
 800585e:	4770      	bx	lr
 8005860:	20000bac 	.word	0x20000bac
 8005864:	20000ed0 	.word	0x20000ed0

08005868 <errors_get_details>:
    errors->next = details;
    errors = details;
}

error_details_t *errors_get_details (void)
{
 8005868:	b480      	push	{r7}
 800586a:	af00      	add	r7, sp, #0
    return &details;
 800586c:	4b02      	ldr	r3, [pc, #8]	; (8005878 <errors_get_details+0x10>)
}
 800586e:	4618      	mov	r0, r3
 8005870:	46bd      	mov	sp, r7
 8005872:	bc80      	pop	{r7}
 8005874:	4770      	bx	lr
 8005876:	bf00      	nop
 8005878:	2000023c 	.word	0x2000023c

0800587c <hypot_f>:
#endif
};

// Simple hypotenuse computation function.
inline static float hypot_f (float x, float y)
{
 800587c:	b590      	push	{r4, r7, lr}
 800587e:	b083      	sub	sp, #12
 8005880:	af00      	add	r7, sp, #0
 8005882:	6078      	str	r0, [r7, #4]
 8005884:	6039      	str	r1, [r7, #0]
    return sqrtf(x * x + y * y);
 8005886:	6879      	ldr	r1, [r7, #4]
 8005888:	6878      	ldr	r0, [r7, #4]
 800588a:	f7fb fa93 	bl	8000db4 <__aeabi_fmul>
 800588e:	4603      	mov	r3, r0
 8005890:	461c      	mov	r4, r3
 8005892:	6839      	ldr	r1, [r7, #0]
 8005894:	6838      	ldr	r0, [r7, #0]
 8005896:	f7fb fa8d 	bl	8000db4 <__aeabi_fmul>
 800589a:	4603      	mov	r3, r0
 800589c:	4619      	mov	r1, r3
 800589e:	4620      	mov	r0, r4
 80058a0:	f7fb f980 	bl	8000ba4 <__addsf3>
 80058a4:	4603      	mov	r3, r0
 80058a6:	4618      	mov	r0, r3
 80058a8:	f01f f8a9 	bl	80249fe <sqrtf>
 80058ac:	4603      	mov	r3, r0
}
 80058ae:	4618      	mov	r0, r3
 80058b0:	370c      	adds	r7, #12
 80058b2:	46bd      	mov	sp, r7
 80058b4:	bd90      	pop	{r4, r7, pc}

080058b6 <motion_is_lasercut>:

inline static bool motion_is_lasercut (motion_mode_t motion)
{
 80058b6:	b480      	push	{r7}
 80058b8:	b083      	sub	sp, #12
 80058ba:	af00      	add	r7, sp, #0
 80058bc:	4603      	mov	r3, r0
 80058be:	80fb      	strh	r3, [r7, #6]
    return motion == MotionMode_Linear || motion == MotionMode_CwArc || motion == MotionMode_CcwArc || motion == MotionMode_CubicSpline || motion == MotionMode_QuadraticSpline;
 80058c0:	88fb      	ldrh	r3, [r7, #6]
 80058c2:	2b01      	cmp	r3, #1
 80058c4:	d00b      	beq.n	80058de <motion_is_lasercut+0x28>
 80058c6:	88fb      	ldrh	r3, [r7, #6]
 80058c8:	2b02      	cmp	r3, #2
 80058ca:	d008      	beq.n	80058de <motion_is_lasercut+0x28>
 80058cc:	88fb      	ldrh	r3, [r7, #6]
 80058ce:	2b03      	cmp	r3, #3
 80058d0:	d005      	beq.n	80058de <motion_is_lasercut+0x28>
 80058d2:	88fb      	ldrh	r3, [r7, #6]
 80058d4:	2b05      	cmp	r3, #5
 80058d6:	d002      	beq.n	80058de <motion_is_lasercut+0x28>
 80058d8:	88fb      	ldrh	r3, [r7, #6]
 80058da:	2b33      	cmp	r3, #51	; 0x33
 80058dc:	d101      	bne.n	80058e2 <motion_is_lasercut+0x2c>
 80058de:	2301      	movs	r3, #1
 80058e0:	e000      	b.n	80058e4 <motion_is_lasercut+0x2e>
 80058e2:	2300      	movs	r3, #0
 80058e4:	f003 0301 	and.w	r3, r3, #1
 80058e8:	b2db      	uxtb	r3, r3
}
 80058ea:	4618      	mov	r0, r3
 80058ec:	370c      	adds	r7, #12
 80058ee:	46bd      	mov	sp, r7
 80058f0:	bc80      	pop	{r7}
 80058f2:	4770      	bx	lr

080058f4 <set_scaling>:
{
    return &gc_state;
}

static void set_scaling (float factor)
{
 80058f4:	b590      	push	{r4, r7, lr}
 80058f6:	b085      	sub	sp, #20
 80058f8:	af00      	add	r7, sp, #0
 80058fa:	6078      	str	r0, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 80058fc:	2303      	movs	r3, #3
 80058fe:	60fb      	str	r3, [r7, #12]
    axes_signals_t state = gc_get_g51_state();
 8005900:	f000 f840 	bl	8005984 <gc_get_g51_state>
 8005904:	4603      	mov	r3, r0
 8005906:	723b      	strb	r3, [r7, #8]

    do {
        scale_factor.ijk[--idx] = factor;
 8005908:	68fb      	ldr	r3, [r7, #12]
 800590a:	3b01      	subs	r3, #1
 800590c:	60fb      	str	r3, [r7, #12]
 800590e:	4a16      	ldr	r2, [pc, #88]	; (8005968 <set_scaling+0x74>)
 8005910:	68fb      	ldr	r3, [r7, #12]
 8005912:	3302      	adds	r3, #2
 8005914:	009b      	lsls	r3, r3, #2
 8005916:	4413      	add	r3, r2
 8005918:	687a      	ldr	r2, [r7, #4]
 800591a:	605a      	str	r2, [r3, #4]
#ifdef MACH3_SCALING
        scale_factor.xyz[idx] = 0.0f;
 800591c:	4a12      	ldr	r2, [pc, #72]	; (8005968 <set_scaling+0x74>)
 800591e:	68fb      	ldr	r3, [r7, #12]
 8005920:	f04f 0100 	mov.w	r1, #0
 8005924:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
#endif
    } while(idx);
 8005928:	68fb      	ldr	r3, [r7, #12]
 800592a:	2b00      	cmp	r3, #0
 800592c:	d1ec      	bne.n	8005908 <set_scaling+0x14>

    gc_state.modal.scaling_active = factor != 1.0f;
 800592e:	2301      	movs	r3, #1
 8005930:	461c      	mov	r4, r3
 8005932:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8005936:	6878      	ldr	r0, [r7, #4]
 8005938:	f7fb fbd0 	bl	80010dc <__aeabi_fcmpeq>
 800593c:	4603      	mov	r3, r0
 800593e:	2b00      	cmp	r3, #0
 8005940:	d001      	beq.n	8005946 <set_scaling+0x52>
 8005942:	2300      	movs	r3, #0
 8005944:	461c      	mov	r4, r3
 8005946:	b2e2      	uxtb	r2, r4
 8005948:	4b08      	ldr	r3, [pc, #32]	; (800596c <set_scaling+0x78>)
 800594a:	779a      	strb	r2, [r3, #30]

    if(state.value != gc_get_g51_state().value)
 800594c:	7a3c      	ldrb	r4, [r7, #8]
 800594e:	f000 f819 	bl	8005984 <gc_get_g51_state>
 8005952:	4603      	mov	r3, r0
 8005954:	b2db      	uxtb	r3, r3
 8005956:	429c      	cmp	r4, r3
 8005958:	d002      	beq.n	8005960 <set_scaling+0x6c>
        system_add_rt_report(Report_Scaling);
 800595a:	2002      	movs	r0, #2
 800595c:	f01c fb1e 	bl	8021f9c <system_add_rt_report>
}
 8005960:	bf00      	nop
 8005962:	3714      	adds	r7, #20
 8005964:	46bd      	mov	sp, r7
 8005966:	bd90      	pop	{r4, r7, pc}
 8005968:	20000248 	.word	0x20000248
 800596c:	20000bb0 	.word	0x20000bb0

08005970 <gc_get_scaling>:

float *gc_get_scaling (void)
{
 8005970:	b480      	push	{r7}
 8005972:	af00      	add	r7, sp, #0
    return scale_factor.ijk;
 8005974:	4b02      	ldr	r3, [pc, #8]	; (8005980 <gc_get_scaling+0x10>)
}
 8005976:	4618      	mov	r0, r3
 8005978:	46bd      	mov	sp, r7
 800597a:	bc80      	pop	{r7}
 800597c:	4770      	bx	lr
 800597e:	bf00      	nop
 8005980:	20000254 	.word	0x20000254

08005984 <gc_get_g51_state>:

axes_signals_t gc_get_g51_state (void)
{
 8005984:	b580      	push	{r7, lr}
 8005986:	b082      	sub	sp, #8
 8005988:	af00      	add	r7, sp, #0
    uint_fast8_t idx = N_AXIS;
 800598a:	2303      	movs	r3, #3
 800598c:	607b      	str	r3, [r7, #4]
    axes_signals_t scaled = {0};
 800598e:	2300      	movs	r3, #0
 8005990:	703b      	strb	r3, [r7, #0]

    do {
        scaled.value <<= 1;
 8005992:	783b      	ldrb	r3, [r7, #0]
 8005994:	005b      	lsls	r3, r3, #1
 8005996:	b2db      	uxtb	r3, r3
 8005998:	703b      	strb	r3, [r7, #0]
        if(scale_factor.ijk[--idx] != 1.0f)
 800599a:	687b      	ldr	r3, [r7, #4]
 800599c:	3b01      	subs	r3, #1
 800599e:	607b      	str	r3, [r7, #4]
 80059a0:	4a0d      	ldr	r2, [pc, #52]	; (80059d8 <gc_get_g51_state+0x54>)
 80059a2:	687b      	ldr	r3, [r7, #4]
 80059a4:	3302      	adds	r3, #2
 80059a6:	009b      	lsls	r3, r3, #2
 80059a8:	4413      	add	r3, r2
 80059aa:	685b      	ldr	r3, [r3, #4]
 80059ac:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80059b0:	4618      	mov	r0, r3
 80059b2:	f7fb fb93 	bl	80010dc <__aeabi_fcmpeq>
 80059b6:	4603      	mov	r3, r0
 80059b8:	2b00      	cmp	r3, #0
 80059ba:	d104      	bne.n	80059c6 <gc_get_g51_state+0x42>
            scaled.value |= 0x01;
 80059bc:	783b      	ldrb	r3, [r7, #0]
 80059be:	f043 0301 	orr.w	r3, r3, #1
 80059c2:	b2db      	uxtb	r3, r3
 80059c4:	703b      	strb	r3, [r7, #0]

    } while(idx);
 80059c6:	687b      	ldr	r3, [r7, #4]
 80059c8:	2b00      	cmp	r3, #0
 80059ca:	d1e2      	bne.n	8005992 <gc_get_g51_state+0xe>

    return scaled;
 80059cc:	783b      	ldrb	r3, [r7, #0]
}
 80059ce:	4618      	mov	r0, r3
 80059d0:	3708      	adds	r7, #8
 80059d2:	46bd      	mov	sp, r7
 80059d4:	bd80      	pop	{r7, pc}
 80059d6:	bf00      	nop
 80059d8:	20000248 	.word	0x20000248

080059dc <gc_get_offset>:

float gc_get_offset (uint_fast8_t idx)
{
 80059dc:	b580      	push	{r7, lr}
 80059de:	b082      	sub	sp, #8
 80059e0:	af00      	add	r7, sp, #0
 80059e2:	6078      	str	r0, [r7, #4]
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 80059e4:	4a0e      	ldr	r2, [pc, #56]	; (8005a20 <gc_get_offset+0x44>)
 80059e6:	687b      	ldr	r3, [r7, #4]
 80059e8:	3302      	adds	r3, #2
 80059ea:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80059ee:	490c      	ldr	r1, [pc, #48]	; (8005a20 <gc_get_offset+0x44>)
 80059f0:	687b      	ldr	r3, [r7, #4]
 80059f2:	331e      	adds	r3, #30
 80059f4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80059f8:	4619      	mov	r1, r3
 80059fa:	4610      	mov	r0, r2
 80059fc:	f7fb f8d2 	bl	8000ba4 <__addsf3>
 8005a00:	4603      	mov	r3, r0
 8005a02:	4618      	mov	r0, r3
 8005a04:	4a06      	ldr	r2, [pc, #24]	; (8005a20 <gc_get_offset+0x44>)
 8005a06:	687b      	ldr	r3, [r7, #4]
 8005a08:	3320      	adds	r3, #32
 8005a0a:	009b      	lsls	r3, r3, #2
 8005a0c:	4413      	add	r3, r2
 8005a0e:	685b      	ldr	r3, [r3, #4]
 8005a10:	4619      	mov	r1, r3
 8005a12:	f7fb f8c7 	bl	8000ba4 <__addsf3>
 8005a16:	4603      	mov	r3, r0
}
 8005a18:	4618      	mov	r0, r3
 8005a1a:	3708      	adds	r7, #8
 8005a1c:	46bd      	mov	sp, r7
 8005a1e:	bd80      	pop	{r7, pc}
 8005a20:	20000bb0 	.word	0x20000bb0

08005a24 <gc_get_block_offset>:

inline static float gc_get_block_offset (parser_block_t *gc_block, uint_fast8_t idx)
{
 8005a24:	b580      	push	{r7, lr}
 8005a26:	b082      	sub	sp, #8
 8005a28:	af00      	add	r7, sp, #0
 8005a2a:	6078      	str	r0, [r7, #4]
 8005a2c:	6039      	str	r1, [r7, #0]
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8005a2e:	687b      	ldr	r3, [r7, #4]
 8005a30:	683a      	ldr	r2, [r7, #0]
 8005a32:	3204      	adds	r2, #4
 8005a34:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8005a38:	490c      	ldr	r1, [pc, #48]	; (8005a6c <gc_get_block_offset+0x48>)
 8005a3a:	683b      	ldr	r3, [r7, #0]
 8005a3c:	331e      	adds	r3, #30
 8005a3e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8005a42:	4619      	mov	r1, r3
 8005a44:	4610      	mov	r0, r2
 8005a46:	f7fb f8ad 	bl	8000ba4 <__addsf3>
 8005a4a:	4603      	mov	r3, r0
 8005a4c:	4618      	mov	r0, r3
 8005a4e:	4a07      	ldr	r2, [pc, #28]	; (8005a6c <gc_get_block_offset+0x48>)
 8005a50:	683b      	ldr	r3, [r7, #0]
 8005a52:	3320      	adds	r3, #32
 8005a54:	009b      	lsls	r3, r3, #2
 8005a56:	4413      	add	r3, r2
 8005a58:	685b      	ldr	r3, [r3, #4]
 8005a5a:	4619      	mov	r1, r3
 8005a5c:	f7fb f8a2 	bl	8000ba4 <__addsf3>
 8005a60:	4603      	mov	r3, r0
}
 8005a62:	4618      	mov	r0, r3
 8005a64:	3708      	adds	r7, #8
 8005a66:	46bd      	mov	sp, r7
 8005a68:	bd80      	pop	{r7, pc}
 8005a6a:	bf00      	nop
 8005a6c:	20000bb0 	.word	0x20000bb0

08005a70 <gc_set_tool_offset>:

void gc_set_tool_offset (tool_offset_mode_t mode, uint_fast8_t idx, int32_t offset)
{
 8005a70:	b5b0      	push	{r4, r5, r7, lr}
 8005a72:	b086      	sub	sp, #24
 8005a74:	af00      	add	r7, sp, #0
 8005a76:	4603      	mov	r3, r0
 8005a78:	60b9      	str	r1, [r7, #8]
 8005a7a:	607a      	str	r2, [r7, #4]
 8005a7c:	73fb      	strb	r3, [r7, #15]
    bool tlo_changed = false;
 8005a7e:	2300      	movs	r3, #0
 8005a80:	75fb      	strb	r3, [r7, #23]

    switch(mode) {
 8005a82:	7bfb      	ldrb	r3, [r7, #15]
 8005a84:	2b00      	cmp	r3, #0
 8005a86:	d002      	beq.n	8005a8e <gc_set_tool_offset+0x1e>
 8005a88:	2b02      	cmp	r3, #2
 8005a8a:	d037      	beq.n	8005afc <gc_set_tool_offset+0x8c>
                    gc_state.tool->offset[idx] = new_offset;
            }
            break;

        default:
            break;
 8005a8c:	e073      	b.n	8005b76 <gc_set_tool_offset+0x106>
            idx = N_AXIS;
 8005a8e:	2303      	movs	r3, #3
 8005a90:	60bb      	str	r3, [r7, #8]
                idx--;
 8005a92:	68bb      	ldr	r3, [r7, #8]
 8005a94:	3b01      	subs	r3, #1
 8005a96:	60bb      	str	r3, [r7, #8]
                tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 8005a98:	7dfc      	ldrb	r4, [r7, #23]
 8005a9a:	4a3f      	ldr	r2, [pc, #252]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005a9c:	68bb      	ldr	r3, [r7, #8]
 8005a9e:	3320      	adds	r3, #32
 8005aa0:	009b      	lsls	r3, r3, #2
 8005aa2:	4413      	add	r3, r2
 8005aa4:	685b      	ldr	r3, [r3, #4]
 8005aa6:	2201      	movs	r2, #1
 8005aa8:	4615      	mov	r5, r2
 8005aaa:	f04f 0100 	mov.w	r1, #0
 8005aae:	4618      	mov	r0, r3
 8005ab0:	f7fb fb14 	bl	80010dc <__aeabi_fcmpeq>
 8005ab4:	4603      	mov	r3, r0
 8005ab6:	2b00      	cmp	r3, #0
 8005ab8:	d001      	beq.n	8005abe <gc_set_tool_offset+0x4e>
 8005aba:	2300      	movs	r3, #0
 8005abc:	461d      	mov	r5, r3
 8005abe:	b2eb      	uxtb	r3, r5
 8005ac0:	4323      	orrs	r3, r4
 8005ac2:	2b00      	cmp	r3, #0
 8005ac4:	bf14      	ite	ne
 8005ac6:	2301      	movne	r3, #1
 8005ac8:	2300      	moveq	r3, #0
 8005aca:	75fb      	strb	r3, [r7, #23]
                gc_state.tool_length_offset[idx] = 0.0f;
 8005acc:	4a32      	ldr	r2, [pc, #200]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005ace:	68bb      	ldr	r3, [r7, #8]
 8005ad0:	3320      	adds	r3, #32
 8005ad2:	009b      	lsls	r3, r3, #2
 8005ad4:	4413      	add	r3, r2
 8005ad6:	f04f 0200 	mov.w	r2, #0
 8005ada:	605a      	str	r2, [r3, #4]
                if(grbl.tool_table.n_tools == 0)
 8005adc:	4b2f      	ldr	r3, [pc, #188]	; (8005b9c <gc_set_tool_offset+0x12c>)
 8005ade:	699b      	ldr	r3, [r3, #24]
 8005ae0:	2b00      	cmp	r3, #0
 8005ae2:	d107      	bne.n	8005af4 <gc_set_tool_offset+0x84>
                    gc_state.tool->offset[idx] = 0.0f;
 8005ae4:	4b2c      	ldr	r3, [pc, #176]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005ae6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005aea:	68ba      	ldr	r2, [r7, #8]
 8005aec:	f04f 0100 	mov.w	r1, #0
 8005af0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            } while(idx);
 8005af4:	68bb      	ldr	r3, [r7, #8]
 8005af6:	2b00      	cmp	r3, #0
 8005af8:	d1cb      	bne.n	8005a92 <gc_set_tool_offset+0x22>
            break;
 8005afa:	e03c      	b.n	8005b76 <gc_set_tool_offset+0x106>
                float new_offset = offset / settings.axis[idx].steps_per_mm;
 8005afc:	6878      	ldr	r0, [r7, #4]
 8005afe:	f7fb f905 	bl	8000d0c <__aeabi_i2f>
 8005b02:	4927      	ldr	r1, [pc, #156]	; (8005ba0 <gc_set_tool_offset+0x130>)
 8005b04:	68ba      	ldr	r2, [r7, #8]
 8005b06:	4613      	mov	r3, r2
 8005b08:	009b      	lsls	r3, r3, #2
 8005b0a:	4413      	add	r3, r2
 8005b0c:	009b      	lsls	r3, r3, #2
 8005b0e:	440b      	add	r3, r1
 8005b10:	3330      	adds	r3, #48	; 0x30
 8005b12:	681b      	ldr	r3, [r3, #0]
 8005b14:	4619      	mov	r1, r3
 8005b16:	f7fb fa01 	bl	8000f1c <__aeabi_fdiv>
 8005b1a:	4603      	mov	r3, r0
 8005b1c:	613b      	str	r3, [r7, #16]
                tlo_changed |= gc_state.tool_length_offset[idx] != new_offset;
 8005b1e:	7dfc      	ldrb	r4, [r7, #23]
 8005b20:	4a1d      	ldr	r2, [pc, #116]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005b22:	68bb      	ldr	r3, [r7, #8]
 8005b24:	3320      	adds	r3, #32
 8005b26:	009b      	lsls	r3, r3, #2
 8005b28:	4413      	add	r3, r2
 8005b2a:	685b      	ldr	r3, [r3, #4]
 8005b2c:	2201      	movs	r2, #1
 8005b2e:	4615      	mov	r5, r2
 8005b30:	4619      	mov	r1, r3
 8005b32:	6938      	ldr	r0, [r7, #16]
 8005b34:	f7fb fad2 	bl	80010dc <__aeabi_fcmpeq>
 8005b38:	4603      	mov	r3, r0
 8005b3a:	2b00      	cmp	r3, #0
 8005b3c:	d001      	beq.n	8005b42 <gc_set_tool_offset+0xd2>
 8005b3e:	2300      	movs	r3, #0
 8005b40:	461d      	mov	r5, r3
 8005b42:	b2eb      	uxtb	r3, r5
 8005b44:	4323      	orrs	r3, r4
 8005b46:	2b00      	cmp	r3, #0
 8005b48:	bf14      	ite	ne
 8005b4a:	2301      	movne	r3, #1
 8005b4c:	2300      	moveq	r3, #0
 8005b4e:	75fb      	strb	r3, [r7, #23]
                gc_state.tool_length_offset[idx] = new_offset;
 8005b50:	4a11      	ldr	r2, [pc, #68]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005b52:	68bb      	ldr	r3, [r7, #8]
 8005b54:	3320      	adds	r3, #32
 8005b56:	009b      	lsls	r3, r3, #2
 8005b58:	4413      	add	r3, r2
 8005b5a:	693a      	ldr	r2, [r7, #16]
 8005b5c:	605a      	str	r2, [r3, #4]
                if(grbl.tool_table.n_tools == 0)
 8005b5e:	4b0f      	ldr	r3, [pc, #60]	; (8005b9c <gc_set_tool_offset+0x12c>)
 8005b60:	699b      	ldr	r3, [r3, #24]
 8005b62:	2b00      	cmp	r3, #0
 8005b64:	d106      	bne.n	8005b74 <gc_set_tool_offset+0x104>
                    gc_state.tool->offset[idx] = new_offset;
 8005b66:	4b0c      	ldr	r3, [pc, #48]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005b68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005b6c:	68ba      	ldr	r2, [r7, #8]
 8005b6e:	6939      	ldr	r1, [r7, #16]
 8005b70:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            break;
 8005b74:	bf00      	nop
    }

    gc_state.modal.tool_offset_mode = mode;
 8005b76:	4a08      	ldr	r2, [pc, #32]	; (8005b98 <gc_set_tool_offset+0x128>)
 8005b78:	7bfb      	ldrb	r3, [r7, #15]
 8005b7a:	71d3      	strb	r3, [r2, #7]

    if(tlo_changed) {
 8005b7c:	7dfb      	ldrb	r3, [r7, #23]
 8005b7e:	2b00      	cmp	r3, #0
 8005b80:	d005      	beq.n	8005b8e <gc_set_tool_offset+0x11e>
        system_add_rt_report(Report_ToolOffset);
 8005b82:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005b86:	f01c fa09 	bl	8021f9c <system_add_rt_report>
        system_flag_wco_change();
 8005b8a:	f01c f923 	bl	8021dd4 <system_flag_wco_change>
    }
}
 8005b8e:	bf00      	nop
 8005b90:	3718      	adds	r7, #24
 8005b92:	46bd      	mov	sp, r7
 8005b94:	bdb0      	pop	{r4, r5, r7, pc}
 8005b96:	bf00      	nop
 8005b98:	20000bb0 	.word	0x20000bb0
 8005b9c:	20000dd4 	.word	0x20000dd4
 8005ba0:	2000147c 	.word	0x2000147c

08005ba4 <gc_get_plane_data>:

plane_t *gc_get_plane_data (plane_t *plane, plane_select_t select)
{
 8005ba4:	b480      	push	{r7}
 8005ba6:	b083      	sub	sp, #12
 8005ba8:	af00      	add	r7, sp, #0
 8005baa:	6078      	str	r0, [r7, #4]
 8005bac:	460b      	mov	r3, r1
 8005bae:	70fb      	strb	r3, [r7, #3]
    switch (select) {
 8005bb0:	78fb      	ldrb	r3, [r7, #3]
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	d002      	beq.n	8005bbc <gc_get_plane_data+0x18>
 8005bb6:	2b01      	cmp	r3, #1
 8005bb8:	d00a      	beq.n	8005bd0 <gc_get_plane_data+0x2c>
 8005bba:	e013      	b.n	8005be4 <gc_get_plane_data+0x40>

        case PlaneSelect_XY:
            plane->axis_0 = X_AXIS;
 8005bbc:	687b      	ldr	r3, [r7, #4]
 8005bbe:	2200      	movs	r2, #0
 8005bc0:	701a      	strb	r2, [r3, #0]
            plane->axis_1 = Y_AXIS;
 8005bc2:	687b      	ldr	r3, [r7, #4]
 8005bc4:	2201      	movs	r2, #1
 8005bc6:	705a      	strb	r2, [r3, #1]
            plane->axis_linear = Z_AXIS;
 8005bc8:	687b      	ldr	r3, [r7, #4]
 8005bca:	2202      	movs	r2, #2
 8005bcc:	709a      	strb	r2, [r3, #2]
            break;
 8005bce:	e012      	b.n	8005bf6 <gc_get_plane_data+0x52>

        case PlaneSelect_ZX:
            plane->axis_0 = Z_AXIS;
 8005bd0:	687b      	ldr	r3, [r7, #4]
 8005bd2:	2202      	movs	r2, #2
 8005bd4:	701a      	strb	r2, [r3, #0]
            plane->axis_1 = X_AXIS;
 8005bd6:	687b      	ldr	r3, [r7, #4]
 8005bd8:	2200      	movs	r2, #0
 8005bda:	705a      	strb	r2, [r3, #1]
            plane->axis_linear = Y_AXIS;
 8005bdc:	687b      	ldr	r3, [r7, #4]
 8005bde:	2201      	movs	r2, #1
 8005be0:	709a      	strb	r2, [r3, #2]
            break;
 8005be2:	e008      	b.n	8005bf6 <gc_get_plane_data+0x52>

        default: // case PlaneSelect_YZ:
            plane->axis_0 = Y_AXIS;
 8005be4:	687b      	ldr	r3, [r7, #4]
 8005be6:	2201      	movs	r2, #1
 8005be8:	701a      	strb	r2, [r3, #0]
            plane->axis_1 = Z_AXIS;
 8005bea:	687b      	ldr	r3, [r7, #4]
 8005bec:	2202      	movs	r2, #2
 8005bee:	705a      	strb	r2, [r3, #1]
            plane->axis_linear = X_AXIS;
 8005bf0:	687b      	ldr	r3, [r7, #4]
 8005bf2:	2200      	movs	r2, #0
 8005bf4:	709a      	strb	r2, [r3, #2]
    }

    return plane;
 8005bf6:	687b      	ldr	r3, [r7, #4]
}
 8005bf8:	4618      	mov	r0, r3
 8005bfa:	370c      	adds	r7, #12
 8005bfc:	46bd      	mov	sp, r7
 8005bfe:	bc80      	pop	{r7}
 8005c00:	4770      	bx	lr
	...

08005c04 <gc_init>:

void gc_init (void)
{
 8005c04:	b580      	push	{r7, lr}
 8005c06:	b088      	sub	sp, #32
 8005c08:	af00      	add	r7, sp, #0
    memset(&gc_state, 0, sizeof(parser_state_t));
    gc_state.tool = &grbl.tool_table.tool[0];
    if(grbl.tool_table.n_tools == 0)
        memset(grbl.tool_table.tool, 0, sizeof(tool_data_t));
#else
    if(sys.cold_start) {
 8005c0a:	4b5c      	ldr	r3, [pc, #368]	; (8005d7c <gc_init+0x178>)
 8005c0c:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8005c10:	2b00      	cmp	r3, #0
 8005c12:	d015      	beq.n	8005c40 <gc_init+0x3c>
        memset(&gc_state, 0, sizeof(parser_state_t));
 8005c14:	2294      	movs	r2, #148	; 0x94
 8005c16:	2100      	movs	r1, #0
 8005c18:	4859      	ldr	r0, [pc, #356]	; (8005d80 <gc_init+0x17c>)
 8005c1a:	f01d fffc 	bl	8023c16 <memset>
        gc_state.tool = &grbl.tool_table.tool[0];
 8005c1e:	4b59      	ldr	r3, [pc, #356]	; (8005d84 <gc_init+0x180>)
 8005c20:	69db      	ldr	r3, [r3, #28]
 8005c22:	4a57      	ldr	r2, [pc, #348]	; (8005d80 <gc_init+0x17c>)
 8005c24:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        if(grbl.tool_table.n_tools == 0)
 8005c28:	4b56      	ldr	r3, [pc, #344]	; (8005d84 <gc_init+0x180>)
 8005c2a:	699b      	ldr	r3, [r3, #24]
 8005c2c:	2b00      	cmp	r3, #0
 8005c2e:	d12d      	bne.n	8005c8c <gc_init+0x88>
            memset(grbl.tool_table.tool, 0, sizeof(tool_data_t));
 8005c30:	4b54      	ldr	r3, [pc, #336]	; (8005d84 <gc_init+0x180>)
 8005c32:	69db      	ldr	r3, [r3, #28]
 8005c34:	2214      	movs	r2, #20
 8005c36:	2100      	movs	r1, #0
 8005c38:	4618      	mov	r0, r3
 8005c3a:	f01d ffec 	bl	8023c16 <memset>
 8005c3e:	e025      	b.n	8005c8c <gc_init+0x88>
    } else {
        memset(&gc_state, 0, offsetof(parser_state_t, g92_coord_offset));
 8005c40:	2278      	movs	r2, #120	; 0x78
 8005c42:	2100      	movs	r1, #0
 8005c44:	484e      	ldr	r0, [pc, #312]	; (8005d80 <gc_init+0x17c>)
 8005c46:	f01d ffe6 	bl	8023c16 <memset>
        gc_state.tool_pending = gc_state.tool->tool_id;
 8005c4a:	4b4d      	ldr	r3, [pc, #308]	; (8005d80 <gc_init+0x17c>)
 8005c4c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005c50:	691b      	ldr	r3, [r3, #16]
 8005c52:	4a4b      	ldr	r2, [pc, #300]	; (8005d80 <gc_init+0x17c>)
 8005c54:	66d3      	str	r3, [r2, #108]	; 0x6c
        if(hal.tool.select)
 8005c56:	4b4c      	ldr	r3, [pc, #304]	; (8005d88 <gc_init+0x184>)
 8005c58:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8005c5c:	2b00      	cmp	r3, #0
 8005c5e:	d015      	beq.n	8005c8c <gc_init+0x88>
            hal.tool.select(gc_state.tool, false);
 8005c60:	4b49      	ldr	r3, [pc, #292]	; (8005d88 <gc_init+0x184>)
 8005c62:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8005c66:	4a46      	ldr	r2, [pc, #280]	; (8005d80 <gc_init+0x17c>)
 8005c68:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8005c6c:	2100      	movs	r1, #0
 8005c6e:	4610      	mov	r0, r2
 8005c70:	4798      	blx	r3
        // TODO: restore offsets, tool offset mode?
    }
#endif

    // Clear any pending output commands
    while(output_commands) {
 8005c72:	e00b      	b.n	8005c8c <gc_init+0x88>
        output_command_t *next = output_commands->next;
 8005c74:	4b45      	ldr	r3, [pc, #276]	; (8005d8c <gc_init+0x188>)
 8005c76:	681b      	ldr	r3, [r3, #0]
 8005c78:	689b      	ldr	r3, [r3, #8]
 8005c7a:	61fb      	str	r3, [r7, #28]
        free(output_commands);
 8005c7c:	4b43      	ldr	r3, [pc, #268]	; (8005d8c <gc_init+0x188>)
 8005c7e:	681b      	ldr	r3, [r3, #0]
 8005c80:	4618      	mov	r0, r3
 8005c82:	f01d fc21 	bl	80234c8 <free>
        output_commands = next;
 8005c86:	4a41      	ldr	r2, [pc, #260]	; (8005d8c <gc_init+0x188>)
 8005c88:	69fb      	ldr	r3, [r7, #28]
 8005c8a:	6013      	str	r3, [r2, #0]
    while(output_commands) {
 8005c8c:	4b3f      	ldr	r3, [pc, #252]	; (8005d8c <gc_init+0x188>)
 8005c8e:	681b      	ldr	r3, [r3, #0]
 8005c90:	2b00      	cmp	r3, #0
 8005c92:	d1ef      	bne.n	8005c74 <gc_init+0x70>
    }

    // Load default override status
    gc_state.modal.override_ctrl = sys.override.control;
 8005c94:	4a3a      	ldr	r2, [pc, #232]	; (8005d80 <gc_init+0x17c>)
 8005c96:	4b39      	ldr	r3, [pc, #228]	; (8005d7c <gc_init+0x178>)
 8005c98:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8005c9c:	7713      	strb	r3, [r2, #28]
    gc_state.spindle.hal = spindle_get(0);
 8005c9e:	2000      	movs	r0, #0
 8005ca0:	f016 ff2c 	bl	801cafc <spindle_get>
 8005ca4:	4603      	mov	r3, r0
 8005ca6:	4a36      	ldr	r2, [pc, #216]	; (8005d80 <gc_init+0x17c>)
 8005ca8:	6513      	str	r3, [r2, #80]	; 0x50

    set_scaling(1.0f);
 8005caa:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8005cae:	f7ff fe21 	bl	80058f4 <set_scaling>

    // Load default G54 coordinate system.
    if (!settings_read_coord_data(gc_state.modal.coord_system.id, &gc_state.modal.coord_system.xyz))
 8005cb2:	4b33      	ldr	r3, [pc, #204]	; (8005d80 <gc_init+0x17c>)
 8005cb4:	7d1b      	ldrb	r3, [r3, #20]
 8005cb6:	4936      	ldr	r1, [pc, #216]	; (8005d90 <gc_init+0x18c>)
 8005cb8:	4618      	mov	r0, r3
 8005cba:	f014 ffad 	bl	801ac18 <settings_read_coord_data>
 8005cbe:	4603      	mov	r3, r0
 8005cc0:	f083 0301 	eor.w	r3, r3, #1
 8005cc4:	b2db      	uxtb	r3, r3
 8005cc6:	2b00      	cmp	r3, #0
 8005cc8:	d003      	beq.n	8005cd2 <gc_init+0xce>
        grbl.report.status_message(Status_SettingReadFail);
 8005cca:	4b2e      	ldr	r3, [pc, #184]	; (8005d84 <gc_init+0x180>)
 8005ccc:	689b      	ldr	r3, [r3, #8]
 8005cce:	2007      	movs	r0, #7
 8005cd0:	4798      	blx	r3

    if (sys.cold_start && !settings.flags.g92_is_volatile && !settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset))
 8005cd2:	4b2a      	ldr	r3, [pc, #168]	; (8005d7c <gc_init+0x178>)
 8005cd4:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8005cd8:	2b00      	cmp	r3, #0
 8005cda:	d015      	beq.n	8005d08 <gc_init+0x104>
 8005cdc:	4b2d      	ldr	r3, [pc, #180]	; (8005d94 <gc_init+0x190>)
 8005cde:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8005ce2:	f003 0302 	and.w	r3, r3, #2
 8005ce6:	b2db      	uxtb	r3, r3
 8005ce8:	2b00      	cmp	r3, #0
 8005cea:	d10d      	bne.n	8005d08 <gc_init+0x104>
 8005cec:	492a      	ldr	r1, [pc, #168]	; (8005d98 <gc_init+0x194>)
 8005cee:	200b      	movs	r0, #11
 8005cf0:	f014 ff92 	bl	801ac18 <settings_read_coord_data>
 8005cf4:	4603      	mov	r3, r0
 8005cf6:	f083 0301 	eor.w	r3, r3, #1
 8005cfa:	b2db      	uxtb	r3, r3
 8005cfc:	2b00      	cmp	r3, #0
 8005cfe:	d003      	beq.n	8005d08 <gc_init+0x104>
        grbl.report.status_message(Status_SettingReadFail);
 8005d00:	4b20      	ldr	r3, [pc, #128]	; (8005d84 <gc_init+0x180>)
 8005d02:	689b      	ldr	r3, [r3, #8]
 8005d04:	2007      	movs	r0, #7
 8005d06:	4798      	blx	r3

    if(grbl.on_wco_changed && (!sys.cold_start ||
 8005d08:	4b1e      	ldr	r3, [pc, #120]	; (8005d84 <gc_init+0x180>)
 8005d0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005d0c:	2b00      	cmp	r3, #0
 8005d0e:	d028      	beq.n	8005d62 <gc_init+0x15e>
 8005d10:	4b1a      	ldr	r3, [pc, #104]	; (8005d7c <gc_init+0x178>)
 8005d12:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8005d16:	f083 0301 	eor.w	r3, r3, #1
 8005d1a:	b2db      	uxtb	r3, r3
 8005d1c:	2b00      	cmp	r3, #0
 8005d1e:	d11d      	bne.n	8005d5c <gc_init+0x158>
                                !is0_position_vector(gc_state.modal.coord_system.xyz) ||
 8005d20:	f107 0310 	add.w	r3, r7, #16
 8005d24:	2200      	movs	r2, #0
 8005d26:	601a      	str	r2, [r3, #0]
 8005d28:	605a      	str	r2, [r3, #4]
 8005d2a:	609a      	str	r2, [r3, #8]
 8005d2c:	f107 0310 	add.w	r3, r7, #16
 8005d30:	220c      	movs	r2, #12
 8005d32:	4619      	mov	r1, r3
 8005d34:	4816      	ldr	r0, [pc, #88]	; (8005d90 <gc_init+0x18c>)
 8005d36:	f01d ff5e 	bl	8023bf6 <memcmp>
 8005d3a:	4603      	mov	r3, r0
    if(grbl.on_wco_changed && (!sys.cold_start ||
 8005d3c:	2b00      	cmp	r3, #0
 8005d3e:	d10d      	bne.n	8005d5c <gc_init+0x158>
                                 !is0_position_vector(gc_state.g92_coord_offset)))
 8005d40:	1d3b      	adds	r3, r7, #4
 8005d42:	2200      	movs	r2, #0
 8005d44:	601a      	str	r2, [r3, #0]
 8005d46:	605a      	str	r2, [r3, #4]
 8005d48:	609a      	str	r2, [r3, #8]
 8005d4a:	1d3b      	adds	r3, r7, #4
 8005d4c:	220c      	movs	r2, #12
 8005d4e:	4619      	mov	r1, r3
 8005d50:	4811      	ldr	r0, [pc, #68]	; (8005d98 <gc_init+0x194>)
 8005d52:	f01d ff50 	bl	8023bf6 <memcmp>
 8005d56:	4603      	mov	r3, r0
                                !is0_position_vector(gc_state.modal.coord_system.xyz) ||
 8005d58:	2b00      	cmp	r3, #0
 8005d5a:	d002      	beq.n	8005d62 <gc_init+0x15e>
        grbl.on_wco_changed();
 8005d5c:	4b09      	ldr	r3, [pc, #36]	; (8005d84 <gc_init+0x180>)
 8005d5e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005d60:	4798      	blx	r3
#endif

//    if(settings.flags.lathe_mode)
//        gc_state.modal.plane_select = PlaneSelect_ZX;

    if(grbl.on_parser_init)
 8005d62:	4b08      	ldr	r3, [pc, #32]	; (8005d84 <gc_init+0x180>)
 8005d64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005d66:	2b00      	cmp	r3, #0
 8005d68:	d003      	beq.n	8005d72 <gc_init+0x16e>
        grbl.on_parser_init(&gc_state);
 8005d6a:	4b06      	ldr	r3, [pc, #24]	; (8005d84 <gc_init+0x180>)
 8005d6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005d6e:	4804      	ldr	r0, [pc, #16]	; (8005d80 <gc_init+0x17c>)
 8005d70:	4798      	blx	r3
}
 8005d72:	bf00      	nop
 8005d74:	3720      	adds	r7, #32
 8005d76:	46bd      	mov	sp, r7
 8005d78:	bd80      	pop	{r7, pc}
 8005d7a:	bf00      	nop
 8005d7c:	20000d3c 	.word	0x20000d3c
 8005d80:	20000bb0 	.word	0x20000bb0
 8005d84:	20000dd4 	.word	0x20000dd4
 8005d88:	20000ed0 	.word	0x20000ed0
 8005d8c:	20000c74 	.word	0x20000c74
 8005d90:	20000bb8 	.word	0x20000bb8
 8005d94:	2000147c 	.word	0x2000147c
 8005d98:	20000c28 	.word	0x20000c28

08005d9c <gc_spindle_off>:

    return grbl.on_laser_ppi_enable && grbl.on_laser_ppi_enable(ppi, pulse_length);
}

void gc_spindle_off (void)
{
 8005d9c:	b580      	push	{r7, lr}
 8005d9e:	af00      	add	r7, sp, #0
    gc_state.spindle.rpm = 0.0f;
 8005da0:	4b06      	ldr	r3, [pc, #24]	; (8005dbc <gc_spindle_off+0x20>)
 8005da2:	f04f 0200 	mov.w	r2, #0
 8005da6:	645a      	str	r2, [r3, #68]	; 0x44
    gc_state.modal.spindle.state.value = 0;
 8005da8:	4b04      	ldr	r3, [pc, #16]	; (8005dbc <gc_spindle_off+0x20>)
 8005daa:	2200      	movs	r2, #0
 8005dac:	769a      	strb	r2, [r3, #26]

    spindle_all_off();
 8005dae:	f017 f98f 	bl	801d0d0 <spindle_all_off>
    system_add_rt_report(Report_Spindle);
 8005db2:	2010      	movs	r0, #16
 8005db4:	f01c f8f2 	bl	8021f9c <system_add_rt_report>
}
 8005db8:	bf00      	nop
 8005dba:	bd80      	pop	{r7, pc}
 8005dbc:	20000bb0 	.word	0x20000bb0

08005dc0 <gc_coolant_off>:

void gc_coolant_off (void)
{
 8005dc0:	b580      	push	{r7, lr}
 8005dc2:	af00      	add	r7, sp, #0
    gc_state.modal.coolant.value = 0;
 8005dc4:	4b06      	ldr	r3, [pc, #24]	; (8005de0 <gc_coolant_off+0x20>)
 8005dc6:	2200      	movs	r2, #0
 8005dc8:	765a      	strb	r2, [r3, #25]
    hal.coolant.set_state(gc_state.modal.coolant);
 8005dca:	4b06      	ldr	r3, [pc, #24]	; (8005de4 <gc_coolant_off+0x24>)
 8005dcc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005dce:	4a04      	ldr	r2, [pc, #16]	; (8005de0 <gc_coolant_off+0x20>)
 8005dd0:	7e50      	ldrb	r0, [r2, #25]
 8005dd2:	4798      	blx	r3
    system_add_rt_report(Report_Coolant);
 8005dd4:	2020      	movs	r0, #32
 8005dd6:	f01c f8e1 	bl	8021f9c <system_add_rt_report>
}
 8005dda:	bf00      	nop
 8005ddc:	bd80      	pop	{r7, pc}
 8005dde:	bf00      	nop
 8005de0:	20000bb0 	.word	0x20000bb0
 8005de4:	20000ed0 	.word	0x20000ed0

08005de8 <gc_spindle_get>:

spindle_ptrs_t *gc_spindle_get (void)
{
 8005de8:	b480      	push	{r7}
 8005dea:	af00      	add	r7, sp, #0
    return gc_state.spindle.hal;
 8005dec:	4b02      	ldr	r3, [pc, #8]	; (8005df8 <gc_spindle_get+0x10>)
 8005dee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
}
 8005df0:	4618      	mov	r0, r3
 8005df2:	46bd      	mov	sp, r7
 8005df4:	bc80      	pop	{r7}
 8005df6:	4770      	bx	lr
 8005df8:	20000bb0 	.word	0x20000bb0

08005dfc <tool_get_pending>:

static tool_data_t *tool_get_pending (tool_id_t tool_id)
{
 8005dfc:	b580      	push	{r7, lr}
 8005dfe:	b082      	sub	sp, #8
 8005e00:	af00      	add	r7, sp, #0
 8005e02:	6078      	str	r0, [r7, #4]
    static tool_data_t tool_data = {0};

    if(grbl.tool_table.n_tools)
 8005e04:	4b0e      	ldr	r3, [pc, #56]	; (8005e40 <tool_get_pending+0x44>)
 8005e06:	699b      	ldr	r3, [r3, #24]
 8005e08:	2b00      	cmp	r3, #0
 8005e0a:	d008      	beq.n	8005e1e <tool_get_pending+0x22>
        return &grbl.tool_table.tool[tool_id];
 8005e0c:	4b0c      	ldr	r3, [pc, #48]	; (8005e40 <tool_get_pending+0x44>)
 8005e0e:	69d9      	ldr	r1, [r3, #28]
 8005e10:	687a      	ldr	r2, [r7, #4]
 8005e12:	4613      	mov	r3, r2
 8005e14:	009b      	lsls	r3, r3, #2
 8005e16:	4413      	add	r3, r2
 8005e18:	009b      	lsls	r3, r3, #2
 8005e1a:	440b      	add	r3, r1
 8005e1c:	e00b      	b.n	8005e36 <tool_get_pending+0x3a>

    memcpy(&tool_data, gc_state.tool, sizeof(tool_data_t));
 8005e1e:	4b09      	ldr	r3, [pc, #36]	; (8005e44 <tool_get_pending+0x48>)
 8005e20:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005e24:	2214      	movs	r2, #20
 8005e26:	4619      	mov	r1, r3
 8005e28:	4807      	ldr	r0, [pc, #28]	; (8005e48 <tool_get_pending+0x4c>)
 8005e2a:	f01e f850 	bl	8023ece <memcpy>
    tool_data.tool_id = tool_id;
 8005e2e:	4a06      	ldr	r2, [pc, #24]	; (8005e48 <tool_get_pending+0x4c>)
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	6113      	str	r3, [r2, #16]

    return &tool_data;
 8005e34:	4b04      	ldr	r3, [pc, #16]	; (8005e48 <tool_get_pending+0x4c>)
}
 8005e36:	4618      	mov	r0, r3
 8005e38:	3708      	adds	r7, #8
 8005e3a:	46bd      	mov	sp, r7
 8005e3c:	bd80      	pop	{r7, pc}
 8005e3e:	bf00      	nop
 8005e40:	20000dd4 	.word	0x20000dd4
 8005e44:	20000bb0 	.word	0x20000bb0
 8005e48:	20000c78 	.word	0x20000c78

08005e4c <tool_set>:

static inline void tool_set (tool_data_t *tool)
{
 8005e4c:	b480      	push	{r7}
 8005e4e:	b083      	sub	sp, #12
 8005e50:	af00      	add	r7, sp, #0
 8005e52:	6078      	str	r0, [r7, #4]
    if(grbl.tool_table.n_tools)
 8005e54:	4b09      	ldr	r3, [pc, #36]	; (8005e7c <tool_set+0x30>)
 8005e56:	699b      	ldr	r3, [r3, #24]
 8005e58:	2b00      	cmp	r3, #0
 8005e5a:	d004      	beq.n	8005e66 <tool_set+0x1a>
        gc_state.tool = tool;
 8005e5c:	4a08      	ldr	r2, [pc, #32]	; (8005e80 <tool_set+0x34>)
 8005e5e:	687b      	ldr	r3, [r7, #4]
 8005e60:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    else
        gc_state.tool->tool_id = tool->tool_id;
}
 8005e64:	e005      	b.n	8005e72 <tool_set+0x26>
        gc_state.tool->tool_id = tool->tool_id;
 8005e66:	4b06      	ldr	r3, [pc, #24]	; (8005e80 <tool_set+0x34>)
 8005e68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005e6c:	687a      	ldr	r2, [r7, #4]
 8005e6e:	6912      	ldr	r2, [r2, #16]
 8005e70:	611a      	str	r2, [r3, #16]
}
 8005e72:	bf00      	nop
 8005e74:	370c      	adds	r7, #12
 8005e76:	46bd      	mov	sp, r7
 8005e78:	bc80      	pop	{r7}
 8005e7a:	4770      	bx	lr
 8005e7c:	20000dd4 	.word	0x20000dd4
 8005e80:	20000bb0 	.word	0x20000bb0

08005e84 <add_output_command>:

// Add output command to linked list
static bool add_output_command (output_command_t *command)
{
 8005e84:	b580      	push	{r7, lr}
 8005e86:	b084      	sub	sp, #16
 8005e88:	af00      	add	r7, sp, #0
 8005e8a:	6078      	str	r0, [r7, #4]
    output_command_t *add_cmd;

    if((add_cmd = malloc(sizeof(output_command_t)))) {
 8005e8c:	200c      	movs	r0, #12
 8005e8e:	f01d fb13 	bl	80234b8 <malloc>
 8005e92:	4603      	mov	r3, r0
 8005e94:	60bb      	str	r3, [r7, #8]
 8005e96:	68bb      	ldr	r3, [r7, #8]
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d01a      	beq.n	8005ed2 <add_output_command+0x4e>

        memcpy(add_cmd, command, sizeof(output_command_t));
 8005e9c:	220c      	movs	r2, #12
 8005e9e:	6879      	ldr	r1, [r7, #4]
 8005ea0:	68b8      	ldr	r0, [r7, #8]
 8005ea2:	f01e f814 	bl	8023ece <memcpy>

        if(output_commands == NULL)
 8005ea6:	4b10      	ldr	r3, [pc, #64]	; (8005ee8 <add_output_command+0x64>)
 8005ea8:	681b      	ldr	r3, [r3, #0]
 8005eaa:	2b00      	cmp	r3, #0
 8005eac:	d103      	bne.n	8005eb6 <add_output_command+0x32>
            output_commands = add_cmd;
 8005eae:	4a0e      	ldr	r2, [pc, #56]	; (8005ee8 <add_output_command+0x64>)
 8005eb0:	68bb      	ldr	r3, [r7, #8]
 8005eb2:	6013      	str	r3, [r2, #0]
 8005eb4:	e00d      	b.n	8005ed2 <add_output_command+0x4e>
        else {
            output_command_t *cmd = output_commands;
 8005eb6:	4b0c      	ldr	r3, [pc, #48]	; (8005ee8 <add_output_command+0x64>)
 8005eb8:	681b      	ldr	r3, [r3, #0]
 8005eba:	60fb      	str	r3, [r7, #12]
            while(cmd->next)
 8005ebc:	e002      	b.n	8005ec4 <add_output_command+0x40>
                cmd = cmd->next;
 8005ebe:	68fb      	ldr	r3, [r7, #12]
 8005ec0:	689b      	ldr	r3, [r3, #8]
 8005ec2:	60fb      	str	r3, [r7, #12]
            while(cmd->next)
 8005ec4:	68fb      	ldr	r3, [r7, #12]
 8005ec6:	689b      	ldr	r3, [r3, #8]
 8005ec8:	2b00      	cmp	r3, #0
 8005eca:	d1f8      	bne.n	8005ebe <add_output_command+0x3a>
            cmd->next = add_cmd;
 8005ecc:	68fb      	ldr	r3, [r7, #12]
 8005ece:	68ba      	ldr	r2, [r7, #8]
 8005ed0:	609a      	str	r2, [r3, #8]
        }
    }

    return add_cmd != NULL;
 8005ed2:	68bb      	ldr	r3, [r7, #8]
 8005ed4:	2b00      	cmp	r3, #0
 8005ed6:	bf14      	ite	ne
 8005ed8:	2301      	movne	r3, #1
 8005eda:	2300      	moveq	r3, #0
 8005edc:	b2db      	uxtb	r3, r3
}
 8005ede:	4618      	mov	r0, r3
 8005ee0:	3710      	adds	r7, #16
 8005ee2:	46bd      	mov	sp, r7
 8005ee4:	bd80      	pop	{r7, pc}
 8005ee6:	bf00      	nop
 8005ee8:	20000c74 	.word	0x20000c74

08005eec <init_sync_motion>:

static status_code_t init_sync_motion (plan_line_data_t *pl_data, float pitch)
{
 8005eec:	b590      	push	{r4, r7, lr}
 8005eee:	b085      	sub	sp, #20
 8005ef0:	af00      	add	r7, sp, #0
 8005ef2:	6078      	str	r0, [r7, #4]
 8005ef4:	6039      	str	r1, [r7, #0]
    if(pl_data->spindle.hal->get_data == NULL)
 8005ef6:	687b      	ldr	r3, [r7, #4]
 8005ef8:	695b      	ldr	r3, [r3, #20]
 8005efa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005efc:	2b00      	cmp	r3, #0
 8005efe:	d101      	bne.n	8005f04 <init_sync_motion+0x18>
        FAIL(Status_GcodeUnsupportedCommand); // [Spindle not sync capable]
 8005f00:	2314      	movs	r3, #20
 8005f02:	e06b      	b.n	8005fdc <init_sync_motion+0xf0>

    pl_data->condition.inverse_time = Off;
 8005f04:	687a      	ldr	r2, [r7, #4]
 8005f06:	7e13      	ldrb	r3, [r2, #24]
 8005f08:	f36f 1345 	bfc	r3, #5, #1
 8005f0c:	7613      	strb	r3, [r2, #24]
    pl_data->feed_rate = gc_state.distance_per_rev = pitch;
 8005f0e:	4a35      	ldr	r2, [pc, #212]	; (8005fe4 <init_sync_motion+0xf8>)
 8005f10:	683b      	ldr	r3, [r7, #0]
 8005f12:	6593      	str	r3, [r2, #88]	; 0x58
 8005f14:	4b33      	ldr	r3, [pc, #204]	; (8005fe4 <init_sync_motion+0xf8>)
 8005f16:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8005f18:	687b      	ldr	r3, [r7, #4]
 8005f1a:	601a      	str	r2, [r3, #0]
    pl_data->spindle.css = NULL;                    // Switch off CSS.
 8005f1c:	687b      	ldr	r3, [r7, #4]
 8005f1e:	2200      	movs	r2, #0
 8005f20:	611a      	str	r2, [r3, #16]
    pl_data->overrides = sys.override.control;      // Use current override flags and
 8005f22:	687b      	ldr	r3, [r7, #4]
 8005f24:	4a30      	ldr	r2, [pc, #192]	; (8005fe8 <init_sync_motion+0xfc>)
 8005f26:	f892 2029 	ldrb.w	r2, [r2, #41]	; 0x29
 8005f2a:	771a      	strb	r2, [r3, #28]
    pl_data->overrides.sync = On;                   // set to sync overrides on execution of motion.
 8005f2c:	687a      	ldr	r2, [r7, #4]
 8005f2e:	7f13      	ldrb	r3, [r2, #28]
 8005f30:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005f34:	7713      	strb	r3, [r2, #28]

    // Disable feed rate and spindle overrides for the duration of the cycle.
    pl_data->overrides.spindle_rpm_disable = sys.override.control.spindle_rpm_disable = On;
 8005f36:	4a2c      	ldr	r2, [pc, #176]	; (8005fe8 <init_sync_motion+0xfc>)
 8005f38:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 8005f3c:	f043 0304 	orr.w	r3, r3, #4
 8005f40:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
 8005f44:	4b28      	ldr	r3, [pc, #160]	; (8005fe8 <init_sync_motion+0xfc>)
 8005f46:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8005f4a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8005f4e:	b2d9      	uxtb	r1, r3
 8005f50:	687a      	ldr	r2, [r7, #4]
 8005f52:	7f13      	ldrb	r3, [r2, #28]
 8005f54:	f361 0382 	bfi	r3, r1, #2, #1
 8005f58:	7713      	strb	r3, [r2, #28]
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
 8005f5a:	4a23      	ldr	r2, [pc, #140]	; (8005fe8 <init_sync_motion+0xfc>)
 8005f5c:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 8005f60:	f043 0301 	orr.w	r3, r3, #1
 8005f64:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
 8005f68:	4b1f      	ldr	r3, [pc, #124]	; (8005fe8 <init_sync_motion+0xfc>)
 8005f6a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8005f6e:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8005f72:	b2d9      	uxtb	r1, r3
 8005f74:	687a      	ldr	r2, [r7, #4]
 8005f76:	7f13      	ldrb	r3, [r2, #28]
 8005f78:	f361 0300 	bfi	r3, r1, #0, #1
 8005f7c:	7713      	strb	r3, [r2, #28]
    pl_data->spindle.hal->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8005f7e:	687b      	ldr	r3, [r7, #4]
 8005f80:	695b      	ldr	r3, [r3, #20]
 8005f82:	685b      	ldr	r3, [r3, #4]
 8005f84:	2264      	movs	r2, #100	; 0x64
 8005f86:	60da      	str	r2, [r3, #12]
    // TODO: need for gc_state.distance_per_rev to be reset on modal change?
    float feed_rate = pl_data->feed_rate * pl_data->spindle.hal->get_data(SpindleData_RPM)->rpm;
 8005f88:	687b      	ldr	r3, [r7, #4]
 8005f8a:	681c      	ldr	r4, [r3, #0]
 8005f8c:	687b      	ldr	r3, [r7, #4]
 8005f8e:	695b      	ldr	r3, [r3, #20]
 8005f90:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005f92:	2001      	movs	r0, #1
 8005f94:	4798      	blx	r3
 8005f96:	4603      	mov	r3, r0
 8005f98:	681b      	ldr	r3, [r3, #0]
 8005f9a:	4619      	mov	r1, r3
 8005f9c:	4620      	mov	r0, r4
 8005f9e:	f7fa ff09 	bl	8000db4 <__aeabi_fmul>
 8005fa2:	4603      	mov	r3, r0
 8005fa4:	60fb      	str	r3, [r7, #12]

    if(feed_rate == 0.0f)
 8005fa6:	f04f 0100 	mov.w	r1, #0
 8005faa:	68f8      	ldr	r0, [r7, #12]
 8005fac:	f7fb f896 	bl	80010dc <__aeabi_fcmpeq>
 8005fb0:	4603      	mov	r3, r0
 8005fb2:	2b00      	cmp	r3, #0
 8005fb4:	d001      	beq.n	8005fba <init_sync_motion+0xce>
        FAIL(Status_GcodeSpindleNotRunning); // [Spindle not running]
 8005fb6:	2329      	movs	r3, #41	; 0x29
 8005fb8:	e010      	b.n	8005fdc <init_sync_motion+0xf0>

    if(feed_rate > settings.axis[Z_AXIS].max_rate * 0.9f)
 8005fba:	4b0c      	ldr	r3, [pc, #48]	; (8005fec <init_sync_motion+0x100>)
 8005fbc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8005fbe:	490c      	ldr	r1, [pc, #48]	; (8005ff0 <init_sync_motion+0x104>)
 8005fc0:	4618      	mov	r0, r3
 8005fc2:	f7fa fef7 	bl	8000db4 <__aeabi_fmul>
 8005fc6:	4603      	mov	r3, r0
 8005fc8:	4619      	mov	r1, r3
 8005fca:	68f8      	ldr	r0, [r7, #12]
 8005fcc:	f7fb f8ae 	bl	800112c <__aeabi_fcmpgt>
 8005fd0:	4603      	mov	r3, r0
 8005fd2:	2b00      	cmp	r3, #0
 8005fd4:	d001      	beq.n	8005fda <init_sync_motion+0xee>
        FAIL(Status_GcodeMaxFeedRateExceeded); // [Feed rate too high]
 8005fd6:	232b      	movs	r3, #43	; 0x2b
 8005fd8:	e000      	b.n	8005fdc <init_sync_motion+0xf0>

    return Status_OK;
 8005fda:	2300      	movs	r3, #0
}
 8005fdc:	4618      	mov	r0, r3
 8005fde:	3714      	adds	r7, #20
 8005fe0:	46bd      	mov	sp, r7
 8005fe2:	bd90      	pop	{r4, r7, pc}
 8005fe4:	20000bb0 	.word	0x20000bb0
 8005fe8:	20000d3c 	.word	0x20000d3c
 8005fec:	2000147c 	.word	0x2000147c
 8005ff0:	3f666666 	.word	0x3f666666

08005ff4 <output_message>:

// Output and free previously allocated message
static void output_message (char *message)
{
 8005ff4:	b580      	push	{r7, lr}
 8005ff6:	b082      	sub	sp, #8
 8005ff8:	af00      	add	r7, sp, #0
 8005ffa:	6078      	str	r0, [r7, #4]
    if(grbl.on_gcode_message)
 8005ffc:	4b0c      	ldr	r3, [pc, #48]	; (8006030 <output_message+0x3c>)
 8005ffe:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8006002:	2b00      	cmp	r3, #0
 8006004:	d004      	beq.n	8006010 <output_message+0x1c>
        grbl.on_gcode_message(message);
 8006006:	4b0a      	ldr	r3, [pc, #40]	; (8006030 <output_message+0x3c>)
 8006008:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800600c:	6878      	ldr	r0, [r7, #4]
 800600e:	4798      	blx	r3

    if(*message)
 8006010:	687b      	ldr	r3, [r7, #4]
 8006012:	781b      	ldrb	r3, [r3, #0]
 8006014:	2b00      	cmp	r3, #0
 8006016:	d003      	beq.n	8006020 <output_message+0x2c>
        report_message(message, Message_Plain);
 8006018:	2100      	movs	r1, #0
 800601a:	6878      	ldr	r0, [r7, #4]
 800601c:	f00e fa6c 	bl	80144f8 <report_message>

    free(message);
 8006020:	6878      	ldr	r0, [r7, #4]
 8006022:	f01d fa51 	bl	80234c8 <free>
}
 8006026:	bf00      	nop
 8006028:	3708      	adds	r7, #8
 800602a:	46bd      	mov	sp, r7
 800602c:	bd80      	pop	{r7, pc}
 800602e:	bf00      	nop
 8006030:	20000dd4 	.word	0x20000dd4

08006034 <gc_normalize_block>:
// else the block delete character. Remaining characters are converted to upper case.
// If the driver handles message comments then the first is extracted and returned in a dynamically
// allocated memory block, the caller must free this after the message has been processed.

char *gc_normalize_block (char *block, char **message)
{
 8006034:	b580      	push	{r7, lr}
 8006036:	b088      	sub	sp, #32
 8006038:	af00      	add	r7, sp, #0
 800603a:	6078      	str	r0, [r7, #4]
 800603c:	6039      	str	r1, [r7, #0]
    char c, *s1, *s2, *comment = NULL;
 800603e:	2300      	movs	r3, #0
 8006040:	617b      	str	r3, [r7, #20]

    // Remove leading whitespace & control characters
    while(*block && *block <= ' ')
 8006042:	e002      	b.n	800604a <gc_normalize_block+0x16>
        block++;
 8006044:	687b      	ldr	r3, [r7, #4]
 8006046:	3301      	adds	r3, #1
 8006048:	607b      	str	r3, [r7, #4]
    while(*block && *block <= ' ')
 800604a:	687b      	ldr	r3, [r7, #4]
 800604c:	781b      	ldrb	r3, [r3, #0]
 800604e:	2b00      	cmp	r3, #0
 8006050:	d003      	beq.n	800605a <gc_normalize_block+0x26>
 8006052:	687b      	ldr	r3, [r7, #4]
 8006054:	781b      	ldrb	r3, [r3, #0]
 8006056:	2b20      	cmp	r3, #32
 8006058:	d9f4      	bls.n	8006044 <gc_normalize_block+0x10>

    if(*block == ';' || (*block == '/' && sys.flags.block_delete_enabled)) {
 800605a:	687b      	ldr	r3, [r7, #4]
 800605c:	781b      	ldrb	r3, [r3, #0]
 800605e:	2b3b      	cmp	r3, #59	; 0x3b
 8006060:	d00a      	beq.n	8006078 <gc_normalize_block+0x44>
 8006062:	687b      	ldr	r3, [r7, #4]
 8006064:	781b      	ldrb	r3, [r3, #0]
 8006066:	2b2f      	cmp	r3, #47	; 0x2f
 8006068:	d10b      	bne.n	8006082 <gc_normalize_block+0x4e>
 800606a:	4b67      	ldr	r3, [pc, #412]	; (8006208 <gc_normalize_block+0x1d4>)
 800606c:	7d9b      	ldrb	r3, [r3, #22]
 800606e:	f003 0310 	and.w	r3, r3, #16
 8006072:	b2db      	uxtb	r3, r3
 8006074:	2b00      	cmp	r3, #0
 8006076:	d004      	beq.n	8006082 <gc_normalize_block+0x4e>
        *block = '\0';
 8006078:	687b      	ldr	r3, [r7, #4]
 800607a:	2200      	movs	r2, #0
 800607c:	701a      	strb	r2, [r3, #0]
        return block;
 800607e:	687b      	ldr	r3, [r7, #4]
 8006080:	e0bd      	b.n	80061fe <gc_normalize_block+0x1ca>
    }

    if(*block == '/')
 8006082:	687b      	ldr	r3, [r7, #4]
 8006084:	781b      	ldrb	r3, [r3, #0]
 8006086:	2b2f      	cmp	r3, #47	; 0x2f
 8006088:	d102      	bne.n	8006090 <gc_normalize_block+0x5c>
        block++;
 800608a:	687b      	ldr	r3, [r7, #4]
 800608c:	3301      	adds	r3, #1
 800608e:	607b      	str	r3, [r7, #4]

    s1 = s2 = block;
 8006090:	687b      	ldr	r3, [r7, #4]
 8006092:	61bb      	str	r3, [r7, #24]
 8006094:	69bb      	ldr	r3, [r7, #24]
 8006096:	61fb      	str	r3, [r7, #28]

    while((c = *s1) != '\0') {
 8006098:	e0a6      	b.n	80061e8 <gc_normalize_block+0x1b4>

        if(c > ' ') switch(c) {
 800609a:	7bfb      	ldrb	r3, [r7, #15]
 800609c:	2b20      	cmp	r3, #32
 800609e:	f240 808a 	bls.w	80061b6 <gc_normalize_block+0x182>
 80060a2:	7bfb      	ldrb	r3, [r7, #15]
 80060a4:	2b3b      	cmp	r3, #59	; 0x3b
 80060a6:	d006      	beq.n	80060b6 <gc_normalize_block+0x82>
 80060a8:	2b3b      	cmp	r3, #59	; 0x3b
 80060aa:	dc6d      	bgt.n	8006188 <gc_normalize_block+0x154>
 80060ac:	2b28      	cmp	r3, #40	; 0x28
 80060ae:	d009      	beq.n	80060c4 <gc_normalize_block+0x90>
 80060b0:	2b29      	cmp	r3, #41	; 0x29
 80060b2:	d00a      	beq.n	80060ca <gc_normalize_block+0x96>
 80060b4:	e068      	b.n	8006188 <gc_normalize_block+0x154>

            case ';':
                if(!comment) {
 80060b6:	697b      	ldr	r3, [r7, #20]
 80060b8:	2b00      	cmp	r3, #0
 80060ba:	d179      	bne.n	80061b0 <gc_normalize_block+0x17c>
                    *s1 = '\0';
 80060bc:	69fb      	ldr	r3, [r7, #28]
 80060be:	2200      	movs	r2, #0
 80060c0:	701a      	strb	r2, [r3, #0]
                    continue;
 80060c2:	e091      	b.n	80061e8 <gc_normalize_block+0x1b4>
                }
                break;

            case '(':
                // TODO: generate error if a left parenthesis is found inside a comment...
                comment = s1;
 80060c4:	69fb      	ldr	r3, [r7, #28]
 80060c6:	617b      	str	r3, [r7, #20]
                break;
 80060c8:	e075      	b.n	80061b6 <gc_normalize_block+0x182>

            case ')':
                if(comment && !gc_state.skip_blocks) {
 80060ca:	697b      	ldr	r3, [r7, #20]
 80060cc:	2b00      	cmp	r3, #0
 80060ce:	d058      	beq.n	8006182 <gc_normalize_block+0x14e>
 80060d0:	4b4e      	ldr	r3, [pc, #312]	; (800620c <gc_normalize_block+0x1d8>)
 80060d2:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
 80060d6:	f083 0301 	eor.w	r3, r3, #1
 80060da:	b2db      	uxtb	r3, r3
 80060dc:	2b00      	cmp	r3, #0
 80060de:	d050      	beq.n	8006182 <gc_normalize_block+0x14e>
                    *s1 = '\0';
 80060e0:	69fb      	ldr	r3, [r7, #28]
 80060e2:	2200      	movs	r2, #0
 80060e4:	701a      	strb	r2, [r3, #0]
                    if(!hal.driver_cap.no_gcode_message_handling) {
 80060e6:	4b4a      	ldr	r3, [pc, #296]	; (8006210 <gc_normalize_block+0x1dc>)
 80060e8:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 80060ec:	f003 0308 	and.w	r3, r3, #8
 80060f0:	b2db      	uxtb	r3, r3
 80060f2:	2b00      	cmp	r3, #0
 80060f4:	d133      	bne.n	800615e <gc_normalize_block+0x12a>

                        size_t len = s1 - comment - 4;
 80060f6:	69fa      	ldr	r2, [r7, #28]
 80060f8:	697b      	ldr	r3, [r7, #20]
 80060fa:	1ad3      	subs	r3, r2, r3
 80060fc:	3b04      	subs	r3, #4
 80060fe:	613b      	str	r3, [r7, #16]

                        if(message && *message == NULL && !strncmp(comment, "(MSG,", 5) && (*message = malloc(len))) {
 8006100:	683b      	ldr	r3, [r7, #0]
 8006102:	2b00      	cmp	r3, #0
 8006104:	d02b      	beq.n	800615e <gc_normalize_block+0x12a>
 8006106:	683b      	ldr	r3, [r7, #0]
 8006108:	681b      	ldr	r3, [r3, #0]
 800610a:	2b00      	cmp	r3, #0
 800610c:	d127      	bne.n	800615e <gc_normalize_block+0x12a>
 800610e:	2205      	movs	r2, #5
 8006110:	4940      	ldr	r1, [pc, #256]	; (8006214 <gc_normalize_block+0x1e0>)
 8006112:	6978      	ldr	r0, [r7, #20]
 8006114:	f01d fda3 	bl	8023c5e <strncmp>
 8006118:	4603      	mov	r3, r0
 800611a:	2b00      	cmp	r3, #0
 800611c:	d11f      	bne.n	800615e <gc_normalize_block+0x12a>
 800611e:	6938      	ldr	r0, [r7, #16]
 8006120:	f01d f9ca 	bl	80234b8 <malloc>
 8006124:	4603      	mov	r3, r0
 8006126:	461a      	mov	r2, r3
 8006128:	683b      	ldr	r3, [r7, #0]
 800612a:	601a      	str	r2, [r3, #0]
 800612c:	683b      	ldr	r3, [r7, #0]
 800612e:	681b      	ldr	r3, [r3, #0]
 8006130:	2b00      	cmp	r3, #0
 8006132:	d014      	beq.n	800615e <gc_normalize_block+0x12a>
                            comment += 5;
 8006134:	697b      	ldr	r3, [r7, #20]
 8006136:	3305      	adds	r3, #5
 8006138:	617b      	str	r3, [r7, #20]
                            // Trim leading spaces
                            while(*comment == ' ') {
 800613a:	e005      	b.n	8006148 <gc_normalize_block+0x114>
                                comment++;
 800613c:	697b      	ldr	r3, [r7, #20]
 800613e:	3301      	adds	r3, #1
 8006140:	617b      	str	r3, [r7, #20]
                                len--;
 8006142:	693b      	ldr	r3, [r7, #16]
 8006144:	3b01      	subs	r3, #1
 8006146:	613b      	str	r3, [r7, #16]
                            while(*comment == ' ') {
 8006148:	697b      	ldr	r3, [r7, #20]
 800614a:	781b      	ldrb	r3, [r3, #0]
 800614c:	2b20      	cmp	r3, #32
 800614e:	d0f5      	beq.n	800613c <gc_normalize_block+0x108>
                            }
                            memcpy(*message, comment, len);
 8006150:	683b      	ldr	r3, [r7, #0]
 8006152:	681b      	ldr	r3, [r3, #0]
 8006154:	693a      	ldr	r2, [r7, #16]
 8006156:	6979      	ldr	r1, [r7, #20]
 8006158:	4618      	mov	r0, r3
 800615a:	f01d feb8 	bl	8023ece <memcpy>
                            *comment = '\0'; // Do not generate grbl.on_gcode_comment event!
                        }
#endif // NGC_EXPRESSIONS_ENABLE
                    }

                    if(*comment && *message == NULL && grbl.on_gcode_comment)
 800615e:	697b      	ldr	r3, [r7, #20]
 8006160:	781b      	ldrb	r3, [r3, #0]
 8006162:	2b00      	cmp	r3, #0
 8006164:	d00d      	beq.n	8006182 <gc_normalize_block+0x14e>
 8006166:	683b      	ldr	r3, [r7, #0]
 8006168:	681b      	ldr	r3, [r3, #0]
 800616a:	2b00      	cmp	r3, #0
 800616c:	d109      	bne.n	8006182 <gc_normalize_block+0x14e>
 800616e:	4b2a      	ldr	r3, [pc, #168]	; (8006218 <gc_normalize_block+0x1e4>)
 8006170:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8006174:	2b00      	cmp	r3, #0
 8006176:	d004      	beq.n	8006182 <gc_normalize_block+0x14e>
                        grbl.on_gcode_comment(comment);
 8006178:	4b27      	ldr	r3, [pc, #156]	; (8006218 <gc_normalize_block+0x1e4>)
 800617a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800617e:	6978      	ldr	r0, [r7, #20]
 8006180:	4798      	blx	r3
                }
                comment = NULL;
 8006182:	2300      	movs	r3, #0
 8006184:	617b      	str	r3, [r7, #20]
                break;
 8006186:	e016      	b.n	80061b6 <gc_normalize_block+0x182>

            default:
                if(comment == NULL)
 8006188:	697b      	ldr	r3, [r7, #20]
 800618a:	2b00      	cmp	r3, #0
 800618c:	d112      	bne.n	80061b4 <gc_normalize_block+0x180>
                    *s2++ = CAPS(c);
 800618e:	7bfb      	ldrb	r3, [r7, #15]
 8006190:	2b60      	cmp	r3, #96	; 0x60
 8006192:	d907      	bls.n	80061a4 <gc_normalize_block+0x170>
 8006194:	7bfb      	ldrb	r3, [r7, #15]
 8006196:	2b7a      	cmp	r3, #122	; 0x7a
 8006198:	d804      	bhi.n	80061a4 <gc_normalize_block+0x170>
 800619a:	7bfb      	ldrb	r3, [r7, #15]
 800619c:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 80061a0:	b2da      	uxtb	r2, r3
 80061a2:	e000      	b.n	80061a6 <gc_normalize_block+0x172>
 80061a4:	7bfa      	ldrb	r2, [r7, #15]
 80061a6:	69bb      	ldr	r3, [r7, #24]
 80061a8:	1c59      	adds	r1, r3, #1
 80061aa:	61b9      	str	r1, [r7, #24]
 80061ac:	701a      	strb	r2, [r3, #0]
                break;
 80061ae:	e001      	b.n	80061b4 <gc_normalize_block+0x180>
                break;
 80061b0:	bf00      	nop
 80061b2:	e000      	b.n	80061b6 <gc_normalize_block+0x182>
                break;
 80061b4:	bf00      	nop

#if NGC_EXPRESSIONS_ENABLE
        if(comment && s1 - comment < (strncmp(comment, "(DEBU,", 5) ? 5 : 7))
            *s1 = CAPS(c);
#else
        if(comment && s1 - comment < 5)
 80061b6:	697b      	ldr	r3, [r7, #20]
 80061b8:	2b00      	cmp	r3, #0
 80061ba:	d012      	beq.n	80061e2 <gc_normalize_block+0x1ae>
 80061bc:	69fa      	ldr	r2, [r7, #28]
 80061be:	697b      	ldr	r3, [r7, #20]
 80061c0:	1ad3      	subs	r3, r2, r3
 80061c2:	2b04      	cmp	r3, #4
 80061c4:	dc0d      	bgt.n	80061e2 <gc_normalize_block+0x1ae>
            *s1 = CAPS(c);
 80061c6:	7bfb      	ldrb	r3, [r7, #15]
 80061c8:	2b60      	cmp	r3, #96	; 0x60
 80061ca:	d907      	bls.n	80061dc <gc_normalize_block+0x1a8>
 80061cc:	7bfb      	ldrb	r3, [r7, #15]
 80061ce:	2b7a      	cmp	r3, #122	; 0x7a
 80061d0:	d804      	bhi.n	80061dc <gc_normalize_block+0x1a8>
 80061d2:	7bfb      	ldrb	r3, [r7, #15]
 80061d4:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 80061d8:	b2db      	uxtb	r3, r3
 80061da:	e000      	b.n	80061de <gc_normalize_block+0x1aa>
 80061dc:	7bfb      	ldrb	r3, [r7, #15]
 80061de:	69fa      	ldr	r2, [r7, #28]
 80061e0:	7013      	strb	r3, [r2, #0]
#endif
        s1++;
 80061e2:	69fb      	ldr	r3, [r7, #28]
 80061e4:	3301      	adds	r3, #1
 80061e6:	61fb      	str	r3, [r7, #28]
    while((c = *s1) != '\0') {
 80061e8:	69fb      	ldr	r3, [r7, #28]
 80061ea:	781b      	ldrb	r3, [r3, #0]
 80061ec:	73fb      	strb	r3, [r7, #15]
 80061ee:	7bfb      	ldrb	r3, [r7, #15]
 80061f0:	2b00      	cmp	r3, #0
 80061f2:	f47f af52 	bne.w	800609a <gc_normalize_block+0x66>
    }

    *s2 = '\0';
 80061f6:	69bb      	ldr	r3, [r7, #24]
 80061f8:	2200      	movs	r2, #0
 80061fa:	701a      	strb	r2, [r3, #0]

    return block;
 80061fc:	687b      	ldr	r3, [r7, #4]
}
 80061fe:	4618      	mov	r0, r3
 8006200:	3720      	adds	r7, #32
 8006202:	46bd      	mov	sp, r7
 8006204:	bd80      	pop	{r7, pc}
 8006206:	bf00      	nop
 8006208:	20000d3c 	.word	0x20000d3c
 800620c:	20000bb0 	.word	0x20000bb0
 8006210:	20000ed0 	.word	0x20000ed0
 8006214:	08028a98 	.word	0x08028a98
 8006218:	20000dd4 	.word	0x20000dd4

0800621c <gc_execute_block>:
// Parses and executes one block (line) of 0-terminated G-Code.
// In this function, all units and positions are converted and exported to internal functions
// in terms of (mm, mm/min) and absolute machine coordinates, respectively.

status_code_t gc_execute_block (char *block)
{
 800621c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006220:	b0c9      	sub	sp, #292	; 0x124
 8006222:	af04      	add	r7, sp, #16
 8006224:	6178      	str	r0, [r7, #20]
       { &gc_block.values.xyz[Z_AXIS], ValueType_Float }
    };

#endif

    char *message = NULL;
 8006226:	2300      	movs	r3, #0
 8006228:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    block = gc_normalize_block(block, &message);
 800622c:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
 8006230:	4619      	mov	r1, r3
 8006232:	6978      	ldr	r0, [r7, #20]
 8006234:	f7ff fefe 	bl	8006034 <gc_normalize_block>
 8006238:	6178      	str	r0, [r7, #20]

    if(block[0] == '\0') {
 800623a:	697b      	ldr	r3, [r7, #20]
 800623c:	781b      	ldrb	r3, [r3, #0]
 800623e:	2b00      	cmp	r3, #0
 8006240:	d10b      	bne.n	800625a <gc_execute_block+0x3e>
        if(message)
 8006242:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8006246:	2b00      	cmp	r3, #0
 8006248:	d004      	beq.n	8006254 <gc_execute_block+0x38>
            output_message(message);
 800624a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800624e:	4618      	mov	r0, r3
 8006250:	f7ff fed0 	bl	8005ff4 <output_message>
        return Status_OK;
 8006254:	2300      	movs	r3, #0
 8006256:	f005 bad9 	b.w	800b80c <gc_execute_block+0x55f0>
    // Old comment from protocol.c:
    // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
    // where, during a program, the system auto-cycle start will continue to execute
    // everything until the next '%' sign. This will help fix resuming issues with certain
    // functions that empty the planner buffer to execute its task on-time.
    if (block[0] == CMD_PROGRAM_DEMARCATION && block[1] == '\0') {
 800625a:	697b      	ldr	r3, [r7, #20]
 800625c:	781b      	ldrb	r3, [r3, #0]
 800625e:	2b25      	cmp	r3, #37	; 0x25
 8006260:	d121      	bne.n	80062a6 <gc_execute_block+0x8a>
 8006262:	697b      	ldr	r3, [r7, #20]
 8006264:	3301      	adds	r3, #1
 8006266:	781b      	ldrb	r3, [r3, #0]
 8006268:	2b00      	cmp	r3, #0
 800626a:	d11c      	bne.n	80062a6 <gc_execute_block+0x8a>
        gc_state.file_run = !gc_state.file_run;
 800626c:	4b9c      	ldr	r3, [pc, #624]	; (80064e0 <gc_execute_block+0x2c4>)
 800626e:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8006272:	2b00      	cmp	r3, #0
 8006274:	bf14      	ite	ne
 8006276:	2301      	movne	r3, #1
 8006278:	2300      	moveq	r3, #0
 800627a:	b2db      	uxtb	r3, r3
 800627c:	f083 0301 	eor.w	r3, r3, #1
 8006280:	b2db      	uxtb	r3, r3
 8006282:	f003 0301 	and.w	r3, r3, #1
 8006286:	b2da      	uxtb	r2, r3
 8006288:	4b95      	ldr	r3, [pc, #596]	; (80064e0 <gc_execute_block+0x2c4>)
 800628a:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
        if(message)
 800628e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8006292:	2b00      	cmp	r3, #0
 8006294:	d004      	beq.n	80062a0 <gc_execute_block+0x84>
            output_message(message);
 8006296:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800629a:	4618      	mov	r0, r3
 800629c:	f7ff feaa 	bl	8005ff4 <output_message>
        return Status_OK;
 80062a0:	2300      	movs	r3, #0
 80062a2:	f005 bab3 	b.w	800b80c <gc_execute_block+0x55f0>
     updates these modes and commands as the block line is parsed and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

    memset(&gc_block, 0, sizeof(gc_block));                           // Initialize the parser block struct.
 80062a6:	22ac      	movs	r2, #172	; 0xac
 80062a8:	2100      	movs	r1, #0
 80062aa:	488e      	ldr	r0, [pc, #568]	; (80064e4 <gc_execute_block+0x2c8>)
 80062ac:	f01d fcb3 	bl	8023c16 <memset>
    memcpy(&gc_block.modal, &gc_state.modal, sizeof(gc_state.modal)); // Copy current modes
 80062b0:	4b8c      	ldr	r3, [pc, #560]	; (80064e4 <gc_execute_block+0x2c8>)
 80062b2:	4a8b      	ldr	r2, [pc, #556]	; (80064e0 <gc_execute_block+0x2c4>)
 80062b4:	f103 0408 	add.w	r4, r3, #8
 80062b8:	4615      	mov	r5, r2
 80062ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80062bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80062be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80062c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80062c2:	e895 0003 	ldmia.w	r5, {r0, r1}
 80062c6:	e884 0003 	stmia.w	r4, {r0, r1}

    bool set_tool = false, spindle_programmed = false;
 80062ca:	2300      	movs	r3, #0
 80062cc:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f
 80062d0:	2300      	movs	r3, #0
 80062d2:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
    axis_command_t axis_command = AxisCommand_None;
 80062d6:	2300      	movs	r3, #0
 80062d8:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
    io_mcode_t port_command = (io_mcode_t)0;
 80062dc:	2300      	movs	r3, #0
 80062de:	f887 310c 	strb.w	r3, [r7, #268]	; 0x10c
    plane_t plane;

    // Initialize bitflag tracking variables for axis indices compatible operations.
    axes_signals_t axis_words = {0}; // XYZ tracking
 80062e2:	2300      	movs	r3, #0
 80062e4:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
    ijk_words_t ijk_words = {0}; // IJK tracking
 80062e8:	2300      	movs	r3, #0
 80062ea:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

    // Initialize command and value words and parser flags variables.
    modal_groups_t command_words = {0};         // Bitfield for tracking G and M command words. Also used for modal group violations.
 80062ee:	2300      	movs	r3, #0
 80062f0:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    gc_parser_flags_t gc_parser_flags = {0};    // Parser flags for handling special cases.
 80062f4:	2300      	movs	r3, #0
 80062f6:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c
    static parameter_words_t user_words = {0};  // User M-code words "taken"

    // Determine if the line is a jogging motion or a normal g-code block.
    if (block[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 80062fa:	697b      	ldr	r3, [r7, #20]
 80062fc:	781b      	ldrb	r3, [r3, #0]
 80062fe:	2b24      	cmp	r3, #36	; 0x24
 8006300:	d113      	bne.n	800632a <gc_execute_block+0x10e>
        // Set G1 and G94 enforced modes to ensure accurate error checks.
        gc_parser_flags.jog_motion = On;
 8006302:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8006306:	f043 0301 	orr.w	r3, r3, #1
 800630a:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
        gc_block.modal.motion = MotionMode_Linear;
 800630e:	4b75      	ldr	r3, [pc, #468]	; (80064e4 <gc_execute_block+0x2c8>)
 8006310:	2201      	movs	r2, #1
 8006312:	811a      	strh	r2, [r3, #8]
        gc_block.modal.feed_mode = FeedMode_UnitsPerMin;
 8006314:	4b73      	ldr	r3, [pc, #460]	; (80064e4 <gc_execute_block+0x2c8>)
 8006316:	2200      	movs	r2, #0
 8006318:	729a      	strb	r2, [r3, #10]
        gc_block.modal.spindle.rpm_mode = SpindleSpeedMode_RPM;
 800631a:	4b72      	ldr	r3, [pc, #456]	; (80064e4 <gc_execute_block+0x2c8>)
 800631c:	2200      	movs	r2, #0
 800631e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
        gc_block.values.n = JOG_LINE_NUMBER; // Initialize default line number reported during jog.
 8006322:	4b70      	ldr	r3, [pc, #448]	; (80064e4 <gc_execute_block+0x2c8>)
 8006324:	2200      	movs	r2, #0
 8006326:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
     STEP 2: Import all g-code words in the block. A g-code word is a letter followed by
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also,
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */

    uint_fast8_t char_counter = gc_parser_flags.jog_motion ? 3 /* Start parsing after `$J=` */ : 0;
 800632a:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800632e:	f003 0301 	and.w	r3, r3, #1
 8006332:	b2db      	uxtb	r3, r3
 8006334:	2b00      	cmp	r3, #0
 8006336:	d001      	beq.n	800633c <gc_execute_block+0x120>
 8006338:	2303      	movs	r3, #3
 800633a:	e000      	b.n	800633e <gc_execute_block+0x122>
 800633c:	2300      	movs	r3, #0
 800633e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    char letter;
    float value;
    uint32_t int_value = 0;
 8006342:	2300      	movs	r3, #0
 8006344:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    uint_fast16_t mantissa = 0;
 8006348:	2300      	movs	r3, #0
 800634a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    bool is_user_mcode = false;
 800634e:	2300      	movs	r3, #0
 8006350:	f887 3103 	strb.w	r3, [r7, #259]	; 0x103
    word_bit_t word_bit = { .parameter = {0}, .modal_group = {0} }; // Bit-value for assigning tracking variables
 8006354:	2300      	movs	r3, #0
 8006356:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800635a:	2300      	movs	r3, #0
 800635c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 8006360:	f001 b895 	b.w	800748e <gc_execute_block+0x1272>
        if(!is_user_mcode && isnanf(value))
            FAIL(Status_BadNumberFormat);   // [Expected word value]

#else

        if((letter < 'A' && letter != '$') || letter > 'Z')
 8006364:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 8006368:	2b40      	cmp	r3, #64	; 0x40
 800636a:	d803      	bhi.n	8006374 <gc_execute_block+0x158>
 800636c:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 8006370:	2b24      	cmp	r3, #36	; 0x24
 8006372:	d103      	bne.n	800637c <gc_execute_block+0x160>
 8006374:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 8006378:	2b5a      	cmp	r3, #90	; 0x5a
 800637a:	d902      	bls.n	8006382 <gc_execute_block+0x166>
            FAIL(Status_ExpectedCommandLetter); // [Expected word letter]
 800637c:	2301      	movs	r3, #1
 800637e:	f005 ba45 	b.w	800b80c <gc_execute_block+0x55f0>

        if (!read_float(block, &char_counter, &value)) {
 8006382:	f107 0294 	add.w	r2, r7, #148	; 0x94
 8006386:	f107 0398 	add.w	r3, r7, #152	; 0x98
 800638a:	4619      	mov	r1, r3
 800638c:	6978      	ldr	r0, [r7, #20]
 800638e:	f00a f911 	bl	80105b4 <read_float>
 8006392:	4603      	mov	r3, r0
 8006394:	f083 0301 	eor.w	r3, r3, #1
 8006398:	b2db      	uxtb	r3, r3
 800639a:	2b00      	cmp	r3, #0
 800639c:	d00a      	beq.n	80063b4 <gc_execute_block+0x198>
            if(is_user_mcode)                   // Valueless parameters allowed for user defined M-codes.
 800639e:	f897 3103 	ldrb.w	r3, [r7, #259]	; 0x103
 80063a2:	2b00      	cmp	r3, #0
 80063a4:	d003      	beq.n	80063ae <gc_execute_block+0x192>
                value = NAN;                    // Parameter validation deferred to implementation.
 80063a6:	4b50      	ldr	r3, [pc, #320]	; (80064e8 <gc_execute_block+0x2cc>)
 80063a8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 80063ac:	e002      	b.n	80063b4 <gc_execute_block+0x198>
            else
                FAIL(Status_BadNumberFormat);   // [Expected word value]
 80063ae:	2302      	movs	r3, #2
 80063b0:	f005 ba2c 	b.w	800b80c <gc_execute_block+0x55f0>
        // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
        // accurate enough for value words that require integers to within 0.0001. This should be
        // a good enough compromise and catch most all non-integer errors. To make it compliant,
        // we would simply need to change the mantissa to int16, but this add compiled flash space.
        // Maybe update this later.
        if(isnan(value))
 80063b4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80063b8:	4619      	mov	r1, r3
 80063ba:	4618      	mov	r0, r3
 80063bc:	f7fa fec0 	bl	8001140 <__aeabi_fcmpun>
 80063c0:	4603      	mov	r3, r0
 80063c2:	2b00      	cmp	r3, #0
 80063c4:	d003      	beq.n	80063ce <gc_execute_block+0x1b2>
            mantissa = 0;
 80063c6:	2300      	movs	r3, #0
 80063c8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 80063cc:	e026      	b.n	800641c <gc_execute_block+0x200>
        else {
            int_value = (uint32_t)truncf(value);
 80063ce:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80063d2:	4618      	mov	r0, r3
 80063d4:	f01e fd0e 	bl	8024df4 <truncf>
 80063d8:	4603      	mov	r3, r0
 80063da:	4618      	mov	r0, r3
 80063dc:	f7fa feec 	bl	80011b8 <__aeabi_f2uiz>
 80063e0:	4603      	mov	r3, r0
 80063e2:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
            mantissa = (uint_fast16_t)roundf(100.0f * (value - int_value));
 80063e6:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
 80063ea:	f8d7 0108 	ldr.w	r0, [r7, #264]	; 0x108
 80063ee:	f7fa fc89 	bl	8000d04 <__aeabi_ui2f>
 80063f2:	4603      	mov	r3, r0
 80063f4:	4619      	mov	r1, r3
 80063f6:	4620      	mov	r0, r4
 80063f8:	f7fa fbd2 	bl	8000ba0 <__aeabi_fsub>
 80063fc:	4603      	mov	r3, r0
 80063fe:	493b      	ldr	r1, [pc, #236]	; (80064ec <gc_execute_block+0x2d0>)
 8006400:	4618      	mov	r0, r3
 8006402:	f7fa fcd7 	bl	8000db4 <__aeabi_fmul>
 8006406:	4603      	mov	r3, r0
 8006408:	4618      	mov	r0, r3
 800640a:	f01e fccf 	bl	8024dac <roundf>
 800640e:	4603      	mov	r3, r0
 8006410:	4618      	mov	r0, r3
 8006412:	f7fa fed1 	bl	80011b8 <__aeabi_f2uiz>
 8006416:	4603      	mov	r3, r0
 8006418:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        }
        // NOTE: Rounding must be used to catch small floating point errors.

        // Check if the g-code word is supported or errors due to modal group violations or has
        // been repeated in the g-code block. If ok, update the command or record its value.
        switch(letter) {
 800641c:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 8006420:	2b47      	cmp	r3, #71	; 0x47
 8006422:	d004      	beq.n	800642e <gc_execute_block+0x212>
 8006424:	2b4d      	cmp	r3, #77	; 0x4d
 8006426:	f000 837d 	beq.w	8006b24 <gc_execute_block+0x908>
 800642a:	f000 be0f 	b.w	800704c <gc_execute_block+0xe30>
          /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
             NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

            case 'G': // Determine 'G' command and its modal group

                is_user_mcode = false;
 800642e:	2300      	movs	r3, #0
 8006430:	f887 3103 	strb.w	r3, [r7, #259]	; 0x103
                word_bit.modal_group.mask = 0;
 8006434:	2300      	movs	r3, #0
 8006436:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800643a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800643e:	2b63      	cmp	r3, #99	; 0x63
 8006440:	f200 834c 	bhi.w	8006adc <gc_execute_block+0x8c0>
 8006444:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006448:	2b5a      	cmp	r3, #90	; 0x5a
 800644a:	d205      	bcs.n	8006458 <gc_execute_block+0x23c>
 800644c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006450:	2b41      	cmp	r3, #65	; 0x41
 8006452:	f200 80db 	bhi.w	800660c <gc_execute_block+0x3f0>
 8006456:	e04d      	b.n	80064f4 <gc_execute_block+0x2d8>
 8006458:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800645c:	3b5a      	subs	r3, #90	; 0x5a
 800645e:	2b09      	cmp	r3, #9
 8006460:	f200 833c 	bhi.w	8006adc <gc_execute_block+0x8c0>
 8006464:	a201      	add	r2, pc, #4	; (adr r2, 800646c <gc_execute_block+0x250>)
 8006466:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800646a:	bf00      	nop
 800646c:	0800686b 	.word	0x0800686b
 8006470:	0800686b 	.word	0x0800686b
 8006474:	08006651 	.word	0x08006651
 8006478:	080068bd 	.word	0x080068bd
 800647c:	080068bd 	.word	0x080068bd
 8006480:	080068db 	.word	0x080068db
 8006484:	08006a65 	.word	0x08006a65
 8006488:	08006a65 	.word	0x08006a65
 800648c:	08006a97 	.word	0x08006a97
 8006490:	08006a97 	.word	0x08006a97
 8006494:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006498:	3b49      	subs	r3, #73	; 0x49
 800649a:	2201      	movs	r2, #1
 800649c:	fa02 f303 	lsl.w	r3, r2, r3
 80064a0:	4a13      	ldr	r2, [pc, #76]	; (80064f0 <gc_execute_block+0x2d4>)
 80064a2:	401a      	ands	r2, r3
 80064a4:	2a00      	cmp	r2, #0
 80064a6:	bf14      	ite	ne
 80064a8:	2201      	movne	r2, #1
 80064aa:	2200      	moveq	r2, #0
 80064ac:	b2d2      	uxtb	r2, r2
 80064ae:	2a00      	cmp	r2, #0
 80064b0:	f040 81a4 	bne.w	80067fc <gc_execute_block+0x5e0>
 80064b4:	f003 0280 	and.w	r2, r3, #128	; 0x80
 80064b8:	2a00      	cmp	r2, #0
 80064ba:	bf14      	ite	ne
 80064bc:	2201      	movne	r2, #1
 80064be:	2200      	moveq	r2, #0
 80064c0:	b2d2      	uxtb	r2, r2
 80064c2:	2a00      	cmp	r2, #0
 80064c4:	f040 8174 	bne.w	80067b0 <gc_execute_block+0x594>
 80064c8:	f003 0308 	and.w	r3, r3, #8
 80064cc:	2b00      	cmp	r3, #0
 80064ce:	bf14      	ite	ne
 80064d0:	2301      	movne	r3, #1
 80064d2:	2300      	moveq	r3, #0
 80064d4:	b2db      	uxtb	r3, r3
 80064d6:	2b00      	cmp	r3, #0
 80064d8:	f040 8118 	bne.w	800670c <gc_execute_block+0x4f0>
 80064dc:	e2fe      	b.n	8006adc <gc_execute_block+0x8c0>
 80064de:	bf00      	nop
 80064e0:	20000bb0 	.word	0x20000bb0
 80064e4:	20000c8c 	.word	0x20000c8c
 80064e8:	7fc00000 	.word	0x7fc00000
 80064ec:	42c80000 	.word	0x42c80000
 80064f0:	00013701 	.word	0x00013701
 80064f4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80064f8:	2b41      	cmp	r3, #65	; 0x41
 80064fa:	f200 82ef 	bhi.w	8006adc <gc_execute_block+0x8c0>
 80064fe:	a201      	add	r2, pc, #4	; (adr r2, 8006504 <gc_execute_block+0x2e8>)
 8006500:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006504:	0800679d 	.word	0x0800679d
 8006508:	0800679d 	.word	0x0800679d
 800650c:	0800679d 	.word	0x0800679d
 8006510:	0800679d 	.word	0x0800679d
 8006514:	0800666d 	.word	0x0800666d
 8006518:	0800679d 	.word	0x0800679d
 800651c:	08006add 	.word	0x08006add
 8006520:	08006623 	.word	0x08006623
 8006524:	08006623 	.word	0x08006623
 8006528:	08006add 	.word	0x08006add
 800652c:	08006651 	.word	0x08006651
 8006530:	08006add 	.word	0x08006add
 8006534:	08006add 	.word	0x08006add
 8006538:	08006add 	.word	0x08006add
 800653c:	08006add 	.word	0x08006add
 8006540:	08006add 	.word	0x08006add
 8006544:	08006add 	.word	0x08006add
 8006548:	0800684f 	.word	0x0800684f
 800654c:	0800684f 	.word	0x0800684f
 8006550:	0800684f 	.word	0x0800684f
 8006554:	080068ef 	.word	0x080068ef
 8006558:	080068ef 	.word	0x080068ef
 800655c:	08006add 	.word	0x08006add
 8006560:	08006add 	.word	0x08006add
 8006564:	08006add 	.word	0x08006add
 8006568:	08006add 	.word	0x08006add
 800656c:	08006add 	.word	0x08006add
 8006570:	08006add 	.word	0x08006add
 8006574:	08006651 	.word	0x08006651
 8006578:	08006add 	.word	0x08006add
 800657c:	08006651 	.word	0x08006651
 8006580:	08006add 	.word	0x08006add
 8006584:	08006add 	.word	0x08006add
 8006588:	0800670d 	.word	0x0800670d
 800658c:	08006add 	.word	0x08006add
 8006590:	08006add 	.word	0x08006add
 8006594:	08006add 	.word	0x08006add
 8006598:	08006add 	.word	0x08006add
 800659c:	0800674f 	.word	0x0800674f
 80065a0:	08006add 	.word	0x08006add
 80065a4:	0800690f 	.word	0x0800690f
 80065a8:	08006add 	.word	0x08006add
 80065ac:	08006add 	.word	0x08006add
 80065b0:	08006931 	.word	0x08006931
 80065b4:	08006add 	.word	0x08006add
 80065b8:	08006add 	.word	0x08006add
 80065bc:	08006add 	.word	0x08006add
 80065c0:	08006add 	.word	0x08006add
 80065c4:	08006add 	.word	0x08006add
 80065c8:	08006931 	.word	0x08006931
 80065cc:	08006ab5 	.word	0x08006ab5
 80065d0:	08006ab5 	.word	0x08006ab5
 80065d4:	08006add 	.word	0x08006add
 80065d8:	0800666d 	.word	0x0800666d
 80065dc:	080069af 	.word	0x080069af
 80065e0:	080069af 	.word	0x080069af
 80065e4:	080069af 	.word	0x080069af
 80065e8:	080069af 	.word	0x080069af
 80065ec:	080069af 	.word	0x080069af
 80065f0:	080069af 	.word	0x080069af
 80065f4:	08006add 	.word	0x08006add
 80065f8:	08006a1d 	.word	0x08006a1d
 80065fc:	08006add 	.word	0x08006add
 8006600:	08006add 	.word	0x08006add
 8006604:	08006add 	.word	0x08006add
 8006608:	08006a37 	.word	0x08006a37
 800660c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006610:	2b59      	cmp	r3, #89	; 0x59
 8006612:	f200 8263 	bhi.w	8006adc <gc_execute_block+0x8c0>
 8006616:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800661a:	2b49      	cmp	r3, #73	; 0x49
 800661c:	f4bf af3a 	bcs.w	8006494 <gc_execute_block+0x278>
 8006620:	e25c      	b.n	8006adc <gc_execute_block+0x8c0>

                switch(int_value) {

                    case 7: case 8:
                        if(settings.mode == Mode_Lathe) {
 8006622:	4bbe      	ldr	r3, [pc, #760]	; (800691c <gc_execute_block+0x700>)
 8006624:	7e1b      	ldrb	r3, [r3, #24]
 8006626:	2b02      	cmp	r3, #2
 8006628:	d10f      	bne.n	800664a <gc_execute_block+0x42e>
                            word_bit.modal_group.G15 = On;
 800662a:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 800662e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006632:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                            gc_block.modal.diameter_mode = int_value == 7; // TODO: find specs for implementation, only affects X calculation? reporting? current position?
 8006636:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800663a:	2b07      	cmp	r3, #7
 800663c:	bf0c      	ite	eq
 800663e:	2301      	moveq	r3, #1
 8006640:	2300      	movne	r3, #0
 8006642:	b2da      	uxtb	r2, r3
 8006644:	4bb6      	ldr	r3, [pc, #728]	; (8006920 <gc_execute_block+0x704>)
 8006646:	735a      	strb	r2, [r3, #13]
                        } else
                            FAIL(Status_GcodeUnsupportedCommand); // [G7 & G8 not supported]
                        break;
 8006648:	e252      	b.n	8006af0 <gc_execute_block+0x8d4>
                            FAIL(Status_GcodeUnsupportedCommand); // [G7 & G8 not supported]
 800664a:	2314      	movs	r3, #20
 800664c:	f005 b8de 	b.w	800b80c <gc_execute_block+0x55f0>

                    case 10: case 28: case 30: case 92:
                        // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
                        // * G43.1 is also an axis command but is not explicitly defined this way.
                        if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
 8006650:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006654:	2b00      	cmp	r3, #0
 8006656:	d109      	bne.n	800666c <gc_execute_block+0x450>
                            if (axis_command)
 8006658:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800665c:	2b00      	cmp	r3, #0
 800665e:	d002      	beq.n	8006666 <gc_execute_block+0x44a>
                                FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 8006660:	2318      	movs	r3, #24
 8006662:	f005 b8d3 	b.w	800b80c <gc_execute_block+0x55f0>
                            axis_command = AxisCommand_NonModal;
 8006666:	2301      	movs	r3, #1
 8006668:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                        }
                        // No break. Continues to next line.

                    case 4: case 53:
                        word_bit.modal_group.G0 = On;
 800666c:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006670:	f043 0301 	orr.w	r3, r3, #1
 8006674:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8006678:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800667c:	b2da      	uxtb	r2, r3
 800667e:	4ba8      	ldr	r3, [pc, #672]	; (8006920 <gc_execute_block+0x704>)
 8006680:	701a      	strb	r2, [r3, #0]
                        if ((int_value == 28) || (int_value == 30)) {
 8006682:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006686:	2b1c      	cmp	r3, #28
 8006688:	d003      	beq.n	8006692 <gc_execute_block+0x476>
 800668a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800668e:	2b1e      	cmp	r3, #30
 8006690:	d117      	bne.n	80066c2 <gc_execute_block+0x4a6>
                            if (!((mantissa == 0) || (mantissa == 10)))
 8006692:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006696:	2b00      	cmp	r3, #0
 8006698:	d006      	beq.n	80066a8 <gc_execute_block+0x48c>
 800669a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800669e:	2b0a      	cmp	r3, #10
 80066a0:	d002      	beq.n	80066a8 <gc_execute_block+0x48c>
                                FAIL(Status_GcodeUnsupportedCommand);
 80066a2:	2314      	movs	r3, #20
 80066a4:	f005 b8b2 	b.w	800b80c <gc_execute_block+0x55f0>
                            gc_block.non_modal_command += mantissa;
 80066a8:	4b9d      	ldr	r3, [pc, #628]	; (8006920 <gc_execute_block+0x704>)
 80066aa:	781a      	ldrb	r2, [r3, #0]
 80066ac:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066b0:	b2db      	uxtb	r3, r3
 80066b2:	4413      	add	r3, r2
 80066b4:	b2da      	uxtb	r2, r3
 80066b6:	4b9a      	ldr	r3, [pc, #616]	; (8006920 <gc_execute_block+0x704>)
 80066b8:	701a      	strb	r2, [r3, #0]
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 80066ba:	2300      	movs	r3, #0
 80066bc:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                            if (!((mantissa == 0) || (mantissa == 10) || (mantissa == 20) || (mantissa == 30)))
                                FAIL(Status_GcodeUnsupportedCommand);
                            gc_block.non_modal_command += mantissa;
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
                        }
                        break;
 80066c0:	e20f      	b.n	8006ae2 <gc_execute_block+0x8c6>
                        } else if (int_value == 92) {
 80066c2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80066c6:	2b5c      	cmp	r3, #92	; 0x5c
 80066c8:	f040 820b 	bne.w	8006ae2 <gc_execute_block+0x8c6>
                            if (!((mantissa == 0) || (mantissa == 10) || (mantissa == 20) || (mantissa == 30)))
 80066cc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066d0:	2b00      	cmp	r3, #0
 80066d2:	d00e      	beq.n	80066f2 <gc_execute_block+0x4d6>
 80066d4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066d8:	2b0a      	cmp	r3, #10
 80066da:	d00a      	beq.n	80066f2 <gc_execute_block+0x4d6>
 80066dc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066e0:	2b14      	cmp	r3, #20
 80066e2:	d006      	beq.n	80066f2 <gc_execute_block+0x4d6>
 80066e4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066e8:	2b1e      	cmp	r3, #30
 80066ea:	d002      	beq.n	80066f2 <gc_execute_block+0x4d6>
                                FAIL(Status_GcodeUnsupportedCommand);
 80066ec:	2314      	movs	r3, #20
 80066ee:	f005 b88d 	b.w	800b80c <gc_execute_block+0x55f0>
                            gc_block.non_modal_command += mantissa;
 80066f2:	4b8b      	ldr	r3, [pc, #556]	; (8006920 <gc_execute_block+0x704>)
 80066f4:	781a      	ldrb	r2, [r3, #0]
 80066f6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80066fa:	b2db      	uxtb	r3, r3
 80066fc:	4413      	add	r3, r2
 80066fe:	b2da      	uxtb	r2, r3
 8006700:	4b87      	ldr	r3, [pc, #540]	; (8006920 <gc_execute_block+0x704>)
 8006702:	701a      	strb	r2, [r3, #0]
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8006704:	2300      	movs	r3, #0
 8006706:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                        break;
 800670a:	e1ea      	b.n	8006ae2 <gc_execute_block+0x8c6>

                    case 33: case 76:
                        if(mantissa != 0)
 800670c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006710:	2b00      	cmp	r3, #0
 8006712:	d002      	beq.n	800671a <gc_execute_block+0x4fe>
                            FAIL(Status_GcodeUnsupportedCommand); // [G33.1 not yet supported]
 8006714:	2314      	movs	r3, #20
 8006716:	f005 b879 	b.w	800b80c <gc_execute_block+0x55f0>
                        if (axis_command)
 800671a:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800671e:	2b00      	cmp	r3, #0
 8006720:	d002      	beq.n	8006728 <gc_execute_block+0x50c>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 8006722:	2318      	movs	r3, #24
 8006724:	f005 b872 	b.w	800b80c <gc_execute_block+0x55f0>
                        axis_command = AxisCommand_MotionMode;
 8006728:	2302      	movs	r3, #2
 800672a:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                        word_bit.modal_group.G1 = On;
 800672e:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006732:	f043 0302 	orr.w	r3, r3, #2
 8006736:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.motion = (motion_mode_t)int_value;
 800673a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800673e:	b29a      	uxth	r2, r3
 8006740:	4b77      	ldr	r3, [pc, #476]	; (8006920 <gc_execute_block+0x704>)
 8006742:	811a      	strh	r2, [r3, #8]
//                        if(mantissa == 10)
//                            gc_block.modal.motion = MotionMode_RigidTapping;
                        gc_block.modal.canned_cycle_active = false;
 8006744:	4b76      	ldr	r3, [pc, #472]	; (8006920 <gc_execute_block+0x704>)
 8006746:	2200      	movs	r2, #0
 8006748:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
                        break;
 800674c:	e1d0      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 38:
                        if(!(hal.probe.get_state && ((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))))
 800674e:	4b75      	ldr	r3, [pc, #468]	; (8006924 <gc_execute_block+0x708>)
 8006750:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8006754:	2b00      	cmp	r3, #0
 8006756:	d00f      	beq.n	8006778 <gc_execute_block+0x55c>
 8006758:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800675c:	2b14      	cmp	r3, #20
 800675e:	d00e      	beq.n	800677e <gc_execute_block+0x562>
 8006760:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006764:	2b1e      	cmp	r3, #30
 8006766:	d00a      	beq.n	800677e <gc_execute_block+0x562>
 8006768:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800676c:	2b28      	cmp	r3, #40	; 0x28
 800676e:	d006      	beq.n	800677e <gc_execute_block+0x562>
 8006770:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006774:	2b32      	cmp	r3, #50	; 0x32
 8006776:	d002      	beq.n	800677e <gc_execute_block+0x562>
                            FAIL(Status_GcodeUnsupportedCommand); // [probing not supported by driver or unsupported G38.x command]
 8006778:	2314      	movs	r3, #20
 800677a:	f005 b847 	b.w	800b80c <gc_execute_block+0x55f0>
                        int_value += (mantissa / 10) + 100;
 800677e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006782:	4a69      	ldr	r2, [pc, #420]	; (8006928 <gc_execute_block+0x70c>)
 8006784:	fba2 2303 	umull	r2, r3, r2, r3
 8006788:	08da      	lsrs	r2, r3, #3
 800678a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800678e:	4413      	add	r3, r2
 8006790:	3364      	adds	r3, #100	; 0x64
 8006792:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8006796:	2300      	movs	r3, #0
 8006798:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                        //  No break. Continues to next line.

                    case 0: case 1: case 2: case 3: case 5:
                        // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
                        // * G43.1 is also an axis command but is not explicitly defined this way.
                        if (axis_command)
 800679c:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 80067a0:	2b00      	cmp	r3, #0
 80067a2:	d002      	beq.n	80067aa <gc_execute_block+0x58e>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 80067a4:	2318      	movs	r3, #24
 80067a6:	f005 b831 	b.w	800b80c <gc_execute_block+0x55f0>
                        axis_command = AxisCommand_MotionMode;
 80067aa:	2302      	movs	r3, #2
 80067ac:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                        // No break. Continues to next line.

                    case 80:
                        word_bit.modal_group.G1 = On;
 80067b0:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 80067b4:	f043 0302 	orr.w	r3, r3, #2
 80067b8:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        if(int_value == 5 && mantissa != 0) {
 80067bc:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80067c0:	2b05      	cmp	r3, #5
 80067c2:	d111      	bne.n	80067e8 <gc_execute_block+0x5cc>
 80067c4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80067c8:	2b00      	cmp	r3, #0
 80067ca:	d00d      	beq.n	80067e8 <gc_execute_block+0x5cc>
                            if(mantissa == 10) {
 80067cc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80067d0:	2b0a      	cmp	r3, #10
 80067d2:	d106      	bne.n	80067e2 <gc_execute_block+0x5c6>
                                gc_block.modal.motion = MotionMode_QuadraticSpline;
 80067d4:	4b52      	ldr	r3, [pc, #328]	; (8006920 <gc_execute_block+0x704>)
 80067d6:	2233      	movs	r2, #51	; 0x33
 80067d8:	811a      	strh	r2, [r3, #8]
                                mantissa = 0; // Set to zero to indicate valid non-integer G command.
 80067da:	2300      	movs	r3, #0
 80067dc:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                            if(mantissa == 10) {
 80067e0:	e007      	b.n	80067f2 <gc_execute_block+0x5d6>
                            } else
                                FAIL(Status_GcodeUnsupportedCommand);
 80067e2:	2314      	movs	r3, #20
 80067e4:	f005 b812 	b.w	800b80c <gc_execute_block+0x55f0>
                        } else
                            gc_block.modal.motion = (motion_mode_t)int_value;
 80067e8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80067ec:	b29a      	uxth	r2, r3
 80067ee:	4b4c      	ldr	r3, [pc, #304]	; (8006920 <gc_execute_block+0x704>)
 80067f0:	811a      	strh	r2, [r3, #8]
                        gc_block.modal.canned_cycle_active = false;
 80067f2:	4b4b      	ldr	r3, [pc, #300]	; (8006920 <gc_execute_block+0x704>)
 80067f4:	2200      	movs	r2, #0
 80067f6:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
                        break;
 80067fa:	e179      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 73: case 81: case 82: case 83: case 85: case 86: case 89:
                        if (axis_command)
 80067fc:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8006800:	2b00      	cmp	r3, #0
 8006802:	d002      	beq.n	800680a <gc_execute_block+0x5ee>
                            FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict]
 8006804:	2318      	movs	r3, #24
 8006806:	f005 b801 	b.w	800b80c <gc_execute_block+0x55f0>
                        axis_command = AxisCommand_MotionMode;
 800680a:	2302      	movs	r3, #2
 800680c:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                        word_bit.modal_group.G1 = On;
 8006810:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006814:	f043 0302 	orr.w	r3, r3, #2
 8006818:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.canned_cycle_active = true;
 800681c:	4b40      	ldr	r3, [pc, #256]	; (8006920 <gc_execute_block+0x704>)
 800681e:	2201      	movs	r2, #1
 8006820:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8006824:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006828:	b29a      	uxth	r2, r3
 800682a:	4b3d      	ldr	r3, [pc, #244]	; (8006920 <gc_execute_block+0x704>)
 800682c:	811a      	strh	r2, [r3, #8]
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 800682e:	4b3c      	ldr	r3, [pc, #240]	; (8006920 <gc_execute_block+0x704>)
 8006830:	891a      	ldrh	r2, [r3, #8]
 8006832:	4b3e      	ldr	r3, [pc, #248]	; (800692c <gc_execute_block+0x710>)
 8006834:	881b      	ldrh	r3, [r3, #0]
 8006836:	429a      	cmp	r2, r3
 8006838:	bf14      	ite	ne
 800683a:	2301      	movne	r3, #1
 800683c:	2300      	moveq	r3, #0
 800683e:	b2da      	uxtb	r2, r3
 8006840:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8006844:	f362 0341 	bfi	r3, r2, #1, #1
 8006848:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
                        break;
 800684c:	e150      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 17: case 18: case 19:
                        word_bit.modal_group.G2 = On;
 800684e:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006852:	f043 0304 	orr.w	r3, r3, #4
 8006856:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.plane_select = (plane_select_t)(int_value - 17);
 800685a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800685e:	b2db      	uxtb	r3, r3
 8006860:	3b11      	subs	r3, #17
 8006862:	b2da      	uxtb	r2, r3
 8006864:	4b2e      	ldr	r3, [pc, #184]	; (8006920 <gc_execute_block+0x704>)
 8006866:	739a      	strb	r2, [r3, #14]
                        break;
 8006868:	e142      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 90: case 91:
                        if (mantissa == 0) {
 800686a:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800686e:	2b00      	cmp	r3, #0
 8006870:	d10f      	bne.n	8006892 <gc_execute_block+0x676>
                            word_bit.modal_group.G3 = On;
 8006872:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006876:	f043 0308 	orr.w	r3, r3, #8
 800687a:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                            gc_block.modal.distance_incremental = int_value == 91;
 800687e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006882:	2b5b      	cmp	r3, #91	; 0x5b
 8006884:	bf0c      	ite	eq
 8006886:	2301      	moveq	r3, #1
 8006888:	2300      	movne	r3, #0
 800688a:	b2da      	uxtb	r2, r3
 800688c:	4b24      	ldr	r3, [pc, #144]	; (8006920 <gc_execute_block+0x704>)
 800688e:	731a      	strb	r2, [r3, #12]
                            if ((mantissa != 10) || (int_value == 90))
                                FAIL(Status_GcodeUnsupportedCommand); // [G90.1 not supported]
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
                            // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
                        }
                        break;
 8006890:	e12e      	b.n	8006af0 <gc_execute_block+0x8d4>
                            word_bit.modal_group.G4 = On;
 8006892:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006896:	f043 0310 	orr.w	r3, r3, #16
 800689a:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                            if ((mantissa != 10) || (int_value == 90))
 800689e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80068a2:	2b0a      	cmp	r3, #10
 80068a4:	d103      	bne.n	80068ae <gc_execute_block+0x692>
 80068a6:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80068aa:	2b5a      	cmp	r3, #90	; 0x5a
 80068ac:	d102      	bne.n	80068b4 <gc_execute_block+0x698>
                                FAIL(Status_GcodeUnsupportedCommand); // [G90.1 not supported]
 80068ae:	2314      	movs	r3, #20
 80068b0:	f004 bfac 	b.w	800b80c <gc_execute_block+0x55f0>
                            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 80068b4:	2300      	movs	r3, #0
 80068b6:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                        break;
 80068ba:	e119      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 93: case 94:
                        word_bit.modal_group.G5 = On;
 80068bc:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 80068c0:	f043 0320 	orr.w	r3, r3, #32
 80068c4:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.feed_mode = (feed_mode_t)(94 - int_value);
 80068c8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80068cc:	b2db      	uxtb	r3, r3
 80068ce:	f1c3 035e 	rsb	r3, r3, #94	; 0x5e
 80068d2:	b2da      	uxtb	r2, r3
 80068d4:	4b12      	ldr	r3, [pc, #72]	; (8006920 <gc_execute_block+0x704>)
 80068d6:	729a      	strb	r2, [r3, #10]
                        break;
 80068d8:	e10a      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 95:
                        word_bit.modal_group.G5 = On;
 80068da:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 80068de:	f043 0320 	orr.w	r3, r3, #32
 80068e2:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.feed_mode = FeedMode_UnitsPerRev;
 80068e6:	4b0e      	ldr	r3, [pc, #56]	; (8006920 <gc_execute_block+0x704>)
 80068e8:	2202      	movs	r2, #2
 80068ea:	729a      	strb	r2, [r3, #10]
                        break;
 80068ec:	e100      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 20: case 21:
                        word_bit.modal_group.G6 = On;
 80068ee:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 80068f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80068f6:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.modal.units_imperial = int_value == 20;
 80068fa:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80068fe:	2b14      	cmp	r3, #20
 8006900:	bf0c      	ite	eq
 8006902:	2301      	moveq	r3, #1
 8006904:	2300      	movne	r3, #0
 8006906:	b2da      	uxtb	r2, r3
 8006908:	4b05      	ldr	r3, [pc, #20]	; (8006920 <gc_execute_block+0x704>)
 800690a:	72da      	strb	r2, [r3, #11]
                        break;
 800690c:	e0f0      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 40:
                        word_bit.modal_group.G7 = On;
 800690e:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006912:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006916:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        // NOTE: Not required since cutter radius compensation is always disabled. Only here
                        // to support G40 commands that often appear in g-code program headers to setup defaults.
                        // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
                        break;
 800691a:	e0e9      	b.n	8006af0 <gc_execute_block+0x8d4>
 800691c:	2000147c 	.word	0x2000147c
 8006920:	20000c8c 	.word	0x20000c8c
 8006924:	20000ed0 	.word	0x20000ed0
 8006928:	cccccccd 	.word	0xcccccccd
 800692c:	20000bb0 	.word	0x20000bb0

                    case 43: case 49:
                        word_bit.modal_group.G8 = On;
 8006930:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006934:	f043 0301 	orr.w	r3, r3, #1
 8006938:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
                        // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
                        // all are explicit axis commands, regardless if they require axis words or not.
                        // NOTE: cannot find the NIST statement referenced above, changed to match LinuxCNC behaviour in build 20210513.
                        if(int_value == 49) // G49
 800693c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006940:	2b31      	cmp	r3, #49	; 0x31
 8006942:	d103      	bne.n	800694c <gc_execute_block+0x730>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_Cancel;
 8006944:	4b89      	ldr	r3, [pc, #548]	; (8006b6c <gc_execute_block+0x950>)
 8006946:	2200      	movs	r2, #0
 8006948:	73da      	strb	r2, [r3, #15]
 800694a:	e02c      	b.n	80069a6 <gc_execute_block+0x78a>
                        else if(mantissa == 0 && grbl.tool_table.n_tools) // G43
 800694c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006950:	2b00      	cmp	r3, #0
 8006952:	d107      	bne.n	8006964 <gc_execute_block+0x748>
 8006954:	4b86      	ldr	r3, [pc, #536]	; (8006b70 <gc_execute_block+0x954>)
 8006956:	699b      	ldr	r3, [r3, #24]
 8006958:	2b00      	cmp	r3, #0
 800695a:	d003      	beq.n	8006964 <gc_execute_block+0x748>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_Enable;
 800695c:	4b83      	ldr	r3, [pc, #524]	; (8006b6c <gc_execute_block+0x950>)
 800695e:	2201      	movs	r2, #1
 8006960:	73da      	strb	r2, [r3, #15]
 8006962:	e020      	b.n	80069a6 <gc_execute_block+0x78a>
                        else if(mantissa == 20 && grbl.tool_table.n_tools) // G43.2
 8006964:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006968:	2b14      	cmp	r3, #20
 800696a:	d107      	bne.n	800697c <gc_execute_block+0x760>
 800696c:	4b80      	ldr	r3, [pc, #512]	; (8006b70 <gc_execute_block+0x954>)
 800696e:	699b      	ldr	r3, [r3, #24]
 8006970:	2b00      	cmp	r3, #0
 8006972:	d003      	beq.n	800697c <gc_execute_block+0x760>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_ApplyAdditional;
 8006974:	4b7d      	ldr	r3, [pc, #500]	; (8006b6c <gc_execute_block+0x950>)
 8006976:	2203      	movs	r2, #3
 8006978:	73da      	strb	r2, [r3, #15]
 800697a:	e014      	b.n	80069a6 <gc_execute_block+0x78a>
                        else if(mantissa == 10) { // G43.1
 800697c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006980:	2b0a      	cmp	r3, #10
 8006982:	d10d      	bne.n	80069a0 <gc_execute_block+0x784>
                            if(axis_command)
 8006984:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8006988:	2b00      	cmp	r3, #0
 800698a:	d002      	beq.n	8006992 <gc_execute_block+0x776>
                                FAIL(Status_GcodeAxisCommandConflict); // [Axis word/command conflict] }
 800698c:	2318      	movs	r3, #24
 800698e:	f004 bf3d 	b.w	800b80c <gc_execute_block+0x55f0>
                            axis_command = AxisCommand_ToolLengthOffset;
 8006992:	2303      	movs	r3, #3
 8006994:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_EnableDynamic;
 8006998:	4b74      	ldr	r3, [pc, #464]	; (8006b6c <gc_execute_block+0x950>)
 800699a:	2202      	movs	r2, #2
 800699c:	73da      	strb	r2, [r3, #15]
 800699e:	e002      	b.n	80069a6 <gc_execute_block+0x78a>
                        } else
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported G43.x command]
 80069a0:	2314      	movs	r3, #20
 80069a2:	f004 bf33 	b.w	800b80c <gc_execute_block+0x55f0>
                        mantissa = 0; // Set to zero to indicate valid non-integer G command.
 80069a6:	2300      	movs	r3, #0
 80069a8:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                        break;
 80069ac:	e0a0      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 54: case 55: case 56: case 57: case 58: case 59:
                        word_bit.modal_group.G12 = On;
 80069ae:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 80069b2:	f043 0308 	orr.w	r3, r3, #8
 80069b6:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        gc_block.modal.coord_system.id = (coord_system_id_t)(int_value - 54); // Shift to array indexing.
 80069ba:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80069be:	b2db      	uxtb	r3, r3
 80069c0:	3b36      	subs	r3, #54	; 0x36
 80069c2:	b2da      	uxtb	r2, r3
 80069c4:	4b69      	ldr	r3, [pc, #420]	; (8006b6c <gc_execute_block+0x950>)
 80069c6:	771a      	strb	r2, [r3, #28]
                        if(int_value == 59 && mantissa > 0) {
 80069c8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80069cc:	2b3b      	cmp	r3, #59	; 0x3b
 80069ce:	f040 808a 	bne.w	8006ae6 <gc_execute_block+0x8ca>
 80069d2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80069d6:	2b00      	cmp	r3, #0
 80069d8:	f000 8085 	beq.w	8006ae6 <gc_execute_block+0x8ca>
                            if(N_WorkCoordinateSystems == 9 && (mantissa == 10 || mantissa == 20 || mantissa == 30)) {
 80069dc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80069e0:	2b0a      	cmp	r3, #10
 80069e2:	d007      	beq.n	80069f4 <gc_execute_block+0x7d8>
 80069e4:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80069e8:	2b14      	cmp	r3, #20
 80069ea:	d003      	beq.n	80069f4 <gc_execute_block+0x7d8>
 80069ec:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80069f0:	2b1e      	cmp	r3, #30
 80069f2:	d110      	bne.n	8006a16 <gc_execute_block+0x7fa>
                                gc_block.modal.coord_system.id += mantissa / 10;
 80069f4:	4b5d      	ldr	r3, [pc, #372]	; (8006b6c <gc_execute_block+0x950>)
 80069f6:	7f1a      	ldrb	r2, [r3, #28]
 80069f8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80069fc:	495d      	ldr	r1, [pc, #372]	; (8006b74 <gc_execute_block+0x958>)
 80069fe:	fba1 1303 	umull	r1, r3, r1, r3
 8006a02:	08db      	lsrs	r3, r3, #3
 8006a04:	b2db      	uxtb	r3, r3
 8006a06:	4413      	add	r3, r2
 8006a08:	b2da      	uxtb	r2, r3
 8006a0a:	4b58      	ldr	r3, [pc, #352]	; (8006b6c <gc_execute_block+0x950>)
 8006a0c:	771a      	strb	r2, [r3, #28]
                                mantissa = 0;
 8006a0e:	2300      	movs	r3, #0
 8006a10:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
                            } else
                                FAIL(Status_GcodeUnsupportedCommand); // [Unsupported G59.x command]
                        }
                        break;
 8006a14:	e067      	b.n	8006ae6 <gc_execute_block+0x8ca>
                                FAIL(Status_GcodeUnsupportedCommand); // [Unsupported G59.x command]
 8006a16:	2314      	movs	r3, #20
 8006a18:	f004 bef8 	b.w	800b80c <gc_execute_block+0x55f0>

                    case 61:
                        word_bit.modal_group.G13 = On;
 8006a1c:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006a20:	f043 0310 	orr.w	r3, r3, #16
 8006a24:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        if (mantissa != 0) // [G61.1 not supported]
 8006a28:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d05c      	beq.n	8006aea <gc_execute_block+0x8ce>
                            FAIL(Status_GcodeUnsupportedCommand);
 8006a30:	2314      	movs	r3, #20
 8006a32:	f004 beeb 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.modal.control = ControlMode_PathBlending; // G64
                        break;
*/

                    case 65: // NOTE: Mach 3/4 GCode
                        word_bit.modal_group.G0 = On;
 8006a36:	f897 3090 	ldrb.w	r3, [r7, #144]	; 0x90
 8006a3a:	f043 0301 	orr.w	r3, r3, #1
 8006a3e:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8006a42:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006a46:	b2da      	uxtb	r2, r3
 8006a48:	4b48      	ldr	r3, [pc, #288]	; (8006b6c <gc_execute_block+0x950>)
 8006a4a:	701a      	strb	r2, [r3, #0]
                        if(mantissa != 0 || grbl.on_macro_execute == NULL)
 8006a4c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006a50:	2b00      	cmp	r3, #0
 8006a52:	d104      	bne.n	8006a5e <gc_execute_block+0x842>
 8006a54:	4b46      	ldr	r3, [pc, #280]	; (8006b70 <gc_execute_block+0x954>)
 8006a56:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8006a5a:	2b00      	cmp	r3, #0
 8006a5c:	d147      	bne.n	8006aee <gc_execute_block+0x8d2>
                            FAIL(Status_GcodeUnsupportedCommand);
 8006a5e:	2314      	movs	r3, #20
 8006a60:	f004 bed4 	b.w	800b80c <gc_execute_block+0x55f0>
                        break;

                    case 96: case 97:
                        if(settings.mode == Mode_Lathe) {
 8006a64:	4b44      	ldr	r3, [pc, #272]	; (8006b78 <gc_execute_block+0x95c>)
 8006a66:	7e1b      	ldrb	r3, [r3, #24]
 8006a68:	2b02      	cmp	r3, #2
 8006a6a:	d111      	bne.n	8006a90 <gc_execute_block+0x874>
                            word_bit.modal_group.G14 = On;
 8006a6c:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006a70:	f043 0320 	orr.w	r3, r3, #32
 8006a74:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                            gc_block.modal.spindle.rpm_mode = (spindle_rpm_mode_t)((int_value - 96) ^ 1);
 8006a78:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006a7c:	b2db      	uxtb	r3, r3
 8006a7e:	3b60      	subs	r3, #96	; 0x60
 8006a80:	b2db      	uxtb	r3, r3
 8006a82:	f083 0301 	eor.w	r3, r3, #1
 8006a86:	b2da      	uxtb	r2, r3
 8006a88:	4b38      	ldr	r3, [pc, #224]	; (8006b6c <gc_execute_block+0x950>)
 8006a8a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
                        } else
                            FAIL(Status_GcodeUnsupportedCommand);
                        break;
 8006a8e:	e02f      	b.n	8006af0 <gc_execute_block+0x8d4>
                            FAIL(Status_GcodeUnsupportedCommand);
 8006a90:	2314      	movs	r3, #20
 8006a92:	f004 bebb 	b.w	800b80c <gc_execute_block+0x55f0>

                    case 98: case 99:
                        word_bit.modal_group.G10 = On;
 8006a96:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006a9a:	f043 0302 	orr.w	r3, r3, #2
 8006a9e:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        gc_block.modal.retract_mode = (cc_retract_mode_t)(int_value - 98);
 8006aa2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006aa6:	b2db      	uxtb	r3, r3
 8006aa8:	3b62      	subs	r3, #98	; 0x62
 8006aaa:	b2da      	uxtb	r2, r3
 8006aac:	4b2f      	ldr	r3, [pc, #188]	; (8006b6c <gc_execute_block+0x950>)
 8006aae:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
                        break;
 8006ab2:	e01d      	b.n	8006af0 <gc_execute_block+0x8d4>

                    case 50: case 51:
                        axis_command = AxisCommand_Scaling;
 8006ab4:	2304      	movs	r3, #4
 8006ab6:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                        word_bit.modal_group.G11 = On;
 8006aba:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006abe:	f043 0304 	orr.w	r3, r3, #4
 8006ac2:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        gc_block.modal.scaling_active = int_value == 51;
 8006ac6:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006aca:	2b33      	cmp	r3, #51	; 0x33
 8006acc:	bf0c      	ite	eq
 8006ace:	2301      	moveq	r3, #1
 8006ad0:	2300      	movne	r3, #0
 8006ad2:	b2da      	uxtb	r2, r3
 8006ad4:	4b25      	ldr	r3, [pc, #148]	; (8006b6c <gc_execute_block+0x950>)
 8006ad6:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
                        break;
 8006ada:	e009      	b.n	8006af0 <gc_execute_block+0x8d4>

                    default: FAIL(Status_GcodeUnsupportedCommand); // [Unsupported G command]
 8006adc:	2314      	movs	r3, #20
 8006ade:	f004 be95 	b.w	800b80c <gc_execute_block+0x55f0>
                        break;
 8006ae2:	bf00      	nop
 8006ae4:	e004      	b.n	8006af0 <gc_execute_block+0x8d4>
                        break;
 8006ae6:	bf00      	nop
 8006ae8:	e002      	b.n	8006af0 <gc_execute_block+0x8d4>
                        break;
 8006aea:	bf00      	nop
 8006aec:	e000      	b.n	8006af0 <gc_execute_block+0x8d4>
                        break;
 8006aee:	bf00      	nop
                } // end G-value switch

                if (mantissa > 0)
 8006af0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006af4:	2b00      	cmp	r3, #0
 8006af6:	d002      	beq.n	8006afe <gc_execute_block+0x8e2>
                    FAIL(Status_GcodeCommandValueNotInteger); // [Unsupported or invalid Gxx.x command]
 8006af8:	2317      	movs	r3, #23
 8006afa:	f004 be87 	b.w	800b80c <gc_execute_block+0x55f0>

                // Check for more than one command per modal group violations in the current block
                // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
                if (command_words.mask & word_bit.modal_group.mask)
 8006afe:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8006b02:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006b06:	4013      	ands	r3, r2
 8006b08:	2b00      	cmp	r3, #0
 8006b0a:	d002      	beq.n	8006b12 <gc_execute_block+0x8f6>
                    FAIL(Status_GcodeModalGroupViolation);
 8006b0c:	2315      	movs	r3, #21
 8006b0e:	f004 be7d 	b.w	800b80c <gc_execute_block+0x55f0>

                command_words.mask |= word_bit.modal_group.mask;
 8006b12:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8006b16:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8006b1a:	4313      	orrs	r3, r2
 8006b1c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
                break;
 8006b20:	f000 bcb5 	b.w	800748e <gc_execute_block+0x1272>

            case 'M': // Determine 'M' command and its modal group

                if(gc_block.non_modal_command == NonModal_MacroCall) {
 8006b24:	4b11      	ldr	r3, [pc, #68]	; (8006b6c <gc_execute_block+0x950>)
 8006b26:	781b      	ldrb	r3, [r3, #0]
 8006b28:	2b41      	cmp	r3, #65	; 0x41
 8006b2a:	d117      	bne.n	8006b5c <gc_execute_block+0x940>

                    if(gc_block.words.m)
 8006b2c:	4b0f      	ldr	r3, [pc, #60]	; (8006b6c <gc_execute_block+0x950>)
 8006b2e:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8006b32:	f003 0320 	and.w	r3, r3, #32
 8006b36:	b2db      	uxtb	r3, r3
 8006b38:	2b00      	cmp	r3, #0
 8006b3a:	d002      	beq.n	8006b42 <gc_execute_block+0x926>
                        FAIL(Status_GcodeWordRepeated); // [Word repeated]
 8006b3c:	2319      	movs	r3, #25
 8006b3e:	f004 be65 	b.w	800b80c <gc_execute_block+0x55f0>

                    gc_block.values.m = value;
 8006b42:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8006b46:	4a09      	ldr	r2, [pc, #36]	; (8006b6c <gc_execute_block+0x950>)
 8006b48:	64d3      	str	r3, [r2, #76]	; 0x4c
                    gc_block.words.m = On; // Flag to indicate parameter assigned.
 8006b4a:	4a08      	ldr	r2, [pc, #32]	; (8006b6c <gc_execute_block+0x950>)
 8006b4c:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8006b50:	f043 0320 	orr.w	r3, r3, #32
 8006b54:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95

                    continue;
 8006b58:	f000 bc99 	b.w	800748e <gc_execute_block+0x1272>
                }

                if(mantissa > 0)
 8006b5c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8006b60:	2b00      	cmp	r3, #0
 8006b62:	d00b      	beq.n	8006b7c <gc_execute_block+0x960>
                    FAIL(Status_GcodeCommandValueNotInteger); // [No Mxx.x commands]
 8006b64:	2317      	movs	r3, #23
 8006b66:	f004 be51 	b.w	800b80c <gc_execute_block+0x55f0>
 8006b6a:	bf00      	nop
 8006b6c:	20000c8c 	.word	0x20000c8c
 8006b70:	20000dd4 	.word	0x20000dd4
 8006b74:	cccccccd 	.word	0xcccccccd
 8006b78:	2000147c 	.word	0x2000147c

                is_user_mcode = false;
 8006b7c:	2300      	movs	r3, #0
 8006b7e:	f887 3103 	strb.w	r3, [r7, #259]	; 0x103
                word_bit.modal_group.mask = 0;
 8006b82:	2300      	movs	r3, #0
 8006b84:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8006b88:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006b8c:	2b63      	cmp	r3, #99	; 0x63
 8006b8e:	f200 8219 	bhi.w	8006fc4 <gc_execute_block+0xda8>
 8006b92:	a201      	add	r2, pc, #4	; (adr r2, 8006b98 <gc_execute_block+0x97c>)
 8006b94:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006b98:	08006d29 	.word	0x08006d29
 8006b9c:	08006d29 	.word	0x08006d29
 8006ba0:	08006d29 	.word	0x08006d29
 8006ba4:	08006db1 	.word	0x08006db1
 8006ba8:	08006db1 	.word	0x08006db1
 8006bac:	08006db1 	.word	0x08006db1
 8006bb0:	08006e05 	.word	0x08006e05
 8006bb4:	08006e39 	.word	0x08006e39
 8006bb8:	08006e39 	.word	0x08006e39
 8006bbc:	08006e39 	.word	0x08006e39
 8006bc0:	08006fc5 	.word	0x08006fc5
 8006bc4:	08006fc5 	.word	0x08006fc5
 8006bc8:	08006fc5 	.word	0x08006fc5
 8006bcc:	08006fc5 	.word	0x08006fc5
 8006bd0:	08006fc5 	.word	0x08006fc5
 8006bd4:	08006fc5 	.word	0x08006fc5
 8006bd8:	08006fc5 	.word	0x08006fc5
 8006bdc:	08006fc5 	.word	0x08006fc5
 8006be0:	08006fc5 	.word	0x08006fc5
 8006be4:	08006fc5 	.word	0x08006fc5
 8006be8:	08006fc5 	.word	0x08006fc5
 8006bec:	08006fc5 	.word	0x08006fc5
 8006bf0:	08006fc5 	.word	0x08006fc5
 8006bf4:	08006fc5 	.word	0x08006fc5
 8006bf8:	08006fc5 	.word	0x08006fc5
 8006bfc:	08006fc5 	.word	0x08006fc5
 8006c00:	08006fc5 	.word	0x08006fc5
 8006c04:	08006fc5 	.word	0x08006fc5
 8006c08:	08006fc5 	.word	0x08006fc5
 8006c0c:	08006fc5 	.word	0x08006fc5
 8006c10:	08006d29 	.word	0x08006d29
 8006c14:	08006fc5 	.word	0x08006fc5
 8006c18:	08006fc5 	.word	0x08006fc5
 8006c1c:	08006fc5 	.word	0x08006fc5
 8006c20:	08006fc5 	.word	0x08006fc5
 8006c24:	08006fc5 	.word	0x08006fc5
 8006c28:	08006fc5 	.word	0x08006fc5
 8006c2c:	08006fc5 	.word	0x08006fc5
 8006c30:	08006fc5 	.word	0x08006fc5
 8006c34:	08006fc5 	.word	0x08006fc5
 8006c38:	08006fc5 	.word	0x08006fc5
 8006c3c:	08006fc5 	.word	0x08006fc5
 8006c40:	08006fc5 	.word	0x08006fc5
 8006c44:	08006fc5 	.word	0x08006fc5
 8006c48:	08006fc5 	.word	0x08006fc5
 8006c4c:	08006fc5 	.word	0x08006fc5
 8006c50:	08006fc5 	.word	0x08006fc5
 8006c54:	08006fc5 	.word	0x08006fc5
 8006c58:	08006edb 	.word	0x08006edb
 8006c5c:	08006edb 	.word	0x08006edb
 8006c60:	08006edb 	.word	0x08006edb
 8006c64:	08006edb 	.word	0x08006edb
 8006c68:	08006fc5 	.word	0x08006fc5
 8006c6c:	08006edb 	.word	0x08006edb
 8006c70:	08006fc5 	.word	0x08006fc5
 8006c74:	08006fc5 	.word	0x08006fc5
 8006c78:	08006ec5 	.word	0x08006ec5
 8006c7c:	08006fc5 	.word	0x08006fc5
 8006c80:	08006fc5 	.word	0x08006fc5
 8006c84:	08006fc5 	.word	0x08006fc5
 8006c88:	08006d29 	.word	0x08006d29
 8006c8c:	08006ef3 	.word	0x08006ef3
 8006c90:	08006f07 	.word	0x08006f07
 8006c94:	08006f07 	.word	0x08006f07
 8006c98:	08006f07 	.word	0x08006f07
 8006c9c:	08006f07 	.word	0x08006f07
 8006ca0:	08006f37 	.word	0x08006f37
 8006ca4:	08006f71 	.word	0x08006f71
 8006ca8:	08006f71 	.word	0x08006f71
 8006cac:	08006fc5 	.word	0x08006fc5
 8006cb0:	08006fc5 	.word	0x08006fc5
 8006cb4:	08006fc5 	.word	0x08006fc5
 8006cb8:	08006fc5 	.word	0x08006fc5
 8006cbc:	08006fc5 	.word	0x08006fc5
 8006cc0:	08006fc5 	.word	0x08006fc5
 8006cc4:	08006fc5 	.word	0x08006fc5
 8006cc8:	08006fc5 	.word	0x08006fc5
 8006ccc:	08006fc5 	.word	0x08006fc5
 8006cd0:	08006fc5 	.word	0x08006fc5
 8006cd4:	08006fc5 	.word	0x08006fc5
 8006cd8:	08006fc5 	.word	0x08006fc5
 8006cdc:	08006fc5 	.word	0x08006fc5
 8006ce0:	08006fc5 	.word	0x08006fc5
 8006ce4:	08006fc5 	.word	0x08006fc5
 8006ce8:	08006fc5 	.word	0x08006fc5
 8006cec:	08006fc5 	.word	0x08006fc5
 8006cf0:	08006fc5 	.word	0x08006fc5
 8006cf4:	08006fc5 	.word	0x08006fc5
 8006cf8:	08006fc5 	.word	0x08006fc5
 8006cfc:	08006fc5 	.word	0x08006fc5
 8006d00:	08006fc5 	.word	0x08006fc5
 8006d04:	08006fc5 	.word	0x08006fc5
 8006d08:	08006fc5 	.word	0x08006fc5
 8006d0c:	08006fc5 	.word	0x08006fc5
 8006d10:	08006fc5 	.word	0x08006fc5
 8006d14:	08006fc5 	.word	0x08006fc5
 8006d18:	08006fc5 	.word	0x08006fc5
 8006d1c:	08006fc5 	.word	0x08006fc5
 8006d20:	08006fc5 	.word	0x08006fc5
 8006d24:	08006fa1 	.word	0x08006fa1

                switch(int_value) {

                    case 0: case 1: case 2: case 30: case 60:
                        word_bit.modal_group.M4 = On;
 8006d28:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006d2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006d30:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
 8006d34:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006d38:	2b00      	cmp	r3, #0
 8006d3a:	d004      	beq.n	8006d46 <gc_execute_block+0xb2a>
 8006d3c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006d40:	2b01      	cmp	r3, #1
 8006d42:	d005      	beq.n	8006d50 <gc_execute_block+0xb34>
 8006d44:	e02b      	b.n	8006d9e <gc_execute_block+0xb82>
                        switch(int_value) {

                            case 0: // M0 - program pause
                                gc_block.modal.program_flow = ProgramFlow_Paused;
 8006d46:	4bbc      	ldr	r3, [pc, #752]	; (8007038 <gc_execute_block+0xe1c>)
 8006d48:	2203      	movs	r2, #3
 8006d4a:	f883 2020 	strb.w	r2, [r3, #32]
                                break;
 8006d4e:	e02e      	b.n	8006dae <gc_execute_block+0xb92>

                            case 1: // M1 - program pause
                                if(hal.signals_cap.stop_disable ? !hal.control.get_state().stop_disable : !sys.flags.optional_stop_disable)
 8006d50:	4bba      	ldr	r3, [pc, #744]	; (800703c <gc_execute_block+0xe20>)
 8006d52:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8006d56:	f003 0320 	and.w	r3, r3, #32
 8006d5a:	b2db      	uxtb	r3, r3
 8006d5c:	2b00      	cmp	r3, #0
 8006d5e:	d00d      	beq.n	8006d7c <gc_execute_block+0xb60>
 8006d60:	4bb6      	ldr	r3, [pc, #728]	; (800703c <gc_execute_block+0xe20>)
 8006d62:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8006d64:	4798      	blx	r3
 8006d66:	4603      	mov	r3, r0
 8006d68:	b2db      	uxtb	r3, r3
 8006d6a:	f003 0320 	and.w	r3, r3, #32
 8006d6e:	b2db      	uxtb	r3, r3
 8006d70:	2b00      	cmp	r3, #0
 8006d72:	bf0c      	ite	eq
 8006d74:	2301      	moveq	r3, #1
 8006d76:	2300      	movne	r3, #0
 8006d78:	b2db      	uxtb	r3, r3
 8006d7a:	e009      	b.n	8006d90 <gc_execute_block+0xb74>
 8006d7c:	4bb0      	ldr	r3, [pc, #704]	; (8007040 <gc_execute_block+0xe24>)
 8006d7e:	7d9b      	ldrb	r3, [r3, #22]
 8006d80:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006d84:	b2db      	uxtb	r3, r3
 8006d86:	2b00      	cmp	r3, #0
 8006d88:	bf0c      	ite	eq
 8006d8a:	2301      	moveq	r3, #1
 8006d8c:	2300      	movne	r3, #0
 8006d8e:	b2db      	uxtb	r3, r3
 8006d90:	2b00      	cmp	r3, #0
 8006d92:	d00b      	beq.n	8006dac <gc_execute_block+0xb90>
                                    gc_block.modal.program_flow = ProgramFlow_OptionalStop;
 8006d94:	4ba8      	ldr	r3, [pc, #672]	; (8007038 <gc_execute_block+0xe1c>)
 8006d96:	2201      	movs	r2, #1
 8006d98:	f883 2020 	strb.w	r2, [r3, #32]
                                break;
 8006d9c:	e006      	b.n	8006dac <gc_execute_block+0xb90>

                            default: // M2, M30, M60 - program end and reset
                                gc_block.modal.program_flow = (program_flow_t)int_value;
 8006d9e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006da2:	b2da      	uxtb	r2, r3
 8006da4:	4ba4      	ldr	r3, [pc, #656]	; (8007038 <gc_execute_block+0xe1c>)
 8006da6:	f883 2020 	strb.w	r2, [r3, #32]
                        }
                        break;
 8006daa:	e132      	b.n	8007012 <gc_execute_block+0xdf6>
                                break;
 8006dac:	bf00      	nop
                        break;
 8006dae:	e130      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 3: case 4: case 5:
                        word_bit.modal_group.M7 = On;
 8006db0:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006db4:	f043 0302 	orr.w	r3, r3, #2
 8006db8:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        gc_block.modal.spindle.state.on = !(int_value == 5);
 8006dbc:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006dc0:	2b05      	cmp	r3, #5
 8006dc2:	bf14      	ite	ne
 8006dc4:	2301      	movne	r3, #1
 8006dc6:	2300      	moveq	r3, #0
 8006dc8:	b2d9      	uxtb	r1, r3
 8006dca:	4a9b      	ldr	r2, [pc, #620]	; (8007038 <gc_execute_block+0xe1c>)
 8006dcc:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
 8006dd0:	f361 0300 	bfi	r3, r1, #0, #1
 8006dd4:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
                        gc_block.modal.spindle.state.ccw = int_value == 4;
 8006dd8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006ddc:	2b04      	cmp	r3, #4
 8006dde:	bf0c      	ite	eq
 8006de0:	2301      	moveq	r3, #1
 8006de2:	2300      	movne	r3, #0
 8006de4:	b2d9      	uxtb	r1, r3
 8006de6:	4a94      	ldr	r2, [pc, #592]	; (8007038 <gc_execute_block+0xe1c>)
 8006de8:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
 8006dec:	f361 0341 	bfi	r3, r1, #1, #1
 8006df0:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
                        sys.override_delay.spindle = On;
 8006df4:	4a92      	ldr	r2, [pc, #584]	; (8007040 <gc_execute_block+0xe24>)
 8006df6:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
 8006dfa:	f043 0304 	orr.w	r3, r3, #4
 8006dfe:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
                        break;
 8006e02:	e106      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 6:
                        if(settings.tool_change.mode != ToolChange_Ignore) {
 8006e04:	4b8f      	ldr	r3, [pc, #572]	; (8007044 <gc_execute_block+0xe28>)
 8006e06:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8006e0a:	2b04      	cmp	r3, #4
 8006e0c:	f000 80fc 	beq.w	8007008 <gc_execute_block+0xdec>
                            if(hal.stream.suspend_read || hal.tool.change)
 8006e10:	4b8a      	ldr	r3, [pc, #552]	; (800703c <gc_execute_block+0xe20>)
 8006e12:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8006e16:	2b00      	cmp	r3, #0
 8006e18:	d104      	bne.n	8006e24 <gc_execute_block+0xc08>
 8006e1a:	4b88      	ldr	r3, [pc, #544]	; (800703c <gc_execute_block+0xe20>)
 8006e1c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	d006      	beq.n	8006e32 <gc_execute_block+0xc16>
                                word_bit.modal_group.M6 = On;
 8006e24:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006e28:	f043 0301 	orr.w	r3, r3, #1
 8006e2c:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                            else
                                FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
                        }
                        break;
 8006e30:	e0ea      	b.n	8007008 <gc_execute_block+0xdec>
                                FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8006e32:	2314      	movs	r3, #20
 8006e34:	f004 bcea 	b.w	800b80c <gc_execute_block+0x55f0>

                    case 7: case 8: case 9:
                        word_bit.modal_group.M8 = On;
 8006e38:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006e3c:	f043 0304 	orr.w	r3, r3, #4
 8006e40:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        sys.override_delay.coolant = On;
 8006e44:	4a7e      	ldr	r2, [pc, #504]	; (8007040 <gc_execute_block+0xe24>)
 8006e46:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
 8006e4a:	f043 0302 	orr.w	r3, r3, #2
 8006e4e:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
                        gc_parser_flags.set_coolant = On;
 8006e52:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8006e56:	f043 0301 	orr.w	r3, r3, #1
 8006e5a:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d
 8006e5e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006e62:	2b09      	cmp	r3, #9
 8006e64:	d028      	beq.n	8006eb8 <gc_execute_block+0xc9c>
 8006e66:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006e6a:	2b09      	cmp	r3, #9
 8006e6c:	f200 80ce 	bhi.w	800700c <gc_execute_block+0xdf0>
 8006e70:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006e74:	2b07      	cmp	r3, #7
 8006e76:	d004      	beq.n	8006e82 <gc_execute_block+0xc66>
 8006e78:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006e7c:	2b08      	cmp	r3, #8
 8006e7e:	d013      	beq.n	8006ea8 <gc_execute_block+0xc8c>

                            case 9:
                                gc_block.modal.coolant.value = 0;
                                break;
                        }
                        break;
 8006e80:	e0c4      	b.n	800700c <gc_execute_block+0xdf0>
                                if(!hal.driver_cap.mist_control)
 8006e82:	4b6e      	ldr	r3, [pc, #440]	; (800703c <gc_execute_block+0xe20>)
 8006e84:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8006e88:	f003 0301 	and.w	r3, r3, #1
 8006e8c:	b2db      	uxtb	r3, r3
 8006e8e:	2b00      	cmp	r3, #0
 8006e90:	d102      	bne.n	8006e98 <gc_execute_block+0xc7c>
                                    FAIL(Status_GcodeUnsupportedCommand);
 8006e92:	2314      	movs	r3, #20
 8006e94:	f004 bcba 	b.w	800b80c <gc_execute_block+0x55f0>
                                gc_block.modal.coolant.mist = On;
 8006e98:	4a67      	ldr	r2, [pc, #412]	; (8007038 <gc_execute_block+0xe1c>)
 8006e9a:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 8006e9e:	f043 0302 	orr.w	r3, r3, #2
 8006ea2:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
                                break;
 8006ea6:	e00c      	b.n	8006ec2 <gc_execute_block+0xca6>
                                gc_block.modal.coolant.flood = On;
 8006ea8:	4a63      	ldr	r2, [pc, #396]	; (8007038 <gc_execute_block+0xe1c>)
 8006eaa:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 8006eae:	f043 0301 	orr.w	r3, r3, #1
 8006eb2:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
                                break;
 8006eb6:	e004      	b.n	8006ec2 <gc_execute_block+0xca6>
                                gc_block.modal.coolant.value = 0;
 8006eb8:	4b5f      	ldr	r3, [pc, #380]	; (8007038 <gc_execute_block+0xe1c>)
 8006eba:	2200      	movs	r2, #0
 8006ebc:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
                                break;
 8006ec0:	bf00      	nop
                        break;
 8006ec2:	e0a3      	b.n	800700c <gc_execute_block+0xdf0>

                    case 56:
                        if(!settings.parking.flags.enable_override_control) // TODO: check if enabled?
 8006ec4:	4b5f      	ldr	r3, [pc, #380]	; (8007044 <gc_execute_block+0xe28>)
 8006ec6:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8006eca:	f003 0304 	and.w	r3, r3, #4
 8006ece:	b2db      	uxtb	r3, r3
 8006ed0:	2b00      	cmp	r3, #0
 8006ed2:	d102      	bne.n	8006eda <gc_execute_block+0xcbe>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8006ed4:	2314      	movs	r3, #20
 8006ed6:	f004 bc99 	b.w	800b80c <gc_execute_block+0x55f0>
                        // no break;
                    case 48: case 49: case 50: case 51: case 53:
                        word_bit.modal_group.M9 = On;
 8006eda:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006ede:	f043 0308 	orr.w	r3, r3, #8
 8006ee2:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        gc_block.override_command = (override_mode_t)int_value;
 8006ee6:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006eea:	b2da      	uxtb	r2, r3
 8006eec:	4b52      	ldr	r3, [pc, #328]	; (8007038 <gc_execute_block+0xe1c>)
 8006eee:	705a      	strb	r2, [r3, #1]
                        break;
 8006ef0:	e08f      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 61:
                        set_tool = true;
 8006ef2:	2301      	movs	r3, #1
 8006ef4:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f
                        word_bit.modal_group.M6 = On; //??
 8006ef8:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006efc:	f043 0301 	orr.w	r3, r3, #1
 8006f00:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        break;
 8006f04:	e085      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 62:
                    case 63:
                    case 64:
                    case 65:
                        if(hal.port.digital_out == NULL || hal.port.num_digital_out == 0)
 8006f06:	4b4d      	ldr	r3, [pc, #308]	; (800703c <gc_execute_block+0xe20>)
 8006f08:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 8006f0c:	2b00      	cmp	r3, #0
 8006f0e:	d004      	beq.n	8006f1a <gc_execute_block+0xcfe>
 8006f10:	4b4a      	ldr	r3, [pc, #296]	; (800703c <gc_execute_block+0xe20>)
 8006f12:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8006f16:	2b00      	cmp	r3, #0
 8006f18:	d102      	bne.n	8006f20 <gc_execute_block+0xd04>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8006f1a:	2314      	movs	r3, #20
 8006f1c:	f004 bc76 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.modal_group.M10 = On;
 8006f20:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006f24:	f043 0310 	orr.w	r3, r3, #16
 8006f28:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        port_command = (io_mcode_t)int_value;
 8006f2c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006f30:	f887 310c 	strb.w	r3, [r7, #268]	; 0x10c
                        break;
 8006f34:	e06d      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 66:
                        if(hal.port.wait_on_input == NULL || (hal.port.num_digital_in == 0 && hal.port.num_analog_in == 0))
 8006f36:	4b41      	ldr	r3, [pc, #260]	; (800703c <gc_execute_block+0xe20>)
 8006f38:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 8006f3c:	2b00      	cmp	r3, #0
 8006f3e:	d009      	beq.n	8006f54 <gc_execute_block+0xd38>
 8006f40:	4b3e      	ldr	r3, [pc, #248]	; (800703c <gc_execute_block+0xe20>)
 8006f42:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8006f46:	2b00      	cmp	r3, #0
 8006f48:	d107      	bne.n	8006f5a <gc_execute_block+0xd3e>
 8006f4a:	4b3c      	ldr	r3, [pc, #240]	; (800703c <gc_execute_block+0xe20>)
 8006f4c:	f893 3116 	ldrb.w	r3, [r3, #278]	; 0x116
 8006f50:	2b00      	cmp	r3, #0
 8006f52:	d102      	bne.n	8006f5a <gc_execute_block+0xd3e>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8006f54:	2314      	movs	r3, #20
 8006f56:	f004 bc59 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.modal_group.M10 = On;
 8006f5a:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006f5e:	f043 0310 	orr.w	r3, r3, #16
 8006f62:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        port_command = (io_mcode_t)int_value;
 8006f66:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006f6a:	f887 310c 	strb.w	r3, [r7, #268]	; 0x10c
                        break;
 8006f6e:	e050      	b.n	8007012 <gc_execute_block+0xdf6>

                    case 67:
                    case 68:
                        if(hal.port.analog_out == NULL || hal.port.num_analog_out == 0)
 8006f70:	4b32      	ldr	r3, [pc, #200]	; (800703c <gc_execute_block+0xe20>)
 8006f72:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 8006f76:	2b00      	cmp	r3, #0
 8006f78:	d004      	beq.n	8006f84 <gc_execute_block+0xd68>
 8006f7a:	4b30      	ldr	r3, [pc, #192]	; (800703c <gc_execute_block+0xe20>)
 8006f7c:	f893 3117 	ldrb.w	r3, [r3, #279]	; 0x117
 8006f80:	2b00      	cmp	r3, #0
 8006f82:	d102      	bne.n	8006f8a <gc_execute_block+0xd6e>
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8006f84:	2314      	movs	r3, #20
 8006f86:	f004 bc41 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.modal_group.M10 = On;
 8006f8a:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006f8e:	f043 0310 	orr.w	r3, r3, #16
 8006f92:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
                        port_command = (io_mcode_t)int_value;
 8006f96:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8006f9a:	f887 310c 	strb.w	r3, [r7, #268]	; 0x10c
                        break;
 8006f9e:	e038      	b.n	8007012 <gc_execute_block+0xdf6>
                        }
                        return Status_OK;
*/

                    case 99:
                        word_bit.modal_group.M4 = On;
 8006fa0:	f897 3091 	ldrb.w	r3, [r7, #145]	; 0x91
 8006fa4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006fa8:	f887 3091 	strb.w	r3, [r7, #145]	; 0x91
                        gc_block.modal.program_flow = ProgramFlow_Return;
 8006fac:	4b22      	ldr	r3, [pc, #136]	; (8007038 <gc_execute_block+0xe1c>)
 8006fae:	2263      	movs	r2, #99	; 0x63
 8006fb0:	f883 2020 	strb.w	r2, [r3, #32]
                        if(grbl.on_macro_return == NULL)
 8006fb4:	4b24      	ldr	r3, [pc, #144]	; (8007048 <gc_execute_block+0xe2c>)
 8006fb6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8006fba:	2b00      	cmp	r3, #0
 8006fbc:	d128      	bne.n	8007010 <gc_execute_block+0xdf4>
                            FAIL(Status_GcodeUnsupportedCommand);
 8006fbe:	2314      	movs	r3, #20
 8006fc0:	f004 bc24 	b.w	800b80c <gc_execute_block+0x55f0>
                        break;

                    default:
                        if(hal.user_mcode.check && (gc_block.user_mcode = hal.user_mcode.check((user_mcode_t)int_value))) {
 8006fc4:	4b1d      	ldr	r3, [pc, #116]	; (800703c <gc_execute_block+0xe20>)
 8006fc6:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8006fca:	2b00      	cmp	r3, #0
 8006fcc:	d019      	beq.n	8007002 <gc_execute_block+0xde6>
 8006fce:	4b1b      	ldr	r3, [pc, #108]	; (800703c <gc_execute_block+0xe20>)
 8006fd0:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8006fd4:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8006fd8:	b292      	uxth	r2, r2
 8006fda:	4610      	mov	r0, r2
 8006fdc:	4798      	blx	r3
 8006fde:	4603      	mov	r3, r0
 8006fe0:	461a      	mov	r2, r3
 8006fe2:	4b15      	ldr	r3, [pc, #84]	; (8007038 <gc_execute_block+0xe1c>)
 8006fe4:	805a      	strh	r2, [r3, #2]
 8006fe6:	4b14      	ldr	r3, [pc, #80]	; (8007038 <gc_execute_block+0xe1c>)
 8006fe8:	885b      	ldrh	r3, [r3, #2]
 8006fea:	2b00      	cmp	r3, #0
 8006fec:	d009      	beq.n	8007002 <gc_execute_block+0xde6>
                            is_user_mcode = true;
 8006fee:	2301      	movs	r3, #1
 8006ff0:	f887 3103 	strb.w	r3, [r7, #259]	; 0x103
                            word_bit.modal_group.M10 = On;
 8006ff4:	f897 3092 	ldrb.w	r3, [r7, #146]	; 0x92
 8006ff8:	f043 0310 	orr.w	r3, r3, #16
 8006ffc:	f887 3092 	strb.w	r3, [r7, #146]	; 0x92
 8007000:	e007      	b.n	8007012 <gc_execute_block+0xdf6>
                        } else
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
 8007002:	2314      	movs	r3, #20
 8007004:	f004 bc02 	b.w	800b80c <gc_execute_block+0x55f0>
                        break;
 8007008:	bf00      	nop
 800700a:	e002      	b.n	8007012 <gc_execute_block+0xdf6>
                        break;
 800700c:	bf00      	nop
 800700e:	e000      	b.n	8007012 <gc_execute_block+0xdf6>
                        break;
 8007010:	bf00      	nop
                } // end M-value switch

                // Check for more than one command per modal group violations in the current block
                // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
                if (command_words.mask & word_bit.modal_group.mask)
 8007012:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8007016:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800701a:	4013      	ands	r3, r2
 800701c:	2b00      	cmp	r3, #0
 800701e:	d002      	beq.n	8007026 <gc_execute_block+0xe0a>
                    FAIL(Status_GcodeModalGroupViolation);
 8007020:	2315      	movs	r3, #21
 8007022:	f004 bbf3 	b.w	800b80c <gc_execute_block+0x55f0>

                command_words.mask |= word_bit.modal_group.mask;
 8007026:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800702a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800702e:	4313      	orrs	r3, r2
 8007030:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
                break;
 8007034:	e22b      	b.n	800748e <gc_execute_block+0x1272>
 8007036:	bf00      	nop
 8007038:	20000c8c 	.word	0x20000c8c
 800703c:	20000ed0 	.word	0x20000ed0
 8007040:	20000d3c 	.word	0x20000d3c
 8007044:	2000147c 	.word	0x2000147c
 8007048:	20000dd4 	.word	0x20000dd4

                /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
                legal g-code words and stores their value. Error-checking is performed later since some
                words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */

                word_bit.parameter.mask = 0;
 800704c:	2300      	movs	r3, #0
 800704e:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

                switch(letter) {
 8007052:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 8007056:	3b24      	subs	r3, #36	; 0x24
 8007058:	2b36      	cmp	r3, #54	; 0x36
 800705a:	f200 81e8 	bhi.w	800742e <gc_execute_block+0x1212>
 800705e:	a201      	add	r2, pc, #4	; (adr r2, 8007064 <gc_execute_block+0xe48>)
 8007060:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007064:	08007403 	.word	0x08007403
 8007068:	0800742f 	.word	0x0800742f
 800706c:	0800742f 	.word	0x0800742f
 8007070:	0800742f 	.word	0x0800742f
 8007074:	0800742f 	.word	0x0800742f
 8007078:	0800742f 	.word	0x0800742f
 800707c:	0800742f 	.word	0x0800742f
 8007080:	0800742f 	.word	0x0800742f
 8007084:	0800742f 	.word	0x0800742f
 8007088:	0800742f 	.word	0x0800742f
 800708c:	0800742f 	.word	0x0800742f
 8007090:	0800742f 	.word	0x0800742f
 8007094:	0800742f 	.word	0x0800742f
 8007098:	0800742f 	.word	0x0800742f
 800709c:	0800742f 	.word	0x0800742f
 80070a0:	0800742f 	.word	0x0800742f
 80070a4:	0800742f 	.word	0x0800742f
 80070a8:	0800742f 	.word	0x0800742f
 80070ac:	0800742f 	.word	0x0800742f
 80070b0:	0800742f 	.word	0x0800742f
 80070b4:	0800742f 	.word	0x0800742f
 80070b8:	0800742f 	.word	0x0800742f
 80070bc:	0800742f 	.word	0x0800742f
 80070c0:	0800742f 	.word	0x0800742f
 80070c4:	0800742f 	.word	0x0800742f
 80070c8:	0800742f 	.word	0x0800742f
 80070cc:	0800742f 	.word	0x0800742f
 80070d0:	0800742f 	.word	0x0800742f
 80070d4:	0800742f 	.word	0x0800742f
 80070d8:	0800742f 	.word	0x0800742f
 80070dc:	0800742f 	.word	0x0800742f
 80070e0:	0800742f 	.word	0x0800742f
 80070e4:	08007141 	.word	0x08007141
 80070e8:	08007157 	.word	0x08007157
 80070ec:	0800716d 	.word	0x0800716d
 80070f0:	0800742f 	.word	0x0800742f
 80070f4:	08007183 	.word	0x08007183
 80070f8:	080071c1 	.word	0x080071c1
 80070fc:	080071e3 	.word	0x080071e3
 8007100:	08007205 	.word	0x08007205
 8007104:	08007227 	.word	0x08007227
 8007108:	0800742f 	.word	0x0800742f
 800710c:	08007265 	.word	0x08007265
 8007110:	0800728d 	.word	0x0800728d
 8007114:	080072cb 	.word	0x080072cb
 8007118:	080072e1 	.word	0x080072e1
 800711c:	080072f7 	.word	0x080072f7
 8007120:	0800730d 	.word	0x0800730d
 8007124:	08007323 	.word	0x08007323
 8007128:	0800742f 	.word	0x0800742f
 800712c:	0800742f 	.word	0x0800742f
 8007130:	0800742f 	.word	0x0800742f
 8007134:	0800739d 	.word	0x0800739d
 8007138:	080073bf 	.word	0x080073bf
 800713c:	080073e1 	.word	0x080073e1
                        gc_block.values.xyz[C_AXIS] = value;
                        break;
#endif

                    case 'D':
                        word_bit.parameter.d = On;
 8007140:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8007144:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007148:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                        gc_block.values.d = value;
 800714c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007150:	4abe      	ldr	r2, [pc, #760]	; (800744c <gc_execute_block+0x1230>)
 8007152:	6313      	str	r3, [r2, #48]	; 0x30
                        break;
 8007154:	e16e      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'E':
                        word_bit.parameter.e = On;
 8007156:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 800715a:	f043 0301 	orr.w	r3, r3, #1
 800715e:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.e = value;
 8007162:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007166:	4ab9      	ldr	r2, [pc, #740]	; (800744c <gc_execute_block+0x1230>)
 8007168:	6353      	str	r3, [r2, #52]	; 0x34
                        break;
 800716a:	e163      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'F':
                        word_bit.parameter.f = On;
 800716c:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 8007170:	f043 0302 	orr.w	r3, r3, #2
 8007174:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.f = value;
 8007178:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800717c:	4ab3      	ldr	r2, [pc, #716]	; (800744c <gc_execute_block+0x1230>)
 800717e:	6393      	str	r3, [r2, #56]	; 0x38
                        break;
 8007180:	e158      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'H':
                        if (mantissa > 0)
 8007182:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8007186:	2b00      	cmp	r3, #0
 8007188:	d002      	beq.n	8007190 <gc_execute_block+0xf74>
                            FAIL(Status_GcodeCommandValueNotInteger);
 800718a:	2317      	movs	r3, #23
 800718c:	f004 bb3e 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.parameter.h = On;
 8007190:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 8007194:	f043 0308 	orr.w	r3, r3, #8
 8007198:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.h = isnan(value) ? 0xFFFFFFFF : int_value;
 800719c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80071a0:	4619      	mov	r1, r3
 80071a2:	4618      	mov	r0, r3
 80071a4:	f7f9 ffcc 	bl	8001140 <__aeabi_fcmpun>
 80071a8:	4603      	mov	r3, r0
 80071aa:	2b00      	cmp	r3, #0
 80071ac:	d102      	bne.n	80071b4 <gc_execute_block+0xf98>
 80071ae:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80071b2:	e001      	b.n	80071b8 <gc_execute_block+0xf9c>
 80071b4:	f04f 33ff 	mov.w	r3, #4294967295
 80071b8:	4aa4      	ldr	r2, [pc, #656]	; (800744c <gc_execute_block+0x1230>)
 80071ba:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                        break;
 80071be:	e139      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'I':
                        ijk_words.i = On;
 80071c0:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 80071c4:	f043 0301 	orr.w	r3, r3, #1
 80071c8:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
                        word_bit.parameter.i = On;
 80071cc:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80071d0:	f043 0310 	orr.w	r3, r3, #16
 80071d4:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                        gc_block.values.ijk[I_VALUE] = value;
 80071d8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80071dc:	4a9b      	ldr	r2, [pc, #620]	; (800744c <gc_execute_block+0x1230>)
 80071de:	63d3      	str	r3, [r2, #60]	; 0x3c
                        break;
 80071e0:	e128      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'J':
                        ijk_words.j = On;
 80071e2:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 80071e6:	f043 0302 	orr.w	r3, r3, #2
 80071ea:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
                        word_bit.parameter.j = On;
 80071ee:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80071f2:	f043 0320 	orr.w	r3, r3, #32
 80071f6:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                        gc_block.values.ijk[J_VALUE] = value;
 80071fa:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80071fe:	4a93      	ldr	r2, [pc, #588]	; (800744c <gc_execute_block+0x1230>)
 8007200:	6413      	str	r3, [r2, #64]	; 0x40
                        break;
 8007202:	e117      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'K':
                        ijk_words.k = On;
 8007204:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 8007208:	f043 0304 	orr.w	r3, r3, #4
 800720c:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
                        word_bit.parameter.k = On;
 8007210:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8007214:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007218:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                        gc_block.values.ijk[K_VALUE] = value;
 800721c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007220:	4a8a      	ldr	r2, [pc, #552]	; (800744c <gc_execute_block+0x1230>)
 8007222:	6453      	str	r3, [r2, #68]	; 0x44
                        break;
 8007224:	e106      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'L':
                        if (mantissa > 0)
 8007226:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800722a:	2b00      	cmp	r3, #0
 800722c:	d002      	beq.n	8007234 <gc_execute_block+0x1018>
                            FAIL(Status_GcodeCommandValueNotInteger);
 800722e:	2317      	movs	r3, #23
 8007230:	f004 baec 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.parameter.l = On;
 8007234:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 8007238:	f043 0310 	orr.w	r3, r3, #16
 800723c:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.l = isnan(value) ? 0xFF : (uint8_t)int_value;
 8007240:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007244:	4619      	mov	r1, r3
 8007246:	4618      	mov	r0, r3
 8007248:	f7f9 ff7a 	bl	8001140 <__aeabi_fcmpun>
 800724c:	4603      	mov	r3, r0
 800724e:	2b00      	cmp	r3, #0
 8007250:	d103      	bne.n	800725a <gc_execute_block+0x103e>
 8007252:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8007256:	b2db      	uxtb	r3, r3
 8007258:	e000      	b.n	800725c <gc_execute_block+0x1040>
 800725a:	23ff      	movs	r3, #255	; 0xff
 800725c:	4a7b      	ldr	r2, [pc, #492]	; (800744c <gc_execute_block+0x1230>)
 800725e:	f882 3090 	strb.w	r3, [r2, #144]	; 0x90
                        break;
 8007262:	e0e7      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'N':
                        word_bit.parameter.n = On;
 8007264:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 8007268:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800726c:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.n = (int32_t)truncf(value);
 8007270:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007274:	4618      	mov	r0, r3
 8007276:	f01d fdbd 	bl	8024df4 <truncf>
 800727a:	4603      	mov	r3, r0
 800727c:	4618      	mov	r0, r3
 800727e:	f7f9 ff75 	bl	800116c <__aeabi_f2iz>
 8007282:	4603      	mov	r3, r0
 8007284:	4a71      	ldr	r2, [pc, #452]	; (800744c <gc_execute_block+0x1230>)
 8007286:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
                        break;
 800728a:	e0d3      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'O':
                        if (mantissa > 0)
 800728c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8007290:	2b00      	cmp	r3, #0
 8007292:	d002      	beq.n	800729a <gc_execute_block+0x107e>
                            FAIL(Status_GcodeCommandValueNotInteger);
 8007294:	2317      	movs	r3, #23
 8007296:	f004 bab9 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.parameter.o = On;
 800729a:	f897 308d 	ldrb.w	r3, [r7, #141]	; 0x8d
 800729e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80072a2:	f887 308d 	strb.w	r3, [r7, #141]	; 0x8d
                        gc_block.values.o = isnan(value) ? 0xFFFFFFFF : int_value;
 80072a6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80072aa:	4619      	mov	r1, r3
 80072ac:	4618      	mov	r0, r3
 80072ae:	f7f9 ff47 	bl	8001140 <__aeabi_fcmpun>
 80072b2:	4603      	mov	r3, r0
 80072b4:	2b00      	cmp	r3, #0
 80072b6:	d102      	bne.n	80072be <gc_execute_block+0x10a2>
 80072b8:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80072bc:	e001      	b.n	80072c2 <gc_execute_block+0x10a6>
 80072be:	f04f 33ff 	mov.w	r3, #4294967295
 80072c2:	4a62      	ldr	r2, [pc, #392]	; (800744c <gc_execute_block+0x1230>)
 80072c4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
                        break;
 80072c8:	e0b4      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'P': // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
                        word_bit.parameter.p = On;
 80072ca:	f897 308e 	ldrb.w	r3, [r7, #142]	; 0x8e
 80072ce:	f043 0301 	orr.w	r3, r3, #1
 80072d2:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        gc_block.values.p = value;
 80072d6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80072da:	4a5c      	ldr	r2, [pc, #368]	; (800744c <gc_execute_block+0x1230>)
 80072dc:	6513      	str	r3, [r2, #80]	; 0x50
                        break;
 80072de:	e0a9      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'Q': // may be used for user defined mcodes or G61,G76
                        word_bit.parameter.q = On;
 80072e0:	f897 308e 	ldrb.w	r3, [r7, #142]	; 0x8e
 80072e4:	f043 0302 	orr.w	r3, r3, #2
 80072e8:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        gc_block.values.q = value;
 80072ec:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80072f0:	4a56      	ldr	r2, [pc, #344]	; (800744c <gc_execute_block+0x1230>)
 80072f2:	6553      	str	r3, [r2, #84]	; 0x54
                        break;
 80072f4:	e09e      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'R':
                        word_bit.parameter.r = On;
 80072f6:	f897 308e 	ldrb.w	r3, [r7, #142]	; 0x8e
 80072fa:	f043 0304 	orr.w	r3, r3, #4
 80072fe:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        gc_block.values.r = value;
 8007302:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007306:	4a51      	ldr	r2, [pc, #324]	; (800744c <gc_execute_block+0x1230>)
 8007308:	6593      	str	r3, [r2, #88]	; 0x58
                        break;
 800730a:	e093      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'S':
                        word_bit.parameter.s = On;
 800730c:	f897 308e 	ldrb.w	r3, [r7, #142]	; 0x8e
 8007310:	f043 0308 	orr.w	r3, r3, #8
 8007314:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        gc_block.values.s = value;
 8007318:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800731c:	4a4b      	ldr	r2, [pc, #300]	; (800744c <gc_execute_block+0x1230>)
 800731e:	65d3      	str	r3, [r2, #92]	; 0x5c
                        break;
 8007320:	e088      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'T':
                        if(mantissa > 0)
 8007322:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8007326:	2b00      	cmp	r3, #0
 8007328:	d002      	beq.n	8007330 <gc_execute_block+0x1114>
                            FAIL(Status_GcodeCommandValueNotInteger);
 800732a:	2317      	movs	r3, #23
 800732c:	f004 ba6e 	b.w	800b80c <gc_execute_block+0x55f0>
                        if(int_value > (grbl.tool_table.n_tools ? grbl.tool_table.n_tools : MAX_TOOL_NUMBER))
 8007330:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8007334:	2200      	movs	r2, #0
 8007336:	60bb      	str	r3, [r7, #8]
 8007338:	60fa      	str	r2, [r7, #12]
 800733a:	4b45      	ldr	r3, [pc, #276]	; (8007450 <gc_execute_block+0x1234>)
 800733c:	699b      	ldr	r3, [r3, #24]
 800733e:	2b00      	cmp	r3, #0
 8007340:	d005      	beq.n	800734e <gc_execute_block+0x1132>
 8007342:	4b43      	ldr	r3, [pc, #268]	; (8007450 <gc_execute_block+0x1234>)
 8007344:	699b      	ldr	r3, [r3, #24]
 8007346:	2200      	movs	r2, #0
 8007348:	469a      	mov	sl, r3
 800734a:	4693      	mov	fp, r2
 800734c:	e003      	b.n	8007356 <gc_execute_block+0x113a>
 800734e:	f06f 0a01 	mvn.w	sl, #1
 8007352:	f04f 0b00 	mov.w	fp, #0
 8007356:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800735a:	461a      	mov	r2, r3
 800735c:	4592      	cmp	sl, r2
 800735e:	4623      	mov	r3, r4
 8007360:	eb7b 0303 	sbcs.w	r3, fp, r3
 8007364:	da02      	bge.n	800736c <gc_execute_block+0x1150>
                            FAIL(Status_GcodeIllegalToolTableEntry);
 8007366:	2326      	movs	r3, #38	; 0x26
 8007368:	f004 ba50 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.parameter.t = On;
 800736c:	f897 308e 	ldrb.w	r3, [r7, #142]	; 0x8e
 8007370:	f043 0310 	orr.w	r3, r3, #16
 8007374:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        gc_block.values.t = isnan(value) ? 0xFFFFFFFF : int_value;
 8007378:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800737c:	4619      	mov	r1, r3
 800737e:	4618      	mov	r0, r3
 8007380:	f7f9 fede 	bl	8001140 <__aeabi_fcmpun>
 8007384:	4603      	mov	r3, r0
 8007386:	2b00      	cmp	r3, #0
 8007388:	d102      	bne.n	8007390 <gc_execute_block+0x1174>
 800738a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800738e:	e001      	b.n	8007394 <gc_execute_block+0x1178>
 8007390:	f04f 33ff 	mov.w	r3, #4294967295
 8007394:	4a2d      	ldr	r2, [pc, #180]	; (800744c <gc_execute_block+0x1230>)
 8007396:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                        break;
 800739a:	e04b      	b.n	8007434 <gc_execute_block+0x1218>
                      gc_block.values.xyz[V_AXIS] = value;
                      break;
#endif
#endif
                  case 'X':
                        axis_words.x = On;
 800739c:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80073a0:	f043 0301 	orr.w	r3, r3, #1
 80073a4:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
                        word_bit.parameter.x = On;
 80073a8:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 80073ac:	f043 0301 	orr.w	r3, r3, #1
 80073b0:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                        gc_block.values.xyz[X_AXIS] = value;
 80073b4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80073b8:	4a24      	ldr	r2, [pc, #144]	; (800744c <gc_execute_block+0x1230>)
 80073ba:	6613      	str	r3, [r2, #96]	; 0x60
                        break;
 80073bc:	e03a      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'Y':
                        axis_words.y = On;
 80073be:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80073c2:	f043 0302 	orr.w	r3, r3, #2
 80073c6:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
                        word_bit.parameter.y = On;
 80073ca:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 80073ce:	f043 0302 	orr.w	r3, r3, #2
 80073d2:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                        gc_block.values.xyz[Y_AXIS] = value;
 80073d6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80073da:	4a1c      	ldr	r2, [pc, #112]	; (800744c <gc_execute_block+0x1230>)
 80073dc:	6653      	str	r3, [r2, #100]	; 0x64
                        break;
 80073de:	e029      	b.n	8007434 <gc_execute_block+0x1218>

                    case 'Z':
                        axis_words.z = On;
 80073e0:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80073e4:	f043 0304 	orr.w	r3, r3, #4
 80073e8:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
                        word_bit.parameter.z = On;
 80073ec:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 80073f0:	f043 0304 	orr.w	r3, r3, #4
 80073f4:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                        gc_block.values.xyz[Z_AXIS] = value;
 80073f8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80073fc:	4a13      	ldr	r2, [pc, #76]	; (800744c <gc_execute_block+0x1230>)
 80073fe:	6693      	str	r3, [r2, #104]	; 0x68
                        break;
 8007400:	e018      	b.n	8007434 <gc_execute_block+0x1218>

                    case '$':
                        if(mantissa > 0)
 8007402:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8007406:	2b00      	cmp	r3, #0
 8007408:	d002      	beq.n	8007410 <gc_execute_block+0x11f4>
                            FAIL(Status_GcodeCommandValueNotInteger);
 800740a:	2317      	movs	r3, #23
 800740c:	f004 b9fe 	b.w	800b80c <gc_execute_block+0x55f0>
                        word_bit.parameter.$ = On;
 8007410:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8007414:	f043 0301 	orr.w	r3, r3, #1
 8007418:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
                        gc_block.values.$ = (int32_t)value;
 800741c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007420:	4618      	mov	r0, r3
 8007422:	f7f9 fea3 	bl	800116c <__aeabi_f2iz>
 8007426:	4603      	mov	r3, r0
 8007428:	4a08      	ldr	r2, [pc, #32]	; (800744c <gc_execute_block+0x1230>)
 800742a:	67d3      	str	r3, [r2, #124]	; 0x7c
                        break;
 800742c:	e002      	b.n	8007434 <gc_execute_block+0x1218>

                    default: FAIL(Status_GcodeUnsupportedCommand);
 800742e:	2314      	movs	r3, #20
 8007430:	f004 b9ec 	b.w	800b80c <gc_execute_block+0x55f0>

                } // end parameter letter switch

                // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
                if (gc_block.words.mask & word_bit.parameter.mask)
 8007434:	4b05      	ldr	r3, [pc, #20]	; (800744c <gc_execute_block+0x1230>)
 8007436:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800743a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800743e:	4013      	ands	r3, r2
 8007440:	2b00      	cmp	r3, #0
 8007442:	d007      	beq.n	8007454 <gc_execute_block+0x1238>
                    FAIL(Status_GcodeWordRepeated); // [Word repeated]
 8007444:	2319      	movs	r3, #25
 8007446:	f004 b9e1 	b.w	800b80c <gc_execute_block+0x55f0>
 800744a:	bf00      	nop
 800744c:	20000c8c 	.word	0x20000c8c
 8007450:	20000dd4 	.word	0x20000dd4

                // Check for invalid negative values for words F, H, N, P, T, and S.
                // NOTE: Negative value check is done here simply for code-efficiency.
                if ((word_bit.parameter.mask & positive_only_words.mask) && value < 0.0f)
 8007454:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8007458:	4b96      	ldr	r3, [pc, #600]	; (80076b4 <gc_execute_block+0x1498>)
 800745a:	681b      	ldr	r3, [r3, #0]
 800745c:	4013      	ands	r3, r2
 800745e:	2b00      	cmp	r3, #0
 8007460:	d00c      	beq.n	800747c <gc_execute_block+0x1260>
 8007462:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8007466:	f04f 0100 	mov.w	r1, #0
 800746a:	4618      	mov	r0, r3
 800746c:	f7f9 fe40 	bl	80010f0 <__aeabi_fcmplt>
 8007470:	4603      	mov	r3, r0
 8007472:	2b00      	cmp	r3, #0
 8007474:	d002      	beq.n	800747c <gc_execute_block+0x1260>
                    FAIL(Status_NegativeValue); // [Word value cannot be negative]
 8007476:	2304      	movs	r3, #4
 8007478:	f004 b9c8 	b.w	800b80c <gc_execute_block+0x55f0>

                gc_block.words.mask |= word_bit.parameter.mask; // Flag to indicate parameter assigned.
 800747c:	4b8e      	ldr	r3, [pc, #568]	; (80076b8 <gc_execute_block+0x149c>)
 800747e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8007482:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8007486:	4313      	orrs	r3, r2
 8007488:	4a8b      	ldr	r2, [pc, #556]	; (80076b8 <gc_execute_block+0x149c>)
 800748a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 800748e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8007492:	1c5a      	adds	r2, r3, #1
 8007494:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
 8007498:	697a      	ldr	r2, [r7, #20]
 800749a:	4413      	add	r3, r2
 800749c:	781b      	ldrb	r3, [r3, #0]
 800749e:	f887 30ed 	strb.w	r3, [r7, #237]	; 0xed
 80074a2:	f897 30ed 	ldrb.w	r3, [r7, #237]	; 0xed
 80074a6:	2b00      	cmp	r3, #0
 80074a8:	f47e af5c 	bne.w	8006364 <gc_execute_block+0x148>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

    // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
    // command has been sent. If so, set axis command to current motion mode.
    if (axis_words.mask && !axis_command)
 80074ac:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80074b0:	2b00      	cmp	r3, #0
 80074b2:	d006      	beq.n	80074c2 <gc_execute_block+0x12a6>
 80074b4:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 80074b8:	2b00      	cmp	r3, #0
 80074ba:	d102      	bne.n	80074c2 <gc_execute_block+0x12a6>
        axis_command = AxisCommand_MotionMode; // Assign implicit motion-mode
 80074bc:	2302      	movs	r3, #2
 80074be:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d

    if(gc_state.tool_change && axis_command == AxisCommand_MotionMode && !gc_parser_flags.jog_motion)
 80074c2:	4b7e      	ldr	r3, [pc, #504]	; (80076bc <gc_execute_block+0x14a0>)
 80074c4:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 80074c8:	2b00      	cmp	r3, #0
 80074ca:	d00d      	beq.n	80074e8 <gc_execute_block+0x12cc>
 80074cc:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 80074d0:	2b02      	cmp	r3, #2
 80074d2:	d109      	bne.n	80074e8 <gc_execute_block+0x12cc>
 80074d4:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80074d8:	f003 0301 	and.w	r3, r3, #1
 80074dc:	b2db      	uxtb	r3, r3
 80074de:	2b00      	cmp	r3, #0
 80074e0:	d102      	bne.n	80074e8 <gc_execute_block+0x12cc>
        FAIL(Status_GcodeToolChangePending); // [Motions (except jogging) not allowed when changing tool]
 80074e2:	2328      	movs	r3, #40	; 0x28
 80074e4:	f004 b992 	b.w	800b80c <gc_execute_block+0x55f0>

    // Check for valid line number N value.
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.words.n && gc_block.values.n > MAX_LINE_NUMBER)
 80074e8:	4b73      	ldr	r3, [pc, #460]	; (80076b8 <gc_execute_block+0x149c>)
 80074ea:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80074ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80074f2:	b2db      	uxtb	r3, r3
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d008      	beq.n	800750a <gc_execute_block+0x12ee>
 80074f8:	4b6f      	ldr	r3, [pc, #444]	; (80076b8 <gc_execute_block+0x149c>)
 80074fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80074fe:	4a70      	ldr	r2, [pc, #448]	; (80076c0 <gc_execute_block+0x14a4>)
 8007500:	4293      	cmp	r3, r2
 8007502:	dd02      	ble.n	800750a <gc_execute_block+0x12ee>
        FAIL(Status_GcodeInvalidLineNumber); // [Exceeds max line number]
 8007504:	231b      	movs	r3, #27
 8007506:	f004 b981 	b.w	800b80c <gc_execute_block+0x55f0>
    // [1. Comments ]: MSG's may be supported by driver layer. Comment handling performed by protocol.

    // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
    //   is not defined after switching between G93, G94 and G95.
    // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
    if (gc_parser_flags.jog_motion) {
 800750a:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800750e:	f003 0301 	and.w	r3, r3, #1
 8007512:	b2db      	uxtb	r3, r3
 8007514:	2b00      	cmp	r3, #0
 8007516:	d019      	beq.n	800754c <gc_execute_block+0x1330>

        if(!gc_block.words.f)
 8007518:	4b67      	ldr	r3, [pc, #412]	; (80076b8 <gc_execute_block+0x149c>)
 800751a:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800751e:	f003 0302 	and.w	r3, r3, #2
 8007522:	b2db      	uxtb	r3, r3
 8007524:	2b00      	cmp	r3, #0
 8007526:	d102      	bne.n	800752e <gc_execute_block+0x1312>
            FAIL(Status_GcodeUndefinedFeedRate);
 8007528:	2316      	movs	r3, #22
 800752a:	f004 b96f 	b.w	800b80c <gc_execute_block+0x55f0>

        if (gc_block.modal.units_imperial)
 800752e:	4b62      	ldr	r3, [pc, #392]	; (80076b8 <gc_execute_block+0x149c>)
 8007530:	7adb      	ldrb	r3, [r3, #11]
 8007532:	2b00      	cmp	r3, #0
 8007534:	d07c      	beq.n	8007630 <gc_execute_block+0x1414>
            gc_block.values.f *= MM_PER_INCH;
 8007536:	4b60      	ldr	r3, [pc, #384]	; (80076b8 <gc_execute_block+0x149c>)
 8007538:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800753a:	4962      	ldr	r1, [pc, #392]	; (80076c4 <gc_execute_block+0x14a8>)
 800753c:	4618      	mov	r0, r3
 800753e:	f7f9 fc39 	bl	8000db4 <__aeabi_fmul>
 8007542:	4603      	mov	r3, r0
 8007544:	461a      	mov	r2, r3
 8007546:	4b5c      	ldr	r3, [pc, #368]	; (80076b8 <gc_execute_block+0x149c>)
 8007548:	639a      	str	r2, [r3, #56]	; 0x38
 800754a:	e071      	b.n	8007630 <gc_execute_block+0x1414>

    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 800754c:	4b5a      	ldr	r3, [pc, #360]	; (80076b8 <gc_execute_block+0x149c>)
 800754e:	891b      	ldrh	r3, [r3, #8]
 8007550:	2b21      	cmp	r3, #33	; 0x21
 8007552:	d129      	bne.n	80075a8 <gc_execute_block+0x138c>

        if (!gc_block.words.k) {
 8007554:	4b58      	ldr	r3, [pc, #352]	; (80076b8 <gc_execute_block+0x149c>)
 8007556:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 800755a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800755e:	b2db      	uxtb	r3, r3
 8007560:	2b00      	cmp	r3, #0
 8007562:	d104      	bne.n	800756e <gc_execute_block+0x1352>
            gc_block.values.k = gc_state.distance_per_rev;
 8007564:	4b55      	ldr	r3, [pc, #340]	; (80076bc <gc_execute_block+0x14a0>)
 8007566:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007568:	4a53      	ldr	r2, [pc, #332]	; (80076b8 <gc_execute_block+0x149c>)
 800756a:	6493      	str	r3, [r2, #72]	; 0x48
 800756c:	e060      	b.n	8007630 <gc_execute_block+0x1414>
        } else {
            gc_block.words.k = Off;
 800756e:	4a52      	ldr	r2, [pc, #328]	; (80076b8 <gc_execute_block+0x149c>)
 8007570:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8007574:	f36f 1386 	bfc	r3, #6, #1
 8007578:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
 800757c:	4b4e      	ldr	r3, [pc, #312]	; (80076b8 <gc_execute_block+0x149c>)
 800757e:	7adb      	ldrb	r3, [r3, #11]
 8007580:	2b00      	cmp	r3, #0
 8007582:	d00c      	beq.n	800759e <gc_execute_block+0x1382>
 8007584:	4b4c      	ldr	r3, [pc, #304]	; (80076b8 <gc_execute_block+0x149c>)
 8007586:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007588:	494e      	ldr	r1, [pc, #312]	; (80076c4 <gc_execute_block+0x14a8>)
 800758a:	4618      	mov	r0, r3
 800758c:	f7f9 fc12 	bl	8000db4 <__aeabi_fmul>
 8007590:	4603      	mov	r3, r0
 8007592:	461a      	mov	r2, r3
 8007594:	4b48      	ldr	r3, [pc, #288]	; (80076b8 <gc_execute_block+0x149c>)
 8007596:	645a      	str	r2, [r3, #68]	; 0x44
 8007598:	4b47      	ldr	r3, [pc, #284]	; (80076b8 <gc_execute_block+0x149c>)
 800759a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800759c:	e001      	b.n	80075a2 <gc_execute_block+0x1386>
 800759e:	4b46      	ldr	r3, [pc, #280]	; (80076b8 <gc_execute_block+0x149c>)
 80075a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80075a2:	4a45      	ldr	r2, [pc, #276]	; (80076b8 <gc_execute_block+0x149c>)
 80075a4:	6493      	str	r3, [r2, #72]	; 0x48
 80075a6:	e043      	b.n	8007630 <gc_execute_block+0x1414>
        }

    } else if (gc_block.modal.feed_mode == FeedMode_InverseTime) { // = G93
 80075a8:	4b43      	ldr	r3, [pc, #268]	; (80076b8 <gc_execute_block+0x149c>)
 80075aa:	7a9b      	ldrb	r3, [r3, #10]
 80075ac:	2b01      	cmp	r3, #1
 80075ae:	d116      	bne.n	80075de <gc_execute_block+0x13c2>
        // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
        if (axis_command == AxisCommand_MotionMode) {
 80075b0:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 80075b4:	2b02      	cmp	r3, #2
 80075b6:	d13b      	bne.n	8007630 <gc_execute_block+0x1414>
            if (!(gc_block.modal.motion == MotionMode_None || gc_block.modal.motion == MotionMode_Seek)) {
 80075b8:	4b3f      	ldr	r3, [pc, #252]	; (80076b8 <gc_execute_block+0x149c>)
 80075ba:	891b      	ldrh	r3, [r3, #8]
 80075bc:	2b50      	cmp	r3, #80	; 0x50
 80075be:	d037      	beq.n	8007630 <gc_execute_block+0x1414>
 80075c0:	4b3d      	ldr	r3, [pc, #244]	; (80076b8 <gc_execute_block+0x149c>)
 80075c2:	891b      	ldrh	r3, [r3, #8]
 80075c4:	2b00      	cmp	r3, #0
 80075c6:	d033      	beq.n	8007630 <gc_execute_block+0x1414>
                if (!gc_block.words.f)
 80075c8:	4b3b      	ldr	r3, [pc, #236]	; (80076b8 <gc_execute_block+0x149c>)
 80075ca:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80075ce:	f003 0302 	and.w	r3, r3, #2
 80075d2:	b2db      	uxtb	r3, r3
 80075d4:	2b00      	cmp	r3, #0
 80075d6:	d12b      	bne.n	8007630 <gc_execute_block+0x1414>
                    FAIL(Status_GcodeUndefinedFeedRate); // [F word missing]
 80075d8:	2316      	movs	r3, #22
 80075da:	f004 b917 	b.w	800b80c <gc_execute_block+0x55f0>
        // NOTE: If in G93 mode or switched into it from G94, just keep F value as initialized zero or passed F word
        // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
        // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
        // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.

    } else if (gc_block.modal.feed_mode == FeedMode_UnitsPerMin || gc_block.modal.feed_mode == FeedMode_UnitsPerRev) {
 80075de:	4b36      	ldr	r3, [pc, #216]	; (80076b8 <gc_execute_block+0x149c>)
 80075e0:	7a9b      	ldrb	r3, [r3, #10]
 80075e2:	2b00      	cmp	r3, #0
 80075e4:	d003      	beq.n	80075ee <gc_execute_block+0x13d2>
 80075e6:	4b34      	ldr	r3, [pc, #208]	; (80076b8 <gc_execute_block+0x149c>)
 80075e8:	7a9b      	ldrb	r3, [r3, #10]
 80075ea:	2b02      	cmp	r3, #2
 80075ec:	d120      	bne.n	8007630 <gc_execute_block+0x1414>
          // if F word passed, ensure value is in mm/min or mm/rev depending on mode, otherwise push last state value.
        if (!gc_block.words.f) {
 80075ee:	4b32      	ldr	r3, [pc, #200]	; (80076b8 <gc_execute_block+0x149c>)
 80075f0:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80075f4:	f003 0302 	and.w	r3, r3, #2
 80075f8:	b2db      	uxtb	r3, r3
 80075fa:	2b00      	cmp	r3, #0
 80075fc:	d10a      	bne.n	8007614 <gc_execute_block+0x13f8>
            if(gc_block.modal.feed_mode == gc_state.modal.feed_mode)
 80075fe:	4b2e      	ldr	r3, [pc, #184]	; (80076b8 <gc_execute_block+0x149c>)
 8007600:	7a9a      	ldrb	r2, [r3, #10]
 8007602:	4b2e      	ldr	r3, [pc, #184]	; (80076bc <gc_execute_block+0x14a0>)
 8007604:	789b      	ldrb	r3, [r3, #2]
 8007606:	429a      	cmp	r2, r3
 8007608:	d112      	bne.n	8007630 <gc_execute_block+0x1414>
                gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 800760a:	4b2c      	ldr	r3, [pc, #176]	; (80076bc <gc_execute_block+0x14a0>)
 800760c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800760e:	4a2a      	ldr	r2, [pc, #168]	; (80076b8 <gc_execute_block+0x149c>)
 8007610:	6393      	str	r3, [r2, #56]	; 0x38
 8007612:	e00d      	b.n	8007630 <gc_execute_block+0x1414>
        } else if (gc_block.modal.units_imperial)
 8007614:	4b28      	ldr	r3, [pc, #160]	; (80076b8 <gc_execute_block+0x149c>)
 8007616:	7adb      	ldrb	r3, [r3, #11]
 8007618:	2b00      	cmp	r3, #0
 800761a:	d009      	beq.n	8007630 <gc_execute_block+0x1414>
            gc_block.values.f *= MM_PER_INCH;
 800761c:	4b26      	ldr	r3, [pc, #152]	; (80076b8 <gc_execute_block+0x149c>)
 800761e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007620:	4928      	ldr	r1, [pc, #160]	; (80076c4 <gc_execute_block+0x14a8>)
 8007622:	4618      	mov	r0, r3
 8007624:	f7f9 fbc6 	bl	8000db4 <__aeabi_fmul>
 8007628:	4603      	mov	r3, r0
 800762a:	461a      	mov	r2, r3
 800762c:	4b22      	ldr	r3, [pc, #136]	; (80076b8 <gc_execute_block+0x149c>)
 800762e:	639a      	str	r2, [r3, #56]	; 0x38
    } // else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.

    // bit_false(gc_block.words,bit(Word_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

    // [4. Set spindle speed and address spindle ]: S or D is negative (done.)
    if(gc_block.words.$) {
 8007630:	4b21      	ldr	r3, [pc, #132]	; (80076b8 <gc_execute_block+0x149c>)
 8007632:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8007636:	f003 0301 	and.w	r3, r3, #1
 800763a:	b2db      	uxtb	r3, r3
 800763c:	2b00      	cmp	r3, #0
 800763e:	f000 8099 	beq.w	8007774 <gc_execute_block+0x1558>
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 8007642:	4b1d      	ldr	r3, [pc, #116]	; (80076b8 <gc_execute_block+0x149c>)
 8007644:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007648:	f003 0308 	and.w	r3, r3, #8
 800764c:	b2db      	uxtb	r3, r3
                                    (command_words.G0 && (gc_block.modal.motion == MotionMode_SpindleSynchronized ||
                                                           gc_block.modal.motion == MotionMode_RigidTapping ||
                                                            gc_block.modal.motion == MotionMode_Threading)) ||
                                      command_words.G14 ||
 800764e:	2b00      	cmp	r3, #0
 8007650:	d006      	beq.n	8007660 <gc_execute_block+0x1444>
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 8007652:	4b1d      	ldr	r3, [pc, #116]	; (80076c8 <gc_execute_block+0x14ac>)
 8007654:	789b      	ldrb	r3, [r3, #2]
 8007656:	f003 0308 	and.w	r3, r3, #8
 800765a:	b2db      	uxtb	r3, r3
 800765c:	2b00      	cmp	r3, #0
 800765e:	d026      	beq.n	80076ae <gc_execute_block+0x1492>
                                    (command_words.G0 && (gc_block.modal.motion == MotionMode_SpindleSynchronized ||
 8007660:	f897 30a0 	ldrb.w	r3, [r7, #160]	; 0xa0
 8007664:	f003 0301 	and.w	r3, r3, #1
 8007668:	b2db      	uxtb	r3, r3
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 800766a:	2b00      	cmp	r3, #0
 800766c:	d00d      	beq.n	800768a <gc_execute_block+0x146e>
                                    (command_words.G0 && (gc_block.modal.motion == MotionMode_SpindleSynchronized ||
 800766e:	4b12      	ldr	r3, [pc, #72]	; (80076b8 <gc_execute_block+0x149c>)
 8007670:	891b      	ldrh	r3, [r3, #8]
 8007672:	2b21      	cmp	r3, #33	; 0x21
 8007674:	d01b      	beq.n	80076ae <gc_execute_block+0x1492>
                                                           gc_block.modal.motion == MotionMode_RigidTapping ||
 8007676:	4b10      	ldr	r3, [pc, #64]	; (80076b8 <gc_execute_block+0x149c>)
 8007678:	891b      	ldrh	r3, [r3, #8]
                                    (command_words.G0 && (gc_block.modal.motion == MotionMode_SpindleSynchronized ||
 800767a:	f240 124b 	movw	r2, #331	; 0x14b
 800767e:	4293      	cmp	r3, r2
 8007680:	d015      	beq.n	80076ae <gc_execute_block+0x1492>
                                                            gc_block.modal.motion == MotionMode_Threading)) ||
 8007682:	4b0d      	ldr	r3, [pc, #52]	; (80076b8 <gc_execute_block+0x149c>)
 8007684:	891b      	ldrh	r3, [r3, #8]
                                                           gc_block.modal.motion == MotionMode_RigidTapping ||
 8007686:	2b4c      	cmp	r3, #76	; 0x4c
 8007688:	d011      	beq.n	80076ae <gc_execute_block+0x1492>
                                                            gc_block.modal.motion == MotionMode_Threading)) ||
 800768a:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 800768e:	f003 0320 	and.w	r3, r3, #32
 8007692:	b2db      	uxtb	r3, r3
 8007694:	2b00      	cmp	r3, #0
 8007696:	d10a      	bne.n	80076ae <gc_execute_block+0x1492>
                                       (command_words.M9 && gc_block.override_command == Override_SpindleSpeed);
 8007698:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 800769c:	f003 0308 	and.w	r3, r3, #8
 80076a0:	b2db      	uxtb	r3, r3
                                      command_words.G14 ||
 80076a2:	2b00      	cmp	r3, #0
 80076a4:	d012      	beq.n	80076cc <gc_execute_block+0x14b0>
                                       (command_words.M9 && gc_block.override_command == Override_SpindleSpeed);
 80076a6:	4b04      	ldr	r3, [pc, #16]	; (80076b8 <gc_execute_block+0x149c>)
 80076a8:	785b      	ldrb	r3, [r3, #1]
 80076aa:	2b33      	cmp	r3, #51	; 0x33
 80076ac:	d10e      	bne.n	80076cc <gc_execute_block+0x14b0>
                                      command_words.G14 ||
 80076ae:	2301      	movs	r3, #1
 80076b0:	e00d      	b.n	80076ce <gc_execute_block+0x14b2>
 80076b2:	bf00      	nop
 80076b4:	08030c74 	.word	0x08030c74
 80076b8:	20000c8c 	.word	0x20000c8c
 80076bc:	20000bb0 	.word	0x20000bb0
 80076c0:	00989680 	.word	0x00989680
 80076c4:	41cb3333 	.word	0x41cb3333
 80076c8:	20000d38 	.word	0x20000d38
 80076cc:	2300      	movs	r3, #0
        bool single_spindle_only = (gc_block.words.s && !user_words.s) ||
 80076ce:	f887 30ec 	strb.w	r3, [r7, #236]	; 0xec
 80076d2:	f897 30ec 	ldrb.w	r3, [r7, #236]	; 0xec
 80076d6:	f003 0301 	and.w	r3, r3, #1
 80076da:	f887 30ec 	strb.w	r3, [r7, #236]	; 0xec
        if(command_words.M7 || single_spindle_only) {
 80076de:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 80076e2:	f003 0302 	and.w	r3, r3, #2
 80076e6:	b2db      	uxtb	r3, r3
 80076e8:	2b00      	cmp	r3, #0
 80076ea:	d103      	bne.n	80076f4 <gc_execute_block+0x14d8>
 80076ec:	f897 30ec 	ldrb.w	r3, [r7, #236]	; 0xec
 80076f0:	2b00      	cmp	r3, #0
 80076f2:	d049      	beq.n	8007788 <gc_execute_block+0x156c>
            if(gc_block.values.$ < (single_spindle_only ? 0 : -1))
 80076f4:	4b9b      	ldr	r3, [pc, #620]	; (8007964 <gc_execute_block+0x1748>)
 80076f6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80076f8:	f897 20ec 	ldrb.w	r2, [r7, #236]	; 0xec
 80076fc:	2a00      	cmp	r2, #0
 80076fe:	d001      	beq.n	8007704 <gc_execute_block+0x14e8>
 8007700:	2200      	movs	r2, #0
 8007702:	e001      	b.n	8007708 <gc_execute_block+0x14ec>
 8007704:	f04f 32ff 	mov.w	r2, #4294967295
 8007708:	429a      	cmp	r2, r3
 800770a:	dd09      	ble.n	8007720 <gc_execute_block+0x1504>
                FAIL(single_spindle_only ? Status_NegativeValue : Status_GcodeValueOutOfRange);
 800770c:	f897 30ec 	ldrb.w	r3, [r7, #236]	; 0xec
 8007710:	2b00      	cmp	r3, #0
 8007712:	d002      	beq.n	800771a <gc_execute_block+0x14fe>
 8007714:	2304      	movs	r3, #4
 8007716:	f004 b879 	b.w	800b80c <gc_execute_block+0x55f0>
 800771a:	2327      	movs	r3, #39	; 0x27
 800771c:	f004 b876 	b.w	800b80c <gc_execute_block+0x55f0>
            if(!spindle_is_enabled(gc_block.values.$))
 8007720:	4b90      	ldr	r3, [pc, #576]	; (8007964 <gc_execute_block+0x1748>)
 8007722:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8007724:	b25b      	sxtb	r3, r3
 8007726:	4618      	mov	r0, r3
 8007728:	f015 f9ba 	bl	801caa0 <spindle_is_enabled>
 800772c:	4603      	mov	r3, r0
 800772e:	f083 0301 	eor.w	r3, r3, #1
 8007732:	b2db      	uxtb	r3, r3
 8007734:	2b00      	cmp	r3, #0
 8007736:	d002      	beq.n	800773e <gc_execute_block+0x1522>
                FAIL(Status_GcodeValueOutOfRange);
 8007738:	2327      	movs	r3, #39	; 0x27
 800773a:	f004 b867 	b.w	800b80c <gc_execute_block+0x55f0>
            if(gc_block.values.$ >= 0)
 800773e:	4b89      	ldr	r3, [pc, #548]	; (8007964 <gc_execute_block+0x1748>)
 8007740:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8007742:	2b00      	cmp	r3, #0
 8007744:	db0e      	blt.n	8007764 <gc_execute_block+0x1548>
                gc_state.spindle.hal = gc_block.spindle = spindle_get(gc_block.values.$);
 8007746:	4b87      	ldr	r3, [pc, #540]	; (8007964 <gc_execute_block+0x1748>)
 8007748:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800774a:	b25b      	sxtb	r3, r3
 800774c:	4618      	mov	r0, r3
 800774e:	f015 f9d5 	bl	801cafc <spindle_get>
 8007752:	4603      	mov	r3, r0
 8007754:	4a83      	ldr	r2, [pc, #524]	; (8007964 <gc_execute_block+0x1748>)
 8007756:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
 800775a:	4b82      	ldr	r3, [pc, #520]	; (8007964 <gc_execute_block+0x1748>)
 800775c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8007760:	4a81      	ldr	r2, [pc, #516]	; (8007968 <gc_execute_block+0x174c>)
 8007762:	6513      	str	r3, [r2, #80]	; 0x50
            gc_block.words.$ = Off;
 8007764:	4a7f      	ldr	r2, [pc, #508]	; (8007964 <gc_execute_block+0x1748>)
 8007766:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 800776a:	f36f 0300 	bfc	r3, #0, #1
 800776e:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8007772:	e009      	b.n	8007788 <gc_execute_block+0x156c>
        }
    } else if(gc_block.spindle == NULL)
 8007774:	4b7b      	ldr	r3, [pc, #492]	; (8007964 <gc_execute_block+0x1748>)
 8007776:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800777a:	2b00      	cmp	r3, #0
 800777c:	d104      	bne.n	8007788 <gc_execute_block+0x156c>
        gc_block.spindle = gc_state.spindle.hal;
 800777e:	4b7a      	ldr	r3, [pc, #488]	; (8007968 <gc_execute_block+0x174c>)
 8007780:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007782:	4a78      	ldr	r2, [pc, #480]	; (8007964 <gc_execute_block+0x1748>)
 8007784:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8

    if(gc_block.modal.feed_mode == FeedMode_UnitsPerRev && !gc_state.spindle.hal->get_data)
 8007788:	4b76      	ldr	r3, [pc, #472]	; (8007964 <gc_execute_block+0x1748>)
 800778a:	7a9b      	ldrb	r3, [r3, #10]
 800778c:	2b02      	cmp	r3, #2
 800778e:	d107      	bne.n	80077a0 <gc_execute_block+0x1584>
 8007790:	4b75      	ldr	r3, [pc, #468]	; (8007968 <gc_execute_block+0x174c>)
 8007792:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007794:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007796:	2b00      	cmp	r3, #0
 8007798:	d102      	bne.n	80077a0 <gc_execute_block+0x1584>
        FAIL(Status_GcodeUnsupportedCommand); // [G95 not supported]
 800779a:	2314      	movs	r3, #20
 800779c:	f004 b836 	b.w	800b80c <gc_execute_block+0x55f0>

    if (command_words.G14) {
 80077a0:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 80077a4:	f003 0320 	and.w	r3, r3, #32
 80077a8:	b2db      	uxtb	r3, r3
 80077aa:	2b00      	cmp	r3, #0
 80077ac:	d060      	beq.n	8007870 <gc_execute_block+0x1654>
        if(gc_block.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 80077ae:	4b6d      	ldr	r3, [pc, #436]	; (8007964 <gc_execute_block+0x1748>)
 80077b0:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 80077b4:	2b01      	cmp	r3, #1
 80077b6:	d143      	bne.n	8007840 <gc_execute_block+0x1624>
            if(!gc_state.spindle.hal->cap.variable)
 80077b8:	4b6b      	ldr	r3, [pc, #428]	; (8007968 <gc_execute_block+0x174c>)
 80077ba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80077bc:	7a9b      	ldrb	r3, [r3, #10]
 80077be:	f003 0301 	and.w	r3, r3, #1
 80077c2:	b2db      	uxtb	r3, r3
 80077c4:	2b00      	cmp	r3, #0
 80077c6:	d102      	bne.n	80077ce <gc_execute_block+0x15b2>
                FAIL(Status_GcodeUnsupportedCommand);
 80077c8:	2314      	movs	r3, #20
 80077ca:	f004 b81f 	b.w	800b80c <gc_execute_block+0x55f0>
            if (!gc_block.words.s) // TODO: add check for S0?
 80077ce:	4b65      	ldr	r3, [pc, #404]	; (8007964 <gc_execute_block+0x1748>)
 80077d0:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80077d4:	f003 0308 	and.w	r3, r3, #8
 80077d8:	b2db      	uxtb	r3, r3
 80077da:	2b00      	cmp	r3, #0
 80077dc:	d102      	bne.n	80077e4 <gc_execute_block+0x15c8>
                FAIL(Status_GcodeValueWordMissing);
 80077de:	231c      	movs	r3, #28
 80077e0:	f004 b814 	b.w	800b80c <gc_execute_block+0x55f0>
    // see below!! gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
            if (gc_block.words.d) {
 80077e4:	4b5f      	ldr	r3, [pc, #380]	; (8007964 <gc_execute_block+0x1748>)
 80077e6:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80077ea:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80077ee:	b2db      	uxtb	r3, r3
 80077f0:	2b00      	cmp	r3, #0
 80077f2:	d01d      	beq.n	8007830 <gc_execute_block+0x1614>
                gc_state.spindle.hal->param->css.max_rpm = min(gc_block.values.d, gc_state.spindle.hal->rpm_max);
 80077f4:	4b5b      	ldr	r3, [pc, #364]	; (8007964 <gc_execute_block+0x1748>)
 80077f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80077f8:	4b5b      	ldr	r3, [pc, #364]	; (8007968 <gc_execute_block+0x174c>)
 80077fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80077fc:	699b      	ldr	r3, [r3, #24]
 80077fe:	4619      	mov	r1, r3
 8007800:	4610      	mov	r0, r2
 8007802:	f7f9 fc75 	bl	80010f0 <__aeabi_fcmplt>
 8007806:	4603      	mov	r3, r0
 8007808:	2b00      	cmp	r3, #0
 800780a:	d002      	beq.n	8007812 <gc_execute_block+0x15f6>
 800780c:	4b55      	ldr	r3, [pc, #340]	; (8007964 <gc_execute_block+0x1748>)
 800780e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007810:	e002      	b.n	8007818 <gc_execute_block+0x15fc>
 8007812:	4b55      	ldr	r3, [pc, #340]	; (8007968 <gc_execute_block+0x174c>)
 8007814:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007816:	699b      	ldr	r3, [r3, #24]
 8007818:	4a53      	ldr	r2, [pc, #332]	; (8007968 <gc_execute_block+0x174c>)
 800781a:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800781c:	6852      	ldr	r2, [r2, #4]
 800781e:	61d3      	str	r3, [r2, #28]
                gc_block.words.d = Off;
 8007820:	4a50      	ldr	r2, [pc, #320]	; (8007964 <gc_execute_block+0x1748>)
 8007822:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8007826:	f36f 13c7 	bfc	r3, #7, #1
 800782a:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 800782e:	e01a      	b.n	8007866 <gc_execute_block+0x164a>
            } else
                gc_state.spindle.hal->param->css.max_rpm = gc_state.spindle.hal->rpm_max;
 8007830:	4b4d      	ldr	r3, [pc, #308]	; (8007968 <gc_execute_block+0x174c>)
 8007832:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007834:	4b4c      	ldr	r3, [pc, #304]	; (8007968 <gc_execute_block+0x174c>)
 8007836:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007838:	685b      	ldr	r3, [r3, #4]
 800783a:	6992      	ldr	r2, [r2, #24]
 800783c:	61da      	str	r2, [r3, #28]
 800783e:	e012      	b.n	8007866 <gc_execute_block+0x164a>
        } else if(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 8007840:	4b49      	ldr	r3, [pc, #292]	; (8007968 <gc_execute_block+0x174c>)
 8007842:	7edb      	ldrb	r3, [r3, #27]
 8007844:	2b01      	cmp	r3, #1
 8007846:	d10e      	bne.n	8007866 <gc_execute_block+0x164a>
            if(gc_state.spindle.css) {
 8007848:	4b47      	ldr	r3, [pc, #284]	; (8007968 <gc_execute_block+0x174c>)
 800784a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800784c:	2b00      	cmp	r3, #0
 800784e:	d004      	beq.n	800785a <gc_execute_block+0x163e>
                gc_state.spindle.css = NULL;
 8007850:	4b45      	ldr	r3, [pc, #276]	; (8007968 <gc_execute_block+0x174c>)
 8007852:	2200      	movs	r2, #0
 8007854:	64da      	str	r2, [r3, #76]	; 0x4c
                protocol_buffer_synchronize(); // Empty planner buffer to ensure we get RPM at end of last CSS motion
 8007856:	f00b fa53 	bl	8012d00 <protocol_buffer_synchronize>
            }
            gc_state.spindle.rpm = gc_state.spindle.hal->param->rpm; // Is it correct to restore latest spindle RPM here?
 800785a:	4b43      	ldr	r3, [pc, #268]	; (8007968 <gc_execute_block+0x174c>)
 800785c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800785e:	685b      	ldr	r3, [r3, #4]
 8007860:	681b      	ldr	r3, [r3, #0]
 8007862:	4a41      	ldr	r2, [pc, #260]	; (8007968 <gc_execute_block+0x174c>)
 8007864:	6453      	str	r3, [r2, #68]	; 0x44
        }
        gc_state.modal.spindle.rpm_mode = gc_block.modal.spindle.rpm_mode;
 8007866:	4b3f      	ldr	r3, [pc, #252]	; (8007964 <gc_execute_block+0x1748>)
 8007868:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 800786c:	4b3e      	ldr	r3, [pc, #248]	; (8007968 <gc_execute_block+0x174c>)
 800786e:	76da      	strb	r2, [r3, #27]
    }

    spindle_programmed = gc_block.words.s && !user_words.s;
 8007870:	4b3c      	ldr	r3, [pc, #240]	; (8007964 <gc_execute_block+0x1748>)
 8007872:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007876:	f003 0308 	and.w	r3, r3, #8
 800787a:	b2db      	uxtb	r3, r3
 800787c:	2b00      	cmp	r3, #0
 800787e:	d008      	beq.n	8007892 <gc_execute_block+0x1676>
 8007880:	4b3a      	ldr	r3, [pc, #232]	; (800796c <gc_execute_block+0x1750>)
 8007882:	789b      	ldrb	r3, [r3, #2]
 8007884:	f003 0308 	and.w	r3, r3, #8
 8007888:	b2db      	uxtb	r3, r3
 800788a:	2b00      	cmp	r3, #0
 800788c:	d101      	bne.n	8007892 <gc_execute_block+0x1676>
 800788e:	2301      	movs	r3, #1
 8007890:	e000      	b.n	8007894 <gc_execute_block+0x1678>
 8007892:	2300      	movs	r3, #0
 8007894:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
 8007898:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800789c:	f003 0301 	and.w	r3, r3, #1
 80078a0:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e

    if (!gc_block.words.s)
 80078a4:	4b2f      	ldr	r3, [pc, #188]	; (8007964 <gc_execute_block+0x1748>)
 80078a6:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80078aa:	f003 0308 	and.w	r3, r3, #8
 80078ae:	b2db      	uxtb	r3, r3
 80078b0:	2b00      	cmp	r3, #0
 80078b2:	d10d      	bne.n	80078d0 <gc_execute_block+0x16b4>
        gc_block.values.s = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? gc_state.spindle.rpm : gc_state.spindle.hal->param->css.max_rpm;
 80078b4:	4b2c      	ldr	r3, [pc, #176]	; (8007968 <gc_execute_block+0x174c>)
 80078b6:	7edb      	ldrb	r3, [r3, #27]
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	d102      	bne.n	80078c2 <gc_execute_block+0x16a6>
 80078bc:	4b2a      	ldr	r3, [pc, #168]	; (8007968 <gc_execute_block+0x174c>)
 80078be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80078c0:	e003      	b.n	80078ca <gc_execute_block+0x16ae>
 80078c2:	4b29      	ldr	r3, [pc, #164]	; (8007968 <gc_execute_block+0x174c>)
 80078c4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80078c6:	685b      	ldr	r3, [r3, #4]
 80078c8:	69db      	ldr	r3, [r3, #28]
 80078ca:	4a26      	ldr	r2, [pc, #152]	; (8007964 <gc_execute_block+0x1748>)
 80078cc:	65d3      	str	r3, [r2, #92]	; 0x5c
 80078ce:	e021      	b.n	8007914 <gc_execute_block+0x16f8>
    else if(!user_words.s && gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 80078d0:	4b26      	ldr	r3, [pc, #152]	; (800796c <gc_execute_block+0x1750>)
 80078d2:	789b      	ldrb	r3, [r3, #2]
 80078d4:	f003 0308 	and.w	r3, r3, #8
 80078d8:	b2db      	uxtb	r3, r3
 80078da:	2b00      	cmp	r3, #0
 80078dc:	d11a      	bne.n	8007914 <gc_execute_block+0x16f8>
 80078de:	4b22      	ldr	r3, [pc, #136]	; (8007968 <gc_execute_block+0x174c>)
 80078e0:	7edb      	ldrb	r3, [r3, #27]
 80078e2:	2b01      	cmp	r3, #1
 80078e4:	d116      	bne.n	8007914 <gc_execute_block+0x16f8>
        // Unsure what to do about S values when in SpindleSpeedMode_CSS - ignore? For now use it to (re)calculate surface speed.
        // Reinsert commented out code above if this is removed!!
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
 80078e6:	4b1f      	ldr	r3, [pc, #124]	; (8007964 <gc_execute_block+0x1748>)
 80078e8:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80078ea:	4b1e      	ldr	r3, [pc, #120]	; (8007964 <gc_execute_block+0x1748>)
 80078ec:	7adb      	ldrb	r3, [r3, #11]
 80078ee:	2b00      	cmp	r3, #0
 80078f0:	d001      	beq.n	80078f6 <gc_execute_block+0x16da>
 80078f2:	4b1f      	ldr	r3, [pc, #124]	; (8007970 <gc_execute_block+0x1754>)
 80078f4:	e000      	b.n	80078f8 <gc_execute_block+0x16dc>
 80078f6:	4b1f      	ldr	r3, [pc, #124]	; (8007974 <gc_execute_block+0x1758>)
 80078f8:	4611      	mov	r1, r2
 80078fa:	4618      	mov	r0, r3
 80078fc:	f7f9 fa5a 	bl	8000db4 <__aeabi_fmul>
 8007900:	4603      	mov	r3, r0
 8007902:	461a      	mov	r2, r3
 8007904:	4b17      	ldr	r3, [pc, #92]	; (8007964 <gc_execute_block+0x1748>)
 8007906:	65da      	str	r2, [r3, #92]	; 0x5c
        gc_state.spindle.hal->param->css.surface_speed = gc_block.values.s;
 8007908:	4b17      	ldr	r3, [pc, #92]	; (8007968 <gc_execute_block+0x174c>)
 800790a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800790c:	685b      	ldr	r3, [r3, #4]
 800790e:	4a15      	ldr	r2, [pc, #84]	; (8007964 <gc_execute_block+0x1748>)
 8007910:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8007912:	611a      	str	r2, [r3, #16]
    }

    // bit_false(gc_block.words,bit(Word_S)); // NOTE: Single-meaning value word. Set at end of error-checking.

    // [5. Select tool ]: If not supported then only tracks value. T is negative (done.) Not an integer (done).
    if(set_tool) { // M61
 8007914:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 8007918:	2b00      	cmp	r3, #0
 800791a:	d060      	beq.n	80079de <gc_execute_block+0x17c2>
        if(!gc_block.words.q)
 800791c:	4b11      	ldr	r3, [pc, #68]	; (8007964 <gc_execute_block+0x1748>)
 800791e:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007922:	f003 0302 	and.w	r3, r3, #2
 8007926:	b2db      	uxtb	r3, r3
 8007928:	2b00      	cmp	r3, #0
 800792a:	d102      	bne.n	8007932 <gc_execute_block+0x1716>
            FAIL(Status_GcodeValueWordMissing);
 800792c:	231c      	movs	r3, #28
 800792e:	f003 bf6d 	b.w	800b80c <gc_execute_block+0x55f0>
        if (floorf(gc_block.values.q) - gc_block.values.q != 0.0f)
 8007932:	4b0c      	ldr	r3, [pc, #48]	; (8007964 <gc_execute_block+0x1748>)
 8007934:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007936:	4618      	mov	r0, r3
 8007938:	f01d f9f8 	bl	8024d2c <floorf>
 800793c:	4602      	mov	r2, r0
 800793e:	4b09      	ldr	r3, [pc, #36]	; (8007964 <gc_execute_block+0x1748>)
 8007940:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007942:	4619      	mov	r1, r3
 8007944:	4610      	mov	r0, r2
 8007946:	f7f9 f92b 	bl	8000ba0 <__aeabi_fsub>
 800794a:	4603      	mov	r3, r0
 800794c:	f04f 0100 	mov.w	r1, #0
 8007950:	4618      	mov	r0, r3
 8007952:	f7f9 fbc3 	bl	80010dc <__aeabi_fcmpeq>
 8007956:	4603      	mov	r3, r0
 8007958:	2b00      	cmp	r3, #0
 800795a:	d10d      	bne.n	8007978 <gc_execute_block+0x175c>
            FAIL(Status_GcodeCommandValueNotInteger);
 800795c:	2317      	movs	r3, #23
 800795e:	f003 bf55 	b.w	800b80c <gc_execute_block+0x55f0>
 8007962:	bf00      	nop
 8007964:	20000c8c 	.word	0x20000c8c
 8007968:	20000bb0 	.word	0x20000bb0
 800796c:	20000d38 	.word	0x20000d38
 8007970:	43986666 	.word	0x43986666
 8007974:	447a0000 	.word	0x447a0000
        if ((uint32_t)gc_block.values.q > (grbl.tool_table.n_tools ? grbl.tool_table.n_tools : MAX_TOOL_NUMBER))
 8007978:	4b9c      	ldr	r3, [pc, #624]	; (8007bec <gc_execute_block+0x19d0>)
 800797a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800797c:	4618      	mov	r0, r3
 800797e:	f7f9 fc1b 	bl	80011b8 <__aeabi_f2uiz>
 8007982:	4603      	mov	r3, r0
 8007984:	2200      	movs	r2, #0
 8007986:	603b      	str	r3, [r7, #0]
 8007988:	607a      	str	r2, [r7, #4]
 800798a:	4b99      	ldr	r3, [pc, #612]	; (8007bf0 <gc_execute_block+0x19d4>)
 800798c:	699b      	ldr	r3, [r3, #24]
 800798e:	2b00      	cmp	r3, #0
 8007990:	d005      	beq.n	800799e <gc_execute_block+0x1782>
 8007992:	4b97      	ldr	r3, [pc, #604]	; (8007bf0 <gc_execute_block+0x19d4>)
 8007994:	699b      	ldr	r3, [r3, #24]
 8007996:	2200      	movs	r2, #0
 8007998:	4698      	mov	r8, r3
 800799a:	4691      	mov	r9, r2
 800799c:	e003      	b.n	80079a6 <gc_execute_block+0x178a>
 800799e:	f06f 0801 	mvn.w	r8, #1
 80079a2:	f04f 0900 	mov.w	r9, #0
 80079a6:	e9d7 3400 	ldrd	r3, r4, [r7]
 80079aa:	461a      	mov	r2, r3
 80079ac:	4590      	cmp	r8, r2
 80079ae:	4623      	mov	r3, r4
 80079b0:	eb79 0303 	sbcs.w	r3, r9, r3
 80079b4:	da02      	bge.n	80079bc <gc_execute_block+0x17a0>
            FAIL(Status_GcodeIllegalToolTableEntry);
 80079b6:	2326      	movs	r3, #38	; 0x26
 80079b8:	f003 bf28 	b.w	800b80c <gc_execute_block+0x55f0>

        gc_block.values.t = (uint32_t)gc_block.values.q;
 80079bc:	4b8b      	ldr	r3, [pc, #556]	; (8007bec <gc_execute_block+0x19d0>)
 80079be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80079c0:	4618      	mov	r0, r3
 80079c2:	f7f9 fbf9 	bl	80011b8 <__aeabi_f2uiz>
 80079c6:	4603      	mov	r3, r0
 80079c8:	4a88      	ldr	r2, [pc, #544]	; (8007bec <gc_execute_block+0x19d0>)
 80079ca:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
        gc_block.words.q = Off;
 80079ce:	4a87      	ldr	r2, [pc, #540]	; (8007bec <gc_execute_block+0x19d0>)
 80079d0:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80079d4:	f36f 0341 	bfc	r3, #1, #1
 80079d8:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80079dc:	e00c      	b.n	80079f8 <gc_execute_block+0x17dc>
                }
                gc_state.g43_pending = 0;
            }
        }
#endif
    } else if (!gc_block.words.t)
 80079de:	4b83      	ldr	r3, [pc, #524]	; (8007bec <gc_execute_block+0x19d0>)
 80079e0:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80079e4:	f003 0310 	and.w	r3, r3, #16
 80079e8:	b2db      	uxtb	r3, r3
 80079ea:	2b00      	cmp	r3, #0
 80079ec:	d104      	bne.n	80079f8 <gc_execute_block+0x17dc>
        gc_block.values.t = gc_state.tool_pending;
 80079ee:	4b81      	ldr	r3, [pc, #516]	; (8007bf4 <gc_execute_block+0x19d8>)
 80079f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80079f2:	4a7e      	ldr	r2, [pc, #504]	; (8007bec <gc_execute_block+0x19d0>)
 80079f4:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c

    if(command_words.M10 && port_command) {
 80079f8:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 80079fc:	f003 0310 	and.w	r3, r3, #16
 8007a00:	b2db      	uxtb	r3, r3
 8007a02:	2b00      	cmp	r3, #0
 8007a04:	f000 8185 	beq.w	8007d12 <gc_execute_block+0x1af6>
 8007a08:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 8007a0c:	2b00      	cmp	r3, #0
 8007a0e:	f000 8180 	beq.w	8007d12 <gc_execute_block+0x1af6>

        switch(port_command) {
 8007a12:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 8007a16:	2b44      	cmp	r3, #68	; 0x44
 8007a18:	f300 817b 	bgt.w	8007d12 <gc_execute_block+0x1af6>
 8007a1c:	2b43      	cmp	r3, #67	; 0x43
 8007a1e:	f280 812a 	bge.w	8007c76 <gc_execute_block+0x1a5a>
 8007a22:	2b41      	cmp	r3, #65	; 0x41
 8007a24:	dc02      	bgt.n	8007a2c <gc_execute_block+0x1810>
 8007a26:	2b3e      	cmp	r3, #62	; 0x3e
 8007a28:	da03      	bge.n	8007a32 <gc_execute_block+0x1816>
 8007a2a:	e172      	b.n	8007d12 <gc_execute_block+0x1af6>
 8007a2c:	2b42      	cmp	r3, #66	; 0x42
 8007a2e:	d04b      	beq.n	8007ac8 <gc_execute_block+0x18ac>
 8007a30:	e16f      	b.n	8007d12 <gc_execute_block+0x1af6>

            case IoMCode_OutputOnSynced:
            case IoMCode_OutputOffSynced:
            case IoMCode_OutputOnImmediate:
            case IoMCode_OutputOffImmediate:
                if(!gc_block.words.p)
 8007a32:	4b6e      	ldr	r3, [pc, #440]	; (8007bec <gc_execute_block+0x19d0>)
 8007a34:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007a38:	f003 0301 	and.w	r3, r3, #1
 8007a3c:	b2db      	uxtb	r3, r3
 8007a3e:	2b00      	cmp	r3, #0
 8007a40:	d102      	bne.n	8007a48 <gc_execute_block+0x182c>
                    FAIL(Status_GcodeValueWordMissing);
 8007a42:	231c      	movs	r3, #28
 8007a44:	f003 bee2 	b.w	800b80c <gc_execute_block+0x55f0>
                if(gc_block.values.p < 0.0f)
 8007a48:	4b68      	ldr	r3, [pc, #416]	; (8007bec <gc_execute_block+0x19d0>)
 8007a4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007a4c:	f04f 0100 	mov.w	r1, #0
 8007a50:	4618      	mov	r0, r3
 8007a52:	f7f9 fb4d 	bl	80010f0 <__aeabi_fcmplt>
 8007a56:	4603      	mov	r3, r0
 8007a58:	2b00      	cmp	r3, #0
 8007a5a:	d002      	beq.n	8007a62 <gc_execute_block+0x1846>
                    FAIL(Status_NegativeValue);
 8007a5c:	2304      	movs	r3, #4
 8007a5e:	f003 bed5 	b.w	800b80c <gc_execute_block+0x55f0>
                if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital_out)
 8007a62:	4b62      	ldr	r3, [pc, #392]	; (8007bec <gc_execute_block+0x19d0>)
 8007a64:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007a66:	4618      	mov	r0, r3
 8007a68:	f7f9 fba6 	bl	80011b8 <__aeabi_f2uiz>
 8007a6c:	4603      	mov	r3, r0
 8007a6e:	3301      	adds	r3, #1
 8007a70:	4a61      	ldr	r2, [pc, #388]	; (8007bf8 <gc_execute_block+0x19dc>)
 8007a72:	f892 2115 	ldrb.w	r2, [r2, #277]	; 0x115
 8007a76:	4293      	cmp	r3, r2
 8007a78:	d902      	bls.n	8007a80 <gc_execute_block+0x1864>
                    FAIL(Status_GcodeValueOutOfRange);
 8007a7a:	2327      	movs	r3, #39	; 0x27
 8007a7c:	f003 bec6 	b.w	800b80c <gc_execute_block+0x55f0>
                gc_block.output_command.is_digital = true;
 8007a80:	4b5a      	ldr	r3, [pc, #360]	; (8007bec <gc_execute_block+0x19d0>)
 8007a82:	2201      	movs	r2, #1
 8007a84:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
                gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8007a88:	4b58      	ldr	r3, [pc, #352]	; (8007bec <gc_execute_block+0x19d0>)
 8007a8a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007a8c:	4618      	mov	r0, r3
 8007a8e:	f7f9 fb93 	bl	80011b8 <__aeabi_f2uiz>
 8007a92:	4603      	mov	r3, r0
 8007a94:	b2da      	uxtb	r2, r3
 8007a96:	4b55      	ldr	r3, [pc, #340]	; (8007bec <gc_execute_block+0x19d0>)
 8007a98:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 8007a9c:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 8007aa0:	2b3e      	cmp	r3, #62	; 0x3e
 8007aa2:	d003      	beq.n	8007aac <gc_execute_block+0x1890>
 8007aa4:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 8007aa8:	2b40      	cmp	r3, #64	; 0x40
 8007aaa:	d101      	bne.n	8007ab0 <gc_execute_block+0x1894>
 8007aac:	2301      	movs	r3, #1
 8007aae:	e000      	b.n	8007ab2 <gc_execute_block+0x1896>
 8007ab0:	2300      	movs	r3, #0
 8007ab2:	4a4e      	ldr	r2, [pc, #312]	; (8007bec <gc_execute_block+0x19d0>)
 8007ab4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
                gc_block.words.p = Off;
 8007ab8:	4a4c      	ldr	r2, [pc, #304]	; (8007bec <gc_execute_block+0x19d0>)
 8007aba:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8007abe:	f36f 0300 	bfc	r3, #0, #1
 8007ac2:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                break;
 8007ac6:	e124      	b.n	8007d12 <gc_execute_block+0x1af6>

            case IoMCode_WaitOnInput:
                if(!(gc_block.words.l || gc_block.words.q))
 8007ac8:	4b48      	ldr	r3, [pc, #288]	; (8007bec <gc_execute_block+0x19d0>)
 8007aca:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8007ace:	f003 0310 	and.w	r3, r3, #16
 8007ad2:	b2db      	uxtb	r3, r3
 8007ad4:	2b00      	cmp	r3, #0
 8007ad6:	d10a      	bne.n	8007aee <gc_execute_block+0x18d2>
 8007ad8:	4b44      	ldr	r3, [pc, #272]	; (8007bec <gc_execute_block+0x19d0>)
 8007ada:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007ade:	f003 0302 	and.w	r3, r3, #2
 8007ae2:	b2db      	uxtb	r3, r3
 8007ae4:	2b00      	cmp	r3, #0
 8007ae6:	d102      	bne.n	8007aee <gc_execute_block+0x18d2>
                    FAIL(Status_GcodeValueWordMissing);
 8007ae8:	231c      	movs	r3, #28
 8007aea:	f003 be8f 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.words.p && gc_block.words.e)
 8007aee:	4b3f      	ldr	r3, [pc, #252]	; (8007bec <gc_execute_block+0x19d0>)
 8007af0:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007af4:	f003 0301 	and.w	r3, r3, #1
 8007af8:	b2db      	uxtb	r3, r3
 8007afa:	2b00      	cmp	r3, #0
 8007afc:	d00a      	beq.n	8007b14 <gc_execute_block+0x18f8>
 8007afe:	4b3b      	ldr	r3, [pc, #236]	; (8007bec <gc_execute_block+0x19d0>)
 8007b00:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8007b04:	f003 0301 	and.w	r3, r3, #1
 8007b08:	b2db      	uxtb	r3, r3
 8007b0a:	2b00      	cmp	r3, #0
 8007b0c:	d002      	beq.n	8007b14 <gc_execute_block+0x18f8>
                    FAIL(Status_ValueWordConflict);
 8007b0e:	2330      	movs	r3, #48	; 0x30
 8007b10:	f003 be7c 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.values.l >= (uint8_t)WaitMode_Max)
 8007b14:	4b35      	ldr	r3, [pc, #212]	; (8007bec <gc_execute_block+0x19d0>)
 8007b16:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8007b1a:	2b04      	cmp	r3, #4
 8007b1c:	d902      	bls.n	8007b24 <gc_execute_block+0x1908>
                    FAIL(Status_GcodeValueOutOfRange);
 8007b1e:	2327      	movs	r3, #39	; 0x27
 8007b20:	f003 be74 	b.w	800b80c <gc_execute_block+0x55f0>

                if((wait_mode_t)gc_block.values.l != WaitMode_Immediate && gc_block.values.q == 0.0f)
 8007b24:	4b31      	ldr	r3, [pc, #196]	; (8007bec <gc_execute_block+0x19d0>)
 8007b26:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8007b2a:	2b00      	cmp	r3, #0
 8007b2c:	d00c      	beq.n	8007b48 <gc_execute_block+0x192c>
 8007b2e:	4b2f      	ldr	r3, [pc, #188]	; (8007bec <gc_execute_block+0x19d0>)
 8007b30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007b32:	f04f 0100 	mov.w	r1, #0
 8007b36:	4618      	mov	r0, r3
 8007b38:	f7f9 fad0 	bl	80010dc <__aeabi_fcmpeq>
 8007b3c:	4603      	mov	r3, r0
 8007b3e:	2b00      	cmp	r3, #0
 8007b40:	d002      	beq.n	8007b48 <gc_execute_block+0x192c>
                    FAIL(Status_GcodeValueOutOfRange);
 8007b42:	2327      	movs	r3, #39	; 0x27
 8007b44:	f003 be62 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.words.p) {
 8007b48:	4b28      	ldr	r3, [pc, #160]	; (8007bec <gc_execute_block+0x19d0>)
 8007b4a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007b4e:	f003 0301 	and.w	r3, r3, #1
 8007b52:	b2db      	uxtb	r3, r3
 8007b54:	2b00      	cmp	r3, #0
 8007b56:	d029      	beq.n	8007bac <gc_execute_block+0x1990>
                    if(gc_block.values.p < 0.0f)
 8007b58:	4b24      	ldr	r3, [pc, #144]	; (8007bec <gc_execute_block+0x19d0>)
 8007b5a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007b5c:	f04f 0100 	mov.w	r1, #0
 8007b60:	4618      	mov	r0, r3
 8007b62:	f7f9 fac5 	bl	80010f0 <__aeabi_fcmplt>
 8007b66:	4603      	mov	r3, r0
 8007b68:	2b00      	cmp	r3, #0
 8007b6a:	d002      	beq.n	8007b72 <gc_execute_block+0x1956>
                        FAIL(Status_NegativeValue);
 8007b6c:	2304      	movs	r3, #4
 8007b6e:	f003 be4d 	b.w	800b80c <gc_execute_block+0x55f0>
                    if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital_in)
 8007b72:	4b1e      	ldr	r3, [pc, #120]	; (8007bec <gc_execute_block+0x19d0>)
 8007b74:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007b76:	4618      	mov	r0, r3
 8007b78:	f7f9 fb1e 	bl	80011b8 <__aeabi_f2uiz>
 8007b7c:	4603      	mov	r3, r0
 8007b7e:	3301      	adds	r3, #1
 8007b80:	4a1d      	ldr	r2, [pc, #116]	; (8007bf8 <gc_execute_block+0x19dc>)
 8007b82:	f892 2114 	ldrb.w	r2, [r2, #276]	; 0x114
 8007b86:	4293      	cmp	r3, r2
 8007b88:	d902      	bls.n	8007b90 <gc_execute_block+0x1974>
                        FAIL(Status_GcodeValueOutOfRange);
 8007b8a:	2327      	movs	r3, #39	; 0x27
 8007b8c:	f003 be3e 	b.w	800b80c <gc_execute_block+0x55f0>

                    gc_block.output_command.is_digital = true;
 8007b90:	4b16      	ldr	r3, [pc, #88]	; (8007bec <gc_execute_block+0x19d0>)
 8007b92:	2201      	movs	r2, #1
 8007b94:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
                    gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8007b98:	4b14      	ldr	r3, [pc, #80]	; (8007bec <gc_execute_block+0x19d0>)
 8007b9a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007b9c:	4618      	mov	r0, r3
 8007b9e:	f7f9 fb0b 	bl	80011b8 <__aeabi_f2uiz>
 8007ba2:	4603      	mov	r3, r0
 8007ba4:	b2da      	uxtb	r2, r3
 8007ba6:	4b11      	ldr	r3, [pc, #68]	; (8007bec <gc_execute_block+0x19d0>)
 8007ba8:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
                }

                if(gc_block.words.e) {
 8007bac:	4b0f      	ldr	r3, [pc, #60]	; (8007bec <gc_execute_block+0x19d0>)
 8007bae:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8007bb2:	f003 0301 	and.w	r3, r3, #1
 8007bb6:	b2db      	uxtb	r3, r3
 8007bb8:	2b00      	cmp	r3, #0
 8007bba:	d02d      	beq.n	8007c18 <gc_execute_block+0x19fc>
                    if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog_in)
 8007bbc:	4b0b      	ldr	r3, [pc, #44]	; (8007bec <gc_execute_block+0x19d0>)
 8007bbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007bc0:	4618      	mov	r0, r3
 8007bc2:	f7f9 faf9 	bl	80011b8 <__aeabi_f2uiz>
 8007bc6:	4603      	mov	r3, r0
 8007bc8:	3301      	adds	r3, #1
 8007bca:	4a0b      	ldr	r2, [pc, #44]	; (8007bf8 <gc_execute_block+0x19dc>)
 8007bcc:	f892 2116 	ldrb.w	r2, [r2, #278]	; 0x116
 8007bd0:	4293      	cmp	r3, r2
 8007bd2:	d902      	bls.n	8007bda <gc_execute_block+0x19be>
                        FAIL(Status_GcodeValueOutOfRange);
 8007bd4:	2327      	movs	r3, #39	; 0x27
 8007bd6:	f003 be19 	b.w	800b80c <gc_execute_block+0x55f0>
                    if((wait_mode_t)gc_block.values.l != WaitMode_Immediate)
 8007bda:	4b04      	ldr	r3, [pc, #16]	; (8007bec <gc_execute_block+0x19d0>)
 8007bdc:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8007be0:	2b00      	cmp	r3, #0
 8007be2:	d00b      	beq.n	8007bfc <gc_execute_block+0x19e0>
                        FAIL(Status_GcodeValueOutOfRange);
 8007be4:	2327      	movs	r3, #39	; 0x27
 8007be6:	f003 be11 	b.w	800b80c <gc_execute_block+0x55f0>
 8007bea:	bf00      	nop
 8007bec:	20000c8c 	.word	0x20000c8c
 8007bf0:	20000dd4 	.word	0x20000dd4
 8007bf4:	20000bb0 	.word	0x20000bb0
 8007bf8:	20000ed0 	.word	0x20000ed0

                    gc_block.output_command.is_digital = false;
 8007bfc:	4bbb      	ldr	r3, [pc, #748]	; (8007eec <gc_execute_block+0x1cd0>)
 8007bfe:	2200      	movs	r2, #0
 8007c00:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
                    gc_block.output_command.port = (uint8_t)gc_block.values.e;
 8007c04:	4bb9      	ldr	r3, [pc, #740]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007c08:	4618      	mov	r0, r3
 8007c0a:	f7f9 fad5 	bl	80011b8 <__aeabi_f2uiz>
 8007c0e:	4603      	mov	r3, r0
 8007c10:	b2da      	uxtb	r2, r3
 8007c12:	4bb6      	ldr	r3, [pc, #728]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c14:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
                }

                gc_block.words.e = gc_block.words.l = gc_block.words.p = gc_block.words.q = Off;
 8007c18:	4ab4      	ldr	r2, [pc, #720]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c1a:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8007c1e:	f36f 0341 	bfc	r3, #1, #1
 8007c22:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8007c26:	4bb1      	ldr	r3, [pc, #708]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c28:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007c2c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8007c30:	b2d9      	uxtb	r1, r3
 8007c32:	4aae      	ldr	r2, [pc, #696]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c34:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8007c38:	f361 0300 	bfi	r3, r1, #0, #1
 8007c3c:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8007c40:	4baa      	ldr	r3, [pc, #680]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c42:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007c46:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8007c4a:	b2d9      	uxtb	r1, r3
 8007c4c:	4aa7      	ldr	r2, [pc, #668]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c4e:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8007c52:	f361 1304 	bfi	r3, r1, #4, #1
 8007c56:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 8007c5a:	4ba4      	ldr	r3, [pc, #656]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c5c:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8007c60:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8007c64:	b2d9      	uxtb	r1, r3
 8007c66:	4aa1      	ldr	r2, [pc, #644]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c68:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8007c6c:	f361 0300 	bfi	r3, r1, #0, #1
 8007c70:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
                break;
 8007c74:	e04d      	b.n	8007d12 <gc_execute_block+0x1af6>

            case IoMCode_AnalogOutSynced:
            case IoMCode_AnalogOutImmediate:
                if(!(gc_block.words.e || gc_block.words.q))
 8007c76:	4b9d      	ldr	r3, [pc, #628]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c78:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8007c7c:	f003 0301 	and.w	r3, r3, #1
 8007c80:	b2db      	uxtb	r3, r3
 8007c82:	2b00      	cmp	r3, #0
 8007c84:	d10a      	bne.n	8007c9c <gc_execute_block+0x1a80>
 8007c86:	4b99      	ldr	r3, [pc, #612]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c88:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007c8c:	f003 0302 	and.w	r3, r3, #2
 8007c90:	b2db      	uxtb	r3, r3
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d102      	bne.n	8007c9c <gc_execute_block+0x1a80>
                    FAIL(Status_GcodeValueWordMissing);
 8007c96:	231c      	movs	r3, #28
 8007c98:	f003 bdb8 	b.w	800b80c <gc_execute_block+0x55f0>
                if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog_out)
 8007c9c:	4b93      	ldr	r3, [pc, #588]	; (8007eec <gc_execute_block+0x1cd0>)
 8007c9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007ca0:	4618      	mov	r0, r3
 8007ca2:	f7f9 fa89 	bl	80011b8 <__aeabi_f2uiz>
 8007ca6:	4603      	mov	r3, r0
 8007ca8:	3301      	adds	r3, #1
 8007caa:	4a91      	ldr	r2, [pc, #580]	; (8007ef0 <gc_execute_block+0x1cd4>)
 8007cac:	f892 2117 	ldrb.w	r2, [r2, #279]	; 0x117
 8007cb0:	4293      	cmp	r3, r2
 8007cb2:	d902      	bls.n	8007cba <gc_execute_block+0x1a9e>
                    FAIL(Status_GcodeRPMOutOfRange);
 8007cb4:	232c      	movs	r3, #44	; 0x2c
 8007cb6:	f003 bda9 	b.w	800b80c <gc_execute_block+0x55f0>
                gc_block.output_command.is_digital = false;
 8007cba:	4b8c      	ldr	r3, [pc, #560]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cbc:	2200      	movs	r2, #0
 8007cbe:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
                gc_block.output_command.port = (uint8_t)gc_block.values.e;
 8007cc2:	4b8a      	ldr	r3, [pc, #552]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cc4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007cc6:	4618      	mov	r0, r3
 8007cc8:	f7f9 fa76 	bl	80011b8 <__aeabi_f2uiz>
 8007ccc:	4603      	mov	r3, r0
 8007cce:	b2da      	uxtb	r2, r3
 8007cd0:	4b86      	ldr	r3, [pc, #536]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cd2:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
                gc_block.output_command.value = gc_block.values.q;
 8007cd6:	4b85      	ldr	r3, [pc, #532]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cd8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007cda:	4618      	mov	r0, r3
 8007cdc:	f7f9 fa46 	bl	800116c <__aeabi_f2iz>
 8007ce0:	4603      	mov	r3, r0
 8007ce2:	4a82      	ldr	r2, [pc, #520]	; (8007eec <gc_execute_block+0x1cd0>)
 8007ce4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
                gc_block.words.e = gc_block.words.q = Off;
 8007ce8:	4a80      	ldr	r2, [pc, #512]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cea:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8007cee:	f36f 0341 	bfc	r3, #1, #1
 8007cf2:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8007cf6:	4b7d      	ldr	r3, [pc, #500]	; (8007eec <gc_execute_block+0x1cd0>)
 8007cf8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007cfc:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8007d00:	b2d9      	uxtb	r1, r3
 8007d02:	4a7a      	ldr	r2, [pc, #488]	; (8007eec <gc_execute_block+0x1cd0>)
 8007d04:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8007d08:	f361 0300 	bfi	r3, r1, #0, #1
 8007d0c:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
            break;
 8007d10:	bf00      	nop
    // bit_false(gc_block.words,bit(Word_T)); // NOTE: Single-meaning value word. Set at end of error-checking.

    // [6. Change tool ]: N/A

    // [7. Spindle control ]:
    if(command_words.M7 && gc_block.modal.spindle.state.ccw) {
 8007d12:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 8007d16:	f003 0302 	and.w	r3, r3, #2
 8007d1a:	b2db      	uxtb	r3, r3
 8007d1c:	2b00      	cmp	r3, #0
 8007d1e:	d054      	beq.n	8007dca <gc_execute_block+0x1bae>
 8007d20:	4b72      	ldr	r3, [pc, #456]	; (8007eec <gc_execute_block+0x1cd0>)
 8007d22:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8007d26:	f003 0302 	and.w	r3, r3, #2
 8007d2a:	b2db      	uxtb	r3, r3
 8007d2c:	2b00      	cmp	r3, #0
 8007d2e:	d04c      	beq.n	8007dca <gc_execute_block+0x1bae>
        // Check if spindle(s) support reversing direction
        if(gc_block.spindle == NULL) {
 8007d30:	4b6e      	ldr	r3, [pc, #440]	; (8007eec <gc_execute_block+0x1cd0>)
 8007d32:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8007d36:	2b00      	cmp	r3, #0
 8007d38:	d132      	bne.n	8007da0 <gc_execute_block+0x1b84>
            uint_fast8_t idx = N_SYS_SPINDLE;
 8007d3a:	2301      	movs	r3, #1
 8007d3c:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
            do {
                idx--;
 8007d40:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8007d44:	3b01      	subs	r3, #1
 8007d46:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
                if(spindle_is_enabled(idx) && !(spindle_get(idx)->cap.direction || spindle_get(idx)->cap.laser))
 8007d4a:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8007d4e:	b25b      	sxtb	r3, r3
 8007d50:	4618      	mov	r0, r3
 8007d52:	f014 fea5 	bl	801caa0 <spindle_is_enabled>
 8007d56:	4603      	mov	r3, r0
 8007d58:	2b00      	cmp	r3, #0
 8007d5a:	d01c      	beq.n	8007d96 <gc_execute_block+0x1b7a>
 8007d5c:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8007d60:	b25b      	sxtb	r3, r3
 8007d62:	4618      	mov	r0, r3
 8007d64:	f014 feca 	bl	801cafc <spindle_get>
 8007d68:	4603      	mov	r3, r0
 8007d6a:	7a9b      	ldrb	r3, [r3, #10]
 8007d6c:	f003 0302 	and.w	r3, r3, #2
 8007d70:	b2db      	uxtb	r3, r3
 8007d72:	2b00      	cmp	r3, #0
 8007d74:	d10f      	bne.n	8007d96 <gc_execute_block+0x1b7a>
 8007d76:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8007d7a:	b25b      	sxtb	r3, r3
 8007d7c:	4618      	mov	r0, r3
 8007d7e:	f014 febd 	bl	801cafc <spindle_get>
 8007d82:	4603      	mov	r3, r0
 8007d84:	7a9b      	ldrb	r3, [r3, #10]
 8007d86:	f003 0308 	and.w	r3, r3, #8
 8007d8a:	b2db      	uxtb	r3, r3
 8007d8c:	2b00      	cmp	r3, #0
 8007d8e:	d102      	bne.n	8007d96 <gc_execute_block+0x1b7a>
                    FAIL(Status_GcodeUnsupportedCommand);
 8007d90:	2314      	movs	r3, #20
 8007d92:	f003 bd3b 	b.w	800b80c <gc_execute_block+0x55f0>
            } while(idx);
 8007d96:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8007d9a:	2b00      	cmp	r3, #0
 8007d9c:	d1d0      	bne.n	8007d40 <gc_execute_block+0x1b24>
 8007d9e:	e014      	b.n	8007dca <gc_execute_block+0x1bae>
        } else if(!(gc_block.spindle->cap.direction || gc_block.spindle->cap.laser))
 8007da0:	4b52      	ldr	r3, [pc, #328]	; (8007eec <gc_execute_block+0x1cd0>)
 8007da2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8007da6:	7a9b      	ldrb	r3, [r3, #10]
 8007da8:	f003 0302 	and.w	r3, r3, #2
 8007dac:	b2db      	uxtb	r3, r3
 8007dae:	2b00      	cmp	r3, #0
 8007db0:	d10b      	bne.n	8007dca <gc_execute_block+0x1bae>
 8007db2:	4b4e      	ldr	r3, [pc, #312]	; (8007eec <gc_execute_block+0x1cd0>)
 8007db4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8007db8:	7a9b      	ldrb	r3, [r3, #10]
 8007dba:	f003 0308 	and.w	r3, r3, #8
 8007dbe:	b2db      	uxtb	r3, r3
 8007dc0:	2b00      	cmp	r3, #0
 8007dc2:	d102      	bne.n	8007dca <gc_execute_block+0x1bae>
            FAIL(Status_GcodeUnsupportedCommand);
 8007dc4:	2314      	movs	r3, #20
 8007dc6:	f003 bd21 	b.w	800b80c <gc_execute_block+0x55f0>
    }

    // [8. Coolant control ]: N/A

    // [9. Override control ]:
    if (command_words.M9) {
 8007dca:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 8007dce:	f003 0308 	and.w	r3, r3, #8
 8007dd2:	b2db      	uxtb	r3, r3
 8007dd4:	2b00      	cmp	r3, #0
 8007dd6:	f000 80c6 	beq.w	8007f66 <gc_execute_block+0x1d4a>

        if(!gc_block.words.p)
 8007dda:	4b44      	ldr	r3, [pc, #272]	; (8007eec <gc_execute_block+0x1cd0>)
 8007ddc:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007de0:	f003 0301 	and.w	r3, r3, #1
 8007de4:	b2db      	uxtb	r3, r3
 8007de6:	2b00      	cmp	r3, #0
 8007de8:	d104      	bne.n	8007df4 <gc_execute_block+0x1bd8>
            gc_block.values.p = 1.0f;
 8007dea:	4b40      	ldr	r3, [pc, #256]	; (8007eec <gc_execute_block+0x1cd0>)
 8007dec:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8007df0:	651a      	str	r2, [r3, #80]	; 0x50
 8007df2:	e013      	b.n	8007e1c <gc_execute_block+0x1c00>
        else {
            if(gc_block.values.p < 0.0f)
 8007df4:	4b3d      	ldr	r3, [pc, #244]	; (8007eec <gc_execute_block+0x1cd0>)
 8007df6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007df8:	f04f 0100 	mov.w	r1, #0
 8007dfc:	4618      	mov	r0, r3
 8007dfe:	f7f9 f977 	bl	80010f0 <__aeabi_fcmplt>
 8007e02:	4603      	mov	r3, r0
 8007e04:	2b00      	cmp	r3, #0
 8007e06:	d002      	beq.n	8007e0e <gc_execute_block+0x1bf2>
                FAIL(Status_NegativeValue);
 8007e08:	2304      	movs	r3, #4
 8007e0a:	f003 bcff 	b.w	800b80c <gc_execute_block+0x55f0>
            gc_block.words.p = Off;
 8007e0e:	4a37      	ldr	r2, [pc, #220]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e10:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8007e14:	f36f 0300 	bfc	r3, #0, #1
 8007e18:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
        }
        switch(gc_block.override_command) {
 8007e1c:	4b33      	ldr	r3, [pc, #204]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e1e:	785b      	ldrb	r3, [r3, #1]
 8007e20:	3b30      	subs	r3, #48	; 0x30
 8007e22:	2b08      	cmp	r3, #8
 8007e24:	f200 809c 	bhi.w	8007f60 <gc_execute_block+0x1d44>
 8007e28:	a201      	add	r2, pc, #4	; (adr r2, 8007e30 <gc_execute_block+0x1c14>)
 8007e2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007e2e:	bf00      	nop
 8007e30:	08007e55 	.word	0x08007e55
 8007e34:	08007e73 	.word	0x08007e73
 8007e38:	08007e91 	.word	0x08007e91
 8007e3c:	08007ebf 	.word	0x08007ebf
 8007e40:	08007f61 	.word	0x08007f61
 8007e44:	08007ef5 	.word	0x08007ef5
 8007e48:	08007f61 	.word	0x08007f61
 8007e4c:	08007f61 	.word	0x08007f61
 8007e50:	08007f23 	.word	0x08007f23

            case Override_FeedSpeedEnable:
                gc_block.modal.override_ctrl.feed_rate_disable = Off;
 8007e54:	4a25      	ldr	r2, [pc, #148]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e56:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007e5a:	f36f 0300 	bfc	r3, #0, #1
 8007e5e:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                gc_block.modal.override_ctrl.spindle_rpm_disable = Off;
 8007e62:	4a22      	ldr	r2, [pc, #136]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e64:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007e68:	f36f 0382 	bfc	r3, #2, #1
 8007e6c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007e70:	e079      	b.n	8007f66 <gc_execute_block+0x1d4a>

            case Override_FeedSpeedDisable:
                gc_block.modal.override_ctrl.feed_rate_disable = On;
 8007e72:	4a1e      	ldr	r2, [pc, #120]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e74:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007e78:	f043 0301 	orr.w	r3, r3, #1
 8007e7c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                gc_block.modal.override_ctrl.spindle_rpm_disable = On;
 8007e80:	4a1a      	ldr	r2, [pc, #104]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e82:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007e86:	f043 0304 	orr.w	r3, r3, #4
 8007e8a:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007e8e:	e06a      	b.n	8007f66 <gc_execute_block+0x1d4a>

            case Override_FeedRate:
                gc_block.modal.override_ctrl.feed_rate_disable = gc_block.values.p == 0.0f;
 8007e90:	4b16      	ldr	r3, [pc, #88]	; (8007eec <gc_execute_block+0x1cd0>)
 8007e92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007e94:	2201      	movs	r2, #1
 8007e96:	4614      	mov	r4, r2
 8007e98:	f04f 0100 	mov.w	r1, #0
 8007e9c:	4618      	mov	r0, r3
 8007e9e:	f7f9 f91d 	bl	80010dc <__aeabi_fcmpeq>
 8007ea2:	4603      	mov	r3, r0
 8007ea4:	2b00      	cmp	r3, #0
 8007ea6:	d101      	bne.n	8007eac <gc_execute_block+0x1c90>
 8007ea8:	2300      	movs	r3, #0
 8007eaa:	461c      	mov	r4, r3
 8007eac:	b2e1      	uxtb	r1, r4
 8007eae:	4a0f      	ldr	r2, [pc, #60]	; (8007eec <gc_execute_block+0x1cd0>)
 8007eb0:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007eb4:	f361 0300 	bfi	r3, r1, #0, #1
 8007eb8:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007ebc:	e053      	b.n	8007f66 <gc_execute_block+0x1d4a>

            case Override_SpindleSpeed:
                gc_block.modal.override_ctrl.spindle_rpm_disable = gc_block.values.p == 0.0f;
 8007ebe:	4b0b      	ldr	r3, [pc, #44]	; (8007eec <gc_execute_block+0x1cd0>)
 8007ec0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007ec2:	2201      	movs	r2, #1
 8007ec4:	4614      	mov	r4, r2
 8007ec6:	f04f 0100 	mov.w	r1, #0
 8007eca:	4618      	mov	r0, r3
 8007ecc:	f7f9 f906 	bl	80010dc <__aeabi_fcmpeq>
 8007ed0:	4603      	mov	r3, r0
 8007ed2:	2b00      	cmp	r3, #0
 8007ed4:	d101      	bne.n	8007eda <gc_execute_block+0x1cbe>
 8007ed6:	2300      	movs	r3, #0
 8007ed8:	461c      	mov	r4, r3
 8007eda:	b2e1      	uxtb	r1, r4
 8007edc:	4a03      	ldr	r2, [pc, #12]	; (8007eec <gc_execute_block+0x1cd0>)
 8007ede:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007ee2:	f361 0382 	bfi	r3, r1, #2, #1
 8007ee6:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007eea:	e03c      	b.n	8007f66 <gc_execute_block+0x1d4a>
 8007eec:	20000c8c 	.word	0x20000c8c
 8007ef0:	20000ed0 	.word	0x20000ed0

            case Override_FeedHold:
                gc_block.modal.override_ctrl.feed_hold_disable = gc_block.values.p == 0.0f;
 8007ef4:	4bb4      	ldr	r3, [pc, #720]	; (80081c8 <gc_execute_block+0x1fac>)
 8007ef6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007ef8:	2201      	movs	r2, #1
 8007efa:	4614      	mov	r4, r2
 8007efc:	f04f 0100 	mov.w	r1, #0
 8007f00:	4618      	mov	r0, r3
 8007f02:	f7f9 f8eb 	bl	80010dc <__aeabi_fcmpeq>
 8007f06:	4603      	mov	r3, r0
 8007f08:	2b00      	cmp	r3, #0
 8007f0a:	d101      	bne.n	8007f10 <gc_execute_block+0x1cf4>
 8007f0c:	2300      	movs	r3, #0
 8007f0e:	461c      	mov	r4, r3
 8007f10:	b2e1      	uxtb	r1, r4
 8007f12:	4aad      	ldr	r2, [pc, #692]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f14:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007f18:	f361 0341 	bfi	r3, r1, #1, #1
 8007f1c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007f20:	e021      	b.n	8007f66 <gc_execute_block+0x1d4a>

            case Override_Parking:
                if(settings.parking.flags.enable_override_control)
 8007f22:	4baa      	ldr	r3, [pc, #680]	; (80081cc <gc_execute_block+0x1fb0>)
 8007f24:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8007f28:	f003 0304 	and.w	r3, r3, #4
 8007f2c:	b2db      	uxtb	r3, r3
 8007f2e:	2b00      	cmp	r3, #0
 8007f30:	d018      	beq.n	8007f64 <gc_execute_block+0x1d48>
                    gc_block.modal.override_ctrl.parking_disable = gc_block.values.p == 0.0f;
 8007f32:	4ba5      	ldr	r3, [pc, #660]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f34:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007f36:	2201      	movs	r2, #1
 8007f38:	4614      	mov	r4, r2
 8007f3a:	f04f 0100 	mov.w	r1, #0
 8007f3e:	4618      	mov	r0, r3
 8007f40:	f7f9 f8cc 	bl	80010dc <__aeabi_fcmpeq>
 8007f44:	4603      	mov	r3, r0
 8007f46:	2b00      	cmp	r3, #0
 8007f48:	d101      	bne.n	8007f4e <gc_execute_block+0x1d32>
 8007f4a:	2300      	movs	r3, #0
 8007f4c:	461c      	mov	r4, r3
 8007f4e:	b2e1      	uxtb	r1, r4
 8007f50:	4a9d      	ldr	r2, [pc, #628]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f52:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8007f56:	f361 03c3 	bfi	r3, r1, #3, #1
 8007f5a:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                break;
 8007f5e:	e001      	b.n	8007f64 <gc_execute_block+0x1d48>

            default:
                break;
 8007f60:	bf00      	nop
 8007f62:	e000      	b.n	8007f66 <gc_execute_block+0x1d4a>
                break;
 8007f64:	bf00      	nop
        }
    }

    // [9a. User defined M commands ]:
    if (command_words.M10 && gc_block.user_mcode) {
 8007f66:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 8007f6a:	f003 0310 	and.w	r3, r3, #16
 8007f6e:	b2db      	uxtb	r3, r3
 8007f70:	2b00      	cmp	r3, #0
 8007f72:	d028      	beq.n	8007fc6 <gc_execute_block+0x1daa>
 8007f74:	4b94      	ldr	r3, [pc, #592]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f76:	885b      	ldrh	r3, [r3, #2]
 8007f78:	2b00      	cmp	r3, #0
 8007f7a:	d024      	beq.n	8007fc6 <gc_execute_block+0x1daa>
        user_words.mask = gc_block.words.mask;
 8007f7c:	4b92      	ldr	r3, [pc, #584]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f7e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8007f82:	4a93      	ldr	r2, [pc, #588]	; (80081d0 <gc_execute_block+0x1fb4>)
 8007f84:	6013      	str	r3, [r2, #0]
        if((int_value = (uint_fast16_t)hal.user_mcode.validate(&gc_block, &gc_block.words)))
 8007f86:	4b93      	ldr	r3, [pc, #588]	; (80081d4 <gc_execute_block+0x1fb8>)
 8007f88:	f8d3 318c 	ldr.w	r3, [r3, #396]	; 0x18c
 8007f8c:	4992      	ldr	r1, [pc, #584]	; (80081d8 <gc_execute_block+0x1fbc>)
 8007f8e:	488e      	ldr	r0, [pc, #568]	; (80081c8 <gc_execute_block+0x1fac>)
 8007f90:	4798      	blx	r3
 8007f92:	4603      	mov	r3, r0
 8007f94:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 8007f98:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8007f9c:	2b00      	cmp	r3, #0
 8007f9e:	d004      	beq.n	8007faa <gc_execute_block+0x1d8e>
            FAIL((status_code_t)int_value);
 8007fa0:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8007fa4:	b2db      	uxtb	r3, r3
 8007fa6:	f003 bc31 	b.w	800b80c <gc_execute_block+0x55f0>
        user_words.mask ^= gc_block.words.mask; // Flag "taken" words for execution
 8007faa:	4b89      	ldr	r3, [pc, #548]	; (80081d0 <gc_execute_block+0x1fb4>)
 8007fac:	681a      	ldr	r2, [r3, #0]
 8007fae:	4b86      	ldr	r3, [pc, #536]	; (80081c8 <gc_execute_block+0x1fac>)
 8007fb0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8007fb4:	4053      	eors	r3, r2
 8007fb6:	4a86      	ldr	r2, [pc, #536]	; (80081d0 <gc_execute_block+0x1fb4>)
 8007fb8:	6013      	str	r3, [r2, #0]
        axis_words.mask = ijk_words.mask = 0;
 8007fba:	2300      	movs	r3, #0
 8007fbc:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8007fc0:	2300      	movs	r3, #0
 8007fc2:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
    }

    // [10. Dwell ]: P value missing. NOTE: See below.
    if (gc_block.non_modal_command == NonModal_Dwell) {
 8007fc6:	4b80      	ldr	r3, [pc, #512]	; (80081c8 <gc_execute_block+0x1fac>)
 8007fc8:	781b      	ldrb	r3, [r3, #0]
 8007fca:	2b04      	cmp	r3, #4
 8007fcc:	d11e      	bne.n	800800c <gc_execute_block+0x1df0>
        if (!gc_block.words.p)
 8007fce:	4b7e      	ldr	r3, [pc, #504]	; (80081c8 <gc_execute_block+0x1fac>)
 8007fd0:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8007fd4:	f003 0301 	and.w	r3, r3, #1
 8007fd8:	b2db      	uxtb	r3, r3
 8007fda:	2b00      	cmp	r3, #0
 8007fdc:	d102      	bne.n	8007fe4 <gc_execute_block+0x1dc8>
            FAIL(Status_GcodeValueWordMissing); // [P word missing]
 8007fde:	231c      	movs	r3, #28
 8007fe0:	f003 bc14 	b.w	800b80c <gc_execute_block+0x55f0>
        if(gc_block.values.p < 0.0f)
 8007fe4:	4b78      	ldr	r3, [pc, #480]	; (80081c8 <gc_execute_block+0x1fac>)
 8007fe6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8007fe8:	f04f 0100 	mov.w	r1, #0
 8007fec:	4618      	mov	r0, r3
 8007fee:	f7f9 f87f 	bl	80010f0 <__aeabi_fcmplt>
 8007ff2:	4603      	mov	r3, r0
 8007ff4:	2b00      	cmp	r3, #0
 8007ff6:	d002      	beq.n	8007ffe <gc_execute_block+0x1de2>
            FAIL(Status_NegativeValue);
 8007ff8:	2304      	movs	r3, #4
 8007ffa:	f003 bc07 	b.w	800b80c <gc_execute_block+0x55f0>
        gc_block.words.p = Off;
 8007ffe:	4a72      	ldr	r2, [pc, #456]	; (80081c8 <gc_execute_block+0x1fac>)
 8008000:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8008004:	f36f 0300 	bfc	r3, #0, #1
 8008008:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
    }

    // [11. Set active plane ]: N/A
    gc_get_plane_data(&plane, gc_block.modal.plane_select);
 800800c:	4b6e      	ldr	r3, [pc, #440]	; (80081c8 <gc_execute_block+0x1fac>)
 800800e:	7b9a      	ldrb	r2, [r3, #14]
 8008010:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 8008014:	4611      	mov	r1, r2
 8008016:	4618      	mov	r0, r3
 8008018:	f7fd fdc4 	bl	8005ba4 <gc_get_plane_data>

    // [12. Set length units ]: N/A
    // Pre-convert XYZ coordinate values to millimeters, if applicable.
    uint_fast8_t idx = N_AXIS;
 800801c:	2303      	movs	r3, #3
 800801e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    if (gc_block.modal.units_imperial) do { // Axes indices are consistent, so loop may be used.
 8008022:	4b69      	ldr	r3, [pc, #420]	; (80081c8 <gc_execute_block+0x1fac>)
 8008024:	7adb      	ldrb	r3, [r3, #11]
 8008026:	2b00      	cmp	r3, #0
 8008028:	d025      	beq.n	8008076 <gc_execute_block+0x1e5a>
        idx--;
 800802a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800802e:	3b01      	subs	r3, #1
 8008030:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
#if N_AXIS > 3
        if (bit_istrue(axis_words.mask, bit(idx)) && bit_isfalse(settings.steppers.is_rotational.mask, bit(idx))) {
#else
        if (bit_istrue(axis_words.mask, bit(idx))) {
 8008034:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008038:	461a      	mov	r2, r3
 800803a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800803e:	fa22 f303 	lsr.w	r3, r2, r3
 8008042:	f003 0301 	and.w	r3, r3, #1
 8008046:	2b00      	cmp	r3, #0
 8008048:	d011      	beq.n	800806e <gc_execute_block+0x1e52>
#endif
            gc_block.values.xyz[idx] *= MM_PER_INCH;
 800804a:	4a5f      	ldr	r2, [pc, #380]	; (80081c8 <gc_execute_block+0x1fac>)
 800804c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008050:	3318      	adds	r3, #24
 8008052:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008056:	4961      	ldr	r1, [pc, #388]	; (80081dc <gc_execute_block+0x1fc0>)
 8008058:	4618      	mov	r0, r3
 800805a:	f7f8 feab 	bl	8000db4 <__aeabi_fmul>
 800805e:	4603      	mov	r3, r0
 8008060:	4619      	mov	r1, r3
 8008062:	4a59      	ldr	r2, [pc, #356]	; (80081c8 <gc_execute_block+0x1fac>)
 8008064:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008068:	3318      	adds	r3, #24
 800806a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            if(idx <= Z_AXIS)
  #endif
            gc_block.values.uvw[idx] *= MM_PER_INCH;
#endif
        }
    } while(idx);
 800806e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008072:	2b00      	cmp	r3, #0
 8008074:	d1d9      	bne.n	800802a <gc_execute_block+0x1e0e>

    if (command_words.G15 && gc_state.modal.diameter_mode != gc_block.modal.diameter_mode) {
 8008076:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 800807a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800807e:	b2db      	uxtb	r3, r3
 8008080:	2b00      	cmp	r3, #0
 8008082:	d00c      	beq.n	800809e <gc_execute_block+0x1e82>
 8008084:	4b56      	ldr	r3, [pc, #344]	; (80081e0 <gc_execute_block+0x1fc4>)
 8008086:	795a      	ldrb	r2, [r3, #5]
 8008088:	4b4f      	ldr	r3, [pc, #316]	; (80081c8 <gc_execute_block+0x1fac>)
 800808a:	7b5b      	ldrb	r3, [r3, #13]
 800808c:	429a      	cmp	r2, r3
 800808e:	d006      	beq.n	800809e <gc_execute_block+0x1e82>
        gc_state.modal.diameter_mode = gc_block.modal.diameter_mode;
 8008090:	4b4d      	ldr	r3, [pc, #308]	; (80081c8 <gc_execute_block+0x1fac>)
 8008092:	7b5a      	ldrb	r2, [r3, #13]
 8008094:	4b52      	ldr	r3, [pc, #328]	; (80081e0 <gc_execute_block+0x1fc4>)
 8008096:	715a      	strb	r2, [r3, #5]
        system_add_rt_report(Report_LatheXMode);
 8008098:	2008      	movs	r0, #8
 800809a:	f019 ff7f 	bl	8021f9c <system_add_rt_report>
    }

    if(gc_state.modal.diameter_mode && bit_istrue(axis_words.mask, bit(X_AXIS)))
 800809e:	4b50      	ldr	r3, [pc, #320]	; (80081e0 <gc_execute_block+0x1fc4>)
 80080a0:	795b      	ldrb	r3, [r3, #5]
 80080a2:	2b00      	cmp	r3, #0
 80080a4:	d010      	beq.n	80080c8 <gc_execute_block+0x1eac>
 80080a6:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80080aa:	f003 0301 	and.w	r3, r3, #1
 80080ae:	2b00      	cmp	r3, #0
 80080b0:	d00a      	beq.n	80080c8 <gc_execute_block+0x1eac>
        gc_block.values.xyz[X_AXIS] /= 2.0f;
 80080b2:	4b45      	ldr	r3, [pc, #276]	; (80081c8 <gc_execute_block+0x1fac>)
 80080b4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80080b6:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80080ba:	4618      	mov	r0, r3
 80080bc:	f7f8 ff2e 	bl	8000f1c <__aeabi_fdiv>
 80080c0:	4603      	mov	r3, r0
 80080c2:	461a      	mov	r2, r3
 80080c4:	4b40      	ldr	r3, [pc, #256]	; (80081c8 <gc_execute_block+0x1fac>)
 80080c6:	661a      	str	r2, [r3, #96]	; 0x60

    // Scale axis words if commanded
    if(axis_command == AxisCommand_Scaling) {
 80080c8:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 80080cc:	2b04      	cmp	r3, #4
 80080ce:	f040 80c4 	bne.w	800825a <gc_execute_block+0x203e>

        if(gc_block.modal.scaling_active) {
 80080d2:	4b3d      	ldr	r3, [pc, #244]	; (80081c8 <gc_execute_block+0x1fac>)
 80080d4:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80080d8:	2b00      	cmp	r3, #0
 80080da:	f000 80ba 	beq.w	8008252 <gc_execute_block+0x2036>

            bool report_scaling = false;
 80080de:	2300      	movs	r3, #0
 80080e0:	f887 30f7 	strb.w	r3, [r7, #247]	; 0xf7

            // TODO: precheck for 0.0f and fail if found?

            gc_block.modal.scaling_active = false;
 80080e4:	4b38      	ldr	r3, [pc, #224]	; (80081c8 <gc_execute_block+0x1fac>)
 80080e6:	2200      	movs	r2, #0
 80080e8:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26

#ifdef MACH3_SCALING
            // [G51 Errors]: No axis words. TODO: add support for P (scale all with same factor)?
            if (!axis_words.mask)
 80080ec:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80080f0:	2b00      	cmp	r3, #0
 80080f2:	d102      	bne.n	80080fa <gc_execute_block+0x1ede>
                FAIL(Status_GcodeNoAxisWords); // [No axis words]
 80080f4:	231a      	movs	r3, #26
 80080f6:	f003 bb89 	b.w	800b80c <gc_execute_block+0x55f0>

            idx = N_AXIS;
 80080fa:	2303      	movs	r3, #3
 80080fc:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
            do {
                if(bit_istrue(axis_words.mask, bit(--idx))) {
 8008100:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008104:	461a      	mov	r2, r3
 8008106:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800810a:	3b01      	subs	r3, #1
 800810c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008110:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008114:	fa22 f303 	lsr.w	r3, r2, r3
 8008118:	f003 0301 	and.w	r3, r3, #1
 800811c:	2b00      	cmp	r3, #0
 800811e:	d03f      	beq.n	80081a0 <gc_execute_block+0x1f84>
                    report_scaling |= scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8008120:	f897 40f7 	ldrb.w	r4, [r7, #247]	; 0xf7
 8008124:	4a2f      	ldr	r2, [pc, #188]	; (80081e4 <gc_execute_block+0x1fc8>)
 8008126:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800812a:	3302      	adds	r3, #2
 800812c:	009b      	lsls	r3, r3, #2
 800812e:	4413      	add	r3, r2
 8008130:	685a      	ldr	r2, [r3, #4]
 8008132:	4925      	ldr	r1, [pc, #148]	; (80081c8 <gc_execute_block+0x1fac>)
 8008134:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008138:	3318      	adds	r3, #24
 800813a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800813e:	2101      	movs	r1, #1
 8008140:	460d      	mov	r5, r1
 8008142:	4619      	mov	r1, r3
 8008144:	4610      	mov	r0, r2
 8008146:	f7f8 ffc9 	bl	80010dc <__aeabi_fcmpeq>
 800814a:	4603      	mov	r3, r0
 800814c:	2b00      	cmp	r3, #0
 800814e:	d001      	beq.n	8008154 <gc_execute_block+0x1f38>
 8008150:	2300      	movs	r3, #0
 8008152:	461d      	mov	r5, r3
 8008154:	b2eb      	uxtb	r3, r5
 8008156:	4323      	orrs	r3, r4
 8008158:	2b00      	cmp	r3, #0
 800815a:	bf14      	ite	ne
 800815c:	2301      	movne	r3, #1
 800815e:	2300      	moveq	r3, #0
 8008160:	f887 30f7 	strb.w	r3, [r7, #247]	; 0xf7
                    scale_factor.ijk[idx] = gc_block.values.xyz[idx];
 8008164:	4a18      	ldr	r2, [pc, #96]	; (80081c8 <gc_execute_block+0x1fac>)
 8008166:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800816a:	3318      	adds	r3, #24
 800816c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8008170:	491c      	ldr	r1, [pc, #112]	; (80081e4 <gc_execute_block+0x1fc8>)
 8008172:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008176:	3302      	adds	r3, #2
 8008178:	009b      	lsls	r3, r3, #2
 800817a:	440b      	add	r3, r1
 800817c:	605a      	str	r2, [r3, #4]
                    bit_false(axis_words.mask, bit(idx));
 800817e:	f897 20a8 	ldrb.w	r2, [r7, #168]	; 0xa8
 8008182:	2101      	movs	r1, #1
 8008184:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008188:	fa01 f303 	lsl.w	r3, r1, r3
 800818c:	b2db      	uxtb	r3, r3
 800818e:	43db      	mvns	r3, r3
 8008190:	b2db      	uxtb	r3, r3
 8008192:	4013      	ands	r3, r2
 8008194:	b2db      	uxtb	r3, r3
 8008196:	f887 30a8 	strb.w	r3, [r7, #168]	; 0xa8
                    system_add_rt_report(Report_Scaling);
 800819a:	2002      	movs	r0, #2
 800819c:	f019 fefe 	bl	8021f9c <system_add_rt_report>
                }
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 80081a0:	4b09      	ldr	r3, [pc, #36]	; (80081c8 <gc_execute_block+0x1fac>)
 80081a2:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80081a6:	2b00      	cmp	r3, #0
 80081a8:	d10c      	bne.n	80081c4 <gc_execute_block+0x1fa8>
 80081aa:	4a0e      	ldr	r2, [pc, #56]	; (80081e4 <gc_execute_block+0x1fc8>)
 80081ac:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80081b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80081b4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80081b8:	4618      	mov	r0, r3
 80081ba:	f7f8 ff8f 	bl	80010dc <__aeabi_fcmpeq>
 80081be:	4603      	mov	r3, r0
 80081c0:	2b00      	cmp	r3, #0
 80081c2:	d111      	bne.n	80081e8 <gc_execute_block+0x1fcc>
 80081c4:	2301      	movs	r3, #1
 80081c6:	e010      	b.n	80081ea <gc_execute_block+0x1fce>
 80081c8:	20000c8c 	.word	0x20000c8c
 80081cc:	2000147c 	.word	0x2000147c
 80081d0:	20000d38 	.word	0x20000d38
 80081d4:	20000ed0 	.word	0x20000ed0
 80081d8:	20000d20 	.word	0x20000d20
 80081dc:	41cb3333 	.word	0x41cb3333
 80081e0:	20000bb0 	.word	0x20000bb0
 80081e4:	20000248 	.word	0x20000248
 80081e8:	2300      	movs	r3, #0
 80081ea:	f003 0301 	and.w	r3, r3, #1
 80081ee:	b2da      	uxtb	r2, r3
 80081f0:	4baf      	ldr	r3, [pc, #700]	; (80084b0 <gc_execute_block+0x2294>)
 80081f2:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
            } while(idx);
 80081f6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80081fa:	2b00      	cmp	r3, #0
 80081fc:	d180      	bne.n	8008100 <gc_execute_block+0x1ee4>

            gc_block.words.mask &= ~axis_words_mask.mask; // Remove axis words.
 80081fe:	4bac      	ldr	r3, [pc, #688]	; (80084b0 <gc_execute_block+0x2294>)
 8008200:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8008204:	4bab      	ldr	r3, [pc, #684]	; (80084b4 <gc_execute_block+0x2298>)
 8008206:	681b      	ldr	r3, [r3, #0]
 8008208:	43db      	mvns	r3, r3
 800820a:	4013      	ands	r3, r2
 800820c:	4aa8      	ldr	r2, [pc, #672]	; (80084b0 <gc_execute_block+0x2294>)
 800820e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
            if(gc_block.words.p)
                gc_block.words.p = Off;
            else
                gc_block.words.i = gc_block.words.j = gc_block.words.k = Off;
#endif
            report_scaling |= gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 8008212:	f897 30f7 	ldrb.w	r3, [r7, #247]	; 0xf7
 8008216:	4aa8      	ldr	r2, [pc, #672]	; (80084b8 <gc_execute_block+0x229c>)
 8008218:	7f91      	ldrb	r1, [r2, #30]
 800821a:	4aa5      	ldr	r2, [pc, #660]	; (80084b0 <gc_execute_block+0x2294>)
 800821c:	f892 2026 	ldrb.w	r2, [r2, #38]	; 0x26
 8008220:	4291      	cmp	r1, r2
 8008222:	bf14      	ite	ne
 8008224:	2201      	movne	r2, #1
 8008226:	2200      	moveq	r2, #0
 8008228:	b2d2      	uxtb	r2, r2
 800822a:	4313      	orrs	r3, r2
 800822c:	2b00      	cmp	r3, #0
 800822e:	bf14      	ite	ne
 8008230:	2301      	movne	r3, #1
 8008232:	2300      	moveq	r3, #0
 8008234:	f887 30f7 	strb.w	r3, [r7, #247]	; 0xf7
            gc_state.modal.scaling_active = gc_block.modal.scaling_active;
 8008238:	4b9d      	ldr	r3, [pc, #628]	; (80084b0 <gc_execute_block+0x2294>)
 800823a:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 800823e:	4b9e      	ldr	r3, [pc, #632]	; (80084b8 <gc_execute_block+0x229c>)
 8008240:	779a      	strb	r2, [r3, #30]

            if(report_scaling)
 8008242:	f897 30f7 	ldrb.w	r3, [r7, #247]	; 0xf7
 8008246:	2b00      	cmp	r3, #0
 8008248:	d007      	beq.n	800825a <gc_execute_block+0x203e>
                system_add_rt_report(Report_Scaling);
 800824a:	2002      	movs	r0, #2
 800824c:	f019 fea6 	bl	8021f9c <system_add_rt_report>
 8008250:	e003      	b.n	800825a <gc_execute_block+0x203e>

        } else
            set_scaling(1.0f);
 8008252:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8008256:	f7fd fb4d 	bl	80058f4 <set_scaling>
    }

    // Scale axis words if scaling active
    if(gc_state.modal.scaling_active) {
 800825a:	4b97      	ldr	r3, [pc, #604]	; (80084b8 <gc_execute_block+0x229c>)
 800825c:	7f9b      	ldrb	r3, [r3, #30]
 800825e:	2b00      	cmp	r3, #0
 8008260:	d061      	beq.n	8008326 <gc_execute_block+0x210a>
        idx = N_AXIS;
 8008262:	2303      	movs	r3, #3
 8008264:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
        do {
            if(bit_istrue(axis_words.mask, bit(--idx))) {
 8008268:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800826c:	461a      	mov	r2, r3
 800826e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008272:	3b01      	subs	r3, #1
 8008274:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008278:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800827c:	fa22 f303 	lsr.w	r3, r2, r3
 8008280:	f003 0301 	and.w	r3, r3, #1
 8008284:	2b00      	cmp	r3, #0
 8008286:	d04a      	beq.n	800831e <gc_execute_block+0x2102>
                if(gc_block.modal.distance_incremental)
 8008288:	4b89      	ldr	r3, [pc, #548]	; (80084b0 <gc_execute_block+0x2294>)
 800828a:	7b1b      	ldrb	r3, [r3, #12]
 800828c:	2b00      	cmp	r3, #0
 800828e:	d019      	beq.n	80082c4 <gc_execute_block+0x20a8>
                     gc_block.values.xyz[idx] *= scale_factor.ijk[idx];
 8008290:	4a87      	ldr	r2, [pc, #540]	; (80084b0 <gc_execute_block+0x2294>)
 8008292:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008296:	3318      	adds	r3, #24
 8008298:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800829c:	4987      	ldr	r1, [pc, #540]	; (80084bc <gc_execute_block+0x22a0>)
 800829e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80082a2:	3302      	adds	r3, #2
 80082a4:	009b      	lsls	r3, r3, #2
 80082a6:	440b      	add	r3, r1
 80082a8:	685b      	ldr	r3, [r3, #4]
 80082aa:	4619      	mov	r1, r3
 80082ac:	4610      	mov	r0, r2
 80082ae:	f7f8 fd81 	bl	8000db4 <__aeabi_fmul>
 80082b2:	4603      	mov	r3, r0
 80082b4:	4619      	mov	r1, r3
 80082b6:	4a7e      	ldr	r2, [pc, #504]	; (80084b0 <gc_execute_block+0x2294>)
 80082b8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80082bc:	3318      	adds	r3, #24
 80082be:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 80082c2:	e02c      	b.n	800831e <gc_execute_block+0x2102>
                else
                     gc_block.values.xyz[idx] = (gc_block.values.xyz[idx] - scale_factor.xyz[idx]) * scale_factor.ijk[idx] + scale_factor.xyz[idx];
 80082c4:	4a7a      	ldr	r2, [pc, #488]	; (80084b0 <gc_execute_block+0x2294>)
 80082c6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80082ca:	3318      	adds	r3, #24
 80082cc:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80082d0:	497a      	ldr	r1, [pc, #488]	; (80084bc <gc_execute_block+0x22a0>)
 80082d2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80082d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80082da:	4619      	mov	r1, r3
 80082dc:	4610      	mov	r0, r2
 80082de:	f7f8 fc5f 	bl	8000ba0 <__aeabi_fsub>
 80082e2:	4603      	mov	r3, r0
 80082e4:	4618      	mov	r0, r3
 80082e6:	4a75      	ldr	r2, [pc, #468]	; (80084bc <gc_execute_block+0x22a0>)
 80082e8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80082ec:	3302      	adds	r3, #2
 80082ee:	009b      	lsls	r3, r3, #2
 80082f0:	4413      	add	r3, r2
 80082f2:	685b      	ldr	r3, [r3, #4]
 80082f4:	4619      	mov	r1, r3
 80082f6:	f7f8 fd5d 	bl	8000db4 <__aeabi_fmul>
 80082fa:	4603      	mov	r3, r0
 80082fc:	4618      	mov	r0, r3
 80082fe:	4a6f      	ldr	r2, [pc, #444]	; (80084bc <gc_execute_block+0x22a0>)
 8008300:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008304:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008308:	4619      	mov	r1, r3
 800830a:	f7f8 fc4b 	bl	8000ba4 <__addsf3>
 800830e:	4603      	mov	r3, r0
 8008310:	4619      	mov	r1, r3
 8008312:	4a67      	ldr	r2, [pc, #412]	; (80084b0 <gc_execute_block+0x2294>)
 8008314:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008318:	3318      	adds	r3, #24
 800831a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                if(idx <= Z_AXIS)
  #endif
                gc_block.values.uvw[idx] *= scale_factor.ijk[idx];
#endif
            }
        } while(idx);
 800831e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008322:	2b00      	cmp	r3, #0
 8008324:	d1a0      	bne.n	8008268 <gc_execute_block+0x204c>
    //   only for the purpose to not error when G40 is sent with a g-code program header to setup the default modes.

    // [14. Tool length compensation ]: G43.1 and G49 are always supported, G43 and G43.2 if grbl.tool_table.n_tools > 0
    // [G43.1 Errors]: Motion command in same line.
    // [G43.2 Errors]: Tool number not in the tool table,
    if (command_words.G8) { // Indicates called in block.
 8008326:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 800832a:	f003 0301 	and.w	r3, r3, #1
 800832e:	b2db      	uxtb	r3, r3
 8008330:	2b00      	cmp	r3, #0
 8008332:	d071      	beq.n	8008418 <gc_execute_block+0x21fc>
            if (axis_words.mask ^ bit(TOOL_LENGTH_OFFSET_AXIS))
                FAIL(Status_GcodeG43DynamicAxisError);
        }
#endif

        switch(gc_block.modal.tool_offset_mode) {
 8008334:	4b5e      	ldr	r3, [pc, #376]	; (80084b0 <gc_execute_block+0x2294>)
 8008336:	7bdb      	ldrb	r3, [r3, #15]
 8008338:	2b03      	cmp	r3, #3
 800833a:	d03f      	beq.n	80083bc <gc_execute_block+0x21a0>
 800833c:	2b03      	cmp	r3, #3
 800833e:	dc66      	bgt.n	800840e <gc_execute_block+0x21f2>
 8008340:	2b01      	cmp	r3, #1
 8008342:	d008      	beq.n	8008356 <gc_execute_block+0x213a>
 8008344:	2b02      	cmp	r3, #2
 8008346:	d162      	bne.n	800840e <gc_execute_block+0x21f2>

            case ToolLengthOffset_EnableDynamic:
                if(!axis_words.mask)
 8008348:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800834c:	2b00      	cmp	r3, #0
 800834e:	d160      	bne.n	8008412 <gc_execute_block+0x21f6>
                    FAIL(Status_GcodeG43DynamicAxisError);
 8008350:	2325      	movs	r3, #37	; 0x25
 8008352:	f003 ba5b 	b.w	800b80c <gc_execute_block+0x55f0>
                break;

            case ToolLengthOffset_Enable:
                if(grbl.tool_table.n_tools) {
 8008356:	4b5a      	ldr	r3, [pc, #360]	; (80084c0 <gc_execute_block+0x22a4>)
 8008358:	699b      	ldr	r3, [r3, #24]
 800835a:	2b00      	cmp	r3, #0
 800835c:	d02b      	beq.n	80083b6 <gc_execute_block+0x219a>
                    if(gc_block.words.h) {
 800835e:	4b54      	ldr	r3, [pc, #336]	; (80084b0 <gc_execute_block+0x2294>)
 8008360:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8008364:	f003 0308 	and.w	r3, r3, #8
 8008368:	b2db      	uxtb	r3, r3
 800836a:	2b00      	cmp	r3, #0
 800836c:	d01c      	beq.n	80083a8 <gc_execute_block+0x218c>
                        if(gc_block.values.h > grbl.tool_table.n_tools)
 800836e:	4b50      	ldr	r3, [pc, #320]	; (80084b0 <gc_execute_block+0x2294>)
 8008370:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8008374:	4b52      	ldr	r3, [pc, #328]	; (80084c0 <gc_execute_block+0x22a4>)
 8008376:	699b      	ldr	r3, [r3, #24]
 8008378:	429a      	cmp	r2, r3
 800837a:	d902      	bls.n	8008382 <gc_execute_block+0x2166>
                            FAIL(Status_GcodeIllegalToolTableEntry);
 800837c:	2326      	movs	r3, #38	; 0x26
 800837e:	f003 ba45 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.words.h = Off;
 8008382:	4a4b      	ldr	r2, [pc, #300]	; (80084b0 <gc_execute_block+0x2294>)
 8008384:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8008388:	f36f 03c3 	bfc	r3, #3, #1
 800838c:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
                        if(gc_block.values.h == 0)
 8008390:	4b47      	ldr	r3, [pc, #284]	; (80084b0 <gc_execute_block+0x2294>)
 8008392:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8008396:	2b00      	cmp	r3, #0
 8008398:	d13d      	bne.n	8008416 <gc_execute_block+0x21fa>
                            gc_block.values.h = gc_block.values.t;
 800839a:	4b45      	ldr	r3, [pc, #276]	; (80084b0 <gc_execute_block+0x2294>)
 800839c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80083a0:	4a43      	ldr	r2, [pc, #268]	; (80084b0 <gc_execute_block+0x2294>)
 80083a2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                    } else
                        gc_block.values.h = gc_block.values.t;
                } else
                    FAIL(Status_GcodeUnsupportedCommand);
                break;
 80083a6:	e036      	b.n	8008416 <gc_execute_block+0x21fa>
                        gc_block.values.h = gc_block.values.t;
 80083a8:	4b41      	ldr	r3, [pc, #260]	; (80084b0 <gc_execute_block+0x2294>)
 80083aa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80083ae:	4a40      	ldr	r2, [pc, #256]	; (80084b0 <gc_execute_block+0x2294>)
 80083b0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                break;
 80083b4:	e02f      	b.n	8008416 <gc_execute_block+0x21fa>
                    FAIL(Status_GcodeUnsupportedCommand);
 80083b6:	2314      	movs	r3, #20
 80083b8:	f003 ba28 	b.w	800b80c <gc_execute_block+0x55f0>

            case ToolLengthOffset_ApplyAdditional:
                if(grbl.tool_table.n_tools) {
 80083bc:	4b40      	ldr	r3, [pc, #256]	; (80084c0 <gc_execute_block+0x22a4>)
 80083be:	699b      	ldr	r3, [r3, #24]
 80083c0:	2b00      	cmp	r3, #0
 80083c2:	d021      	beq.n	8008408 <gc_execute_block+0x21ec>
                    if(gc_block.words.h) {
 80083c4:	4b3a      	ldr	r3, [pc, #232]	; (80084b0 <gc_execute_block+0x2294>)
 80083c6:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80083ca:	f003 0308 	and.w	r3, r3, #8
 80083ce:	b2db      	uxtb	r3, r3
 80083d0:	2b00      	cmp	r3, #0
 80083d2:	d016      	beq.n	8008402 <gc_execute_block+0x21e6>
                        if(gc_block.values.h == 0 || gc_block.values.h > grbl.tool_table.n_tools)
 80083d4:	4b36      	ldr	r3, [pc, #216]	; (80084b0 <gc_execute_block+0x2294>)
 80083d6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80083da:	2b00      	cmp	r3, #0
 80083dc:	d006      	beq.n	80083ec <gc_execute_block+0x21d0>
 80083de:	4b34      	ldr	r3, [pc, #208]	; (80084b0 <gc_execute_block+0x2294>)
 80083e0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80083e4:	4b36      	ldr	r3, [pc, #216]	; (80084c0 <gc_execute_block+0x22a4>)
 80083e6:	699b      	ldr	r3, [r3, #24]
 80083e8:	429a      	cmp	r2, r3
 80083ea:	d902      	bls.n	80083f2 <gc_execute_block+0x21d6>
                            FAIL(Status_GcodeIllegalToolTableEntry);
 80083ec:	2326      	movs	r3, #38	; 0x26
 80083ee:	f003 ba0d 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.words.h = Off;
 80083f2:	4a2f      	ldr	r2, [pc, #188]	; (80084b0 <gc_execute_block+0x2294>)
 80083f4:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 80083f8:	f36f 03c3 	bfc	r3, #3, #1
 80083fc:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
                    } else
                        FAIL(Status_GcodeValueWordMissing);
                } else
                    FAIL(Status_GcodeUnsupportedCommand);
                break;
 8008400:	e00a      	b.n	8008418 <gc_execute_block+0x21fc>
                        FAIL(Status_GcodeValueWordMissing);
 8008402:	231c      	movs	r3, #28
 8008404:	f003 ba02 	b.w	800b80c <gc_execute_block+0x55f0>
                    FAIL(Status_GcodeUnsupportedCommand);
 8008408:	2314      	movs	r3, #20
 800840a:	f003 b9ff 	b.w	800b80c <gc_execute_block+0x55f0>

            default:
                break;
 800840e:	bf00      	nop
 8008410:	e002      	b.n	8008418 <gc_execute_block+0x21fc>
                break;
 8008412:	bf00      	nop
 8008414:	e000      	b.n	8008418 <gc_execute_block+0x21fc>
                break;
 8008416:	bf00      	nop
    // TODO: A read of the coordinate data may require a buffer sync when the cycle
    // is active. The read pauses the processor temporarily and may cause a rare crash.
    // NOTE: If NVS buffering is active then non-volatile storage reads/writes are buffered and updates
    // delayed until no cycle is active.

    if (command_words.G12) { // Check if called in block
 8008418:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 800841c:	f003 0308 	and.w	r3, r3, #8
 8008420:	b2db      	uxtb	r3, r3
 8008422:	2b00      	cmp	r3, #0
 8008424:	d014      	beq.n	8008450 <gc_execute_block+0x2234>
        if (gc_state.modal.coord_system.id != gc_block.modal.coord_system.id && !settings_read_coord_data(gc_block.modal.coord_system.id, &gc_block.modal.coord_system.xyz))
 8008426:	4b24      	ldr	r3, [pc, #144]	; (80084b8 <gc_execute_block+0x229c>)
 8008428:	7d1a      	ldrb	r2, [r3, #20]
 800842a:	4b21      	ldr	r3, [pc, #132]	; (80084b0 <gc_execute_block+0x2294>)
 800842c:	7f1b      	ldrb	r3, [r3, #28]
 800842e:	429a      	cmp	r2, r3
 8008430:	d00e      	beq.n	8008450 <gc_execute_block+0x2234>
 8008432:	4b1f      	ldr	r3, [pc, #124]	; (80084b0 <gc_execute_block+0x2294>)
 8008434:	7f1b      	ldrb	r3, [r3, #28]
 8008436:	4923      	ldr	r1, [pc, #140]	; (80084c4 <gc_execute_block+0x22a8>)
 8008438:	4618      	mov	r0, r3
 800843a:	f012 fbed 	bl	801ac18 <settings_read_coord_data>
 800843e:	4603      	mov	r3, r0
 8008440:	f083 0301 	eor.w	r3, r3, #1
 8008444:	b2db      	uxtb	r3, r3
 8008446:	2b00      	cmp	r3, #0
 8008448:	d002      	beq.n	8008450 <gc_execute_block+0x2234>
            FAIL(Status_SettingReadFail);
 800844a:	2307      	movs	r3, #7
 800844c:	f003 b9de 	b.w	800b80c <gc_execute_block+0x55f0>
    // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
    // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
    // commands all treat axis words differently. G10 as absolute offsets or computes current position as
    // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
    // all the current coordinate system and G92 offsets.
    switch (gc_block.non_modal_command) {
 8008450:	4b17      	ldr	r3, [pc, #92]	; (80084b0 <gc_execute_block+0x2294>)
 8008452:	781b      	ldrb	r3, [r3, #0]
 8008454:	2b0a      	cmp	r3, #10
 8008456:	d003      	beq.n	8008460 <gc_execute_block+0x2244>
 8008458:	2b5c      	cmp	r3, #92	; 0x5c
 800845a:	f000 827c 	beq.w	8008956 <gc_execute_block+0x273a>
 800845e:	e2d6      	b.n	8008a0e <gc_execute_block+0x27f2>
            // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
            // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to N_WorkCoordinateSystems (max 9). Axis words missing.
            // [G10 L20 Errors]: P must be 0 to N_WorkCoordinateSystems (max 9). Axis words missing.
            // [G10 L1, L10, L11 Errors]: P must be 0 to grbl.tool_table.n_tools. Axis words or R word missing.

            if (!(axis_words.mask || (gc_block.values.l != 20 && gc_block.words.r)))
 8008460:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008464:	2b00      	cmp	r3, #0
 8008466:	d10f      	bne.n	8008488 <gc_execute_block+0x226c>
 8008468:	4b11      	ldr	r3, [pc, #68]	; (80084b0 <gc_execute_block+0x2294>)
 800846a:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 800846e:	2b14      	cmp	r3, #20
 8008470:	d007      	beq.n	8008482 <gc_execute_block+0x2266>
 8008472:	4b0f      	ldr	r3, [pc, #60]	; (80084b0 <gc_execute_block+0x2294>)
 8008474:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008478:	f003 0304 	and.w	r3, r3, #4
 800847c:	b2db      	uxtb	r3, r3
 800847e:	2b00      	cmp	r3, #0
 8008480:	d102      	bne.n	8008488 <gc_execute_block+0x226c>
                FAIL(Status_GcodeNoAxisWords); // [No axis words (or R word for tool offsets)]
 8008482:	231a      	movs	r3, #26
 8008484:	f003 b9c2 	b.w	800b80c <gc_execute_block+0x55f0>

            if (!(gc_block.words.p || gc_block.words.l))
 8008488:	4b09      	ldr	r3, [pc, #36]	; (80084b0 <gc_execute_block+0x2294>)
 800848a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800848e:	f003 0301 	and.w	r3, r3, #1
 8008492:	b2db      	uxtb	r3, r3
 8008494:	2b00      	cmp	r3, #0
 8008496:	d117      	bne.n	80084c8 <gc_execute_block+0x22ac>
 8008498:	4b05      	ldr	r3, [pc, #20]	; (80084b0 <gc_execute_block+0x2294>)
 800849a:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800849e:	f003 0310 	and.w	r3, r3, #16
 80084a2:	b2db      	uxtb	r3, r3
 80084a4:	2b00      	cmp	r3, #0
 80084a6:	d10f      	bne.n	80084c8 <gc_execute_block+0x22ac>
                FAIL(Status_GcodeValueWordMissing); // [P/L word missing]
 80084a8:	231c      	movs	r3, #28
 80084aa:	f003 b9af 	b.w	800b80c <gc_execute_block+0x55f0>
 80084ae:	bf00      	nop
 80084b0:	20000c8c 	.word	0x20000c8c
 80084b4:	08030c78 	.word	0x08030c78
 80084b8:	20000bb0 	.word	0x20000bb0
 80084bc:	20000248 	.word	0x20000248
 80084c0:	20000dd4 	.word	0x20000dd4
 80084c4:	20000c9c 	.word	0x20000c9c

            if(gc_block.values.p < 0.0f)
 80084c8:	4bc2      	ldr	r3, [pc, #776]	; (80087d4 <gc_execute_block+0x25b8>)
 80084ca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80084cc:	f04f 0100 	mov.w	r1, #0
 80084d0:	4618      	mov	r0, r3
 80084d2:	f7f8 fe0d 	bl	80010f0 <__aeabi_fcmplt>
 80084d6:	4603      	mov	r3, r0
 80084d8:	2b00      	cmp	r3, #0
 80084da:	d002      	beq.n	80084e2 <gc_execute_block+0x22c6>
                FAIL(Status_NegativeValue);
 80084dc:	2304      	movs	r3, #4
 80084de:	f003 b995 	b.w	800b80c <gc_execute_block+0x55f0>

            uint8_t p_value;

            p_value = (uint8_t)truncf(gc_block.values.p); // Convert p value to int.
 80084e2:	4bbc      	ldr	r3, [pc, #752]	; (80087d4 <gc_execute_block+0x25b8>)
 80084e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80084e6:	4618      	mov	r0, r3
 80084e8:	f01c fc84 	bl	8024df4 <truncf>
 80084ec:	4603      	mov	r3, r0
 80084ee:	4618      	mov	r0, r3
 80084f0:	f7f8 fe62 	bl	80011b8 <__aeabi_f2uiz>
 80084f4:	4603      	mov	r3, r0
 80084f6:	f887 30eb 	strb.w	r3, [r7, #235]	; 0xeb

            switch(gc_block.values.l) {
 80084fa:	4bb6      	ldr	r3, [pc, #728]	; (80087d4 <gc_execute_block+0x25b8>)
 80084fc:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008500:	3b01      	subs	r3, #1
 8008502:	2b13      	cmp	r3, #19
 8008504:	f200 820e 	bhi.w	8008924 <gc_execute_block+0x2708>
 8008508:	a201      	add	r2, pc, #4	; (adr r2, 8008510 <gc_execute_block+0x22f4>)
 800850a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800850e:	bf00      	nop
 8008510:	080086b9 	.word	0x080086b9
 8008514:	08008561 	.word	0x08008561
 8008518:	08008925 	.word	0x08008925
 800851c:	08008925 	.word	0x08008925
 8008520:	08008925 	.word	0x08008925
 8008524:	08008925 	.word	0x08008925
 8008528:	08008925 	.word	0x08008925
 800852c:	08008925 	.word	0x08008925
 8008530:	08008925 	.word	0x08008925
 8008534:	080086b9 	.word	0x080086b9
 8008538:	080086b9 	.word	0x080086b9
 800853c:	08008925 	.word	0x08008925
 8008540:	08008925 	.word	0x08008925
 8008544:	08008925 	.word	0x08008925
 8008548:	08008925 	.word	0x08008925
 800854c:	08008925 	.word	0x08008925
 8008550:	08008925 	.word	0x08008925
 8008554:	08008925 	.word	0x08008925
 8008558:	08008925 	.word	0x08008925
 800855c:	08008577 	.word	0x08008577

                case 2:
                    if (gc_block.words.r)
 8008560:	4b9c      	ldr	r3, [pc, #624]	; (80087d4 <gc_execute_block+0x25b8>)
 8008562:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008566:	f003 0304 	and.w	r3, r3, #4
 800856a:	b2db      	uxtb	r3, r3
 800856c:	2b00      	cmp	r3, #0
 800856e:	d002      	beq.n	8008576 <gc_execute_block+0x235a>
                        FAIL(Status_GcodeUnsupportedCommand); // [G10 L2 R not supported]
 8008570:	2314      	movs	r3, #20
 8008572:	f003 b94b 	b.w	800b80c <gc_execute_block+0x55f0>
                    // no break

                case 20:
                    if (p_value > N_WorkCoordinateSystems)
 8008576:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 800857a:	2b09      	cmp	r3, #9
 800857c:	d902      	bls.n	8008584 <gc_execute_block+0x2368>
                        FAIL(Status_GcodeUnsupportedCoordSys); // [Greater than N sys]
 800857e:	231d      	movs	r3, #29
 8008580:	f003 b944 	b.w	800b80c <gc_execute_block+0x55f0>
                    // Determine coordinate system to change and try to load from non-volatile storage.
                    gc_block.values.coord_data.id = p_value == 0
                                                     ? gc_block.modal.coord_system.id       // Index P0 as the active coordinate system
                                                     : (coord_system_id_t)(p_value - 1);    // else adjust index to NVS coordinate data indexing.
 8008584:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 8008588:	2b00      	cmp	r3, #0
 800858a:	d102      	bne.n	8008592 <gc_execute_block+0x2376>
 800858c:	4b91      	ldr	r3, [pc, #580]	; (80087d4 <gc_execute_block+0x25b8>)
 800858e:	7f1b      	ldrb	r3, [r3, #28]
 8008590:	e003      	b.n	800859a <gc_execute_block+0x237e>
 8008592:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 8008596:	3b01      	subs	r3, #1
 8008598:	b2db      	uxtb	r3, r3
                    gc_block.values.coord_data.id = p_value == 0
 800859a:	4a8e      	ldr	r2, [pc, #568]	; (80087d4 <gc_execute_block+0x25b8>)
 800859c:	f882 3078 	strb.w	r3, [r2, #120]	; 0x78

                    if (!settings_read_coord_data(gc_block.values.coord_data.id, &gc_block.values.coord_data.xyz))
 80085a0:	4b8c      	ldr	r3, [pc, #560]	; (80087d4 <gc_execute_block+0x25b8>)
 80085a2:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 80085a6:	498c      	ldr	r1, [pc, #560]	; (80087d8 <gc_execute_block+0x25bc>)
 80085a8:	4618      	mov	r0, r3
 80085aa:	f012 fb35 	bl	801ac18 <settings_read_coord_data>
 80085ae:	4603      	mov	r3, r0
 80085b0:	f083 0301 	eor.w	r3, r3, #1
 80085b4:	b2db      	uxtb	r3, r3
 80085b6:	2b00      	cmp	r3, #0
 80085b8:	d002      	beq.n	80085c0 <gc_execute_block+0x23a4>
                        FAIL(Status_SettingReadFail); // [non-volatile storage read fail]
 80085ba:	2307      	movs	r3, #7
 80085bc:	f003 b926 	b.w	800b80c <gc_execute_block+0x55f0>

#if COMPATIBILITY_LEVEL <= 1
                    if(settings.offset_lock.mask && gc_block.values.coord_data.id >= CoordinateSystem_G59_1 && gc_block.values.coord_data.id <= CoordinateSystem_G59_3) {
 80085c0:	4b86      	ldr	r3, [pc, #536]	; (80087dc <gc_execute_block+0x25c0>)
 80085c2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80085c6:	2b00      	cmp	r3, #0
 80085c8:	d01a      	beq.n	8008600 <gc_execute_block+0x23e4>
 80085ca:	4b82      	ldr	r3, [pc, #520]	; (80087d4 <gc_execute_block+0x25b8>)
 80085cc:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 80085d0:	2b05      	cmp	r3, #5
 80085d2:	d915      	bls.n	8008600 <gc_execute_block+0x23e4>
 80085d4:	4b7f      	ldr	r3, [pc, #508]	; (80087d4 <gc_execute_block+0x25b8>)
 80085d6:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 80085da:	2b08      	cmp	r3, #8
 80085dc:	d810      	bhi.n	8008600 <gc_execute_block+0x23e4>
                        if(bit_istrue(settings.offset_lock.mask, bit(gc_block.values.coord_data.id - CoordinateSystem_G59_1)))
 80085de:	4b7f      	ldr	r3, [pc, #508]	; (80087dc <gc_execute_block+0x25c0>)
 80085e0:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80085e4:	461a      	mov	r2, r3
 80085e6:	4b7b      	ldr	r3, [pc, #492]	; (80087d4 <gc_execute_block+0x25b8>)
 80085e8:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 80085ec:	3b06      	subs	r3, #6
 80085ee:	fa22 f303 	lsr.w	r3, r2, r3
 80085f2:	f003 0301 	and.w	r3, r3, #1
 80085f6:	2b00      	cmp	r3, #0
 80085f8:	d002      	beq.n	8008600 <gc_execute_block+0x23e4>
                            FAIL(Status_GCodeCoordSystemLocked);
 80085fa:	2338      	movs	r3, #56	; 0x38
 80085fc:	f003 b906 	b.w	800b80c <gc_execute_block+0x55f0>
                    }
#endif

                    // Pre-calculate the coordinate data changes.
                    idx = N_AXIS;
 8008600:	2303      	movs	r3, #3
 8008602:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                    do { // Axes indices are consistent, so loop may be used.
                        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
                        if (bit_istrue(axis_words.mask, bit(--idx))) {
 8008606:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800860a:	461a      	mov	r2, r3
 800860c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008610:	3b01      	subs	r3, #1
 8008612:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008616:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800861a:	fa22 f303 	lsr.w	r3, r2, r3
 800861e:	f003 0301 	and.w	r3, r3, #1
 8008622:	2b00      	cmp	r3, #0
 8008624:	d043      	beq.n	80086ae <gc_execute_block+0x2492>
                            if (gc_block.values.l == 20)
 8008626:	4b6b      	ldr	r3, [pc, #428]	; (80087d4 <gc_execute_block+0x25b8>)
 8008628:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 800862c:	2b14      	cmp	r3, #20
 800862e:	d131      	bne.n	8008694 <gc_execute_block+0x2478>
                                // L20: Update coordinate system axis at current position (with modifiers) with programmed value
                                // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx] - gc_block.values.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_state.tool_length_offset[idx];
 8008630:	4a6b      	ldr	r2, [pc, #428]	; (80087e0 <gc_execute_block+0x25c4>)
 8008632:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008636:	3316      	adds	r3, #22
 8008638:	009b      	lsls	r3, r3, #2
 800863a:	4413      	add	r3, r2
 800863c:	685a      	ldr	r2, [r3, #4]
 800863e:	4965      	ldr	r1, [pc, #404]	; (80087d4 <gc_execute_block+0x25b8>)
 8008640:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008644:	3318      	adds	r3, #24
 8008646:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800864a:	4619      	mov	r1, r3
 800864c:	4610      	mov	r0, r2
 800864e:	f7f8 faa7 	bl	8000ba0 <__aeabi_fsub>
 8008652:	4603      	mov	r3, r0
 8008654:	4618      	mov	r0, r3
 8008656:	4a62      	ldr	r2, [pc, #392]	; (80087e0 <gc_execute_block+0x25c4>)
 8008658:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800865c:	331e      	adds	r3, #30
 800865e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008662:	4619      	mov	r1, r3
 8008664:	f7f8 fa9c 	bl	8000ba0 <__aeabi_fsub>
 8008668:	4603      	mov	r3, r0
 800866a:	4618      	mov	r0, r3
 800866c:	4a5c      	ldr	r2, [pc, #368]	; (80087e0 <gc_execute_block+0x25c4>)
 800866e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008672:	3320      	adds	r3, #32
 8008674:	009b      	lsls	r3, r3, #2
 8008676:	4413      	add	r3, r2
 8008678:	685b      	ldr	r3, [r3, #4]
 800867a:	4619      	mov	r1, r3
 800867c:	f7f8 fa90 	bl	8000ba0 <__aeabi_fsub>
 8008680:	4603      	mov	r3, r0
 8008682:	4619      	mov	r1, r3
 8008684:	4a53      	ldr	r2, [pc, #332]	; (80087d4 <gc_execute_block+0x25b8>)
 8008686:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800868a:	331a      	adds	r3, #26
 800868c:	009b      	lsls	r3, r3, #2
 800868e:	4413      	add	r3, r2
 8008690:	6059      	str	r1, [r3, #4]
 8008692:	e00c      	b.n	80086ae <gc_execute_block+0x2492>
                            else // L2: Update coordinate system axis to programmed value.
                                gc_block.values.coord_data.xyz[idx] = gc_block.values.xyz[idx];
 8008694:	4a4f      	ldr	r2, [pc, #316]	; (80087d4 <gc_execute_block+0x25b8>)
 8008696:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800869a:	3318      	adds	r3, #24
 800869c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80086a0:	494c      	ldr	r1, [pc, #304]	; (80087d4 <gc_execute_block+0x25b8>)
 80086a2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80086a6:	331a      	adds	r3, #26
 80086a8:	009b      	lsls	r3, r3, #2
 80086aa:	440b      	add	r3, r1
 80086ac:	605a      	str	r2, [r3, #4]
                        } // else, keep current stored value.
                    } while(idx);
 80086ae:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80086b2:	2b00      	cmp	r3, #0
 80086b4:	d1a7      	bne.n	8008606 <gc_execute_block+0x23ea>
                    break;
 80086b6:	e139      	b.n	800892c <gc_execute_block+0x2710>

                case 1: case 10: case 11:
                    if(grbl.tool_table.n_tools) {
 80086b8:	4b4a      	ldr	r3, [pc, #296]	; (80087e4 <gc_execute_block+0x25c8>)
 80086ba:	699b      	ldr	r3, [r3, #24]
 80086bc:	2b00      	cmp	r3, #0
 80086be:	f000 812e 	beq.w	800891e <gc_execute_block+0x2702>
                        if(p_value == 0 || p_value > grbl.tool_table.n_tools)
 80086c2:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 80086c6:	2b00      	cmp	r3, #0
 80086c8:	d005      	beq.n	80086d6 <gc_execute_block+0x24ba>
 80086ca:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 80086ce:	4b45      	ldr	r3, [pc, #276]	; (80087e4 <gc_execute_block+0x25c8>)
 80086d0:	699b      	ldr	r3, [r3, #24]
 80086d2:	429a      	cmp	r2, r3
 80086d4:	d902      	bls.n	80086dc <gc_execute_block+0x24c0>
                           FAIL(Status_GcodeIllegalToolTableEntry); // [Greater than max allowed tool number]
 80086d6:	2326      	movs	r3, #38	; 0x26
 80086d8:	f003 b898 	b.w	800b80c <gc_execute_block+0x55f0>

                        grbl.tool_table.tool[p_value].tool_id = (tool_id_t)p_value;
 80086dc:	4b41      	ldr	r3, [pc, #260]	; (80087e4 <gc_execute_block+0x25c8>)
 80086de:	69d9      	ldr	r1, [r3, #28]
 80086e0:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 80086e4:	4613      	mov	r3, r2
 80086e6:	009b      	lsls	r3, r3, #2
 80086e8:	4413      	add	r3, r2
 80086ea:	009b      	lsls	r3, r3, #2
 80086ec:	440b      	add	r3, r1
 80086ee:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 80086f2:	611a      	str	r2, [r3, #16]

                        if(gc_block.words.r) {
 80086f4:	4b37      	ldr	r3, [pc, #220]	; (80087d4 <gc_execute_block+0x25b8>)
 80086f6:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80086fa:	f003 0304 	and.w	r3, r3, #4
 80086fe:	b2db      	uxtb	r3, r3
 8008700:	2b00      	cmp	r3, #0
 8008702:	d012      	beq.n	800872a <gc_execute_block+0x250e>
                            grbl.tool_table.tool[p_value].radius = gc_block.values.r;
 8008704:	4b37      	ldr	r3, [pc, #220]	; (80087e4 <gc_execute_block+0x25c8>)
 8008706:	69d9      	ldr	r1, [r3, #28]
 8008708:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 800870c:	4613      	mov	r3, r2
 800870e:	009b      	lsls	r3, r3, #2
 8008710:	4413      	add	r3, r2
 8008712:	009b      	lsls	r3, r3, #2
 8008714:	440b      	add	r3, r1
 8008716:	4a2f      	ldr	r2, [pc, #188]	; (80087d4 <gc_execute_block+0x25b8>)
 8008718:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800871a:	60da      	str	r2, [r3, #12]
                            gc_block.words.r = Off;
 800871c:	4a2d      	ldr	r2, [pc, #180]	; (80087d4 <gc_execute_block+0x25b8>)
 800871e:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8008722:	f36f 0382 	bfc	r3, #2, #1
 8008726:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                        }

                        float g59_3_offset[N_AXIS];
                        if(gc_block.values.l == 11 && !settings_read_coord_data(CoordinateSystem_G59_3, &g59_3_offset))
 800872a:	4b2a      	ldr	r3, [pc, #168]	; (80087d4 <gc_execute_block+0x25b8>)
 800872c:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008730:	2b0b      	cmp	r3, #11
 8008732:	d10e      	bne.n	8008752 <gc_execute_block+0x2536>
 8008734:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8008738:	4619      	mov	r1, r3
 800873a:	2008      	movs	r0, #8
 800873c:	f012 fa6c 	bl	801ac18 <settings_read_coord_data>
 8008740:	4603      	mov	r3, r0
 8008742:	f083 0301 	eor.w	r3, r3, #1
 8008746:	b2db      	uxtb	r3, r3
 8008748:	2b00      	cmp	r3, #0
 800874a:	d002      	beq.n	8008752 <gc_execute_block+0x2536>
                            FAIL(Status_SettingReadFail);
 800874c:	2307      	movs	r3, #7
 800874e:	f003 b85d 	b.w	800b80c <gc_execute_block+0x55f0>

                        if(gc_block.values.l == 1)
 8008752:	4b20      	ldr	r3, [pc, #128]	; (80087d4 <gc_execute_block+0x25b8>)
 8008754:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008758:	2b01      	cmp	r3, #1
 800875a:	d10e      	bne.n	800877a <gc_execute_block+0x255e>
                            grbl.tool_table.read(p_value, &grbl.tool_table.tool[p_value]);
 800875c:	4b21      	ldr	r3, [pc, #132]	; (80087e4 <gc_execute_block+0x25c8>)
 800875e:	6a1c      	ldr	r4, [r3, #32]
 8008760:	f897 00eb 	ldrb.w	r0, [r7, #235]	; 0xeb
 8008764:	4b1f      	ldr	r3, [pc, #124]	; (80087e4 <gc_execute_block+0x25c8>)
 8008766:	69d9      	ldr	r1, [r3, #28]
 8008768:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 800876c:	4613      	mov	r3, r2
 800876e:	009b      	lsls	r3, r3, #2
 8008770:	4413      	add	r3, r2
 8008772:	009b      	lsls	r3, r3, #2
 8008774:	440b      	add	r3, r1
 8008776:	4619      	mov	r1, r3
 8008778:	47a0      	blx	r4

                        idx = N_AXIS;
 800877a:	2303      	movs	r3, #3
 800877c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                        do {
                            if(bit_istrue(axis_words.mask, bit(--idx))) {
 8008780:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008784:	461a      	mov	r2, r3
 8008786:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800878a:	3b01      	subs	r3, #1
 800878c:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008790:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008794:	fa22 f303 	lsr.w	r3, r2, r3
 8008798:	f003 0301 	and.w	r3, r3, #1
 800879c:	2b00      	cmp	r3, #0
 800879e:	f000 8088 	beq.w	80088b2 <gc_execute_block+0x2696>
                                if(gc_block.values.l == 1)
 80087a2:	4b0c      	ldr	r3, [pc, #48]	; (80087d4 <gc_execute_block+0x25b8>)
 80087a4:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 80087a8:	2b01      	cmp	r3, #1
 80087aa:	d11d      	bne.n	80087e8 <gc_execute_block+0x25cc>
                                    grbl.tool_table.tool[p_value].offset[idx] = gc_block.values.xyz[idx];
 80087ac:	4b0d      	ldr	r3, [pc, #52]	; (80087e4 <gc_execute_block+0x25c8>)
 80087ae:	69d9      	ldr	r1, [r3, #28]
 80087b0:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 80087b4:	4613      	mov	r3, r2
 80087b6:	009b      	lsls	r3, r3, #2
 80087b8:	4413      	add	r3, r2
 80087ba:	009b      	lsls	r3, r3, #2
 80087bc:	440b      	add	r3, r1
 80087be:	4905      	ldr	r1, [pc, #20]	; (80087d4 <gc_execute_block+0x25b8>)
 80087c0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80087c4:	3218      	adds	r2, #24
 80087c6:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80087ca:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 80087ce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 80087d2:	e08c      	b.n	80088ee <gc_execute_block+0x26d2>
 80087d4:	20000c8c 	.word	0x20000c8c
 80087d8:	20000cf8 	.word	0x20000cf8
 80087dc:	2000147c 	.word	0x2000147c
 80087e0:	20000bb0 	.word	0x20000bb0
 80087e4:	20000dd4 	.word	0x20000dd4
                                else if(gc_block.values.l == 10)
 80087e8:	4bae      	ldr	r3, [pc, #696]	; (8008aa4 <gc_execute_block+0x2888>)
 80087ea:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 80087ee:	2b0a      	cmp	r3, #10
 80087f0:	d137      	bne.n	8008862 <gc_execute_block+0x2646>
                                    grbl.tool_table.tool[p_value].offset[idx] = gc_state.position[idx] - gc_state.modal.coord_system.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_block.values.xyz[idx];
 80087f2:	4aad      	ldr	r2, [pc, #692]	; (8008aa8 <gc_execute_block+0x288c>)
 80087f4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80087f8:	3316      	adds	r3, #22
 80087fa:	009b      	lsls	r3, r3, #2
 80087fc:	4413      	add	r3, r2
 80087fe:	685a      	ldr	r2, [r3, #4]
 8008800:	49a9      	ldr	r1, [pc, #676]	; (8008aa8 <gc_execute_block+0x288c>)
 8008802:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008806:	3302      	adds	r3, #2
 8008808:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800880c:	4619      	mov	r1, r3
 800880e:	4610      	mov	r0, r2
 8008810:	f7f8 f9c6 	bl	8000ba0 <__aeabi_fsub>
 8008814:	4603      	mov	r3, r0
 8008816:	4618      	mov	r0, r3
 8008818:	4aa3      	ldr	r2, [pc, #652]	; (8008aa8 <gc_execute_block+0x288c>)
 800881a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800881e:	331e      	adds	r3, #30
 8008820:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008824:	4619      	mov	r1, r3
 8008826:	f7f8 f9bb 	bl	8000ba0 <__aeabi_fsub>
 800882a:	4603      	mov	r3, r0
 800882c:	461d      	mov	r5, r3
 800882e:	4a9d      	ldr	r2, [pc, #628]	; (8008aa4 <gc_execute_block+0x2888>)
 8008830:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008834:	3318      	adds	r3, #24
 8008836:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 800883a:	4b9c      	ldr	r3, [pc, #624]	; (8008aac <gc_execute_block+0x2890>)
 800883c:	69d9      	ldr	r1, [r3, #28]
 800883e:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 8008842:	4613      	mov	r3, r2
 8008844:	009b      	lsls	r3, r3, #2
 8008846:	4413      	add	r3, r2
 8008848:	009b      	lsls	r3, r3, #2
 800884a:	18cc      	adds	r4, r1, r3
 800884c:	4601      	mov	r1, r0
 800884e:	4628      	mov	r0, r5
 8008850:	f7f8 f9a6 	bl	8000ba0 <__aeabi_fsub>
 8008854:	4603      	mov	r3, r0
 8008856:	461a      	mov	r2, r3
 8008858:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800885c:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
 8008860:	e045      	b.n	80088ee <gc_execute_block+0x26d2>
                                else if(gc_block.values.l == 11)
 8008862:	4b90      	ldr	r3, [pc, #576]	; (8008aa4 <gc_execute_block+0x2888>)
 8008864:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008868:	2b0b      	cmp	r3, #11
 800886a:	d140      	bne.n	80088ee <gc_execute_block+0x26d2>
                                    grbl.tool_table.tool[p_value].offset[idx] = g59_3_offset[idx] - gc_block.values.xyz[idx];
 800886c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008870:	009b      	lsls	r3, r3, #2
 8008872:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8008876:	f107 0210 	add.w	r2, r7, #16
 800887a:	4413      	add	r3, r2
 800887c:	f853 0cbc 	ldr.w	r0, [r3, #-188]
 8008880:	4a88      	ldr	r2, [pc, #544]	; (8008aa4 <gc_execute_block+0x2888>)
 8008882:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008886:	3318      	adds	r3, #24
 8008888:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
 800888c:	4b87      	ldr	r3, [pc, #540]	; (8008aac <gc_execute_block+0x2890>)
 800888e:	69d9      	ldr	r1, [r3, #28]
 8008890:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 8008894:	4613      	mov	r3, r2
 8008896:	009b      	lsls	r3, r3, #2
 8008898:	4413      	add	r3, r2
 800889a:	009b      	lsls	r3, r3, #2
 800889c:	18cc      	adds	r4, r1, r3
 800889e:	4629      	mov	r1, r5
 80088a0:	f7f8 f97e 	bl	8000ba0 <__aeabi_fsub>
 80088a4:	4603      	mov	r3, r0
 80088a6:	461a      	mov	r2, r3
 80088a8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80088ac:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
 80088b0:	e01d      	b.n	80088ee <gc_execute_block+0x26d2>
    //                            if(gc_block.values.l != 1)
    //                                tool_table[p_value].offset[idx] -= gc_state.tool_length_offset[idx];
                            } else if(gc_block.values.l == 10 || gc_block.values.l == 11)
 80088b2:	4b7c      	ldr	r3, [pc, #496]	; (8008aa4 <gc_execute_block+0x2888>)
 80088b4:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 80088b8:	2b0a      	cmp	r3, #10
 80088ba:	d004      	beq.n	80088c6 <gc_execute_block+0x26aa>
 80088bc:	4b79      	ldr	r3, [pc, #484]	; (8008aa4 <gc_execute_block+0x2888>)
 80088be:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 80088c2:	2b0b      	cmp	r3, #11
 80088c4:	d113      	bne.n	80088ee <gc_execute_block+0x26d2>
                                grbl.tool_table.tool[p_value].offset[idx] = gc_state.tool_length_offset[idx];
 80088c6:	4b79      	ldr	r3, [pc, #484]	; (8008aac <gc_execute_block+0x2890>)
 80088c8:	69d9      	ldr	r1, [r3, #28]
 80088ca:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 80088ce:	4613      	mov	r3, r2
 80088d0:	009b      	lsls	r3, r3, #2
 80088d2:	4413      	add	r3, r2
 80088d4:	009b      	lsls	r3, r3, #2
 80088d6:	18ca      	adds	r2, r1, r3
 80088d8:	4973      	ldr	r1, [pc, #460]	; (8008aa8 <gc_execute_block+0x288c>)
 80088da:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80088de:	3320      	adds	r3, #32
 80088e0:	009b      	lsls	r3, r3, #2
 80088e2:	440b      	add	r3, r1
 80088e4:	6859      	ldr	r1, [r3, #4]
 80088e6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80088ea:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

                            // else, keep current stored value.
                        } while(idx);
 80088ee:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80088f2:	2b00      	cmp	r3, #0
 80088f4:	f47f af44 	bne.w	8008780 <gc_execute_block+0x2564>

                        if(gc_block.values.l == 1)
 80088f8:	4b6a      	ldr	r3, [pc, #424]	; (8008aa4 <gc_execute_block+0x2888>)
 80088fa:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 80088fe:	2b01      	cmp	r3, #1
 8008900:	d113      	bne.n	800892a <gc_execute_block+0x270e>
                            grbl.tool_table.write(&grbl.tool_table.tool[p_value]);
 8008902:	4b6a      	ldr	r3, [pc, #424]	; (8008aac <gc_execute_block+0x2890>)
 8008904:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8008906:	4b69      	ldr	r3, [pc, #420]	; (8008aac <gc_execute_block+0x2890>)
 8008908:	69d8      	ldr	r0, [r3, #28]
 800890a:	f897 20eb 	ldrb.w	r2, [r7, #235]	; 0xeb
 800890e:	4613      	mov	r3, r2
 8008910:	009b      	lsls	r3, r3, #2
 8008912:	4413      	add	r3, r2
 8008914:	009b      	lsls	r3, r3, #2
 8008916:	4403      	add	r3, r0
 8008918:	4618      	mov	r0, r3
 800891a:	4788      	blx	r1
                    } else
                        FAIL(Status_GcodeUnsupportedCommand);
                    break;
 800891c:	e005      	b.n	800892a <gc_execute_block+0x270e>
                        FAIL(Status_GcodeUnsupportedCommand);
 800891e:	2314      	movs	r3, #20
 8008920:	f002 bf74 	b.w	800b80c <gc_execute_block+0x55f0>

                default:
                    FAIL(Status_GcodeUnsupportedCommand); // [Unsupported L]
 8008924:	2314      	movs	r3, #20
 8008926:	f002 bf71 	b.w	800b80c <gc_execute_block+0x55f0>
                    break;
 800892a:	bf00      	nop
            }
            gc_block.words.l = gc_block.words.p = Off;
 800892c:	4a5d      	ldr	r2, [pc, #372]	; (8008aa4 <gc_execute_block+0x2888>)
 800892e:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8008932:	f36f 0300 	bfc	r3, #0, #1
 8008936:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 800893a:	4b5a      	ldr	r3, [pc, #360]	; (8008aa4 <gc_execute_block+0x2888>)
 800893c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008940:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8008944:	b2d9      	uxtb	r1, r3
 8008946:	4a57      	ldr	r2, [pc, #348]	; (8008aa4 <gc_execute_block+0x2888>)
 8008948:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 800894c:	f361 1304 	bfi	r3, r1, #4, #1
 8008950:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
            break;
 8008954:	e193      	b.n	8008c7e <gc_execute_block+0x2a62>

        case NonModal_SetCoordinateOffset:

            // [G92 Errors]: No axis words.
            if (!axis_words.mask)
 8008956:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800895a:	2b00      	cmp	r3, #0
 800895c:	d102      	bne.n	8008964 <gc_execute_block+0x2748>
                FAIL(Status_GcodeNoAxisWords); // [No axis words]
 800895e:	231a      	movs	r3, #26
 8008960:	f002 bf54 	b.w	800b80c <gc_execute_block+0x55f0>

            // Update axes defined only in block. Offsets current system to defined value. Does not update when
            // active coordinate system is selected, but is still active unless G92.1 disables it.
            idx = N_AXIS;
 8008964:	2303      	movs	r3, #3
 8008966:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
            do { // Axes indices are consistent, so loop may be used.
                if (bit_istrue(axis_words.mask, bit(--idx))) {
 800896a:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800896e:	461a      	mov	r2, r3
 8008970:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008974:	3b01      	subs	r3, #1
 8008976:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800897a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800897e:	fa22 f303 	lsr.w	r3, r2, r3
 8008982:	f003 0301 	and.w	r3, r3, #1
 8008986:	2b00      	cmp	r3, #0
 8008988:	d030      	beq.n	80089ec <gc_execute_block+0x27d0>
            // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
                    gc_block.values.xyz[idx] = gc_state.position[idx] - gc_block.modal.coord_system.xyz[idx] - gc_block.values.xyz[idx] - gc_state.tool_length_offset[idx];
 800898a:	4a47      	ldr	r2, [pc, #284]	; (8008aa8 <gc_execute_block+0x288c>)
 800898c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008990:	3316      	adds	r3, #22
 8008992:	009b      	lsls	r3, r3, #2
 8008994:	4413      	add	r3, r2
 8008996:	685a      	ldr	r2, [r3, #4]
 8008998:	4942      	ldr	r1, [pc, #264]	; (8008aa4 <gc_execute_block+0x2888>)
 800899a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800899e:	3304      	adds	r3, #4
 80089a0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80089a4:	4619      	mov	r1, r3
 80089a6:	4610      	mov	r0, r2
 80089a8:	f7f8 f8fa 	bl	8000ba0 <__aeabi_fsub>
 80089ac:	4603      	mov	r3, r0
 80089ae:	4618      	mov	r0, r3
 80089b0:	4a3c      	ldr	r2, [pc, #240]	; (8008aa4 <gc_execute_block+0x2888>)
 80089b2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80089b6:	3318      	adds	r3, #24
 80089b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80089bc:	4619      	mov	r1, r3
 80089be:	f7f8 f8ef 	bl	8000ba0 <__aeabi_fsub>
 80089c2:	4603      	mov	r3, r0
 80089c4:	4618      	mov	r0, r3
 80089c6:	4a38      	ldr	r2, [pc, #224]	; (8008aa8 <gc_execute_block+0x288c>)
 80089c8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80089cc:	3320      	adds	r3, #32
 80089ce:	009b      	lsls	r3, r3, #2
 80089d0:	4413      	add	r3, r2
 80089d2:	685b      	ldr	r3, [r3, #4]
 80089d4:	4619      	mov	r1, r3
 80089d6:	f7f8 f8e3 	bl	8000ba0 <__aeabi_fsub>
 80089da:	4603      	mov	r3, r0
 80089dc:	4619      	mov	r1, r3
 80089de:	4a31      	ldr	r2, [pc, #196]	; (8008aa4 <gc_execute_block+0x2888>)
 80089e0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80089e4:	3318      	adds	r3, #24
 80089e6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 80089ea:	e00b      	b.n	8008a04 <gc_execute_block+0x27e8>
                } else
                    gc_block.values.xyz[idx] = gc_state.g92_coord_offset[idx];
 80089ec:	4a2e      	ldr	r2, [pc, #184]	; (8008aa8 <gc_execute_block+0x288c>)
 80089ee:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80089f2:	331e      	adds	r3, #30
 80089f4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80089f8:	492a      	ldr	r1, [pc, #168]	; (8008aa4 <gc_execute_block+0x2888>)
 80089fa:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80089fe:	3318      	adds	r3, #24
 8008a00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            } while(idx);
 8008a04:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a08:	2b00      	cmp	r3, #0
 8008a0a:	d1ae      	bne.n	800896a <gc_execute_block+0x274e>
            break;
 8008a0c:	e137      	b.n	8008c7e <gc_execute_block+0x2a62>

            // At this point, the rest of the explicit axis commands treat the axis values as the traditional
            // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
            // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
            // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
            if (axis_words.mask && axis_command != AxisCommand_ToolLengthOffset) { // TLO block any axis command.
 8008a0e:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008a12:	2b00      	cmp	r3, #0
 8008a14:	d068      	beq.n	8008ae8 <gc_execute_block+0x28cc>
 8008a16:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8008a1a:	2b03      	cmp	r3, #3
 8008a1c:	d064      	beq.n	8008ae8 <gc_execute_block+0x28cc>
                idx = N_AXIS;
 8008a1e:	2303      	movs	r3, #3
 8008a20:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                do { // Axes indices are consistent, so loop may be used to save flash space.
                    if(bit_isfalse(axis_words.mask, bit(--idx)))
 8008a24:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008a28:	461a      	mov	r2, r3
 8008a2a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a2e:	3b01      	subs	r3, #1
 8008a30:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008a34:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a38:	fa22 f303 	lsr.w	r3, r2, r3
 8008a3c:	f003 0301 	and.w	r3, r3, #1
 8008a40:	2b00      	cmp	r3, #0
 8008a42:	d10d      	bne.n	8008a60 <gc_execute_block+0x2844>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8008a44:	4a18      	ldr	r2, [pc, #96]	; (8008aa8 <gc_execute_block+0x288c>)
 8008a46:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a4a:	3316      	adds	r3, #22
 8008a4c:	009b      	lsls	r3, r3, #2
 8008a4e:	4413      	add	r3, r2
 8008a50:	685a      	ldr	r2, [r3, #4]
 8008a52:	4914      	ldr	r1, [pc, #80]	; (8008aa4 <gc_execute_block+0x2888>)
 8008a54:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a58:	3318      	adds	r3, #24
 8008a5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8008a5e:	e03f      	b.n	8008ae0 <gc_execute_block+0x28c4>
                    else if(gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 8008a60:	4b10      	ldr	r3, [pc, #64]	; (8008aa4 <gc_execute_block+0x2888>)
 8008a62:	781b      	ldrb	r3, [r3, #0]
 8008a64:	2b35      	cmp	r3, #53	; 0x35
 8008a66:	d03b      	beq.n	8008ae0 <gc_execute_block+0x28c4>
                        if(bit_istrue(axis_words.mask, bit(idx)) && gc_block.values.uvw[idx] != 0.0f)
  #endif
                            gc_block.values.xyz[idx] = gc_state.position[idx] + gc_block.values.uvw[idx];
                        else
#endif
                        if(gc_block.modal.distance_incremental)
 8008a68:	4b0e      	ldr	r3, [pc, #56]	; (8008aa4 <gc_execute_block+0x2888>)
 8008a6a:	7b1b      	ldrb	r3, [r3, #12]
 8008a6c:	2b00      	cmp	r3, #0
 8008a6e:	d01f      	beq.n	8008ab0 <gc_execute_block+0x2894>
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 8008a70:	4a0c      	ldr	r2, [pc, #48]	; (8008aa4 <gc_execute_block+0x2888>)
 8008a72:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a76:	3318      	adds	r3, #24
 8008a78:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8008a7c:	490a      	ldr	r1, [pc, #40]	; (8008aa8 <gc_execute_block+0x288c>)
 8008a7e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a82:	3316      	adds	r3, #22
 8008a84:	009b      	lsls	r3, r3, #2
 8008a86:	440b      	add	r3, r1
 8008a88:	685b      	ldr	r3, [r3, #4]
 8008a8a:	4619      	mov	r1, r3
 8008a8c:	4610      	mov	r0, r2
 8008a8e:	f7f8 f889 	bl	8000ba4 <__addsf3>
 8008a92:	4603      	mov	r3, r0
 8008a94:	4619      	mov	r1, r3
 8008a96:	4a03      	ldr	r2, [pc, #12]	; (8008aa4 <gc_execute_block+0x2888>)
 8008a98:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008a9c:	3318      	adds	r3, #24
 8008a9e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8008aa2:	e01d      	b.n	8008ae0 <gc_execute_block+0x28c4>
 8008aa4:	20000c8c 	.word	0x20000c8c
 8008aa8:	20000bb0 	.word	0x20000bb0
 8008aac:	20000dd4 	.word	0x20000dd4
                        else  // Absolute mode
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8008ab0:	f8d7 10f8 	ldr.w	r1, [r7, #248]	; 0xf8
 8008ab4:	48ba      	ldr	r0, [pc, #744]	; (8008da0 <gc_execute_block+0x2b84>)
 8008ab6:	f7fc ffb5 	bl	8005a24 <gc_get_block_offset>
 8008aba:	4602      	mov	r2, r0
 8008abc:	49b8      	ldr	r1, [pc, #736]	; (8008da0 <gc_execute_block+0x2b84>)
 8008abe:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008ac2:	3318      	adds	r3, #24
 8008ac4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8008ac8:	4619      	mov	r1, r3
 8008aca:	4610      	mov	r0, r2
 8008acc:	f7f8 f86a 	bl	8000ba4 <__addsf3>
 8008ad0:	4603      	mov	r3, r0
 8008ad2:	4619      	mov	r1, r3
 8008ad4:	4ab2      	ldr	r2, [pc, #712]	; (8008da0 <gc_execute_block+0x2b84>)
 8008ad6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008ada:	3318      	adds	r3, #24
 8008adc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    }
                } while(idx);
 8008ae0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008ae4:	2b00      	cmp	r3, #0
 8008ae6:	d19d      	bne.n	8008a24 <gc_execute_block+0x2808>
            }

            // Check remaining non-modal commands for errors.
            switch (gc_block.non_modal_command) {
 8008ae8:	4bad      	ldr	r3, [pc, #692]	; (8008da0 <gc_execute_block+0x2b84>)
 8008aea:	781b      	ldrb	r3, [r3, #0]
 8008aec:	2b41      	cmp	r3, #65	; 0x41
 8008aee:	dc55      	bgt.n	8008b9c <gc_execute_block+0x2980>
 8008af0:	2b1c      	cmp	r3, #28
 8008af2:	f2c0 80c1 	blt.w	8008c78 <gc_execute_block+0x2a5c>
 8008af6:	3b1c      	subs	r3, #28
 8008af8:	2b25      	cmp	r3, #37	; 0x25
 8008afa:	f200 80bd 	bhi.w	8008c78 <gc_execute_block+0x2a5c>
 8008afe:	a201      	add	r2, pc, #4	; (adr r2, 8008b04 <gc_execute_block+0x28e8>)
 8008b00:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008b04:	08008ba1 	.word	0x08008ba1
 8008b08:	08008c79 	.word	0x08008c79
 8008b0c:	08008ba1 	.word	0x08008ba1
 8008b10:	08008c79 	.word	0x08008c79
 8008b14:	08008c79 	.word	0x08008c79
 8008b18:	08008c79 	.word	0x08008c79
 8008b1c:	08008c79 	.word	0x08008c79
 8008b20:	08008c79 	.word	0x08008c79
 8008b24:	08008c79 	.word	0x08008c79
 8008b28:	08008c79 	.word	0x08008c79
 8008b2c:	08008c79 	.word	0x08008c79
 8008b30:	08008c79 	.word	0x08008c79
 8008b34:	08008c79 	.word	0x08008c79
 8008b38:	08008c79 	.word	0x08008c79
 8008b3c:	08008c79 	.word	0x08008c79
 8008b40:	08008c79 	.word	0x08008c79
 8008b44:	08008c79 	.word	0x08008c79
 8008b48:	08008c79 	.word	0x08008c79
 8008b4c:	08008c79 	.word	0x08008c79
 8008b50:	08008c79 	.word	0x08008c79
 8008b54:	08008c79 	.word	0x08008c79
 8008b58:	08008c79 	.word	0x08008c79
 8008b5c:	08008c79 	.word	0x08008c79
 8008b60:	08008c79 	.word	0x08008c79
 8008b64:	08008c79 	.word	0x08008c79
 8008b68:	08008c25 	.word	0x08008c25
 8008b6c:	08008c79 	.word	0x08008c79
 8008b70:	08008c79 	.word	0x08008c79
 8008b74:	08008c79 	.word	0x08008c79
 8008b78:	08008c79 	.word	0x08008c79
 8008b7c:	08008c79 	.word	0x08008c79
 8008b80:	08008c79 	.word	0x08008c79
 8008b84:	08008c79 	.word	0x08008c79
 8008b88:	08008c79 	.word	0x08008c79
 8008b8c:	08008c79 	.word	0x08008c79
 8008b90:	08008c79 	.word	0x08008c79
 8008b94:	08008c79 	.word	0x08008c79
 8008b98:	08008c3b 	.word	0x08008c3b
 8008b9c:	2b66      	cmp	r3, #102	; 0x66
                    // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
                    break;

                case NonModal_ResetCoordinateOffset:
                    // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
                    break;
 8008b9e:	e06e      	b.n	8008c7e <gc_execute_block+0x2a62>
                    if (!settings_read_coord_data(gc_block.non_modal_command == NonModal_GoHome_0 ? CoordinateSystem_G28 : CoordinateSystem_G30, &gc_block.values.coord_data.xyz))
 8008ba0:	4b7f      	ldr	r3, [pc, #508]	; (8008da0 <gc_execute_block+0x2b84>)
 8008ba2:	781b      	ldrb	r3, [r3, #0]
 8008ba4:	2b1c      	cmp	r3, #28
 8008ba6:	d101      	bne.n	8008bac <gc_execute_block+0x2990>
 8008ba8:	2309      	movs	r3, #9
 8008baa:	e000      	b.n	8008bae <gc_execute_block+0x2992>
 8008bac:	230a      	movs	r3, #10
 8008bae:	497d      	ldr	r1, [pc, #500]	; (8008da4 <gc_execute_block+0x2b88>)
 8008bb0:	4618      	mov	r0, r3
 8008bb2:	f012 f831 	bl	801ac18 <settings_read_coord_data>
 8008bb6:	4603      	mov	r3, r0
 8008bb8:	f083 0301 	eor.w	r3, r3, #1
 8008bbc:	b2db      	uxtb	r3, r3
 8008bbe:	2b00      	cmp	r3, #0
 8008bc0:	d002      	beq.n	8008bc8 <gc_execute_block+0x29ac>
                        FAIL(Status_SettingReadFail);
 8008bc2:	2307      	movs	r3, #7
 8008bc4:	f002 be22 	b.w	800b80c <gc_execute_block+0x55f0>
                    if (axis_words.mask) {
 8008bc8:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008bcc:	2b00      	cmp	r3, #0
 8008bce:	d025      	beq.n	8008c1c <gc_execute_block+0x2a00>
                        idx = N_AXIS;
 8008bd0:	2303      	movs	r3, #3
 8008bd2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                            if (bit_isfalse(axis_words.mask, bit(--idx)))
 8008bd6:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008bda:	461a      	mov	r2, r3
 8008bdc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008be0:	3b01      	subs	r3, #1
 8008be2:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8008be6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008bea:	fa22 f303 	lsr.w	r3, r2, r3
 8008bee:	f003 0301 	and.w	r3, r3, #1
 8008bf2:	2b00      	cmp	r3, #0
 8008bf4:	d10d      	bne.n	8008c12 <gc_execute_block+0x29f6>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx];
 8008bf6:	4a6c      	ldr	r2, [pc, #432]	; (8008da8 <gc_execute_block+0x2b8c>)
 8008bf8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008bfc:	3316      	adds	r3, #22
 8008bfe:	009b      	lsls	r3, r3, #2
 8008c00:	4413      	add	r3, r2
 8008c02:	685a      	ldr	r2, [r3, #4]
 8008c04:	4966      	ldr	r1, [pc, #408]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c06:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008c0a:	331a      	adds	r3, #26
 8008c0c:	009b      	lsls	r3, r3, #2
 8008c0e:	440b      	add	r3, r1
 8008c10:	605a      	str	r2, [r3, #4]
                        } while(idx);
 8008c12:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8008c16:	2b00      	cmp	r3, #0
 8008c18:	d1dd      	bne.n	8008bd6 <gc_execute_block+0x29ba>
                    break;
 8008c1a:	e030      	b.n	8008c7e <gc_execute_block+0x2a62>
                        axis_command = AxisCommand_None; // Set to none if no intermediate motion.
 8008c1c:	2300      	movs	r3, #0
 8008c1e:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                    break;
 8008c22:	e02c      	b.n	8008c7e <gc_execute_block+0x2a62>

                case NonModal_AbsoluteOverride:
                    // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
                    // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
                    if (!(gc_block.modal.motion == MotionMode_Seek || gc_block.modal.motion == MotionMode_Linear))
 8008c24:	4b5e      	ldr	r3, [pc, #376]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c26:	891b      	ldrh	r3, [r3, #8]
 8008c28:	2b00      	cmp	r3, #0
 8008c2a:	d027      	beq.n	8008c7c <gc_execute_block+0x2a60>
 8008c2c:	4b5c      	ldr	r3, [pc, #368]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c2e:	891b      	ldrh	r3, [r3, #8]
 8008c30:	2b01      	cmp	r3, #1
 8008c32:	d023      	beq.n	8008c7c <gc_execute_block+0x2a60>
                        FAIL(Status_GcodeG53InvalidMotionMode); // [G53 G0/1 not active]
 8008c34:	231e      	movs	r3, #30
 8008c36:	f002 bde9 	b.w	800b80c <gc_execute_block+0x55f0>
                    break;

                case NonModal_MacroCall:
                    if(!gc_block.words.p)
 8008c3a:	4b59      	ldr	r3, [pc, #356]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c3c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008c40:	f003 0301 	and.w	r3, r3, #1
 8008c44:	b2db      	uxtb	r3, r3
 8008c46:	2b00      	cmp	r3, #0
 8008c48:	d102      	bne.n	8008c50 <gc_execute_block+0x2a34>
                        FAIL(Status_GcodeValueWordMissing); // [P word missing]
 8008c4a:	231c      	movs	r3, #28
 8008c4c:	f002 bdde 	b.w	800b80c <gc_execute_block+0x55f0>
                    if(gc_block.values.p > 65535.0f)
 8008c50:	4b53      	ldr	r3, [pc, #332]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c52:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008c54:	4955      	ldr	r1, [pc, #340]	; (8008dac <gc_execute_block+0x2b90>)
 8008c56:	4618      	mov	r0, r3
 8008c58:	f7f8 fa68 	bl	800112c <__aeabi_fcmpgt>
 8008c5c:	4603      	mov	r3, r0
 8008c5e:	2b00      	cmp	r3, #0
 8008c60:	d002      	beq.n	8008c68 <gc_execute_block+0x2a4c>
                        FAIL(Status_GcodeValueOutOfRange); // [P word out of range]
 8008c62:	2327      	movs	r3, #39	; 0x27
 8008c64:	f002 bdd2 	b.w	800b80c <gc_execute_block+0x55f0>
                            idx++;
                            gc_block.words.value >>= 1;
                        }
                    }
#else
                    gc_block.words.p = Off;
 8008c68:	4a4d      	ldr	r2, [pc, #308]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c6a:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8008c6e:	f36f 0300 	bfc	r3, #0, #1
 8008c72:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
#endif
                    break;
 8008c76:	e002      	b.n	8008c7e <gc_execute_block+0x2a62>
                default:
                    break;
 8008c78:	bf00      	nop
 8008c7a:	e000      	b.n	8008c7e <gc_execute_block+0x2a62>
                    break;
 8008c7c:	bf00      	nop
            }
    } // end gc_block.non_modal_command

    // [20. Motion modes ]:
    if (gc_block.modal.motion == MotionMode_None) {
 8008c7e:	4b48      	ldr	r3, [pc, #288]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c80:	891b      	ldrh	r3, [r3, #8]
 8008c82:	2b50      	cmp	r3, #80	; 0x50
 8008c84:	d110      	bne.n	8008ca8 <gc_execute_block+0x2a8c>

        // [G80 Errors]: Axis word are programmed while G80 is active.
        // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
        if (axis_words.mask && axis_command != AxisCommand_NonModal) // [No axis words allowed]
 8008c86:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008c8a:	2b00      	cmp	r3, #0
 8008c8c:	d006      	beq.n	8008c9c <gc_execute_block+0x2a80>
 8008c8e:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8008c92:	2b01      	cmp	r3, #1
 8008c94:	d002      	beq.n	8008c9c <gc_execute_block+0x2a80>
            FAIL(Status_GcodeAxisWordsExist);
 8008c96:	231f      	movs	r3, #31
 8008c98:	f002 bdb8 	b.w	800b80c <gc_execute_block+0x55f0>

        gc_block.modal.retract_mode = CCRetractMode_Previous;
 8008c9c:	4b40      	ldr	r3, [pc, #256]	; (8008da0 <gc_execute_block+0x2b84>)
 8008c9e:	2200      	movs	r2, #0
 8008ca0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8008ca4:	f001 b984 	b.w	8009fb0 <gc_execute_block+0x3d94>

    // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
    // was explicitly commanded in the g-code block.
    } else if (axis_command == AxisCommand_MotionMode) {
 8008ca8:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 8008cac:	2b02      	cmp	r3, #2
 8008cae:	f041 817f 	bne.w	8009fb0 <gc_execute_block+0x3d94>

        gc_parser_flags.motion_mode_changed = gc_block.modal.motion != gc_state.modal.motion;
 8008cb2:	4b3b      	ldr	r3, [pc, #236]	; (8008da0 <gc_execute_block+0x2b84>)
 8008cb4:	891a      	ldrh	r2, [r3, #8]
 8008cb6:	4b3c      	ldr	r3, [pc, #240]	; (8008da8 <gc_execute_block+0x2b8c>)
 8008cb8:	881b      	ldrh	r3, [r3, #0]
 8008cba:	429a      	cmp	r2, r3
 8008cbc:	bf14      	ite	ne
 8008cbe:	2301      	movne	r3, #1
 8008cc0:	2300      	moveq	r3, #0
 8008cc2:	b2da      	uxtb	r2, r3
 8008cc4:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8008cc8:	f362 0341 	bfi	r3, r2, #1, #1
 8008ccc:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d

        if (gc_block.modal.motion == MotionMode_Seek) {
 8008cd0:	4b33      	ldr	r3, [pc, #204]	; (8008da0 <gc_execute_block+0x2b84>)
 8008cd2:	891b      	ldrh	r3, [r3, #8]
 8008cd4:	2b00      	cmp	r3, #0
 8008cd6:	d109      	bne.n	8008cec <gc_execute_block+0x2ad0>
            // [G0 Errors]: Axis letter not configured or without real value (done.)
            // Axis words are optional. If missing, set axis command flag to ignore execution.
            if (!axis_words.mask)
 8008cd8:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008cdc:	2b00      	cmp	r3, #0
 8008cde:	f041 8167 	bne.w	8009fb0 <gc_execute_block+0x3d94>
                axis_command = AxisCommand_None;
 8008ce2:	2300      	movs	r3, #0
 8008ce4:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
 8008ce8:	f001 b962 	b.w	8009fb0 <gc_execute_block+0x3d94>

        // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
        // the value must be positive. In inverse time mode, a positive value must be passed with each block.
        } else {

            if(!gc_block.modal.canned_cycle_active)
 8008cec:	4b2c      	ldr	r3, [pc, #176]	; (8008da0 <gc_execute_block+0x2b84>)
 8008cee:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8008cf2:	f083 0301 	eor.w	r3, r3, #1
 8008cf6:	b2db      	uxtb	r3, r3
 8008cf8:	2b00      	cmp	r3, #0
 8008cfa:	d003      	beq.n	8008d04 <gc_execute_block+0x2ae8>
                gc_block.modal.retract_mode = CCRetractMode_Previous;
 8008cfc:	4b28      	ldr	r3, [pc, #160]	; (8008da0 <gc_execute_block+0x2b84>)
 8008cfe:	2200      	movs	r2, #0
 8008d00:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

            // Initial(?) check for spindle running for moves in G96 mode
            if(gc_block.modal.spindle.rpm_mode == SpindleSpeedMode_CSS && (!gc_block.modal.spindle.state.on || gc_block.values.s == 0.0f))
 8008d04:	4b26      	ldr	r3, [pc, #152]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d06:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8008d0a:	2b01      	cmp	r3, #1
 8008d0c:	d114      	bne.n	8008d38 <gc_execute_block+0x2b1c>
 8008d0e:	4b24      	ldr	r3, [pc, #144]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d10:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8008d14:	f003 0301 	and.w	r3, r3, #1
 8008d18:	b2db      	uxtb	r3, r3
 8008d1a:	2b00      	cmp	r3, #0
 8008d1c:	d009      	beq.n	8008d32 <gc_execute_block+0x2b16>
 8008d1e:	4b20      	ldr	r3, [pc, #128]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008d22:	f04f 0100 	mov.w	r1, #0
 8008d26:	4618      	mov	r0, r3
 8008d28:	f7f8 f9d8 	bl	80010dc <__aeabi_fcmpeq>
 8008d2c:	4603      	mov	r3, r0
 8008d2e:	2b00      	cmp	r3, #0
 8008d30:	d002      	beq.n	8008d38 <gc_execute_block+0x2b1c>
                 FAIL(Status_GcodeSpindleNotRunning);
 8008d32:	2329      	movs	r3, #41	; 0x29
 8008d34:	f002 bd6a 	b.w	800b80c <gc_execute_block+0x55f0>

            // Check if feed rate is defined for the motion modes that require it.
            if (gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 8008d38:	4b19      	ldr	r3, [pc, #100]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d3a:	891b      	ldrh	r3, [r3, #8]
 8008d3c:	2b21      	cmp	r3, #33	; 0x21
 8008d3e:	d11b      	bne.n	8008d78 <gc_execute_block+0x2b5c>

                if(!gc_state.spindle.hal->get_data)
 8008d40:	4b19      	ldr	r3, [pc, #100]	; (8008da8 <gc_execute_block+0x2b8c>)
 8008d42:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008d44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008d46:	2b00      	cmp	r3, #0
 8008d48:	d102      	bne.n	8008d50 <gc_execute_block+0x2b34>
                    FAIL(Status_GcodeUnsupportedCommand); // [G33, G33.1]
 8008d4a:	2314      	movs	r3, #20
 8008d4c:	f002 bd5e 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.values.k == 0.0f)
 8008d50:	4b13      	ldr	r3, [pc, #76]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d52:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008d54:	f04f 0100 	mov.w	r1, #0
 8008d58:	4618      	mov	r0, r3
 8008d5a:	f7f8 f9bf 	bl	80010dc <__aeabi_fcmpeq>
 8008d5e:	4603      	mov	r3, r0
 8008d60:	2b00      	cmp	r3, #0
 8008d62:	d002      	beq.n	8008d6a <gc_execute_block+0x2b4e>
                    FAIL(Status_GcodeValueOutOfRange); // [No distance (pitch) given]
 8008d64:	2327      	movs	r3, #39	; 0x27
 8008d66:	f002 bd51 	b.w	800b80c <gc_execute_block+0x55f0>

                // Ensure spindle speed is at 100% - any override will be disabled on execute.
                gc_parser_flags.spindle_force_sync = On;
 8008d6a:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8008d6e:	f043 0320 	orr.w	r3, r3, #32
 8008d72:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
 8008d76:	e29c      	b.n	80092b2 <gc_execute_block+0x3096>

            } else if (gc_block.modal.motion == MotionMode_Threading) {
 8008d78:	4b09      	ldr	r3, [pc, #36]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d7a:	891b      	ldrh	r3, [r3, #8]
 8008d7c:	2b4c      	cmp	r3, #76	; 0x4c
 8008d7e:	f040 828b 	bne.w	8009298 <gc_execute_block+0x307c>

                // Fail if cutter radius comp is active

                if(!gc_state.spindle.hal->get_data)
 8008d82:	4b09      	ldr	r3, [pc, #36]	; (8008da8 <gc_execute_block+0x2b8c>)
 8008d84:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008d86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008d88:	2b00      	cmp	r3, #0
 8008d8a:	d102      	bne.n	8008d92 <gc_execute_block+0x2b76>
                    FAIL(Status_GcodeUnsupportedCommand); // [G76 not supported]
 8008d8c:	2314      	movs	r3, #20
 8008d8e:	f002 bd3d 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.modal.plane_select != PlaneSelect_ZX)
 8008d92:	4b03      	ldr	r3, [pc, #12]	; (8008da0 <gc_execute_block+0x2b84>)
 8008d94:	7b9b      	ldrb	r3, [r3, #14]
 8008d96:	2b01      	cmp	r3, #1
 8008d98:	d00a      	beq.n	8008db0 <gc_execute_block+0x2b94>
                    FAIL(Status_GcodeIllegalPlane); // [Plane not ZX]
 8008d9a:	232a      	movs	r3, #42	; 0x2a
 8008d9c:	f002 bd36 	b.w	800b80c <gc_execute_block+0x55f0>
 8008da0:	20000c8c 	.word	0x20000c8c
 8008da4:	20000cf8 	.word	0x20000cf8
 8008da8:	20000bb0 	.word	0x20000bb0
 8008dac:	477fff00 	.word	0x477fff00

                if(axis_words.mask & ~(bit(X_AXIS)|bit(Z_AXIS)))
 8008db0:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008db4:	f023 0305 	bic.w	r3, r3, #5
 8008db8:	2b00      	cmp	r3, #0
 8008dba:	d002      	beq.n	8008dc2 <gc_execute_block+0x2ba6>
                    FAIL(Status_GcodeUnusedWords); // [Only X and Z axis words allowed]
 8008dbc:	2324      	movs	r3, #36	; 0x24
 8008dbe:	f002 bd25 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.words.r && gc_block.values.r < 1.0f)
 8008dc2:	4b66      	ldr	r3, [pc, #408]	; (8008f5c <gc_execute_block+0x2d40>)
 8008dc4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008dc8:	f003 0304 	and.w	r3, r3, #4
 8008dcc:	b2db      	uxtb	r3, r3
 8008dce:	2b00      	cmp	r3, #0
 8008dd0:	d00c      	beq.n	8008dec <gc_execute_block+0x2bd0>
 8008dd2:	4b62      	ldr	r3, [pc, #392]	; (8008f5c <gc_execute_block+0x2d40>)
 8008dd4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008dd6:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008dda:	4618      	mov	r0, r3
 8008ddc:	f7f8 f988 	bl	80010f0 <__aeabi_fcmplt>
 8008de0:	4603      	mov	r3, r0
 8008de2:	2b00      	cmp	r3, #0
 8008de4:	d002      	beq.n	8008dec <gc_execute_block+0x2bd0>
                    FAIL(Status_GcodeValueOutOfRange);
 8008de6:	2327      	movs	r3, #39	; 0x27
 8008de8:	f002 bd10 	b.w	800b80c <gc_execute_block+0x55f0>

                if(!axis_words.z || !(gc_block.words.i || gc_block.words.j || gc_block.words.k || gc_block.words.p))
 8008dec:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8008df0:	f003 0304 	and.w	r3, r3, #4
 8008df4:	b2db      	uxtb	r3, r3
 8008df6:	2b00      	cmp	r3, #0
 8008df8:	d01f      	beq.n	8008e3a <gc_execute_block+0x2c1e>
 8008dfa:	4b58      	ldr	r3, [pc, #352]	; (8008f5c <gc_execute_block+0x2d40>)
 8008dfc:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8008e00:	f003 0310 	and.w	r3, r3, #16
 8008e04:	b2db      	uxtb	r3, r3
 8008e06:	2b00      	cmp	r3, #0
 8008e08:	d11a      	bne.n	8008e40 <gc_execute_block+0x2c24>
 8008e0a:	4b54      	ldr	r3, [pc, #336]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e0c:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8008e10:	f003 0320 	and.w	r3, r3, #32
 8008e14:	b2db      	uxtb	r3, r3
 8008e16:	2b00      	cmp	r3, #0
 8008e18:	d112      	bne.n	8008e40 <gc_execute_block+0x2c24>
 8008e1a:	4b50      	ldr	r3, [pc, #320]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e1c:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8008e20:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008e24:	b2db      	uxtb	r3, r3
 8008e26:	2b00      	cmp	r3, #0
 8008e28:	d10a      	bne.n	8008e40 <gc_execute_block+0x2c24>
 8008e2a:	4b4c      	ldr	r3, [pc, #304]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e2c:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8008e30:	f003 0301 	and.w	r3, r3, #1
 8008e34:	b2db      	uxtb	r3, r3
 8008e36:	2b00      	cmp	r3, #0
 8008e38:	d102      	bne.n	8008e40 <gc_execute_block+0x2c24>
                    FAIL(Status_GcodeValueWordMissing);
 8008e3a:	231c      	movs	r3, #28
 8008e3c:	f002 bce6 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.values.p < 0.0f || gc_block.values.ijk[J_VALUE] < 0.0f || gc_block.values.ijk[K_VALUE] < 0.0f)
 8008e40:	4b46      	ldr	r3, [pc, #280]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e42:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008e44:	f04f 0100 	mov.w	r1, #0
 8008e48:	4618      	mov	r0, r3
 8008e4a:	f7f8 f951 	bl	80010f0 <__aeabi_fcmplt>
 8008e4e:	4603      	mov	r3, r0
 8008e50:	2b00      	cmp	r3, #0
 8008e52:	d113      	bne.n	8008e7c <gc_execute_block+0x2c60>
 8008e54:	4b41      	ldr	r3, [pc, #260]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008e58:	f04f 0100 	mov.w	r1, #0
 8008e5c:	4618      	mov	r0, r3
 8008e5e:	f7f8 f947 	bl	80010f0 <__aeabi_fcmplt>
 8008e62:	4603      	mov	r3, r0
 8008e64:	2b00      	cmp	r3, #0
 8008e66:	d109      	bne.n	8008e7c <gc_execute_block+0x2c60>
 8008e68:	4b3c      	ldr	r3, [pc, #240]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e6a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008e6c:	f04f 0100 	mov.w	r1, #0
 8008e70:	4618      	mov	r0, r3
 8008e72:	f7f8 f93d 	bl	80010f0 <__aeabi_fcmplt>
 8008e76:	4603      	mov	r3, r0
 8008e78:	2b00      	cmp	r3, #0
 8008e7a:	d002      	beq.n	8008e82 <gc_execute_block+0x2c66>
                    FAIL(Status_NegativeValue);
 8008e7c:	2304      	movs	r3, #4
 8008e7e:	f002 bcc5 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.values.ijk[I_VALUE] == 0.0f ||
 8008e82:	4b36      	ldr	r3, [pc, #216]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008e86:	f04f 0100 	mov.w	r1, #0
 8008e8a:	4618      	mov	r0, r3
 8008e8c:	f7f8 f926 	bl	80010dc <__aeabi_fcmpeq>
 8008e90:	4603      	mov	r3, r0
 8008e92:	2b00      	cmp	r3, #0
 8008e94:	d121      	bne.n	8008eda <gc_execute_block+0x2cbe>
                    gc_block.values.ijk[J_VALUE] == 0.0f ||
 8008e96:	4b31      	ldr	r3, [pc, #196]	; (8008f5c <gc_execute_block+0x2d40>)
 8008e98:	6c1b      	ldr	r3, [r3, #64]	; 0x40
                if(gc_block.values.ijk[I_VALUE] == 0.0f ||
 8008e9a:	f04f 0100 	mov.w	r1, #0
 8008e9e:	4618      	mov	r0, r3
 8008ea0:	f7f8 f91c 	bl	80010dc <__aeabi_fcmpeq>
 8008ea4:	4603      	mov	r3, r0
 8008ea6:	2b00      	cmp	r3, #0
 8008ea8:	d117      	bne.n	8008eda <gc_execute_block+0x2cbe>
                     gc_block.values.ijk[K_VALUE] <= gc_block.values.ijk[J_VALUE] ||
 8008eaa:	4b2c      	ldr	r3, [pc, #176]	; (8008f5c <gc_execute_block+0x2d40>)
 8008eac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008eae:	4a2b      	ldr	r2, [pc, #172]	; (8008f5c <gc_execute_block+0x2d40>)
 8008eb0:	6c12      	ldr	r2, [r2, #64]	; 0x40
                    gc_block.values.ijk[J_VALUE] == 0.0f ||
 8008eb2:	4611      	mov	r1, r2
 8008eb4:	4618      	mov	r0, r3
 8008eb6:	f7f8 f925 	bl	8001104 <__aeabi_fcmple>
 8008eba:	4603      	mov	r3, r0
 8008ebc:	2b00      	cmp	r3, #0
 8008ebe:	d10c      	bne.n	8008eda <gc_execute_block+0x2cbe>
                      (gc_block.words.l && (gc_taper_type)gc_block.values.l > Taper_Both))
 8008ec0:	4b26      	ldr	r3, [pc, #152]	; (8008f5c <gc_execute_block+0x2d40>)
 8008ec2:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8008ec6:	f003 0310 	and.w	r3, r3, #16
 8008eca:	b2db      	uxtb	r3, r3
                     gc_block.values.ijk[K_VALUE] <= gc_block.values.ijk[J_VALUE] ||
 8008ecc:	2b00      	cmp	r3, #0
 8008ece:	d007      	beq.n	8008ee0 <gc_execute_block+0x2cc4>
                      (gc_block.words.l && (gc_taper_type)gc_block.values.l > Taper_Both))
 8008ed0:	4b22      	ldr	r3, [pc, #136]	; (8008f5c <gc_execute_block+0x2d40>)
 8008ed2:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8008ed6:	2b03      	cmp	r3, #3
 8008ed8:	d902      	bls.n	8008ee0 <gc_execute_block+0x2cc4>
                    FAIL(Status_GcodeValueOutOfRange);
 8008eda:	2327      	movs	r3, #39	; 0x27
 8008edc:	f002 bc96 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_state.spindle.rpm < gc_state.spindle.hal->rpm_min || gc_state.spindle.rpm > gc_state.spindle.hal->rpm_max)
 8008ee0:	4b1f      	ldr	r3, [pc, #124]	; (8008f60 <gc_execute_block+0x2d44>)
 8008ee2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008ee4:	4b1e      	ldr	r3, [pc, #120]	; (8008f60 <gc_execute_block+0x2d44>)
 8008ee6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008ee8:	695b      	ldr	r3, [r3, #20]
 8008eea:	4619      	mov	r1, r3
 8008eec:	4610      	mov	r0, r2
 8008eee:	f7f8 f8ff 	bl	80010f0 <__aeabi_fcmplt>
 8008ef2:	4603      	mov	r3, r0
 8008ef4:	2b00      	cmp	r3, #0
 8008ef6:	d10b      	bne.n	8008f10 <gc_execute_block+0x2cf4>
 8008ef8:	4b19      	ldr	r3, [pc, #100]	; (8008f60 <gc_execute_block+0x2d44>)
 8008efa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008efc:	4b18      	ldr	r3, [pc, #96]	; (8008f60 <gc_execute_block+0x2d44>)
 8008efe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008f00:	699b      	ldr	r3, [r3, #24]
 8008f02:	4619      	mov	r1, r3
 8008f04:	4610      	mov	r0, r2
 8008f06:	f7f8 f911 	bl	800112c <__aeabi_fcmpgt>
 8008f0a:	4603      	mov	r3, r0
 8008f0c:	2b00      	cmp	r3, #0
 8008f0e:	d002      	beq.n	8008f16 <gc_execute_block+0x2cfa>
                    FAIL(Status_GcodeRPMOutOfRange);
 8008f10:	232c      	movs	r3, #44	; 0x2c
 8008f12:	f002 bc7b 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.modal.motion != gc_state.modal.motion) {
 8008f16:	4b11      	ldr	r3, [pc, #68]	; (8008f5c <gc_execute_block+0x2d40>)
 8008f18:	891a      	ldrh	r2, [r3, #8]
 8008f1a:	4b11      	ldr	r3, [pc, #68]	; (8008f60 <gc_execute_block+0x2d44>)
 8008f1c:	881b      	ldrh	r3, [r3, #0]
 8008f1e:	429a      	cmp	r2, r3
 8008f20:	d008      	beq.n	8008f34 <gc_execute_block+0x2d18>
                    memset(&thread, 0, sizeof(gc_thread_data));
 8008f22:	2230      	movs	r2, #48	; 0x30
 8008f24:	2100      	movs	r1, #0
 8008f26:	480f      	ldr	r0, [pc, #60]	; (8008f64 <gc_execute_block+0x2d48>)
 8008f28:	f01a fe75 	bl	8023c16 <memset>
                    thread.depth_degression = 1.0f;
 8008f2c:	4b0d      	ldr	r3, [pc, #52]	; (8008f64 <gc_execute_block+0x2d48>)
 8008f2e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8008f32:	615a      	str	r2, [r3, #20]
                }

                thread.pitch = gc_block.values.p;
 8008f34:	4b09      	ldr	r3, [pc, #36]	; (8008f5c <gc_execute_block+0x2d40>)
 8008f36:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008f38:	4a0a      	ldr	r2, [pc, #40]	; (8008f64 <gc_execute_block+0x2d48>)
 8008f3a:	6013      	str	r3, [r2, #0]
                thread.z_final = gc_block.values.xyz[Z_AXIS];
 8008f3c:	4b07      	ldr	r3, [pc, #28]	; (8008f5c <gc_execute_block+0x2d40>)
 8008f3e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8008f40:	4a08      	ldr	r2, [pc, #32]	; (8008f64 <gc_execute_block+0x2d48>)
 8008f42:	6053      	str	r3, [r2, #4]
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 8008f44:	4b05      	ldr	r3, [pc, #20]	; (8008f5c <gc_execute_block+0x2d40>)
 8008f46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008f48:	f04f 0100 	mov.w	r1, #0
 8008f4c:	4618      	mov	r0, r3
 8008f4e:	f7f8 f8cf 	bl	80010f0 <__aeabi_fcmplt>
 8008f52:	4603      	mov	r3, r0
 8008f54:	2b00      	cmp	r3, #0
 8008f56:	d009      	beq.n	8008f6c <gc_execute_block+0x2d50>
 8008f58:	4b03      	ldr	r3, [pc, #12]	; (8008f68 <gc_execute_block+0x2d4c>)
 8008f5a:	e009      	b.n	8008f70 <gc_execute_block+0x2d54>
 8008f5c:	20000c8c 	.word	0x20000c8c
 8008f60:	20000bb0 	.word	0x20000bb0
 8008f64:	20000c44 	.word	0x20000c44
 8008f68:	bf800000 	.word	0xbf800000
 8008f6c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8008f70:	4a7e      	ldr	r2, [pc, #504]	; (800916c <gc_execute_block+0x2f50>)
 8008f72:	6253      	str	r3, [r2, #36]	; 0x24
                thread.peak = fabsf(gc_block.values.ijk[I_VALUE]);
 8008f74:	4b7e      	ldr	r3, [pc, #504]	; (8009170 <gc_execute_block+0x2f54>)
 8008f76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008f78:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8008f7c:	4a7b      	ldr	r2, [pc, #492]	; (800916c <gc_execute_block+0x2f50>)
 8008f7e:	6093      	str	r3, [r2, #8]
                thread.initial_depth = gc_block.values.ijk[J_VALUE];
 8008f80:	4b7b      	ldr	r3, [pc, #492]	; (8009170 <gc_execute_block+0x2f54>)
 8008f82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008f84:	4a79      	ldr	r2, [pc, #484]	; (800916c <gc_execute_block+0x2f50>)
 8008f86:	60d3      	str	r3, [r2, #12]
                thread.depth = gc_block.values.ijk[K_VALUE];
 8008f88:	4b79      	ldr	r3, [pc, #484]	; (8009170 <gc_execute_block+0x2f54>)
 8008f8a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008f8c:	4a77      	ldr	r2, [pc, #476]	; (800916c <gc_execute_block+0x2f50>)
 8008f8e:	6113      	str	r3, [r2, #16]

                if(gc_block.modal.units_imperial) {
 8008f90:	4b77      	ldr	r3, [pc, #476]	; (8009170 <gc_execute_block+0x2f54>)
 8008f92:	7adb      	ldrb	r3, [r3, #11]
 8008f94:	2b00      	cmp	r3, #0
 8008f96:	d01d      	beq.n	8008fd4 <gc_execute_block+0x2db8>
                    thread.peak *= MM_PER_INCH;
 8008f98:	4b74      	ldr	r3, [pc, #464]	; (800916c <gc_execute_block+0x2f50>)
 8008f9a:	689b      	ldr	r3, [r3, #8]
 8008f9c:	4975      	ldr	r1, [pc, #468]	; (8009174 <gc_execute_block+0x2f58>)
 8008f9e:	4618      	mov	r0, r3
 8008fa0:	f7f7 ff08 	bl	8000db4 <__aeabi_fmul>
 8008fa4:	4603      	mov	r3, r0
 8008fa6:	461a      	mov	r2, r3
 8008fa8:	4b70      	ldr	r3, [pc, #448]	; (800916c <gc_execute_block+0x2f50>)
 8008faa:	609a      	str	r2, [r3, #8]
                    thread.initial_depth *= MM_PER_INCH;
 8008fac:	4b6f      	ldr	r3, [pc, #444]	; (800916c <gc_execute_block+0x2f50>)
 8008fae:	68db      	ldr	r3, [r3, #12]
 8008fb0:	4970      	ldr	r1, [pc, #448]	; (8009174 <gc_execute_block+0x2f58>)
 8008fb2:	4618      	mov	r0, r3
 8008fb4:	f7f7 fefe 	bl	8000db4 <__aeabi_fmul>
 8008fb8:	4603      	mov	r3, r0
 8008fba:	461a      	mov	r2, r3
 8008fbc:	4b6b      	ldr	r3, [pc, #428]	; (800916c <gc_execute_block+0x2f50>)
 8008fbe:	60da      	str	r2, [r3, #12]
                    thread.depth *= MM_PER_INCH;
 8008fc0:	4b6a      	ldr	r3, [pc, #424]	; (800916c <gc_execute_block+0x2f50>)
 8008fc2:	691b      	ldr	r3, [r3, #16]
 8008fc4:	496b      	ldr	r1, [pc, #428]	; (8009174 <gc_execute_block+0x2f58>)
 8008fc6:	4618      	mov	r0, r3
 8008fc8:	f7f7 fef4 	bl	8000db4 <__aeabi_fmul>
 8008fcc:	4603      	mov	r3, r0
 8008fce:	461a      	mov	r2, r3
 8008fd0:	4b66      	ldr	r3, [pc, #408]	; (800916c <gc_execute_block+0x2f50>)
 8008fd2:	611a      	str	r2, [r3, #16]
                }

                if(gc_block.modal.diameter_mode) {
 8008fd4:	4b66      	ldr	r3, [pc, #408]	; (8009170 <gc_execute_block+0x2f54>)
 8008fd6:	7b5b      	ldrb	r3, [r3, #13]
 8008fd8:	2b00      	cmp	r3, #0
 8008fda:	d020      	beq.n	800901e <gc_execute_block+0x2e02>
                    thread.peak /= 2.0f;
 8008fdc:	4b63      	ldr	r3, [pc, #396]	; (800916c <gc_execute_block+0x2f50>)
 8008fde:	689b      	ldr	r3, [r3, #8]
 8008fe0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8008fe4:	4618      	mov	r0, r3
 8008fe6:	f7f7 ff99 	bl	8000f1c <__aeabi_fdiv>
 8008fea:	4603      	mov	r3, r0
 8008fec:	461a      	mov	r2, r3
 8008fee:	4b5f      	ldr	r3, [pc, #380]	; (800916c <gc_execute_block+0x2f50>)
 8008ff0:	609a      	str	r2, [r3, #8]
                    thread.initial_depth /= 2.0f;
 8008ff2:	4b5e      	ldr	r3, [pc, #376]	; (800916c <gc_execute_block+0x2f50>)
 8008ff4:	68db      	ldr	r3, [r3, #12]
 8008ff6:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8008ffa:	4618      	mov	r0, r3
 8008ffc:	f7f7 ff8e 	bl	8000f1c <__aeabi_fdiv>
 8009000:	4603      	mov	r3, r0
 8009002:	461a      	mov	r2, r3
 8009004:	4b59      	ldr	r3, [pc, #356]	; (800916c <gc_execute_block+0x2f50>)
 8009006:	60da      	str	r2, [r3, #12]
                    thread.depth /= 2.0f;
 8009008:	4b58      	ldr	r3, [pc, #352]	; (800916c <gc_execute_block+0x2f50>)
 800900a:	691b      	ldr	r3, [r3, #16]
 800900c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8009010:	4618      	mov	r0, r3
 8009012:	f7f7 ff83 	bl	8000f1c <__aeabi_fdiv>
 8009016:	4603      	mov	r3, r0
 8009018:	461a      	mov	r2, r3
 800901a:	4b54      	ldr	r3, [pc, #336]	; (800916c <gc_execute_block+0x2f50>)
 800901c:	611a      	str	r2, [r3, #16]
                }

                //scaling?

                if(axis_words.x) {
 800901e:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009022:	f003 0301 	and.w	r3, r3, #1
 8009026:	b2db      	uxtb	r3, r3
 8009028:	2b00      	cmp	r3, #0
 800902a:	d036      	beq.n	800909a <gc_execute_block+0x2e7e>
                    thread.main_taper_height = gc_block.values.xyz[X_AXIS] - gc_get_block_offset(&gc_block, X_AXIS);
 800902c:	4b50      	ldr	r3, [pc, #320]	; (8009170 <gc_execute_block+0x2f54>)
 800902e:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8009030:	2100      	movs	r1, #0
 8009032:	484f      	ldr	r0, [pc, #316]	; (8009170 <gc_execute_block+0x2f54>)
 8009034:	f7fc fcf6 	bl	8005a24 <gc_get_block_offset>
 8009038:	4603      	mov	r3, r0
 800903a:	4619      	mov	r1, r3
 800903c:	4620      	mov	r0, r4
 800903e:	f7f7 fdaf 	bl	8000ba0 <__aeabi_fsub>
 8009042:	4603      	mov	r3, r0
 8009044:	461a      	mov	r2, r3
 8009046:	4b49      	ldr	r3, [pc, #292]	; (800916c <gc_execute_block+0x2f50>)
 8009048:	619a      	str	r2, [r3, #24]
                    gc_block.values.p = fabsf(thread.z_final - gc_state.position[Z_AXIS]);
 800904a:	4b48      	ldr	r3, [pc, #288]	; (800916c <gc_execute_block+0x2f50>)
 800904c:	685b      	ldr	r3, [r3, #4]
 800904e:	4a4a      	ldr	r2, [pc, #296]	; (8009178 <gc_execute_block+0x2f5c>)
 8009050:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8009052:	4611      	mov	r1, r2
 8009054:	4618      	mov	r0, r3
 8009056:	f7f7 fda3 	bl	8000ba0 <__aeabi_fsub>
 800905a:	4603      	mov	r3, r0
 800905c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009060:	4a43      	ldr	r2, [pc, #268]	; (8009170 <gc_execute_block+0x2f54>)
 8009062:	6513      	str	r3, [r2, #80]	; 0x50
                    thread.pitch = thread.pitch * hypot_f(thread.main_taper_height, gc_block.values.p) / gc_block.values.p;
 8009064:	4b41      	ldr	r3, [pc, #260]	; (800916c <gc_execute_block+0x2f50>)
 8009066:	681c      	ldr	r4, [r3, #0]
 8009068:	4b40      	ldr	r3, [pc, #256]	; (800916c <gc_execute_block+0x2f50>)
 800906a:	699b      	ldr	r3, [r3, #24]
 800906c:	4a40      	ldr	r2, [pc, #256]	; (8009170 <gc_execute_block+0x2f54>)
 800906e:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009070:	4611      	mov	r1, r2
 8009072:	4618      	mov	r0, r3
 8009074:	f7fc fc02 	bl	800587c <hypot_f>
 8009078:	4603      	mov	r3, r0
 800907a:	4619      	mov	r1, r3
 800907c:	4620      	mov	r0, r4
 800907e:	f7f7 fe99 	bl	8000db4 <__aeabi_fmul>
 8009082:	4603      	mov	r3, r0
 8009084:	461a      	mov	r2, r3
 8009086:	4b3a      	ldr	r3, [pc, #232]	; (8009170 <gc_execute_block+0x2f54>)
 8009088:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800908a:	4619      	mov	r1, r3
 800908c:	4610      	mov	r0, r2
 800908e:	f7f7 ff45 	bl	8000f1c <__aeabi_fdiv>
 8009092:	4603      	mov	r3, r0
 8009094:	461a      	mov	r2, r3
 8009096:	4b35      	ldr	r3, [pc, #212]	; (800916c <gc_execute_block+0x2f50>)
 8009098:	601a      	str	r2, [r3, #0]
                }

                if(gc_block.words.h)
 800909a:	4b35      	ldr	r3, [pc, #212]	; (8009170 <gc_execute_block+0x2f54>)
 800909c:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80090a0:	f003 0308 	and.w	r3, r3, #8
 80090a4:	b2db      	uxtb	r3, r3
 80090a6:	2b00      	cmp	r3, #0
 80090a8:	d004      	beq.n	80090b4 <gc_execute_block+0x2e98>
                    thread.spring_passes = (uint_fast16_t)gc_block.values.h;
 80090aa:	4b31      	ldr	r3, [pc, #196]	; (8009170 <gc_execute_block+0x2f54>)
 80090ac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80090b0:	4a2e      	ldr	r2, [pc, #184]	; (800916c <gc_execute_block+0x2f50>)
 80090b2:	6293      	str	r3, [r2, #40]	; 0x28

                if(gc_block.words.l)
 80090b4:	4b2e      	ldr	r3, [pc, #184]	; (8009170 <gc_execute_block+0x2f54>)
 80090b6:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80090ba:	f003 0310 	and.w	r3, r3, #16
 80090be:	b2db      	uxtb	r3, r3
 80090c0:	2b00      	cmp	r3, #0
 80090c2:	d005      	beq.n	80090d0 <gc_execute_block+0x2eb4>
                    thread.end_taper_type = (gc_taper_type)gc_block.values.l;
 80090c4:	4b2a      	ldr	r3, [pc, #168]	; (8009170 <gc_execute_block+0x2f54>)
 80090c6:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
 80090ca:	4b28      	ldr	r3, [pc, #160]	; (800916c <gc_execute_block+0x2f50>)
 80090cc:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

                if(gc_block.words.e)
 80090d0:	4b27      	ldr	r3, [pc, #156]	; (8009170 <gc_execute_block+0x2f54>)
 80090d2:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80090d6:	f003 0301 	and.w	r3, r3, #1
 80090da:	b2db      	uxtb	r3, r3
 80090dc:	2b00      	cmp	r3, #0
 80090de:	d003      	beq.n	80090e8 <gc_execute_block+0x2ecc>
                    thread.end_taper_length = gc_block.values.e;
 80090e0:	4b23      	ldr	r3, [pc, #140]	; (8009170 <gc_execute_block+0x2f54>)
 80090e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80090e4:	4a21      	ldr	r2, [pc, #132]	; (800916c <gc_execute_block+0x2f50>)
 80090e6:	61d3      	str	r3, [r2, #28]

                if(thread.end_taper_length <= 0.0f || thread.end_taper_type == Taper_None) {
 80090e8:	4b20      	ldr	r3, [pc, #128]	; (800916c <gc_execute_block+0x2f50>)
 80090ea:	69db      	ldr	r3, [r3, #28]
 80090ec:	f04f 0100 	mov.w	r1, #0
 80090f0:	4618      	mov	r0, r3
 80090f2:	f7f8 f807 	bl	8001104 <__aeabi_fcmple>
 80090f6:	4603      	mov	r3, r0
 80090f8:	2b00      	cmp	r3, #0
 80090fa:	d104      	bne.n	8009106 <gc_execute_block+0x2eea>
 80090fc:	4b1b      	ldr	r3, [pc, #108]	; (800916c <gc_execute_block+0x2f50>)
 80090fe:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8009102:	2b00      	cmp	r3, #0
 8009104:	d107      	bne.n	8009116 <gc_execute_block+0x2efa>
                    thread.end_taper_length = 0.0f;
 8009106:	4b19      	ldr	r3, [pc, #100]	; (800916c <gc_execute_block+0x2f50>)
 8009108:	f04f 0200 	mov.w	r2, #0
 800910c:	61da      	str	r2, [r3, #28]
                    thread.end_taper_type = Taper_None;
 800910e:	4b17      	ldr	r3, [pc, #92]	; (800916c <gc_execute_block+0x2f50>)
 8009110:	2200      	movs	r2, #0
 8009112:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
                    // TODO: fail?
                }

                if(thread.end_taper_type != Taper_None && thread.end_taper_length > abs(thread.z_final - gc_state.position[Z_AXIS]) / 2.0f)
 8009116:	4b15      	ldr	r3, [pc, #84]	; (800916c <gc_execute_block+0x2f50>)
 8009118:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800911c:	2b00      	cmp	r3, #0
 800911e:	d02d      	beq.n	800917c <gc_execute_block+0x2f60>
 8009120:	4b12      	ldr	r3, [pc, #72]	; (800916c <gc_execute_block+0x2f50>)
 8009122:	69dc      	ldr	r4, [r3, #28]
 8009124:	4b11      	ldr	r3, [pc, #68]	; (800916c <gc_execute_block+0x2f50>)
 8009126:	685b      	ldr	r3, [r3, #4]
 8009128:	4a13      	ldr	r2, [pc, #76]	; (8009178 <gc_execute_block+0x2f5c>)
 800912a:	6e52      	ldr	r2, [r2, #100]	; 0x64
 800912c:	4611      	mov	r1, r2
 800912e:	4618      	mov	r0, r3
 8009130:	f7f7 fd36 	bl	8000ba0 <__aeabi_fsub>
 8009134:	4603      	mov	r3, r0
 8009136:	4618      	mov	r0, r3
 8009138:	f7f8 f818 	bl	800116c <__aeabi_f2iz>
 800913c:	4603      	mov	r3, r0
 800913e:	2b00      	cmp	r3, #0
 8009140:	bfb8      	it	lt
 8009142:	425b      	neglt	r3, r3
 8009144:	4618      	mov	r0, r3
 8009146:	f7f7 fde1 	bl	8000d0c <__aeabi_i2f>
 800914a:	4603      	mov	r3, r0
 800914c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8009150:	4618      	mov	r0, r3
 8009152:	f7f7 fee3 	bl	8000f1c <__aeabi_fdiv>
 8009156:	4603      	mov	r3, r0
 8009158:	4619      	mov	r1, r3
 800915a:	4620      	mov	r0, r4
 800915c:	f7f7 ffe6 	bl	800112c <__aeabi_fcmpgt>
 8009160:	4603      	mov	r3, r0
 8009162:	2b00      	cmp	r3, #0
 8009164:	d00a      	beq.n	800917c <gc_execute_block+0x2f60>
                    FAIL(Status_GcodeValueOutOfRange);
 8009166:	2327      	movs	r3, #39	; 0x27
 8009168:	f002 bb50 	b.w	800b80c <gc_execute_block+0x55f0>
 800916c:	20000c44 	.word	0x20000c44
 8009170:	20000c8c 	.word	0x20000c8c
 8009174:	41cb3333 	.word	0x41cb3333
 8009178:	20000bb0 	.word	0x20000bb0

                if(gc_block.words.r)
 800917c:	4bb5      	ldr	r3, [pc, #724]	; (8009454 <gc_execute_block+0x3238>)
 800917e:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009182:	f003 0304 	and.w	r3, r3, #4
 8009186:	b2db      	uxtb	r3, r3
 8009188:	2b00      	cmp	r3, #0
 800918a:	d003      	beq.n	8009194 <gc_execute_block+0x2f78>
                    thread.depth_degression = gc_block.values.r;
 800918c:	4bb1      	ldr	r3, [pc, #708]	; (8009454 <gc_execute_block+0x3238>)
 800918e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009190:	4ab1      	ldr	r2, [pc, #708]	; (8009458 <gc_execute_block+0x323c>)
 8009192:	6153      	str	r3, [r2, #20]

                if(gc_block.words.q)
 8009194:	4baf      	ldr	r3, [pc, #700]	; (8009454 <gc_execute_block+0x3238>)
 8009196:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800919a:	f003 0302 	and.w	r3, r3, #2
 800919e:	b2db      	uxtb	r3, r3
 80091a0:	2b00      	cmp	r3, #0
 80091a2:	d003      	beq.n	80091ac <gc_execute_block+0x2f90>
                    thread.infeed_angle = gc_block.values.q;
 80091a4:	4bab      	ldr	r3, [pc, #684]	; (8009454 <gc_execute_block+0x3238>)
 80091a6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80091a8:	4aab      	ldr	r2, [pc, #684]	; (8009458 <gc_execute_block+0x323c>)
 80091aa:	6213      	str	r3, [r2, #32]

                // Ensure spindle speed is at 100% - any override will be disabled on execute.
                gc_parser_flags.spindle_force_sync = On;
 80091ac:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80091b0:	f043 0320 	orr.w	r3, r3, #32
 80091b4:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c

                gc_block.words.e = gc_block.words.h = gc_block.words.i = gc_block.words.j = gc_block.words.k = gc_block.words.l = gc_block.words.p = gc_block.words.q = gc_block.words.r = Off;
 80091b8:	4aa6      	ldr	r2, [pc, #664]	; (8009454 <gc_execute_block+0x3238>)
 80091ba:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80091be:	f36f 0382 	bfc	r3, #2, #1
 80091c2:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80091c6:	4ba3      	ldr	r3, [pc, #652]	; (8009454 <gc_execute_block+0x3238>)
 80091c8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80091cc:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80091d0:	b2d9      	uxtb	r1, r3
 80091d2:	4aa0      	ldr	r2, [pc, #640]	; (8009454 <gc_execute_block+0x3238>)
 80091d4:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80091d8:	f361 0341 	bfi	r3, r1, #1, #1
 80091dc:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80091e0:	4b9c      	ldr	r3, [pc, #624]	; (8009454 <gc_execute_block+0x3238>)
 80091e2:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80091e6:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80091ea:	b2d9      	uxtb	r1, r3
 80091ec:	4a99      	ldr	r2, [pc, #612]	; (8009454 <gc_execute_block+0x3238>)
 80091ee:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80091f2:	f361 0300 	bfi	r3, r1, #0, #1
 80091f6:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80091fa:	4b96      	ldr	r3, [pc, #600]	; (8009454 <gc_execute_block+0x3238>)
 80091fc:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009200:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009204:	b2d9      	uxtb	r1, r3
 8009206:	4a93      	ldr	r2, [pc, #588]	; (8009454 <gc_execute_block+0x3238>)
 8009208:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 800920c:	f361 1304 	bfi	r3, r1, #4, #1
 8009210:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 8009214:	4b8f      	ldr	r3, [pc, #572]	; (8009454 <gc_execute_block+0x3238>)
 8009216:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800921a:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800921e:	b2d9      	uxtb	r1, r3
 8009220:	4a8c      	ldr	r2, [pc, #560]	; (8009454 <gc_execute_block+0x3238>)
 8009222:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009226:	f361 1386 	bfi	r3, r1, #6, #1
 800922a:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 800922e:	4b89      	ldr	r3, [pc, #548]	; (8009454 <gc_execute_block+0x3238>)
 8009230:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009234:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009238:	b2d9      	uxtb	r1, r3
 800923a:	4a86      	ldr	r2, [pc, #536]	; (8009454 <gc_execute_block+0x3238>)
 800923c:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009240:	f361 1345 	bfi	r3, r1, #5, #1
 8009244:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009248:	4b82      	ldr	r3, [pc, #520]	; (8009454 <gc_execute_block+0x3238>)
 800924a:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 800924e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009252:	b2d9      	uxtb	r1, r3
 8009254:	4a7f      	ldr	r2, [pc, #508]	; (8009454 <gc_execute_block+0x3238>)
 8009256:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 800925a:	f361 1304 	bfi	r3, r1, #4, #1
 800925e:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009262:	4b7c      	ldr	r3, [pc, #496]	; (8009454 <gc_execute_block+0x3238>)
 8009264:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009268:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800926c:	b2d9      	uxtb	r1, r3
 800926e:	4a79      	ldr	r2, [pc, #484]	; (8009454 <gc_execute_block+0x3238>)
 8009270:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8009274:	f361 03c3 	bfi	r3, r1, #3, #1
 8009278:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 800927c:	4b75      	ldr	r3, [pc, #468]	; (8009454 <gc_execute_block+0x3238>)
 800927e:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8009282:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8009286:	b2d9      	uxtb	r1, r3
 8009288:	4a72      	ldr	r2, [pc, #456]	; (8009454 <gc_execute_block+0x3238>)
 800928a:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 800928e:	f361 0300 	bfi	r3, r1, #0, #1
 8009292:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 8009296:	e00c      	b.n	80092b2 <gc_execute_block+0x3096>

            } else if (gc_block.values.f == 0.0f)
 8009298:	4b6e      	ldr	r3, [pc, #440]	; (8009454 <gc_execute_block+0x3238>)
 800929a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800929c:	f04f 0100 	mov.w	r1, #0
 80092a0:	4618      	mov	r0, r3
 80092a2:	f7f7 ff1b 	bl	80010dc <__aeabi_fcmpeq>
 80092a6:	4603      	mov	r3, r0
 80092a8:	2b00      	cmp	r3, #0
 80092aa:	d002      	beq.n	80092b2 <gc_execute_block+0x3096>
                FAIL(Status_GcodeUndefinedFeedRate); // [Feed rate undefined]
 80092ac:	2316      	movs	r3, #22
 80092ae:	f002 baad 	b.w	800b80c <gc_execute_block+0x55f0>

            if (gc_block.modal.canned_cycle_active) {
 80092b2:	4b68      	ldr	r3, [pc, #416]	; (8009454 <gc_execute_block+0x3238>)
 80092b4:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80092b8:	2b00      	cmp	r3, #0
 80092ba:	f000 81e6 	beq.w	800968a <gc_execute_block+0x346e>

                if(gc_parser_flags.canned_cycle_change) {
 80092be:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80092c2:	f003 0302 	and.w	r3, r3, #2
 80092c6:	b2db      	uxtb	r3, r3
 80092c8:	2b00      	cmp	r3, #0
 80092ca:	d03b      	beq.n	8009344 <gc_execute_block+0x3128>

                    if(gc_state.modal.feed_mode == FeedMode_InverseTime)
 80092cc:	4b63      	ldr	r3, [pc, #396]	; (800945c <gc_execute_block+0x3240>)
 80092ce:	789b      	ldrb	r3, [r3, #2]
 80092d0:	2b01      	cmp	r3, #1
 80092d2:	d102      	bne.n	80092da <gc_execute_block+0x30be>
                        FAIL(Status_InvalidStatement);
 80092d4:	2303      	movs	r3, #3
 80092d6:	f002 ba99 	b.w	800b80c <gc_execute_block+0x55f0>

                    if(!gc_block.words.r)
 80092da:	4b5e      	ldr	r3, [pc, #376]	; (8009454 <gc_execute_block+0x3238>)
 80092dc:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 80092e0:	f003 0304 	and.w	r3, r3, #4
 80092e4:	b2db      	uxtb	r3, r3
 80092e6:	2b00      	cmp	r3, #0
 80092e8:	d102      	bne.n	80092f0 <gc_execute_block+0x30d4>
                        FAIL(Status_GcodeValueWordMissing);
 80092ea:	231c      	movs	r3, #28
 80092ec:	f002 ba8e 	b.w	800b80c <gc_execute_block+0x55f0>

                    if(!(axis_words.mask & bit(plane.axis_linear)))
 80092f0:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80092f4:	461a      	mov	r2, r3
 80092f6:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 80092fa:	fa22 f303 	lsr.w	r3, r2, r3
 80092fe:	f003 0301 	and.w	r3, r3, #1
 8009302:	2b00      	cmp	r3, #0
 8009304:	d102      	bne.n	800930c <gc_execute_block+0x30f0>
                        FAIL(Status_GcodeValueWordMissing);
 8009306:	231c      	movs	r3, #28
 8009308:	f002 ba80 	b.w	800b80c <gc_execute_block+0x55f0>

                    gc_state.canned.dwell = 0.0f;
 800930c:	4b53      	ldr	r3, [pc, #332]	; (800945c <gc_execute_block+0x3240>)
 800930e:	f04f 0200 	mov.w	r2, #0
 8009312:	639a      	str	r2, [r3, #56]	; 0x38
                    gc_state.canned.xyz[plane.axis_0] = 0.0f;
 8009314:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 8009318:	4a50      	ldr	r2, [pc, #320]	; (800945c <gc_execute_block+0x3240>)
 800931a:	330a      	adds	r3, #10
 800931c:	f04f 0100 	mov.w	r1, #0
 8009320:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    gc_state.canned.xyz[plane.axis_1] = 0.0f;
 8009324:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009328:	4a4c      	ldr	r2, [pc, #304]	; (800945c <gc_execute_block+0x3240>)
 800932a:	330a      	adds	r3, #10
 800932c:	f04f 0100 	mov.w	r1, #0
 8009330:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    gc_state.canned.rapid_retract = On;
 8009334:	4b49      	ldr	r3, [pc, #292]	; (800945c <gc_execute_block+0x3240>)
 8009336:	2201      	movs	r2, #1
 8009338:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                    gc_state.canned.spindle_off = Off;
 800933c:	4b47      	ldr	r3, [pc, #284]	; (800945c <gc_execute_block+0x3240>)
 800933e:	2200      	movs	r2, #0
 8009340:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
                }

                if(!gc_block.words.l)
 8009344:	4b43      	ldr	r3, [pc, #268]	; (8009454 <gc_execute_block+0x3238>)
 8009346:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800934a:	f003 0310 	and.w	r3, r3, #16
 800934e:	b2db      	uxtb	r3, r3
 8009350:	2b00      	cmp	r3, #0
 8009352:	d104      	bne.n	800935e <gc_execute_block+0x3142>
                    gc_block.values.l = 1;
 8009354:	4b3f      	ldr	r3, [pc, #252]	; (8009454 <gc_execute_block+0x3238>)
 8009356:	2201      	movs	r2, #1
 8009358:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
 800935c:	e007      	b.n	800936e <gc_execute_block+0x3152>
                else if(gc_block.values.l <= 0)
 800935e:	4b3d      	ldr	r3, [pc, #244]	; (8009454 <gc_execute_block+0x3238>)
 8009360:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 8009364:	2b00      	cmp	r3, #0
 8009366:	d102      	bne.n	800936e <gc_execute_block+0x3152>
                    FAIL(Status_NonPositiveValue); // [L <= 0]
 8009368:	2313      	movs	r3, #19
 800936a:	f002 ba4f 	b.w	800b80c <gc_execute_block+0x55f0>

                if(gc_block.words.r)
 800936e:	4b39      	ldr	r3, [pc, #228]	; (8009454 <gc_execute_block+0x3238>)
 8009370:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009374:	f003 0304 	and.w	r3, r3, #4
 8009378:	b2db      	uxtb	r3, r3
 800937a:	2b00      	cmp	r3, #0
 800937c:	d02a      	beq.n	80093d4 <gc_execute_block+0x31b8>
                    gc_state.canned.retract_position = gc_block.values.r * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f) +
 800937e:	4b35      	ldr	r3, [pc, #212]	; (8009454 <gc_execute_block+0x3238>)
 8009380:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8009382:	4b34      	ldr	r3, [pc, #208]	; (8009454 <gc_execute_block+0x3238>)
 8009384:	7adb      	ldrb	r3, [r3, #11]
 8009386:	2b00      	cmp	r3, #0
 8009388:	d001      	beq.n	800938e <gc_execute_block+0x3172>
 800938a:	4b35      	ldr	r3, [pc, #212]	; (8009460 <gc_execute_block+0x3244>)
 800938c:	e001      	b.n	8009392 <gc_execute_block+0x3176>
 800938e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8009392:	4611      	mov	r1, r2
 8009394:	4618      	mov	r0, r3
 8009396:	f7f7 fd0d 	bl	8000db4 <__aeabi_fmul>
 800939a:	4603      	mov	r3, r0
 800939c:	461c      	mov	r4, r3
                                                        (gc_block.modal.distance_incremental
 800939e:	4b2d      	ldr	r3, [pc, #180]	; (8009454 <gc_execute_block+0x3238>)
 80093a0:	7b1b      	ldrb	r3, [r3, #12]
                                                          ? gc_state.position[plane.axis_linear]
                                                          : gc_get_block_offset(&gc_block, plane.axis_linear));
 80093a2:	2b00      	cmp	r3, #0
 80093a4:	d007      	beq.n	80093b6 <gc_execute_block+0x319a>
                                                          ? gc_state.position[plane.axis_linear]
 80093a6:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
                                                          : gc_get_block_offset(&gc_block, plane.axis_linear));
 80093aa:	4a2c      	ldr	r2, [pc, #176]	; (800945c <gc_execute_block+0x3240>)
 80093ac:	3316      	adds	r3, #22
 80093ae:	009b      	lsls	r3, r3, #2
 80093b0:	4413      	add	r3, r2
 80093b2:	685b      	ldr	r3, [r3, #4]
 80093b4:	e006      	b.n	80093c4 <gc_execute_block+0x31a8>
 80093b6:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 80093ba:	4619      	mov	r1, r3
 80093bc:	4825      	ldr	r0, [pc, #148]	; (8009454 <gc_execute_block+0x3238>)
 80093be:	f7fc fb31 	bl	8005a24 <gc_get_block_offset>
 80093c2:	4603      	mov	r3, r0
                    gc_state.canned.retract_position = gc_block.values.r * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f) +
 80093c4:	4621      	mov	r1, r4
 80093c6:	4618      	mov	r0, r3
 80093c8:	f7f7 fbec 	bl	8000ba4 <__addsf3>
 80093cc:	4603      	mov	r3, r0
 80093ce:	461a      	mov	r2, r3
 80093d0:	4b22      	ldr	r3, [pc, #136]	; (800945c <gc_execute_block+0x3240>)
 80093d2:	63da      	str	r2, [r3, #60]	; 0x3c

                idx = N_AXIS;
 80093d4:	2303      	movs	r3, #3
 80093d6:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                do {
                    if(bit_istrue(axis_words.mask, bit(--idx))) {
 80093da:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80093de:	461a      	mov	r2, r3
 80093e0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80093e4:	3b01      	subs	r3, #1
 80093e6:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 80093ea:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80093ee:	fa22 f303 	lsr.w	r3, r2, r3
 80093f2:	f003 0301 	and.w	r3, r3, #1
 80093f6:	2b00      	cmp	r3, #0
 80093f8:	d058      	beq.n	80094ac <gc_execute_block+0x3290>
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 80093fa:	4a16      	ldr	r2, [pc, #88]	; (8009454 <gc_execute_block+0x3238>)
 80093fc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009400:	3318      	adds	r3, #24
 8009402:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8009406:	4915      	ldr	r1, [pc, #84]	; (800945c <gc_execute_block+0x3240>)
 8009408:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800940c:	330a      	adds	r3, #10
 800940e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                        if(idx != plane.axis_linear)
 8009412:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 8009416:	461a      	mov	r2, r3
 8009418:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800941c:	4293      	cmp	r3, r2
 800941e:	d021      	beq.n	8009464 <gc_execute_block+0x3248>
                            gc_state.canned.xyz[idx] -= gc_state.position[idx];
 8009420:	4a0e      	ldr	r2, [pc, #56]	; (800945c <gc_execute_block+0x3240>)
 8009422:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009426:	330a      	adds	r3, #10
 8009428:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800942c:	490b      	ldr	r1, [pc, #44]	; (800945c <gc_execute_block+0x3240>)
 800942e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009432:	3316      	adds	r3, #22
 8009434:	009b      	lsls	r3, r3, #2
 8009436:	440b      	add	r3, r1
 8009438:	685b      	ldr	r3, [r3, #4]
 800943a:	4619      	mov	r1, r3
 800943c:	4610      	mov	r0, r2
 800943e:	f7f7 fbaf 	bl	8000ba0 <__aeabi_fsub>
 8009442:	4603      	mov	r3, r0
 8009444:	4619      	mov	r1, r3
 8009446:	4a05      	ldr	r2, [pc, #20]	; (800945c <gc_execute_block+0x3240>)
 8009448:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800944c:	330a      	adds	r3, #10
 800944e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8009452:	e02b      	b.n	80094ac <gc_execute_block+0x3290>
 8009454:	20000c8c 	.word	0x20000c8c
 8009458:	20000c44 	.word	0x20000c44
 800945c:	20000bb0 	.word	0x20000bb0
 8009460:	41cb3333 	.word	0x41cb3333
                        else if(gc_block.modal.distance_incremental)
 8009464:	4bb9      	ldr	r3, [pc, #740]	; (800974c <gc_execute_block+0x3530>)
 8009466:	7b1b      	ldrb	r3, [r3, #12]
 8009468:	2b00      	cmp	r3, #0
 800946a:	d01f      	beq.n	80094ac <gc_execute_block+0x3290>
                            gc_state.canned.xyz[idx] = gc_state.canned.retract_position + (gc_state.canned.xyz[idx] - gc_state.position[idx]);
 800946c:	4bb8      	ldr	r3, [pc, #736]	; (8009750 <gc_execute_block+0x3534>)
 800946e:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8009470:	4ab7      	ldr	r2, [pc, #732]	; (8009750 <gc_execute_block+0x3534>)
 8009472:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009476:	330a      	adds	r3, #10
 8009478:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800947c:	49b4      	ldr	r1, [pc, #720]	; (8009750 <gc_execute_block+0x3534>)
 800947e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009482:	3316      	adds	r3, #22
 8009484:	009b      	lsls	r3, r3, #2
 8009486:	440b      	add	r3, r1
 8009488:	685b      	ldr	r3, [r3, #4]
 800948a:	4619      	mov	r1, r3
 800948c:	4610      	mov	r0, r2
 800948e:	f7f7 fb87 	bl	8000ba0 <__aeabi_fsub>
 8009492:	4603      	mov	r3, r0
 8009494:	4619      	mov	r1, r3
 8009496:	4620      	mov	r0, r4
 8009498:	f7f7 fb84 	bl	8000ba4 <__addsf3>
 800949c:	4603      	mov	r3, r0
 800949e:	4619      	mov	r1, r3
 80094a0:	4aab      	ldr	r2, [pc, #684]	; (8009750 <gc_execute_block+0x3534>)
 80094a2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80094a6:	330a      	adds	r3, #10
 80094a8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    }
                } while(idx);
 80094ac:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 80094b0:	2b00      	cmp	r3, #0
 80094b2:	d192      	bne.n	80093da <gc_execute_block+0x31be>

                if(gc_state.canned.retract_position < gc_state.canned.xyz[plane.axis_linear])
 80094b4:	4ba6      	ldr	r3, [pc, #664]	; (8009750 <gc_execute_block+0x3534>)
 80094b6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80094b8:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 80094bc:	49a4      	ldr	r1, [pc, #656]	; (8009750 <gc_execute_block+0x3534>)
 80094be:	330a      	adds	r3, #10
 80094c0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80094c4:	4619      	mov	r1, r3
 80094c6:	4610      	mov	r0, r2
 80094c8:	f7f7 fe12 	bl	80010f0 <__aeabi_fcmplt>
 80094cc:	4603      	mov	r3, r0
 80094ce:	2b00      	cmp	r3, #0
 80094d0:	d002      	beq.n	80094d8 <gc_execute_block+0x32bc>
                    FAIL(Status_GcodeInvalidRetractPosition);
 80094d2:	2336      	movs	r3, #54	; 0x36
 80094d4:	f002 b99a 	b.w	800b80c <gc_execute_block+0x55f0>

                gc_block.words.r = gc_block.words.l = Off; // Remove single-meaning value words.
 80094d8:	4a9c      	ldr	r2, [pc, #624]	; (800974c <gc_execute_block+0x3530>)
 80094da:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 80094de:	f36f 1304 	bfc	r3, #4, #1
 80094e2:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 80094e6:	4b99      	ldr	r3, [pc, #612]	; (800974c <gc_execute_block+0x3530>)
 80094e8:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80094ec:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80094f0:	b2d9      	uxtb	r1, r3
 80094f2:	4a96      	ldr	r2, [pc, #600]	; (800974c <gc_execute_block+0x3530>)
 80094f4:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80094f8:	f361 0382 	bfi	r3, r1, #2, #1
 80094fc:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96

                switch (gc_block.modal.motion) {
 8009500:	4b92      	ldr	r3, [pc, #584]	; (800974c <gc_execute_block+0x3530>)
 8009502:	891b      	ldrh	r3, [r3, #8]
 8009504:	3b49      	subs	r3, #73	; 0x49
 8009506:	2b10      	cmp	r3, #16
 8009508:	f200 8549 	bhi.w	8009f9e <gc_execute_block+0x3d82>
 800950c:	a201      	add	r2, pc, #4	; (adr r2, 8009514 <gc_execute_block+0x32f8>)
 800950e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009512:	bf00      	nop
 8009514:	0800960d 	.word	0x0800960d
 8009518:	08009f9f 	.word	0x08009f9f
 800951c:	08009f9f 	.word	0x08009f9f
 8009520:	08009f9f 	.word	0x08009f9f
 8009524:	08009f9f 	.word	0x08009f9f
 8009528:	08009f9f 	.word	0x08009f9f
 800952c:	08009f9f 	.word	0x08009f9f
 8009530:	08009f9f 	.word	0x08009f9f
 8009534:	080095d7 	.word	0x080095d7
 8009538:	08009581 	.word	0x08009581
 800953c:	0800960d 	.word	0x0800960d
 8009540:	08009f9f 	.word	0x08009f9f
 8009544:	080095d7 	.word	0x080095d7
 8009548:	08009559 	.word	0x08009559
 800954c:	08009f9f 	.word	0x08009f9f
 8009550:	08009f9f 	.word	0x08009f9f
 8009554:	08009559 	.word	0x08009559

                    case MotionMode_CannedCycle86:
                    case MotionMode_CannedCycle89:
                        gc_state.canned.spindle_off = gc_block.modal.motion == MotionMode_CannedCycle86;
 8009558:	4b7c      	ldr	r3, [pc, #496]	; (800974c <gc_execute_block+0x3530>)
 800955a:	891b      	ldrh	r3, [r3, #8]
 800955c:	2b56      	cmp	r3, #86	; 0x56
 800955e:	bf0c      	ite	eq
 8009560:	2301      	moveq	r3, #1
 8009562:	2300      	movne	r3, #0
 8009564:	b2da      	uxtb	r2, r3
 8009566:	4b7a      	ldr	r3, [pc, #488]	; (8009750 <gc_execute_block+0x3534>)
 8009568:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
                        gc_state.canned.rapid_retract = gc_block.modal.motion == MotionMode_CannedCycle86;
 800956c:	4b77      	ldr	r3, [pc, #476]	; (800974c <gc_execute_block+0x3530>)
 800956e:	891b      	ldrh	r3, [r3, #8]
 8009570:	2b56      	cmp	r3, #86	; 0x56
 8009572:	bf0c      	ite	eq
 8009574:	2301      	moveq	r3, #1
 8009576:	2300      	movne	r3, #0
 8009578:	b2da      	uxtb	r2, r3
 800957a:	4b75      	ldr	r3, [pc, #468]	; (8009750 <gc_execute_block+0x3534>)
 800957c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                        // no break

                    case MotionMode_CannedCycle82:
                        if(gc_block.words.p) {
 8009580:	4b72      	ldr	r3, [pc, #456]	; (800974c <gc_execute_block+0x3530>)
 8009582:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009586:	f003 0301 	and.w	r3, r3, #1
 800958a:	b2db      	uxtb	r3, r3
 800958c:	2b00      	cmp	r3, #0
 800958e:	d018      	beq.n	80095c2 <gc_execute_block+0x33a6>
                            if(gc_block.values.p < 0.0f)
 8009590:	4b6e      	ldr	r3, [pc, #440]	; (800974c <gc_execute_block+0x3530>)
 8009592:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009594:	f04f 0100 	mov.w	r1, #0
 8009598:	4618      	mov	r0, r3
 800959a:	f7f7 fda9 	bl	80010f0 <__aeabi_fcmplt>
 800959e:	4603      	mov	r3, r0
 80095a0:	2b00      	cmp	r3, #0
 80095a2:	d002      	beq.n	80095aa <gc_execute_block+0x338e>
                                FAIL(Status_NegativeValue);
 80095a4:	2304      	movs	r3, #4
 80095a6:	f002 b931 	b.w	800b80c <gc_execute_block+0x55f0>
                            gc_state.canned.dwell = gc_block.values.p;
 80095aa:	4b68      	ldr	r3, [pc, #416]	; (800974c <gc_execute_block+0x3530>)
 80095ac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80095ae:	4a68      	ldr	r2, [pc, #416]	; (8009750 <gc_execute_block+0x3534>)
 80095b0:	6393      	str	r3, [r2, #56]	; 0x38
                            gc_block.words.p = Off; // Remove single-meaning value word.
 80095b2:	4a66      	ldr	r2, [pc, #408]	; (800974c <gc_execute_block+0x3530>)
 80095b4:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80095b8:	f36f 0300 	bfc	r3, #0, #1
 80095bc:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80095c0:	e009      	b.n	80095d6 <gc_execute_block+0x33ba>
                        } else if(gc_parser_flags.canned_cycle_change)
 80095c2:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 80095c6:	f003 0302 	and.w	r3, r3, #2
 80095ca:	b2db      	uxtb	r3, r3
 80095cc:	2b00      	cmp	r3, #0
 80095ce:	d002      	beq.n	80095d6 <gc_execute_block+0x33ba>
                            FAIL(Status_GcodeValueWordMissing);
 80095d0:	231c      	movs	r3, #28
 80095d2:	f002 b91b 	b.w	800b80c <gc_execute_block+0x55f0>
                        // no break

                    case MotionMode_CannedCycle85:
                    case MotionMode_CannedCycle81:
                        gc_state.canned.delta = - gc_state.canned.xyz[plane.axis_linear] + gc_state.canned.retract_position;
 80095d6:	4b5e      	ldr	r3, [pc, #376]	; (8009750 <gc_execute_block+0x3534>)
 80095d8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80095da:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 80095de:	495c      	ldr	r1, [pc, #368]	; (8009750 <gc_execute_block+0x3534>)
 80095e0:	330a      	adds	r3, #10
 80095e2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80095e6:	4619      	mov	r1, r3
 80095e8:	4610      	mov	r0, r2
 80095ea:	f7f7 fad9 	bl	8000ba0 <__aeabi_fsub>
 80095ee:	4603      	mov	r3, r0
 80095f0:	461a      	mov	r2, r3
 80095f2:	4b57      	ldr	r3, [pc, #348]	; (8009750 <gc_execute_block+0x3534>)
 80095f4:	635a      	str	r2, [r3, #52]	; 0x34
                        if(gc_block.modal.motion == MotionMode_CannedCycle85)
 80095f6:	4b55      	ldr	r3, [pc, #340]	; (800974c <gc_execute_block+0x3530>)
 80095f8:	891b      	ldrh	r3, [r3, #8]
 80095fa:	2b55      	cmp	r3, #85	; 0x55
 80095fc:	f040 84d1 	bne.w	8009fa2 <gc_execute_block+0x3d86>
                            gc_state.canned.rapid_retract = Off;
 8009600:	4b53      	ldr	r3, [pc, #332]	; (8009750 <gc_execute_block+0x3534>)
 8009602:	2200      	movs	r2, #0
 8009604:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                        break;
 8009608:	f000 bccb 	b.w	8009fa2 <gc_execute_block+0x3d86>

                    case MotionMode_DrillChipBreak:
                    case MotionMode_CannedCycle83:
                        if(gc_block.words.q) {
 800960c:	4b4f      	ldr	r3, [pc, #316]	; (800974c <gc_execute_block+0x3530>)
 800960e:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009612:	f003 0302 	and.w	r3, r3, #2
 8009616:	b2db      	uxtb	r3, r3
 8009618:	2b00      	cmp	r3, #0
 800961a:	d026      	beq.n	800966a <gc_execute_block+0x344e>
                            if(gc_block.values.q <= 0.0f)
 800961c:	4b4b      	ldr	r3, [pc, #300]	; (800974c <gc_execute_block+0x3530>)
 800961e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009620:	f04f 0100 	mov.w	r1, #0
 8009624:	4618      	mov	r0, r3
 8009626:	f7f7 fd6d 	bl	8001104 <__aeabi_fcmple>
 800962a:	4603      	mov	r3, r0
 800962c:	2b00      	cmp	r3, #0
 800962e:	d002      	beq.n	8009636 <gc_execute_block+0x341a>
                                FAIL(Status_NegativeValue); // [Q <= 0]
 8009630:	2304      	movs	r3, #4
 8009632:	f002 b8eb 	b.w	800b80c <gc_execute_block+0x55f0>
                            gc_state.canned.delta = gc_block.values.q * (gc_block.modal.units_imperial ? MM_PER_INCH : 1.0f);
 8009636:	4b45      	ldr	r3, [pc, #276]	; (800974c <gc_execute_block+0x3530>)
 8009638:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800963a:	4b44      	ldr	r3, [pc, #272]	; (800974c <gc_execute_block+0x3530>)
 800963c:	7adb      	ldrb	r3, [r3, #11]
 800963e:	2b00      	cmp	r3, #0
 8009640:	d001      	beq.n	8009646 <gc_execute_block+0x342a>
 8009642:	4b44      	ldr	r3, [pc, #272]	; (8009754 <gc_execute_block+0x3538>)
 8009644:	e001      	b.n	800964a <gc_execute_block+0x342e>
 8009646:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800964a:	4611      	mov	r1, r2
 800964c:	4618      	mov	r0, r3
 800964e:	f7f7 fbb1 	bl	8000db4 <__aeabi_fmul>
 8009652:	4603      	mov	r3, r0
 8009654:	461a      	mov	r2, r3
 8009656:	4b3e      	ldr	r3, [pc, #248]	; (8009750 <gc_execute_block+0x3534>)
 8009658:	635a      	str	r2, [r3, #52]	; 0x34
                            gc_block.words.q = Off; // Remove single-meaning value word.
 800965a:	4a3c      	ldr	r2, [pc, #240]	; (800974c <gc_execute_block+0x3530>)
 800965c:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8009660:	f36f 0341 	bfc	r3, #1, #1
 8009664:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8009668:	e009      	b.n	800967e <gc_execute_block+0x3462>
                        } else if(gc_parser_flags.canned_cycle_change)
 800966a:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800966e:	f003 0302 	and.w	r3, r3, #2
 8009672:	b2db      	uxtb	r3, r3
 8009674:	2b00      	cmp	r3, #0
 8009676:	d002      	beq.n	800967e <gc_execute_block+0x3462>
                            FAIL(Status_GcodeValueWordMissing);
 8009678:	231c      	movs	r3, #28
 800967a:	f002 b8c7 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_state.canned.dwell = 0.25f;
 800967e:	4b34      	ldr	r3, [pc, #208]	; (8009750 <gc_execute_block+0x3534>)
 8009680:	f04f 527a 	mov.w	r2, #1048576000	; 0x3e800000
 8009684:	639a      	str	r2, [r3, #56]	; 0x38
                        break;
 8009686:	f000 bc93 	b.w	8009fb0 <gc_execute_block+0x3d94>
                    default:
                        break;

                } // end switch gc_state.canned.motion

            } else switch (gc_block.modal.motion) {
 800968a:	4b30      	ldr	r3, [pc, #192]	; (800974c <gc_execute_block+0x3530>)
 800968c:	891b      	ldrh	r3, [r3, #8]
 800968e:	2b8f      	cmp	r3, #143	; 0x8f
 8009690:	f300 8489 	bgt.w	8009fa6 <gc_execute_block+0x3d8a>
 8009694:	2b8c      	cmp	r3, #140	; 0x8c
 8009696:	da05      	bge.n	80096a4 <gc_execute_block+0x3488>
 8009698:	2b05      	cmp	r3, #5
 800969a:	dc25      	bgt.n	80096e8 <gc_execute_block+0x34cc>
 800969c:	2b00      	cmp	r3, #0
 800969e:	dc11      	bgt.n	80096c4 <gc_execute_block+0x34a8>
                    if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
                        FAIL(Status_GcodeInvalidTarget); // [Invalid target]
                    break;

                default:
                    break;
 80096a0:	f000 bc81 	b.w	8009fa6 <gc_execute_block+0x3d8a>
            } else switch (gc_block.modal.motion) {
 80096a4:	3b8c      	subs	r3, #140	; 0x8c
 80096a6:	2b03      	cmp	r3, #3
 80096a8:	f200 847d 	bhi.w	8009fa6 <gc_execute_block+0x3d8a>
 80096ac:	a201      	add	r2, pc, #4	; (adr r2, 80096b4 <gc_execute_block+0x3498>)
 80096ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80096b2:	bf00      	nop
 80096b4:	08009f49 	.word	0x08009f49
 80096b8:	08009f3d 	.word	0x08009f3d
 80096bc:	08009f49 	.word	0x08009f49
 80096c0:	08009f3d 	.word	0x08009f3d
 80096c4:	3b01      	subs	r3, #1
 80096c6:	2b04      	cmp	r3, #4
 80096c8:	f200 846d 	bhi.w	8009fa6 <gc_execute_block+0x3d8a>
 80096cc:	a201      	add	r2, pc, #4	; (adr r2, 80096d4 <gc_execute_block+0x34b8>)
 80096ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80096d2:	bf00      	nop
 80096d4:	080096f3 	.word	0x080096f3
 80096d8:	08009707 	.word	0x08009707
 80096dc:	08009713 	.word	0x08009713
 80096e0:	08009fa7 	.word	0x08009fa7
 80096e4:	08009c47 	.word	0x08009c47
 80096e8:	2b33      	cmp	r3, #51	; 0x33
 80096ea:	f000 83aa 	beq.w	8009e42 <gc_execute_block+0x3c26>
                    break;
 80096ee:	f000 bc5a 	b.w	8009fa6 <gc_execute_block+0x3d8a>
                    if (!axis_words.mask)
 80096f2:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 80096f6:	2b00      	cmp	r3, #0
 80096f8:	f040 8457 	bne.w	8009faa <gc_execute_block+0x3d8e>
                        axis_command = AxisCommand_None;
 80096fc:	2300      	movs	r3, #0
 80096fe:	f887 310d 	strb.w	r3, [r7, #269]	; 0x10d
                    break;
 8009702:	f000 bc52 	b.w	8009faa <gc_execute_block+0x3d8e>
                    gc_parser_flags.arc_is_clockwise = On;
 8009706:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800970a:	f043 0304 	orr.w	r3, r3, #4
 800970e:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
                    if (!axis_words.mask)
 8009712:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009716:	2b00      	cmp	r3, #0
 8009718:	d102      	bne.n	8009720 <gc_execute_block+0x3504>
                        FAIL(Status_GcodeNoAxisWords); // [No axis words]
 800971a:	231a      	movs	r3, #26
 800971c:	f002 b876 	b.w	800b80c <gc_execute_block+0x55f0>
                    if (!(axis_words.mask & (bit(plane.axis_0)|bit(plane.axis_1))))
 8009720:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009724:	4619      	mov	r1, r3
 8009726:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800972a:	461a      	mov	r2, r3
 800972c:	2301      	movs	r3, #1
 800972e:	fa03 f202 	lsl.w	r2, r3, r2
 8009732:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009736:	4618      	mov	r0, r3
 8009738:	2301      	movs	r3, #1
 800973a:	4083      	lsls	r3, r0
 800973c:	4313      	orrs	r3, r2
 800973e:	400b      	ands	r3, r1
 8009740:	2b00      	cmp	r3, #0
 8009742:	d109      	bne.n	8009758 <gc_execute_block+0x353c>
                        FAIL(Status_GcodeNoAxisWordsInPlane); // [No axis words in plane]
 8009744:	2320      	movs	r3, #32
 8009746:	f002 b861 	b.w	800b80c <gc_execute_block+0x55f0>
 800974a:	bf00      	nop
 800974c:	20000c8c 	.word	0x20000c8c
 8009750:	20000bb0 	.word	0x20000bb0
 8009754:	41cb3333 	.word	0x41cb3333
                    if (gc_block.words.p) { // Number of turns
 8009758:	4bb1      	ldr	r3, [pc, #708]	; (8009a20 <gc_execute_block+0x3804>)
 800975a:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800975e:	f003 0301 	and.w	r3, r3, #1
 8009762:	b2db      	uxtb	r3, r3
 8009764:	2b00      	cmp	r3, #0
 8009766:	d02a      	beq.n	80097be <gc_execute_block+0x35a2>
                        if(!isintf(gc_block.values.p))
 8009768:	4bad      	ldr	r3, [pc, #692]	; (8009a20 <gc_execute_block+0x3804>)
 800976a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800976c:	4618      	mov	r0, r3
 800976e:	f006 ffe7 	bl	8010740 <isintf>
 8009772:	4603      	mov	r3, r0
 8009774:	f083 0301 	eor.w	r3, r3, #1
 8009778:	b2db      	uxtb	r3, r3
 800977a:	2b00      	cmp	r3, #0
 800977c:	d002      	beq.n	8009784 <gc_execute_block+0x3568>
                            FAIL(Status_GcodeCommandValueNotInteger); // [P word is not an integer]
 800977e:	2317      	movs	r3, #23
 8009780:	f002 b844 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.arc_turns = (uint32_t)truncf(gc_block.values.p);
 8009784:	4ba6      	ldr	r3, [pc, #664]	; (8009a20 <gc_execute_block+0x3804>)
 8009786:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009788:	4618      	mov	r0, r3
 800978a:	f01b fb33 	bl	8024df4 <truncf>
 800978e:	4603      	mov	r3, r0
 8009790:	4618      	mov	r0, r3
 8009792:	f7f7 fd11 	bl	80011b8 <__aeabi_f2uiz>
 8009796:	4603      	mov	r3, r0
 8009798:	4aa1      	ldr	r2, [pc, #644]	; (8009a20 <gc_execute_block+0x3804>)
 800979a:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
                        if(gc_block.arc_turns == 0)
 800979e:	4ba0      	ldr	r3, [pc, #640]	; (8009a20 <gc_execute_block+0x3804>)
 80097a0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80097a4:	2b00      	cmp	r3, #0
 80097a6:	d102      	bne.n	80097ae <gc_execute_block+0x3592>
                            FAIL(Status_GcodeValueOutOfRange); // [P word is 0]
 80097a8:	2327      	movs	r3, #39	; 0x27
 80097aa:	f002 b82f 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.words.p = Off;
 80097ae:	4a9c      	ldr	r2, [pc, #624]	; (8009a20 <gc_execute_block+0x3804>)
 80097b0:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 80097b4:	f36f 0300 	bfc	r3, #0, #1
 80097b8:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 80097bc:	e003      	b.n	80097c6 <gc_execute_block+0x35aa>
                        gc_block.arc_turns = 1;
 80097be:	4b98      	ldr	r3, [pc, #608]	; (8009a20 <gc_execute_block+0x3804>)
 80097c0:	2201      	movs	r2, #1
 80097c2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                    x = gc_block.values.xyz[plane.axis_0] - gc_state.position[plane.axis_0]; // Delta x between current position and target
 80097c6:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 80097ca:	4a95      	ldr	r2, [pc, #596]	; (8009a20 <gc_execute_block+0x3804>)
 80097cc:	3318      	adds	r3, #24
 80097ce:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80097d2:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 80097d6:	4993      	ldr	r1, [pc, #588]	; (8009a24 <gc_execute_block+0x3808>)
 80097d8:	3316      	adds	r3, #22
 80097da:	009b      	lsls	r3, r3, #2
 80097dc:	440b      	add	r3, r1
 80097de:	685b      	ldr	r3, [r3, #4]
 80097e0:	4619      	mov	r1, r3
 80097e2:	4610      	mov	r0, r2
 80097e4:	f7f7 f9dc 	bl	8000ba0 <__aeabi_fsub>
 80097e8:	4603      	mov	r3, r0
 80097ea:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
                    y = gc_block.values.xyz[plane.axis_1] - gc_state.position[plane.axis_1]; // Delta y between current position and target
 80097ee:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 80097f2:	4a8b      	ldr	r2, [pc, #556]	; (8009a20 <gc_execute_block+0x3804>)
 80097f4:	3318      	adds	r3, #24
 80097f6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80097fa:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 80097fe:	4989      	ldr	r1, [pc, #548]	; (8009a24 <gc_execute_block+0x3808>)
 8009800:	3316      	adds	r3, #22
 8009802:	009b      	lsls	r3, r3, #2
 8009804:	440b      	add	r3, r1
 8009806:	685b      	ldr	r3, [r3, #4]
 8009808:	4619      	mov	r1, r3
 800980a:	4610      	mov	r0, r2
 800980c:	f7f7 f9c8 	bl	8000ba0 <__aeabi_fsub>
 8009810:	4603      	mov	r3, r0
 8009812:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
                    if (gc_block.words.r) { // Arc Radius Mode
 8009816:	4b82      	ldr	r3, [pc, #520]	; (8009a20 <gc_execute_block+0x3804>)
 8009818:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800981c:	f003 0304 	and.w	r3, r3, #4
 8009820:	b2db      	uxtb	r3, r3
 8009822:	2b00      	cmp	r3, #0
 8009824:	f000 8108 	beq.w	8009a38 <gc_execute_block+0x381c>
                        gc_block.words.r = Off;
 8009828:	4a7d      	ldr	r2, [pc, #500]	; (8009a20 <gc_execute_block+0x3804>)
 800982a:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 800982e:	f36f 0382 	bfc	r3, #2, #1
 8009832:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                        if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8009836:	220c      	movs	r2, #12
 8009838:	497b      	ldr	r1, [pc, #492]	; (8009a28 <gc_execute_block+0x380c>)
 800983a:	487c      	ldr	r0, [pc, #496]	; (8009a2c <gc_execute_block+0x3810>)
 800983c:	f01a f9db 	bl	8023bf6 <memcmp>
 8009840:	4603      	mov	r3, r0
 8009842:	2b00      	cmp	r3, #0
 8009844:	d102      	bne.n	800984c <gc_execute_block+0x3630>
                            FAIL(Status_GcodeInvalidTarget); // [Invalid target]
 8009846:	2321      	movs	r3, #33	; 0x21
 8009848:	f001 bfe0 	b.w	800b80c <gc_execute_block+0x55f0>
                        if (gc_block.modal.units_imperial)
 800984c:	4b74      	ldr	r3, [pc, #464]	; (8009a20 <gc_execute_block+0x3804>)
 800984e:	7adb      	ldrb	r3, [r3, #11]
 8009850:	2b00      	cmp	r3, #0
 8009852:	d009      	beq.n	8009868 <gc_execute_block+0x364c>
                            gc_block.values.r *= MM_PER_INCH;
 8009854:	4b72      	ldr	r3, [pc, #456]	; (8009a20 <gc_execute_block+0x3804>)
 8009856:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009858:	4975      	ldr	r1, [pc, #468]	; (8009a30 <gc_execute_block+0x3814>)
 800985a:	4618      	mov	r0, r3
 800985c:	f7f7 faaa 	bl	8000db4 <__aeabi_fmul>
 8009860:	4603      	mov	r3, r0
 8009862:	461a      	mov	r2, r3
 8009864:	4b6e      	ldr	r3, [pc, #440]	; (8009a20 <gc_execute_block+0x3804>)
 8009866:	659a      	str	r2, [r3, #88]	; 0x58
                        if(gc_state.modal.scaling_active)
 8009868:	4b6e      	ldr	r3, [pc, #440]	; (8009a24 <gc_execute_block+0x3808>)
 800986a:	7f9b      	ldrb	r3, [r3, #30]
 800986c:	2b00      	cmp	r3, #0
 800986e:	d02d      	beq.n	80098cc <gc_execute_block+0x36b0>
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 8009870:	4b6b      	ldr	r3, [pc, #428]	; (8009a20 <gc_execute_block+0x3804>)
 8009872:	6d9c      	ldr	r4, [r3, #88]	; 0x58
 8009874:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 8009878:	4a6e      	ldr	r2, [pc, #440]	; (8009a34 <gc_execute_block+0x3818>)
 800987a:	3302      	adds	r3, #2
 800987c:	009b      	lsls	r3, r3, #2
 800987e:	4413      	add	r3, r2
 8009880:	685a      	ldr	r2, [r3, #4]
 8009882:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009886:	496b      	ldr	r1, [pc, #428]	; (8009a34 <gc_execute_block+0x3818>)
 8009888:	3302      	adds	r3, #2
 800988a:	009b      	lsls	r3, r3, #2
 800988c:	440b      	add	r3, r1
 800988e:	685b      	ldr	r3, [r3, #4]
                                                   : scale_factor.ijk[plane.axis_1]);
 8009890:	4619      	mov	r1, r3
 8009892:	4610      	mov	r0, r2
 8009894:	f7f7 fc4a 	bl	800112c <__aeabi_fcmpgt>
 8009898:	4603      	mov	r3, r0
 800989a:	2b00      	cmp	r3, #0
 800989c:	d007      	beq.n	80098ae <gc_execute_block+0x3692>
                                                   ? scale_factor.ijk[plane.axis_0]
 800989e:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
                                                   : scale_factor.ijk[plane.axis_1]);
 80098a2:	4a64      	ldr	r2, [pc, #400]	; (8009a34 <gc_execute_block+0x3818>)
 80098a4:	3302      	adds	r3, #2
 80098a6:	009b      	lsls	r3, r3, #2
 80098a8:	4413      	add	r3, r2
 80098aa:	685b      	ldr	r3, [r3, #4]
 80098ac:	e006      	b.n	80098bc <gc_execute_block+0x36a0>
 80098ae:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 80098b2:	4a60      	ldr	r2, [pc, #384]	; (8009a34 <gc_execute_block+0x3818>)
 80098b4:	3302      	adds	r3, #2
 80098b6:	009b      	lsls	r3, r3, #2
 80098b8:	4413      	add	r3, r2
 80098ba:	685b      	ldr	r3, [r3, #4]
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 80098bc:	4621      	mov	r1, r4
 80098be:	4618      	mov	r0, r3
 80098c0:	f7f7 fa78 	bl	8000db4 <__aeabi_fmul>
 80098c4:	4603      	mov	r3, r0
 80098c6:	461a      	mov	r2, r3
 80098c8:	4b55      	ldr	r3, [pc, #340]	; (8009a20 <gc_execute_block+0x3804>)
 80098ca:	659a      	str	r2, [r3, #88]	; 0x58
                        float h_x2_div_d = 4.0f * gc_block.values.r * gc_block.values.r - x * x - y * y;
 80098cc:	4b54      	ldr	r3, [pc, #336]	; (8009a20 <gc_execute_block+0x3804>)
 80098ce:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80098d0:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 80098d4:	4618      	mov	r0, r3
 80098d6:	f7f7 fa6d 	bl	8000db4 <__aeabi_fmul>
 80098da:	4603      	mov	r3, r0
 80098dc:	461a      	mov	r2, r3
 80098de:	4b50      	ldr	r3, [pc, #320]	; (8009a20 <gc_execute_block+0x3804>)
 80098e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80098e2:	4619      	mov	r1, r3
 80098e4:	4610      	mov	r0, r2
 80098e6:	f7f7 fa65 	bl	8000db4 <__aeabi_fmul>
 80098ea:	4603      	mov	r3, r0
 80098ec:	461c      	mov	r4, r3
 80098ee:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
 80098f2:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 80098f6:	f7f7 fa5d 	bl	8000db4 <__aeabi_fmul>
 80098fa:	4603      	mov	r3, r0
 80098fc:	4619      	mov	r1, r3
 80098fe:	4620      	mov	r0, r4
 8009900:	f7f7 f94e 	bl	8000ba0 <__aeabi_fsub>
 8009904:	4603      	mov	r3, r0
 8009906:	461c      	mov	r4, r3
 8009908:	f8d7 10e0 	ldr.w	r1, [r7, #224]	; 0xe0
 800990c:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8009910:	f7f7 fa50 	bl	8000db4 <__aeabi_fmul>
 8009914:	4603      	mov	r3, r0
 8009916:	4619      	mov	r1, r3
 8009918:	4620      	mov	r0, r4
 800991a:	f7f7 f941 	bl	8000ba0 <__aeabi_fsub>
 800991e:	4603      	mov	r3, r0
 8009920:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
                        if (h_x2_div_d < 0.0f)
 8009924:	f04f 0100 	mov.w	r1, #0
 8009928:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 800992c:	f7f7 fbe0 	bl	80010f0 <__aeabi_fcmplt>
 8009930:	4603      	mov	r3, r0
 8009932:	2b00      	cmp	r3, #0
 8009934:	d002      	beq.n	800993c <gc_execute_block+0x3720>
                            FAIL(Status_GcodeArcRadiusError); // [Arc radius error] TODO: this will fail due to limited float precision...
 8009936:	2322      	movs	r3, #34	; 0x22
 8009938:	f001 bf68 	b.w	800b80c <gc_execute_block+0x55f0>
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 800993c:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 8009940:	f01b f85d 	bl	80249fe <sqrtf>
 8009944:	4603      	mov	r3, r0
 8009946:	f083 4400 	eor.w	r4, r3, #2147483648	; 0x80000000
 800994a:	f8d7 10e0 	ldr.w	r1, [r7, #224]	; 0xe0
 800994e:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 8009952:	f7fb ff93 	bl	800587c <hypot_f>
 8009956:	4603      	mov	r3, r0
 8009958:	4619      	mov	r1, r3
 800995a:	4620      	mov	r0, r4
 800995c:	f7f7 fade 	bl	8000f1c <__aeabi_fdiv>
 8009960:	4603      	mov	r3, r0
 8009962:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
                        if (gc_block.modal.motion == MotionMode_CcwArc)
 8009966:	4b2e      	ldr	r3, [pc, #184]	; (8009a20 <gc_execute_block+0x3804>)
 8009968:	891b      	ldrh	r3, [r3, #8]
 800996a:	2b03      	cmp	r3, #3
 800996c:	d105      	bne.n	800997a <gc_execute_block+0x375e>
                            h_x2_div_d = -h_x2_div_d;
 800996e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8009972:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8009976:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
                        if (gc_block.values.r < 0.0f) {
 800997a:	4b29      	ldr	r3, [pc, #164]	; (8009a20 <gc_execute_block+0x3804>)
 800997c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800997e:	f04f 0100 	mov.w	r1, #0
 8009982:	4618      	mov	r0, r3
 8009984:	f7f7 fbb4 	bl	80010f0 <__aeabi_fcmplt>
 8009988:	4603      	mov	r3, r0
 800998a:	2b00      	cmp	r3, #0
 800998c:	d00b      	beq.n	80099a6 <gc_execute_block+0x378a>
                            h_x2_div_d = -h_x2_div_d;
 800998e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8009992:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8009996:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
                            gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 800999a:	4b21      	ldr	r3, [pc, #132]	; (8009a20 <gc_execute_block+0x3804>)
 800999c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800999e:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 80099a2:	4a1f      	ldr	r2, [pc, #124]	; (8009a20 <gc_execute_block+0x3804>)
 80099a4:	6593      	str	r3, [r2, #88]	; 0x58
                        gc_block.values.ijk[plane.axis_0] = 0.5f * (x - (y * h_x2_div_d));
 80099a6:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 80099aa:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 80099ae:	f7f7 fa01 	bl	8000db4 <__aeabi_fmul>
 80099b2:	4603      	mov	r3, r0
 80099b4:	4619      	mov	r1, r3
 80099b6:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 80099ba:	f7f7 f8f1 	bl	8000ba0 <__aeabi_fsub>
 80099be:	4603      	mov	r3, r0
 80099c0:	461a      	mov	r2, r3
 80099c2:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 80099c6:	461c      	mov	r4, r3
 80099c8:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80099cc:	4610      	mov	r0, r2
 80099ce:	f7f7 f9f1 	bl	8000db4 <__aeabi_fmul>
 80099d2:	4603      	mov	r3, r0
 80099d4:	4619      	mov	r1, r3
 80099d6:	4a12      	ldr	r2, [pc, #72]	; (8009a20 <gc_execute_block+0x3804>)
 80099d8:	f104 030e 	add.w	r3, r4, #14
 80099dc:	009b      	lsls	r3, r3, #2
 80099de:	4413      	add	r3, r2
 80099e0:	6059      	str	r1, [r3, #4]
                        gc_block.values.ijk[plane.axis_1] = 0.5f * (y + (x * h_x2_div_d));
 80099e2:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 80099e6:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 80099ea:	f7f7 f9e3 	bl	8000db4 <__aeabi_fmul>
 80099ee:	4603      	mov	r3, r0
 80099f0:	f8d7 10e0 	ldr.w	r1, [r7, #224]	; 0xe0
 80099f4:	4618      	mov	r0, r3
 80099f6:	f7f7 f8d5 	bl	8000ba4 <__addsf3>
 80099fa:	4603      	mov	r3, r0
 80099fc:	461a      	mov	r2, r3
 80099fe:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009a02:	461c      	mov	r4, r3
 8009a04:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8009a08:	4610      	mov	r0, r2
 8009a0a:	f7f7 f9d3 	bl	8000db4 <__aeabi_fmul>
 8009a0e:	4603      	mov	r3, r0
 8009a10:	4619      	mov	r1, r3
 8009a12:	4a03      	ldr	r2, [pc, #12]	; (8009a20 <gc_execute_block+0x3804>)
 8009a14:	f104 030e 	add.w	r3, r4, #14
 8009a18:	009b      	lsls	r3, r3, #2
 8009a1a:	4413      	add	r3, r2
 8009a1c:	6059      	str	r1, [r3, #4]
                    break;
 8009a1e:	e2c7      	b.n	8009fb0 <gc_execute_block+0x3d94>
 8009a20:	20000c8c 	.word	0x20000c8c
 8009a24:	20000bb0 	.word	0x20000bb0
 8009a28:	20000cec 	.word	0x20000cec
 8009a2c:	20000c0c 	.word	0x20000c0c
 8009a30:	41cb3333 	.word	0x41cb3333
 8009a34:	20000248 	.word	0x20000248
                        if (!(ijk_words.mask & (bit(plane.axis_0)|bit(plane.axis_1))))
 8009a38:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8009a3c:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 8009a40:	4619      	mov	r1, r3
 8009a42:	2301      	movs	r3, #1
 8009a44:	fa03 f101 	lsl.w	r1, r3, r1
 8009a48:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009a4c:	4618      	mov	r0, r3
 8009a4e:	2301      	movs	r3, #1
 8009a50:	4083      	lsls	r3, r0
 8009a52:	430b      	orrs	r3, r1
 8009a54:	4013      	ands	r3, r2
 8009a56:	2b00      	cmp	r3, #0
 8009a58:	d102      	bne.n	8009a60 <gc_execute_block+0x3844>
                            FAIL(Status_GcodeNoOffsetsInPlane);// [No offsets in plane]
 8009a5a:	2323      	movs	r3, #35	; 0x23
 8009a5c:	f001 bed6 	b.w	800b80c <gc_execute_block+0x55f0>
                        gc_block.words.i = gc_block.words.j = gc_block.words.k = Off;
 8009a60:	4aa0      	ldr	r2, [pc, #640]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009a62:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009a66:	f36f 1386 	bfc	r3, #6, #1
 8009a6a:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009a6e:	4b9d      	ldr	r3, [pc, #628]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009a70:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009a74:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009a78:	b2d9      	uxtb	r1, r3
 8009a7a:	4a9a      	ldr	r2, [pc, #616]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009a7c:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009a80:	f361 1345 	bfi	r3, r1, #5, #1
 8009a84:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009a88:	4b96      	ldr	r3, [pc, #600]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009a8a:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009a8e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009a92:	b2d9      	uxtb	r1, r3
 8009a94:	4a93      	ldr	r2, [pc, #588]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009a96:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009a9a:	f361 1304 	bfi	r3, r1, #4, #1
 8009a9e:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
                        if (gc_block.modal.units_imperial) {
 8009aa2:	4b90      	ldr	r3, [pc, #576]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009aa4:	7adb      	ldrb	r3, [r3, #11]
 8009aa6:	2b00      	cmp	r3, #0
 8009aa8:	d029      	beq.n	8009afe <gc_execute_block+0x38e2>
                            idx = 3;
 8009aaa:	2303      	movs	r3, #3
 8009aac:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                                idx--;
 8009ab0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009ab4:	3b01      	subs	r3, #1
 8009ab6:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                                if (ijk_words.mask & bit(idx))
 8009aba:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8009abe:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009ac2:	fa22 f303 	lsr.w	r3, r2, r3
 8009ac6:	f003 0301 	and.w	r3, r3, #1
 8009aca:	2b00      	cmp	r3, #0
 8009acc:	d013      	beq.n	8009af6 <gc_execute_block+0x38da>
                                    gc_block.values.ijk[idx] *= MM_PER_INCH;
 8009ace:	4a85      	ldr	r2, [pc, #532]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009ad0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009ad4:	330e      	adds	r3, #14
 8009ad6:	009b      	lsls	r3, r3, #2
 8009ad8:	4413      	add	r3, r2
 8009ada:	685b      	ldr	r3, [r3, #4]
 8009adc:	4982      	ldr	r1, [pc, #520]	; (8009ce8 <gc_execute_block+0x3acc>)
 8009ade:	4618      	mov	r0, r3
 8009ae0:	f7f7 f968 	bl	8000db4 <__aeabi_fmul>
 8009ae4:	4603      	mov	r3, r0
 8009ae6:	4619      	mov	r1, r3
 8009ae8:	4a7e      	ldr	r2, [pc, #504]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009aea:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009aee:	330e      	adds	r3, #14
 8009af0:	009b      	lsls	r3, r3, #2
 8009af2:	4413      	add	r3, r2
 8009af4:	6059      	str	r1, [r3, #4]
                            } while(idx);
 8009af6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009afa:	2b00      	cmp	r3, #0
 8009afc:	d1d8      	bne.n	8009ab0 <gc_execute_block+0x3894>
                        if(gc_state.modal.scaling_active) {
 8009afe:	4b7b      	ldr	r3, [pc, #492]	; (8009cec <gc_execute_block+0x3ad0>)
 8009b00:	7f9b      	ldrb	r3, [r3, #30]
 8009b02:	2b00      	cmp	r3, #0
 8009b04:	d030      	beq.n	8009b68 <gc_execute_block+0x394c>
                            idx = 3;
 8009b06:	2303      	movs	r3, #3
 8009b08:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                                if (ijk_words.mask & bit(--idx))
 8009b0c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8009b10:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b14:	3b01      	subs	r3, #1
 8009b16:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8009b1a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b1e:	fa22 f303 	lsr.w	r3, r2, r3
 8009b22:	f003 0301 	and.w	r3, r3, #1
 8009b26:	2b00      	cmp	r3, #0
 8009b28:	d01a      	beq.n	8009b60 <gc_execute_block+0x3944>
                                    gc_block.values.ijk[idx] *= scale_factor.ijk[idx];
 8009b2a:	4a6e      	ldr	r2, [pc, #440]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009b2c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b30:	330e      	adds	r3, #14
 8009b32:	009b      	lsls	r3, r3, #2
 8009b34:	4413      	add	r3, r2
 8009b36:	685a      	ldr	r2, [r3, #4]
 8009b38:	496d      	ldr	r1, [pc, #436]	; (8009cf0 <gc_execute_block+0x3ad4>)
 8009b3a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b3e:	3302      	adds	r3, #2
 8009b40:	009b      	lsls	r3, r3, #2
 8009b42:	440b      	add	r3, r1
 8009b44:	685b      	ldr	r3, [r3, #4]
 8009b46:	4619      	mov	r1, r3
 8009b48:	4610      	mov	r0, r2
 8009b4a:	f7f7 f933 	bl	8000db4 <__aeabi_fmul>
 8009b4e:	4603      	mov	r3, r0
 8009b50:	4619      	mov	r1, r3
 8009b52:	4a64      	ldr	r2, [pc, #400]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009b54:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b58:	330e      	adds	r3, #14
 8009b5a:	009b      	lsls	r3, r3, #2
 8009b5c:	4413      	add	r3, r2
 8009b5e:	6059      	str	r1, [r3, #4]
                            } while(idx);
 8009b60:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8009b64:	2b00      	cmp	r3, #0
 8009b66:	d1d1      	bne.n	8009b0c <gc_execute_block+0x38f0>
                        x -= gc_block.values.ijk[plane.axis_0]; // Delta x between circle center and target
 8009b68:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 8009b6c:	4a5d      	ldr	r2, [pc, #372]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009b6e:	330e      	adds	r3, #14
 8009b70:	009b      	lsls	r3, r3, #2
 8009b72:	4413      	add	r3, r2
 8009b74:	685b      	ldr	r3, [r3, #4]
 8009b76:	4619      	mov	r1, r3
 8009b78:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 8009b7c:	f7f7 f810 	bl	8000ba0 <__aeabi_fsub>
 8009b80:	4603      	mov	r3, r0
 8009b82:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
                        y -= gc_block.values.ijk[plane.axis_1]; // Delta y between circle center and target
 8009b86:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009b8a:	4a56      	ldr	r2, [pc, #344]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009b8c:	330e      	adds	r3, #14
 8009b8e:	009b      	lsls	r3, r3, #2
 8009b90:	4413      	add	r3, r2
 8009b92:	685b      	ldr	r3, [r3, #4]
 8009b94:	4619      	mov	r1, r3
 8009b96:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8009b9a:	f7f7 f801 	bl	8000ba0 <__aeabi_fsub>
 8009b9e:	4603      	mov	r3, r0
 8009ba0:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
                        float target_r = hypot_f(x, y);
 8009ba4:	f8d7 10e0 	ldr.w	r1, [r7, #224]	; 0xe0
 8009ba8:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 8009bac:	f7fb fe66 	bl	800587c <hypot_f>
 8009bb0:	f8c7 00dc 	str.w	r0, [r7, #220]	; 0xdc
                        gc_block.values.r = hypot_f(gc_block.values.ijk[plane.axis_0], gc_block.values.ijk[plane.axis_1]);
 8009bb4:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 8009bb8:	4a4a      	ldr	r2, [pc, #296]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009bba:	330e      	adds	r3, #14
 8009bbc:	009b      	lsls	r3, r3, #2
 8009bbe:	4413      	add	r3, r2
 8009bc0:	685a      	ldr	r2, [r3, #4]
 8009bc2:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 8009bc6:	4947      	ldr	r1, [pc, #284]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009bc8:	330e      	adds	r3, #14
 8009bca:	009b      	lsls	r3, r3, #2
 8009bcc:	440b      	add	r3, r1
 8009bce:	685b      	ldr	r3, [r3, #4]
 8009bd0:	4619      	mov	r1, r3
 8009bd2:	4610      	mov	r0, r2
 8009bd4:	f7fb fe52 	bl	800587c <hypot_f>
 8009bd8:	4603      	mov	r3, r0
 8009bda:	4a42      	ldr	r2, [pc, #264]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009bdc:	6593      	str	r3, [r2, #88]	; 0x58
                        float delta_r = fabsf(target_r - gc_block.values.r);
 8009bde:	4b41      	ldr	r3, [pc, #260]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009be0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009be2:	4619      	mov	r1, r3
 8009be4:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 8009be8:	f7f6 ffda 	bl	8000ba0 <__aeabi_fsub>
 8009bec:	4603      	mov	r3, r0
 8009bee:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8009bf2:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
                        if (delta_r > 0.005f) {
 8009bf6:	493f      	ldr	r1, [pc, #252]	; (8009cf4 <gc_execute_block+0x3ad8>)
 8009bf8:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 8009bfc:	f7f7 fa96 	bl	800112c <__aeabi_fcmpgt>
 8009c00:	4603      	mov	r3, r0
 8009c02:	2b00      	cmp	r3, #0
 8009c04:	d100      	bne.n	8009c08 <gc_execute_block+0x39ec>
                    break;
 8009c06:	e1d3      	b.n	8009fb0 <gc_execute_block+0x3d94>
                            if (delta_r > 0.5f)
 8009c08:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8009c0c:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 8009c10:	f7f7 fa8c 	bl	800112c <__aeabi_fcmpgt>
 8009c14:	4603      	mov	r3, r0
 8009c16:	2b00      	cmp	r3, #0
 8009c18:	d002      	beq.n	8009c20 <gc_execute_block+0x3a04>
                                FAIL(Status_GcodeInvalidTarget); // [Arc definition error] > 0.5mm
 8009c1a:	2321      	movs	r3, #33	; 0x21
 8009c1c:	f001 bdf6 	b.w	800b80c <gc_execute_block+0x55f0>
                            if (delta_r > (0.001f * gc_block.values.r))
 8009c20:	4b30      	ldr	r3, [pc, #192]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009c22:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009c24:	4934      	ldr	r1, [pc, #208]	; (8009cf8 <gc_execute_block+0x3adc>)
 8009c26:	4618      	mov	r0, r3
 8009c28:	f7f7 f8c4 	bl	8000db4 <__aeabi_fmul>
 8009c2c:	4603      	mov	r3, r0
 8009c2e:	4619      	mov	r1, r3
 8009c30:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 8009c34:	f7f7 fa7a 	bl	800112c <__aeabi_fcmpgt>
 8009c38:	4603      	mov	r3, r0
 8009c3a:	2b00      	cmp	r3, #0
 8009c3c:	d100      	bne.n	8009c40 <gc_execute_block+0x3a24>
                    break;
 8009c3e:	e1b7      	b.n	8009fb0 <gc_execute_block+0x3d94>
                                FAIL(Status_GcodeInvalidTarget); // [Arc definition error] > 0.005mm AND 0.1% radius
 8009c40:	2321      	movs	r3, #33	; 0x21
 8009c42:	f001 bde3 	b.w	800b80c <gc_execute_block+0x55f0>
                    if(gc_block.modal.plane_select != PlaneSelect_XY)
 8009c46:	4b27      	ldr	r3, [pc, #156]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009c48:	7b9b      	ldrb	r3, [r3, #14]
 8009c4a:	2b00      	cmp	r3, #0
 8009c4c:	d002      	beq.n	8009c54 <gc_execute_block+0x3a38>
                        FAIL(Status_GcodeIllegalPlane); // [The active plane is not G17]
 8009c4e:	232a      	movs	r3, #42	; 0x2a
 8009c50:	f001 bddc 	b.w	800b80c <gc_execute_block+0x55f0>
                    if (axis_words.mask & ~(bit(X_AXIS)|bit(Y_AXIS)))
 8009c54:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009c58:	f023 0303 	bic.w	r3, r3, #3
 8009c5c:	2b00      	cmp	r3, #0
 8009c5e:	d002      	beq.n	8009c66 <gc_execute_block+0x3a4a>
                        FAIL(Status_GcodeAxisCommandConflict); // [An axis other than X or Y is specified]
 8009c60:	2318      	movs	r3, #24
 8009c62:	f001 bdd3 	b.w	800b80c <gc_execute_block+0x55f0>
                    if((gc_block.words.mask & pq_words.mask) != pq_words.mask)
 8009c66:	4b1f      	ldr	r3, [pc, #124]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009c68:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8009c6c:	4b23      	ldr	r3, [pc, #140]	; (8009cfc <gc_execute_block+0x3ae0>)
 8009c6e:	681b      	ldr	r3, [r3, #0]
 8009c70:	401a      	ands	r2, r3
 8009c72:	4b22      	ldr	r3, [pc, #136]	; (8009cfc <gc_execute_block+0x3ae0>)
 8009c74:	681b      	ldr	r3, [r3, #0]
 8009c76:	429a      	cmp	r2, r3
 8009c78:	d002      	beq.n	8009c80 <gc_execute_block+0x3a64>
                        FAIL(Status_GcodeValueWordMissing); // [P and Q are not both specified]
 8009c7a:	231c      	movs	r3, #28
 8009c7c:	f001 bdc6 	b.w	800b80c <gc_execute_block+0x55f0>
                    if(gc_parser_flags.motion_mode_changed && (gc_block.words.mask & ij_words.mask) != ij_words.mask)
 8009c80:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8009c84:	f003 0302 	and.w	r3, r3, #2
 8009c88:	b2db      	uxtb	r3, r3
 8009c8a:	2b00      	cmp	r3, #0
 8009c8c:	d00c      	beq.n	8009ca8 <gc_execute_block+0x3a8c>
 8009c8e:	4b15      	ldr	r3, [pc, #84]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009c90:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8009c94:	4b1a      	ldr	r3, [pc, #104]	; (8009d00 <gc_execute_block+0x3ae4>)
 8009c96:	681b      	ldr	r3, [r3, #0]
 8009c98:	401a      	ands	r2, r3
 8009c9a:	4b19      	ldr	r3, [pc, #100]	; (8009d00 <gc_execute_block+0x3ae4>)
 8009c9c:	681b      	ldr	r3, [r3, #0]
 8009c9e:	429a      	cmp	r2, r3
 8009ca0:	d002      	beq.n	8009ca8 <gc_execute_block+0x3a8c>
                        FAIL(Status_GcodeValueWordMissing); // [I or J are unspecified in the first of a series of G5 commands]
 8009ca2:	231c      	movs	r3, #28
 8009ca4:	f001 bdb2 	b.w	800b80c <gc_execute_block+0x55f0>
                    if(!(gc_block.words.i || gc_block.words.j)) {
 8009ca8:	4b0e      	ldr	r3, [pc, #56]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009caa:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009cae:	f003 0310 	and.w	r3, r3, #16
 8009cb2:	b2db      	uxtb	r3, r3
 8009cb4:	2b00      	cmp	r3, #0
 8009cb6:	d125      	bne.n	8009d04 <gc_execute_block+0x3ae8>
 8009cb8:	4b0a      	ldr	r3, [pc, #40]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009cba:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009cbe:	f003 0320 	and.w	r3, r3, #32
 8009cc2:	b2db      	uxtb	r3, r3
 8009cc4:	2b00      	cmp	r3, #0
 8009cc6:	d11d      	bne.n	8009d04 <gc_execute_block+0x3ae8>
                        gc_block.values.ijk[I_VALUE] = - gc_block.values.p;
 8009cc8:	4b06      	ldr	r3, [pc, #24]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009cca:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009ccc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8009cd0:	4a04      	ldr	r2, [pc, #16]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009cd2:	63d3      	str	r3, [r2, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] = - gc_block.values.q;
 8009cd4:	4b03      	ldr	r3, [pc, #12]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009cd6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009cd8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8009cdc:	4a01      	ldr	r2, [pc, #4]	; (8009ce4 <gc_execute_block+0x3ac8>)
 8009cde:	6413      	str	r3, [r2, #64]	; 0x40
 8009ce0:	e044      	b.n	8009d6c <gc_execute_block+0x3b50>
 8009ce2:	bf00      	nop
 8009ce4:	20000c8c 	.word	0x20000c8c
 8009ce8:	41cb3333 	.word	0x41cb3333
 8009cec:	20000bb0 	.word	0x20000bb0
 8009cf0:	20000248 	.word	0x20000248
 8009cf4:	3ba3d70a 	.word	0x3ba3d70a
 8009cf8:	3a83126f 	.word	0x3a83126f
 8009cfc:	08030c7c 	.word	0x08030c7c
 8009d00:	08030c80 	.word	0x08030c80
                        if (gc_block.modal.units_imperial) {
 8009d04:	4b9b      	ldr	r3, [pc, #620]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d06:	7adb      	ldrb	r3, [r3, #11]
 8009d08:	2b00      	cmp	r3, #0
 8009d0a:	d013      	beq.n	8009d34 <gc_execute_block+0x3b18>
                            gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 8009d0c:	4b99      	ldr	r3, [pc, #612]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d0e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009d10:	4999      	ldr	r1, [pc, #612]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009d12:	4618      	mov	r0, r3
 8009d14:	f7f7 f84e 	bl	8000db4 <__aeabi_fmul>
 8009d18:	4603      	mov	r3, r0
 8009d1a:	461a      	mov	r2, r3
 8009d1c:	4b95      	ldr	r3, [pc, #596]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d1e:	63da      	str	r2, [r3, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8009d20:	4b94      	ldr	r3, [pc, #592]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009d24:	4994      	ldr	r1, [pc, #592]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009d26:	4618      	mov	r0, r3
 8009d28:	f7f7 f844 	bl	8000db4 <__aeabi_fmul>
 8009d2c:	4603      	mov	r3, r0
 8009d2e:	461a      	mov	r2, r3
 8009d30:	4b90      	ldr	r3, [pc, #576]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d32:	641a      	str	r2, [r3, #64]	; 0x40
                        if(gc_state.modal.scaling_active) {
 8009d34:	4b91      	ldr	r3, [pc, #580]	; (8009f7c <gc_execute_block+0x3d60>)
 8009d36:	7f9b      	ldrb	r3, [r3, #30]
 8009d38:	2b00      	cmp	r3, #0
 8009d3a:	d017      	beq.n	8009d6c <gc_execute_block+0x3b50>
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 8009d3c:	4b8d      	ldr	r3, [pc, #564]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d3e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009d40:	4a8f      	ldr	r2, [pc, #572]	; (8009f80 <gc_execute_block+0x3d64>)
 8009d42:	68d2      	ldr	r2, [r2, #12]
 8009d44:	4611      	mov	r1, r2
 8009d46:	4618      	mov	r0, r3
 8009d48:	f7f7 f834 	bl	8000db4 <__aeabi_fmul>
 8009d4c:	4603      	mov	r3, r0
 8009d4e:	461a      	mov	r2, r3
 8009d50:	4b88      	ldr	r3, [pc, #544]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d52:	63da      	str	r2, [r3, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 8009d54:	4b87      	ldr	r3, [pc, #540]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009d58:	4a89      	ldr	r2, [pc, #548]	; (8009f80 <gc_execute_block+0x3d64>)
 8009d5a:	6912      	ldr	r2, [r2, #16]
 8009d5c:	4611      	mov	r1, r2
 8009d5e:	4618      	mov	r0, r3
 8009d60:	f7f7 f828 	bl	8000db4 <__aeabi_fmul>
 8009d64:	4603      	mov	r3, r0
 8009d66:	461a      	mov	r2, r3
 8009d68:	4b82      	ldr	r3, [pc, #520]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d6a:	641a      	str	r2, [r3, #64]	; 0x40
                    if (gc_block.modal.units_imperial) {
 8009d6c:	4b81      	ldr	r3, [pc, #516]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d6e:	7adb      	ldrb	r3, [r3, #11]
 8009d70:	2b00      	cmp	r3, #0
 8009d72:	d013      	beq.n	8009d9c <gc_execute_block+0x3b80>
                        gc_block.values.p *= MM_PER_INCH;
 8009d74:	4b7f      	ldr	r3, [pc, #508]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d76:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009d78:	497f      	ldr	r1, [pc, #508]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009d7a:	4618      	mov	r0, r3
 8009d7c:	f7f7 f81a 	bl	8000db4 <__aeabi_fmul>
 8009d80:	4603      	mov	r3, r0
 8009d82:	461a      	mov	r2, r3
 8009d84:	4b7b      	ldr	r3, [pc, #492]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d86:	651a      	str	r2, [r3, #80]	; 0x50
                        gc_block.values.q *= MM_PER_INCH;
 8009d88:	4b7a      	ldr	r3, [pc, #488]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d8a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009d8c:	497a      	ldr	r1, [pc, #488]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009d8e:	4618      	mov	r0, r3
 8009d90:	f7f7 f810 	bl	8000db4 <__aeabi_fmul>
 8009d94:	4603      	mov	r3, r0
 8009d96:	461a      	mov	r2, r3
 8009d98:	4b76      	ldr	r3, [pc, #472]	; (8009f74 <gc_execute_block+0x3d58>)
 8009d9a:	655a      	str	r2, [r3, #84]	; 0x54
                    if(gc_state.modal.scaling_active) {
 8009d9c:	4b77      	ldr	r3, [pc, #476]	; (8009f7c <gc_execute_block+0x3d60>)
 8009d9e:	7f9b      	ldrb	r3, [r3, #30]
 8009da0:	2b00      	cmp	r3, #0
 8009da2:	d017      	beq.n	8009dd4 <gc_execute_block+0x3bb8>
                        gc_block.values.p *= scale_factor.ijk[X_AXIS];
 8009da4:	4b73      	ldr	r3, [pc, #460]	; (8009f74 <gc_execute_block+0x3d58>)
 8009da6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009da8:	4a75      	ldr	r2, [pc, #468]	; (8009f80 <gc_execute_block+0x3d64>)
 8009daa:	68d2      	ldr	r2, [r2, #12]
 8009dac:	4611      	mov	r1, r2
 8009dae:	4618      	mov	r0, r3
 8009db0:	f7f7 f800 	bl	8000db4 <__aeabi_fmul>
 8009db4:	4603      	mov	r3, r0
 8009db6:	461a      	mov	r2, r3
 8009db8:	4b6e      	ldr	r3, [pc, #440]	; (8009f74 <gc_execute_block+0x3d58>)
 8009dba:	651a      	str	r2, [r3, #80]	; 0x50
                        gc_block.values.q *= scale_factor.ijk[Y_AXIS];
 8009dbc:	4b6d      	ldr	r3, [pc, #436]	; (8009f74 <gc_execute_block+0x3d58>)
 8009dbe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009dc0:	4a6f      	ldr	r2, [pc, #444]	; (8009f80 <gc_execute_block+0x3d64>)
 8009dc2:	6912      	ldr	r2, [r2, #16]
 8009dc4:	4611      	mov	r1, r2
 8009dc6:	4618      	mov	r0, r3
 8009dc8:	f7f6 fff4 	bl	8000db4 <__aeabi_fmul>
 8009dcc:	4603      	mov	r3, r0
 8009dce:	461a      	mov	r2, r3
 8009dd0:	4b68      	ldr	r3, [pc, #416]	; (8009f74 <gc_execute_block+0x3d58>)
 8009dd2:	655a      	str	r2, [r3, #84]	; 0x54
                    gc_state.modal.spline_pq[X_AXIS] = gc_block.values.p;
 8009dd4:	4b67      	ldr	r3, [pc, #412]	; (8009f74 <gc_execute_block+0x3d58>)
 8009dd6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009dd8:	4a68      	ldr	r2, [pc, #416]	; (8009f7c <gc_execute_block+0x3d60>)
 8009dda:	6213      	str	r3, [r2, #32]
                    gc_state.modal.spline_pq[Y_AXIS] = gc_block.values.q;
 8009ddc:	4b65      	ldr	r3, [pc, #404]	; (8009f74 <gc_execute_block+0x3d58>)
 8009dde:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009de0:	4a66      	ldr	r2, [pc, #408]	; (8009f7c <gc_execute_block+0x3d60>)
 8009de2:	6253      	str	r3, [r2, #36]	; 0x24
                    gc_block.words.p = gc_block.words.q = gc_block.words.i = gc_block.words.j = Off;
 8009de4:	4a63      	ldr	r2, [pc, #396]	; (8009f74 <gc_execute_block+0x3d58>)
 8009de6:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009dea:	f36f 1345 	bfc	r3, #5, #1
 8009dee:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009df2:	4b60      	ldr	r3, [pc, #384]	; (8009f74 <gc_execute_block+0x3d58>)
 8009df4:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009df8:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009dfc:	b2d9      	uxtb	r1, r3
 8009dfe:	4a5d      	ldr	r2, [pc, #372]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e00:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009e04:	f361 1304 	bfi	r3, r1, #4, #1
 8009e08:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009e0c:	4b59      	ldr	r3, [pc, #356]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e0e:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009e12:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8009e16:	b2d9      	uxtb	r1, r3
 8009e18:	4a56      	ldr	r2, [pc, #344]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e1a:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8009e1e:	f361 0341 	bfi	r3, r1, #1, #1
 8009e22:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8009e26:	4b53      	ldr	r3, [pc, #332]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e28:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009e2c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8009e30:	b2d9      	uxtb	r1, r3
 8009e32:	4a50      	ldr	r2, [pc, #320]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e34:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8009e38:	f361 0300 	bfi	r3, r1, #0, #1
 8009e3c:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
                    break;
 8009e40:	e0b6      	b.n	8009fb0 <gc_execute_block+0x3d94>
                    if(gc_block.modal.plane_select != PlaneSelect_XY)
 8009e42:	4b4c      	ldr	r3, [pc, #304]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e44:	7b9b      	ldrb	r3, [r3, #14]
 8009e46:	2b00      	cmp	r3, #0
 8009e48:	d002      	beq.n	8009e50 <gc_execute_block+0x3c34>
                        FAIL(Status_GcodeIllegalPlane); // [The active plane is not G17]
 8009e4a:	232a      	movs	r3, #42	; 0x2a
 8009e4c:	f001 bcde 	b.w	800b80c <gc_execute_block+0x55f0>
                    if (axis_words.mask & ~(bit(X_AXIS)|bit(Y_AXIS)))
 8009e50:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009e54:	f023 0303 	bic.w	r3, r3, #3
 8009e58:	2b00      	cmp	r3, #0
 8009e5a:	d002      	beq.n	8009e62 <gc_execute_block+0x3c46>
                        FAIL(Status_GcodeAxisCommandConflict); // [An axis other than X or Y is specified]
 8009e5c:	2318      	movs	r3, #24
 8009e5e:	f001 bcd5 	b.w	800b80c <gc_execute_block+0x55f0>
                    if((gc_block.words.mask & ij_words.mask) != ij_words.mask)
 8009e62:	4b44      	ldr	r3, [pc, #272]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e64:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8009e68:	4b46      	ldr	r3, [pc, #280]	; (8009f84 <gc_execute_block+0x3d68>)
 8009e6a:	681b      	ldr	r3, [r3, #0]
 8009e6c:	401a      	ands	r2, r3
 8009e6e:	4b45      	ldr	r3, [pc, #276]	; (8009f84 <gc_execute_block+0x3d68>)
 8009e70:	681b      	ldr	r3, [r3, #0]
 8009e72:	429a      	cmp	r2, r3
 8009e74:	d002      	beq.n	8009e7c <gc_execute_block+0x3c60>
                        FAIL(Status_GcodeValueWordMissing); // [I or J are unspecified]
 8009e76:	231c      	movs	r3, #28
 8009e78:	f001 bcc8 	b.w	800b80c <gc_execute_block+0x55f0>
                    if(gc_block.values.ijk[I_VALUE] == 0.0f && gc_block.values.ijk[I_VALUE] == 0.0f)
 8009e7c:	4b3d      	ldr	r3, [pc, #244]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009e80:	f04f 0100 	mov.w	r1, #0
 8009e84:	4618      	mov	r0, r3
 8009e86:	f7f7 f929 	bl	80010dc <__aeabi_fcmpeq>
 8009e8a:	4603      	mov	r3, r0
 8009e8c:	2b00      	cmp	r3, #0
 8009e8e:	d00c      	beq.n	8009eaa <gc_execute_block+0x3c8e>
 8009e90:	4b38      	ldr	r3, [pc, #224]	; (8009f74 <gc_execute_block+0x3d58>)
 8009e92:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009e94:	f04f 0100 	mov.w	r1, #0
 8009e98:	4618      	mov	r0, r3
 8009e9a:	f7f7 f91f 	bl	80010dc <__aeabi_fcmpeq>
 8009e9e:	4603      	mov	r3, r0
 8009ea0:	2b00      	cmp	r3, #0
 8009ea2:	d002      	beq.n	8009eaa <gc_execute_block+0x3c8e>
                        FAIL(Status_GcodeValueOutOfRange); // [I or J are zero]
 8009ea4:	2327      	movs	r3, #39	; 0x27
 8009ea6:	f001 bcb1 	b.w	800b80c <gc_execute_block+0x55f0>
                    if (gc_block.modal.units_imperial) {
 8009eaa:	4b32      	ldr	r3, [pc, #200]	; (8009f74 <gc_execute_block+0x3d58>)
 8009eac:	7adb      	ldrb	r3, [r3, #11]
 8009eae:	2b00      	cmp	r3, #0
 8009eb0:	d013      	beq.n	8009eda <gc_execute_block+0x3cbe>
                        gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 8009eb2:	4b30      	ldr	r3, [pc, #192]	; (8009f74 <gc_execute_block+0x3d58>)
 8009eb4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009eb6:	4930      	ldr	r1, [pc, #192]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009eb8:	4618      	mov	r0, r3
 8009eba:	f7f6 ff7b 	bl	8000db4 <__aeabi_fmul>
 8009ebe:	4603      	mov	r3, r0
 8009ec0:	461a      	mov	r2, r3
 8009ec2:	4b2c      	ldr	r3, [pc, #176]	; (8009f74 <gc_execute_block+0x3d58>)
 8009ec4:	63da      	str	r2, [r3, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8009ec6:	4b2b      	ldr	r3, [pc, #172]	; (8009f74 <gc_execute_block+0x3d58>)
 8009ec8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009eca:	492b      	ldr	r1, [pc, #172]	; (8009f78 <gc_execute_block+0x3d5c>)
 8009ecc:	4618      	mov	r0, r3
 8009ece:	f7f6 ff71 	bl	8000db4 <__aeabi_fmul>
 8009ed2:	4603      	mov	r3, r0
 8009ed4:	461a      	mov	r2, r3
 8009ed6:	4b27      	ldr	r3, [pc, #156]	; (8009f74 <gc_execute_block+0x3d58>)
 8009ed8:	641a      	str	r2, [r3, #64]	; 0x40
                    if(gc_state.modal.scaling_active) {
 8009eda:	4b28      	ldr	r3, [pc, #160]	; (8009f7c <gc_execute_block+0x3d60>)
 8009edc:	7f9b      	ldrb	r3, [r3, #30]
 8009ede:	2b00      	cmp	r3, #0
 8009ee0:	d017      	beq.n	8009f12 <gc_execute_block+0x3cf6>
                        gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 8009ee2:	4b24      	ldr	r3, [pc, #144]	; (8009f74 <gc_execute_block+0x3d58>)
 8009ee4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009ee6:	4a26      	ldr	r2, [pc, #152]	; (8009f80 <gc_execute_block+0x3d64>)
 8009ee8:	68d2      	ldr	r2, [r2, #12]
 8009eea:	4611      	mov	r1, r2
 8009eec:	4618      	mov	r0, r3
 8009eee:	f7f6 ff61 	bl	8000db4 <__aeabi_fmul>
 8009ef2:	4603      	mov	r3, r0
 8009ef4:	461a      	mov	r2, r3
 8009ef6:	4b1f      	ldr	r3, [pc, #124]	; (8009f74 <gc_execute_block+0x3d58>)
 8009ef8:	63da      	str	r2, [r3, #60]	; 0x3c
                        gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 8009efa:	4b1e      	ldr	r3, [pc, #120]	; (8009f74 <gc_execute_block+0x3d58>)
 8009efc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009efe:	4a20      	ldr	r2, [pc, #128]	; (8009f80 <gc_execute_block+0x3d64>)
 8009f00:	6912      	ldr	r2, [r2, #16]
 8009f02:	4611      	mov	r1, r2
 8009f04:	4618      	mov	r0, r3
 8009f06:	f7f6 ff55 	bl	8000db4 <__aeabi_fmul>
 8009f0a:	4603      	mov	r3, r0
 8009f0c:	461a      	mov	r2, r3
 8009f0e:	4b19      	ldr	r3, [pc, #100]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f10:	641a      	str	r2, [r3, #64]	; 0x40
                    gc_block.words.i = gc_block.words.j = Off;
 8009f12:	4a18      	ldr	r2, [pc, #96]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f14:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009f18:	f36f 1345 	bfc	r3, #5, #1
 8009f1c:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
 8009f20:	4b14      	ldr	r3, [pc, #80]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f22:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 8009f26:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009f2a:	b2d9      	uxtb	r1, r3
 8009f2c:	4a11      	ldr	r2, [pc, #68]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f2e:	f892 3094 	ldrb.w	r3, [r2, #148]	; 0x94
 8009f32:	f361 1304 	bfi	r3, r1, #4, #1
 8009f36:	f882 3094 	strb.w	r3, [r2, #148]	; 0x94
                    break;
 8009f3a:	e039      	b.n	8009fb0 <gc_execute_block+0x3d94>
                    gc_parser_flags.probe_is_no_error = On;
 8009f3c:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8009f40:	f043 0310 	orr.w	r3, r3, #16
 8009f44:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
                    if(gc_block.modal.motion == MotionMode_ProbeAway || gc_block.modal.motion == MotionMode_ProbeAwayNoError)
 8009f48:	4b0a      	ldr	r3, [pc, #40]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f4a:	891b      	ldrh	r3, [r3, #8]
 8009f4c:	2b8e      	cmp	r3, #142	; 0x8e
 8009f4e:	d003      	beq.n	8009f58 <gc_execute_block+0x3d3c>
 8009f50:	4b08      	ldr	r3, [pc, #32]	; (8009f74 <gc_execute_block+0x3d58>)
 8009f52:	891b      	ldrh	r3, [r3, #8]
 8009f54:	2b8f      	cmp	r3, #143	; 0x8f
 8009f56:	d105      	bne.n	8009f64 <gc_execute_block+0x3d48>
                        gc_parser_flags.probe_is_away = On;
 8009f58:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8009f5c:	f043 0308 	orr.w	r3, r3, #8
 8009f60:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
                    if (!axis_words.mask)
 8009f64:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8009f68:	2b00      	cmp	r3, #0
 8009f6a:	d10d      	bne.n	8009f88 <gc_execute_block+0x3d6c>
                        FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8009f6c:	231a      	movs	r3, #26
 8009f6e:	f001 bc4d 	b.w	800b80c <gc_execute_block+0x55f0>
 8009f72:	bf00      	nop
 8009f74:	20000c8c 	.word	0x20000c8c
 8009f78:	41cb3333 	.word	0x41cb3333
 8009f7c:	20000bb0 	.word	0x20000bb0
 8009f80:	20000248 	.word	0x20000248
 8009f84:	08030c80 	.word	0x08030c80
                    if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8009f88:	220c      	movs	r2, #12
 8009f8a:	49b1      	ldr	r1, [pc, #708]	; (800a250 <gc_execute_block+0x4034>)
 8009f8c:	48b1      	ldr	r0, [pc, #708]	; (800a254 <gc_execute_block+0x4038>)
 8009f8e:	f019 fe32 	bl	8023bf6 <memcmp>
 8009f92:	4603      	mov	r3, r0
 8009f94:	2b00      	cmp	r3, #0
 8009f96:	d10a      	bne.n	8009fae <gc_execute_block+0x3d92>
                        FAIL(Status_GcodeInvalidTarget); // [Invalid target]
 8009f98:	2321      	movs	r3, #33	; 0x21
 8009f9a:	f001 bc37 	b.w	800b80c <gc_execute_block+0x55f0>
                        break;
 8009f9e:	bf00      	nop
 8009fa0:	e006      	b.n	8009fb0 <gc_execute_block+0x3d94>
                        break;
 8009fa2:	bf00      	nop
 8009fa4:	e004      	b.n	8009fb0 <gc_execute_block+0x3d94>
                    break;
 8009fa6:	bf00      	nop
 8009fa8:	e002      	b.n	8009fb0 <gc_execute_block+0x3d94>
                    break;
 8009faa:	bf00      	nop
 8009fac:	e000      	b.n	8009fb0 <gc_execute_block+0x3d94>
                    break;
 8009fae:	bf00      	nop

    // [21. Program flow ]: No error checks required.

    // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
    // radius mode, or axis words that aren't used in the block.
    if (gc_parser_flags.jog_motion) // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
 8009fb0:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 8009fb4:	f003 0301 	and.w	r3, r3, #1
 8009fb8:	b2db      	uxtb	r3, r3
 8009fba:	2b00      	cmp	r3, #0
 8009fbc:	d014      	beq.n	8009fe8 <gc_execute_block+0x3dcc>
        gc_block.words.n = gc_block.words.f = Off;
 8009fbe:	4aa6      	ldr	r2, [pc, #664]	; (800a258 <gc_execute_block+0x403c>)
 8009fc0:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8009fc4:	f36f 0341 	bfc	r3, #1, #1
 8009fc8:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 8009fcc:	4ba2      	ldr	r3, [pc, #648]	; (800a258 <gc_execute_block+0x403c>)
 8009fce:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 8009fd2:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8009fd6:	b2d9      	uxtb	r1, r3
 8009fd8:	4a9f      	ldr	r2, [pc, #636]	; (800a258 <gc_execute_block+0x403c>)
 8009fda:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 8009fde:	f361 1386 	bfi	r3, r1, #6, #1
 8009fe2:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 8009fe6:	e02d      	b.n	800a044 <gc_execute_block+0x3e28>
    else
        gc_block.words.n = gc_block.words.f = gc_block.words.s = gc_block.words.t = Off;
 8009fe8:	4a9b      	ldr	r2, [pc, #620]	; (800a258 <gc_execute_block+0x403c>)
 8009fea:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 8009fee:	f36f 1304 	bfc	r3, #4, #1
 8009ff2:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 8009ff6:	4b98      	ldr	r3, [pc, #608]	; (800a258 <gc_execute_block+0x403c>)
 8009ff8:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8009ffc:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a000:	b2d9      	uxtb	r1, r3
 800a002:	4a95      	ldr	r2, [pc, #596]	; (800a258 <gc_execute_block+0x403c>)
 800a004:	f892 3096 	ldrb.w	r3, [r2, #150]	; 0x96
 800a008:	f361 03c3 	bfi	r3, r1, #3, #1
 800a00c:	f882 3096 	strb.w	r3, [r2, #150]	; 0x96
 800a010:	4b91      	ldr	r3, [pc, #580]	; (800a258 <gc_execute_block+0x403c>)
 800a012:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 800a016:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a01a:	b2d9      	uxtb	r1, r3
 800a01c:	4a8e      	ldr	r2, [pc, #568]	; (800a258 <gc_execute_block+0x403c>)
 800a01e:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 800a022:	f361 0341 	bfi	r3, r1, #1, #1
 800a026:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95
 800a02a:	4b8b      	ldr	r3, [pc, #556]	; (800a258 <gc_execute_block+0x403c>)
 800a02c:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800a030:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800a034:	b2d9      	uxtb	r1, r3
 800a036:	4a88      	ldr	r2, [pc, #544]	; (800a258 <gc_execute_block+0x403c>)
 800a038:	f892 3095 	ldrb.w	r3, [r2, #149]	; 0x95
 800a03c:	f361 1386 	bfi	r3, r1, #6, #1
 800a040:	f882 3095 	strb.w	r3, [r2, #149]	; 0x95

    if (axis_command)
 800a044:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800a048:	2b00      	cmp	r3, #0
 800a04a:	d009      	beq.n	800a060 <gc_execute_block+0x3e44>
        gc_block.words.mask &= ~axis_words_mask.mask; // Remove axis words.
 800a04c:	4b82      	ldr	r3, [pc, #520]	; (800a258 <gc_execute_block+0x403c>)
 800a04e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800a052:	4b82      	ldr	r3, [pc, #520]	; (800a25c <gc_execute_block+0x4040>)
 800a054:	681b      	ldr	r3, [r3, #0]
 800a056:	43db      	mvns	r3, r3
 800a058:	4013      	ands	r3, r2
 800a05a:	4a7f      	ldr	r2, [pc, #508]	; (800a258 <gc_execute_block+0x403c>)
 800a05c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

    if (gc_block.words.mask)
 800a060:	4b7d      	ldr	r3, [pc, #500]	; (800a258 <gc_execute_block+0x403c>)
 800a062:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800a066:	2b00      	cmp	r3, #0
 800a068:	d002      	beq.n	800a070 <gc_execute_block+0x3e54>
        FAIL(Status_GcodeUnusedWords); // [Unused words]
 800a06a:	2324      	movs	r3, #36	; 0x24
 800a06c:	f001 bbce 	b.w	800b80c <gc_execute_block+0x55f0>
     need to update the state and execute the block according to the order-of-execution.
    */

    // Initialize planner data struct for motion blocks.
    plan_line_data_t plan_data;
    memset(&plan_data, 0, sizeof(plan_line_data_t)); // Zero plan_data struct
 800a070:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800a074:	222c      	movs	r2, #44	; 0x2c
 800a076:	2100      	movs	r1, #0
 800a078:	4618      	mov	r0, r3
 800a07a:	f019 fdcc 	bl	8023c16 <memset>
    plan_data.condition.target_validated = plan_data.condition.target_valid = sys.soft_limits.mask == 0;
 800a07e:	4b78      	ldr	r3, [pc, #480]	; (800a260 <gc_execute_block+0x4044>)
 800a080:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800a084:	2b00      	cmp	r3, #0
 800a086:	bf0c      	ite	eq
 800a088:	2301      	moveq	r3, #1
 800a08a:	2300      	movne	r3, #0
 800a08c:	b2da      	uxtb	r2, r3
 800a08e:	f897 3079 	ldrb.w	r3, [r7, #121]	; 0x79
 800a092:	f362 0300 	bfi	r3, r2, #0, #1
 800a096:	f887 3079 	strb.w	r3, [r7, #121]	; 0x79
 800a09a:	f897 3079 	ldrb.w	r3, [r7, #121]	; 0x79
 800a09e:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800a0a2:	b2da      	uxtb	r2, r3
 800a0a4:	f897 3079 	ldrb.w	r3, [r7, #121]	; 0x79
 800a0a8:	f362 0341 	bfi	r3, r2, #1, #1
 800a0ac:	f887 3079 	strb.w	r3, [r7, #121]	; 0x79

    // Intercept jog commands and complete error checking for valid jog commands and execute.
    // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
    // targets are computed correctly. The final parser position after a jog is updated in
    // protocol_execute_realtime() when jogging completes or is canceled.
    if (gc_parser_flags.jog_motion) {
 800a0b0:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a0b4:	f003 0301 	and.w	r3, r3, #1
 800a0b8:	b2db      	uxtb	r3, r3
 800a0ba:	2b00      	cmp	r3, #0
 800a0bc:	d05f      	beq.n	800a17e <gc_execute_block+0x3f62>

        // Only distance and unit modal commands and G53 absolute override command are allowed.
        // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
        if (command_words.mask & ~jog_groups.mask)
 800a0be:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 800a0c2:	4b68      	ldr	r3, [pc, #416]	; (800a264 <gc_execute_block+0x4048>)
 800a0c4:	681b      	ldr	r3, [r3, #0]
 800a0c6:	43db      	mvns	r3, r3
 800a0c8:	4013      	ands	r3, r2
 800a0ca:	2b00      	cmp	r3, #0
 800a0cc:	d002      	beq.n	800a0d4 <gc_execute_block+0x3eb8>
            FAIL(Status_InvalidJogCommand);
 800a0ce:	2310      	movs	r3, #16
 800a0d0:	f001 bb9c 	b.w	800b80c <gc_execute_block+0x55f0>

        if (!(gc_block.non_modal_command == NonModal_AbsoluteOverride || gc_block.non_modal_command == NonModal_NoAction))
 800a0d4:	4b60      	ldr	r3, [pc, #384]	; (800a258 <gc_execute_block+0x403c>)
 800a0d6:	781b      	ldrb	r3, [r3, #0]
 800a0d8:	2b35      	cmp	r3, #53	; 0x35
 800a0da:	d006      	beq.n	800a0ea <gc_execute_block+0x3ece>
 800a0dc:	4b5e      	ldr	r3, [pc, #376]	; (800a258 <gc_execute_block+0x403c>)
 800a0de:	781b      	ldrb	r3, [r3, #0]
 800a0e0:	2b00      	cmp	r3, #0
 800a0e2:	d002      	beq.n	800a0ea <gc_execute_block+0x3ece>
            FAIL(Status_InvalidJogCommand);
 800a0e4:	2310      	movs	r3, #16
 800a0e6:	f001 bb91 	b.w	800b80c <gc_execute_block+0x55f0>

        // Initialize planner data to current spindle and coolant modal state.
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 800a0ea:	4b5f      	ldr	r3, [pc, #380]	; (800a268 <gc_execute_block+0x404c>)
 800a0ec:	f107 0468 	add.w	r4, r7, #104	; 0x68
 800a0f0:	3344      	adds	r3, #68	; 0x44
 800a0f2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800a0f4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        plan_data.spindle.state = gc_state.modal.spindle.state;
 800a0f8:	4b5b      	ldr	r3, [pc, #364]	; (800a268 <gc_execute_block+0x404c>)
 800a0fa:	7e9b      	ldrb	r3, [r3, #26]
 800a0fc:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
        plan_data.condition.coolant = gc_state.modal.coolant;
 800a100:	4b59      	ldr	r3, [pc, #356]	; (800a268 <gc_execute_block+0x404c>)
 800a102:	7e5b      	ldrb	r3, [r3, #25]
 800a104:	f887 307a 	strb.w	r3, [r7, #122]	; 0x7a
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted || (gc_state.modal.spindle.state.ccw && gc_state.spindle.hal->cap.laser);
 800a108:	4b57      	ldr	r3, [pc, #348]	; (800a268 <gc_execute_block+0x404c>)
 800a10a:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
 800a10e:	2b00      	cmp	r3, #0
 800a110:	d10e      	bne.n	800a130 <gc_execute_block+0x3f14>
 800a112:	4b55      	ldr	r3, [pc, #340]	; (800a268 <gc_execute_block+0x404c>)
 800a114:	7e9b      	ldrb	r3, [r3, #26]
 800a116:	f003 0302 	and.w	r3, r3, #2
 800a11a:	b2db      	uxtb	r3, r3
 800a11c:	2b00      	cmp	r3, #0
 800a11e:	d009      	beq.n	800a134 <gc_execute_block+0x3f18>
 800a120:	4b51      	ldr	r3, [pc, #324]	; (800a268 <gc_execute_block+0x404c>)
 800a122:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a124:	7a9b      	ldrb	r3, [r3, #10]
 800a126:	f003 0308 	and.w	r3, r3, #8
 800a12a:	b2db      	uxtb	r3, r3
 800a12c:	2b00      	cmp	r3, #0
 800a12e:	d001      	beq.n	800a134 <gc_execute_block+0x3f18>
 800a130:	2301      	movs	r3, #1
 800a132:	e000      	b.n	800a136 <gc_execute_block+0x3f1a>
 800a134:	2300      	movs	r3, #0
 800a136:	f003 0301 	and.w	r3, r3, #1
 800a13a:	b2da      	uxtb	r2, r3
 800a13c:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800a140:	f362 1386 	bfi	r3, r2, #6, #1
 800a144:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78

        if ((status_code_t)(int_value = (uint_fast16_t)mc_jog_execute(&plan_data, &gc_block, gc_state.position)) == Status_OK)
 800a148:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800a14c:	4a41      	ldr	r2, [pc, #260]	; (800a254 <gc_execute_block+0x4038>)
 800a14e:	4942      	ldr	r1, [pc, #264]	; (800a258 <gc_execute_block+0x403c>)
 800a150:	4618      	mov	r0, r3
 800a152:	f004 feb9 	bl	800eec8 <mc_jog_execute>
 800a156:	4603      	mov	r3, r0
 800a158:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800a15c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800a160:	b2db      	uxtb	r3, r3
 800a162:	2b00      	cmp	r3, #0
 800a164:	d106      	bne.n	800a174 <gc_execute_block+0x3f58>
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position));
 800a166:	4b40      	ldr	r3, [pc, #256]	; (800a268 <gc_execute_block+0x404c>)
 800a168:	4a3b      	ldr	r2, [pc, #236]	; (800a258 <gc_execute_block+0x403c>)
 800a16a:	335c      	adds	r3, #92	; 0x5c
 800a16c:	3260      	adds	r2, #96	; 0x60
 800a16e:	ca07      	ldmia	r2, {r0, r1, r2}
 800a170:	e883 0007 	stmia.w	r3, {r0, r1, r2}

        return (status_code_t)int_value;
 800a174:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800a178:	b2db      	uxtb	r3, r3
 800a17a:	f001 bb47 	b.w	800b80c <gc_execute_block+0x55f0>
    }

    // If in laser mode, setup laser power based on current and past parser conditions.
    if(gc_state.spindle.hal->cap.laser) {
 800a17e:	4b3a      	ldr	r3, [pc, #232]	; (800a268 <gc_execute_block+0x404c>)
 800a180:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a182:	7a9b      	ldrb	r3, [r3, #10]
 800a184:	f003 0308 	and.w	r3, r3, #8
 800a188:	b2db      	uxtb	r3, r3
 800a18a:	2b00      	cmp	r3, #0
 800a18c:	d075      	beq.n	800a27a <gc_execute_block+0x405e>

        if(!motion_is_lasercut(gc_block.modal.motion))
 800a18e:	4b32      	ldr	r3, [pc, #200]	; (800a258 <gc_execute_block+0x403c>)
 800a190:	891b      	ldrh	r3, [r3, #8]
 800a192:	4618      	mov	r0, r3
 800a194:	f7fb fb8f 	bl	80058b6 <motion_is_lasercut>
 800a198:	4603      	mov	r3, r0
 800a19a:	f083 0301 	eor.w	r3, r3, #1
 800a19e:	b2db      	uxtb	r3, r3
 800a1a0:	2b00      	cmp	r3, #0
 800a1a2:	d005      	beq.n	800a1b0 <gc_execute_block+0x3f94>
            gc_parser_flags.laser_disable = On;
 800a1a4:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a1a8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a1ac:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c

        // Any motion mode with axis words is allowed to be passed from a spindle speed update.
        // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
        // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
        if(axis_words.mask && (axis_command == AxisCommand_MotionMode))
 800a1b0:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800a1b4:	2b00      	cmp	r3, #0
 800a1b6:	d00a      	beq.n	800a1ce <gc_execute_block+0x3fb2>
 800a1b8:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800a1bc:	2b02      	cmp	r3, #2
 800a1be:	d106      	bne.n	800a1ce <gc_execute_block+0x3fb2>
            gc_parser_flags.laser_is_motion = On;
 800a1c0:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a1c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a1c8:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
 800a1cc:	e030      	b.n	800a230 <gc_execute_block+0x4014>
        else if(gc_state.modal.spindle.state.on && !gc_state.modal.spindle.state.ccw) {
 800a1ce:	4b26      	ldr	r3, [pc, #152]	; (800a268 <gc_execute_block+0x404c>)
 800a1d0:	7e9b      	ldrb	r3, [r3, #26]
 800a1d2:	f003 0301 	and.w	r3, r3, #1
 800a1d6:	b2db      	uxtb	r3, r3
 800a1d8:	2b00      	cmp	r3, #0
 800a1da:	d029      	beq.n	800a230 <gc_execute_block+0x4014>
 800a1dc:	4b22      	ldr	r3, [pc, #136]	; (800a268 <gc_execute_block+0x404c>)
 800a1de:	7e9b      	ldrb	r3, [r3, #26]
 800a1e0:	f003 0302 	and.w	r3, r3, #2
 800a1e4:	b2db      	uxtb	r3, r3
 800a1e6:	2b00      	cmp	r3, #0
 800a1e8:	d122      	bne.n	800a230 <gc_execute_block+0x4014>
            // M3 constant power laser requires planner syncs to update the laser when changing between
            // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
            if(motion_is_lasercut(gc_state.modal.motion)) {
 800a1ea:	4b1f      	ldr	r3, [pc, #124]	; (800a268 <gc_execute_block+0x404c>)
 800a1ec:	881b      	ldrh	r3, [r3, #0]
 800a1ee:	4618      	mov	r0, r3
 800a1f0:	f7fb fb61 	bl	80058b6 <motion_is_lasercut>
 800a1f4:	4603      	mov	r3, r0
 800a1f6:	2b00      	cmp	r3, #0
 800a1f8:	d00d      	beq.n	800a216 <gc_execute_block+0x3ffa>
                if(gc_parser_flags.laser_disable)
 800a1fa:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a1fe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a202:	b2db      	uxtb	r3, r3
 800a204:	2b00      	cmp	r3, #0
 800a206:	d013      	beq.n	800a230 <gc_execute_block+0x4014>
                    gc_parser_flags.spindle_force_sync = On; // Change from G1/2/3 motion mode.
 800a208:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a20c:	f043 0320 	orr.w	r3, r3, #32
 800a210:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
 800a214:	e00c      	b.n	800a230 <gc_execute_block+0x4014>
            } else if(!gc_parser_flags.laser_disable) // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
 800a216:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a21a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a21e:	b2db      	uxtb	r3, r3
 800a220:	2b00      	cmp	r3, #0
 800a222:	d105      	bne.n	800a230 <gc_execute_block+0x4014>
                gc_parser_flags.spindle_force_sync = On;
 800a224:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a228:	f043 0320 	orr.w	r3, r3, #32
 800a22c:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
        }

        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.state.ccw && !gc_parser_flags.laser_disable;
 800a230:	4b0d      	ldr	r3, [pc, #52]	; (800a268 <gc_execute_block+0x404c>)
 800a232:	7e9b      	ldrb	r3, [r3, #26]
 800a234:	f003 0302 	and.w	r3, r3, #2
 800a238:	b2db      	uxtb	r3, r3
 800a23a:	2b00      	cmp	r3, #0
 800a23c:	d016      	beq.n	800a26c <gc_execute_block+0x4050>
 800a23e:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a242:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a246:	b2db      	uxtb	r3, r3
 800a248:	2b00      	cmp	r3, #0
 800a24a:	d10f      	bne.n	800a26c <gc_execute_block+0x4050>
 800a24c:	2301      	movs	r3, #1
 800a24e:	e00e      	b.n	800a26e <gc_execute_block+0x4052>
 800a250:	20000cec 	.word	0x20000cec
 800a254:	20000c0c 	.word	0x20000c0c
 800a258:	20000c8c 	.word	0x20000c8c
 800a25c:	08030c78 	.word	0x08030c78
 800a260:	20000d3c 	.word	0x20000d3c
 800a264:	08030c84 	.word	0x08030c84
 800a268:	20000bb0 	.word	0x20000bb0
 800a26c:	2300      	movs	r3, #0
 800a26e:	f003 0301 	and.w	r3, r3, #1
 800a272:	b2da      	uxtb	r2, r3
 800a274:	4b93      	ldr	r3, [pc, #588]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a276:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72
    }

    // [0. Non-specific/common error-checks and miscellaneous setup]:
    // NOTE: If no line number is present, the value is zero.
    gc_state.line_number = gc_block.values.n;
 800a27a:	4b93      	ldr	r3, [pc, #588]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a27c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a280:	4a90      	ldr	r2, [pc, #576]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a282:	6693      	str	r3, [r2, #104]	; 0x68
    plan_data.line_number = gc_state.line_number; // Record data for planner use.
 800a284:	4b8f      	ldr	r3, [pc, #572]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a286:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800a288:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    bool check_mode = state_get() == STATE_CHECK_MODE;
 800a28c:	f013 fb18 	bl	801d8c0 <state_get>
 800a290:	4603      	mov	r3, r0
 800a292:	2b02      	cmp	r3, #2
 800a294:	bf0c      	ite	eq
 800a296:	2301      	moveq	r3, #1
 800a298:	2300      	movne	r3, #0
 800a29a:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7

    // [1. Comments feedback ]: Extracted in protocol.c if HAL entry point provided
    if(message && !check_mode && (plan_data.message = malloc(strlen(message) + 1)))
 800a29e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800a2a2:	2b00      	cmp	r3, #0
 800a2a4:	d01f      	beq.n	800a2e6 <gc_execute_block+0x40ca>
 800a2a6:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800a2aa:	f083 0301 	eor.w	r3, r3, #1
 800a2ae:	b2db      	uxtb	r3, r3
 800a2b0:	2b00      	cmp	r3, #0
 800a2b2:	d018      	beq.n	800a2e6 <gc_execute_block+0x40ca>
 800a2b4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800a2b8:	4618      	mov	r0, r3
 800a2ba:	f7f5 ffbf 	bl	800023c <strlen>
 800a2be:	4603      	mov	r3, r0
 800a2c0:	3301      	adds	r3, #1
 800a2c2:	4618      	mov	r0, r3
 800a2c4:	f019 f8f8 	bl	80234b8 <malloc>
 800a2c8:	4603      	mov	r3, r0
 800a2ca:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800a2ce:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a2d2:	2b00      	cmp	r3, #0
 800a2d4:	d007      	beq.n	800a2e6 <gc_execute_block+0x40ca>
        strcpy(plan_data.message, message);
 800a2d6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a2da:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 800a2de:	4611      	mov	r1, r2
 800a2e0:	4618      	mov	r0, r3
 800a2e2:	f019 fdec 	bl	8023ebe <strcpy>

    // [2. Set feed rate mode ]:
    gc_state.modal.feed_mode = gc_block.modal.feed_mode;
 800a2e6:	4b78      	ldr	r3, [pc, #480]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a2e8:	7a9a      	ldrb	r2, [r3, #10]
 800a2ea:	4b76      	ldr	r3, [pc, #472]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a2ec:	709a      	strb	r2, [r3, #2]
    if (gc_state.modal.feed_mode == FeedMode_InverseTime)
 800a2ee:	4b75      	ldr	r3, [pc, #468]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a2f0:	789b      	ldrb	r3, [r3, #2]
 800a2f2:	2b01      	cmp	r3, #1
 800a2f4:	d105      	bne.n	800a302 <gc_execute_block+0x40e6>
        plan_data.condition.inverse_time = On; // Set condition flag for planner use.
 800a2f6:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800a2fa:	f043 0320 	orr.w	r3, r3, #32
 800a2fe:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78

    // [3. Set feed rate ]:
    gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 800a302:	4b71      	ldr	r3, [pc, #452]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a304:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a306:	4a6f      	ldr	r2, [pc, #444]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a308:	6553      	str	r3, [r2, #84]	; 0x54
    plan_data.feed_rate = gc_state.feed_rate; // Record data for planner use.
 800a30a:	4b6e      	ldr	r3, [pc, #440]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a30c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a30e:	663b      	str	r3, [r7, #96]	; 0x60

    // [4. Set spindle speed ]:
    if(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS) {
 800a310:	4b6c      	ldr	r3, [pc, #432]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a312:	7edb      	ldrb	r3, [r3, #27]
 800a314:	2b01      	cmp	r3, #1
 800a316:	d17b      	bne.n	800a410 <gc_execute_block+0x41f4>
        if(gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek) {
 800a318:	4b6b      	ldr	r3, [pc, #428]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a31a:	891b      	ldrh	r3, [r3, #8]
 800a31c:	2b50      	cmp	r3, #80	; 0x50
 800a31e:	d06a      	beq.n	800a3f6 <gc_execute_block+0x41da>
 800a320:	4b69      	ldr	r3, [pc, #420]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a322:	891b      	ldrh	r3, [r3, #8]
 800a324:	2b00      	cmp	r3, #0
 800a326:	d066      	beq.n	800a3f6 <gc_execute_block+0x41da>
            gc_state.spindle.css = &gc_state.spindle.hal->param->css;
 800a328:	4b66      	ldr	r3, [pc, #408]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a32a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a32c:	685b      	ldr	r3, [r3, #4]
 800a32e:	3310      	adds	r3, #16
 800a330:	4a64      	ldr	r2, [pc, #400]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a332:	64d3      	str	r3, [r2, #76]	; 0x4c
            gc_state.spindle.css->axis = plane.axis_1;
 800a334:	f897 20ad 	ldrb.w	r2, [r7, #173]	; 0xad
 800a338:	4b62      	ldr	r3, [pc, #392]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a33a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a33c:	615a      	str	r2, [r3, #20]
            gc_state.spindle.css->tool_offset = gc_get_offset(gc_state.spindle.css->axis);
 800a33e:	4b61      	ldr	r3, [pc, #388]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a340:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a342:	695b      	ldr	r3, [r3, #20]
 800a344:	4a5f      	ldr	r2, [pc, #380]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a346:	6cd4      	ldr	r4, [r2, #76]	; 0x4c
 800a348:	4618      	mov	r0, r3
 800a34a:	f7fb fb47 	bl	80059dc <gc_get_offset>
 800a34e:	4603      	mov	r3, r0
 800a350:	6123      	str	r3, [r4, #16]
            float pos = gc_state.position[gc_state.spindle.css->axis] - gc_state.spindle.css->tool_offset;
 800a352:	4b5c      	ldr	r3, [pc, #368]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a354:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a356:	695b      	ldr	r3, [r3, #20]
 800a358:	4a5a      	ldr	r2, [pc, #360]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a35a:	3316      	adds	r3, #22
 800a35c:	009b      	lsls	r3, r3, #2
 800a35e:	4413      	add	r3, r2
 800a360:	685a      	ldr	r2, [r3, #4]
 800a362:	4b58      	ldr	r3, [pc, #352]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a364:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a366:	691b      	ldr	r3, [r3, #16]
 800a368:	4619      	mov	r1, r3
 800a36a:	4610      	mov	r0, r2
 800a36c:	f7f6 fc18 	bl	8000ba0 <__aeabi_fsub>
 800a370:	4603      	mov	r3, r0
 800a372:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css->max_rpm : min(gc_state.spindle.css->max_rpm, gc_state.spindle.css->surface_speed / (pos * (float)(2.0f * M_PI)));
 800a376:	f04f 0100 	mov.w	r1, #0
 800a37a:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 800a37e:	f7f6 fec1 	bl	8001104 <__aeabi_fcmple>
 800a382:	4603      	mov	r3, r0
 800a384:	2b00      	cmp	r3, #0
 800a386:	d003      	beq.n	800a390 <gc_execute_block+0x4174>
 800a388:	4b4e      	ldr	r3, [pc, #312]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a38a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a38c:	68db      	ldr	r3, [r3, #12]
 800a38e:	e029      	b.n	800a3e4 <gc_execute_block+0x41c8>
 800a390:	4b4c      	ldr	r3, [pc, #304]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a392:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a394:	68dc      	ldr	r4, [r3, #12]
 800a396:	4b4b      	ldr	r3, [pc, #300]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a398:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a39a:	681d      	ldr	r5, [r3, #0]
 800a39c:	494b      	ldr	r1, [pc, #300]	; (800a4cc <gc_execute_block+0x42b0>)
 800a39e:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 800a3a2:	f7f6 fd07 	bl	8000db4 <__aeabi_fmul>
 800a3a6:	4603      	mov	r3, r0
 800a3a8:	4619      	mov	r1, r3
 800a3aa:	4628      	mov	r0, r5
 800a3ac:	f7f6 fdb6 	bl	8000f1c <__aeabi_fdiv>
 800a3b0:	4603      	mov	r3, r0
 800a3b2:	4619      	mov	r1, r3
 800a3b4:	4620      	mov	r0, r4
 800a3b6:	f7f6 fe9b 	bl	80010f0 <__aeabi_fcmplt>
 800a3ba:	4603      	mov	r3, r0
 800a3bc:	2b00      	cmp	r3, #0
 800a3be:	d003      	beq.n	800a3c8 <gc_execute_block+0x41ac>
 800a3c0:	4b40      	ldr	r3, [pc, #256]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a3c2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a3c4:	68db      	ldr	r3, [r3, #12]
 800a3c6:	e00d      	b.n	800a3e4 <gc_execute_block+0x41c8>
 800a3c8:	4b3e      	ldr	r3, [pc, #248]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a3ca:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a3cc:	681c      	ldr	r4, [r3, #0]
 800a3ce:	493f      	ldr	r1, [pc, #252]	; (800a4cc <gc_execute_block+0x42b0>)
 800a3d0:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 800a3d4:	f7f6 fcee 	bl	8000db4 <__aeabi_fmul>
 800a3d8:	4603      	mov	r3, r0
 800a3da:	4619      	mov	r1, r3
 800a3dc:	4620      	mov	r0, r4
 800a3de:	f7f6 fd9d 	bl	8000f1c <__aeabi_fdiv>
 800a3e2:	4603      	mov	r3, r0
 800a3e4:	4a38      	ldr	r2, [pc, #224]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a3e6:	65d3      	str	r3, [r2, #92]	; 0x5c
            gc_parser_flags.spindle_force_sync = On;
 800a3e8:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a3ec:	f043 0320 	orr.w	r3, r3, #32
 800a3f0:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
        if(gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek) {
 800a3f4:	e00c      	b.n	800a410 <gc_execute_block+0x41f4>
        } else {
            if(gc_state.spindle.css) {
 800a3f6:	4b33      	ldr	r3, [pc, #204]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a3f8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800a3fa:	2b00      	cmp	r3, #0
 800a3fc:	d004      	beq.n	800a408 <gc_execute_block+0x41ec>
                gc_state.spindle.css = NULL;
 800a3fe:	4b31      	ldr	r3, [pc, #196]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a400:	2200      	movs	r2, #0
 800a402:	64da      	str	r2, [r3, #76]	; 0x4c
                protocol_buffer_synchronize(); // Empty planner buffer to ensure we get RPM at end of last CSS motion
 800a404:	f008 fc7c 	bl	8012d00 <protocol_buffer_synchronize>
            }
            gc_block.values.s = gc_state.spindle.rpm; //gc_state.spindle.hal->param->rpm; // Keep current RPM
 800a408:	4b2e      	ldr	r3, [pc, #184]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a40a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a40c:	4a2e      	ldr	r2, [pc, #184]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a40e:	65d3      	str	r3, [r2, #92]	; 0x5c
        }
    }

    if(!user_words.s && ((gc_state.spindle.rpm != gc_block.values.s) || gc_parser_flags.spindle_force_sync)) {
 800a410:	4b2f      	ldr	r3, [pc, #188]	; (800a4d0 <gc_execute_block+0x42b4>)
 800a412:	789b      	ldrb	r3, [r3, #2]
 800a414:	f003 0308 	and.w	r3, r3, #8
 800a418:	b2db      	uxtb	r3, r3
 800a41a:	2b00      	cmp	r3, #0
 800a41c:	d143      	bne.n	800a4a6 <gc_execute_block+0x428a>
 800a41e:	4b29      	ldr	r3, [pc, #164]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a420:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a422:	4a29      	ldr	r2, [pc, #164]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a424:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800a426:	4611      	mov	r1, r2
 800a428:	4618      	mov	r0, r3
 800a42a:	f7f6 fe57 	bl	80010dc <__aeabi_fcmpeq>
 800a42e:	4603      	mov	r3, r0
 800a430:	2b00      	cmp	r3, #0
 800a432:	d006      	beq.n	800a442 <gc_execute_block+0x4226>
 800a434:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a438:	f003 0320 	and.w	r3, r3, #32
 800a43c:	b2db      	uxtb	r3, r3
 800a43e:	2b00      	cmp	r3, #0
 800a440:	d031      	beq.n	800a4a6 <gc_execute_block+0x428a>
        if(gc_state.modal.spindle.state.on && !gc_parser_flags.laser_is_motion) {
 800a442:	4b20      	ldr	r3, [pc, #128]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a444:	7e9b      	ldrb	r3, [r3, #26]
 800a446:	f003 0301 	and.w	r3, r3, #1
 800a44a:	b2db      	uxtb	r3, r3
 800a44c:	2b00      	cmp	r3, #0
 800a44e:	d026      	beq.n	800a49e <gc_execute_block+0x4282>
 800a450:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a454:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800a458:	b2db      	uxtb	r3, r3
 800a45a:	2b00      	cmp	r3, #0
 800a45c:	d11f      	bne.n	800a49e <gc_execute_block+0x4282>
            if(gc_block.spindle) {
 800a45e:	4b1a      	ldr	r3, [pc, #104]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a460:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a464:	2b00      	cmp	r3, #0
 800a466:	d01a      	beq.n	800a49e <gc_execute_block+0x4282>
                gc_block.spindle->param->rpm = gc_block.values.s;
 800a468:	4b17      	ldr	r3, [pc, #92]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a46a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a46e:	685b      	ldr	r3, [r3, #4]
 800a470:	4a15      	ldr	r2, [pc, #84]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a472:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800a474:	601a      	str	r2, [r3, #0]
                spindle_sync(gc_block.spindle, gc_state.modal.spindle.state, gc_parser_flags.laser_disable ? 0.0f : gc_block.values.s);
 800a476:	4b14      	ldr	r3, [pc, #80]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a478:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
 800a47c:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a480:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a484:	b2db      	uxtb	r3, r3
 800a486:	2b00      	cmp	r3, #0
 800a488:	d102      	bne.n	800a490 <gc_execute_block+0x4274>
 800a48a:	4b0f      	ldr	r3, [pc, #60]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a48c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800a48e:	e001      	b.n	800a494 <gc_execute_block+0x4278>
 800a490:	f04f 0300 	mov.w	r3, #0
 800a494:	490b      	ldr	r1, [pc, #44]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a496:	461a      	mov	r2, r3
 800a498:	7e89      	ldrb	r1, [r1, #26]
 800a49a:	f012 fcab 	bl	801cdf4 <spindle_sync>
            }
            // else... - setting the same rpm for multiple spindles at once is not allowed!
        }
        gc_state.spindle.rpm = gc_block.values.s; // Update spindle speed state.
 800a49e:	4b0a      	ldr	r3, [pc, #40]	; (800a4c8 <gc_execute_block+0x42ac>)
 800a4a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800a4a2:	4a08      	ldr	r2, [pc, #32]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a4a4:	6453      	str	r3, [r2, #68]	; 0x44
    }

    // NOTE: Pass zero spindle speed for all restricted laser motions.
    if (!gc_parser_flags.laser_disable)
 800a4a6:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800a4aa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a4ae:	b2db      	uxtb	r3, r3
 800a4b0:	2b00      	cmp	r3, #0
 800a4b2:	d10f      	bne.n	800a4d4 <gc_execute_block+0x42b8>
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t)); // Record data for planner use.
 800a4b4:	4b03      	ldr	r3, [pc, #12]	; (800a4c4 <gc_execute_block+0x42a8>)
 800a4b6:	f107 0468 	add.w	r4, r7, #104	; 0x68
 800a4ba:	3344      	adds	r3, #68	; 0x44
 800a4bc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800a4be:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 800a4c2:	e00a      	b.n	800a4da <gc_execute_block+0x42be>
 800a4c4:	20000bb0 	.word	0x20000bb0
 800a4c8:	20000c8c 	.word	0x20000c8c
 800a4cc:	40c90fdb 	.word	0x40c90fdb
 800a4d0:	20000d38 	.word	0x20000d38
    else {
        plan_data.spindle.hal = gc_state.spindle.hal;
 800a4d4:	4ba8      	ldr	r3, [pc, #672]	; (800a778 <gc_execute_block+0x455c>)
 800a4d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a4d8:	677b      	str	r3, [r7, #116]	; 0x74
    //  plan_data.spindle.speed = 0.0f; // Initialized as zero already.
    }

    // [5. Select tool ]: Only tracks tool value if ATC or manual tool change is not possible.
    if(gc_state.tool_pending != gc_block.values.t && !check_mode) {
 800a4da:	4ba7      	ldr	r3, [pc, #668]	; (800a778 <gc_execute_block+0x455c>)
 800a4dc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800a4de:	4ba7      	ldr	r3, [pc, #668]	; (800a77c <gc_execute_block+0x4560>)
 800a4e0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a4e4:	429a      	cmp	r2, r3
 800a4e6:	d072      	beq.n	800a5ce <gc_execute_block+0x43b2>
 800a4e8:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800a4ec:	f083 0301 	eor.w	r3, r3, #1
 800a4f0:	b2db      	uxtb	r3, r3
 800a4f2:	2b00      	cmp	r3, #0
 800a4f4:	d06b      	beq.n	800a5ce <gc_execute_block+0x43b2>

        tool_data_t *pending_tool = tool_get_pending((gc_state.tool_pending = gc_block.values.t));
 800a4f6:	4ba1      	ldr	r3, [pc, #644]	; (800a77c <gc_execute_block+0x4560>)
 800a4f8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a4fc:	4a9e      	ldr	r2, [pc, #632]	; (800a778 <gc_execute_block+0x455c>)
 800a4fe:	66d3      	str	r3, [r2, #108]	; 0x6c
 800a500:	4b9d      	ldr	r3, [pc, #628]	; (800a778 <gc_execute_block+0x455c>)
 800a502:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a504:	4618      	mov	r0, r3
 800a506:	f7fb fc79 	bl	8005dfc <tool_get_pending>
 800a50a:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc

        // If M6 not available or M61 commanded set new tool immediately
        if(set_tool || settings.tool_change.mode == ToolChange_Ignore || !(hal.stream.suspend_read || hal.tool.change)) {
 800a50e:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800a512:	2b00      	cmp	r3, #0
 800a514:	d10e      	bne.n	800a534 <gc_execute_block+0x4318>
 800a516:	4b9a      	ldr	r3, [pc, #616]	; (800a780 <gc_execute_block+0x4564>)
 800a518:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800a51c:	2b04      	cmp	r3, #4
 800a51e:	d009      	beq.n	800a534 <gc_execute_block+0x4318>
 800a520:	4b98      	ldr	r3, [pc, #608]	; (800a784 <gc_execute_block+0x4568>)
 800a522:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800a526:	2b00      	cmp	r3, #0
 800a528:	d134      	bne.n	800a594 <gc_execute_block+0x4378>
 800a52a:	4b96      	ldr	r3, [pc, #600]	; (800a784 <gc_execute_block+0x4568>)
 800a52c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a530:	2b00      	cmp	r3, #0
 800a532:	d12f      	bne.n	800a594 <gc_execute_block+0x4378>

            tool_set(pending_tool);
 800a534:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
 800a538:	f7fb fc88 	bl	8005e4c <tool_set>

            if(grbl.on_tool_selected) {
 800a53c:	4b92      	ldr	r3, [pc, #584]	; (800a788 <gc_execute_block+0x456c>)
 800a53e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800a542:	2b00      	cmp	r3, #0
 800a544:	d016      	beq.n	800a574 <gc_execute_block+0x4358>

                spindle_state_t state = gc_state.modal.spindle.state;
 800a546:	4b8c      	ldr	r3, [pc, #560]	; (800a778 <gc_execute_block+0x455c>)
 800a548:	7e9b      	ldrb	r3, [r3, #26]
 800a54a:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50

                grbl.on_tool_selected(gc_state.tool);
 800a54e:	4b8e      	ldr	r3, [pc, #568]	; (800a788 <gc_execute_block+0x456c>)
 800a550:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800a554:	4a88      	ldr	r2, [pc, #544]	; (800a778 <gc_execute_block+0x455c>)
 800a556:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800a55a:	4610      	mov	r0, r2
 800a55c:	4798      	blx	r3

                if(state.value != gc_state.modal.spindle.state.value)
 800a55e:	f897 2050 	ldrb.w	r2, [r7, #80]	; 0x50
 800a562:	4b85      	ldr	r3, [pc, #532]	; (800a778 <gc_execute_block+0x455c>)
 800a564:	7e9b      	ldrb	r3, [r3, #26]
 800a566:	429a      	cmp	r2, r3
 800a568:	d004      	beq.n	800a574 <gc_execute_block+0x4358>
                    gc_block.modal.spindle.state = gc_state.modal.spindle.state;
 800a56a:	4a84      	ldr	r2, [pc, #528]	; (800a77c <gc_execute_block+0x4560>)
 800a56c:	4b82      	ldr	r3, [pc, #520]	; (800a778 <gc_execute_block+0x455c>)
 800a56e:	7e9b      	ldrb	r3, [r3, #26]
 800a570:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
            }

            if(grbl.on_tool_changed)
 800a574:	4b84      	ldr	r3, [pc, #528]	; (800a788 <gc_execute_block+0x456c>)
 800a576:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800a57a:	2b00      	cmp	r3, #0
 800a57c:	d007      	beq.n	800a58e <gc_execute_block+0x4372>
                grbl.on_tool_changed(gc_state.tool);
 800a57e:	4b82      	ldr	r3, [pc, #520]	; (800a788 <gc_execute_block+0x456c>)
 800a580:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800a584:	4a7c      	ldr	r2, [pc, #496]	; (800a778 <gc_execute_block+0x455c>)
 800a586:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800a58a:	4610      	mov	r0, r2
 800a58c:	4798      	blx	r3

            system_add_rt_report(Report_Tool);
 800a58e:	2080      	movs	r0, #128	; 0x80
 800a590:	f017 fd04 	bl	8021f9c <system_add_rt_report>
        }

        // Prepare tool carousel when available
        if(hal.tool.select)
 800a594:	4b7b      	ldr	r3, [pc, #492]	; (800a784 <gc_execute_block+0x4568>)
 800a596:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800a59a:	2b00      	cmp	r3, #0
 800a59c:	d014      	beq.n	800a5c8 <gc_execute_block+0x43ac>
            hal.tool.select(pending_tool, !set_tool);
 800a59e:	4b79      	ldr	r3, [pc, #484]	; (800a784 <gc_execute_block+0x4568>)
 800a5a0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800a5a4:	f897 210f 	ldrb.w	r2, [r7, #271]	; 0x10f
 800a5a8:	2a00      	cmp	r2, #0
 800a5aa:	bf14      	ite	ne
 800a5ac:	2201      	movne	r2, #1
 800a5ae:	2200      	moveq	r2, #0
 800a5b0:	b2d2      	uxtb	r2, r2
 800a5b2:	f082 0201 	eor.w	r2, r2, #1
 800a5b6:	b2d2      	uxtb	r2, r2
 800a5b8:	f002 0201 	and.w	r2, r2, #1
 800a5bc:	b2d2      	uxtb	r2, r2
 800a5be:	4611      	mov	r1, r2
 800a5c0:	f8d7 00cc 	ldr.w	r0, [r7, #204]	; 0xcc
 800a5c4:	4798      	blx	r3
 800a5c6:	e002      	b.n	800a5ce <gc_execute_block+0x43b2>
        else
            system_add_rt_report(Report_Tool);
 800a5c8:	2080      	movs	r0, #128	; 0x80
 800a5ca:	f017 fce7 	bl	8021f9c <system_add_rt_report>
    }

    // [5a. HAL pin I/O ]: M62 - M68. (Modal group M10)

    if(port_command) {
 800a5ce:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 800a5d2:	2b00      	cmp	r3, #0
 800a5d4:	d065      	beq.n	800a6a2 <gc_execute_block+0x4486>

        switch(port_command) {
 800a5d6:	f897 310c 	ldrb.w	r3, [r7, #268]	; 0x10c
 800a5da:	3b3e      	subs	r3, #62	; 0x3e
 800a5dc:	2b06      	cmp	r3, #6
 800a5de:	d860      	bhi.n	800a6a2 <gc_execute_block+0x4486>
 800a5e0:	a201      	add	r2, pc, #4	; (adr r2, 800a5e8 <gc_execute_block+0x43cc>)
 800a5e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a5e6:	bf00      	nop
 800a5e8:	0800a605 	.word	0x0800a605
 800a5ec:	0800a605 	.word	0x0800a605
 800a5f0:	0800a60d 	.word	0x0800a60d
 800a5f4:	0800a60d 	.word	0x0800a60d
 800a5f8:	0800a649 	.word	0x0800a649
 800a5fc:	0800a679 	.word	0x0800a679
 800a600:	0800a681 	.word	0x0800a681

            case IoMCode_OutputOnSynced:
            case IoMCode_OutputOffSynced:
                add_output_command(&gc_block.output_command);
 800a604:	4861      	ldr	r0, [pc, #388]	; (800a78c <gc_execute_block+0x4570>)
 800a606:	f7fb fc3d 	bl	8005e84 <add_output_command>
                break;
 800a60a:	e04a      	b.n	800a6a2 <gc_execute_block+0x4486>

            case IoMCode_OutputOnImmediate:
            case IoMCode_OutputOffImmediate:
                hal.port.digital_out(gc_block.output_command.port, gc_block.output_command.value != 0.0f);
 800a60c:	4b5d      	ldr	r3, [pc, #372]	; (800a784 <gc_execute_block+0x4568>)
 800a60e:	f8d3 4118 	ldr.w	r4, [r3, #280]	; 0x118
 800a612:	4b5a      	ldr	r3, [pc, #360]	; (800a77c <gc_execute_block+0x4560>)
 800a614:	f893 509a 	ldrb.w	r5, [r3, #154]	; 0x9a
 800a618:	4b58      	ldr	r3, [pc, #352]	; (800a77c <gc_execute_block+0x4560>)
 800a61a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800a61e:	4618      	mov	r0, r3
 800a620:	f7f6 fb74 	bl	8000d0c <__aeabi_i2f>
 800a624:	4603      	mov	r3, r0
 800a626:	2201      	movs	r2, #1
 800a628:	4616      	mov	r6, r2
 800a62a:	f04f 0100 	mov.w	r1, #0
 800a62e:	4618      	mov	r0, r3
 800a630:	f7f6 fd54 	bl	80010dc <__aeabi_fcmpeq>
 800a634:	4603      	mov	r3, r0
 800a636:	2b00      	cmp	r3, #0
 800a638:	d001      	beq.n	800a63e <gc_execute_block+0x4422>
 800a63a:	2300      	movs	r3, #0
 800a63c:	461e      	mov	r6, r3
 800a63e:	b2f3      	uxtb	r3, r6
 800a640:	4619      	mov	r1, r3
 800a642:	4628      	mov	r0, r5
 800a644:	47a0      	blx	r4
                break;
 800a646:	e02c      	b.n	800a6a2 <gc_execute_block+0x4486>

            case IoMCode_WaitOnInput:
                sys.var5399 = hal.port.wait_on_input((io_port_type_t)gc_block.output_command.is_digital, gc_block.output_command.port, (wait_mode_t)gc_block.values.l, gc_block.values.q);
 800a648:	4b4e      	ldr	r3, [pc, #312]	; (800a784 <gc_execute_block+0x4568>)
 800a64a:	f8d3 4120 	ldr.w	r4, [r3, #288]	; 0x120
 800a64e:	4b4b      	ldr	r3, [pc, #300]	; (800a77c <gc_execute_block+0x4560>)
 800a650:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 800a654:	4618      	mov	r0, r3
 800a656:	4b49      	ldr	r3, [pc, #292]	; (800a77c <gc_execute_block+0x4560>)
 800a658:	f893 109a 	ldrb.w	r1, [r3, #154]	; 0x9a
 800a65c:	4b47      	ldr	r3, [pc, #284]	; (800a77c <gc_execute_block+0x4560>)
 800a65e:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
 800a662:	4b46      	ldr	r3, [pc, #280]	; (800a77c <gc_execute_block+0x4560>)
 800a664:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a666:	47a0      	blx	r4
 800a668:	4603      	mov	r3, r0
 800a66a:	4a49      	ldr	r2, [pc, #292]	; (800a790 <gc_execute_block+0x4574>)
 800a66c:	6513      	str	r3, [r2, #80]	; 0x50
                system_add_rt_report(Report_M66Result);
 800a66e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800a672:	f017 fc93 	bl	8021f9c <system_add_rt_report>
                break;
 800a676:	e014      	b.n	800a6a2 <gc_execute_block+0x4486>

            case IoMCode_AnalogOutSynced:
                add_output_command(&gc_block.output_command);
 800a678:	4844      	ldr	r0, [pc, #272]	; (800a78c <gc_execute_block+0x4570>)
 800a67a:	f7fb fc03 	bl	8005e84 <add_output_command>
                break;
 800a67e:	e010      	b.n	800a6a2 <gc_execute_block+0x4486>

            case IoMCode_AnalogOutImmediate:
                hal.port.analog_out(gc_block.output_command.port, gc_block.output_command.value);
 800a680:	4b40      	ldr	r3, [pc, #256]	; (800a784 <gc_execute_block+0x4568>)
 800a682:	f8d3 411c 	ldr.w	r4, [r3, #284]	; 0x11c
 800a686:	4b3d      	ldr	r3, [pc, #244]	; (800a77c <gc_execute_block+0x4560>)
 800a688:	f893 509a 	ldrb.w	r5, [r3, #154]	; 0x9a
 800a68c:	4b3b      	ldr	r3, [pc, #236]	; (800a77c <gc_execute_block+0x4560>)
 800a68e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800a692:	4618      	mov	r0, r3
 800a694:	f7f6 fb3a 	bl	8000d0c <__aeabi_i2f>
 800a698:	4603      	mov	r3, r0
 800a69a:	4619      	mov	r1, r3
 800a69c:	4628      	mov	r0, r5
 800a69e:	47a0      	blx	r4
                break;
 800a6a0:	bf00      	nop
        }
    }

    // [6. Change tool ]: Delegated to (possible) driver implementation
    if (command_words.M6 && !set_tool && !check_mode) {
 800a6a2:	f897 30a2 	ldrb.w	r3, [r7, #162]	; 0xa2
 800a6a6:	f003 0301 	and.w	r3, r3, #1
 800a6aa:	b2db      	uxtb	r3, r3
 800a6ac:	2b00      	cmp	r3, #0
 800a6ae:	f000 8097 	beq.w	800a7e0 <gc_execute_block+0x45c4>
 800a6b2:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800a6b6:	f083 0301 	eor.w	r3, r3, #1
 800a6ba:	b2db      	uxtb	r3, r3
 800a6bc:	2b00      	cmp	r3, #0
 800a6be:	f000 808f 	beq.w	800a7e0 <gc_execute_block+0x45c4>
 800a6c2:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800a6c6:	f083 0301 	eor.w	r3, r3, #1
 800a6ca:	b2db      	uxtb	r3, r3
 800a6cc:	2b00      	cmp	r3, #0
 800a6ce:	f000 8087 	beq.w	800a7e0 <gc_execute_block+0x45c4>

        tool_data_t *pending_tool = tool_get_pending(gc_state.tool_pending);
 800a6d2:	4b29      	ldr	r3, [pc, #164]	; (800a778 <gc_execute_block+0x455c>)
 800a6d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a6d6:	4618      	mov	r0, r3
 800a6d8:	f7fb fb90 	bl	8005dfc <tool_get_pending>
 800a6dc:	f8c7 00c8 	str.w	r0, [r7, #200]	; 0xc8

        protocol_buffer_synchronize();
 800a6e0:	f008 fb0e 	bl	8012d00 <protocol_buffer_synchronize>

        if(plan_data.message) {
 800a6e4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a6e8:	2b00      	cmp	r3, #0
 800a6ea:	d007      	beq.n	800a6fc <gc_execute_block+0x44e0>
            output_message(plan_data.message);
 800a6ec:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800a6f0:	4618      	mov	r0, r3
 800a6f2:	f7fb fc7f 	bl	8005ff4 <output_message>
            plan_data.message = NULL;
 800a6f6:	2300      	movs	r3, #0
 800a6f8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        }

        if(pending_tool->tool_id != gc_state.tool->tool_id) {
 800a6fc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800a700:	691a      	ldr	r2, [r3, #16]
 800a702:	4b1d      	ldr	r3, [pc, #116]	; (800a778 <gc_execute_block+0x455c>)
 800a704:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800a708:	691b      	ldr	r3, [r3, #16]
 800a70a:	429a      	cmp	r2, r3
 800a70c:	d068      	beq.n	800a7e0 <gc_execute_block+0x45c4>

            if(grbl.on_tool_selected) {
 800a70e:	4b1e      	ldr	r3, [pc, #120]	; (800a788 <gc_execute_block+0x456c>)
 800a710:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800a714:	2b00      	cmp	r3, #0
 800a716:	d014      	beq.n	800a742 <gc_execute_block+0x4526>

                spindle_state_t state = gc_state.modal.spindle.state;
 800a718:	4b17      	ldr	r3, [pc, #92]	; (800a778 <gc_execute_block+0x455c>)
 800a71a:	7e9b      	ldrb	r3, [r3, #26]
 800a71c:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c

                grbl.on_tool_selected(pending_tool);
 800a720:	4b19      	ldr	r3, [pc, #100]	; (800a788 <gc_execute_block+0x456c>)
 800a722:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 800a726:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 800a72a:	4798      	blx	r3

                if(state.value != gc_state.modal.spindle.state.value)
 800a72c:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800a730:	4b11      	ldr	r3, [pc, #68]	; (800a778 <gc_execute_block+0x455c>)
 800a732:	7e9b      	ldrb	r3, [r3, #26]
 800a734:	429a      	cmp	r2, r3
 800a736:	d004      	beq.n	800a742 <gc_execute_block+0x4526>
                    gc_block.modal.spindle.state = gc_state.modal.spindle.state;
 800a738:	4a10      	ldr	r2, [pc, #64]	; (800a77c <gc_execute_block+0x4560>)
 800a73a:	4b0f      	ldr	r3, [pc, #60]	; (800a778 <gc_execute_block+0x455c>)
 800a73c:	7e9b      	ldrb	r3, [r3, #26]
 800a73e:	f882 3022 	strb.w	r3, [r2, #34]	; 0x22
            }

            if(hal.tool.change) { // ATC
 800a742:	4b10      	ldr	r3, [pc, #64]	; (800a784 <gc_execute_block+0x4568>)
 800a744:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a748:	2b00      	cmp	r3, #0
 800a74a:	d023      	beq.n	800a794 <gc_execute_block+0x4578>
                if((int_value = (uint_fast16_t)hal.tool.change(&gc_state)) != Status_OK) {
 800a74c:	4b0d      	ldr	r3, [pc, #52]	; (800a784 <gc_execute_block+0x4568>)
 800a74e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a752:	4809      	ldr	r0, [pc, #36]	; (800a778 <gc_execute_block+0x455c>)
 800a754:	4798      	blx	r3
 800a756:	4603      	mov	r3, r0
 800a758:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 800a75c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800a760:	2b00      	cmp	r3, #0
 800a762:	d004      	beq.n	800a76e <gc_execute_block+0x4552>
#if NGC_EXPRESSIONS_ENABLE
                    if(int_value != Status_Unhandled)
#endif
                        FAIL((status_code_t)int_value);
 800a764:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800a768:	b2db      	uxtb	r3, r3
 800a76a:	f001 b84f 	b.w	800b80c <gc_execute_block+0x55f0>
                }
                system_add_rt_report(Report_Tool);
 800a76e:	2080      	movs	r0, #128	; 0x80
 800a770:	f017 fc14 	bl	8021f9c <system_add_rt_report>
 800a774:	e01d      	b.n	800a7b2 <gc_execute_block+0x4596>
 800a776:	bf00      	nop
 800a778:	20000bb0 	.word	0x20000bb0
 800a77c:	20000c8c 	.word	0x20000c8c
 800a780:	2000147c 	.word	0x2000147c
 800a784:	20000ed0 	.word	0x20000ed0
 800a788:	20000dd4 	.word	0x20000dd4
 800a78c:	20000d24 	.word	0x20000d24
 800a790:	20000d3c 	.word	0x20000d3c
            } else { // Manual
                int_value = (uint_fast16_t)Status_OK;
 800a794:	2300      	movs	r3, #0
 800a796:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
                gc_state.tool_change = true;
 800a79a:	4b58      	ldr	r3, [pc, #352]	; (800a8fc <gc_execute_block+0x46e0>)
 800a79c:	2201      	movs	r2, #1
 800a79e:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
                system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 800a7a2:	4b57      	ldr	r3, [pc, #348]	; (800a900 <gc_execute_block+0x46e4>)
 800a7a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a7a6:	f44f 7100 	mov.w	r1, #512	; 0x200
 800a7aa:	4856      	ldr	r0, [pc, #344]	; (800a904 <gc_execute_block+0x46e8>)
 800a7ac:	4798      	blx	r3
                protocol_execute_realtime();                    // Execute...
 800a7ae:	f008 fad7 	bl	8012d60 <protocol_execute_realtime>
            else if(grbl.tool_table.n_tools && command_words.G8 && gc_block.modal.tool_offset_mode && ToolLengthOffset_Enable) {
                gc_state.g43_pending = gc_block.values.h;
                command_words.G8 = Off;
            }
#else
            tool_set(pending_tool);
 800a7b2:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 800a7b6:	f7fb fb49 	bl	8005e4c <tool_set>
#endif
            if(grbl.on_tool_changed && state_get() != STATE_TOOL_CHANGE)
 800a7ba:	4b53      	ldr	r3, [pc, #332]	; (800a908 <gc_execute_block+0x46ec>)
 800a7bc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800a7c0:	2b00      	cmp	r3, #0
 800a7c2:	d00d      	beq.n	800a7e0 <gc_execute_block+0x45c4>
 800a7c4:	f013 f87c 	bl	801d8c0 <state_get>
 800a7c8:	4603      	mov	r3, r0
 800a7ca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a7ce:	d007      	beq.n	800a7e0 <gc_execute_block+0x45c4>
                grbl.on_tool_changed(gc_state.tool);
 800a7d0:	4b4d      	ldr	r3, [pc, #308]	; (800a908 <gc_execute_block+0x46ec>)
 800a7d2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 800a7d6:	4a49      	ldr	r2, [pc, #292]	; (800a8fc <gc_execute_block+0x46e0>)
 800a7d8:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800a7dc:	4610      	mov	r0, r2
 800a7de:	4798      	blx	r3
        }
    }

    // [7. Spindle control ]:
    if (gc_state.modal.spindle.state.value != gc_block.modal.spindle.state.value) {
 800a7e0:	4b46      	ldr	r3, [pc, #280]	; (800a8fc <gc_execute_block+0x46e0>)
 800a7e2:	7e9a      	ldrb	r2, [r3, #26]
 800a7e4:	4b49      	ldr	r3, [pc, #292]	; (800a90c <gc_execute_block+0x46f0>)
 800a7e6:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a7ea:	429a      	cmp	r2, r3
 800a7ec:	d05a      	beq.n	800a8a4 <gc_execute_block+0x4688>
        // Update spindle control and apply spindle speed when enabling it in this block.
        // NOTE: All spindle state changes are synced, even in laser mode. Also, plan_data,
        // rather than gc_state, is used to manage laser state for non-laser motions.
        if(gc_block.spindle) {
 800a7ee:	4b47      	ldr	r3, [pc, #284]	; (800a90c <gc_execute_block+0x46f0>)
 800a7f0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a7f4:	2b00      	cmp	r3, #0
 800a7f6:	d019      	beq.n	800a82c <gc_execute_block+0x4610>
            if((spindle_programmed = spindle_sync(gc_block.spindle, gc_block.modal.spindle.state, plan_data.spindle.rpm)))
 800a7f8:	4b44      	ldr	r3, [pc, #272]	; (800a90c <gc_execute_block+0x46f0>)
 800a7fa:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a7fe:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800a800:	4942      	ldr	r1, [pc, #264]	; (800a90c <gc_execute_block+0x46f0>)
 800a802:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
 800a806:	4618      	mov	r0, r3
 800a808:	f012 faf4 	bl	801cdf4 <spindle_sync>
 800a80c:	4603      	mov	r3, r0
 800a80e:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
 800a812:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800a816:	2b00      	cmp	r3, #0
 800a818:	d03b      	beq.n	800a892 <gc_execute_block+0x4676>
                gc_block.spindle->param->state = gc_block.modal.spindle.state;
 800a81a:	4b3c      	ldr	r3, [pc, #240]	; (800a90c <gc_execute_block+0x46f0>)
 800a81c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a820:	685b      	ldr	r3, [r3, #4]
 800a822:	4a3a      	ldr	r2, [pc, #232]	; (800a90c <gc_execute_block+0x46f0>)
 800a824:	f892 2022 	ldrb.w	r2, [r2, #34]	; 0x22
 800a828:	721a      	strb	r2, [r3, #8]
 800a82a:	e032      	b.n	800a892 <gc_execute_block+0x4676>
        } else {
            idx = N_SYS_SPINDLE;
 800a82c:	2301      	movs	r3, #1
 800a82e:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
            do {
                if(spindle_is_enabled(--idx)) {
 800a832:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a836:	3b01      	subs	r3, #1
 800a838:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800a83c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a840:	b25b      	sxtb	r3, r3
 800a842:	4618      	mov	r0, r3
 800a844:	f012 f92c 	bl	801caa0 <spindle_is_enabled>
 800a848:	4603      	mov	r3, r0
 800a84a:	2b00      	cmp	r3, #0
 800a84c:	d01d      	beq.n	800a88a <gc_execute_block+0x466e>
                    spindle_ptrs_t *spindle = spindle_get(idx);
 800a84e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a852:	b25b      	sxtb	r3, r3
 800a854:	4618      	mov	r0, r3
 800a856:	f012 f951 	bl	801cafc <spindle_get>
 800a85a:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4
                    if(spindle_sync(spindle, gc_block.modal.spindle.state, plan_data.spindle.rpm)) {
 800a85e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a860:	492a      	ldr	r1, [pc, #168]	; (800a90c <gc_execute_block+0x46f0>)
 800a862:	461a      	mov	r2, r3
 800a864:	f891 1022 	ldrb.w	r1, [r1, #34]	; 0x22
 800a868:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 800a86c:	f012 fac2 	bl	801cdf4 <spindle_sync>
 800a870:	4603      	mov	r3, r0
 800a872:	2b00      	cmp	r3, #0
 800a874:	d009      	beq.n	800a88a <gc_execute_block+0x466e>
                        spindle_programmed = true;
 800a876:	2301      	movs	r3, #1
 800a878:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
                        spindle->param->state = gc_block.modal.spindle.state;
 800a87c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800a880:	685b      	ldr	r3, [r3, #4]
 800a882:	4a22      	ldr	r2, [pc, #136]	; (800a90c <gc_execute_block+0x46f0>)
 800a884:	f892 2022 	ldrb.w	r2, [r2, #34]	; 0x22
 800a888:	721a      	strb	r2, [r3, #8]
                    }
                }
            } while(idx);
 800a88a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800a88e:	2b00      	cmp	r3, #0
 800a890:	d1cf      	bne.n	800a832 <gc_execute_block+0x4616>
        }
        if(spindle_programmed)
 800a892:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800a896:	2b00      	cmp	r3, #0
 800a898:	d004      	beq.n	800a8a4 <gc_execute_block+0x4688>
            gc_state.modal.spindle.state = gc_block.modal.spindle.state;
 800a89a:	4a18      	ldr	r2, [pc, #96]	; (800a8fc <gc_execute_block+0x46e0>)
 800a89c:	4b1b      	ldr	r3, [pc, #108]	; (800a90c <gc_execute_block+0x46f0>)
 800a89e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a8a2:	7693      	strb	r3, [r2, #26]
    }

    // TODO: add spindle argument and move into loop above?
    if(spindle_programmed && grbl.on_spindle_programmed)
 800a8a4:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800a8a8:	2b00      	cmp	r3, #0
 800a8aa:	d00e      	beq.n	800a8ca <gc_execute_block+0x46ae>
 800a8ac:	4b16      	ldr	r3, [pc, #88]	; (800a908 <gc_execute_block+0x46ec>)
 800a8ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a8b0:	2b00      	cmp	r3, #0
 800a8b2:	d00a      	beq.n	800a8ca <gc_execute_block+0x46ae>
        grbl.on_spindle_programmed(gc_state.spindle.hal, gc_state.modal.spindle.state, gc_state.spindle.rpm, gc_state.modal.spindle.rpm_mode);
 800a8b4:	4b14      	ldr	r3, [pc, #80]	; (800a908 <gc_execute_block+0x46ec>)
 800a8b6:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 800a8b8:	4b10      	ldr	r3, [pc, #64]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8ba:	6d18      	ldr	r0, [r3, #80]	; 0x50
 800a8bc:	4b0f      	ldr	r3, [pc, #60]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8be:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a8c0:	4b0e      	ldr	r3, [pc, #56]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8c2:	7edb      	ldrb	r3, [r3, #27]
 800a8c4:	490d      	ldr	r1, [pc, #52]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8c6:	7e89      	ldrb	r1, [r1, #26]
 800a8c8:	47a0      	blx	r4

// TODO: Recheck spindle running in CCS mode (is_rpm_pos_adjusted == On)?

    plan_data.spindle.state = gc_state.modal.spindle.state; // Set condition flag for planner use.
 800a8ca:	4b0c      	ldr	r3, [pc, #48]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8cc:	7e9b      	ldrb	r3, [r3, #26]
 800a8ce:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
    plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 800a8d2:	4b0a      	ldr	r3, [pc, #40]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8d4:	f893 2072 	ldrb.w	r2, [r3, #114]	; 0x72
 800a8d8:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800a8dc:	f362 1386 	bfi	r3, r2, #6, #1
 800a8e0:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78
    plan_data.condition.is_laser_ppi_mode = gc_state.is_rpm_rate_adjusted && gc_state.is_laser_ppi_mode;
 800a8e4:	4b05      	ldr	r3, [pc, #20]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8e6:	f893 3072 	ldrb.w	r3, [r3, #114]	; 0x72
 800a8ea:	2b00      	cmp	r3, #0
 800a8ec:	d010      	beq.n	800a910 <gc_execute_block+0x46f4>
 800a8ee:	4b03      	ldr	r3, [pc, #12]	; (800a8fc <gc_execute_block+0x46e0>)
 800a8f0:	f893 3071 	ldrb.w	r3, [r3, #113]	; 0x71
 800a8f4:	2b00      	cmp	r3, #0
 800a8f6:	d00b      	beq.n	800a910 <gc_execute_block+0x46f4>
 800a8f8:	2301      	movs	r3, #1
 800a8fa:	e00a      	b.n	800a912 <gc_execute_block+0x46f6>
 800a8fc:	20000bb0 	.word	0x20000bb0
 800a900:	20000ed0 	.word	0x20000ed0
 800a904:	20000d84 	.word	0x20000d84
 800a908:	20000dd4 	.word	0x20000dd4
 800a90c:	20000c8c 	.word	0x20000c8c
 800a910:	2300      	movs	r3, #0
 800a912:	f003 0301 	and.w	r3, r3, #1
 800a916:	b2da      	uxtb	r2, r3
 800a918:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800a91c:	f362 13c7 	bfi	r3, r2, #7, #1
 800a920:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78

    // [8. Coolant control ]:
    if (gc_parser_flags.set_coolant && gc_state.modal.coolant.value != gc_block.modal.coolant.value) {
 800a924:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 800a928:	f003 0301 	and.w	r3, r3, #1
 800a92c:	b2db      	uxtb	r3, r3
 800a92e:	2b00      	cmp	r3, #0
 800a930:	d013      	beq.n	800a95a <gc_execute_block+0x473e>
 800a932:	4bab      	ldr	r3, [pc, #684]	; (800abe0 <gc_execute_block+0x49c4>)
 800a934:	7e5a      	ldrb	r2, [r3, #25]
 800a936:	4bab      	ldr	r3, [pc, #684]	; (800abe4 <gc_execute_block+0x49c8>)
 800a938:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a93c:	429a      	cmp	r2, r3
 800a93e:	d00c      	beq.n	800a95a <gc_execute_block+0x473e>
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
        if(coolant_sync(gc_block.modal.coolant))
 800a940:	4ba8      	ldr	r3, [pc, #672]	; (800abe4 <gc_execute_block+0x49c8>)
 800a942:	f893 0021 	ldrb.w	r0, [r3, #33]	; 0x21
 800a946:	f7fa feab 	bl	80056a0 <coolant_sync>
 800a94a:	4603      	mov	r3, r0
 800a94c:	2b00      	cmp	r3, #0
 800a94e:	d004      	beq.n	800a95a <gc_execute_block+0x473e>
            gc_state.modal.coolant = gc_block.modal.coolant;
 800a950:	4aa3      	ldr	r2, [pc, #652]	; (800abe0 <gc_execute_block+0x49c4>)
 800a952:	4ba4      	ldr	r3, [pc, #656]	; (800abe4 <gc_execute_block+0x49c8>)
 800a954:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a958:	7653      	strb	r3, [r2, #25]
    }

    plan_data.condition.coolant = gc_state.modal.coolant; // Set condition flag for planner use.
 800a95a:	4ba1      	ldr	r3, [pc, #644]	; (800abe0 <gc_execute_block+0x49c4>)
 800a95c:	7e5b      	ldrb	r3, [r3, #25]
 800a95e:	f887 307a 	strb.w	r3, [r7, #122]	; 0x7a

    sys.override_delay.flags = 0;
 800a962:	4ba1      	ldr	r3, [pc, #644]	; (800abe8 <gc_execute_block+0x49cc>)
 800a964:	2200      	movs	r2, #0
 800a966:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    // [9. Override control ]:
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 800a96a:	4b9d      	ldr	r3, [pc, #628]	; (800abe0 <gc_execute_block+0x49c4>)
 800a96c:	7f1a      	ldrb	r2, [r3, #28]
 800a96e:	4b9d      	ldr	r3, [pc, #628]	; (800abe4 <gc_execute_block+0x49c8>)
 800a970:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800a974:	429a      	cmp	r2, r3
 800a976:	d035      	beq.n	800a9e4 <gc_execute_block+0x47c8>

        gc_state.modal.override_ctrl = gc_block.modal.override_ctrl;
 800a978:	4a99      	ldr	r2, [pc, #612]	; (800abe0 <gc_execute_block+0x49c4>)
 800a97a:	4b9a      	ldr	r3, [pc, #616]	; (800abe4 <gc_execute_block+0x49c8>)
 800a97c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800a980:	7713      	strb	r3, [r2, #28]
        gc_state.modal.spindle.state.override_disable = gc_state.spindle.hal->param->state.override_disable = gc_state.modal.override_ctrl.spindle_rpm_disable;
 800a982:	4b97      	ldr	r3, [pc, #604]	; (800abe0 <gc_execute_block+0x49c4>)
 800a984:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a986:	685b      	ldr	r3, [r3, #4]
 800a988:	4a95      	ldr	r2, [pc, #596]	; (800abe0 <gc_execute_block+0x49c4>)
 800a98a:	7f12      	ldrb	r2, [r2, #28]
 800a98c:	f3c2 0280 	ubfx	r2, r2, #2, #1
 800a990:	b2d1      	uxtb	r1, r2
 800a992:	7a1a      	ldrb	r2, [r3, #8]
 800a994:	f361 1204 	bfi	r2, r1, #4, #1
 800a998:	721a      	strb	r2, [r3, #8]
 800a99a:	7a1b      	ldrb	r3, [r3, #8]
 800a99c:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800a9a0:	b2d9      	uxtb	r1, r3
 800a9a2:	4a8f      	ldr	r2, [pc, #572]	; (800abe0 <gc_execute_block+0x49c4>)
 800a9a4:	7e93      	ldrb	r3, [r2, #26]
 800a9a6:	f361 1304 	bfi	r3, r1, #4, #1
 800a9aa:	7693      	strb	r3, [r2, #26]

        if(gc_state.modal.override_ctrl.feed_rate_disable)
 800a9ac:	4b8c      	ldr	r3, [pc, #560]	; (800abe0 <gc_execute_block+0x49c4>)
 800a9ae:	7f1b      	ldrb	r3, [r3, #28]
 800a9b0:	f003 0301 	and.w	r3, r3, #1
 800a9b4:	b2db      	uxtb	r3, r3
 800a9b6:	2b00      	cmp	r3, #0
 800a9b8:	d003      	beq.n	800a9c2 <gc_execute_block+0x47a6>
            plan_feed_override(0, 0);
 800a9ba:	2100      	movs	r1, #0
 800a9bc:	2000      	movs	r0, #0
 800a9be:	f007 fc99 	bl	80122f4 <plan_feed_override>

        if(gc_state.modal.override_ctrl.spindle_rpm_disable)
 800a9c2:	4b87      	ldr	r3, [pc, #540]	; (800abe0 <gc_execute_block+0x49c4>)
 800a9c4:	7f1b      	ldrb	r3, [r3, #28]
 800a9c6:	f003 0304 	and.w	r3, r3, #4
 800a9ca:	b2db      	uxtb	r3, r3
 800a9cc:	2b00      	cmp	r3, #0
 800a9ce:	d005      	beq.n	800a9dc <gc_execute_block+0x47c0>
            spindle_set_override(gc_state.spindle.hal, DEFAULT_SPINDLE_RPM_OVERRIDE);
 800a9d0:	4b83      	ldr	r3, [pc, #524]	; (800abe0 <gc_execute_block+0x49c4>)
 800a9d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a9d4:	2164      	movs	r1, #100	; 0x64
 800a9d6:	4618      	mov	r0, r3
 800a9d8:	f012 f92e 	bl	801cc38 <spindle_set_override>

        mc_override_ctrl_update(gc_state.modal.override_ctrl); // NOTE: must be called last!
 800a9dc:	4b80      	ldr	r3, [pc, #512]	; (800abe0 <gc_execute_block+0x49c4>)
 800a9de:	7f18      	ldrb	r0, [r3, #28]
 800a9e0:	f004 fe6a 	bl	800f6b8 <mc_override_ctrl_update>
    }

    // [9a. User defined M commands ]:
    if(gc_block.user_mcode && !check_mode) {
 800a9e4:	4b7f      	ldr	r3, [pc, #508]	; (800abe4 <gc_execute_block+0x49c8>)
 800a9e6:	885b      	ldrh	r3, [r3, #2]
 800a9e8:	2b00      	cmp	r3, #0
 800a9ea:	d01e      	beq.n	800aa2a <gc_execute_block+0x480e>
 800a9ec:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800a9f0:	f083 0301 	eor.w	r3, r3, #1
 800a9f4:	b2db      	uxtb	r3, r3
 800a9f6:	2b00      	cmp	r3, #0
 800a9f8:	d017      	beq.n	800aa2a <gc_execute_block+0x480e>

        if(gc_block.user_mcode_sync)
 800a9fa:	4b7a      	ldr	r3, [pc, #488]	; (800abe4 <gc_execute_block+0x49c8>)
 800a9fc:	791b      	ldrb	r3, [r3, #4]
 800a9fe:	2b00      	cmp	r3, #0
 800aa00:	d001      	beq.n	800aa06 <gc_execute_block+0x47ea>
            protocol_buffer_synchronize(); // Ensure user defined mcode is executed when specified in program.
 800aa02:	f008 f97d 	bl	8012d00 <protocol_buffer_synchronize>
        gc_block.words.mask = user_words.mask;
 800aa06:	4b79      	ldr	r3, [pc, #484]	; (800abec <gc_execute_block+0x49d0>)
 800aa08:	681b      	ldr	r3, [r3, #0]
 800aa0a:	4a76      	ldr	r2, [pc, #472]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa0c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
        hal.user_mcode.execute(state_get(), &gc_block);
 800aa10:	4b77      	ldr	r3, [pc, #476]	; (800abf0 <gc_execute_block+0x49d4>)
 800aa12:	f8d3 4190 	ldr.w	r4, [r3, #400]	; 0x190
 800aa16:	f012 ff53 	bl	801d8c0 <state_get>
 800aa1a:	4603      	mov	r3, r0
 800aa1c:	4971      	ldr	r1, [pc, #452]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa1e:	4618      	mov	r0, r3
 800aa20:	47a0      	blx	r4
        gc_block.words.mask = 0;
 800aa22:	4b70      	ldr	r3, [pc, #448]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa24:	2200      	movs	r2, #0
 800aa26:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    }

    // [10. Dwell ]:
    if (gc_block.non_modal_command == NonModal_Dwell)
 800aa2a:	4b6e      	ldr	r3, [pc, #440]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa2c:	781b      	ldrb	r3, [r3, #0]
 800aa2e:	2b04      	cmp	r3, #4
 800aa30:	d104      	bne.n	800aa3c <gc_execute_block+0x4820>
        mc_dwell(gc_block.values.p);
 800aa32:	4b6c      	ldr	r3, [pc, #432]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa34:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800aa36:	4618      	mov	r0, r3
 800aa38:	f004 fab2 	bl	800efa0 <mc_dwell>

    // [11. Set active plane ]:
    gc_state.modal.plane_select = gc_block.modal.plane_select;
 800aa3c:	4b69      	ldr	r3, [pc, #420]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa3e:	7b9a      	ldrb	r2, [r3, #14]
 800aa40:	4b67      	ldr	r3, [pc, #412]	; (800abe0 <gc_execute_block+0x49c4>)
 800aa42:	719a      	strb	r2, [r3, #6]

    // [12. Set length units ]:
    gc_state.modal.units_imperial = gc_block.modal.units_imperial;
 800aa44:	4b67      	ldr	r3, [pc, #412]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa46:	7ada      	ldrb	r2, [r3, #11]
 800aa48:	4b65      	ldr	r3, [pc, #404]	; (800abe0 <gc_execute_block+0x49c4>)
 800aa4a:	70da      	strb	r2, [r3, #3]

    // [14. Tool length compensation ]: G43, G43.1 and G49 supported. G43 supported when grbl.tool_table.n_tools > 0.
    // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
    // of execution. The error-checking step would simply load the offset value into the correct
    // axis of the block XYZ value array.
    if (command_words.G8) { // Indicates a change.
 800aa4c:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 800aa50:	f003 0301 	and.w	r3, r3, #1
 800aa54:	b2db      	uxtb	r3, r3
 800aa56:	2b00      	cmp	r3, #0
 800aa58:	f000 8111 	beq.w	800ac7e <gc_execute_block+0x4a62>

        bool tlo_changed = false;
 800aa5c:	2300      	movs	r3, #0
 800aa5e:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef

        idx = N_AXIS;
 800aa62:	2303      	movs	r3, #3
 800aa64:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
        gc_state.modal.tool_offset_mode = gc_block.modal.tool_offset_mode;
 800aa68:	4b5e      	ldr	r3, [pc, #376]	; (800abe4 <gc_execute_block+0x49c8>)
 800aa6a:	7bda      	ldrb	r2, [r3, #15]
 800aa6c:	4b5c      	ldr	r3, [pc, #368]	; (800abe0 <gc_execute_block+0x49c4>)
 800aa6e:	71da      	strb	r2, [r3, #7]

        do {

            idx--;
 800aa70:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800aa74:	3b01      	subs	r3, #1
 800aa76:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8

            switch(gc_state.modal.tool_offset_mode) {
 800aa7a:	4b59      	ldr	r3, [pc, #356]	; (800abe0 <gc_execute_block+0x49c4>)
 800aa7c:	79db      	ldrb	r3, [r3, #7]
 800aa7e:	2b03      	cmp	r3, #3
 800aa80:	f200 80eb 	bhi.w	800ac5a <gc_execute_block+0x4a3e>
 800aa84:	a201      	add	r2, pc, #4	; (adr r2, 800aa8c <gc_execute_block+0x4870>)
 800aa86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aa8a:	bf00      	nop
 800aa8c:	0800aa9d 	.word	0x0800aa9d
 800aa90:	0800aaeb 	.word	0x0800aaeb
 800aa94:	0800abf9 	.word	0x0800abf9
 800aa98:	0800ab55 	.word	0x0800ab55

                case ToolLengthOffset_Cancel: // G49
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 800aa9c:	f897 40ef 	ldrb.w	r4, [r7, #239]	; 0xef
 800aaa0:	4a4f      	ldr	r2, [pc, #316]	; (800abe0 <gc_execute_block+0x49c4>)
 800aaa2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800aaa6:	3320      	adds	r3, #32
 800aaa8:	009b      	lsls	r3, r3, #2
 800aaaa:	4413      	add	r3, r2
 800aaac:	685b      	ldr	r3, [r3, #4]
 800aaae:	2201      	movs	r2, #1
 800aab0:	4615      	mov	r5, r2
 800aab2:	f04f 0100 	mov.w	r1, #0
 800aab6:	4618      	mov	r0, r3
 800aab8:	f7f6 fb10 	bl	80010dc <__aeabi_fcmpeq>
 800aabc:	4603      	mov	r3, r0
 800aabe:	2b00      	cmp	r3, #0
 800aac0:	d001      	beq.n	800aac6 <gc_execute_block+0x48aa>
 800aac2:	2300      	movs	r3, #0
 800aac4:	461d      	mov	r5, r3
 800aac6:	b2eb      	uxtb	r3, r5
 800aac8:	4323      	orrs	r3, r4
 800aaca:	2b00      	cmp	r3, #0
 800aacc:	bf14      	ite	ne
 800aace:	2301      	movne	r3, #1
 800aad0:	2300      	moveq	r3, #0
 800aad2:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef
                    gc_state.tool_length_offset[idx] = 0.0f;
 800aad6:	4a42      	ldr	r2, [pc, #264]	; (800abe0 <gc_execute_block+0x49c4>)
 800aad8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800aadc:	3320      	adds	r3, #32
 800aade:	009b      	lsls	r3, r3, #2
 800aae0:	4413      	add	r3, r2
 800aae2:	f04f 0200 	mov.w	r2, #0
 800aae6:	605a      	str	r2, [r3, #4]
                    break;
 800aae8:	e0ba      	b.n	800ac60 <gc_execute_block+0x4a44>

                case ToolLengthOffset_Enable: // G43
                    if (gc_state.tool_length_offset[idx] != grbl.tool_table.tool[gc_block.values.h].offset[idx]) {
 800aaea:	4a3d      	ldr	r2, [pc, #244]	; (800abe0 <gc_execute_block+0x49c4>)
 800aaec:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800aaf0:	3320      	adds	r3, #32
 800aaf2:	009b      	lsls	r3, r3, #2
 800aaf4:	4413      	add	r3, r2
 800aaf6:	6858      	ldr	r0, [r3, #4]
 800aaf8:	4b3e      	ldr	r3, [pc, #248]	; (800abf4 <gc_execute_block+0x49d8>)
 800aafa:	69d9      	ldr	r1, [r3, #28]
 800aafc:	4b39      	ldr	r3, [pc, #228]	; (800abe4 <gc_execute_block+0x49c8>)
 800aafe:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800ab02:	4613      	mov	r3, r2
 800ab04:	009b      	lsls	r3, r3, #2
 800ab06:	4413      	add	r3, r2
 800ab08:	009b      	lsls	r3, r3, #2
 800ab0a:	440b      	add	r3, r1
 800ab0c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800ab10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ab14:	4619      	mov	r1, r3
 800ab16:	f7f6 fae1 	bl	80010dc <__aeabi_fcmpeq>
 800ab1a:	4603      	mov	r3, r0
 800ab1c:	2b00      	cmp	r3, #0
 800ab1e:	d000      	beq.n	800ab22 <gc_execute_block+0x4906>
                        tlo_changed = true;
                        gc_state.tool_length_offset[idx] = grbl.tool_table.tool[gc_block.values.h].offset[idx];
                    }
                    break;
 800ab20:	e09e      	b.n	800ac60 <gc_execute_block+0x4a44>
                        tlo_changed = true;
 800ab22:	2301      	movs	r3, #1
 800ab24:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef
                        gc_state.tool_length_offset[idx] = grbl.tool_table.tool[gc_block.values.h].offset[idx];
 800ab28:	4b32      	ldr	r3, [pc, #200]	; (800abf4 <gc_execute_block+0x49d8>)
 800ab2a:	69d9      	ldr	r1, [r3, #28]
 800ab2c:	4b2d      	ldr	r3, [pc, #180]	; (800abe4 <gc_execute_block+0x49c8>)
 800ab2e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800ab32:	4613      	mov	r3, r2
 800ab34:	009b      	lsls	r3, r3, #2
 800ab36:	4413      	add	r3, r2
 800ab38:	009b      	lsls	r3, r3, #2
 800ab3a:	440b      	add	r3, r1
 800ab3c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800ab40:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800ab44:	4926      	ldr	r1, [pc, #152]	; (800abe0 <gc_execute_block+0x49c4>)
 800ab46:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ab4a:	3320      	adds	r3, #32
 800ab4c:	009b      	lsls	r3, r3, #2
 800ab4e:	440b      	add	r3, r1
 800ab50:	605a      	str	r2, [r3, #4]
                    break;
 800ab52:	e085      	b.n	800ac60 <gc_execute_block+0x4a44>

                case ToolLengthOffset_ApplyAdditional: // G43.2
                    tlo_changed |= grbl.tool_table.tool[gc_block.values.h].offset[idx] != 0.0f;
 800ab54:	f897 40ef 	ldrb.w	r4, [r7, #239]	; 0xef
 800ab58:	4b26      	ldr	r3, [pc, #152]	; (800abf4 <gc_execute_block+0x49d8>)
 800ab5a:	69d9      	ldr	r1, [r3, #28]
 800ab5c:	4b21      	ldr	r3, [pc, #132]	; (800abe4 <gc_execute_block+0x49c8>)
 800ab5e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800ab62:	4613      	mov	r3, r2
 800ab64:	009b      	lsls	r3, r3, #2
 800ab66:	4413      	add	r3, r2
 800ab68:	009b      	lsls	r3, r3, #2
 800ab6a:	440b      	add	r3, r1
 800ab6c:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800ab70:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ab74:	2201      	movs	r2, #1
 800ab76:	4615      	mov	r5, r2
 800ab78:	f04f 0100 	mov.w	r1, #0
 800ab7c:	4618      	mov	r0, r3
 800ab7e:	f7f6 faad 	bl	80010dc <__aeabi_fcmpeq>
 800ab82:	4603      	mov	r3, r0
 800ab84:	2b00      	cmp	r3, #0
 800ab86:	d001      	beq.n	800ab8c <gc_execute_block+0x4970>
 800ab88:	2300      	movs	r3, #0
 800ab8a:	461d      	mov	r5, r3
 800ab8c:	b2eb      	uxtb	r3, r5
 800ab8e:	4323      	orrs	r3, r4
 800ab90:	2b00      	cmp	r3, #0
 800ab92:	bf14      	ite	ne
 800ab94:	2301      	movne	r3, #1
 800ab96:	2300      	moveq	r3, #0
 800ab98:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef
                    gc_state.tool_length_offset[idx] += grbl.tool_table.tool[gc_block.values.h].offset[idx];
 800ab9c:	4a10      	ldr	r2, [pc, #64]	; (800abe0 <gc_execute_block+0x49c4>)
 800ab9e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800aba2:	3320      	adds	r3, #32
 800aba4:	009b      	lsls	r3, r3, #2
 800aba6:	4413      	add	r3, r2
 800aba8:	6858      	ldr	r0, [r3, #4]
 800abaa:	4b12      	ldr	r3, [pc, #72]	; (800abf4 <gc_execute_block+0x49d8>)
 800abac:	69d9      	ldr	r1, [r3, #28]
 800abae:	4b0d      	ldr	r3, [pc, #52]	; (800abe4 <gc_execute_block+0x49c8>)
 800abb0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800abb4:	4613      	mov	r3, r2
 800abb6:	009b      	lsls	r3, r3, #2
 800abb8:	4413      	add	r3, r2
 800abba:	009b      	lsls	r3, r3, #2
 800abbc:	440b      	add	r3, r1
 800abbe:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
 800abc2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800abc6:	4619      	mov	r1, r3
 800abc8:	f7f5 ffec 	bl	8000ba4 <__addsf3>
 800abcc:	4603      	mov	r3, r0
 800abce:	4619      	mov	r1, r3
 800abd0:	4a03      	ldr	r2, [pc, #12]	; (800abe0 <gc_execute_block+0x49c4>)
 800abd2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800abd6:	3320      	adds	r3, #32
 800abd8:	009b      	lsls	r3, r3, #2
 800abda:	4413      	add	r3, r2
 800abdc:	6059      	str	r1, [r3, #4]
                    break;
 800abde:	e03f      	b.n	800ac60 <gc_execute_block+0x4a44>
 800abe0:	20000bb0 	.word	0x20000bb0
 800abe4:	20000c8c 	.word	0x20000c8c
 800abe8:	20000d3c 	.word	0x20000d3c
 800abec:	20000d38 	.word	0x20000d38
 800abf0:	20000ed0 	.word	0x20000ed0
 800abf4:	20000dd4 	.word	0x20000dd4

                case ToolLengthOffset_EnableDynamic: // G43.1
                    if (bit_istrue(axis_words.mask, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 800abf8:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 800abfc:	461a      	mov	r2, r3
 800abfe:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac02:	fa22 f303 	lsr.w	r3, r2, r3
 800ac06:	f003 0301 	and.w	r3, r3, #1
 800ac0a:	2b00      	cmp	r3, #0
 800ac0c:	d027      	beq.n	800ac5e <gc_execute_block+0x4a42>
 800ac0e:	4ac2      	ldr	r2, [pc, #776]	; (800af18 <gc_execute_block+0x4cfc>)
 800ac10:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac14:	3320      	adds	r3, #32
 800ac16:	009b      	lsls	r3, r3, #2
 800ac18:	4413      	add	r3, r2
 800ac1a:	685a      	ldr	r2, [r3, #4]
 800ac1c:	49bf      	ldr	r1, [pc, #764]	; (800af1c <gc_execute_block+0x4d00>)
 800ac1e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac22:	3318      	adds	r3, #24
 800ac24:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ac28:	4619      	mov	r1, r3
 800ac2a:	4610      	mov	r0, r2
 800ac2c:	f7f6 fa56 	bl	80010dc <__aeabi_fcmpeq>
 800ac30:	4603      	mov	r3, r0
 800ac32:	2b00      	cmp	r3, #0
 800ac34:	d000      	beq.n	800ac38 <gc_execute_block+0x4a1c>
                        tlo_changed = true;
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
                    }
                    break;
 800ac36:	e012      	b.n	800ac5e <gc_execute_block+0x4a42>
                        tlo_changed = true;
 800ac38:	2301      	movs	r3, #1
 800ac3a:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
 800ac3e:	4ab7      	ldr	r2, [pc, #732]	; (800af1c <gc_execute_block+0x4d00>)
 800ac40:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac44:	3318      	adds	r3, #24
 800ac46:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800ac4a:	49b3      	ldr	r1, [pc, #716]	; (800af18 <gc_execute_block+0x4cfc>)
 800ac4c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac50:	3320      	adds	r3, #32
 800ac52:	009b      	lsls	r3, r3, #2
 800ac54:	440b      	add	r3, r1
 800ac56:	605a      	str	r2, [r3, #4]
                    break;
 800ac58:	e001      	b.n	800ac5e <gc_execute_block+0x4a42>

                default:
                    break;
 800ac5a:	bf00      	nop
 800ac5c:	e000      	b.n	800ac60 <gc_execute_block+0x4a44>
                    break;
 800ac5e:	bf00      	nop
            }
        } while(idx);
 800ac60:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800ac64:	2b00      	cmp	r3, #0
 800ac66:	f47f af03 	bne.w	800aa70 <gc_execute_block+0x4854>

        if(tlo_changed) {
 800ac6a:	f897 30ef 	ldrb.w	r3, [r7, #239]	; 0xef
 800ac6e:	2b00      	cmp	r3, #0
 800ac70:	d005      	beq.n	800ac7e <gc_execute_block+0x4a62>
            system_add_rt_report(Report_ToolOffset);
 800ac72:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ac76:	f017 f991 	bl	8021f9c <system_add_rt_report>
            system_flag_wco_change();
 800ac7a:	f017 f8ab 	bl	8021dd4 <system_flag_wco_change>
        }
    }

    // [15. Coordinate system selection ]:
    if (gc_state.modal.coord_system.id != gc_block.modal.coord_system.id) {
 800ac7e:	4ba6      	ldr	r3, [pc, #664]	; (800af18 <gc_execute_block+0x4cfc>)
 800ac80:	7d1a      	ldrb	r2, [r3, #20]
 800ac82:	4ba6      	ldr	r3, [pc, #664]	; (800af1c <gc_execute_block+0x4d00>)
 800ac84:	7f1b      	ldrb	r3, [r3, #28]
 800ac86:	429a      	cmp	r2, r3
 800ac88:	d00d      	beq.n	800aca6 <gc_execute_block+0x4a8a>
        memcpy(&gc_state.modal.coord_system, &gc_block.modal.coord_system, sizeof(gc_state.modal.coord_system));
 800ac8a:	4aa3      	ldr	r2, [pc, #652]	; (800af18 <gc_execute_block+0x4cfc>)
 800ac8c:	4ba3      	ldr	r3, [pc, #652]	; (800af1c <gc_execute_block+0x4d00>)
 800ac8e:	f102 0408 	add.w	r4, r2, #8
 800ac92:	3310      	adds	r3, #16
 800ac94:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800ac96:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        system_add_rt_report(Report_GWCO);
 800ac9a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800ac9e:	f017 f97d 	bl	8021f9c <system_add_rt_report>
        system_flag_wco_change();
 800aca2:	f017 f897 	bl	8021dd4 <system_flag_wco_change>

    // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
    // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

    // [17. Set distance mode ]:
    gc_state.modal.distance_incremental = gc_block.modal.distance_incremental;
 800aca6:	4b9d      	ldr	r3, [pc, #628]	; (800af1c <gc_execute_block+0x4d00>)
 800aca8:	7b1a      	ldrb	r2, [r3, #12]
 800acaa:	4b9b      	ldr	r3, [pc, #620]	; (800af18 <gc_execute_block+0x4cfc>)
 800acac:	711a      	strb	r2, [r3, #4]

    // [18. Set retract mode ]:
    gc_state.modal.retract_mode = gc_block.modal.retract_mode;
 800acae:	4b9b      	ldr	r3, [pc, #620]	; (800af1c <gc_execute_block+0x4d00>)
 800acb0:	f893 2025 	ldrb.w	r2, [r3, #37]	; 0x25
 800acb4:	4b98      	ldr	r3, [pc, #608]	; (800af18 <gc_execute_block+0x4cfc>)
 800acb6:	775a      	strb	r2, [r3, #29]

    // [19. Go to predefined position, Set G10, or Set axis offsets ]:
    switch(gc_block.non_modal_command) {
 800acb8:	4b98      	ldr	r3, [pc, #608]	; (800af1c <gc_execute_block+0x4d00>)
 800acba:	781b      	ldrb	r3, [r3, #0]
 800acbc:	2b7a      	cmp	r3, #122	; 0x7a
 800acbe:	f300 816a 	bgt.w	800af96 <gc_execute_block+0x4d7a>
 800acc2:	2b5c      	cmp	r3, #92	; 0x5c
 800acc4:	da0b      	bge.n	800acde <gc_execute_block+0x4ac2>
 800acc6:	2b0a      	cmp	r3, #10
 800acc8:	f000 80a2 	beq.w	800ae10 <gc_execute_block+0x4bf4>
 800accc:	2b0a      	cmp	r3, #10
 800acce:	f2c0 8162 	blt.w	800af96 <gc_execute_block+0x4d7a>
 800acd2:	2b41      	cmp	r3, #65	; 0x41
 800acd4:	f300 815f 	bgt.w	800af96 <gc_execute_block+0x4d7a>
 800acd8:	2b1c      	cmp	r3, #28
 800acda:	da45      	bge.n	800ad68 <gc_execute_block+0x4b4c>
            settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Restore G92 offsets from non-volatile storage
            system_flag_wco_change();
            break;

        default:
            break;
 800acdc:	e15b      	b.n	800af96 <gc_execute_block+0x4d7a>
    switch(gc_block.non_modal_command) {
 800acde:	3b5c      	subs	r3, #92	; 0x5c
 800ace0:	2b1e      	cmp	r3, #30
 800ace2:	f200 8158 	bhi.w	800af96 <gc_execute_block+0x4d7a>
 800ace6:	a201      	add	r2, pc, #4	; (adr r2, 800acec <gc_execute_block+0x4ad0>)
 800ace8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800acec:	0800aee5 	.word	0x0800aee5
 800acf0:	0800af97 	.word	0x0800af97
 800acf4:	0800af97 	.word	0x0800af97
 800acf8:	0800af97 	.word	0x0800af97
 800acfc:	0800af97 	.word	0x0800af97
 800ad00:	0800af97 	.word	0x0800af97
 800ad04:	0800af97 	.word	0x0800af97
 800ad08:	0800af97 	.word	0x0800af97
 800ad0c:	0800af97 	.word	0x0800af97
 800ad10:	0800af97 	.word	0x0800af97
 800ad14:	0800af39 	.word	0x0800af39
 800ad18:	0800af97 	.word	0x0800af97
 800ad1c:	0800af97 	.word	0x0800af97
 800ad20:	0800af97 	.word	0x0800af97
 800ad24:	0800af97 	.word	0x0800af97
 800ad28:	0800af97 	.word	0x0800af97
 800ad2c:	0800af97 	.word	0x0800af97
 800ad30:	0800af97 	.word	0x0800af97
 800ad34:	0800af97 	.word	0x0800af97
 800ad38:	0800af97 	.word	0x0800af97
 800ad3c:	0800af69 	.word	0x0800af69
 800ad40:	0800af97 	.word	0x0800af97
 800ad44:	0800af97 	.word	0x0800af97
 800ad48:	0800af97 	.word	0x0800af97
 800ad4c:	0800af97 	.word	0x0800af97
 800ad50:	0800af97 	.word	0x0800af97
 800ad54:	0800af97 	.word	0x0800af97
 800ad58:	0800af97 	.word	0x0800af97
 800ad5c:	0800af97 	.word	0x0800af97
 800ad60:	0800af97 	.word	0x0800af97
 800ad64:	0800af81 	.word	0x0800af81
 800ad68:	3b1c      	subs	r3, #28
 800ad6a:	2b25      	cmp	r3, #37	; 0x25
 800ad6c:	f200 8113 	bhi.w	800af96 <gc_execute_block+0x4d7a>
 800ad70:	a201      	add	r2, pc, #4	; (adr r2, 800ad78 <gc_execute_block+0x4b5c>)
 800ad72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ad76:	bf00      	nop
 800ad78:	0800ae59 	.word	0x0800ae59
 800ad7c:	0800af97 	.word	0x0800af97
 800ad80:	0800ae59 	.word	0x0800ae59
 800ad84:	0800af97 	.word	0x0800af97
 800ad88:	0800af97 	.word	0x0800af97
 800ad8c:	0800af97 	.word	0x0800af97
 800ad90:	0800af97 	.word	0x0800af97
 800ad94:	0800af97 	.word	0x0800af97
 800ad98:	0800af97 	.word	0x0800af97
 800ad9c:	0800af97 	.word	0x0800af97
 800ada0:	0800ae9d 	.word	0x0800ae9d
 800ada4:	0800af97 	.word	0x0800af97
 800ada8:	0800aea7 	.word	0x0800aea7
 800adac:	0800af97 	.word	0x0800af97
 800adb0:	0800af97 	.word	0x0800af97
 800adb4:	0800af97 	.word	0x0800af97
 800adb8:	0800af97 	.word	0x0800af97
 800adbc:	0800af97 	.word	0x0800af97
 800adc0:	0800af97 	.word	0x0800af97
 800adc4:	0800af97 	.word	0x0800af97
 800adc8:	0800af97 	.word	0x0800af97
 800adcc:	0800af97 	.word	0x0800af97
 800add0:	0800af97 	.word	0x0800af97
 800add4:	0800af97 	.word	0x0800af97
 800add8:	0800af97 	.word	0x0800af97
 800addc:	0800af97 	.word	0x0800af97
 800ade0:	0800af97 	.word	0x0800af97
 800ade4:	0800af97 	.word	0x0800af97
 800ade8:	0800af97 	.word	0x0800af97
 800adec:	0800af97 	.word	0x0800af97
 800adf0:	0800af97 	.word	0x0800af97
 800adf4:	0800af97 	.word	0x0800af97
 800adf8:	0800af97 	.word	0x0800af97
 800adfc:	0800af97 	.word	0x0800af97
 800ae00:	0800af97 	.word	0x0800af97
 800ae04:	0800af97 	.word	0x0800af97
 800ae08:	0800af97 	.word	0x0800af97
 800ae0c:	0800aeb1 	.word	0x0800aeb1
            if(gc_block.values.l == 2 || gc_block.values.l == 20) {
 800ae10:	4b42      	ldr	r3, [pc, #264]	; (800af1c <gc_execute_block+0x4d00>)
 800ae12:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 800ae16:	2b02      	cmp	r3, #2
 800ae18:	d005      	beq.n	800ae26 <gc_execute_block+0x4c0a>
 800ae1a:	4b40      	ldr	r3, [pc, #256]	; (800af1c <gc_execute_block+0x4d00>)
 800ae1c:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 800ae20:	2b14      	cmp	r3, #20
 800ae22:	f040 80ba 	bne.w	800af9a <gc_execute_block+0x4d7e>
                settings_write_coord_data(gc_block.values.coord_data.id, &gc_block.values.coord_data.xyz);
 800ae26:	4b3d      	ldr	r3, [pc, #244]	; (800af1c <gc_execute_block+0x4d00>)
 800ae28:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 800ae2c:	493c      	ldr	r1, [pc, #240]	; (800af20 <gc_execute_block+0x4d04>)
 800ae2e:	4618      	mov	r0, r3
 800ae30:	f00f fec2 	bl	801abb8 <settings_write_coord_data>
                if (gc_state.modal.coord_system.id == gc_block.values.coord_data.id) {
 800ae34:	4b38      	ldr	r3, [pc, #224]	; (800af18 <gc_execute_block+0x4cfc>)
 800ae36:	7d1a      	ldrb	r2, [r3, #20]
 800ae38:	4b38      	ldr	r3, [pc, #224]	; (800af1c <gc_execute_block+0x4d00>)
 800ae3a:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
 800ae3e:	429a      	cmp	r2, r3
 800ae40:	f040 80ab 	bne.w	800af9a <gc_execute_block+0x4d7e>
                    memcpy(gc_state.modal.coord_system.xyz, gc_block.values.coord_data.xyz, sizeof(gc_state.modal.coord_system.xyz));
 800ae44:	4b34      	ldr	r3, [pc, #208]	; (800af18 <gc_execute_block+0x4cfc>)
 800ae46:	4a35      	ldr	r2, [pc, #212]	; (800af1c <gc_execute_block+0x4d00>)
 800ae48:	3308      	adds	r3, #8
 800ae4a:	326c      	adds	r2, #108	; 0x6c
 800ae4c:	ca07      	ldmia	r2, {r0, r1, r2}
 800ae4e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                    system_flag_wco_change();
 800ae52:	f016 ffbf 	bl	8021dd4 <system_flag_wco_change>
            break;
 800ae56:	e0a0      	b.n	800af9a <gc_execute_block+0x4d7e>
            plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 800ae58:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800ae5c:	f043 0301 	orr.w	r3, r3, #1
 800ae60:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78
            if (axis_command)
 800ae64:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800ae68:	2b00      	cmp	r3, #0
 800ae6a:	d005      	beq.n	800ae78 <gc_execute_block+0x4c5c>
                mc_line(gc_block.values.xyz, &plan_data);
 800ae6c:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800ae70:	4619      	mov	r1, r3
 800ae72:	482c      	ldr	r0, [pc, #176]	; (800af24 <gc_execute_block+0x4d08>)
 800ae74:	f002 fdc0 	bl	800d9f8 <mc_line>
            mc_line(gc_block.values.coord_data.xyz, &plan_data);
 800ae78:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800ae7c:	4619      	mov	r1, r3
 800ae7e:	4828      	ldr	r0, [pc, #160]	; (800af20 <gc_execute_block+0x4d04>)
 800ae80:	f002 fdba 	bl	800d9f8 <mc_line>
            memcpy(gc_state.position, gc_block.values.coord_data.xyz, sizeof(gc_state.position));
 800ae84:	4b24      	ldr	r3, [pc, #144]	; (800af18 <gc_execute_block+0x4cfc>)
 800ae86:	4a25      	ldr	r2, [pc, #148]	; (800af1c <gc_execute_block+0x4d00>)
 800ae88:	335c      	adds	r3, #92	; 0x5c
 800ae8a:	326c      	adds	r2, #108	; 0x6c
 800ae8c:	ca07      	ldmia	r2, {r0, r1, r2}
 800ae8e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            set_scaling(1.0f);
 800ae92:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800ae96:	f7fa fd2d 	bl	80058f4 <set_scaling>
            break;
 800ae9a:	e07f      	b.n	800af9c <gc_execute_block+0x4d80>
            settings_write_coord_data(CoordinateSystem_G28, &gc_state.position);
 800ae9c:	4922      	ldr	r1, [pc, #136]	; (800af28 <gc_execute_block+0x4d0c>)
 800ae9e:	2009      	movs	r0, #9
 800aea0:	f00f fe8a 	bl	801abb8 <settings_write_coord_data>
            break;
 800aea4:	e07a      	b.n	800af9c <gc_execute_block+0x4d80>
            settings_write_coord_data(CoordinateSystem_G30, &gc_state.position);
 800aea6:	4920      	ldr	r1, [pc, #128]	; (800af28 <gc_execute_block+0x4d0c>)
 800aea8:	200a      	movs	r0, #10
 800aeaa:	f00f fe85 	bl	801abb8 <settings_write_coord_data>
            break;
 800aeae:	e075      	b.n	800af9c <gc_execute_block+0x4d80>
                status_code_t status = grbl.on_macro_execute((macro_id_t)gc_block.values.p);
 800aeb0:	4b1e      	ldr	r3, [pc, #120]	; (800af2c <gc_execute_block+0x4d10>)
 800aeb2:	f8d3 40f4 	ldr.w	r4, [r3, #244]	; 0xf4
 800aeb6:	4b19      	ldr	r3, [pc, #100]	; (800af1c <gc_execute_block+0x4d00>)
 800aeb8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800aeba:	4618      	mov	r0, r3
 800aebc:	f7f6 f97c 	bl	80011b8 <__aeabi_f2uiz>
 800aec0:	4603      	mov	r3, r0
 800aec2:	b29b      	uxth	r3, r3
 800aec4:	4618      	mov	r0, r3
 800aec6:	47a0      	blx	r4
 800aec8:	4603      	mov	r3, r0
 800aeca:	f887 30c3 	strb.w	r3, [r7, #195]	; 0xc3
                return status == Status_Unhandled ? Status_GcodeValueOutOfRange : status;
 800aece:	f897 30c3 	ldrb.w	r3, [r7, #195]	; 0xc3
 800aed2:	2b54      	cmp	r3, #84	; 0x54
 800aed4:	d003      	beq.n	800aede <gc_execute_block+0x4cc2>
 800aed6:	f897 30c3 	ldrb.w	r3, [r7, #195]	; 0xc3
 800aeda:	f000 bc97 	b.w	800b80c <gc_execute_block+0x55f0>
 800aede:	2327      	movs	r3, #39	; 0x27
 800aee0:	f000 bc94 	b.w	800b80c <gc_execute_block+0x55f0>
            gc_state.g92_coord_offset_applied = true; // TODO: check for all zero?
 800aee4:	4b0c      	ldr	r3, [pc, #48]	; (800af18 <gc_execute_block+0x4cfc>)
 800aee6:	2201      	movs	r2, #1
 800aee8:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
            memcpy(gc_state.g92_coord_offset, gc_block.values.xyz, sizeof(gc_state.g92_coord_offset));
 800aeec:	4b0a      	ldr	r3, [pc, #40]	; (800af18 <gc_execute_block+0x4cfc>)
 800aeee:	4a0b      	ldr	r2, [pc, #44]	; (800af1c <gc_execute_block+0x4d00>)
 800aef0:	3378      	adds	r3, #120	; 0x78
 800aef2:	3260      	adds	r2, #96	; 0x60
 800aef4:	ca07      	ldmia	r2, {r0, r1, r2}
 800aef6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            if(!settings.flags.g92_is_volatile)
 800aefa:	4b0d      	ldr	r3, [pc, #52]	; (800af30 <gc_execute_block+0x4d14>)
 800aefc:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800af00:	f003 0302 	and.w	r3, r3, #2
 800af04:	b2db      	uxtb	r3, r3
 800af06:	2b00      	cmp	r3, #0
 800af08:	d103      	bne.n	800af12 <gc_execute_block+0x4cf6>
                settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 800af0a:	490a      	ldr	r1, [pc, #40]	; (800af34 <gc_execute_block+0x4d18>)
 800af0c:	200b      	movs	r0, #11
 800af0e:	f00f fe53 	bl	801abb8 <settings_write_coord_data>
            system_flag_wco_change();
 800af12:	f016 ff5f 	bl	8021dd4 <system_flag_wco_change>
            break;
 800af16:	e041      	b.n	800af9c <gc_execute_block+0x4d80>
 800af18:	20000bb0 	.word	0x20000bb0
 800af1c:	20000c8c 	.word	0x20000c8c
 800af20:	20000cf8 	.word	0x20000cf8
 800af24:	20000cec 	.word	0x20000cec
 800af28:	20000c0c 	.word	0x20000c0c
 800af2c:	20000dd4 	.word	0x20000dd4
 800af30:	2000147c 	.word	0x2000147c
 800af34:	20000c28 	.word	0x20000c28
            gc_state.g92_coord_offset_applied = false;
 800af38:	4bc1      	ldr	r3, [pc, #772]	; (800b240 <gc_execute_block+0x5024>)
 800af3a:	2200      	movs	r2, #0
 800af3c:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 800af40:	220c      	movs	r2, #12
 800af42:	2100      	movs	r1, #0
 800af44:	48bf      	ldr	r0, [pc, #764]	; (800b244 <gc_execute_block+0x5028>)
 800af46:	f018 fe66 	bl	8023c16 <memset>
            if(!settings.flags.g92_is_volatile)
 800af4a:	4bbf      	ldr	r3, [pc, #764]	; (800b248 <gc_execute_block+0x502c>)
 800af4c:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800af50:	f003 0302 	and.w	r3, r3, #2
 800af54:	b2db      	uxtb	r3, r3
 800af56:	2b00      	cmp	r3, #0
 800af58:	d103      	bne.n	800af62 <gc_execute_block+0x4d46>
                settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 800af5a:	49ba      	ldr	r1, [pc, #744]	; (800b244 <gc_execute_block+0x5028>)
 800af5c:	200b      	movs	r0, #11
 800af5e:	f00f fe2b 	bl	801abb8 <settings_write_coord_data>
            system_flag_wco_change();
 800af62:	f016 ff37 	bl	8021dd4 <system_flag_wco_change>
            break;
 800af66:	e019      	b.n	800af9c <gc_execute_block+0x4d80>
            gc_state.g92_coord_offset_applied = false;
 800af68:	4bb5      	ldr	r3, [pc, #724]	; (800b240 <gc_execute_block+0x5024>)
 800af6a:	2200      	movs	r2, #0
 800af6c:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 800af70:	220c      	movs	r2, #12
 800af72:	2100      	movs	r1, #0
 800af74:	48b3      	ldr	r0, [pc, #716]	; (800b244 <gc_execute_block+0x5028>)
 800af76:	f018 fe4e 	bl	8023c16 <memset>
            system_flag_wco_change();
 800af7a:	f016 ff2b 	bl	8021dd4 <system_flag_wco_change>
            break;
 800af7e:	e00d      	b.n	800af9c <gc_execute_block+0x4d80>
            gc_state.g92_coord_offset_applied = true; // TODO: check for all zero?
 800af80:	4baf      	ldr	r3, [pc, #700]	; (800b240 <gc_execute_block+0x5024>)
 800af82:	2201      	movs	r2, #1
 800af84:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
            settings_read_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Restore G92 offsets from non-volatile storage
 800af88:	49ae      	ldr	r1, [pc, #696]	; (800b244 <gc_execute_block+0x5028>)
 800af8a:	200b      	movs	r0, #11
 800af8c:	f00f fe44 	bl	801ac18 <settings_read_coord_data>
            system_flag_wco_change();
 800af90:	f016 ff20 	bl	8021dd4 <system_flag_wco_change>
            break;
 800af94:	e002      	b.n	800af9c <gc_execute_block+0x4d80>
            break;
 800af96:	bf00      	nop
 800af98:	e000      	b.n	800af9c <gc_execute_block+0x4d80>
            break;
 800af9a:	bf00      	nop
    }

    // [20. Motion modes ]:
    // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
    // Enter motion modes only if there are axis words or a motion mode command word in the block.
    gc_state.modal.motion = gc_block.modal.motion;
 800af9c:	4bab      	ldr	r3, [pc, #684]	; (800b24c <gc_execute_block+0x5030>)
 800af9e:	891a      	ldrh	r2, [r3, #8]
 800afa0:	4ba7      	ldr	r3, [pc, #668]	; (800b240 <gc_execute_block+0x5024>)
 800afa2:	801a      	strh	r2, [r3, #0]
    gc_state.modal.canned_cycle_active = gc_block.modal.canned_cycle_active;
 800afa4:	4ba9      	ldr	r3, [pc, #676]	; (800b24c <gc_execute_block+0x5030>)
 800afa6:	f893 2027 	ldrb.w	r2, [r3, #39]	; 0x27
 800afaa:	4ba5      	ldr	r3, [pc, #660]	; (800b240 <gc_execute_block+0x5024>)
 800afac:	77da      	strb	r2, [r3, #31]

    if (gc_state.modal.motion != MotionMode_None && axis_command == AxisCommand_MotionMode) {
 800afae:	4ba4      	ldr	r3, [pc, #656]	; (800b240 <gc_execute_block+0x5024>)
 800afb0:	881b      	ldrh	r3, [r3, #0]
 800afb2:	2b50      	cmp	r3, #80	; 0x50
 800afb4:	f000 82aa 	beq.w	800b50c <gc_execute_block+0x52f0>
 800afb8:	f897 310d 	ldrb.w	r3, [r7, #269]	; 0x10d
 800afbc:	2b02      	cmp	r3, #2
 800afbe:	f040 82a5 	bne.w	800b50c <gc_execute_block+0x52f0>

        plan_data.output_commands = output_commands;
 800afc2:	4ba3      	ldr	r3, [pc, #652]	; (800b250 <gc_execute_block+0x5034>)
 800afc4:	681b      	ldr	r3, [r3, #0]
 800afc6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        output_commands = NULL;
 800afca:	4ba1      	ldr	r3, [pc, #644]	; (800b250 <gc_execute_block+0x5034>)
 800afcc:	2200      	movs	r2, #0
 800afce:	601a      	str	r2, [r3, #0]

        pos_update_t gc_update_pos = GCUpdatePos_Target;
 800afd0:	2300      	movs	r3, #0
 800afd2:	f887 30ee 	strb.w	r3, [r7, #238]	; 0xee

        switch(gc_state.modal.motion) {
 800afd6:	4b9a      	ldr	r3, [pc, #616]	; (800b240 <gc_execute_block+0x5024>)
 800afd8:	881b      	ldrh	r3, [r3, #0]
 800afda:	2b53      	cmp	r3, #83	; 0x53
 800afdc:	f300 80b2 	bgt.w	800b144 <gc_execute_block+0x4f28>
 800afe0:	2b00      	cmp	r3, #0
 800afe2:	f2c0 8253 	blt.w	800b48c <gc_execute_block+0x5270>
 800afe6:	2b53      	cmp	r3, #83	; 0x53
 800afe8:	f200 8250 	bhi.w	800b48c <gc_execute_block+0x5270>
 800afec:	a201      	add	r2, pc, #4	; (adr r2, 800aff4 <gc_execute_block+0x4dd8>)
 800afee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aff2:	bf00      	nop
 800aff4:	0800b171 	.word	0x0800b171
 800aff8:	0800b14f 	.word	0x0800b14f
 800affc:	0800b18b 	.word	0x0800b18b
 800b000:	0800b18b 	.word	0x0800b18b
 800b004:	0800b48d 	.word	0x0800b48d
 800b008:	0800b1d5 	.word	0x0800b1d5
 800b00c:	0800b48d 	.word	0x0800b48d
 800b010:	0800b48d 	.word	0x0800b48d
 800b014:	0800b48d 	.word	0x0800b48d
 800b018:	0800b48d 	.word	0x0800b48d
 800b01c:	0800b48d 	.word	0x0800b48d
 800b020:	0800b48d 	.word	0x0800b48d
 800b024:	0800b48d 	.word	0x0800b48d
 800b028:	0800b48d 	.word	0x0800b48d
 800b02c:	0800b48d 	.word	0x0800b48d
 800b030:	0800b48d 	.word	0x0800b48d
 800b034:	0800b48d 	.word	0x0800b48d
 800b038:	0800b48d 	.word	0x0800b48d
 800b03c:	0800b48d 	.word	0x0800b48d
 800b040:	0800b48d 	.word	0x0800b48d
 800b044:	0800b48d 	.word	0x0800b48d
 800b048:	0800b48d 	.word	0x0800b48d
 800b04c:	0800b48d 	.word	0x0800b48d
 800b050:	0800b48d 	.word	0x0800b48d
 800b054:	0800b48d 	.word	0x0800b48d
 800b058:	0800b48d 	.word	0x0800b48d
 800b05c:	0800b48d 	.word	0x0800b48d
 800b060:	0800b48d 	.word	0x0800b48d
 800b064:	0800b48d 	.word	0x0800b48d
 800b068:	0800b48d 	.word	0x0800b48d
 800b06c:	0800b48d 	.word	0x0800b48d
 800b070:	0800b48d 	.word	0x0800b48d
 800b074:	0800b48d 	.word	0x0800b48d
 800b078:	0800b357 	.word	0x0800b357
 800b07c:	0800b48d 	.word	0x0800b48d
 800b080:	0800b48d 	.word	0x0800b48d
 800b084:	0800b48d 	.word	0x0800b48d
 800b088:	0800b48d 	.word	0x0800b48d
 800b08c:	0800b48d 	.word	0x0800b48d
 800b090:	0800b48d 	.word	0x0800b48d
 800b094:	0800b48d 	.word	0x0800b48d
 800b098:	0800b48d 	.word	0x0800b48d
 800b09c:	0800b48d 	.word	0x0800b48d
 800b0a0:	0800b48d 	.word	0x0800b48d
 800b0a4:	0800b48d 	.word	0x0800b48d
 800b0a8:	0800b48d 	.word	0x0800b48d
 800b0ac:	0800b48d 	.word	0x0800b48d
 800b0b0:	0800b48d 	.word	0x0800b48d
 800b0b4:	0800b48d 	.word	0x0800b48d
 800b0b8:	0800b48d 	.word	0x0800b48d
 800b0bc:	0800b48d 	.word	0x0800b48d
 800b0c0:	0800b261 	.word	0x0800b261
 800b0c4:	0800b48d 	.word	0x0800b48d
 800b0c8:	0800b48d 	.word	0x0800b48d
 800b0cc:	0800b48d 	.word	0x0800b48d
 800b0d0:	0800b48d 	.word	0x0800b48d
 800b0d4:	0800b48d 	.word	0x0800b48d
 800b0d8:	0800b48d 	.word	0x0800b48d
 800b0dc:	0800b48d 	.word	0x0800b48d
 800b0e0:	0800b48d 	.word	0x0800b48d
 800b0e4:	0800b48d 	.word	0x0800b48d
 800b0e8:	0800b48d 	.word	0x0800b48d
 800b0ec:	0800b48d 	.word	0x0800b48d
 800b0f0:	0800b48d 	.word	0x0800b48d
 800b0f4:	0800b48d 	.word	0x0800b48d
 800b0f8:	0800b48d 	.word	0x0800b48d
 800b0fc:	0800b48d 	.word	0x0800b48d
 800b100:	0800b48d 	.word	0x0800b48d
 800b104:	0800b48d 	.word	0x0800b48d
 800b108:	0800b48d 	.word	0x0800b48d
 800b10c:	0800b48d 	.word	0x0800b48d
 800b110:	0800b48d 	.word	0x0800b48d
 800b114:	0800b48d 	.word	0x0800b48d
 800b118:	0800b40f 	.word	0x0800b40f
 800b11c:	0800b48d 	.word	0x0800b48d
 800b120:	0800b48d 	.word	0x0800b48d
 800b124:	0800b3b1 	.word	0x0800b3b1
 800b128:	0800b48d 	.word	0x0800b48d
 800b12c:	0800b48d 	.word	0x0800b48d
 800b130:	0800b48d 	.word	0x0800b48d
 800b134:	0800b48d 	.word	0x0800b48d
 800b138:	0800b40f 	.word	0x0800b40f
 800b13c:	0800b40f 	.word	0x0800b40f
 800b140:	0800b40f 	.word	0x0800b40f
 800b144:	3b8c      	subs	r3, #140	; 0x8c
 800b146:	2b03      	cmp	r3, #3
 800b148:	f200 81a0 	bhi.w	800b48c <gc_execute_block+0x5270>
 800b14c:	e181      	b.n	800b452 <gc_execute_block+0x5236>

            case MotionMode_Linear:
                if(gc_state.modal.feed_mode == FeedMode_UnitsPerRev) {
 800b14e:	4b3c      	ldr	r3, [pc, #240]	; (800b240 <gc_execute_block+0x5024>)
 800b150:	789b      	ldrb	r3, [r3, #2]
 800b152:	2b02      	cmp	r3, #2
 800b154:	d105      	bne.n	800b162 <gc_execute_block+0x4f46>
                    plan_data.spindle.state.synchronized = On;
 800b156:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 800b15a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b15e:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
                //??    gc_state.distance_per_rev = plan_data.feed_rate;
                    // check initial feed rate - fail if zero?
                }
                mc_line(gc_block.values.xyz, &plan_data);
 800b162:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b166:	4619      	mov	r1, r3
 800b168:	483a      	ldr	r0, [pc, #232]	; (800b254 <gc_execute_block+0x5038>)
 800b16a:	f002 fc45 	bl	800d9f8 <mc_line>
                break;
 800b16e:	e18e      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_Seek:
                plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 800b170:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800b174:	f043 0301 	orr.w	r3, r3, #1
 800b178:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78
                mc_line(gc_block.values.xyz, &plan_data);
 800b17c:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b180:	4619      	mov	r1, r3
 800b182:	4834      	ldr	r0, [pc, #208]	; (800b254 <gc_execute_block+0x5038>)
 800b184:	f002 fc38 	bl	800d9f8 <mc_line>
                break;
 800b188:	e181      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_CwArc:
            case MotionMode_CcwArc:
                // fail if spindle synchronized motion?
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 800b18a:	4b30      	ldr	r3, [pc, #192]	; (800b24c <gc_execute_block+0x5030>)
 800b18c:	6d99      	ldr	r1, [r3, #88]	; 0x58
                        plane, gc_parser_flags.arc_is_clockwise ? -gc_block.arc_turns : gc_block.arc_turns);
 800b18e:	f897 309c 	ldrb.w	r3, [r7, #156]	; 0x9c
 800b192:	f003 0304 	and.w	r3, r3, #4
 800b196:	b2db      	uxtb	r3, r3
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 800b198:	2b00      	cmp	r3, #0
 800b19a:	d004      	beq.n	800b1a6 <gc_execute_block+0x4f8a>
                        plane, gc_parser_flags.arc_is_clockwise ? -gc_block.arc_turns : gc_block.arc_turns);
 800b19c:	4b2b      	ldr	r3, [pc, #172]	; (800b24c <gc_execute_block+0x5030>)
 800b19e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800b1a2:	425b      	negs	r3, r3
 800b1a4:	e002      	b.n	800b1ac <gc_execute_block+0x4f90>
 800b1a6:	4b29      	ldr	r3, [pc, #164]	; (800b24c <gc_execute_block+0x5030>)
 800b1a8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 800b1ac:	f107 0060 	add.w	r0, r7, #96	; 0x60
 800b1b0:	9302      	str	r3, [sp, #8]
 800b1b2:	ab01      	add	r3, sp, #4
 800b1b4:	f107 02ac 	add.w	r2, r7, #172	; 0xac
 800b1b8:	6812      	ldr	r2, [r2, #0]
 800b1ba:	4614      	mov	r4, r2
 800b1bc:	801c      	strh	r4, [r3, #0]
 800b1be:	3302      	adds	r3, #2
 800b1c0:	0c12      	lsrs	r2, r2, #16
 800b1c2:	701a      	strb	r2, [r3, #0]
 800b1c4:	9100      	str	r1, [sp, #0]
 800b1c6:	4b24      	ldr	r3, [pc, #144]	; (800b258 <gc_execute_block+0x503c>)
 800b1c8:	4a24      	ldr	r2, [pc, #144]	; (800b25c <gc_execute_block+0x5040>)
 800b1ca:	4601      	mov	r1, r0
 800b1cc:	4821      	ldr	r0, [pc, #132]	; (800b254 <gc_execute_block+0x5038>)
 800b1ce:	f002 fccf 	bl	800db70 <mc_arc>
                break;
 800b1d2:	e15c      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_CubicSpline:
                {
                    point_2d_t cp1 = {
                        .x = gc_state.position[X_AXIS] + gc_block.values.ijk[X_AXIS],
 800b1d4:	4b1a      	ldr	r3, [pc, #104]	; (800b240 <gc_execute_block+0x5024>)
 800b1d6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b1d8:	4a1c      	ldr	r2, [pc, #112]	; (800b24c <gc_execute_block+0x5030>)
 800b1da:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800b1dc:	4611      	mov	r1, r2
 800b1de:	4618      	mov	r0, r3
 800b1e0:	f7f5 fce0 	bl	8000ba4 <__addsf3>
 800b1e4:	4603      	mov	r3, r0
                    point_2d_t cp1 = {
 800b1e6:	647b      	str	r3, [r7, #68]	; 0x44
                        .y = gc_state.position[Y_AXIS] + gc_block.values.ijk[Y_AXIS]
 800b1e8:	4b15      	ldr	r3, [pc, #84]	; (800b240 <gc_execute_block+0x5024>)
 800b1ea:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b1ec:	4a17      	ldr	r2, [pc, #92]	; (800b24c <gc_execute_block+0x5030>)
 800b1ee:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800b1f0:	4611      	mov	r1, r2
 800b1f2:	4618      	mov	r0, r3
 800b1f4:	f7f5 fcd6 	bl	8000ba4 <__addsf3>
 800b1f8:	4603      	mov	r3, r0
                    point_2d_t cp1 = {
 800b1fa:	64bb      	str	r3, [r7, #72]	; 0x48
                    };
                    point_2d_t cp2 = {
                        .x = gc_block.values.xyz[X_AXIS] + gc_state.modal.spline_pq[X_AXIS],
 800b1fc:	4b13      	ldr	r3, [pc, #76]	; (800b24c <gc_execute_block+0x5030>)
 800b1fe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b200:	4a0f      	ldr	r2, [pc, #60]	; (800b240 <gc_execute_block+0x5024>)
 800b202:	6a12      	ldr	r2, [r2, #32]
 800b204:	4611      	mov	r1, r2
 800b206:	4618      	mov	r0, r3
 800b208:	f7f5 fccc 	bl	8000ba4 <__addsf3>
 800b20c:	4603      	mov	r3, r0
                    point_2d_t cp2 = {
 800b20e:	63fb      	str	r3, [r7, #60]	; 0x3c
                        .y = gc_block.values.xyz[Y_AXIS] + gc_state.modal.spline_pq[Y_AXIS]
 800b210:	4b0e      	ldr	r3, [pc, #56]	; (800b24c <gc_execute_block+0x5030>)
 800b212:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800b214:	4a0a      	ldr	r2, [pc, #40]	; (800b240 <gc_execute_block+0x5024>)
 800b216:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b218:	4611      	mov	r1, r2
 800b21a:	4618      	mov	r0, r3
 800b21c:	f7f5 fcc2 	bl	8000ba4 <__addsf3>
 800b220:	4603      	mov	r3, r0
                    point_2d_t cp2 = {
 800b222:	643b      	str	r3, [r7, #64]	; 0x40
                    };
                    mc_cubic_b_spline(gc_block.values.xyz, &plan_data, gc_state.position, cp1.values, cp2.values);
 800b224:	f107 0244 	add.w	r2, r7, #68	; 0x44
 800b228:	f107 0160 	add.w	r1, r7, #96	; 0x60
 800b22c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800b230:	9300      	str	r3, [sp, #0]
 800b232:	4613      	mov	r3, r2
 800b234:	4a09      	ldr	r2, [pc, #36]	; (800b25c <gc_execute_block+0x5040>)
 800b236:	4807      	ldr	r0, [pc, #28]	; (800b254 <gc_execute_block+0x5038>)
 800b238:	f003 f8e2 	bl	800e400 <mc_cubic_b_spline>
                }
                break;
 800b23c:	e127      	b.n	800b48e <gc_execute_block+0x5272>
 800b23e:	bf00      	nop
 800b240:	20000bb0 	.word	0x20000bb0
 800b244:	20000c28 	.word	0x20000c28
 800b248:	2000147c 	.word	0x2000147c
 800b24c:	20000c8c 	.word	0x20000c8c
 800b250:	20000c74 	.word	0x20000c74
 800b254:	20000cec 	.word	0x20000cec
 800b258:	20000cc8 	.word	0x20000cc8
 800b25c:	20000c0c 	.word	0x20000c0c

            case MotionMode_QuadraticSpline:
                {
                    point_2d_t cp1 = {
                        .x = gc_state.position[X_AXIS] + (gc_block.values.ijk[X_AXIS] * 2.0f) / 3.0f,
 800b260:	4b9d      	ldr	r3, [pc, #628]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b262:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
 800b264:	4b9d      	ldr	r3, [pc, #628]	; (800b4dc <gc_execute_block+0x52c0>)
 800b266:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b268:	4619      	mov	r1, r3
 800b26a:	4618      	mov	r0, r3
 800b26c:	f7f5 fc9a 	bl	8000ba4 <__addsf3>
 800b270:	4603      	mov	r3, r0
 800b272:	499b      	ldr	r1, [pc, #620]	; (800b4e0 <gc_execute_block+0x52c4>)
 800b274:	4618      	mov	r0, r3
 800b276:	f7f5 fe51 	bl	8000f1c <__aeabi_fdiv>
 800b27a:	4603      	mov	r3, r0
 800b27c:	4619      	mov	r1, r3
 800b27e:	4620      	mov	r0, r4
 800b280:	f7f5 fc90 	bl	8000ba4 <__addsf3>
 800b284:	4603      	mov	r3, r0
                    point_2d_t cp1 = {
 800b286:	637b      	str	r3, [r7, #52]	; 0x34
                        .y = gc_state.position[Y_AXIS] + (gc_block.values.ijk[Y_AXIS] * 2.0f) / 3.0f
 800b288:	4b93      	ldr	r3, [pc, #588]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b28a:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 800b28c:	4b93      	ldr	r3, [pc, #588]	; (800b4dc <gc_execute_block+0x52c0>)
 800b28e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b290:	4619      	mov	r1, r3
 800b292:	4618      	mov	r0, r3
 800b294:	f7f5 fc86 	bl	8000ba4 <__addsf3>
 800b298:	4603      	mov	r3, r0
 800b29a:	4991      	ldr	r1, [pc, #580]	; (800b4e0 <gc_execute_block+0x52c4>)
 800b29c:	4618      	mov	r0, r3
 800b29e:	f7f5 fe3d 	bl	8000f1c <__aeabi_fdiv>
 800b2a2:	4603      	mov	r3, r0
 800b2a4:	4619      	mov	r1, r3
 800b2a6:	4620      	mov	r0, r4
 800b2a8:	f7f5 fc7c 	bl	8000ba4 <__addsf3>
 800b2ac:	4603      	mov	r3, r0
                    point_2d_t cp1 = {
 800b2ae:	63bb      	str	r3, [r7, #56]	; 0x38
                    };
                    point_2d_t cp2 = {
                        .x = gc_block.values.xyz[X_AXIS] + ((gc_state.position[X_AXIS] + gc_block.values.ijk[X_AXIS] - gc_block.values.xyz[X_AXIS]) * 2.0f) / 3.0f,
 800b2b0:	4b8a      	ldr	r3, [pc, #552]	; (800b4dc <gc_execute_block+0x52c0>)
 800b2b2:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 800b2b4:	4b88      	ldr	r3, [pc, #544]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b2b6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b2b8:	4a88      	ldr	r2, [pc, #544]	; (800b4dc <gc_execute_block+0x52c0>)
 800b2ba:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 800b2bc:	4611      	mov	r1, r2
 800b2be:	4618      	mov	r0, r3
 800b2c0:	f7f5 fc70 	bl	8000ba4 <__addsf3>
 800b2c4:	4603      	mov	r3, r0
 800b2c6:	461a      	mov	r2, r3
 800b2c8:	4b84      	ldr	r3, [pc, #528]	; (800b4dc <gc_execute_block+0x52c0>)
 800b2ca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b2cc:	4619      	mov	r1, r3
 800b2ce:	4610      	mov	r0, r2
 800b2d0:	f7f5 fc66 	bl	8000ba0 <__aeabi_fsub>
 800b2d4:	4603      	mov	r3, r0
 800b2d6:	4619      	mov	r1, r3
 800b2d8:	4618      	mov	r0, r3
 800b2da:	f7f5 fc63 	bl	8000ba4 <__addsf3>
 800b2de:	4603      	mov	r3, r0
 800b2e0:	497f      	ldr	r1, [pc, #508]	; (800b4e0 <gc_execute_block+0x52c4>)
 800b2e2:	4618      	mov	r0, r3
 800b2e4:	f7f5 fe1a 	bl	8000f1c <__aeabi_fdiv>
 800b2e8:	4603      	mov	r3, r0
 800b2ea:	4619      	mov	r1, r3
 800b2ec:	4620      	mov	r0, r4
 800b2ee:	f7f5 fc59 	bl	8000ba4 <__addsf3>
 800b2f2:	4603      	mov	r3, r0
                    point_2d_t cp2 = {
 800b2f4:	62fb      	str	r3, [r7, #44]	; 0x2c
                        .y = gc_block.values.xyz[Y_AXIS] + ((gc_state.position[Y_AXIS] + gc_block.values.ijk[Y_AXIS] - gc_block.values.xyz[Y_AXIS]) * 2.0f) / 3.0f
 800b2f6:	4b79      	ldr	r3, [pc, #484]	; (800b4dc <gc_execute_block+0x52c0>)
 800b2f8:	6e5c      	ldr	r4, [r3, #100]	; 0x64
 800b2fa:	4b77      	ldr	r3, [pc, #476]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b2fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b2fe:	4a77      	ldr	r2, [pc, #476]	; (800b4dc <gc_execute_block+0x52c0>)
 800b300:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800b302:	4611      	mov	r1, r2
 800b304:	4618      	mov	r0, r3
 800b306:	f7f5 fc4d 	bl	8000ba4 <__addsf3>
 800b30a:	4603      	mov	r3, r0
 800b30c:	461a      	mov	r2, r3
 800b30e:	4b73      	ldr	r3, [pc, #460]	; (800b4dc <gc_execute_block+0x52c0>)
 800b310:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800b312:	4619      	mov	r1, r3
 800b314:	4610      	mov	r0, r2
 800b316:	f7f5 fc43 	bl	8000ba0 <__aeabi_fsub>
 800b31a:	4603      	mov	r3, r0
 800b31c:	4619      	mov	r1, r3
 800b31e:	4618      	mov	r0, r3
 800b320:	f7f5 fc40 	bl	8000ba4 <__addsf3>
 800b324:	4603      	mov	r3, r0
 800b326:	496e      	ldr	r1, [pc, #440]	; (800b4e0 <gc_execute_block+0x52c4>)
 800b328:	4618      	mov	r0, r3
 800b32a:	f7f5 fdf7 	bl	8000f1c <__aeabi_fdiv>
 800b32e:	4603      	mov	r3, r0
 800b330:	4619      	mov	r1, r3
 800b332:	4620      	mov	r0, r4
 800b334:	f7f5 fc36 	bl	8000ba4 <__addsf3>
 800b338:	4603      	mov	r3, r0
                    point_2d_t cp2 = {
 800b33a:	633b      	str	r3, [r7, #48]	; 0x30
                    };
                    mc_cubic_b_spline(gc_block.values.xyz, &plan_data, gc_state.position, cp1.values, cp2.values);
 800b33c:	f107 0234 	add.w	r2, r7, #52	; 0x34
 800b340:	f107 0160 	add.w	r1, r7, #96	; 0x60
 800b344:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b348:	9300      	str	r3, [sp, #0]
 800b34a:	4613      	mov	r3, r2
 800b34c:	4a65      	ldr	r2, [pc, #404]	; (800b4e4 <gc_execute_block+0x52c8>)
 800b34e:	4866      	ldr	r0, [pc, #408]	; (800b4e8 <gc_execute_block+0x52cc>)
 800b350:	f003 f856 	bl	800e400 <mc_cubic_b_spline>
                }
                break;
 800b354:	e09b      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_SpindleSynchronized:
                {
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 800b356:	f007 fcd3 	bl	8012d00 <protocol_buffer_synchronize>

                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 800b35a:	4b64      	ldr	r3, [pc, #400]	; (800b4ec <gc_execute_block+0x52d0>)
 800b35c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800b360:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28

                    status_code_t status = init_sync_motion(&plan_data, gc_block.values.k);
 800b364:	4b5d      	ldr	r3, [pc, #372]	; (800b4dc <gc_execute_block+0x52c0>)
 800b366:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800b368:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b36c:	4611      	mov	r1, r2
 800b36e:	4618      	mov	r0, r3
 800b370:	f7fa fdbc 	bl	8005eec <init_sync_motion>
 800b374:	4603      	mov	r3, r0
 800b376:	f887 30c1 	strb.w	r3, [r7, #193]	; 0xc1
                    if(status != Status_OK)
 800b37a:	f897 30c1 	ldrb.w	r3, [r7, #193]	; 0xc1
 800b37e:	2b00      	cmp	r3, #0
 800b380:	d002      	beq.n	800b388 <gc_execute_block+0x516c>
                        FAIL(status);
 800b382:	f897 30c1 	ldrb.w	r3, [r7, #193]	; 0xc1
 800b386:	e241      	b.n	800b80c <gc_execute_block+0x55f0>

                    plan_data.spindle.state.synchronized = On;
 800b388:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 800b38c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b390:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c

                    mc_line(gc_block.values.xyz, &plan_data);
 800b394:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b398:	4619      	mov	r1, r3
 800b39a:	4853      	ldr	r0, [pc, #332]	; (800b4e8 <gc_execute_block+0x52cc>)
 800b39c:	f002 fb2c 	bl	800d9f8 <mc_line>

                    protocol_buffer_synchronize();    // Wait until synchronized move is finished,
 800b3a0:	f007 fcae 	bl	8012d00 <protocol_buffer_synchronize>
                    sys.override.control = overrides; // then restore previous override disable status.
 800b3a4:	4a51      	ldr	r2, [pc, #324]	; (800b4ec <gc_execute_block+0x52d0>)
 800b3a6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800b3aa:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
                }
                break;
 800b3ae:	e06e      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_Threading:
                {
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 800b3b0:	f007 fca6 	bl	8012d00 <protocol_buffer_synchronize>

                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 800b3b4:	4b4d      	ldr	r3, [pc, #308]	; (800b4ec <gc_execute_block+0x52d0>)
 800b3b6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 800b3ba:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24

                    status_code_t status = init_sync_motion(&plan_data, thread.pitch);
 800b3be:	4b4c      	ldr	r3, [pc, #304]	; (800b4f0 <gc_execute_block+0x52d4>)
 800b3c0:	681a      	ldr	r2, [r3, #0]
 800b3c2:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b3c6:	4611      	mov	r1, r2
 800b3c8:	4618      	mov	r0, r3
 800b3ca:	f7fa fd8f 	bl	8005eec <init_sync_motion>
 800b3ce:	4603      	mov	r3, r0
 800b3d0:	f887 30c2 	strb.w	r3, [r7, #194]	; 0xc2
                    if(status != Status_OK)
 800b3d4:	f897 30c2 	ldrb.w	r3, [r7, #194]	; 0xc2
 800b3d8:	2b00      	cmp	r3, #0
 800b3da:	d002      	beq.n	800b3e2 <gc_execute_block+0x51c6>
                        FAIL(status);
 800b3dc:	f897 30c2 	ldrb.w	r3, [r7, #194]	; 0xc2
 800b3e0:	e214      	b.n	800b80c <gc_execute_block+0x55f0>

                    mc_thread(&plan_data, gc_state.position, &thread, overrides.feed_hold_disable);
 800b3e2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 800b3e6:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800b3ea:	b2db      	uxtb	r3, r3
 800b3ec:	2b00      	cmp	r3, #0
 800b3ee:	bf14      	ite	ne
 800b3f0:	2301      	movne	r3, #1
 800b3f2:	2300      	moveq	r3, #0
 800b3f4:	b2db      	uxtb	r3, r3
 800b3f6:	f107 0060 	add.w	r0, r7, #96	; 0x60
 800b3fa:	4a3d      	ldr	r2, [pc, #244]	; (800b4f0 <gc_execute_block+0x52d4>)
 800b3fc:	4939      	ldr	r1, [pc, #228]	; (800b4e4 <gc_execute_block+0x52c8>)
 800b3fe:	f003 fb05 	bl	800ea0c <mc_thread>

                    sys.override.control = overrides; // then restore previous override disable status.
 800b402:	4a3a      	ldr	r2, [pc, #232]	; (800b4ec <gc_execute_block+0x52d0>)
 800b404:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 800b408:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
                }
                break;
 800b40c:	e03f      	b.n	800b48e <gc_execute_block+0x5272>

            case MotionMode_DrillChipBreak:
            case MotionMode_CannedCycle81:
            case MotionMode_CannedCycle82:
            case MotionMode_CannedCycle83:;
                plan_data.spindle.rpm = gc_block.values.s;
 800b40e:	4b33      	ldr	r3, [pc, #204]	; (800b4dc <gc_execute_block+0x52c0>)
 800b410:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b412:	66bb      	str	r3, [r7, #104]	; 0x68
                gc_state.canned.retract_mode = gc_state.modal.retract_mode;
 800b414:	4b30      	ldr	r3, [pc, #192]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b416:	7f5a      	ldrb	r2, [r3, #29]
 800b418:	4b2f      	ldr	r3, [pc, #188]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b41a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 800b41e:	4b2e      	ldr	r3, [pc, #184]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b420:	8818      	ldrh	r0, [r3, #0]
 800b422:	4b2e      	ldr	r3, [pc, #184]	; (800b4dc <gc_execute_block+0x52c0>)
 800b424:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
 800b428:	461a      	mov	r2, r3
 800b42a:	f107 0160 	add.w	r1, r7, #96	; 0x60
 800b42e:	4b31      	ldr	r3, [pc, #196]	; (800b4f4 <gc_execute_block+0x52d8>)
 800b430:	9302      	str	r3, [sp, #8]
 800b432:	9201      	str	r2, [sp, #4]
 800b434:	466b      	mov	r3, sp
 800b436:	f107 02ac 	add.w	r2, r7, #172	; 0xac
 800b43a:	6812      	ldr	r2, [r2, #0]
 800b43c:	4614      	mov	r4, r2
 800b43e:	801c      	strh	r4, [r3, #0]
 800b440:	3302      	adds	r3, #2
 800b442:	0c12      	lsrs	r2, r2, #16
 800b444:	701a      	strb	r2, [r3, #0]
 800b446:	4b27      	ldr	r3, [pc, #156]	; (800b4e4 <gc_execute_block+0x52c8>)
 800b448:	460a      	mov	r2, r1
 800b44a:	4927      	ldr	r1, [pc, #156]	; (800b4e8 <gc_execute_block+0x52cc>)
 800b44c:	f003 f936 	bl	800e6bc <mc_canned_drill>
                break;
 800b450:	e01d      	b.n	800b48e <gc_execute_block+0x5272>
            case MotionMode_ProbeTowardNoError:
            case MotionMode_ProbeAway:
            case MotionMode_ProbeAwayNoError:
                // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
                // upon a successful probing cycle, the machine position and the returned value should be the same.
                plan_data.condition.no_feed_override = !settings.probe.allow_feed_override;
 800b452:	4b29      	ldr	r3, [pc, #164]	; (800b4f8 <gc_execute_block+0x52dc>)
 800b454:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 800b458:	f003 0310 	and.w	r3, r3, #16
 800b45c:	b2db      	uxtb	r3, r3
 800b45e:	2b00      	cmp	r3, #0
 800b460:	bf0c      	ite	eq
 800b462:	2301      	moveq	r3, #1
 800b464:	2300      	movne	r3, #0
 800b466:	b2da      	uxtb	r2, r3
 800b468:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 800b46c:	f362 1304 	bfi	r3, r2, #4, #1
 800b470:	f887 3078 	strb.w	r3, [r7, #120]	; 0x78
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 800b474:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800b478:	f8b7 209c 	ldrh.w	r2, [r7, #156]	; 0x9c
 800b47c:	4619      	mov	r1, r3
 800b47e:	481a      	ldr	r0, [pc, #104]	; (800b4e8 <gc_execute_block+0x52cc>)
 800b480:	f003 ff6a 	bl	800f358 <mc_probe_cycle>
 800b484:	4603      	mov	r3, r0
 800b486:	f887 30ee 	strb.w	r3, [r7, #238]	; 0xee
                break;
 800b48a:	e000      	b.n	800b48e <gc_execute_block+0x5272>

            default:
                break;
 800b48c:	bf00      	nop
        }

        // Do not update position on cancel (already done in protocol_exec_rt_system)
        if(sys.cancel)
 800b48e:	4b17      	ldr	r3, [pc, #92]	; (800b4ec <gc_execute_block+0x52d0>)
 800b490:	785b      	ldrb	r3, [r3, #1]
 800b492:	2b00      	cmp	r3, #0
 800b494:	d010      	beq.n	800b4b8 <gc_execute_block+0x529c>
            gc_update_pos = GCUpdatePos_None;
 800b496:	2302      	movs	r3, #2
 800b498:	f887 30ee 	strb.w	r3, [r7, #238]	; 0xee

        //  Clean out any remaining output commands (may linger on error)
        while(plan_data.output_commands) {
 800b49c:	e00c      	b.n	800b4b8 <gc_execute_block+0x529c>
            output_command_t *next = plan_data.output_commands;
 800b49e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800b4a2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
            free(plan_data.output_commands);
 800b4a6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800b4aa:	4618      	mov	r0, r3
 800b4ac:	f018 f80c 	bl	80234c8 <free>
            plan_data.output_commands = next;
 800b4b0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800b4b4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        while(plan_data.output_commands) {
 800b4b8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800b4bc:	2b00      	cmp	r3, #0
 800b4be:	d1ee      	bne.n	800b49e <gc_execute_block+0x5282>
        }

        // As far as the parser is concerned, the position is now == target. In reality the
        // motion control system might still be processing the action and the real tool position
        // in any intermediate location.
        if (gc_update_pos == GCUpdatePos_Target)
 800b4c0:	f897 30ee 	ldrb.w	r3, [r7, #238]	; 0xee
 800b4c4:	2b00      	cmp	r3, #0
 800b4c6:	d119      	bne.n	800b4fc <gc_execute_block+0x52e0>
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position)); // gc_state.position[] = gc_block.values.xyz[]
 800b4c8:	4b03      	ldr	r3, [pc, #12]	; (800b4d8 <gc_execute_block+0x52bc>)
 800b4ca:	4a04      	ldr	r2, [pc, #16]	; (800b4dc <gc_execute_block+0x52c0>)
 800b4cc:	335c      	adds	r3, #92	; 0x5c
 800b4ce:	3260      	adds	r2, #96	; 0x60
 800b4d0:	ca07      	ldmia	r2, {r0, r1, r2}
 800b4d2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800b4d6:	e019      	b.n	800b50c <gc_execute_block+0x52f0>
 800b4d8:	20000bb0 	.word	0x20000bb0
 800b4dc:	20000c8c 	.word	0x20000c8c
 800b4e0:	40400000 	.word	0x40400000
 800b4e4:	20000c0c 	.word	0x20000c0c
 800b4e8:	20000cec 	.word	0x20000cec
 800b4ec:	20000d3c 	.word	0x20000d3c
 800b4f0:	20000c44 	.word	0x20000c44
 800b4f4:	20000bd8 	.word	0x20000bd8
 800b4f8:	2000147c 	.word	0x2000147c
        else if (gc_update_pos == GCUpdatePos_System)
 800b4fc:	f897 30ee 	ldrb.w	r3, [r7, #238]	; 0xee
 800b500:	2b01      	cmp	r3, #1
 800b502:	d103      	bne.n	800b50c <gc_execute_block+0x52f0>
            gc_sync_position(); // gc_state.position[] = sys.position
 800b504:	49a9      	ldr	r1, [pc, #676]	; (800b7ac <gc_execute_block+0x5590>)
 800b506:	48aa      	ldr	r0, [pc, #680]	; (800b7b0 <gc_execute_block+0x5594>)
 800b508:	f016 fc82 	bl	8021e10 <system_convert_array_steps_to_mpos>
        // == GCUpdatePos_None
    }

    if(plan_data.message)
 800b50c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800b510:	2b00      	cmp	r3, #0
 800b512:	d004      	beq.n	800b51e <gc_execute_block+0x5302>
        output_message(plan_data.message);
 800b514:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800b518:	4618      	mov	r0, r3
 800b51a:	f7fa fd6b 	bl	8005ff4 <output_message>

    // [21. Program flow ]:
    // M0,M1,M2,M30,M60: Perform non-running program flow actions. During a program pause, the buffer may
    // refill and can only be resumed by the cycle start run-time command.
    gc_state.modal.program_flow = gc_block.modal.program_flow;
 800b51e:	4ba5      	ldr	r3, [pc, #660]	; (800b7b4 <gc_execute_block+0x5598>)
 800b520:	f893 2020 	ldrb.w	r2, [r3, #32]
 800b524:	4ba4      	ldr	r3, [pc, #656]	; (800b7b8 <gc_execute_block+0x559c>)
 800b526:	761a      	strb	r2, [r3, #24]

    if(gc_state.modal.program_flow || sys.flags.single_block) {
 800b528:	4ba3      	ldr	r3, [pc, #652]	; (800b7b8 <gc_execute_block+0x559c>)
 800b52a:	7e1b      	ldrb	r3, [r3, #24]
 800b52c:	2b00      	cmp	r3, #0
 800b52e:	d107      	bne.n	800b540 <gc_execute_block+0x5324>
 800b530:	4ba2      	ldr	r3, [pc, #648]	; (800b7bc <gc_execute_block+0x55a0>)
 800b532:	7d9b      	ldrb	r3, [r3, #22]
 800b534:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b538:	b2db      	uxtb	r3, r3
 800b53a:	2b00      	cmp	r3, #0
 800b53c:	f000 8165 	beq.w	800b80a <gc_execute_block+0x55ee>

        protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
 800b540:	f007 fbde 	bl	8012d00 <protocol_buffer_synchronize>

        if(gc_state.modal.program_flow == ProgramFlow_Return) {
 800b544:	4b9c      	ldr	r3, [pc, #624]	; (800b7b8 <gc_execute_block+0x559c>)
 800b546:	7e1b      	ldrb	r3, [r3, #24]
 800b548:	2b63      	cmp	r3, #99	; 0x63
 800b54a:	d10a      	bne.n	800b562 <gc_execute_block+0x5346>
            if(grbl.on_macro_return)
 800b54c:	4b9c      	ldr	r3, [pc, #624]	; (800b7c0 <gc_execute_block+0x55a4>)
 800b54e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800b552:	2b00      	cmp	r3, #0
 800b554:	f000 8156 	beq.w	800b804 <gc_execute_block+0x55e8>
                grbl.on_macro_return();
 800b558:	4b99      	ldr	r3, [pc, #612]	; (800b7c0 <gc_execute_block+0x55a4>)
 800b55a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800b55e:	4798      	blx	r3
 800b560:	e150      	b.n	800b804 <gc_execute_block+0x55e8>
        } else if(gc_state.modal.program_flow == ProgramFlow_Paused || gc_block.modal.program_flow == ProgramFlow_OptionalStop || gc_block.modal.program_flow == ProgramFlow_CompletedM60 || sys.flags.single_block) {
 800b562:	4b95      	ldr	r3, [pc, #596]	; (800b7b8 <gc_execute_block+0x559c>)
 800b564:	7e1b      	ldrb	r3, [r3, #24]
 800b566:	2b03      	cmp	r3, #3
 800b568:	d010      	beq.n	800b58c <gc_execute_block+0x5370>
 800b56a:	4b92      	ldr	r3, [pc, #584]	; (800b7b4 <gc_execute_block+0x5598>)
 800b56c:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b570:	2b01      	cmp	r3, #1
 800b572:	d00b      	beq.n	800b58c <gc_execute_block+0x5370>
 800b574:	4b8f      	ldr	r3, [pc, #572]	; (800b7b4 <gc_execute_block+0x5598>)
 800b576:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b57a:	2b3c      	cmp	r3, #60	; 0x3c
 800b57c:	d006      	beq.n	800b58c <gc_execute_block+0x5370>
 800b57e:	4b8f      	ldr	r3, [pc, #572]	; (800b7bc <gc_execute_block+0x55a0>)
 800b580:	7d9b      	ldrb	r3, [r3, #22]
 800b582:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b586:	b2db      	uxtb	r3, r3
 800b588:	2b00      	cmp	r3, #0
 800b58a:	d01d      	beq.n	800b5c8 <gc_execute_block+0x53ac>
            if(!check_mode) {
 800b58c:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800b590:	f083 0301 	eor.w	r3, r3, #1
 800b594:	b2db      	uxtb	r3, r3
 800b596:	2b00      	cmp	r3, #0
 800b598:	f000 8134 	beq.w	800b804 <gc_execute_block+0x55e8>
                if(gc_block.modal.program_flow == ProgramFlow_CompletedM60 && hal.pallet_shuttle)
 800b59c:	4b85      	ldr	r3, [pc, #532]	; (800b7b4 <gc_execute_block+0x5598>)
 800b59e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b5a2:	2b3c      	cmp	r3, #60	; 0x3c
 800b5a4:	d108      	bne.n	800b5b8 <gc_execute_block+0x539c>
 800b5a6:	4b87      	ldr	r3, [pc, #540]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b5a8:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 800b5ac:	2b00      	cmp	r3, #0
 800b5ae:	d003      	beq.n	800b5b8 <gc_execute_block+0x539c>
                    hal.pallet_shuttle();
 800b5b0:	4b84      	ldr	r3, [pc, #528]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b5b2:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 800b5b6:	4798      	blx	r3
                system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 800b5b8:	4b82      	ldr	r3, [pc, #520]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b5ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b5bc:	2108      	movs	r1, #8
 800b5be:	4882      	ldr	r0, [pc, #520]	; (800b7c8 <gc_execute_block+0x55ac>)
 800b5c0:	4798      	blx	r3
                protocol_execute_realtime(); // Execute suspend.
 800b5c2:	f007 fbcd 	bl	8012d60 <protocol_execute_realtime>
            if(!check_mode) {
 800b5c6:	e11d      	b.n	800b804 <gc_execute_block+0x55e8>
            // Upon program complete, only a subset of g-codes reset to certain defaults, according to
            // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
            // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
            // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.

            if(!check_mode && gc_block.modal.program_flow == ProgramFlow_CompletedM30 && hal.pallet_shuttle)
 800b5c8:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800b5cc:	f083 0301 	eor.w	r3, r3, #1
 800b5d0:	b2db      	uxtb	r3, r3
 800b5d2:	2b00      	cmp	r3, #0
 800b5d4:	d00d      	beq.n	800b5f2 <gc_execute_block+0x53d6>
 800b5d6:	4b77      	ldr	r3, [pc, #476]	; (800b7b4 <gc_execute_block+0x5598>)
 800b5d8:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b5dc:	2b1e      	cmp	r3, #30
 800b5de:	d108      	bne.n	800b5f2 <gc_execute_block+0x53d6>
 800b5e0:	4b78      	ldr	r3, [pc, #480]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b5e2:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 800b5e6:	2b00      	cmp	r3, #0
 800b5e8:	d003      	beq.n	800b5f2 <gc_execute_block+0x53d6>
                hal.pallet_shuttle();
 800b5ea:	4b76      	ldr	r3, [pc, #472]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b5ec:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 800b5f0:	4798      	blx	r3

            gc_state.file_run = false;
 800b5f2:	4b71      	ldr	r3, [pc, #452]	; (800b7b8 <gc_execute_block+0x559c>)
 800b5f4:	2200      	movs	r2, #0
 800b5f6:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
            gc_state.modal.motion = MotionMode_Linear;
 800b5fa:	4b6f      	ldr	r3, [pc, #444]	; (800b7b8 <gc_execute_block+0x559c>)
 800b5fc:	2201      	movs	r2, #1
 800b5fe:	801a      	strh	r2, [r3, #0]
            gc_block.modal.canned_cycle_active = false;
 800b600:	4b6c      	ldr	r3, [pc, #432]	; (800b7b4 <gc_execute_block+0x5598>)
 800b602:	2200      	movs	r2, #0
 800b604:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
            gc_state.modal.plane_select = PlaneSelect_XY;
 800b608:	4b6b      	ldr	r3, [pc, #428]	; (800b7b8 <gc_execute_block+0x559c>)
 800b60a:	2200      	movs	r2, #0
 800b60c:	719a      	strb	r2, [r3, #6]
//            gc_state.modal.plane_select = settings.flags.lathe_mode ? PlaneSelect_ZX : PlaneSelect_XY;
            gc_state.modal.spindle.rpm_mode = SpindleSpeedMode_RPM; // NOTE: not compliant with linuxcnc (?)
 800b60e:	4b6a      	ldr	r3, [pc, #424]	; (800b7b8 <gc_execute_block+0x559c>)
 800b610:	2200      	movs	r2, #0
 800b612:	76da      	strb	r2, [r3, #27]
            gc_state.modal.distance_incremental = false;
 800b614:	4b68      	ldr	r3, [pc, #416]	; (800b7b8 <gc_execute_block+0x559c>)
 800b616:	2200      	movs	r2, #0
 800b618:	711a      	strb	r2, [r3, #4]
            gc_state.modal.feed_mode = FeedMode_UnitsPerMin;
 800b61a:	4b67      	ldr	r3, [pc, #412]	; (800b7b8 <gc_execute_block+0x559c>)
 800b61c:	2200      	movs	r2, #0
 800b61e:	709a      	strb	r2, [r3, #2]
// TODO: check           gc_state.distance_per_rev = 0.0f;
            // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
            if(gc_state.modal.coord_system.id != CoordinateSystem_G54) {
 800b620:	4b65      	ldr	r3, [pc, #404]	; (800b7b8 <gc_execute_block+0x559c>)
 800b622:	7d1b      	ldrb	r3, [r3, #20]
 800b624:	2b00      	cmp	r3, #0
 800b626:	d006      	beq.n	800b636 <gc_execute_block+0x541a>
                gc_state.modal.coord_system.id = CoordinateSystem_G54;
 800b628:	4b63      	ldr	r3, [pc, #396]	; (800b7b8 <gc_execute_block+0x559c>)
 800b62a:	2200      	movs	r2, #0
 800b62c:	751a      	strb	r2, [r3, #20]
                system_add_rt_report(Report_GWCO);
 800b62e:	f44f 7000 	mov.w	r0, #512	; 0x200
 800b632:	f016 fcb3 	bl	8021f9c <system_add_rt_report>
            }
            gc_state.modal.spindle.state = (spindle_state_t){0};
 800b636:	4b60      	ldr	r3, [pc, #384]	; (800b7b8 <gc_execute_block+0x559c>)
 800b638:	2200      	movs	r2, #0
 800b63a:	769a      	strb	r2, [r3, #26]
            gc_state.modal.coolant = (coolant_state_t){0};
 800b63c:	4b5e      	ldr	r3, [pc, #376]	; (800b7b8 <gc_execute_block+0x559c>)
 800b63e:	2200      	movs	r2, #0
 800b640:	765a      	strb	r2, [r3, #25]
            gc_state.modal.override_ctrl.feed_rate_disable = Off;
 800b642:	4a5d      	ldr	r2, [pc, #372]	; (800b7b8 <gc_execute_block+0x559c>)
 800b644:	7f13      	ldrb	r3, [r2, #28]
 800b646:	f36f 0300 	bfc	r3, #0, #1
 800b64a:	7713      	strb	r3, [r2, #28]
            gc_state.modal.override_ctrl.spindle_rpm_disable = Off;
 800b64c:	4a5a      	ldr	r2, [pc, #360]	; (800b7b8 <gc_execute_block+0x559c>)
 800b64e:	7f13      	ldrb	r3, [r2, #28]
 800b650:	f36f 0382 	bfc	r3, #2, #1
 800b654:	7713      	strb	r3, [r2, #28]

            idx = N_SYS_SPINDLE;
 800b656:	2301      	movs	r3, #1
 800b658:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
            spindle_ptrs_t *spindle;
            do {
                if((spindle = spindle_get(--idx))) {
 800b65c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800b660:	3b01      	subs	r3, #1
 800b662:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 800b666:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800b66a:	b25b      	sxtb	r3, r3
 800b66c:	4618      	mov	r0, r3
 800b66e:	f011 fa45 	bl	801cafc <spindle_get>
 800b672:	f8c7 00b8 	str.w	r0, [r7, #184]	; 0xb8
 800b676:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b67a:	2b00      	cmp	r3, #0
 800b67c:	d013      	beq.n	800b6a6 <gc_execute_block+0x548a>
                    spindle->param->state.override_disable = Off;
 800b67e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b682:	685a      	ldr	r2, [r3, #4]
 800b684:	7a13      	ldrb	r3, [r2, #8]
 800b686:	f36f 1304 	bfc	r3, #4, #1
 800b68a:	7213      	strb	r3, [r2, #8]
                    if(settings.flags.restore_overrides)
 800b68c:	4b4f      	ldr	r3, [pc, #316]	; (800b7cc <gc_execute_block+0x55b0>)
 800b68e:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 800b692:	f003 0302 	and.w	r3, r3, #2
 800b696:	b2db      	uxtb	r3, r3
 800b698:	2b00      	cmp	r3, #0
 800b69a:	d004      	beq.n	800b6a6 <gc_execute_block+0x548a>
                        spindle->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 800b69c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800b6a0:	685b      	ldr	r3, [r3, #4]
 800b6a2:	2264      	movs	r2, #100	; 0x64
 800b6a4:	60da      	str	r2, [r3, #12]
                }
            } while(idx);
 800b6a6:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 800b6aa:	2b00      	cmp	r3, #0
 800b6ac:	d1d6      	bne.n	800b65c <gc_execute_block+0x5440>

            if(settings.parking.flags.enabled)
 800b6ae:	4b47      	ldr	r3, [pc, #284]	; (800b7cc <gc_execute_block+0x55b0>)
 800b6b0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800b6b4:	f003 0301 	and.w	r3, r3, #1
 800b6b8:	b2db      	uxtb	r3, r3
 800b6ba:	2b00      	cmp	r3, #0
 800b6bc:	d01a      	beq.n	800b6f4 <gc_execute_block+0x54d8>
                gc_state.modal.override_ctrl.parking_disable = settings.parking.flags.enable_override_control &&
 800b6be:	4b43      	ldr	r3, [pc, #268]	; (800b7cc <gc_execute_block+0x55b0>)
 800b6c0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800b6c4:	f003 0304 	and.w	r3, r3, #4
 800b6c8:	b2db      	uxtb	r3, r3
 800b6ca:	2b00      	cmp	r3, #0
 800b6cc:	d009      	beq.n	800b6e2 <gc_execute_block+0x54c6>
 800b6ce:	4b3f      	ldr	r3, [pc, #252]	; (800b7cc <gc_execute_block+0x55b0>)
 800b6d0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800b6d4:	f003 0302 	and.w	r3, r3, #2
 800b6d8:	b2db      	uxtb	r3, r3
 800b6da:	2b00      	cmp	r3, #0
 800b6dc:	d001      	beq.n	800b6e2 <gc_execute_block+0x54c6>
 800b6de:	2301      	movs	r3, #1
 800b6e0:	e000      	b.n	800b6e4 <gc_execute_block+0x54c8>
 800b6e2:	2300      	movs	r3, #0
 800b6e4:	f003 0301 	and.w	r3, r3, #1
 800b6e8:	b2d9      	uxtb	r1, r3
 800b6ea:	4a33      	ldr	r2, [pc, #204]	; (800b7b8 <gc_execute_block+0x559c>)
 800b6ec:	7f13      	ldrb	r3, [r2, #28]
 800b6ee:	f361 03c3 	bfi	r3, r1, #3, #1
 800b6f2:	7713      	strb	r3, [r2, #28]
                                                                settings.parking.flags.deactivate_upon_init;
            sys.override.control = gc_state.modal.override_ctrl;
 800b6f4:	4a31      	ldr	r2, [pc, #196]	; (800b7bc <gc_execute_block+0x55a0>)
 800b6f6:	4b30      	ldr	r3, [pc, #192]	; (800b7b8 <gc_execute_block+0x559c>)
 800b6f8:	7f1b      	ldrb	r3, [r3, #28]
 800b6fa:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29

            if(settings.flags.restore_overrides) {
 800b6fe:	4b33      	ldr	r3, [pc, #204]	; (800b7cc <gc_execute_block+0x55b0>)
 800b700:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 800b704:	f003 0302 	and.w	r3, r3, #2
 800b708:	b2db      	uxtb	r3, r3
 800b70a:	2b00      	cmp	r3, #0
 800b70c:	d005      	beq.n	800b71a <gc_execute_block+0x54fe>
                sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;
 800b70e:	4b2b      	ldr	r3, [pc, #172]	; (800b7bc <gc_execute_block+0x55a0>)
 800b710:	2264      	movs	r2, #100	; 0x64
 800b712:	61da      	str	r2, [r3, #28]
                sys.override.rapid_rate = DEFAULT_RAPID_OVERRIDE;
 800b714:	4b29      	ldr	r3, [pc, #164]	; (800b7bc <gc_execute_block+0x55a0>)
 800b716:	2264      	movs	r2, #100	; 0x64
 800b718:	621a      	str	r2, [r3, #32]
            }

            // Execute coordinate change and spindle/coolant stop.
            if (!check_mode) {
 800b71a:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 800b71e:	f083 0301 	eor.w	r3, r3, #1
 800b722:	b2db      	uxtb	r3, r3
 800b724:	2b00      	cmp	r3, #0
 800b726:	d033      	beq.n	800b790 <gc_execute_block+0x5574>

                if (!(settings_read_coord_data(gc_state.modal.coord_system.id, &gc_state.modal.coord_system.xyz)))
 800b728:	4b23      	ldr	r3, [pc, #140]	; (800b7b8 <gc_execute_block+0x559c>)
 800b72a:	7d1b      	ldrb	r3, [r3, #20]
 800b72c:	4928      	ldr	r1, [pc, #160]	; (800b7d0 <gc_execute_block+0x55b4>)
 800b72e:	4618      	mov	r0, r3
 800b730:	f00f fa72 	bl	801ac18 <settings_read_coord_data>
 800b734:	4603      	mov	r3, r0
 800b736:	f083 0301 	eor.w	r3, r3, #1
 800b73a:	b2db      	uxtb	r3, r3
 800b73c:	2b00      	cmp	r3, #0
 800b73e:	d001      	beq.n	800b744 <gc_execute_block+0x5528>
                    FAIL(Status_SettingReadFail);
 800b740:	2307      	movs	r3, #7
 800b742:	e063      	b.n	800b80c <gc_execute_block+0x55f0>

#if COMPATIBILITY_LEVEL <= 1
                float g92_offset_stored[N_AXIS];
                if(settings_read_coord_data(CoordinateSystem_G92, &g92_offset_stored) && !isequal_position_vector(g92_offset_stored, gc_state.g92_coord_offset))
 800b744:	f107 0318 	add.w	r3, r7, #24
 800b748:	4619      	mov	r1, r3
 800b74a:	200b      	movs	r0, #11
 800b74c:	f00f fa64 	bl	801ac18 <settings_read_coord_data>
 800b750:	4603      	mov	r3, r0
 800b752:	2b00      	cmp	r3, #0
 800b754:	d00d      	beq.n	800b772 <gc_execute_block+0x5556>
 800b756:	f107 0318 	add.w	r3, r7, #24
 800b75a:	220c      	movs	r2, #12
 800b75c:	491d      	ldr	r1, [pc, #116]	; (800b7d4 <gc_execute_block+0x55b8>)
 800b75e:	4618      	mov	r0, r3
 800b760:	f018 fa49 	bl	8023bf6 <memcmp>
 800b764:	4603      	mov	r3, r0
 800b766:	2b00      	cmp	r3, #0
 800b768:	d003      	beq.n	800b772 <gc_execute_block+0x5556>
                    settings_write_coord_data(CoordinateSystem_G92, &gc_state.g92_coord_offset); // Save G92 offsets to non-volatile storage
 800b76a:	491a      	ldr	r1, [pc, #104]	; (800b7d4 <gc_execute_block+0x55b8>)
 800b76c:	200b      	movs	r0, #11
 800b76e:	f00f fa23 	bl	801abb8 <settings_write_coord_data>
#endif

                system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 800b772:	f016 fb2f 	bl	8021dd4 <system_flag_wco_change>

                spindle_all_off();
 800b776:	f011 fcab 	bl	801d0d0 <spindle_all_off>
                hal.coolant.set_state(gc_state.modal.coolant);
 800b77a:	4b12      	ldr	r3, [pc, #72]	; (800b7c4 <gc_execute_block+0x55a8>)
 800b77c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b77e:	4a0e      	ldr	r2, [pc, #56]	; (800b7b8 <gc_execute_block+0x559c>)
 800b780:	7e50      	ldrb	r0, [r2, #25]
 800b782:	4798      	blx	r3
                system_add_rt_report(Report_Spindle); // Set to report change
 800b784:	2010      	movs	r0, #16
 800b786:	f016 fc09 	bl	8021f9c <system_add_rt_report>
                system_add_rt_report(Report_Coolant); // immediately.
 800b78a:	2020      	movs	r0, #32
 800b78c:	f016 fc06 	bl	8021f9c <system_add_rt_report>
            }

            if(grbl.on_program_completed)
 800b790:	4b0b      	ldr	r3, [pc, #44]	; (800b7c0 <gc_execute_block+0x55a4>)
 800b792:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b794:	2b00      	cmp	r3, #0
 800b796:	d02d      	beq.n	800b7f4 <gc_execute_block+0x55d8>
                grbl.on_program_completed(gc_state.modal.program_flow, check_mode);
 800b798:	4b09      	ldr	r3, [pc, #36]	; (800b7c0 <gc_execute_block+0x55a4>)
 800b79a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b79c:	4a06      	ldr	r2, [pc, #24]	; (800b7b8 <gc_execute_block+0x559c>)
 800b79e:	7e12      	ldrb	r2, [r2, #24]
 800b7a0:	f897 10d7 	ldrb.w	r1, [r7, #215]	; 0xd7
 800b7a4:	4610      	mov	r0, r2
 800b7a6:	4798      	blx	r3

            // Clear any pending output commands
            while(output_commands) {
 800b7a8:	e024      	b.n	800b7f4 <gc_execute_block+0x55d8>
 800b7aa:	bf00      	nop
 800b7ac:	20000dc4 	.word	0x20000dc4
 800b7b0:	20000c0c 	.word	0x20000c0c
 800b7b4:	20000c8c 	.word	0x20000c8c
 800b7b8:	20000bb0 	.word	0x20000bb0
 800b7bc:	20000d3c 	.word	0x20000d3c
 800b7c0:	20000dd4 	.word	0x20000dd4
 800b7c4:	20000ed0 	.word	0x20000ed0
 800b7c8:	20000d84 	.word	0x20000d84
 800b7cc:	2000147c 	.word	0x2000147c
 800b7d0:	20000bb8 	.word	0x20000bb8
 800b7d4:	20000c28 	.word	0x20000c28
                output_command_t *next = output_commands->next;
 800b7d8:	4b0f      	ldr	r3, [pc, #60]	; (800b818 <gc_execute_block+0x55fc>)
 800b7da:	681b      	ldr	r3, [r3, #0]
 800b7dc:	689b      	ldr	r3, [r3, #8]
 800b7de:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
                free(output_commands);
 800b7e2:	4b0d      	ldr	r3, [pc, #52]	; (800b818 <gc_execute_block+0x55fc>)
 800b7e4:	681b      	ldr	r3, [r3, #0]
 800b7e6:	4618      	mov	r0, r3
 800b7e8:	f017 fe6e 	bl	80234c8 <free>
                output_commands = next;
 800b7ec:	4a0a      	ldr	r2, [pc, #40]	; (800b818 <gc_execute_block+0x55fc>)
 800b7ee:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800b7f2:	6013      	str	r3, [r2, #0]
            while(output_commands) {
 800b7f4:	4b08      	ldr	r3, [pc, #32]	; (800b818 <gc_execute_block+0x55fc>)
 800b7f6:	681b      	ldr	r3, [r3, #0]
 800b7f8:	2b00      	cmp	r3, #0
 800b7fa:	d1ed      	bne.n	800b7d8 <gc_execute_block+0x55bc>
            }

            grbl.report.feedback_message(Message_ProgramEnd);
 800b7fc:	4b07      	ldr	r3, [pc, #28]	; (800b81c <gc_execute_block+0x5600>)
 800b7fe:	68db      	ldr	r3, [r3, #12]
 800b800:	2008      	movs	r0, #8
 800b802:	4798      	blx	r3
        }
        gc_state.modal.program_flow = ProgramFlow_Running; // Reset program flow.
 800b804:	4b06      	ldr	r3, [pc, #24]	; (800b820 <gc_execute_block+0x5604>)
 800b806:	2200      	movs	r2, #0
 800b808:	761a      	strb	r2, [r3, #24]
    } while(ngc_param_count);
#endif

    // TODO: % to denote start of program.

    return Status_OK;
 800b80a:	2300      	movs	r3, #0
}
 800b80c:	4618      	mov	r0, r3
 800b80e:	f507 778a 	add.w	r7, r7, #276	; 0x114
 800b812:	46bd      	mov	sp, r7
 800b814:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b818:	20000c74 	.word	0x20000c74
 800b81c:	20000dd4 	.word	0x20000dd4
 800b820:	20000bb0 	.word	0x20000bb0

0800b824 <dummy_bool_handler>:
#ifdef KINEMATICS_API
kinematics_t kinematics;
#endif

void dummy_bool_handler (bool arg)
{
 800b824:	b480      	push	{r7}
 800b826:	b083      	sub	sp, #12
 800b828:	af00      	add	r7, sp, #0
 800b82a:	4603      	mov	r3, r0
 800b82c:	71fb      	strb	r3, [r7, #7]
    // NOOP
}
 800b82e:	bf00      	nop
 800b830:	370c      	adds	r7, #12
 800b832:	46bd      	mov	sp, r7
 800b834:	bc80      	pop	{r7}
 800b836:	4770      	bx	lr

0800b838 <reset_handler>:

void reset_handler (void)
{
 800b838:	b580      	push	{r7, lr}
 800b83a:	af00      	add	r7, sp, #0
    report_init_fns();
 800b83c:	f00d f9a8 	bl	8018b90 <report_init_fns>

    grbl.on_macro_return = NULL;
 800b840:	4b02      	ldr	r3, [pc, #8]	; (800b84c <reset_handler+0x14>)
 800b842:	2200      	movs	r2, #0
 800b844:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
}
 800b848:	bf00      	nop
 800b84a:	bd80      	pop	{r7, pc}
 800b84c:	20000dd4 	.word	0x20000dd4

0800b850 <dummy_irq_claim>:

static bool dummy_irq_claim (irq_type_t irq, uint_fast8_t id, irq_callback_ptr callback)
{
 800b850:	b480      	push	{r7}
 800b852:	b085      	sub	sp, #20
 800b854:	af00      	add	r7, sp, #0
 800b856:	4603      	mov	r3, r0
 800b858:	60b9      	str	r1, [r7, #8]
 800b85a:	607a      	str	r2, [r7, #4]
 800b85c:	73fb      	strb	r3, [r7, #15]
    return false;
 800b85e:	2300      	movs	r3, #0
}
 800b860:	4618      	mov	r0, r3
 800b862:	3714      	adds	r7, #20
 800b864:	46bd      	mov	sp, r7
 800b866:	bc80      	pop	{r7}
 800b868:	4770      	bx	lr
	...

0800b86c <report_driver_error>:

static void report_driver_error (sys_state_t state)
{
 800b86c:	b5b0      	push	{r4, r5, r7, lr}
 800b86e:	b08c      	sub	sp, #48	; 0x30
 800b870:	af00      	add	r7, sp, #0
 800b872:	6078      	str	r0, [r7, #4]
    char msg[40];

    driver.ok = ~driver.ok;
 800b874:	4b1a      	ldr	r3, [pc, #104]	; (800b8e0 <report_driver_error+0x74>)
 800b876:	781b      	ldrb	r3, [r3, #0]
 800b878:	43db      	mvns	r3, r3
 800b87a:	b2da      	uxtb	r2, r3
 800b87c:	4b18      	ldr	r3, [pc, #96]	; (800b8e0 <report_driver_error+0x74>)
 800b87e:	701a      	strb	r2, [r3, #0]
    strcpy(msg, "Fatal: Incompatible driver (");
 800b880:	f107 0308 	add.w	r3, r7, #8
 800b884:	4a17      	ldr	r2, [pc, #92]	; (800b8e4 <report_driver_error+0x78>)
 800b886:	461c      	mov	r4, r3
 800b888:	4615      	mov	r5, r2
 800b88a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b88c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800b88e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 800b892:	c407      	stmia	r4!, {r0, r1, r2}
 800b894:	7023      	strb	r3, [r4, #0]
    strcat(msg, uitoa(driver.ok));
 800b896:	4b12      	ldr	r3, [pc, #72]	; (800b8e0 <report_driver_error+0x74>)
 800b898:	781b      	ldrb	r3, [r3, #0]
 800b89a:	4618      	mov	r0, r3
 800b89c:	f004 fcf6 	bl	801028c <uitoa>
 800b8a0:	4602      	mov	r2, r0
 800b8a2:	f107 0308 	add.w	r3, r7, #8
 800b8a6:	4611      	mov	r1, r2
 800b8a8:	4618      	mov	r0, r3
 800b8aa:	f018 f9bc 	bl	8023c26 <strcat>
    strcat(msg, ")");
 800b8ae:	f107 0308 	add.w	r3, r7, #8
 800b8b2:	4618      	mov	r0, r3
 800b8b4:	f7f4 fcc2 	bl	800023c <strlen>
 800b8b8:	4603      	mov	r3, r0
 800b8ba:	461a      	mov	r2, r3
 800b8bc:	f107 0308 	add.w	r3, r7, #8
 800b8c0:	4413      	add	r3, r2
 800b8c2:	4909      	ldr	r1, [pc, #36]	; (800b8e8 <report_driver_error+0x7c>)
 800b8c4:	461a      	mov	r2, r3
 800b8c6:	460b      	mov	r3, r1
 800b8c8:	881b      	ldrh	r3, [r3, #0]
 800b8ca:	8013      	strh	r3, [r2, #0]

    report_message(msg, Message_Plain);
 800b8cc:	f107 0308 	add.w	r3, r7, #8
 800b8d0:	2100      	movs	r1, #0
 800b8d2:	4618      	mov	r0, r3
 800b8d4:	f008 fe10 	bl	80144f8 <report_message>
}
 800b8d8:	bf00      	nop
 800b8da:	3730      	adds	r7, #48	; 0x30
 800b8dc:	46bd      	mov	sp, r7
 800b8de:	bdb0      	pop	{r4, r5, r7, pc}
 800b8e0:	20000260 	.word	0x20000260
 800b8e4:	0802904c 	.word	0x0802904c
 800b8e8:	0802906c 	.word	0x0802906c

0800b8ec <auto_realtime_report>:

static void auto_realtime_report (sys_state_t state)
{
 800b8ec:	b580      	push	{r7, lr}
 800b8ee:	b084      	sub	sp, #16
 800b8f0:	af00      	add	r7, sp, #0
 800b8f2:	6078      	str	r0, [r7, #4]
    static uint32_t ms = 0;

    if(sys.flags.auto_reporting) {
 800b8f4:	4b11      	ldr	r3, [pc, #68]	; (800b93c <auto_realtime_report+0x50>)
 800b8f6:	7ddb      	ldrb	r3, [r3, #23]
 800b8f8:	f003 0302 	and.w	r3, r3, #2
 800b8fc:	b2db      	uxtb	r3, r3
 800b8fe:	2b00      	cmp	r3, #0
 800b900:	d014      	beq.n	800b92c <auto_realtime_report+0x40>

        uint32_t t = hal.get_elapsed_ticks();
 800b902:	4b0f      	ldr	r3, [pc, #60]	; (800b940 <auto_realtime_report+0x54>)
 800b904:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 800b908:	4798      	blx	r3
 800b90a:	60f8      	str	r0, [r7, #12]

        if(t - ms >= settings.report_interval) {
 800b90c:	4b0d      	ldr	r3, [pc, #52]	; (800b944 <auto_realtime_report+0x58>)
 800b90e:	681b      	ldr	r3, [r3, #0]
 800b910:	68fa      	ldr	r2, [r7, #12]
 800b912:	1ad3      	subs	r3, r2, r3
 800b914:	4a0c      	ldr	r2, [pc, #48]	; (800b948 <auto_realtime_report+0x5c>)
 800b916:	8a92      	ldrh	r2, [r2, #20]
 800b918:	4293      	cmp	r3, r2
 800b91a:	d307      	bcc.n	800b92c <auto_realtime_report+0x40>
            ms = t;
 800b91c:	4a09      	ldr	r2, [pc, #36]	; (800b944 <auto_realtime_report+0x58>)
 800b91e:	68fb      	ldr	r3, [r7, #12]
 800b920:	6013      	str	r3, [r2, #0]
            system_set_exec_state_flag(EXEC_STATUS_REPORT);
 800b922:	4b07      	ldr	r3, [pc, #28]	; (800b940 <auto_realtime_report+0x54>)
 800b924:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b926:	2101      	movs	r1, #1
 800b928:	4808      	ldr	r0, [pc, #32]	; (800b94c <auto_realtime_report+0x60>)
 800b92a:	4798      	blx	r3
        }
    }

    on_execute_realtime(state);
 800b92c:	4b08      	ldr	r3, [pc, #32]	; (800b950 <auto_realtime_report+0x64>)
 800b92e:	681b      	ldr	r3, [r3, #0]
 800b930:	6878      	ldr	r0, [r7, #4]
 800b932:	4798      	blx	r3
}
 800b934:	bf00      	nop
 800b936:	3710      	adds	r7, #16
 800b938:	46bd      	mov	sp, r7
 800b93a:	bd80      	pop	{r7, pc}
 800b93c:	20000d3c 	.word	0x20000d3c
 800b940:	20000ed0 	.word	0x20000ed0
 800b944:	200010a8 	.word	0x200010a8
 800b948:	2000147c 	.word	0x2000147c
 800b94c:	20000d84 	.word	0x20000d84
 800b950:	20001084 	.word	0x20001084

0800b954 <get_homing_status>:

// "Wire" homing signals to limit signals, used when max limit inputs not available.
ISR_CODE static home_signals_t ISR_FUNC(get_homing_status)(void)
{
 800b954:	b580      	push	{r7, lr}
 800b956:	b084      	sub	sp, #16
 800b958:	af00      	add	r7, sp, #0
    home_signals_t home;
    limit_signals_t limits = hal.limits.get_state();
 800b95a:	4b0b      	ldr	r3, [pc, #44]	; (800b988 <get_homing_status+0x34>)
 800b95c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b95e:	4798      	blx	r3
 800b960:	4603      	mov	r3, r0
 800b962:	607b      	str	r3, [r7, #4]

    home.a.value = limits.min.value;
 800b964:	793b      	ldrb	r3, [r7, #4]
 800b966:	723b      	strb	r3, [r7, #8]
    home.b.value = limits.min2.value;
 800b968:	79bb      	ldrb	r3, [r7, #6]
 800b96a:	727b      	strb	r3, [r7, #9]

    return home;
 800b96c:	893b      	ldrh	r3, [r7, #8]
 800b96e:	81bb      	strh	r3, [r7, #12]
 800b970:	2300      	movs	r3, #0
 800b972:	7b3a      	ldrb	r2, [r7, #12]
 800b974:	f362 0307 	bfi	r3, r2, #0, #8
 800b978:	7b7a      	ldrb	r2, [r7, #13]
 800b97a:	f362 230f 	bfi	r3, r2, #8, #8
}
 800b97e:	4618      	mov	r0, r3
 800b980:	3710      	adds	r7, #16
 800b982:	46bd      	mov	sp, r7
 800b984:	bd80      	pop	{r7, pc}
 800b986:	bf00      	nop
 800b988:	20000ed0 	.word	0x20000ed0

0800b98c <get_homing_status2>:

// "Wire" homing signals to limit signals, used when max limit inputs available.
ISR_CODE static home_signals_t ISR_FUNC(get_homing_status2)(void)
{
 800b98c:	b580      	push	{r7, lr}
 800b98e:	b084      	sub	sp, #16
 800b990:	af00      	add	r7, sp, #0
    home_signals_t home;
    limit_signals_t source = xbar_get_homing_source(), limits = hal.limits.get_state();
 800b992:	f7f9 ff0d 	bl	80057b0 <xbar_get_homing_source>
 800b996:	4603      	mov	r3, r0
 800b998:	607b      	str	r3, [r7, #4]
 800b99a:	4b14      	ldr	r3, [pc, #80]	; (800b9ec <get_homing_status2+0x60>)
 800b99c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b99e:	4798      	blx	r3
 800b9a0:	4603      	mov	r3, r0
 800b9a2:	603b      	str	r3, [r7, #0]

    home.a.value = (limits.min.value & source.min.mask) | (limits.max.value & source.max.mask);
 800b9a4:	783a      	ldrb	r2, [r7, #0]
 800b9a6:	793b      	ldrb	r3, [r7, #4]
 800b9a8:	4013      	ands	r3, r2
 800b9aa:	b2da      	uxtb	r2, r3
 800b9ac:	7879      	ldrb	r1, [r7, #1]
 800b9ae:	797b      	ldrb	r3, [r7, #5]
 800b9b0:	400b      	ands	r3, r1
 800b9b2:	b2db      	uxtb	r3, r3
 800b9b4:	4313      	orrs	r3, r2
 800b9b6:	b2db      	uxtb	r3, r3
 800b9b8:	723b      	strb	r3, [r7, #8]
    home.b.value = (limits.min2.value & source.min2.mask) | (limits.max2.value & source.max2.mask);
 800b9ba:	78ba      	ldrb	r2, [r7, #2]
 800b9bc:	79bb      	ldrb	r3, [r7, #6]
 800b9be:	4013      	ands	r3, r2
 800b9c0:	b2da      	uxtb	r2, r3
 800b9c2:	78f9      	ldrb	r1, [r7, #3]
 800b9c4:	79fb      	ldrb	r3, [r7, #7]
 800b9c6:	400b      	ands	r3, r1
 800b9c8:	b2db      	uxtb	r3, r3
 800b9ca:	4313      	orrs	r3, r2
 800b9cc:	b2db      	uxtb	r3, r3
 800b9ce:	727b      	strb	r3, [r7, #9]

    return home;
 800b9d0:	893b      	ldrh	r3, [r7, #8]
 800b9d2:	81bb      	strh	r3, [r7, #12]
 800b9d4:	2300      	movs	r3, #0
 800b9d6:	7b3a      	ldrb	r2, [r7, #12]
 800b9d8:	f362 0307 	bfi	r3, r2, #0, #8
 800b9dc:	7b7a      	ldrb	r2, [r7, #13]
 800b9de:	f362 230f 	bfi	r3, r2, #8, #8
}
 800b9e2:	4618      	mov	r0, r3
 800b9e4:	3710      	adds	r7, #16
 800b9e6:	46bd      	mov	sp, r7
 800b9e8:	bd80      	pop	{r7, pc}
 800b9ea:	bf00      	nop
 800b9ec:	20000ed0 	.word	0x20000ed0

0800b9f0 <grbl_enter>:

// main entry point

int grbl_enter (void)
{
 800b9f0:	b580      	push	{r7, lr}
 800b9f2:	b084      	sub	sp, #16
 800b9f4:	af00      	add	r7, sp, #0
    assert(NVS_ADDR_PARAMETERS + N_CoordinateSystems * (sizeof(coord_data_t) + NVS_CRC_BYTES) < NVS_ADDR_STARTUP_BLOCK);
    assert(NVS_ADDR_STARTUP_BLOCK + N_STARTUP_LINE * (sizeof(stored_line_t) + NVS_CRC_BYTES) < NVS_ADDR_BUILD_INFO);

    bool looping = true;
 800b9f6:	2301      	movs	r3, #1
 800b9f8:	73fb      	strb	r3, [r7, #15]

    // Clear all and set some core function pointers
    memset(&grbl, 0, sizeof(grbl_t));
 800b9fa:	22fc      	movs	r2, #252	; 0xfc
 800b9fc:	2100      	movs	r1, #0
 800b9fe:	489d      	ldr	r0, [pc, #628]	; (800bc74 <grbl_enter+0x284>)
 800ba00:	f018 f909 	bl	8023c16 <memset>
    grbl.on_execute_realtime = grbl.on_execute_delay = protocol_execute_noop;
 800ba04:	4b9b      	ldr	r3, [pc, #620]	; (800bc74 <grbl_enter+0x284>)
 800ba06:	4a9c      	ldr	r2, [pc, #624]	; (800bc78 <grbl_enter+0x288>)
 800ba08:	64da      	str	r2, [r3, #76]	; 0x4c
 800ba0a:	4b9a      	ldr	r3, [pc, #616]	; (800bc74 <grbl_enter+0x284>)
 800ba0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800ba0e:	4a99      	ldr	r2, [pc, #612]	; (800bc74 <grbl_enter+0x284>)
 800ba10:	6493      	str	r3, [r2, #72]	; 0x48
    grbl.enqueue_gcode = protocol_enqueue_gcode;
 800ba12:	4b98      	ldr	r3, [pc, #608]	; (800bc74 <grbl_enter+0x284>)
 800ba14:	4a99      	ldr	r2, [pc, #612]	; (800bc7c <grbl_enter+0x28c>)
 800ba16:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    grbl.enqueue_realtime_command = stream_enqueue_realtime_command;
 800ba1a:	4b96      	ldr	r3, [pc, #600]	; (800bc74 <grbl_enter+0x284>)
 800ba1c:	4a98      	ldr	r2, [pc, #608]	; (800bc80 <grbl_enter+0x290>)
 800ba1e:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    grbl.on_report_options = dummy_bool_handler;
 800ba22:	4b94      	ldr	r3, [pc, #592]	; (800bc74 <grbl_enter+0x284>)
 800ba24:	4a97      	ldr	r2, [pc, #604]	; (800bc84 <grbl_enter+0x294>)
 800ba26:	655a      	str	r2, [r3, #84]	; 0x54
    grbl.on_report_command_help = system_command_help;
 800ba28:	4b92      	ldr	r3, [pc, #584]	; (800bc74 <grbl_enter+0x284>)
 800ba2a:	4a97      	ldr	r2, [pc, #604]	; (800bc88 <grbl_enter+0x298>)
 800ba2c:	659a      	str	r2, [r3, #88]	; 0x58
    grbl.on_get_alarms = alarms_get_details;
 800ba2e:	4b91      	ldr	r3, [pc, #580]	; (800bc74 <grbl_enter+0x284>)
 800ba30:	4a96      	ldr	r2, [pc, #600]	; (800bc8c <grbl_enter+0x29c>)
 800ba32:	669a      	str	r2, [r3, #104]	; 0x68
    grbl.on_get_errors = errors_get_details;
 800ba34:	4b8f      	ldr	r3, [pc, #572]	; (800bc74 <grbl_enter+0x284>)
 800ba36:	4a96      	ldr	r2, [pc, #600]	; (800bc90 <grbl_enter+0x2a0>)
 800ba38:	66da      	str	r2, [r3, #108]	; 0x6c
    grbl.on_get_settings = settings_get_details;
 800ba3a:	4b8e      	ldr	r3, [pc, #568]	; (800bc74 <grbl_enter+0x284>)
 800ba3c:	4a95      	ldr	r2, [pc, #596]	; (800bc94 <grbl_enter+0x2a4>)
 800ba3e:	671a      	str	r2, [r3, #112]	; 0x70

    // Clear all and set some HAL function pointers
    memset(&hal, 0, sizeof(grbl_hal_t));
 800ba40:	f44f 72da 	mov.w	r2, #436	; 0x1b4
 800ba44:	2100      	movs	r1, #0
 800ba46:	4894      	ldr	r0, [pc, #592]	; (800bc98 <grbl_enter+0x2a8>)
 800ba48:	f018 f8e5 	bl	8023c16 <memset>
    hal.version = HAL_VERSION; // Update when signatures and/or contract is changed - driver_init() should fail
 800ba4c:	4b92      	ldr	r3, [pc, #584]	; (800bc98 <grbl_enter+0x2a8>)
 800ba4e:	220a      	movs	r2, #10
 800ba50:	601a      	str	r2, [r3, #0]
    hal.driver_reset = reset_handler;
 800ba52:	4b91      	ldr	r3, [pc, #580]	; (800bc98 <grbl_enter+0x2a8>)
 800ba54:	4a91      	ldr	r2, [pc, #580]	; (800bc9c <grbl_enter+0x2ac>)
 800ba56:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    hal.irq_enable = dummy_handler;
 800ba5a:	4b8f      	ldr	r3, [pc, #572]	; (800bc98 <grbl_enter+0x2a8>)
 800ba5c:	4a90      	ldr	r2, [pc, #576]	; (800bca0 <grbl_enter+0x2b0>)
 800ba5e:	649a      	str	r2, [r3, #72]	; 0x48
    hal.irq_disable = dummy_handler;
 800ba60:	4b8d      	ldr	r3, [pc, #564]	; (800bc98 <grbl_enter+0x2a8>)
 800ba62:	4a8f      	ldr	r2, [pc, #572]	; (800bca0 <grbl_enter+0x2b0>)
 800ba64:	64da      	str	r2, [r3, #76]	; 0x4c
    hal.irq_claim = dummy_irq_claim;
 800ba66:	4b8c      	ldr	r3, [pc, #560]	; (800bc98 <grbl_enter+0x2a8>)
 800ba68:	4a8e      	ldr	r2, [pc, #568]	; (800bca4 <grbl_enter+0x2b4>)
 800ba6a:	651a      	str	r2, [r3, #80]	; 0x50
    hal.nvs.size = GRBL_NVS_SIZE;
 800ba6c:	4b8a      	ldr	r3, [pc, #552]	; (800bc98 <grbl_enter+0x2a8>)
 800ba6e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ba72:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    hal.limits.interrupt_callback = limit_interrupt_handler;
 800ba76:	4b88      	ldr	r3, [pc, #544]	; (800bc98 <grbl_enter+0x2a8>)
 800ba78:	4a8b      	ldr	r2, [pc, #556]	; (800bca8 <grbl_enter+0x2b8>)
 800ba7a:	65da      	str	r2, [r3, #92]	; 0x5c
    hal.control.interrupt_callback = control_interrupt_handler;
 800ba7c:	4b86      	ldr	r3, [pc, #536]	; (800bc98 <grbl_enter+0x2a8>)
 800ba7e:	4a8b      	ldr	r2, [pc, #556]	; (800bcac <grbl_enter+0x2bc>)
 800ba80:	66da      	str	r2, [r3, #108]	; 0x6c
    hal.stepper.interrupt_callback = stepper_driver_interrupt_handler;
 800ba82:	4b85      	ldr	r3, [pc, #532]	; (800bc98 <grbl_enter+0x2a8>)
 800ba84:	4a8a      	ldr	r2, [pc, #552]	; (800bcb0 <grbl_enter+0x2c0>)
 800ba86:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    hal.stream_blocking_callback = stream_tx_blocking;
 800ba8a:	4b83      	ldr	r3, [pc, #524]	; (800bc98 <grbl_enter+0x2a8>)
 800ba8c:	4a89      	ldr	r2, [pc, #548]	; (800bcb4 <grbl_enter+0x2c4>)
 800ba8e:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    hal.signals_cap.reset = hal.signals_cap.feed_hold = hal.signals_cap.cycle_start = On;
 800ba92:	4a81      	ldr	r2, [pc, #516]	; (800bc98 <grbl_enter+0x2a8>)
 800ba94:	f892 31ac 	ldrb.w	r3, [r2, #428]	; 0x1ac
 800ba98:	f043 0304 	orr.w	r3, r3, #4
 800ba9c:	f882 31ac 	strb.w	r3, [r2, #428]	; 0x1ac
 800baa0:	4b7d      	ldr	r3, [pc, #500]	; (800bc98 <grbl_enter+0x2a8>)
 800baa2:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 800baa6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800baaa:	b2d9      	uxtb	r1, r3
 800baac:	4a7a      	ldr	r2, [pc, #488]	; (800bc98 <grbl_enter+0x2a8>)
 800baae:	f892 31ac 	ldrb.w	r3, [r2, #428]	; 0x1ac
 800bab2:	f361 0341 	bfi	r3, r1, #1, #1
 800bab6:	f882 31ac 	strb.w	r3, [r2, #428]	; 0x1ac
 800baba:	4b77      	ldr	r3, [pc, #476]	; (800bc98 <grbl_enter+0x2a8>)
 800babc:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 800bac0:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800bac4:	b2d9      	uxtb	r1, r3
 800bac6:	4a74      	ldr	r2, [pc, #464]	; (800bc98 <grbl_enter+0x2a8>)
 800bac8:	f892 31ac 	ldrb.w	r3, [r2, #428]	; 0x1ac
 800bacc:	f361 0300 	bfi	r3, r1, #0, #1
 800bad0:	f882 31ac 	strb.w	r3, [r2, #428]	; 0x1ac

    sys.cold_start = true;
 800bad4:	4b78      	ldr	r3, [pc, #480]	; (800bcb8 <grbl_enter+0x2c8>)
 800bad6:	2201      	movs	r2, #1
 800bad8:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

    limits_init();
 800badc:	f001 ff3e 	bl	800d95c <limits_init>

#if NVSDATA_BUFFER_ENABLE
    nvs_buffer_alloc(); // Allocate memory block for NVS buffer
 800bae0:	f005 f9a0 	bl	8010e24 <nvs_buffer_alloc>
#endif

    settings_clear();
 800bae4:	f010 f958 	bl	801bd98 <settings_clear>
    report_init_fns();
 800bae8:	f00d f852 	bl	8018b90 <report_init_fns>

#ifdef KINEMATICS_API
    memset(&kinematics, 0, sizeof(kinematics_t));
 800baec:	2220      	movs	r2, #32
 800baee:	2100      	movs	r1, #0
 800baf0:	4872      	ldr	r0, [pc, #456]	; (800bcbc <grbl_enter+0x2cc>)
 800baf2:	f018 f890 	bl	8023c16 <memset>
#endif

    driver.init = driver_init();
 800baf6:	f7f8 fbcd 	bl	8004294 <driver_init>
 800bafa:	4603      	mov	r3, r0
 800bafc:	4619      	mov	r1, r3
 800bafe:	4a70      	ldr	r2, [pc, #448]	; (800bcc0 <grbl_enter+0x2d0>)
 800bb00:	7813      	ldrb	r3, [r2, #0]
 800bb02:	f361 0300 	bfi	r3, r1, #0, #1
 800bb06:	7013      	strb	r3, [r2, #0]
#ifdef NO_SAFETY_DOOR_SUPPORT
    hal.signals_cap.safety_door_ajar = Off;
#endif

#if COREXY
    corexy_init();
 800bb08:	f017 fc44 	bl	8023394 <corexy_init>
#if POLAR_ROBOT
    polar_init();
#endif

  #if NVSDATA_BUFFER_ENABLE
    nvs_buffer_init();
 800bb0c:	f005 f9be 	bl	8010e8c <nvs_buffer_init>
  #endif
    settings_init(); // Load settings from non-volatile storage
 800bb10:	f010 f952 	bl	801bdb8 <settings_init>

    memset(sys.position, 0, sizeof(sys.position)); // Clear machine position.
 800bb14:	220c      	movs	r2, #12
 800bb16:	2100      	movs	r1, #0
 800bb18:	486a      	ldr	r0, [pc, #424]	; (800bcc4 <grbl_enter+0x2d4>)
 800bb1a:	f018 f87c 	bl	8023c16 <memset>

// check and configure driver

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    driver.amass = hal.driver_cap.amass_level >= MAX_AMASS_LEVEL;
 800bb1e:	4b5e      	ldr	r3, [pc, #376]	; (800bc98 <grbl_enter+0x2a8>)
 800bb20:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800bb24:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800bb28:	b2db      	uxtb	r3, r3
 800bb2a:	2bc0      	cmp	r3, #192	; 0xc0
 800bb2c:	bf0c      	ite	eq
 800bb2e:	2301      	moveq	r3, #1
 800bb30:	2300      	movne	r3, #0
 800bb32:	b2d9      	uxtb	r1, r3
 800bb34:	4a62      	ldr	r2, [pc, #392]	; (800bcc0 <grbl_enter+0x2d0>)
 800bb36:	7813      	ldrb	r3, [r2, #0]
 800bb38:	f361 03c3 	bfi	r3, r1, #3, #1
 800bb3c:	7013      	strb	r3, [r2, #0]
    hal.driver_cap.amass_level = MAX_AMASS_LEVEL;
 800bb3e:	4a56      	ldr	r2, [pc, #344]	; (800bc98 <grbl_enter+0x2a8>)
 800bb40:	f892 31a8 	ldrb.w	r3, [r2, #424]	; 0x1a8
 800bb44:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800bb48:	f882 31a8 	strb.w	r3, [r2, #424]	; 0x1a8
#else
    hal.driver_cap.amass_level = 0;
#endif

#ifdef DEFAULT_STEP_PULSE_DELAY
    driver.pulse_delay = hal.driver_cap.step_pulse_delay;
 800bb4c:	4b52      	ldr	r3, [pc, #328]	; (800bc98 <grbl_enter+0x2a8>)
 800bb4e:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 800bb52:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800bb56:	b2d9      	uxtb	r1, r3
 800bb58:	4a59      	ldr	r2, [pc, #356]	; (800bcc0 <grbl_enter+0x2d0>)
 800bb5a:	7813      	ldrb	r3, [r2, #0]
 800bb5c:	f361 1304 	bfi	r3, r1, #4, #1
 800bb60:	7013      	strb	r3, [r2, #0]
/*
#if AXIS_N_SETTINGS > 4
    driver_ok = driver_ok & hal.driver_cap.axes >= AXIS_N_SETTINGS;
#endif
*/
    sys.mpg_mode = false;
 800bb62:	4b55      	ldr	r3, [pc, #340]	; (800bcb8 <grbl_enter+0x2c8>)
 800bb64:	2200      	movs	r2, #0
 800bb66:	f883 207f 	strb.w	r2, [r3, #127]	; 0x7f

    if(driver.ok == 0xFF)
 800bb6a:	4b55      	ldr	r3, [pc, #340]	; (800bcc0 <grbl_enter+0x2d0>)
 800bb6c:	781b      	ldrb	r3, [r3, #0]
 800bb6e:	2bff      	cmp	r3, #255	; 0xff
 800bb70:	d10a      	bne.n	800bb88 <grbl_enter+0x198>
        driver.setup = hal.driver_setup(&settings);
 800bb72:	4b49      	ldr	r3, [pc, #292]	; (800bc98 <grbl_enter+0x2a8>)
 800bb74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bb76:	4854      	ldr	r0, [pc, #336]	; (800bcc8 <grbl_enter+0x2d8>)
 800bb78:	4798      	blx	r3
 800bb7a:	4603      	mov	r3, r0
 800bb7c:	4619      	mov	r1, r3
 800bb7e:	4a50      	ldr	r2, [pc, #320]	; (800bcc0 <grbl_enter+0x2d0>)
 800bb80:	7813      	ldrb	r3, [r2, #0]
 800bb82:	f361 0341 	bfi	r3, r1, #1, #1
 800bb86:	7013      	strb	r3, [r2, #0]

    if((driver.spindle = spindle_select(settings.spindle.flags.type))) {
 800bb88:	4b4f      	ldr	r3, [pc, #316]	; (800bcc8 <grbl_enter+0x2d8>)
 800bb8a:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 800bb8e:	f3c3 0384 	ubfx	r3, r3, #2, #5
 800bb92:	b2db      	uxtb	r3, r3
 800bb94:	b25b      	sxtb	r3, r3
 800bb96:	4618      	mov	r0, r3
 800bb98:	f010 fd46 	bl	801c628 <spindle_select>
 800bb9c:	4603      	mov	r3, r0
 800bb9e:	4619      	mov	r1, r3
 800bba0:	4a47      	ldr	r2, [pc, #284]	; (800bcc0 <grbl_enter+0x2d0>)
 800bba2:	7813      	ldrb	r3, [r2, #0]
 800bba4:	f361 0382 	bfi	r3, r1, #2, #1
 800bba8:	7013      	strb	r3, [r2, #0]
 800bbaa:	4b45      	ldr	r3, [pc, #276]	; (800bcc0 <grbl_enter+0x2d0>)
 800bbac:	781b      	ldrb	r3, [r3, #0]
 800bbae:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800bbb2:	b2db      	uxtb	r3, r3
 800bbb4:	2b00      	cmp	r3, #0
 800bbb6:	d017      	beq.n	800bbe8 <grbl_enter+0x1f8>
        spindle_ptrs_t *spindle = spindle_get(0);
 800bbb8:	2000      	movs	r0, #0
 800bbba:	f010 ff9f 	bl	801cafc <spindle_get>
 800bbbe:	60b8      	str	r0, [r7, #8]
        driver.spindle = spindle->get_pwm == NULL || spindle->update_pwm != NULL;
 800bbc0:	68bb      	ldr	r3, [r7, #8]
 800bbc2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bbc4:	2b00      	cmp	r3, #0
 800bbc6:	d003      	beq.n	800bbd0 <grbl_enter+0x1e0>
 800bbc8:	68bb      	ldr	r3, [r7, #8]
 800bbca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bbcc:	2b00      	cmp	r3, #0
 800bbce:	d001      	beq.n	800bbd4 <grbl_enter+0x1e4>
 800bbd0:	2301      	movs	r3, #1
 800bbd2:	e000      	b.n	800bbd6 <grbl_enter+0x1e6>
 800bbd4:	2300      	movs	r3, #0
 800bbd6:	f003 0301 	and.w	r3, r3, #1
 800bbda:	b2d9      	uxtb	r1, r3
 800bbdc:	4a38      	ldr	r2, [pc, #224]	; (800bcc0 <grbl_enter+0x2d0>)
 800bbde:	7813      	ldrb	r3, [r2, #0]
 800bbe0:	f361 0382 	bfi	r3, r1, #2, #1
 800bbe4:	7013      	strb	r3, [r2, #0]
 800bbe6:	e00c      	b.n	800bc02 <grbl_enter+0x212>
    } else
        driver.spindle = spindle_select(spindle_add_null());
 800bbe8:	f010 ffe8 	bl	801cbbc <spindle_add_null>
 800bbec:	4603      	mov	r3, r0
 800bbee:	4618      	mov	r0, r3
 800bbf0:	f010 fd1a 	bl	801c628 <spindle_select>
 800bbf4:	4603      	mov	r3, r0
 800bbf6:	4619      	mov	r1, r3
 800bbf8:	4a31      	ldr	r2, [pc, #196]	; (800bcc0 <grbl_enter+0x2d0>)
 800bbfa:	7813      	ldrb	r3, [r2, #0]
 800bbfc:	f361 0382 	bfi	r3, r1, #2, #1
 800bc00:	7013      	strb	r3, [r2, #0]

    if(driver.ok != 0xFF) {
 800bc02:	4b2f      	ldr	r3, [pc, #188]	; (800bcc0 <grbl_enter+0x2d0>)
 800bc04:	781b      	ldrb	r3, [r3, #0]
 800bc06:	2bff      	cmp	r3, #255	; 0xff
 800bc08:	d006      	beq.n	800bc18 <grbl_enter+0x228>
        sys.alarm = Alarm_SelftestFailed;
 800bc0a:	4b2b      	ldr	r3, [pc, #172]	; (800bcb8 <grbl_enter+0x2c8>)
 800bc0c:	2210      	movs	r2, #16
 800bc0e:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        protocol_enqueue_rt_command(report_driver_error);
 800bc12:	482e      	ldr	r0, [pc, #184]	; (800bccc <grbl_enter+0x2dc>)
 800bc14:	f008 f8ea 	bl	8013dec <protocol_enqueue_rt_command>
    }

    hal.stepper.enable(settings.steppers.deenergize);
 800bc18:	4b1f      	ldr	r3, [pc, #124]	; (800bc98 <grbl_enter+0x2a8>)
 800bc1a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800bc1e:	4a2a      	ldr	r2, [pc, #168]	; (800bcc8 <grbl_enter+0x2d8>)
 800bc20:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 800bc24:	4798      	blx	r3

    spindle_all_off();
 800bc26:	f011 fa53 	bl	801d0d0 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 800bc2a:	4b1b      	ldr	r3, [pc, #108]	; (800bc98 <grbl_enter+0x2a8>)
 800bc2c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bc2e:	2200      	movs	r2, #0
 800bc30:	4610      	mov	r0, r2
 800bc32:	4798      	blx	r3

    if(hal.get_position)
 800bc34:	4b18      	ldr	r3, [pc, #96]	; (800bc98 <grbl_enter+0x2a8>)
 800bc36:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800bc3a:	2b00      	cmp	r3, #0
 800bc3c:	d004      	beq.n	800bc48 <grbl_enter+0x258>
        hal.get_position(&sys.position); // TODO: restore on abort when returns true?
 800bc3e:	4b16      	ldr	r3, [pc, #88]	; (800bc98 <grbl_enter+0x2a8>)
 800bc40:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800bc44:	481f      	ldr	r0, [pc, #124]	; (800bcc4 <grbl_enter+0x2d4>)
 800bc46:	4798      	blx	r3

#if ENABLE_BACKLASH_COMPENSATION
    mc_backlash_init((axes_signals_t){AXES_BITMASK});
#endif

    sys.driver_started = sys.alarm != Alarm_SelftestFailed;
 800bc48:	4b1b      	ldr	r3, [pc, #108]	; (800bcb8 <grbl_enter+0x2c8>)
 800bc4a:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 800bc4e:	2b10      	cmp	r3, #16
 800bc50:	bf14      	ite	ne
 800bc52:	2301      	movne	r3, #1
 800bc54:	2300      	moveq	r3, #0
 800bc56:	b2da      	uxtb	r2, r3
 800bc58:	4b17      	ldr	r3, [pc, #92]	; (800bcb8 <grbl_enter+0x2c8>)
 800bc5a:	f883 207e 	strb.w	r2, [r3, #126]	; 0x7e

    // "Wire" homing switches to limit switches if not provided by the driver.
    if(hal.homing.get_state == NULL)
 800bc5e:	4b0e      	ldr	r3, [pc, #56]	; (800bc98 <grbl_enter+0x2a8>)
 800bc60:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800bc62:	2b00      	cmp	r3, #0
 800bc64:	d139      	bne.n	800bcda <grbl_enter+0x2ea>
        hal.homing.get_state = hal.limits_cap.max.mask ? get_homing_status2 : get_homing_status;
 800bc66:	4b0c      	ldr	r3, [pc, #48]	; (800bc98 <grbl_enter+0x2a8>)
 800bc68:	f893 31af 	ldrb.w	r3, [r3, #431]	; 0x1af
 800bc6c:	2b00      	cmp	r3, #0
 800bc6e:	d031      	beq.n	800bcd4 <grbl_enter+0x2e4>
 800bc70:	4b17      	ldr	r3, [pc, #92]	; (800bcd0 <grbl_enter+0x2e0>)
 800bc72:	e030      	b.n	800bcd6 <grbl_enter+0x2e6>
 800bc74:	20000dd4 	.word	0x20000dd4
 800bc78:	08013ec1 	.word	0x08013ec1
 800bc7c:	08012421 	.word	0x08012421
 800bc80:	080202cd 	.word	0x080202cd
 800bc84:	0800b825 	.word	0x0800b825
 800bc88:	08021805 	.word	0x08021805
 800bc8c:	08005649 	.word	0x08005649
 800bc90:	08005869 	.word	0x08005869
 800bc94:	08018d1d 	.word	0x08018d1d
 800bc98:	20000ed0 	.word	0x20000ed0
 800bc9c:	0800b839 	.word	0x0800b839
 800bca0:	08010b01 	.word	0x08010b01
 800bca4:	0800b851 	.word	0x0800b851
 800bca8:	0800bfd9 	.word	0x0800bfd9
 800bcac:	08020a11 	.word	0x08020a11
 800bcb0:	0801eb55 	.word	0x0801eb55
 800bcb4:	08020131 	.word	0x08020131
 800bcb8:	20000d3c 	.word	0x20000d3c
 800bcbc:	20001088 	.word	0x20001088
 800bcc0:	20000260 	.word	0x20000260
 800bcc4:	20000dc4 	.word	0x20000dc4
 800bcc8:	2000147c 	.word	0x2000147c
 800bccc:	0800b86d 	.word	0x0800b86d
 800bcd0:	0800b98d 	.word	0x0800b98d
 800bcd4:	4b95      	ldr	r3, [pc, #596]	; (800bf2c <grbl_enter+0x53c>)
 800bcd6:	4a96      	ldr	r2, [pc, #600]	; (800bf30 <grbl_enter+0x540>)
 800bcd8:	6613      	str	r3, [r2, #96]	; 0x60

    if(settings.report_interval) {
 800bcda:	4b96      	ldr	r3, [pc, #600]	; (800bf34 <grbl_enter+0x544>)
 800bcdc:	8a9b      	ldrh	r3, [r3, #20]
 800bcde:	2b00      	cmp	r3, #0
 800bce0:	d006      	beq.n	800bcf0 <grbl_enter+0x300>
        on_execute_realtime = grbl.on_execute_realtime;
 800bce2:	4b95      	ldr	r3, [pc, #596]	; (800bf38 <grbl_enter+0x548>)
 800bce4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800bce6:	4a95      	ldr	r2, [pc, #596]	; (800bf3c <grbl_enter+0x54c>)
 800bce8:	6013      	str	r3, [r2, #0]
        grbl.on_execute_realtime = auto_realtime_report;
 800bcea:	4b93      	ldr	r3, [pc, #588]	; (800bf38 <grbl_enter+0x548>)
 800bcec:	4a94      	ldr	r2, [pc, #592]	; (800bf40 <grbl_enter+0x550>)
 800bcee:	649a      	str	r2, [r3, #72]	; 0x48
    }

    if(hal.driver_cap.sd_card || hal.driver_cap.littlefs) {
 800bcf0:	4b8f      	ldr	r3, [pc, #572]	; (800bf30 <grbl_enter+0x540>)
 800bcf2:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 800bcf6:	f003 0304 	and.w	r3, r3, #4
 800bcfa:	b2db      	uxtb	r3, r3
 800bcfc:	2b00      	cmp	r3, #0
 800bcfe:	d108      	bne.n	800bd12 <grbl_enter+0x322>
 800bd00:	4b8b      	ldr	r3, [pc, #556]	; (800bf30 <grbl_enter+0x540>)
 800bd02:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 800bd06:	f003 0308 	and.w	r3, r3, #8
 800bd0a:	b2db      	uxtb	r3, r3
 800bd0c:	2b00      	cmp	r3, #0
 800bd0e:	f000 8102 	beq.w	800bf16 <grbl_enter+0x526>
        fs_options_t fs_options = {0};
 800bd12:	2300      	movs	r3, #0
 800bd14:	713b      	strb	r3, [r7, #4]
        fs_options.lfs_hidden = hal.driver_cap.littlefs;
 800bd16:	4b86      	ldr	r3, [pc, #536]	; (800bf30 <grbl_enter+0x540>)
 800bd18:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 800bd1c:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800bd20:	b2da      	uxtb	r2, r3
 800bd22:	793b      	ldrb	r3, [r7, #4]
 800bd24:	f362 0341 	bfi	r3, r2, #1, #1
 800bd28:	713b      	strb	r3, [r7, #4]
        fs_options.sd_mount_on_boot = hal.driver_cap.sd_card;
 800bd2a:	4b81      	ldr	r3, [pc, #516]	; (800bf30 <grbl_enter+0x540>)
 800bd2c:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 800bd30:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800bd34:	b2da      	uxtb	r2, r3
 800bd36:	793b      	ldrb	r3, [r7, #4]
 800bd38:	f362 0300 	bfi	r3, r2, #0, #1
 800bd3c:	713b      	strb	r3, [r7, #4]
        setting_remove_elements(Setting_FSOptions, fs_options.mask);
 800bd3e:	793b      	ldrb	r3, [r7, #4]
 800bd40:	4619      	mov	r1, r3
 800bd42:	f240 208a 	movw	r0, #650	; 0x28a
 800bd46:	f00f fd17 	bl	801b778 <setting_remove_elements>
    }

    // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
    // will return to this loop to be cleanly re-initialized.
    while(looping) {
 800bd4a:	e0e4      	b.n	800bf16 <grbl_enter+0x526>

        spindle_num_t spindle_num = N_SYS_SPINDLE;
 800bd4c:	2301      	movs	r3, #1
 800bd4e:	73bb      	strb	r3, [r7, #14]

        // Reset report entry points
        report_init_fns();
 800bd50:	f00c ff1e 	bl	8018b90 <report_init_fns>

        if(!sys.position_lost || settings.homing.flags.keep_on_reset)
 800bd54:	4b7b      	ldr	r3, [pc, #492]	; (800bf44 <grbl_enter+0x554>)
 800bd56:	78db      	ldrb	r3, [r3, #3]
 800bd58:	f083 0301 	eor.w	r3, r3, #1
 800bd5c:	b2db      	uxtb	r3, r3
 800bd5e:	2b00      	cmp	r3, #0
 800bd60:	d107      	bne.n	800bd72 <grbl_enter+0x382>
 800bd62:	4b74      	ldr	r3, [pc, #464]	; (800bf34 <grbl_enter+0x544>)
 800bd64:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800bd68:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800bd6c:	b2db      	uxtb	r3, r3
 800bd6e:	2b00      	cmp	r3, #0
 800bd70:	d005      	beq.n	800bd7e <grbl_enter+0x38e>
            memset(&sys, 0, offsetof(system_t, homed)); // Clear system variables except alarm & homed status.
 800bd72:	2254      	movs	r2, #84	; 0x54
 800bd74:	2100      	movs	r1, #0
 800bd76:	4873      	ldr	r0, [pc, #460]	; (800bf44 <grbl_enter+0x554>)
 800bd78:	f017 ff4d 	bl	8023c16 <memset>
 800bd7c:	e004      	b.n	800bd88 <grbl_enter+0x398>
        else
            memset(&sys, 0, offsetof(system_t, alarm)); // Clear system variables except state & alarm.
 800bd7e:	227c      	movs	r2, #124	; 0x7c
 800bd80:	2100      	movs	r1, #0
 800bd82:	4870      	ldr	r0, [pc, #448]	; (800bf44 <grbl_enter+0x554>)
 800bd84:	f017 ff47 	bl	8023c16 <memset>

        sys.var5399 = -2;                                        // Clear last M66 result
 800bd88:	4b6e      	ldr	r3, [pc, #440]	; (800bf44 <grbl_enter+0x554>)
 800bd8a:	f06f 0201 	mvn.w	r2, #1
 800bd8e:	651a      	str	r2, [r3, #80]	; 0x50
        sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;          // Set to 100%
 800bd90:	4b6c      	ldr	r3, [pc, #432]	; (800bf44 <grbl_enter+0x554>)
 800bd92:	2264      	movs	r2, #100	; 0x64
 800bd94:	61da      	str	r2, [r3, #28]
        sys.override.rapid_rate = DEFAULT_RAPID_OVERRIDE;        // Set to 100%
 800bd96:	4b6b      	ldr	r3, [pc, #428]	; (800bf44 <grbl_enter+0x554>)
 800bd98:	2264      	movs	r2, #100	; 0x64
 800bd9a:	621a      	str	r2, [r3, #32]
        do {
            if(spindle_is_enabled(--spindle_num))
 800bd9c:	7bbb      	ldrb	r3, [r7, #14]
 800bd9e:	3b01      	subs	r3, #1
 800bda0:	b2db      	uxtb	r3, r3
 800bda2:	73bb      	strb	r3, [r7, #14]
 800bda4:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800bda8:	4618      	mov	r0, r3
 800bdaa:	f010 fe79 	bl	801caa0 <spindle_is_enabled>
 800bdae:	4603      	mov	r3, r0
 800bdb0:	2b00      	cmp	r3, #0
 800bdb2:	d008      	beq.n	800bdc6 <grbl_enter+0x3d6>
                spindle_get(spindle_num)->param->override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE; // Set to 100%
 800bdb4:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800bdb8:	4618      	mov	r0, r3
 800bdba:	f010 fe9f 	bl	801cafc <spindle_get>
 800bdbe:	4603      	mov	r3, r0
 800bdc0:	685b      	ldr	r3, [r3, #4]
 800bdc2:	2264      	movs	r2, #100	; 0x64
 800bdc4:	60da      	str	r2, [r3, #12]
        } while(spindle_num);
 800bdc6:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800bdca:	2b00      	cmp	r3, #0
 800bdcc:	d1e6      	bne.n	800bd9c <grbl_enter+0x3ac>
        sys.flags.auto_reporting = settings.report_interval != 0;
 800bdce:	4b59      	ldr	r3, [pc, #356]	; (800bf34 <grbl_enter+0x544>)
 800bdd0:	8a9b      	ldrh	r3, [r3, #20]
 800bdd2:	2b00      	cmp	r3, #0
 800bdd4:	bf14      	ite	ne
 800bdd6:	2301      	movne	r3, #1
 800bdd8:	2300      	moveq	r3, #0
 800bdda:	b2d9      	uxtb	r1, r3
 800bddc:	4a59      	ldr	r2, [pc, #356]	; (800bf44 <grbl_enter+0x554>)
 800bdde:	7dd3      	ldrb	r3, [r2, #23]
 800bde0:	f361 0341 	bfi	r3, r1, #1, #1
 800bde4:	75d3      	strb	r3, [r2, #23]

        if(settings.parking.flags.enabled)
 800bde6:	4b53      	ldr	r3, [pc, #332]	; (800bf34 <grbl_enter+0x544>)
 800bde8:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800bdec:	f003 0301 	and.w	r3, r3, #1
 800bdf0:	b2db      	uxtb	r3, r3
 800bdf2:	2b00      	cmp	r3, #0
 800bdf4:	d00c      	beq.n	800be10 <grbl_enter+0x420>
            sys.override.control.parking_disable = settings.parking.flags.deactivate_upon_init;
 800bdf6:	4b4f      	ldr	r3, [pc, #316]	; (800bf34 <grbl_enter+0x544>)
 800bdf8:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 800bdfc:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800be00:	b2d9      	uxtb	r1, r3
 800be02:	4a50      	ldr	r2, [pc, #320]	; (800bf44 <grbl_enter+0x554>)
 800be04:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 800be08:	f361 03c3 	bfi	r3, r1, #3, #1
 800be0c:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29

        flush_override_buffers();
 800be10:	f005 fb0c 	bl	801142c <flush_override_buffers>

        // Reset Grbl primary systems.
        hal.stream.reset_read_buffer(); // Clear input stream buffer
 800be14:	4b46      	ldr	r3, [pc, #280]	; (800bf30 <grbl_enter+0x540>)
 800be16:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 800be1a:	4798      	blx	r3
        gc_init();                      // Set g-code parser to default state
 800be1c:	f7f9 fef2 	bl	8005c04 <gc_init>
        hal.limits.enable(settings.limits.flags.hard_enabled, (axes_signals_t){0});
 800be20:	4b43      	ldr	r3, [pc, #268]	; (800bf30 <grbl_enter+0x540>)
 800be22:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800be24:	4a43      	ldr	r2, [pc, #268]	; (800bf34 <grbl_enter+0x544>)
 800be26:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 800be2a:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800be2e:	b2d2      	uxtb	r2, r2
 800be30:	2a00      	cmp	r2, #0
 800be32:	bf14      	ite	ne
 800be34:	2201      	movne	r2, #1
 800be36:	2200      	moveq	r2, #0
 800be38:	b2d2      	uxtb	r2, r2
 800be3a:	2100      	movs	r1, #0
 800be3c:	4610      	mov	r0, r2
 800be3e:	4798      	blx	r3
        plan_reset();                   // Clear block buffer and planner variables
 800be40:	f005 fc6e 	bl	8011720 <plan_reset>
        st_reset();                     // Clear stepper subsystem variables.
 800be44:	f013 f8b0 	bl	801efa8 <st_reset>
        limits_set_homing_axes();       // Set axes to be homed from settings.
 800be48:	f000 ff40 	bl	800cccc <limits_set_homing_axes>

        // Sync cleared gcode and planner positions to current system position.
        sync_position();
 800be4c:	f006 f9ca 	bl	80121e4 <plan_sync_position>
 800be50:	493d      	ldr	r1, [pc, #244]	; (800bf48 <grbl_enter+0x558>)
 800be52:	483e      	ldr	r0, [pc, #248]	; (800bf4c <grbl_enter+0x55c>)
 800be54:	f015 ffdc 	bl	8021e10 <system_convert_array_steps_to_mpos>

        if(hal.stepper.disable_motors)
 800be58:	4b35      	ldr	r3, [pc, #212]	; (800bf30 <grbl_enter+0x540>)
 800be5a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800be5e:	2b00      	cmp	r3, #0
 800be60:	d006      	beq.n	800be70 <grbl_enter+0x480>
            hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 800be62:	4b33      	ldr	r3, [pc, #204]	; (800bf30 <grbl_enter+0x540>)
 800be64:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800be68:	2200      	movs	r2, #0
 800be6a:	2100      	movs	r1, #0
 800be6c:	4610      	mov	r0, r2
 800be6e:	4798      	blx	r3

        if(!hal.driver_cap.atc)
 800be70:	4b2f      	ldr	r3, [pc, #188]	; (800bf30 <grbl_enter+0x540>)
 800be72:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 800be76:	f003 0304 	and.w	r3, r3, #4
 800be7a:	b2db      	uxtb	r3, r3
 800be7c:	2b00      	cmp	r3, #0
 800be7e:	d101      	bne.n	800be84 <grbl_enter+0x494>
            tc_init();
 800be80:	f016 fdee 	bl	8022a60 <tc_init>

        // Print welcome message. Indicates an initialization has occurred at power-up or with a reset.
        grbl.report.init_message();
 800be84:	4b2c      	ldr	r3, [pc, #176]	; (800bf38 <grbl_enter+0x548>)
 800be86:	681b      	ldr	r3, [r3, #0]
 800be88:	4798      	blx	r3

        if(!settings.flags.no_unlock_after_estop && state_get() == STATE_ESTOP)
 800be8a:	4b2a      	ldr	r3, [pc, #168]	; (800bf34 <grbl_enter+0x544>)
 800be8c:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800be90:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800be94:	b2db      	uxtb	r3, r3
 800be96:	2b00      	cmp	r3, #0
 800be98:	d108      	bne.n	800beac <grbl_enter+0x4bc>
 800be9a:	f011 fd11 	bl	801d8c0 <state_get>
 800be9e:	4603      	mov	r3, r0
 800bea0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800bea4:	d102      	bne.n	800beac <grbl_enter+0x4bc>
            state_set(STATE_ALARM);
 800bea6:	2001      	movs	r0, #1
 800bea8:	f011 fd14 	bl	801d8d4 <state_set>

        if(hal.driver_cap.mpg_mode)
 800beac:	4b20      	ldr	r3, [pc, #128]	; (800bf30 <grbl_enter+0x540>)
 800beae:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 800beb2:	f003 0301 	and.w	r3, r3, #1
 800beb6:	b2db      	uxtb	r3, r3
 800beb8:	2b00      	cmp	r3, #0
 800beba:	d00a      	beq.n	800bed2 <grbl_enter+0x4e2>
            protocol_enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 800bebc:	4b21      	ldr	r3, [pc, #132]	; (800bf44 <grbl_enter+0x554>)
 800bebe:	f893 307f 	ldrb.w	r3, [r3, #127]	; 0x7f
 800bec2:	2b00      	cmp	r3, #0
 800bec4:	d001      	beq.n	800beca <grbl_enter+0x4da>
 800bec6:	2387      	movs	r3, #135	; 0x87
 800bec8:	e000      	b.n	800becc <grbl_enter+0x4dc>
 800beca:	2380      	movs	r3, #128	; 0x80
 800becc:	4618      	mov	r0, r3
 800bece:	f007 fc23 	bl	8013718 <protocol_enqueue_realtime_command>

        // Start Grbl main loop. Processes program inputs and executes them.
        if(!(looping = protocol_main_loop()))
 800bed2:	f006 fbaf 	bl	8012634 <protocol_main_loop>
 800bed6:	4603      	mov	r3, r0
 800bed8:	73fb      	strb	r3, [r7, #15]
 800beda:	7bfb      	ldrb	r3, [r7, #15]
 800bedc:	f083 0301 	eor.w	r3, r3, #1
 800bee0:	b2db      	uxtb	r3, r3
 800bee2:	2b00      	cmp	r3, #0
 800bee4:	d013      	beq.n	800bf0e <grbl_enter+0x51e>
            looping = hal.driver_release == NULL || hal.driver_release();
 800bee6:	4b12      	ldr	r3, [pc, #72]	; (800bf30 <grbl_enter+0x540>)
 800bee8:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800beec:	2b00      	cmp	r3, #0
 800beee:	d006      	beq.n	800befe <grbl_enter+0x50e>
 800bef0:	4b0f      	ldr	r3, [pc, #60]	; (800bf30 <grbl_enter+0x540>)
 800bef2:	f8d3 3174 	ldr.w	r3, [r3, #372]	; 0x174
 800bef6:	4798      	blx	r3
 800bef8:	4603      	mov	r3, r0
 800befa:	2b00      	cmp	r3, #0
 800befc:	d001      	beq.n	800bf02 <grbl_enter+0x512>
 800befe:	2301      	movs	r3, #1
 800bf00:	e000      	b.n	800bf04 <grbl_enter+0x514>
 800bf02:	2300      	movs	r3, #0
 800bf04:	73fb      	strb	r3, [r7, #15]
 800bf06:	7bfb      	ldrb	r3, [r7, #15]
 800bf08:	f003 0301 	and.w	r3, r3, #1
 800bf0c:	73fb      	strb	r3, [r7, #15]

        sys.cold_start = false;
 800bf0e:	4b0d      	ldr	r3, [pc, #52]	; (800bf44 <grbl_enter+0x554>)
 800bf10:	2200      	movs	r2, #0
 800bf12:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
    while(looping) {
 800bf16:	7bfb      	ldrb	r3, [r7, #15]
 800bf18:	2b00      	cmp	r3, #0
 800bf1a:	f47f af17 	bne.w	800bd4c <grbl_enter+0x35c>
    }

    nvs_buffer_free();
 800bf1e:	f004 ffa3 	bl	8010e68 <nvs_buffer_free>

    return 0;
 800bf22:	2300      	movs	r3, #0
}
 800bf24:	4618      	mov	r0, r3
 800bf26:	3710      	adds	r7, #16
 800bf28:	46bd      	mov	sp, r7
 800bf2a:	bd80      	pop	{r7, pc}
 800bf2c:	0800b955 	.word	0x0800b955
 800bf30:	20000ed0 	.word	0x20000ed0
 800bf34:	2000147c 	.word	0x2000147c
 800bf38:	20000dd4 	.word	0x20000dd4
 800bf3c:	20001084 	.word	0x20001084
 800bf40:	0800b8ed 	.word	0x0800b8ed
 800bf44:	20000d3c 	.word	0x20000d3c
 800bf48:	20000dc4 	.word	0x20000dc4
 800bf4c:	20000c0c 	.word	0x20000c0c

0800bf50 <limit_signals_merge>:

#include "config.h"

// Merge (bitwise or) all limit switch inputs.
ISR_CODE axes_signals_t ISR_FUNC(limit_signals_merge)(limit_signals_t signals)
{
 800bf50:	b480      	push	{r7}
 800bf52:	b085      	sub	sp, #20
 800bf54:	af00      	add	r7, sp, #0
 800bf56:	6078      	str	r0, [r7, #4]
    axes_signals_t state;

    state.mask = signals.min.mask | signals.min2.mask | signals.max.mask | signals.max2.mask;
 800bf58:	793a      	ldrb	r2, [r7, #4]
 800bf5a:	79bb      	ldrb	r3, [r7, #6]
 800bf5c:	4313      	orrs	r3, r2
 800bf5e:	b2da      	uxtb	r2, r3
 800bf60:	797b      	ldrb	r3, [r7, #5]
 800bf62:	4313      	orrs	r3, r2
 800bf64:	b2da      	uxtb	r2, r3
 800bf66:	79fb      	ldrb	r3, [r7, #7]
 800bf68:	4313      	orrs	r3, r2
 800bf6a:	b2db      	uxtb	r3, r3
 800bf6c:	733b      	strb	r3, [r7, #12]

    return state;
 800bf6e:	7b3b      	ldrb	r3, [r7, #12]
}
 800bf70:	4618      	mov	r0, r3
 800bf72:	3714      	adds	r7, #20
 800bf74:	46bd      	mov	sp, r7
 800bf76:	bc80      	pop	{r7}
 800bf78:	4770      	bx	lr

0800bf7a <homing_signals_select>:

// Merge (bitwise or) home switch inputs (typically acquired from limits.min and limits.min2).
ISR_CODE static axes_signals_t ISR_FUNC(homing_signals_select)(home_signals_t signals, axes_signals_t auto_square, squaring_mode_t mode)
{
 800bf7a:	b480      	push	{r7}
 800bf7c:	b085      	sub	sp, #20
 800bf7e:	af00      	add	r7, sp, #0
 800bf80:	80b8      	strh	r0, [r7, #4]
 800bf82:	7039      	strb	r1, [r7, #0]
 800bf84:	4613      	mov	r3, r2
 800bf86:	70fb      	strb	r3, [r7, #3]
    axes_signals_t state;

    switch(mode) {
 800bf88:	78fb      	ldrb	r3, [r7, #3]
 800bf8a:	2b01      	cmp	r3, #1
 800bf8c:	d002      	beq.n	800bf94 <homing_signals_select+0x1a>
 800bf8e:	2b02      	cmp	r3, #2
 800bf90:	d00b      	beq.n	800bfaa <homing_signals_select+0x30>
        case SquaringMode_B:
            signals.b.mask &= ~auto_square.mask;
            break;

        default:
            break;
 800bf92:	e015      	b.n	800bfc0 <homing_signals_select+0x46>
            signals.a.mask &= ~auto_square.mask;
 800bf94:	793b      	ldrb	r3, [r7, #4]
 800bf96:	b25a      	sxtb	r2, r3
 800bf98:	783b      	ldrb	r3, [r7, #0]
 800bf9a:	b25b      	sxtb	r3, r3
 800bf9c:	43db      	mvns	r3, r3
 800bf9e:	b25b      	sxtb	r3, r3
 800bfa0:	4013      	ands	r3, r2
 800bfa2:	b25b      	sxtb	r3, r3
 800bfa4:	b2db      	uxtb	r3, r3
 800bfa6:	713b      	strb	r3, [r7, #4]
            break;
 800bfa8:	e00a      	b.n	800bfc0 <homing_signals_select+0x46>
            signals.b.mask &= ~auto_square.mask;
 800bfaa:	797b      	ldrb	r3, [r7, #5]
 800bfac:	b25a      	sxtb	r2, r3
 800bfae:	783b      	ldrb	r3, [r7, #0]
 800bfb0:	b25b      	sxtb	r3, r3
 800bfb2:	43db      	mvns	r3, r3
 800bfb4:	b25b      	sxtb	r3, r3
 800bfb6:	4013      	ands	r3, r2
 800bfb8:	b25b      	sxtb	r3, r3
 800bfba:	b2db      	uxtb	r3, r3
 800bfbc:	717b      	strb	r3, [r7, #5]
            break;
 800bfbe:	bf00      	nop
    }

    state.mask = signals.a.mask | signals.b.mask;
 800bfc0:	793a      	ldrb	r2, [r7, #4]
 800bfc2:	797b      	ldrb	r3, [r7, #5]
 800bfc4:	4313      	orrs	r3, r2
 800bfc6:	b2db      	uxtb	r3, r3
 800bfc8:	733b      	strb	r3, [r7, #12]

    return state;
 800bfca:	7b3b      	ldrb	r3, [r7, #12]
}
 800bfcc:	4618      	mov	r0, r3
 800bfce:	3714      	adds	r7, #20
 800bfd0:	46bd      	mov	sp, r7
 800bfd2:	bc80      	pop	{r7}
 800bfd4:	4770      	bx	lr
	...

0800bfd8 <limit_interrupt_handler>:
// if a limit switch is being disengaged. It's impossible to reliably tell the state of a
// bouncing pin because the microcontroller does not retain any state information when
// detecting a pin change. If we poll the pins in the ISR, you can miss the correct reading if the
// switch is bouncing.
ISR_CODE void ISR_FUNC(limit_interrupt_handler)(limit_signals_t state) // DEFAULT: Limit pin change interrupt process.
{
 800bfd8:	b580      	push	{r7, lr}
 800bfda:	b082      	sub	sp, #8
 800bfdc:	af00      	add	r7, sp, #0
 800bfde:	6078      	str	r0, [r7, #4]
 800bfe0:	687b      	ldr	r3, [r7, #4]
#if N_AXIS > 3
    if((limit_signals_merge(state).value & sys.hard_limits.mask) == 0)
        return;
#endif

    memcpy(&sys.last_event.limits, &state, sizeof(limit_signals_t));
 800bfe2:	4a0d      	ldr	r2, [pc, #52]	; (800c018 <limit_interrupt_handler+0x40>)
 800bfe4:	f8c2 3082 	str.w	r3, [r2, #130]	; 0x82

    if (!(state_get() & (STATE_ALARM|STATE_ESTOP)) && !sys.rt_exec_alarm) {
 800bfe8:	f011 fc6a 	bl	801d8c0 <state_get>
 800bfec:	4602      	mov	r2, r0
 800bfee:	f240 1301 	movw	r3, #257	; 0x101
 800bff2:	4013      	ands	r3, r2
 800bff4:	2b00      	cmp	r3, #0
 800bff6:	d10a      	bne.n	800c00e <limit_interrupt_handler+0x36>
 800bff8:	4b07      	ldr	r3, [pc, #28]	; (800c018 <limit_interrupt_handler+0x40>)
 800bffa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800bffc:	2b00      	cmp	r3, #0
 800bffe:	d106      	bne.n	800c00e <limit_interrupt_handler+0x36>
        if (limit_signals_merge(state).value) {
            mc_reset(); // Initiate system kill.
            system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
        }
      #else
        mc_reset(); // Initiate system kill.
 800c000:	f003 fb72 	bl	800f6e8 <mc_reset>
        system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
 800c004:	4b05      	ldr	r3, [pc, #20]	; (800c01c <limit_interrupt_handler+0x44>)
 800c006:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c008:	2101      	movs	r1, #1
 800c00a:	4805      	ldr	r0, [pc, #20]	; (800c020 <limit_interrupt_handler+0x48>)
 800c00c:	4798      	blx	r3
      #endif
    }
}
 800c00e:	bf00      	nop
 800c010:	3708      	adds	r7, #8
 800c012:	46bd      	mov	sp, r7
 800c014:	bd80      	pop	{r7, pc}
 800c016:	bf00      	nop
 800c018:	20000d3c 	.word	0x20000d3c
 800c01c:	20000ed0 	.word	0x20000ed0
 800c020:	20000d88 	.word	0x20000d88

0800c024 <limits_set_work_envelope>:

// Establish work envelope for homed axes, used by soft limits and jog limits handling.
// When hard limits are enabled pulloff distance is subtracted to avoid triggering limit switches.
void limits_set_work_envelope (void)
{
 800c024:	b580      	push	{r7, lr}
 800c026:	b082      	sub	sp, #8
 800c028:	af00      	add	r7, sp, #0
    uint_fast8_t idx = N_AXIS;
 800c02a:	2303      	movs	r3, #3
 800c02c:	607b      	str	r3, [r7, #4]

    do {
        if(sys.homed.mask & bit(--idx)) {
 800c02e:	4b5a      	ldr	r3, [pc, #360]	; (800c198 <limits_set_work_envelope+0x174>)
 800c030:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800c034:	461a      	mov	r2, r3
 800c036:	687b      	ldr	r3, [r7, #4]
 800c038:	3b01      	subs	r3, #1
 800c03a:	607b      	str	r3, [r7, #4]
 800c03c:	687b      	ldr	r3, [r7, #4]
 800c03e:	fa22 f303 	lsr.w	r3, r2, r3
 800c042:	f003 0301 	and.w	r3, r3, #1
 800c046:	2b00      	cmp	r3, #0
 800c048:	f000 8088 	beq.w	800c15c <limits_set_work_envelope+0x138>

            float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 800c04c:	4b53      	ldr	r3, [pc, #332]	; (800c19c <limits_set_work_envelope+0x178>)
 800c04e:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 800c052:	f003 0301 	and.w	r3, r3, #1
 800c056:	b2db      	uxtb	r3, r3
 800c058:	2b00      	cmp	r3, #0
 800c05a:	d00d      	beq.n	800c078 <limits_set_work_envelope+0x54>
 800c05c:	4b4e      	ldr	r3, [pc, #312]	; (800c198 <limits_set_work_envelope+0x174>)
 800c05e:	7e9b      	ldrb	r3, [r3, #26]
 800c060:	461a      	mov	r2, r3
 800c062:	687b      	ldr	r3, [r7, #4]
 800c064:	fa22 f303 	lsr.w	r3, r2, r3
 800c068:	f003 0301 	and.w	r3, r3, #1
 800c06c:	2b00      	cmp	r3, #0
 800c06e:	d003      	beq.n	800c078 <limits_set_work_envelope+0x54>
 800c070:	4b4a      	ldr	r3, [pc, #296]	; (800c19c <limits_set_work_envelope+0x178>)
 800c072:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800c076:	e001      	b.n	800c07c <limits_set_work_envelope+0x58>
 800c078:	f04f 0300 	mov.w	r3, #0
 800c07c:	603b      	str	r3, [r7, #0]

            if(settings.homing.flags.force_set_origin) {
 800c07e:	4b47      	ldr	r3, [pc, #284]	; (800c19c <limits_set_work_envelope+0x178>)
 800c080:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800c084:	f003 0308 	and.w	r3, r3, #8
 800c088:	b2db      	uxtb	r3, r3
 800c08a:	2b00      	cmp	r3, #0
 800c08c:	d047      	beq.n	800c11e <limits_set_work_envelope+0xfa>
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 800c08e:	4b43      	ldr	r3, [pc, #268]	; (800c19c <limits_set_work_envelope+0x178>)
 800c090:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 800c094:	461a      	mov	r2, r3
 800c096:	687b      	ldr	r3, [r7, #4]
 800c098:	fa22 f303 	lsr.w	r3, r2, r3
 800c09c:	f003 0301 	and.w	r3, r3, #1
 800c0a0:	2b00      	cmp	r3, #0
 800c0a2:	d11d      	bne.n	800c0e0 <limits_set_work_envelope+0xbc>
                    sys.work_envelope.min.values[idx] = settings.axis[idx].max_travel + pulloff;
 800c0a4:	493d      	ldr	r1, [pc, #244]	; (800c19c <limits_set_work_envelope+0x178>)
 800c0a6:	687a      	ldr	r2, [r7, #4]
 800c0a8:	4613      	mov	r3, r2
 800c0aa:	009b      	lsls	r3, r3, #2
 800c0ac:	4413      	add	r3, r2
 800c0ae:	009b      	lsls	r3, r3, #2
 800c0b0:	440b      	add	r3, r1
 800c0b2:	333c      	adds	r3, #60	; 0x3c
 800c0b4:	681b      	ldr	r3, [r3, #0]
 800c0b6:	6839      	ldr	r1, [r7, #0]
 800c0b8:	4618      	mov	r0, r3
 800c0ba:	f7f4 fd73 	bl	8000ba4 <__addsf3>
 800c0be:	4603      	mov	r3, r0
 800c0c0:	4619      	mov	r1, r3
 800c0c2:	4a35      	ldr	r2, [pc, #212]	; (800c198 <limits_set_work_envelope+0x174>)
 800c0c4:	687b      	ldr	r3, [r7, #4]
 800c0c6:	3318      	adds	r3, #24
 800c0c8:	009b      	lsls	r3, r3, #2
 800c0ca:	4413      	add	r3, r2
 800c0cc:	6059      	str	r1, [r3, #4]
                    sys.work_envelope.max.values[idx] = 0.0f;
 800c0ce:	4a32      	ldr	r2, [pc, #200]	; (800c198 <limits_set_work_envelope+0x174>)
 800c0d0:	687b      	ldr	r3, [r7, #4]
 800c0d2:	331a      	adds	r3, #26
 800c0d4:	009b      	lsls	r3, r3, #2
 800c0d6:	4413      	add	r3, r2
 800c0d8:	f04f 0200 	mov.w	r2, #0
 800c0dc:	609a      	str	r2, [r3, #8]
 800c0de:	e051      	b.n	800c184 <limits_set_work_envelope+0x160>
                } else {
                    sys.work_envelope.min.values[idx] = 0.0f;
 800c0e0:	4a2d      	ldr	r2, [pc, #180]	; (800c198 <limits_set_work_envelope+0x174>)
 800c0e2:	687b      	ldr	r3, [r7, #4]
 800c0e4:	3318      	adds	r3, #24
 800c0e6:	009b      	lsls	r3, r3, #2
 800c0e8:	4413      	add	r3, r2
 800c0ea:	f04f 0200 	mov.w	r2, #0
 800c0ee:	605a      	str	r2, [r3, #4]
                    sys.work_envelope.max.values[idx] = - (settings.axis[idx].max_travel + pulloff);
 800c0f0:	492a      	ldr	r1, [pc, #168]	; (800c19c <limits_set_work_envelope+0x178>)
 800c0f2:	687a      	ldr	r2, [r7, #4]
 800c0f4:	4613      	mov	r3, r2
 800c0f6:	009b      	lsls	r3, r3, #2
 800c0f8:	4413      	add	r3, r2
 800c0fa:	009b      	lsls	r3, r3, #2
 800c0fc:	440b      	add	r3, r1
 800c0fe:	333c      	adds	r3, #60	; 0x3c
 800c100:	681b      	ldr	r3, [r3, #0]
 800c102:	6839      	ldr	r1, [r7, #0]
 800c104:	4618      	mov	r0, r3
 800c106:	f7f4 fd4d 	bl	8000ba4 <__addsf3>
 800c10a:	4603      	mov	r3, r0
 800c10c:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
 800c110:	4921      	ldr	r1, [pc, #132]	; (800c198 <limits_set_work_envelope+0x174>)
 800c112:	687b      	ldr	r3, [r7, #4]
 800c114:	331a      	adds	r3, #26
 800c116:	009b      	lsls	r3, r3, #2
 800c118:	440b      	add	r3, r1
 800c11a:	609a      	str	r2, [r3, #8]
 800c11c:	e032      	b.n	800c184 <limits_set_work_envelope+0x160>
                }
            } else {
                sys.work_envelope.min.values[idx] = settings.axis[idx].max_travel + pulloff;
 800c11e:	491f      	ldr	r1, [pc, #124]	; (800c19c <limits_set_work_envelope+0x178>)
 800c120:	687a      	ldr	r2, [r7, #4]
 800c122:	4613      	mov	r3, r2
 800c124:	009b      	lsls	r3, r3, #2
 800c126:	4413      	add	r3, r2
 800c128:	009b      	lsls	r3, r3, #2
 800c12a:	440b      	add	r3, r1
 800c12c:	333c      	adds	r3, #60	; 0x3c
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	6839      	ldr	r1, [r7, #0]
 800c132:	4618      	mov	r0, r3
 800c134:	f7f4 fd36 	bl	8000ba4 <__addsf3>
 800c138:	4603      	mov	r3, r0
 800c13a:	4619      	mov	r1, r3
 800c13c:	4a16      	ldr	r2, [pc, #88]	; (800c198 <limits_set_work_envelope+0x174>)
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	3318      	adds	r3, #24
 800c142:	009b      	lsls	r3, r3, #2
 800c144:	4413      	add	r3, r2
 800c146:	6059      	str	r1, [r3, #4]
                sys.work_envelope.max.values[idx] = - pulloff;
 800c148:	683b      	ldr	r3, [r7, #0]
 800c14a:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
 800c14e:	4912      	ldr	r1, [pc, #72]	; (800c198 <limits_set_work_envelope+0x174>)
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	331a      	adds	r3, #26
 800c154:	009b      	lsls	r3, r3, #2
 800c156:	440b      	add	r3, r1
 800c158:	609a      	str	r2, [r3, #8]
 800c15a:	e013      	b.n	800c184 <limits_set_work_envelope+0x160>
            }
        } else
            sys.work_envelope.min.values[idx] = sys.work_envelope.max.values[idx] = 0.0f;
 800c15c:	4a0e      	ldr	r2, [pc, #56]	; (800c198 <limits_set_work_envelope+0x174>)
 800c15e:	687b      	ldr	r3, [r7, #4]
 800c160:	331a      	adds	r3, #26
 800c162:	009b      	lsls	r3, r3, #2
 800c164:	4413      	add	r3, r2
 800c166:	f04f 0200 	mov.w	r2, #0
 800c16a:	609a      	str	r2, [r3, #8]
 800c16c:	4a0a      	ldr	r2, [pc, #40]	; (800c198 <limits_set_work_envelope+0x174>)
 800c16e:	687b      	ldr	r3, [r7, #4]
 800c170:	331a      	adds	r3, #26
 800c172:	009b      	lsls	r3, r3, #2
 800c174:	4413      	add	r3, r2
 800c176:	689a      	ldr	r2, [r3, #8]
 800c178:	4907      	ldr	r1, [pc, #28]	; (800c198 <limits_set_work_envelope+0x174>)
 800c17a:	687b      	ldr	r3, [r7, #4]
 800c17c:	3318      	adds	r3, #24
 800c17e:	009b      	lsls	r3, r3, #2
 800c180:	440b      	add	r3, r1
 800c182:	605a      	str	r2, [r3, #4]
    } while(idx);
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	2b00      	cmp	r3, #0
 800c188:	f47f af51 	bne.w	800c02e <limits_set_work_envelope+0xa>
}
 800c18c:	bf00      	nop
 800c18e:	bf00      	nop
 800c190:	3708      	adds	r7, #8
 800c192:	46bd      	mov	sp, r7
 800c194:	bd80      	pop	{r7, pc}
 800c196:	bf00      	nop
 800c198:	20000d3c 	.word	0x20000d3c
 800c19c:	2000147c 	.word	0x2000147c

0800c1a0 <limits_pull_off>:
#endif

// Pulls off axes from asserted homing switches before homing starts.
// For now only for auto squared axes.
static bool limits_pull_off (axes_signals_t axis, float distance)
{
 800c1a0:	b590      	push	{r4, r7, lr}
 800c1a2:	b099      	sub	sp, #100	; 0x64
 800c1a4:	af00      	add	r7, sp, #0
 800c1a6:	7138      	strb	r0, [r7, #4]
 800c1a8:	6039      	str	r1, [r7, #0]
    uint_fast8_t n_axis = 0, idx = N_AXIS;
 800c1aa:	2300      	movs	r3, #0
 800c1ac:	65fb      	str	r3, [r7, #92]	; 0x5c
 800c1ae:	2303      	movs	r3, #3
 800c1b0:	65bb      	str	r3, [r7, #88]	; 0x58
    coord_data_t target = {0};
 800c1b2:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800c1b6:	2200      	movs	r2, #0
 800c1b8:	601a      	str	r2, [r3, #0]
 800c1ba:	605a      	str	r2, [r3, #4]
 800c1bc:	609a      	str	r2, [r3, #8]
    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 800c1be:	f107 0318 	add.w	r3, r7, #24
 800c1c2:	4618      	mov	r0, r3
 800c1c4:	f006 f8f2 	bl	80123ac <plan_data_init>
    plan_data.condition.system_motion = On;
 800c1c8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800c1cc:	f043 0302 	orr.w	r3, r3, #2
 800c1d0:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    plan_data.condition.no_feed_override = On;
 800c1d4:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800c1d8:	f043 0310 	orr.w	r3, r3, #16
 800c1dc:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    plan_data.line_number = DEFAULT_HOMING_CYCLE_LINE_NUMBER;
 800c1e0:	2300      	movs	r3, #0
 800c1e2:	63bb      	str	r3, [r7, #56]	; 0x38

    system_convert_array_steps_to_mpos(target.values, sys.position);
 800c1e4:	f107 0344 	add.w	r3, r7, #68	; 0x44
 800c1e8:	496b      	ldr	r1, [pc, #428]	; (800c398 <limits_pull_off+0x1f8>)
 800c1ea:	4618      	mov	r0, r3
 800c1ec:	f015 fe10 	bl	8021e10 <system_convert_array_steps_to_mpos>

    do {
        idx--;
 800c1f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c1f2:	3b01      	subs	r3, #1
 800c1f4:	65bb      	str	r3, [r7, #88]	; 0x58
        if(bit_istrue(axis.mask, bit(idx))) {
 800c1f6:	793b      	ldrb	r3, [r7, #4]
 800c1f8:	461a      	mov	r2, r3
 800c1fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c1fc:	fa22 f303 	lsr.w	r3, r2, r3
 800c200:	f003 0301 	and.w	r3, r3, #1
 800c204:	2b00      	cmp	r3, #0
 800c206:	d032      	beq.n	800c26e <limits_pull_off+0xce>
            n_axis++;
 800c208:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800c20a:	3301      	adds	r3, #1
 800c20c:	65fb      	str	r3, [r7, #92]	; 0x5c
            if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 800c20e:	4b63      	ldr	r3, [pc, #396]	; (800c39c <limits_pull_off+0x1fc>)
 800c210:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 800c214:	461a      	mov	r2, r3
 800c216:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c218:	fa22 f303 	lsr.w	r3, r2, r3
 800c21c:	f003 0301 	and.w	r3, r3, #1
 800c220:	2b00      	cmp	r3, #0
 800c222:	d012      	beq.n	800c24a <limits_pull_off+0xaa>
                target.values[idx] += distance;
 800c224:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c226:	009b      	lsls	r3, r3, #2
 800c228:	3360      	adds	r3, #96	; 0x60
 800c22a:	443b      	add	r3, r7
 800c22c:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 800c230:	6839      	ldr	r1, [r7, #0]
 800c232:	4618      	mov	r0, r3
 800c234:	f7f4 fcb6 	bl	8000ba4 <__addsf3>
 800c238:	4603      	mov	r3, r0
 800c23a:	461a      	mov	r2, r3
 800c23c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c23e:	009b      	lsls	r3, r3, #2
 800c240:	3360      	adds	r3, #96	; 0x60
 800c242:	443b      	add	r3, r7
 800c244:	f843 2c1c 	str.w	r2, [r3, #-28]
 800c248:	e011      	b.n	800c26e <limits_pull_off+0xce>
            else
                target.values[idx] -= distance;
 800c24a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c24c:	009b      	lsls	r3, r3, #2
 800c24e:	3360      	adds	r3, #96	; 0x60
 800c250:	443b      	add	r3, r7
 800c252:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 800c256:	6839      	ldr	r1, [r7, #0]
 800c258:	4618      	mov	r0, r3
 800c25a:	f7f4 fca1 	bl	8000ba0 <__aeabi_fsub>
 800c25e:	4603      	mov	r3, r0
 800c260:	461a      	mov	r2, r3
 800c262:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c264:	009b      	lsls	r3, r3, #2
 800c266:	3360      	adds	r3, #96	; 0x60
 800c268:	443b      	add	r3, r7
 800c26a:	f843 2c1c 	str.w	r2, [r3, #-28]
        }
    } while(idx);
 800c26e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c270:	2b00      	cmp	r3, #0
 800c272:	d1bd      	bne.n	800c1f0 <limits_pull_off+0x50>

    plan_data.feed_rate = settings.homing.seek_rate * sqrtf(n_axis); // Adjust so individual axes all move at pull-off rate.
 800c274:	4b49      	ldr	r3, [pc, #292]	; (800c39c <limits_pull_off+0x1fc>)
 800c276:	f8d3 4108 	ldr.w	r4, [r3, #264]	; 0x108
 800c27a:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800c27c:	f7f4 fd42 	bl	8000d04 <__aeabi_ui2f>
 800c280:	4603      	mov	r3, r0
 800c282:	4618      	mov	r0, r3
 800c284:	f018 fbbb 	bl	80249fe <sqrtf>
 800c288:	4603      	mov	r3, r0
 800c28a:	4619      	mov	r1, r3
 800c28c:	4620      	mov	r0, r4
 800c28e:	f7f4 fd91 	bl	8000db4 <__aeabi_fmul>
 800c292:	4603      	mov	r3, r0
 800c294:	61bb      	str	r3, [r7, #24]
    plan_data.condition.coolant = gc_state.modal.coolant;
 800c296:	4b42      	ldr	r3, [pc, #264]	; (800c3a0 <limits_pull_off+0x200>)
 800c298:	7e5b      	ldrb	r3, [r3, #25]
 800c29a:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 800c29e:	4b40      	ldr	r3, [pc, #256]	; (800c3a0 <limits_pull_off+0x200>)
 800c2a0:	f107 0420 	add.w	r4, r7, #32
 800c2a4:	3344      	adds	r3, #68	; 0x44
 800c2a6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800c2a8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

#ifdef KINEMATICS_API
    coord_data_t k_target;
    plan_buffer_line(kinematics.transform_from_cartesian(k_target.values, target.values), &plan_data);    // Bypass mc_line(). Directly plan homing motion.;
 800c2ac:	4b3d      	ldr	r3, [pc, #244]	; (800c3a4 <limits_pull_off+0x204>)
 800c2ae:	685b      	ldr	r3, [r3, #4]
 800c2b0:	f107 0144 	add.w	r1, r7, #68	; 0x44
 800c2b4:	f107 020c 	add.w	r2, r7, #12
 800c2b8:	4610      	mov	r0, r2
 800c2ba:	4798      	blx	r3
 800c2bc:	4602      	mov	r2, r0
 800c2be:	f107 0318 	add.w	r3, r7, #24
 800c2c2:	4619      	mov	r1, r3
 800c2c4:	4610      	mov	r0, r2
 800c2c6:	f005 fc97 	bl	8011bf8 <plan_buffer_line>
#else
    plan_buffer_line(target.values, &plan_data);    // Bypass mc_line(). Directly plan homing motion.
#endif

    sys.step_control.flags = 0;                 // Clear existing flags and
 800c2ca:	4b37      	ldr	r3, [pc, #220]	; (800c3a8 <limits_pull_off+0x208>)
 800c2cc:	2200      	movs	r2, #0
 800c2ce:	761a      	strb	r2, [r3, #24]
    sys.step_control.execute_sys_motion = On;   // set to execute homing motion.
 800c2d0:	4a35      	ldr	r2, [pc, #212]	; (800c3a8 <limits_pull_off+0x208>)
 800c2d2:	7e13      	ldrb	r3, [r2, #24]
 800c2d4:	f043 0304 	orr.w	r3, r3, #4
 800c2d8:	7613      	strb	r3, [r2, #24]
    sys.homing_axis_lock.mask = axis.mask;
 800c2da:	793a      	ldrb	r2, [r7, #4]
 800c2dc:	4b32      	ldr	r3, [pc, #200]	; (800c3a8 <limits_pull_off+0x208>)
 800c2de:	765a      	strb	r2, [r3, #25]

    st_prep_buffer();   // Prep and fill segment buffer from newly planned block.
 800c2e0:	f012 fffe 	bl	801f2e0 <st_prep_buffer>
    st_wake_up();       // Initiate motion.
 800c2e4:	f012 fbd6 	bl	801ea94 <st_wake_up>

    while(true) {

        st_prep_buffer(); // Check and prep segment buffer.
 800c2e8:	f012 fffa 	bl	801f2e0 <st_prep_buffer>

        // Exit routines: No time to run protocol_execute_realtime() in this loop.
        if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 800c2ec:	4b2e      	ldr	r3, [pc, #184]	; (800c3a8 <limits_pull_off+0x208>)
 800c2ee:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c2f0:	f003 0364 	and.w	r3, r3, #100	; 0x64
 800c2f4:	2b00      	cmp	r3, #0
 800c2f6:	d045      	beq.n	800c384 <limits_pull_off+0x1e4>

            uint_fast16_t rt_exec = sys.rt_exec_state;
 800c2f8:	4b2b      	ldr	r3, [pc, #172]	; (800c3a8 <limits_pull_off+0x208>)
 800c2fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c2fc:	657b      	str	r3, [r7, #84]	; 0x54

            // Homing failure condition: Reset issued during cycle.
            if (rt_exec & EXEC_RESET)
 800c2fe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c300:	f003 0320 	and.w	r3, r3, #32
 800c304:	2b00      	cmp	r3, #0
 800c306:	d004      	beq.n	800c312 <limits_pull_off+0x172>
                system_set_exec_alarm(Alarm_HomingFailReset);
 800c308:	4b28      	ldr	r3, [pc, #160]	; (800c3ac <limits_pull_off+0x20c>)
 800c30a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c30c:	2106      	movs	r1, #6
 800c30e:	4828      	ldr	r0, [pc, #160]	; (800c3b0 <limits_pull_off+0x210>)
 800c310:	4798      	blx	r3

            // Homing failure condition: Safety door was opened.
            if (rt_exec & EXEC_SAFETY_DOOR)
 800c312:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c314:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c318:	2b00      	cmp	r3, #0
 800c31a:	d004      	beq.n	800c326 <limits_pull_off+0x186>
                system_set_exec_alarm(Alarm_HomingFailDoor);
 800c31c:	4b23      	ldr	r3, [pc, #140]	; (800c3ac <limits_pull_off+0x20c>)
 800c31e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c320:	2107      	movs	r1, #7
 800c322:	4823      	ldr	r0, [pc, #140]	; (800c3b0 <limits_pull_off+0x210>)
 800c324:	4798      	blx	r3

            // Homing failure condition: Homing switch(es) still engaged after pull-off motion
            if (homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask & axis.mask)
 800c326:	4b21      	ldr	r3, [pc, #132]	; (800c3ac <limits_pull_off+0x20c>)
 800c328:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c32a:	4798      	blx	r3
 800c32c:	4603      	mov	r3, r0
 800c32e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 800c332:	2300      	movs	r3, #0
 800c334:	2200      	movs	r2, #0
 800c336:	4619      	mov	r1, r3
 800c338:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800c33a:	f7ff fe1e 	bl	800bf7a <homing_signals_select>
 800c33e:	4603      	mov	r3, r0
 800c340:	b2da      	uxtb	r2, r3
 800c342:	793b      	ldrb	r3, [r7, #4]
 800c344:	4013      	ands	r3, r2
 800c346:	b2db      	uxtb	r3, r3
 800c348:	2b00      	cmp	r3, #0
 800c34a:	d004      	beq.n	800c356 <limits_pull_off+0x1b6>
                system_set_exec_alarm(Alarm_FailPulloff);
 800c34c:	4b17      	ldr	r3, [pc, #92]	; (800c3ac <limits_pull_off+0x20c>)
 800c34e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c350:	2108      	movs	r1, #8
 800c352:	4817      	ldr	r0, [pc, #92]	; (800c3b0 <limits_pull_off+0x210>)
 800c354:	4798      	blx	r3

            if (sys.rt_exec_alarm) {
 800c356:	4b14      	ldr	r3, [pc, #80]	; (800c3a8 <limits_pull_off+0x208>)
 800c358:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c35a:	2b00      	cmp	r3, #0
 800c35c:	d005      	beq.n	800c36a <limits_pull_off+0x1ca>
                mc_reset(); // Stop motors, if they are running.
 800c35e:	f003 f9c3 	bl	800f6e8 <mc_reset>
                protocol_execute_realtime();
 800c362:	f006 fcfd 	bl	8012d60 <protocol_execute_realtime>
                return false;
 800c366:	2300      	movs	r3, #0
 800c368:	e011      	b.n	800c38e <limits_pull_off+0x1ee>
            } else {
                // Pull-off motion complete. Disable CYCLE_STOP from executing.
                system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
 800c36a:	4b10      	ldr	r3, [pc, #64]	; (800c3ac <limits_pull_off+0x20c>)
 800c36c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c36e:	2104      	movs	r1, #4
 800c370:	4810      	ldr	r0, [pc, #64]	; (800c3b4 <limits_pull_off+0x214>)
 800c372:	4798      	blx	r3
                break;
 800c374:	bf00      	nop
        }

        grbl.on_execute_realtime(STATE_HOMING);
    }

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
 800c376:	f012 fe17 	bl	801efa8 <st_reset>

    sys.step_control.flags = 0; // Return step control to normal operation.
 800c37a:	4b0b      	ldr	r3, [pc, #44]	; (800c3a8 <limits_pull_off+0x208>)
 800c37c:	2200      	movs	r2, #0
 800c37e:	761a      	strb	r2, [r3, #24]

    return true; // Note: failure is returned above if move fails.
 800c380:	2301      	movs	r3, #1
 800c382:	e004      	b.n	800c38e <limits_pull_off+0x1ee>
        grbl.on_execute_realtime(STATE_HOMING);
 800c384:	4b0c      	ldr	r3, [pc, #48]	; (800c3b8 <limits_pull_off+0x218>)
 800c386:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c388:	2004      	movs	r0, #4
 800c38a:	4798      	blx	r3
        st_prep_buffer(); // Check and prep segment buffer.
 800c38c:	e7ac      	b.n	800c2e8 <limits_pull_off+0x148>
}
 800c38e:	4618      	mov	r0, r3
 800c390:	3764      	adds	r7, #100	; 0x64
 800c392:	46bd      	mov	sp, r7
 800c394:	bd90      	pop	{r4, r7, pc}
 800c396:	bf00      	nop
 800c398:	20000dc4 	.word	0x20000dc4
 800c39c:	2000147c 	.word	0x2000147c
 800c3a0:	20000bb0 	.word	0x20000bb0
 800c3a4:	20001088 	.word	0x20001088
 800c3a8:	20000d3c 	.word	0x20000d3c
 800c3ac:	20000ed0 	.word	0x20000ed0
 800c3b0:	20000d88 	.word	0x20000d88
 800c3b4:	20000d84 	.word	0x20000d84
 800c3b8:	20000dd4 	.word	0x20000dd4

0800c3bc <homing_cycle>:
// the trigger point of the limit switches. The rapid stops are handled by a system level axis lock
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
static bool homing_cycle (axes_signals_t cycle, axes_signals_t auto_square)
{
 800c3bc:	b590      	push	{r4, r7, lr}
 800c3be:	b0a7      	sub	sp, #156	; 0x9c
 800c3c0:	af00      	add	r7, sp, #0
 800c3c2:	7138      	strb	r0, [r7, #4]
 800c3c4:	7039      	strb	r1, [r7, #0]
    if (ABORTED) // Block if system reset has been issued.
 800c3c6:	4ba4      	ldr	r3, [pc, #656]	; (800c658 <homing_cycle+0x29c>)
 800c3c8:	781b      	ldrb	r3, [r3, #0]
 800c3ca:	2b00      	cmp	r3, #0
 800c3cc:	d103      	bne.n	800c3d6 <homing_cycle+0x1a>
 800c3ce:	4ba2      	ldr	r3, [pc, #648]	; (800c658 <homing_cycle+0x29c>)
 800c3d0:	785b      	ldrb	r3, [r3, #1]
 800c3d2:	2b00      	cmp	r3, #0
 800c3d4:	d001      	beq.n	800c3da <homing_cycle+0x1e>
        return false;
 800c3d6:	2300      	movs	r3, #0
 800c3d8:	e385      	b.n	800cae6 <homing_cycle+0x72a>

    int32_t initial_trigger_position = 0, autosquare_fail_distance = 0;
 800c3da:	2300      	movs	r3, #0
 800c3dc:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800c3e0:	2300      	movs	r3, #0
 800c3e2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 800c3e6:	4b9d      	ldr	r3, [pc, #628]	; (800c65c <homing_cycle+0x2a0>)
 800c3e8:	f893 3111 	ldrb.w	r3, [r3, #273]	; 0x111
 800c3ec:	005b      	lsls	r3, r3, #1
 800c3ee:	3301      	adds	r3, #1
 800c3f0:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    uint_fast8_t step_pin[N_AXIS], n_active_axis, dual_motor_axis = 0;
 800c3f4:	2300      	movs	r3, #0
 800c3f6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    bool autosquare_check = false;
 800c3fa:	2300      	movs	r3, #0
 800c3fc:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
    float max_travel = 0.0f, homing_rate;
 800c400:	f04f 0300 	mov.w	r3, #0
 800c404:	67fb      	str	r3, [r7, #124]	; 0x7c
    homing_mode_t mode = HomingMode_Seek;
 800c406:	2300      	movs	r3, #0
 800c408:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
    axes_signals_t axislock, homing_state;
    home_signals_t signals_state;
    squaring_mode_t squaring_mode = SquaringMode_Both;
 800c40c:	2300      	movs	r3, #0
 800c40e:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
    coord_data_t target;
    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 800c412:	f107 0314 	add.w	r3, r7, #20
 800c416:	4618      	mov	r0, r3
 800c418:	f005 ffc8 	bl	80123ac <plan_data_init>
    plan_data.condition.system_motion = On;
 800c41c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800c420:	f043 0302 	orr.w	r3, r3, #2
 800c424:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    plan_data.condition.no_feed_override = On;
 800c428:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 800c42c:	f043 0310 	orr.w	r3, r3, #16
 800c430:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
    plan_data.line_number = DEFAULT_HOMING_CYCLE_LINE_NUMBER;
 800c434:	2300      	movs	r3, #0
 800c436:	637b      	str	r3, [r7, #52]	; 0x34

    // Initialize plan data struct for homing motion.
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 800c438:	4b89      	ldr	r3, [pc, #548]	; (800c660 <homing_cycle+0x2a4>)
 800c43a:	f107 041c 	add.w	r4, r7, #28
 800c43e:	3344      	adds	r3, #68	; 0x44
 800c440:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800c442:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    plan_data.condition.coolant = gc_state.modal.coolant;
 800c446:	4b86      	ldr	r3, [pc, #536]	; (800c660 <homing_cycle+0x2a4>)
 800c448:	7e5b      	ldrb	r3, [r3, #25]
 800c44a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

    uint_fast8_t idx = N_AXIS;
 800c44e:	2303      	movs	r3, #3
 800c450:	673b      	str	r3, [r7, #112]	; 0x70
    do {
        idx--;
 800c452:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c454:	3b01      	subs	r3, #1
 800c456:	673b      	str	r3, [r7, #112]	; 0x70
        // Initialize step pin masks
#ifdef KINEMATICS_API
        step_pin[idx] = kinematics.limits_get_axis_mask(idx);
 800c458:	4b82      	ldr	r3, [pc, #520]	; (800c664 <homing_cycle+0x2a8>)
 800c45a:	68db      	ldr	r3, [r3, #12]
 800c45c:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800c45e:	4798      	blx	r3
 800c460:	4602      	mov	r2, r0
 800c462:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c464:	009b      	lsls	r3, r3, #2
 800c466:	3398      	adds	r3, #152	; 0x98
 800c468:	443b      	add	r3, r7
 800c46a:	f843 2c40 	str.w	r2, [r3, #-64]
#else
        step_pin[idx] = bit(idx);
#endif
        // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
        // NOTE: settings.axis[].max_travel is stored as a negative value.
        if(bit_istrue(cycle.mask, bit(idx))) {
 800c46e:	793b      	ldrb	r3, [r7, #4]
 800c470:	461a      	mov	r2, r3
 800c472:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c474:	fa22 f303 	lsr.w	r3, r2, r3
 800c478:	f003 0301 	and.w	r3, r3, #1
 800c47c:	2b00      	cmp	r3, #0
 800c47e:	d031      	beq.n	800c4e4 <homing_cycle+0x128>
#if N_AXIS > 3
            if(bit_istrue(settings.steppers.is_rotational.mask, bit(idx)))
                max_travel = max(max_travel, (-HOMING_AXIS_SEARCH_SCALAR) * (settings.axis[idx].max_travel < -0.0f ? settings.axis[idx].max_travel : -360.0f));
            else
#endif
            max_travel = max(max_travel, (-HOMING_AXIS_SEARCH_SCALAR) * settings.axis[idx].max_travel);
 800c480:	4976      	ldr	r1, [pc, #472]	; (800c65c <homing_cycle+0x2a0>)
 800c482:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800c484:	4613      	mov	r3, r2
 800c486:	009b      	lsls	r3, r3, #2
 800c488:	4413      	add	r3, r2
 800c48a:	009b      	lsls	r3, r3, #2
 800c48c:	440b      	add	r3, r1
 800c48e:	333c      	adds	r3, #60	; 0x3c
 800c490:	681b      	ldr	r3, [r3, #0]
 800c492:	4975      	ldr	r1, [pc, #468]	; (800c668 <homing_cycle+0x2ac>)
 800c494:	4618      	mov	r0, r3
 800c496:	f7f4 fc8d 	bl	8000db4 <__aeabi_fmul>
 800c49a:	4603      	mov	r3, r0
 800c49c:	4619      	mov	r1, r3
 800c49e:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 800c4a0:	f7f4 fe44 	bl	800112c <__aeabi_fcmpgt>
 800c4a4:	4603      	mov	r3, r0
 800c4a6:	2b00      	cmp	r3, #0
 800c4a8:	d001      	beq.n	800c4ae <homing_cycle+0xf2>
 800c4aa:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c4ac:	e00d      	b.n	800c4ca <homing_cycle+0x10e>
 800c4ae:	496b      	ldr	r1, [pc, #428]	; (800c65c <homing_cycle+0x2a0>)
 800c4b0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800c4b2:	4613      	mov	r3, r2
 800c4b4:	009b      	lsls	r3, r3, #2
 800c4b6:	4413      	add	r3, r2
 800c4b8:	009b      	lsls	r3, r3, #2
 800c4ba:	440b      	add	r3, r1
 800c4bc:	333c      	adds	r3, #60	; 0x3c
 800c4be:	681b      	ldr	r3, [r3, #0]
 800c4c0:	4969      	ldr	r1, [pc, #420]	; (800c668 <homing_cycle+0x2ac>)
 800c4c2:	4618      	mov	r0, r3
 800c4c4:	f7f4 fc76 	bl	8000db4 <__aeabi_fmul>
 800c4c8:	4603      	mov	r3, r0
 800c4ca:	67fb      	str	r3, [r7, #124]	; 0x7c

            if(bit_istrue(auto_square.mask, bit(idx)))
 800c4cc:	783b      	ldrb	r3, [r7, #0]
 800c4ce:	461a      	mov	r2, r3
 800c4d0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c4d2:	fa22 f303 	lsr.w	r3, r2, r3
 800c4d6:	f003 0301 	and.w	r3, r3, #1
 800c4da:	2b00      	cmp	r3, #0
 800c4dc:	d002      	beq.n	800c4e4 <homing_cycle+0x128>
                dual_motor_axis = idx;
 800c4de:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c4e0:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        }
    } while(idx);
 800c4e4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d1b3      	bne.n	800c452 <homing_cycle+0x96>

    if(max_travel == 0.0f)
 800c4ea:	f04f 0100 	mov.w	r1, #0
 800c4ee:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 800c4f0:	f7f4 fdf4 	bl	80010dc <__aeabi_fcmpeq>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	2b00      	cmp	r3, #0
 800c4f8:	d001      	beq.n	800c4fe <homing_cycle+0x142>
        return true;
 800c4fa:	2301      	movs	r3, #1
 800c4fc:	e2f3      	b.n	800cae6 <homing_cycle+0x72a>

    if((homing_rate = hal.homing.get_feedrate(cycle, HomingMode_Seek)) == 0.0f)
 800c4fe:	4b5b      	ldr	r3, [pc, #364]	; (800c66c <homing_cycle+0x2b0>)
 800c500:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c502:	2100      	movs	r1, #0
 800c504:	7938      	ldrb	r0, [r7, #4]
 800c506:	4798      	blx	r3
 800c508:	67b8      	str	r0, [r7, #120]	; 0x78
 800c50a:	f04f 0100 	mov.w	r1, #0
 800c50e:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 800c510:	f7f4 fde4 	bl	80010dc <__aeabi_fcmpeq>
 800c514:	4603      	mov	r3, r0
 800c516:	2b00      	cmp	r3, #0
 800c518:	d001      	beq.n	800c51e <homing_cycle+0x162>
        return false;
 800c51a:	2300      	movs	r3, #0
 800c51c:	e2e3      	b.n	800cae6 <homing_cycle+0x72a>

    if(auto_square.mask) {
 800c51e:	783b      	ldrb	r3, [r7, #0]
 800c520:	2b00      	cmp	r3, #0
 800c522:	d052      	beq.n	800c5ca <homing_cycle+0x20e>
        float fail_distance = (-settings.homing.dual_axis.fail_length_percent / 100.0f) * settings.axis[dual_motor_axis].max_travel;
 800c524:	4b4d      	ldr	r3, [pc, #308]	; (800c65c <homing_cycle+0x2a0>)
 800c526:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
 800c52a:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800c52e:	4950      	ldr	r1, [pc, #320]	; (800c670 <homing_cycle+0x2b4>)
 800c530:	4618      	mov	r0, r3
 800c532:	f7f4 fcf3 	bl	8000f1c <__aeabi_fdiv>
 800c536:	4603      	mov	r3, r0
 800c538:	4618      	mov	r0, r3
 800c53a:	4948      	ldr	r1, [pc, #288]	; (800c65c <homing_cycle+0x2a0>)
 800c53c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800c540:	4613      	mov	r3, r2
 800c542:	009b      	lsls	r3, r3, #2
 800c544:	4413      	add	r3, r2
 800c546:	009b      	lsls	r3, r3, #2
 800c548:	440b      	add	r3, r1
 800c54a:	333c      	adds	r3, #60	; 0x3c
 800c54c:	681b      	ldr	r3, [r3, #0]
 800c54e:	4619      	mov	r1, r3
 800c550:	f7f4 fc30 	bl	8000db4 <__aeabi_fmul>
 800c554:	4603      	mov	r3, r0
 800c556:	66fb      	str	r3, [r7, #108]	; 0x6c
        fail_distance = min(fail_distance, settings.homing.dual_axis.fail_distance_max);
 800c558:	4b40      	ldr	r3, [pc, #256]	; (800c65c <homing_cycle+0x2a0>)
 800c55a:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800c55e:	4619      	mov	r1, r3
 800c560:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800c562:	f7f4 fdc5 	bl	80010f0 <__aeabi_fcmplt>
 800c566:	4603      	mov	r3, r0
 800c568:	2b00      	cmp	r3, #0
 800c56a:	d001      	beq.n	800c570 <homing_cycle+0x1b4>
 800c56c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c56e:	e002      	b.n	800c576 <homing_cycle+0x1ba>
 800c570:	4b3a      	ldr	r3, [pc, #232]	; (800c65c <homing_cycle+0x2a0>)
 800c572:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 800c576:	66fb      	str	r3, [r7, #108]	; 0x6c
        fail_distance = max(fail_distance, settings.homing.dual_axis.fail_distance_min);
 800c578:	4b38      	ldr	r3, [pc, #224]	; (800c65c <homing_cycle+0x2a0>)
 800c57a:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800c57e:	4619      	mov	r1, r3
 800c580:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800c582:	f7f4 fdd3 	bl	800112c <__aeabi_fcmpgt>
 800c586:	4603      	mov	r3, r0
 800c588:	2b00      	cmp	r3, #0
 800c58a:	d001      	beq.n	800c590 <homing_cycle+0x1d4>
 800c58c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c58e:	e002      	b.n	800c596 <homing_cycle+0x1da>
 800c590:	4b32      	ldr	r3, [pc, #200]	; (800c65c <homing_cycle+0x2a0>)
 800c592:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 800c596:	66fb      	str	r3, [r7, #108]	; 0x6c
        autosquare_fail_distance = truncf(fail_distance * settings.axis[dual_motor_axis].steps_per_mm);
 800c598:	4930      	ldr	r1, [pc, #192]	; (800c65c <homing_cycle+0x2a0>)
 800c59a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800c59e:	4613      	mov	r3, r2
 800c5a0:	009b      	lsls	r3, r3, #2
 800c5a2:	4413      	add	r3, r2
 800c5a4:	009b      	lsls	r3, r3, #2
 800c5a6:	440b      	add	r3, r1
 800c5a8:	3330      	adds	r3, #48	; 0x30
 800c5aa:	681b      	ldr	r3, [r3, #0]
 800c5ac:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800c5ae:	4618      	mov	r0, r3
 800c5b0:	f7f4 fc00 	bl	8000db4 <__aeabi_fmul>
 800c5b4:	4603      	mov	r3, r0
 800c5b6:	4618      	mov	r0, r3
 800c5b8:	f018 fc1c 	bl	8024df4 <truncf>
 800c5bc:	4603      	mov	r3, r0
 800c5be:	4618      	mov	r0, r3
 800c5c0:	f7f4 fdd4 	bl	800116c <__aeabi_f2iz>
 800c5c4:	4603      	mov	r3, r0
 800c5c6:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

    // Set search mode with approach at seek rate to quickly engage the specified cycle.mask limit switches.
    do {

        // Initialize and declare variables needed for homing routine.
        system_convert_array_steps_to_mpos(target.values, sys.position);
 800c5ca:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800c5ce:	4929      	ldr	r1, [pc, #164]	; (800c674 <homing_cycle+0x2b8>)
 800c5d0:	4618      	mov	r0, r3
 800c5d2:	f015 fc1d 	bl	8021e10 <system_convert_array_steps_to_mpos>
        axislock = (axes_signals_t){0};
 800c5d6:	2300      	movs	r3, #0
 800c5d8:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
        n_active_axis = 0;
 800c5dc:	2300      	movs	r3, #0
 800c5de:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

        idx = N_AXIS;
 800c5e2:	2303      	movs	r3, #3
 800c5e4:	673b      	str	r3, [r7, #112]	; 0x70
        do {
            // Set target location for active axes and setup computation for homing rate.
            if (bit_istrue(cycle.mask, bit(--idx))) {
 800c5e6:	793b      	ldrb	r3, [r7, #4]
 800c5e8:	461a      	mov	r2, r3
 800c5ea:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c5ec:	3b01      	subs	r3, #1
 800c5ee:	673b      	str	r3, [r7, #112]	; 0x70
 800c5f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c5f2:	fa22 f303 	lsr.w	r3, r2, r3
 800c5f6:	f003 0301 	and.w	r3, r3, #1
 800c5fa:	2b00      	cmp	r3, #0
 800c5fc:	d050      	beq.n	800c6a0 <homing_cycle+0x2e4>
                n_active_axis++;
 800c5fe:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800c602:	3301      	adds	r3, #1
 800c604:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

#ifdef KINEMATICS_API
                kinematics.limits_set_target_pos(idx);
 800c608:	4b16      	ldr	r3, [pc, #88]	; (800c664 <homing_cycle+0x2a8>)
 800c60a:	691b      	ldr	r3, [r3, #16]
 800c60c:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800c60e:	4798      	blx	r3
#else
                sys.position[idx] = 0;
#endif
                // Set target direction based on cycle mask and homing cycle approach state.
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 800c610:	4b12      	ldr	r3, [pc, #72]	; (800c65c <homing_cycle+0x2a0>)
 800c612:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 800c616:	461a      	mov	r2, r3
 800c618:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c61a:	fa22 f303 	lsr.w	r3, r2, r3
 800c61e:	f003 0301 	and.w	r3, r3, #1
 800c622:	2b00      	cmp	r3, #0
 800c624:	d00f      	beq.n	800c646 <homing_cycle+0x28a>
                    target.values[idx] = mode == HomingMode_Pulloff ? max_travel : - max_travel;
 800c626:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c62a:	2b02      	cmp	r3, #2
 800c62c:	d003      	beq.n	800c636 <homing_cycle+0x27a>
 800c62e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c630:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
 800c634:	e000      	b.n	800c638 <homing_cycle+0x27c>
 800c636:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800c638:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c63a:	009b      	lsls	r3, r3, #2
 800c63c:	3398      	adds	r3, #152	; 0x98
 800c63e:	443b      	add	r3, r7
 800c640:	f843 2c58 	str.w	r2, [r3, #-88]
 800c644:	e01f      	b.n	800c686 <homing_cycle+0x2ca>
                else
                    target.values[idx] = mode == HomingMode_Pulloff ? - max_travel : max_travel;
 800c646:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c64a:	2b02      	cmp	r3, #2
 800c64c:	d114      	bne.n	800c678 <homing_cycle+0x2bc>
 800c64e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800c650:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
 800c654:	e011      	b.n	800c67a <homing_cycle+0x2be>
 800c656:	bf00      	nop
 800c658:	20000d3c 	.word	0x20000d3c
 800c65c:	2000147c 	.word	0x2000147c
 800c660:	20000bb0 	.word	0x20000bb0
 800c664:	20001088 	.word	0x20001088
 800c668:	bfc00000 	.word	0xbfc00000
 800c66c:	20000ed0 	.word	0x20000ed0
 800c670:	42c80000 	.word	0x42c80000
 800c674:	20000dc4 	.word	0x20000dc4
 800c678:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800c67a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c67c:	009b      	lsls	r3, r3, #2
 800c67e:	3398      	adds	r3, #152	; 0x98
 800c680:	443b      	add	r3, r7
 800c682:	f843 2c58 	str.w	r2, [r3, #-88]

                // Apply axislock to the step port pins active in this cycle.
                axislock.mask |= step_pin[idx];
 800c686:	f897 2054 	ldrb.w	r2, [r7, #84]	; 0x54
 800c68a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c68c:	009b      	lsls	r3, r3, #2
 800c68e:	3398      	adds	r3, #152	; 0x98
 800c690:	443b      	add	r3, r7
 800c692:	f853 3c40 	ldr.w	r3, [r3, #-64]
 800c696:	b2db      	uxtb	r3, r3
 800c698:	4313      	orrs	r3, r2
 800c69a:	b2db      	uxtb	r3, r3
 800c69c:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
            }
        } while(idx);
 800c6a0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c6a2:	2b00      	cmp	r3, #0
 800c6a4:	d19f      	bne.n	800c5e6 <homing_cycle+0x22a>

#ifdef KINEMATICS_API
        if(kinematics.homing_cycle_get_feedrate)
 800c6a6:	4bac      	ldr	r3, [pc, #688]	; (800c958 <homing_cycle+0x59c>)
 800c6a8:	69db      	ldr	r3, [r3, #28]
 800c6aa:	2b00      	cmp	r3, #0
 800c6ac:	d007      	beq.n	800c6be <homing_cycle+0x302>
            homing_rate = kinematics.homing_cycle_get_feedrate(cycle, homing_rate, mode);
 800c6ae:	4baa      	ldr	r3, [pc, #680]	; (800c958 <homing_cycle+0x59c>)
 800c6b0:	69db      	ldr	r3, [r3, #28]
 800c6b2:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800c6b6:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800c6b8:	7938      	ldrb	r0, [r7, #4]
 800c6ba:	4798      	blx	r3
 800c6bc:	67b8      	str	r0, [r7, #120]	; 0x78
#endif

        if(grbl.on_homing_rate_set)
 800c6be:	4ba7      	ldr	r3, [pc, #668]	; (800c95c <homing_cycle+0x5a0>)
 800c6c0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c6c4:	2b00      	cmp	r3, #0
 800c6c6:	d007      	beq.n	800c6d8 <homing_cycle+0x31c>
            grbl.on_homing_rate_set(cycle, homing_rate, mode);
 800c6c8:	4ba4      	ldr	r3, [pc, #656]	; (800c95c <homing_cycle+0x5a0>)
 800c6ca:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c6ce:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800c6d2:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800c6d4:	7938      	ldrb	r0, [r7, #4]
 800c6d6:	4798      	blx	r3

        homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 800c6d8:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800c6dc:	f7f4 fb12 	bl	8000d04 <__aeabi_ui2f>
 800c6e0:	4603      	mov	r3, r0
 800c6e2:	4618      	mov	r0, r3
 800c6e4:	f018 f98b 	bl	80249fe <sqrtf>
 800c6e8:	4603      	mov	r3, r0
 800c6ea:	4619      	mov	r1, r3
 800c6ec:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 800c6ee:	f7f4 fb61 	bl	8000db4 <__aeabi_fmul>
 800c6f2:	4603      	mov	r3, r0
 800c6f4:	67bb      	str	r3, [r7, #120]	; 0x78

        // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
        plan_data.feed_rate = homing_rate;      // Set current homing rate.
 800c6f6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800c6f8:	617b      	str	r3, [r7, #20]
        sys.homing_axis_lock.mask = axislock.mask;
 800c6fa:	f897 2054 	ldrb.w	r2, [r7, #84]	; 0x54
 800c6fe:	4b98      	ldr	r3, [pc, #608]	; (800c960 <homing_cycle+0x5a4>)
 800c700:	765a      	strb	r2, [r3, #25]

#ifdef KINEMATICS_API
        coord_data_t k_target;
        plan_buffer_line(kinematics.transform_from_cartesian(k_target.values, target.values), &plan_data);    // Bypass mc_line(). Directly plan homing motion.;
 800c702:	4b95      	ldr	r3, [pc, #596]	; (800c958 <homing_cycle+0x59c>)
 800c704:	685b      	ldr	r3, [r3, #4]
 800c706:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800c70a:	f107 0208 	add.w	r2, r7, #8
 800c70e:	4610      	mov	r0, r2
 800c710:	4798      	blx	r3
 800c712:	4602      	mov	r2, r0
 800c714:	f107 0314 	add.w	r3, r7, #20
 800c718:	4619      	mov	r1, r3
 800c71a:	4610      	mov	r0, r2
 800c71c:	f005 fa6c 	bl	8011bf8 <plan_buffer_line>
#else
        plan_buffer_line(target.values, &plan_data);    // Bypass mc_line(). Directly plan homing motion.
#endif

        sys.step_control.flags = 0;
 800c720:	4b8f      	ldr	r3, [pc, #572]	; (800c960 <homing_cycle+0x5a4>)
 800c722:	2200      	movs	r2, #0
 800c724:	761a      	strb	r2, [r3, #24]
        sys.step_control.execute_sys_motion = On; // Set to execute homing motion and clear existing flags.
 800c726:	4a8e      	ldr	r2, [pc, #568]	; (800c960 <homing_cycle+0x5a4>)
 800c728:	7e13      	ldrb	r3, [r2, #24]
 800c72a:	f043 0304 	orr.w	r3, r3, #4
 800c72e:	7613      	strb	r3, [r2, #24]
        st_prep_buffer();   // Prep and fill segment buffer from newly planned block.
 800c730:	f012 fdd6 	bl	801f2e0 <st_prep_buffer>
        st_wake_up();       // Initiate motion
 800c734:	f012 f9ae 	bl	801ea94 <st_wake_up>

        do {

            if (mode != HomingMode_Pulloff) {
 800c738:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c73c:	2b02      	cmp	r3, #2
 800c73e:	f000 80ac 	beq.w	800c89a <homing_cycle+0x4de>

                // Check homing switches state. Lock out cycle axes when they change.
                homing_state = homing_signals_select(signals_state = hal.homing.get_state(), auto_square, squaring_mode);
 800c742:	4b88      	ldr	r3, [pc, #544]	; (800c964 <homing_cycle+0x5a8>)
 800c744:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c746:	4798      	blx	r3
 800c748:	4603      	mov	r3, r0
 800c74a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 800c74e:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 800c752:	461a      	mov	r2, r3
 800c754:	7839      	ldrb	r1, [r7, #0]
 800c756:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800c758:	f7ff fc0f 	bl	800bf7a <homing_signals_select>
 800c75c:	4603      	mov	r3, r0
 800c75e:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50

                // Auto squaring check
                if((homing_state.mask & auto_square.mask) && squaring_mode == SquaringMode_Both) {
 800c762:	f897 2050 	ldrb.w	r2, [r7, #80]	; 0x50
 800c766:	783b      	ldrb	r3, [r7, #0]
 800c768:	4013      	ands	r3, r2
 800c76a:	b2db      	uxtb	r3, r3
 800c76c:	2b00      	cmp	r3, #0
 800c76e:	d03e      	beq.n	800c7ee <homing_cycle+0x432>
 800c770:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 800c774:	2b00      	cmp	r3, #0
 800c776:	d13a      	bne.n	800c7ee <homing_cycle+0x432>
                    if((autosquare_check = (signals_state.a.mask & auto_square.mask) != (signals_state.b.mask & auto_square.mask))) {
 800c778:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800c77c:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800c780:	4053      	eors	r3, r2
 800c782:	b2da      	uxtb	r2, r3
 800c784:	783b      	ldrb	r3, [r7, #0]
 800c786:	4013      	ands	r3, r2
 800c788:	b2db      	uxtb	r3, r3
 800c78a:	2b00      	cmp	r3, #0
 800c78c:	bf14      	ite	ne
 800c78e:	2301      	movne	r3, #1
 800c790:	2300      	moveq	r3, #0
 800c792:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
 800c796:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 800c79a:	2b00      	cmp	r3, #0
 800c79c:	d027      	beq.n	800c7ee <homing_cycle+0x432>
                        initial_trigger_position = sys.position[dual_motor_axis];
 800c79e:	4a70      	ldr	r2, [pc, #448]	; (800c960 <homing_cycle+0x5a4>)
 800c7a0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800c7a4:	3322      	adds	r3, #34	; 0x22
 800c7a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c7aa:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                        homing_state.mask &= ~auto_square.mask;
 800c7ae:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800c7b2:	b25a      	sxtb	r2, r3
 800c7b4:	783b      	ldrb	r3, [r7, #0]
 800c7b6:	b25b      	sxtb	r3, r3
 800c7b8:	43db      	mvns	r3, r3
 800c7ba:	b25b      	sxtb	r3, r3
 800c7bc:	4013      	ands	r3, r2
 800c7be:	b25b      	sxtb	r3, r3
 800c7c0:	b2db      	uxtb	r3, r3
 800c7c2:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
                        squaring_mode = (signals_state.a.mask & auto_square.mask) ? SquaringMode_A : SquaringMode_B;
 800c7c6:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 800c7ca:	783b      	ldrb	r3, [r7, #0]
 800c7cc:	4013      	ands	r3, r2
 800c7ce:	b2db      	uxtb	r3, r3
 800c7d0:	2b00      	cmp	r3, #0
 800c7d2:	d001      	beq.n	800c7d8 <homing_cycle+0x41c>
 800c7d4:	2301      	movs	r3, #1
 800c7d6:	e000      	b.n	800c7da <homing_cycle+0x41e>
 800c7d8:	2302      	movs	r3, #2
 800c7da:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
                        hal.stepper.disable_motors(auto_square, squaring_mode);
 800c7de:	4b61      	ldr	r3, [pc, #388]	; (800c964 <homing_cycle+0x5a8>)
 800c7e0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c7e4:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 800c7e8:	4611      	mov	r1, r2
 800c7ea:	7838      	ldrb	r0, [r7, #0]
 800c7ec:	4798      	blx	r3
                    }
                }

                idx = N_AXIS;
 800c7ee:	2303      	movs	r3, #3
 800c7f0:	673b      	str	r3, [r7, #112]	; 0x70
                do {
                    idx--;
 800c7f2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c7f4:	3b01      	subs	r3, #1
 800c7f6:	673b      	str	r3, [r7, #112]	; 0x70
                    if ((axislock.mask & step_pin[idx]) && (homing_state.mask & bit(idx))) {
 800c7f8:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 800c7fc:	461a      	mov	r2, r3
 800c7fe:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c800:	009b      	lsls	r3, r3, #2
 800c802:	3398      	adds	r3, #152	; 0x98
 800c804:	443b      	add	r3, r7
 800c806:	f853 3c40 	ldr.w	r3, [r3, #-64]
 800c80a:	4013      	ands	r3, r2
 800c80c:	2b00      	cmp	r3, #0
 800c80e:	d01e      	beq.n	800c84e <homing_cycle+0x492>
 800c810:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800c814:	461a      	mov	r2, r3
 800c816:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c818:	fa22 f303 	lsr.w	r3, r2, r3
 800c81c:	f003 0301 	and.w	r3, r3, #1
 800c820:	2b00      	cmp	r3, #0
 800c822:	d014      	beq.n	800c84e <homing_cycle+0x492>
#ifdef KINEMATICS_API
                        axislock.mask &= ~kinematics.limits_get_axis_mask(idx);
 800c824:	4b4c      	ldr	r3, [pc, #304]	; (800c958 <homing_cycle+0x59c>)
 800c826:	68db      	ldr	r3, [r3, #12]
 800c828:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800c82a:	4798      	blx	r3
 800c82c:	4603      	mov	r3, r0
 800c82e:	43db      	mvns	r3, r3
 800c830:	f897 2054 	ldrb.w	r2, [r7, #84]	; 0x54
 800c834:	b2db      	uxtb	r3, r3
 800c836:	4013      	ands	r3, r2
 800c838:	b2db      	uxtb	r3, r3
 800c83a:	f887 3054 	strb.w	r3, [r7, #84]	; 0x54
#else
                        axislock.mask &= ~bit(idx);
#endif
                        if(idx == dual_motor_axis)
 800c83e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800c840:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800c844:	429a      	cmp	r2, r3
 800c846:	d102      	bne.n	800c84e <homing_cycle+0x492>
                            autosquare_check = false;
 800c848:	2300      	movs	r3, #0
 800c84a:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
                    }
                } while(idx);
 800c84e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800c850:	2b00      	cmp	r3, #0
 800c852:	d1ce      	bne.n	800c7f2 <homing_cycle+0x436>

                sys.homing_axis_lock.mask = axislock.mask;
 800c854:	f897 2054 	ldrb.w	r2, [r7, #84]	; 0x54
 800c858:	4b41      	ldr	r3, [pc, #260]	; (800c960 <homing_cycle+0x5a4>)
 800c85a:	765a      	strb	r2, [r3, #25]

                if (autosquare_check && abs(initial_trigger_position - sys.position[dual_motor_axis]) > autosquare_fail_distance) {
 800c85c:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 800c860:	2b00      	cmp	r3, #0
 800c862:	d01a      	beq.n	800c89a <homing_cycle+0x4de>
 800c864:	4a3e      	ldr	r2, [pc, #248]	; (800c960 <homing_cycle+0x5a4>)
 800c866:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800c86a:	3322      	adds	r3, #34	; 0x22
 800c86c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c870:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800c874:	1ad3      	subs	r3, r2, r3
 800c876:	2b00      	cmp	r3, #0
 800c878:	bfb8      	it	lt
 800c87a:	425b      	neglt	r3, r3
 800c87c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 800c880:	429a      	cmp	r2, r3
 800c882:	da0a      	bge.n	800c89a <homing_cycle+0x4de>
                    system_set_exec_alarm(Alarm_HomingFailAutoSquaringApproach);
 800c884:	4b37      	ldr	r3, [pc, #220]	; (800c964 <homing_cycle+0x5a8>)
 800c886:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c888:	210f      	movs	r1, #15
 800c88a:	4837      	ldr	r0, [pc, #220]	; (800c968 <homing_cycle+0x5ac>)
 800c88c:	4798      	blx	r3
                    mc_reset();
 800c88e:	f002 ff2b 	bl	800f6e8 <mc_reset>
                    protocol_execute_realtime();
 800c892:	f006 fa65 	bl	8012d60 <protocol_execute_realtime>
                    return false;
 800c896:	2300      	movs	r3, #0
 800c898:	e125      	b.n	800cae6 <homing_cycle+0x72a>
                }
            }

            st_prep_buffer(); // Check and prep segment buffer.
 800c89a:	f012 fd21 	bl	801f2e0 <st_prep_buffer>

            // Exit routines: No time to run protocol_execute_realtime() in this loop.
            if (sys.rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 800c89e:	4b30      	ldr	r3, [pc, #192]	; (800c960 <homing_cycle+0x5a4>)
 800c8a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c8a2:	f003 0364 	and.w	r3, r3, #100	; 0x64
 800c8a6:	2b00      	cmp	r3, #0
 800c8a8:	d062      	beq.n	800c970 <homing_cycle+0x5b4>

                uint_fast16_t rt_exec = sys.rt_exec_state;
 800c8aa:	4b2d      	ldr	r3, [pc, #180]	; (800c960 <homing_cycle+0x5a4>)
 800c8ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c8ae:	66bb      	str	r3, [r7, #104]	; 0x68

                // Homing failure condition: Reset issued during cycle.
                if (rt_exec & EXEC_RESET)
 800c8b0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c8b2:	f003 0320 	and.w	r3, r3, #32
 800c8b6:	2b00      	cmp	r3, #0
 800c8b8:	d004      	beq.n	800c8c4 <homing_cycle+0x508>
                    system_set_exec_alarm(Alarm_HomingFailReset);
 800c8ba:	4b2a      	ldr	r3, [pc, #168]	; (800c964 <homing_cycle+0x5a8>)
 800c8bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c8be:	2106      	movs	r1, #6
 800c8c0:	4829      	ldr	r0, [pc, #164]	; (800c968 <homing_cycle+0x5ac>)
 800c8c2:	4798      	blx	r3

                // Homing failure condition: Safety door was opened.
                if (rt_exec & EXEC_SAFETY_DOOR)
 800c8c4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c8c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c8ca:	2b00      	cmp	r3, #0
 800c8cc:	d004      	beq.n	800c8d8 <homing_cycle+0x51c>
                    system_set_exec_alarm(Alarm_HomingFailDoor);
 800c8ce:	4b25      	ldr	r3, [pc, #148]	; (800c964 <homing_cycle+0x5a8>)
 800c8d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c8d2:	2107      	movs	r1, #7
 800c8d4:	4824      	ldr	r0, [pc, #144]	; (800c968 <homing_cycle+0x5ac>)
 800c8d6:	4798      	blx	r3

                hal.delay_ms(2, NULL);
 800c8d8:	4b22      	ldr	r3, [pc, #136]	; (800c964 <homing_cycle+0x5a8>)
 800c8da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c8dc:	2100      	movs	r1, #0
 800c8de:	2002      	movs	r0, #2
 800c8e0:	4798      	blx	r3

                // Homing failure condition: Homing switch(es) still engaged after pull-off motion
                if (mode == HomingMode_Pulloff && (homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask & cycle.mask))
 800c8e2:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c8e6:	2b02      	cmp	r3, #2
 800c8e8:	d117      	bne.n	800c91a <homing_cycle+0x55e>
 800c8ea:	4b1e      	ldr	r3, [pc, #120]	; (800c964 <homing_cycle+0x5a8>)
 800c8ec:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800c8ee:	4798      	blx	r3
 800c8f0:	4603      	mov	r3, r0
 800c8f2:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 800c8f6:	2300      	movs	r3, #0
 800c8f8:	2200      	movs	r2, #0
 800c8fa:	4619      	mov	r1, r3
 800c8fc:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800c8fe:	f7ff fb3c 	bl	800bf7a <homing_signals_select>
 800c902:	4603      	mov	r3, r0
 800c904:	b2da      	uxtb	r2, r3
 800c906:	793b      	ldrb	r3, [r7, #4]
 800c908:	4013      	ands	r3, r2
 800c90a:	b2db      	uxtb	r3, r3
 800c90c:	2b00      	cmp	r3, #0
 800c90e:	d004      	beq.n	800c91a <homing_cycle+0x55e>
                    system_set_exec_alarm(Alarm_FailPulloff);
 800c910:	4b14      	ldr	r3, [pc, #80]	; (800c964 <homing_cycle+0x5a8>)
 800c912:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c914:	2108      	movs	r1, #8
 800c916:	4814      	ldr	r0, [pc, #80]	; (800c968 <homing_cycle+0x5ac>)
 800c918:	4798      	blx	r3

                // Homing failure condition: Limit switch not found during approach.
                if (mode != HomingMode_Pulloff && (rt_exec & EXEC_CYCLE_COMPLETE))
 800c91a:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c91e:	2b02      	cmp	r3, #2
 800c920:	d009      	beq.n	800c936 <homing_cycle+0x57a>
 800c922:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c924:	f003 0304 	and.w	r3, r3, #4
 800c928:	2b00      	cmp	r3, #0
 800c92a:	d004      	beq.n	800c936 <homing_cycle+0x57a>
                    system_set_exec_alarm(Alarm_HomingFailApproach);
 800c92c:	4b0d      	ldr	r3, [pc, #52]	; (800c964 <homing_cycle+0x5a8>)
 800c92e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c930:	2109      	movs	r1, #9
 800c932:	480d      	ldr	r0, [pc, #52]	; (800c968 <homing_cycle+0x5ac>)
 800c934:	4798      	blx	r3

                if (sys.rt_exec_alarm) {
 800c936:	4b0a      	ldr	r3, [pc, #40]	; (800c960 <homing_cycle+0x5a4>)
 800c938:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800c93a:	2b00      	cmp	r3, #0
 800c93c:	d005      	beq.n	800c94a <homing_cycle+0x58e>
                    mc_reset(); // Stop motors, if they are running.
 800c93e:	f002 fed3 	bl	800f6e8 <mc_reset>
                    protocol_execute_realtime();
 800c942:	f006 fa0d 	bl	8012d60 <protocol_execute_realtime>
                    return false;
 800c946:	2300      	movs	r3, #0
 800c948:	e0cd      	b.n	800cae6 <homing_cycle+0x72a>
                } else {
                    // Pull-off motion complete. Disable CYCLE_STOP from executing.
                    system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
 800c94a:	4b06      	ldr	r3, [pc, #24]	; (800c964 <homing_cycle+0x5a8>)
 800c94c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c94e:	2104      	movs	r1, #4
 800c950:	4806      	ldr	r0, [pc, #24]	; (800c96c <homing_cycle+0x5b0>)
 800c952:	4798      	blx	r3
                    break;
 800c954:	e017      	b.n	800c986 <homing_cycle+0x5ca>
 800c956:	bf00      	nop
 800c958:	20001088 	.word	0x20001088
 800c95c:	20000dd4 	.word	0x20000dd4
 800c960:	20000d3c 	.word	0x20000d3c
 800c964:	20000ed0 	.word	0x20000ed0
 800c968:	20000d88 	.word	0x20000d88
 800c96c:	20000d84 	.word	0x20000d84
                }
            }

            grbl.on_execute_realtime(STATE_HOMING);
 800c970:	4b5f      	ldr	r3, [pc, #380]	; (800caf0 <homing_cycle+0x734>)
 800c972:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c974:	2004      	movs	r0, #4
 800c976:	4798      	blx	r3

        } while (axislock.mask & AXES_BITMASK);
 800c978:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 800c97c:	f003 0307 	and.w	r3, r3, #7
 800c980:	2b00      	cmp	r3, #0
 800c982:	f47f aed9 	bne.w	800c738 <homing_cycle+0x37c>

        st_reset(); // Immediately force kill steppers and reset step segment buffer.
 800c986:	f012 fb0f 	bl	801efa8 <st_reset>
        hal.delay_ms(settings.homing.debounce_delay, NULL); // Delay to allow transient dynamics to dissipate.
 800c98a:	4b5a      	ldr	r3, [pc, #360]	; (800caf4 <homing_cycle+0x738>)
 800c98c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c98e:	4a5a      	ldr	r2, [pc, #360]	; (800caf8 <homing_cycle+0x73c>)
 800c990:	f8b2 2112 	ldrh.w	r2, [r2, #274]	; 0x112
 800c994:	2100      	movs	r1, #0
 800c996:	4610      	mov	r0, r2
 800c998:	4798      	blx	r3

        // Reverse direction and reset homing rate for cycle(s).
        mode = mode == HomingMode_Pulloff ? HomingMode_Locate : HomingMode_Pulloff;
 800c99a:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c99e:	2b02      	cmp	r3, #2
 800c9a0:	d101      	bne.n	800c9a6 <homing_cycle+0x5ea>
 800c9a2:	2301      	movs	r3, #1
 800c9a4:	e000      	b.n	800c9a8 <homing_cycle+0x5ec>
 800c9a6:	2302      	movs	r3, #2
 800c9a8:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
        homing_rate = hal.homing.get_feedrate(cycle, mode);
 800c9ac:	4b51      	ldr	r3, [pc, #324]	; (800caf4 <homing_cycle+0x738>)
 800c9ae:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c9b0:	f897 2077 	ldrb.w	r2, [r7, #119]	; 0x77
 800c9b4:	4611      	mov	r1, r2
 800c9b6:	7938      	ldrb	r0, [r7, #4]
 800c9b8:	4798      	blx	r3
 800c9ba:	67b8      	str	r0, [r7, #120]	; 0x78

        // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
        if (mode == HomingMode_Locate) {
 800c9bc:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 800c9c0:	2b01      	cmp	r3, #1
 800c9c2:	d109      	bne.n	800c9d8 <homing_cycle+0x61c>
            // Only one initial pass for auto squared axis when both motors are active
            //if(mode == SquaringMode_Both && auto_square.mask)
            //    cycle.mask &= ~auto_square.mask;
            max_travel = settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR;
 800c9c4:	4b4c      	ldr	r3, [pc, #304]	; (800caf8 <homing_cycle+0x73c>)
 800c9c6:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800c9ca:	494c      	ldr	r1, [pc, #304]	; (800cafc <homing_cycle+0x740>)
 800c9cc:	4618      	mov	r0, r3
 800c9ce:	f7f4 f9f1 	bl	8000db4 <__aeabi_fmul>
 800c9d2:	4603      	mov	r3, r0
 800c9d4:	67fb      	str	r3, [r7, #124]	; 0x7c
 800c9d6:	e003      	b.n	800c9e0 <homing_cycle+0x624>
        } else
            max_travel = settings.homing.pulloff;
 800c9d8:	4b47      	ldr	r3, [pc, #284]	; (800caf8 <homing_cycle+0x73c>)
 800c9da:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800c9de:	67fb      	str	r3, [r7, #124]	; 0x7c

        if(auto_square.mask) {
 800c9e0:	783b      	ldrb	r3, [r7, #0]
 800c9e2:	2b00      	cmp	r3, #0
 800c9e4:	d00c      	beq.n	800ca00 <homing_cycle+0x644>
            autosquare_check = false;
 800c9e6:	2300      	movs	r3, #0
 800c9e8:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
            squaring_mode = SquaringMode_Both;
 800c9ec:	2300      	movs	r3, #0
 800c9ee:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
            hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 800c9f2:	4b40      	ldr	r3, [pc, #256]	; (800caf4 <homing_cycle+0x738>)
 800c9f4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800c9f8:	2200      	movs	r2, #0
 800c9fa:	2100      	movs	r1, #0
 800c9fc:	4610      	mov	r0, r2
 800c9fe:	4798      	blx	r3
        }

    } while (homing_rate > 0.0f && cycle.mask && n_cycle-- > 0);
 800ca00:	f04f 0100 	mov.w	r1, #0
 800ca04:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 800ca06:	f7f4 fb91 	bl	800112c <__aeabi_fcmpgt>
 800ca0a:	4603      	mov	r3, r0
 800ca0c:	2b00      	cmp	r3, #0
 800ca0e:	d00a      	beq.n	800ca26 <homing_cycle+0x66a>
 800ca10:	793b      	ldrb	r3, [r7, #4]
 800ca12:	2b00      	cmp	r3, #0
 800ca14:	d007      	beq.n	800ca26 <homing_cycle+0x66a>
 800ca16:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ca1a:	1e5a      	subs	r2, r3, #1
 800ca1c:	f8c7 208c 	str.w	r2, [r7, #140]	; 0x8c
 800ca20:	2b00      	cmp	r3, #0
 800ca22:	f47f add2 	bne.w	800c5ca <homing_cycle+0x20e>

    // Pull off B motor to compensate for switch inaccuracy when configured.
    if(auto_square.mask && settings.axis[dual_motor_axis].dual_axis_offset != 0.0f) {
 800ca26:	783b      	ldrb	r3, [r7, #0]
 800ca28:	2b00      	cmp	r3, #0
 800ca2a:	d04b      	beq.n	800cac4 <homing_cycle+0x708>
 800ca2c:	4932      	ldr	r1, [pc, #200]	; (800caf8 <homing_cycle+0x73c>)
 800ca2e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800ca32:	4613      	mov	r3, r2
 800ca34:	009b      	lsls	r3, r3, #2
 800ca36:	4413      	add	r3, r2
 800ca38:	009b      	lsls	r3, r3, #2
 800ca3a:	440b      	add	r3, r1
 800ca3c:	3340      	adds	r3, #64	; 0x40
 800ca3e:	681b      	ldr	r3, [r3, #0]
 800ca40:	f04f 0100 	mov.w	r1, #0
 800ca44:	4618      	mov	r0, r3
 800ca46:	f7f4 fb49 	bl	80010dc <__aeabi_fcmpeq>
 800ca4a:	4603      	mov	r3, r0
 800ca4c:	2b00      	cmp	r3, #0
 800ca4e:	d139      	bne.n	800cac4 <homing_cycle+0x708>
        hal.stepper.disable_motors(auto_square, settings.axis[dual_motor_axis].dual_axis_offset < 0.0f ? SquaringMode_B : SquaringMode_A);
 800ca50:	4b28      	ldr	r3, [pc, #160]	; (800caf4 <homing_cycle+0x738>)
 800ca52:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
 800ca56:	4928      	ldr	r1, [pc, #160]	; (800caf8 <homing_cycle+0x73c>)
 800ca58:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800ca5c:	4613      	mov	r3, r2
 800ca5e:	009b      	lsls	r3, r3, #2
 800ca60:	4413      	add	r3, r2
 800ca62:	009b      	lsls	r3, r3, #2
 800ca64:	440b      	add	r3, r1
 800ca66:	3340      	adds	r3, #64	; 0x40
 800ca68:	681b      	ldr	r3, [r3, #0]
 800ca6a:	f04f 0100 	mov.w	r1, #0
 800ca6e:	4618      	mov	r0, r3
 800ca70:	f7f4 fb3e 	bl	80010f0 <__aeabi_fcmplt>
 800ca74:	4603      	mov	r3, r0
 800ca76:	2b00      	cmp	r3, #0
 800ca78:	d001      	beq.n	800ca7e <homing_cycle+0x6c2>
 800ca7a:	2302      	movs	r3, #2
 800ca7c:	e000      	b.n	800ca80 <homing_cycle+0x6c4>
 800ca7e:	2301      	movs	r3, #1
 800ca80:	4619      	mov	r1, r3
 800ca82:	7838      	ldrb	r0, [r7, #0]
 800ca84:	47a0      	blx	r4
        if(!limits_pull_off(auto_square, fabs(settings.axis[dual_motor_axis].dual_axis_offset)))
 800ca86:	491c      	ldr	r1, [pc, #112]	; (800caf8 <homing_cycle+0x73c>)
 800ca88:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800ca8c:	4613      	mov	r3, r2
 800ca8e:	009b      	lsls	r3, r3, #2
 800ca90:	4413      	add	r3, r2
 800ca92:	009b      	lsls	r3, r3, #2
 800ca94:	440b      	add	r3, r1
 800ca96:	3340      	adds	r3, #64	; 0x40
 800ca98:	681b      	ldr	r3, [r3, #0]
 800ca9a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800ca9e:	4619      	mov	r1, r3
 800caa0:	7838      	ldrb	r0, [r7, #0]
 800caa2:	f7ff fb7d 	bl	800c1a0 <limits_pull_off>
 800caa6:	4603      	mov	r3, r0
 800caa8:	f083 0301 	eor.w	r3, r3, #1
 800caac:	b2db      	uxtb	r3, r3
 800caae:	2b00      	cmp	r3, #0
 800cab0:	d001      	beq.n	800cab6 <homing_cycle+0x6fa>
            return false;
 800cab2:	2300      	movs	r3, #0
 800cab4:	e017      	b.n	800cae6 <homing_cycle+0x72a>
        hal.stepper.disable_motors((axes_signals_t){0}, SquaringMode_Both);
 800cab6:	4b0f      	ldr	r3, [pc, #60]	; (800caf4 <homing_cycle+0x738>)
 800cab8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800cabc:	2200      	movs	r2, #0
 800cabe:	2100      	movs	r1, #0
 800cac0:	4610      	mov	r0, r2
 800cac2:	4798      	blx	r3
    // can be on either side of an axes, check and set axes machine zero appropriately. Also,
    // set up pull-off maneuver from axes limit switches that have been homed. This provides
    // some initial clearance off the switches and should also help prevent them from falsely
    // triggering when hard limits are enabled or when more than one axes shares a limit pin.
#ifdef KINEMATICS_API
    kinematics.limits_set_machine_positions(cycle);
 800cac4:	4b0e      	ldr	r3, [pc, #56]	; (800cb00 <homing_cycle+0x744>)
 800cac6:	695b      	ldr	r3, [r3, #20]
 800cac8:	7938      	ldrb	r0, [r7, #4]
 800caca:	4798      	blx	r3
#endif

#if ENABLE_BACKLASH_COMPENSATION
    mc_backlash_init(cycle);
#endif
    sys.step_control.flags = 0; // Return step control to normal operation.
 800cacc:	4b0d      	ldr	r3, [pc, #52]	; (800cb04 <homing_cycle+0x748>)
 800cace:	2200      	movs	r2, #0
 800cad0:	761a      	strb	r2, [r3, #24]
    sys.homed.mask |= cycle.mask;
 800cad2:	4b0c      	ldr	r3, [pc, #48]	; (800cb04 <homing_cycle+0x748>)
 800cad4:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 800cad8:	793b      	ldrb	r3, [r7, #4]
 800cada:	4313      	orrs	r3, r2
 800cadc:	b2da      	uxtb	r2, r3
 800cade:	4b09      	ldr	r3, [pc, #36]	; (800cb04 <homing_cycle+0x748>)
 800cae0:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    return true;
 800cae4:	2301      	movs	r3, #1
}
 800cae6:	4618      	mov	r0, r3
 800cae8:	379c      	adds	r7, #156	; 0x9c
 800caea:	46bd      	mov	sp, r7
 800caec:	bd90      	pop	{r4, r7, pc}
 800caee:	bf00      	nop
 800caf0:	20000dd4 	.word	0x20000dd4
 800caf4:	20000ed0 	.word	0x20000ed0
 800caf8:	2000147c 	.word	0x2000147c
 800cafc:	41200000 	.word	0x41200000
 800cb00:	20001088 	.word	0x20001088
 800cb04:	20000d3c 	.word	0x20000d3c

0800cb08 <limits_go_home>:

// Perform homing cycle(s) according to configuration.
// NOTE: only one auto squared axis can be homed at a time.
status_code_t limits_go_home (axes_signals_t cycle)
{
 800cb08:	b590      	push	{r4, r7, lr}
 800cb0a:	b087      	sub	sp, #28
 800cb0c:	af00      	add	r7, sp, #0
 800cb0e:	7138      	strb	r0, [r7, #4]
    axes_signals_t auto_square = {0}, auto_squared = {0};
 800cb10:	2300      	movs	r3, #0
 800cb12:	743b      	strb	r3, [r7, #16]
 800cb14:	2300      	movs	r3, #0
 800cb16:	733b      	strb	r3, [r7, #12]

    hal.limits.enable(settings.limits.flags.hard_enabled, cycle); // Disable hard limits pin change register for cycle duration
 800cb18:	4b3c      	ldr	r3, [pc, #240]	; (800cc0c <limits_go_home+0x104>)
 800cb1a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800cb1c:	4a3c      	ldr	r2, [pc, #240]	; (800cc10 <limits_go_home+0x108>)
 800cb1e:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 800cb22:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800cb26:	b2d2      	uxtb	r2, r2
 800cb28:	2a00      	cmp	r2, #0
 800cb2a:	bf14      	ite	ne
 800cb2c:	2201      	movne	r2, #1
 800cb2e:	2200      	moveq	r2, #0
 800cb30:	b2d2      	uxtb	r2, r2
 800cb32:	7939      	ldrb	r1, [r7, #4]
 800cb34:	4610      	mov	r0, r2
 800cb36:	4798      	blx	r3

    if(hal.stepper.get_ganged)
 800cb38:	4b34      	ldr	r3, [pc, #208]	; (800cc0c <limits_go_home+0x104>)
 800cb3a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800cb3e:	2b00      	cmp	r3, #0
 800cb40:	d006      	beq.n	800cb50 <limits_go_home+0x48>
        auto_squared = hal.stepper.get_ganged(true);
 800cb42:	4b32      	ldr	r3, [pc, #200]	; (800cc0c <limits_go_home+0x104>)
 800cb44:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800cb48:	2001      	movs	r0, #1
 800cb4a:	4798      	blx	r3
 800cb4c:	4603      	mov	r3, r0
 800cb4e:	733b      	strb	r3, [r7, #12]

    auto_squared.mask &= cycle.mask;
 800cb50:	7b3a      	ldrb	r2, [r7, #12]
 800cb52:	793b      	ldrb	r3, [r7, #4]
 800cb54:	4013      	ands	r3, r2
 800cb56:	b2db      	uxtb	r3, r3
 800cb58:	733b      	strb	r3, [r7, #12]

    if(auto_squared.mask) {
 800cb5a:	7b3b      	ldrb	r3, [r7, #12]
 800cb5c:	2b00      	cmp	r3, #0
 800cb5e:	d041      	beq.n	800cbe4 <limits_go_home+0xdc>

        if(!hal.stepper.disable_motors)
 800cb60:	4b2a      	ldr	r3, [pc, #168]	; (800cc0c <limits_go_home+0x104>)
 800cb62:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800cb66:	2b00      	cmp	r3, #0
 800cb68:	d101      	bne.n	800cb6e <limits_go_home+0x66>
            return Status_IllegalHomingConfiguration; // Bad driver! - should not happen.
 800cb6a:	2337      	movs	r3, #55	; 0x37
 800cb6c:	e049      	b.n	800cc02 <limits_go_home+0xfa>

        auto_square.x = On;
 800cb6e:	7c3b      	ldrb	r3, [r7, #16]
 800cb70:	f043 0301 	orr.w	r3, r3, #1
 800cb74:	743b      	strb	r3, [r7, #16]
        while(!(auto_squared.mask & auto_square.mask))
 800cb76:	e003      	b.n	800cb80 <limits_go_home+0x78>
            auto_square.mask <<= 1;
 800cb78:	7c3b      	ldrb	r3, [r7, #16]
 800cb7a:	005b      	lsls	r3, r3, #1
 800cb7c:	b2db      	uxtb	r3, r3
 800cb7e:	743b      	strb	r3, [r7, #16]
        while(!(auto_squared.mask & auto_square.mask))
 800cb80:	7b3a      	ldrb	r2, [r7, #12]
 800cb82:	7c3b      	ldrb	r3, [r7, #16]
 800cb84:	4013      	ands	r3, r2
 800cb86:	b2db      	uxtb	r3, r3
 800cb88:	2b00      	cmp	r3, #0
 800cb8a:	d0f5      	beq.n	800cb78 <limits_go_home+0x70>

        if(auto_squared.mask != auto_square.mask)
 800cb8c:	7b3a      	ldrb	r2, [r7, #12]
 800cb8e:	7c3b      	ldrb	r3, [r7, #16]
 800cb90:	429a      	cmp	r2, r3
 800cb92:	d001      	beq.n	800cb98 <limits_go_home+0x90>
            return Status_IllegalHomingConfiguration; // Attempt at squaring more than one auto squared axis at the same time.
 800cb94:	2337      	movs	r3, #55	; 0x37
 800cb96:	e034      	b.n	800cc02 <limits_go_home+0xfa>

        if((auto_squared.mask & homing_signals_select(hal.homing.get_state(), (axes_signals_t){0}, SquaringMode_Both).mask) && !limits_pull_off(auto_square, settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR))
 800cb98:	7b3c      	ldrb	r4, [r7, #12]
 800cb9a:	4b1c      	ldr	r3, [pc, #112]	; (800cc0c <limits_go_home+0x104>)
 800cb9c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cb9e:	4798      	blx	r3
 800cba0:	4603      	mov	r3, r0
 800cba2:	82bb      	strh	r3, [r7, #20]
 800cba4:	2300      	movs	r3, #0
 800cba6:	2200      	movs	r2, #0
 800cba8:	4619      	mov	r1, r3
 800cbaa:	6978      	ldr	r0, [r7, #20]
 800cbac:	f7ff f9e5 	bl	800bf7a <homing_signals_select>
 800cbb0:	4603      	mov	r3, r0
 800cbb2:	b2db      	uxtb	r3, r3
 800cbb4:	4023      	ands	r3, r4
 800cbb6:	b2db      	uxtb	r3, r3
 800cbb8:	2b00      	cmp	r3, #0
 800cbba:	d013      	beq.n	800cbe4 <limits_go_home+0xdc>
 800cbbc:	4b14      	ldr	r3, [pc, #80]	; (800cc10 <limits_go_home+0x108>)
 800cbbe:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 800cbc2:	4914      	ldr	r1, [pc, #80]	; (800cc14 <limits_go_home+0x10c>)
 800cbc4:	4618      	mov	r0, r3
 800cbc6:	f7f4 f8f5 	bl	8000db4 <__aeabi_fmul>
 800cbca:	4603      	mov	r3, r0
 800cbcc:	4619      	mov	r1, r3
 800cbce:	7c38      	ldrb	r0, [r7, #16]
 800cbd0:	f7ff fae6 	bl	800c1a0 <limits_pull_off>
 800cbd4:	4603      	mov	r3, r0
 800cbd6:	f083 0301 	eor.w	r3, r3, #1
 800cbda:	b2db      	uxtb	r3, r3
 800cbdc:	2b00      	cmp	r3, #0
 800cbde:	d001      	beq.n	800cbe4 <limits_go_home+0xdc>
            return Status_LimitsEngaged; // Auto squaring with limit switch asserted is not allowed.
 800cbe0:	232d      	movs	r3, #45	; 0x2d
 800cbe2:	e00e      	b.n	800cc02 <limits_go_home+0xfa>
    }

    tc_clear_tlo_reference(cycle);
 800cbe4:	7938      	ldrb	r0, [r7, #4]
 800cbe6:	f015 ffa1 	bl	8022b2c <tc_clear_tlo_reference>

    return grbl.home_machine(cycle, auto_square) ? Status_OK : Status_Unhandled;
 800cbea:	4b0b      	ldr	r3, [pc, #44]	; (800cc18 <limits_go_home+0x110>)
 800cbec:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 800cbf0:	7c39      	ldrb	r1, [r7, #16]
 800cbf2:	7938      	ldrb	r0, [r7, #4]
 800cbf4:	4798      	blx	r3
 800cbf6:	4603      	mov	r3, r0
 800cbf8:	2b00      	cmp	r3, #0
 800cbfa:	d001      	beq.n	800cc00 <limits_go_home+0xf8>
 800cbfc:	2300      	movs	r3, #0
 800cbfe:	e000      	b.n	800cc02 <limits_go_home+0xfa>
 800cc00:	2354      	movs	r3, #84	; 0x54
}
 800cc02:	4618      	mov	r0, r3
 800cc04:	371c      	adds	r7, #28
 800cc06:	46bd      	mov	sp, r7
 800cc08:	bd90      	pop	{r4, r7, pc}
 800cc0a:	bf00      	nop
 800cc0c:	20000ed0 	.word	0x20000ed0
 800cc10:	2000147c 	.word	0x2000147c
 800cc14:	41200000 	.word	0x41200000
 800cc18:	20000dd4 	.word	0x20000dd4

0800cc1c <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Also used by jogging to block travel outside soft-limit volume.
void limits_soft_check (float *target, planner_cond_t condition)
{
 800cc1c:	b580      	push	{r7, lr}
 800cc1e:	b082      	sub	sp, #8
 800cc20:	af00      	add	r7, sp, #0
 800cc22:	6078      	str	r0, [r7, #4]
 800cc24:	6039      	str	r1, [r7, #0]
#ifdef KINEMATICS_API
    if(condition.target_validated ? !condition.target_valid : !grbl.check_travel_limits(target, sys.soft_limits, false)) {
 800cc26:	787b      	ldrb	r3, [r7, #1]
 800cc28:	f003 0302 	and.w	r3, r3, #2
 800cc2c:	b2db      	uxtb	r3, r3
 800cc2e:	2b00      	cmp	r3, #0
 800cc30:	d009      	beq.n	800cc46 <limits_soft_check+0x2a>
 800cc32:	787b      	ldrb	r3, [r7, #1]
 800cc34:	f003 0301 	and.w	r3, r3, #1
 800cc38:	b2db      	uxtb	r3, r3
 800cc3a:	2b00      	cmp	r3, #0
 800cc3c:	bf0c      	ite	eq
 800cc3e:	2301      	moveq	r3, #1
 800cc40:	2300      	movne	r3, #0
 800cc42:	b2db      	uxtb	r3, r3
 800cc44:	e00c      	b.n	800cc60 <limits_soft_check+0x44>
 800cc46:	4b1c      	ldr	r3, [pc, #112]	; (800ccb8 <limits_soft_check+0x9c>)
 800cc48:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800cc4c:	491b      	ldr	r1, [pc, #108]	; (800ccbc <limits_soft_check+0xa0>)
 800cc4e:	2200      	movs	r2, #0
 800cc50:	f891 1095 	ldrb.w	r1, [r1, #149]	; 0x95
 800cc54:	6878      	ldr	r0, [r7, #4]
 800cc56:	4798      	blx	r3
 800cc58:	4603      	mov	r3, r0
 800cc5a:	f083 0301 	eor.w	r3, r3, #1
 800cc5e:	b2db      	uxtb	r3, r3
 800cc60:	2b00      	cmp	r3, #0
 800cc62:	d026      	beq.n	800ccb2 <limits_soft_check+0x96>
#else
    if(condition.target_validated ? !condition.target_valid : !grbl.check_travel_limits(target, sys.soft_limits, true)) {
#endif

        sys.flags.soft_limit = On;
 800cc64:	4a15      	ldr	r2, [pc, #84]	; (800ccbc <limits_soft_check+0xa0>)
 800cc66:	7d93      	ldrb	r3, [r2, #22]
 800cc68:	f043 0304 	orr.w	r3, r3, #4
 800cc6c:	7593      	strb	r3, [r2, #22]
        // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
        // workspace volume so just come to a controlled stop so position is not lost. When complete
        // enter alarm mode.
        if(state_get() == STATE_CYCLE) {
 800cc6e:	f010 fe27 	bl	801d8c0 <state_get>
 800cc72:	4603      	mov	r3, r0
 800cc74:	2b08      	cmp	r3, #8
 800cc76:	d111      	bne.n	800cc9c <limits_soft_check+0x80>
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 800cc78:	4b11      	ldr	r3, [pc, #68]	; (800ccc0 <limits_soft_check+0xa4>)
 800cc7a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cc7c:	2108      	movs	r1, #8
 800cc7e:	4811      	ldr	r0, [pc, #68]	; (800ccc4 <limits_soft_check+0xa8>)
 800cc80:	4798      	blx	r3
            do {
                if(!protocol_execute_realtime())
 800cc82:	f006 f86d 	bl	8012d60 <protocol_execute_realtime>
 800cc86:	4603      	mov	r3, r0
 800cc88:	f083 0301 	eor.w	r3, r3, #1
 800cc8c:	b2db      	uxtb	r3, r3
 800cc8e:	2b00      	cmp	r3, #0
 800cc90:	d10e      	bne.n	800ccb0 <limits_soft_check+0x94>
                    return; // aborted!
            } while(state_get() != STATE_IDLE);
 800cc92:	f010 fe15 	bl	801d8c0 <state_get>
 800cc96:	4603      	mov	r3, r0
 800cc98:	2b00      	cmp	r3, #0
 800cc9a:	d1f2      	bne.n	800cc82 <limits_soft_check+0x66>
        }
        mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 800cc9c:	f002 fd24 	bl	800f6e8 <mc_reset>
        system_set_exec_alarm(Alarm_SoftLimit); // Indicate soft limit critical event
 800cca0:	4b07      	ldr	r3, [pc, #28]	; (800ccc0 <limits_soft_check+0xa4>)
 800cca2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800cca4:	2102      	movs	r1, #2
 800cca6:	4808      	ldr	r0, [pc, #32]	; (800ccc8 <limits_soft_check+0xac>)
 800cca8:	4798      	blx	r3
        protocol_execute_realtime(); // Execute to enter critical event loop and system abort
 800ccaa:	f006 f859 	bl	8012d60 <protocol_execute_realtime>
 800ccae:	e000      	b.n	800ccb2 <limits_soft_check+0x96>
                    return; // aborted!
 800ccb0:	bf00      	nop
    }
}
 800ccb2:	3708      	adds	r7, #8
 800ccb4:	46bd      	mov	sp, r7
 800ccb6:	bd80      	pop	{r7, pc}
 800ccb8:	20000dd4 	.word	0x20000dd4
 800ccbc:	20000d3c 	.word	0x20000d3c
 800ccc0:	20000ed0 	.word	0x20000ed0
 800ccc4:	20000d84 	.word	0x20000d84
 800ccc8:	20000d88 	.word	0x20000d88

0800cccc <limits_set_homing_axes>:

// Set axes to be homed from settings.
void limits_set_homing_axes (void)
{
 800cccc:	b480      	push	{r7}
 800ccce:	b083      	sub	sp, #12
 800ccd0:	af00      	add	r7, sp, #0
    uint_fast8_t idx = N_AXIS;
 800ccd2:	2303      	movs	r3, #3
 800ccd4:	607b      	str	r3, [r7, #4]

    sys.homing.mask = 0;
 800ccd6:	4b12      	ldr	r3, [pc, #72]	; (800cd20 <limits_set_homing_axes+0x54>)
 800ccd8:	2200      	movs	r2, #0
 800ccda:	769a      	strb	r2, [r3, #26]

    do {
        sys.homing.mask |= settings.homing.cycle[--idx].mask;
 800ccdc:	687b      	ldr	r3, [r7, #4]
 800ccde:	3b01      	subs	r3, #1
 800cce0:	607b      	str	r3, [r7, #4]
 800cce2:	4a10      	ldr	r2, [pc, #64]	; (800cd24 <limits_set_homing_axes+0x58>)
 800cce4:	687b      	ldr	r3, [r7, #4]
 800cce6:	4413      	add	r3, r2
 800cce8:	f203 1315 	addw	r3, r3, #277	; 0x115
 800ccec:	781a      	ldrb	r2, [r3, #0]
 800ccee:	4b0c      	ldr	r3, [pc, #48]	; (800cd20 <limits_set_homing_axes+0x54>)
 800ccf0:	7e9b      	ldrb	r3, [r3, #26]
 800ccf2:	4313      	orrs	r3, r2
 800ccf4:	b2da      	uxtb	r2, r3
 800ccf6:	4b0a      	ldr	r3, [pc, #40]	; (800cd20 <limits_set_homing_axes+0x54>)
 800ccf8:	769a      	strb	r2, [r3, #26]
    } while(idx);
 800ccfa:	687b      	ldr	r3, [r7, #4]
 800ccfc:	2b00      	cmp	r3, #0
 800ccfe:	d1ed      	bne.n	800ccdc <limits_set_homing_axes+0x10>

    sys.homed.mask &= sys.homing.mask;
 800cd00:	4b07      	ldr	r3, [pc, #28]	; (800cd20 <limits_set_homing_axes+0x54>)
 800cd02:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 800cd06:	4b06      	ldr	r3, [pc, #24]	; (800cd20 <limits_set_homing_axes+0x54>)
 800cd08:	7e9b      	ldrb	r3, [r3, #26]
 800cd0a:	4013      	ands	r3, r2
 800cd0c:	b2da      	uxtb	r2, r3
 800cd0e:	4b04      	ldr	r3, [pc, #16]	; (800cd20 <limits_set_homing_axes+0x54>)
 800cd10:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
}
 800cd14:	bf00      	nop
 800cd16:	370c      	adds	r7, #12
 800cd18:	46bd      	mov	sp, r7
 800cd1a:	bc80      	pop	{r7}
 800cd1c:	4770      	bx	lr
 800cd1e:	bf00      	nop
 800cd20:	20000d3c 	.word	0x20000d3c
 800cd24:	2000147c 	.word	0x2000147c

0800cd28 <limits_homing_required>:

// Check if homing is required.
bool limits_homing_required (void)
{
 800cd28:	b480      	push	{r7}
 800cd2a:	af00      	add	r7, sp, #0
    return settings.homing.flags.enabled && settings.homing.flags.init_lock &&
 800cd2c:	4b1a      	ldr	r3, [pc, #104]	; (800cd98 <limits_homing_required+0x70>)
 800cd2e:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800cd32:	f003 0301 	and.w	r3, r3, #1
 800cd36:	b2db      	uxtb	r3, r3
            (sys.cold_start || !settings.homing.flags.override_locks) &&
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 800cd38:	2b00      	cmp	r3, #0
 800cd3a:	d025      	beq.n	800cd88 <limits_homing_required+0x60>
    return settings.homing.flags.enabled && settings.homing.flags.init_lock &&
 800cd3c:	4b16      	ldr	r3, [pc, #88]	; (800cd98 <limits_homing_required+0x70>)
 800cd3e:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800cd42:	f003 0304 	and.w	r3, r3, #4
 800cd46:	b2db      	uxtb	r3, r3
 800cd48:	2b00      	cmp	r3, #0
 800cd4a:	d01d      	beq.n	800cd88 <limits_homing_required+0x60>
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 800cd4c:	4b13      	ldr	r3, [pc, #76]	; (800cd9c <limits_homing_required+0x74>)
 800cd4e:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
    return settings.homing.flags.enabled && settings.homing.flags.init_lock &&
 800cd52:	2b00      	cmp	r3, #0
 800cd54:	d107      	bne.n	800cd66 <limits_homing_required+0x3e>
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 800cd56:	4b10      	ldr	r3, [pc, #64]	; (800cd98 <limits_homing_required+0x70>)
 800cd58:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800cd5c:	f003 0320 	and.w	r3, r3, #32
 800cd60:	b2db      	uxtb	r3, r3
 800cd62:	2b00      	cmp	r3, #0
 800cd64:	d110      	bne.n	800cd88 <limits_homing_required+0x60>
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 800cd66:	4b0d      	ldr	r3, [pc, #52]	; (800cd9c <limits_homing_required+0x74>)
 800cd68:	7e9b      	ldrb	r3, [r3, #26]
            (sys.cold_start || !settings.homing.flags.override_locks) &&
 800cd6a:	2b00      	cmp	r3, #0
 800cd6c:	d00c      	beq.n	800cd88 <limits_homing_required+0x60>
              sys.homing.mask && (sys.homing.mask & sys.homed.mask) != sys.homing.mask;
 800cd6e:	4b0b      	ldr	r3, [pc, #44]	; (800cd9c <limits_homing_required+0x74>)
 800cd70:	7e9a      	ldrb	r2, [r3, #26]
 800cd72:	4b0a      	ldr	r3, [pc, #40]	; (800cd9c <limits_homing_required+0x74>)
 800cd74:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800cd78:	4013      	ands	r3, r2
 800cd7a:	b2da      	uxtb	r2, r3
 800cd7c:	4b07      	ldr	r3, [pc, #28]	; (800cd9c <limits_homing_required+0x74>)
 800cd7e:	7e9b      	ldrb	r3, [r3, #26]
 800cd80:	429a      	cmp	r2, r3
 800cd82:	d001      	beq.n	800cd88 <limits_homing_required+0x60>
 800cd84:	2301      	movs	r3, #1
 800cd86:	e000      	b.n	800cd8a <limits_homing_required+0x62>
 800cd88:	2300      	movs	r3, #0
 800cd8a:	f003 0301 	and.w	r3, r3, #1
 800cd8e:	b2db      	uxtb	r3, r3
}
 800cd90:	4618      	mov	r0, r3
 800cd92:	46bd      	mov	sp, r7
 800cd94:	bc80      	pop	{r7}
 800cd96:	4770      	bx	lr
 800cd98:	2000147c 	.word	0x2000147c
 800cd9c:	20000d3c 	.word	0x20000d3c

0800cda0 <get_homing_rate>:

static float get_homing_rate (axes_signals_t cycle, homing_mode_t mode)
{
 800cda0:	b480      	push	{r7}
 800cda2:	b083      	sub	sp, #12
 800cda4:	af00      	add	r7, sp, #0
 800cda6:	7138      	strb	r0, [r7, #4]
 800cda8:	460b      	mov	r3, r1
 800cdaa:	71fb      	strb	r3, [r7, #7]
    return mode == HomingMode_Locate ? settings.homing.feed_rate : settings.homing.seek_rate;
 800cdac:	79fb      	ldrb	r3, [r7, #7]
 800cdae:	2b01      	cmp	r3, #1
 800cdb0:	d103      	bne.n	800cdba <get_homing_rate+0x1a>
 800cdb2:	4b06      	ldr	r3, [pc, #24]	; (800cdcc <get_homing_rate+0x2c>)
 800cdb4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800cdb8:	e002      	b.n	800cdc0 <get_homing_rate+0x20>
 800cdba:	4b04      	ldr	r3, [pc, #16]	; (800cdcc <get_homing_rate+0x2c>)
 800cdbc:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
}
 800cdc0:	4618      	mov	r0, r3
 800cdc2:	370c      	adds	r7, #12
 800cdc4:	46bd      	mov	sp, r7
 800cdc6:	bc80      	pop	{r7}
 800cdc8:	4770      	bx	lr
 800cdca:	bf00      	nop
 800cdcc:	2000147c 	.word	0x2000147c

0800cdd0 <check_travel_limits>:

// Checks and reports if target array exceeds machine travel limits. Returns false if check failed.
static bool check_travel_limits (float *target, axes_signals_t axes, bool is_cartesian)
{
 800cdd0:	b580      	push	{r7, lr}
 800cdd2:	b084      	sub	sp, #16
 800cdd4:	af00      	add	r7, sp, #0
 800cdd6:	6078      	str	r0, [r7, #4]
 800cdd8:	7039      	strb	r1, [r7, #0]
 800cdda:	4613      	mov	r3, r2
 800cddc:	70fb      	strb	r3, [r7, #3]
    bool failed = false;
 800cdde:	2300      	movs	r3, #0
 800cde0:	73fb      	strb	r3, [r7, #15]
    uint_fast8_t idx = N_AXIS;
 800cde2:	2303      	movs	r3, #3
 800cde4:	60bb      	str	r3, [r7, #8]

    if(is_cartesian && (sys.homed.mask & axes.mask)) do {
 800cde6:	78fb      	ldrb	r3, [r7, #3]
 800cde8:	2b00      	cmp	r3, #0
 800cdea:	d053      	beq.n	800ce94 <check_travel_limits+0xc4>
 800cdec:	4b33      	ldr	r3, [pc, #204]	; (800cebc <check_travel_limits+0xec>)
 800cdee:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 800cdf2:	783b      	ldrb	r3, [r7, #0]
 800cdf4:	4013      	ands	r3, r2
 800cdf6:	b2db      	uxtb	r3, r3
 800cdf8:	2b00      	cmp	r3, #0
 800cdfa:	d04b      	beq.n	800ce94 <check_travel_limits+0xc4>
        idx--;
 800cdfc:	68bb      	ldr	r3, [r7, #8]
 800cdfe:	3b01      	subs	r3, #1
 800ce00:	60bb      	str	r3, [r7, #8]
        if(bit_istrue(sys.homed.mask, bit(idx)) && bit_istrue(axes.mask, bit(idx)))
 800ce02:	4b2e      	ldr	r3, [pc, #184]	; (800cebc <check_travel_limits+0xec>)
 800ce04:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800ce08:	461a      	mov	r2, r3
 800ce0a:	68bb      	ldr	r3, [r7, #8]
 800ce0c:	fa22 f303 	lsr.w	r3, r2, r3
 800ce10:	f003 0301 	and.w	r3, r3, #1
 800ce14:	2b00      	cmp	r3, #0
 800ce16:	d034      	beq.n	800ce82 <check_travel_limits+0xb2>
 800ce18:	783b      	ldrb	r3, [r7, #0]
 800ce1a:	461a      	mov	r2, r3
 800ce1c:	68bb      	ldr	r3, [r7, #8]
 800ce1e:	fa22 f303 	lsr.w	r3, r2, r3
 800ce22:	f003 0301 	and.w	r3, r3, #1
 800ce26:	2b00      	cmp	r3, #0
 800ce28:	d02b      	beq.n	800ce82 <check_travel_limits+0xb2>
            failed = target[idx] < sys.work_envelope.min.values[idx] || target[idx] > sys.work_envelope.max.values[idx];
 800ce2a:	68bb      	ldr	r3, [r7, #8]
 800ce2c:	009b      	lsls	r3, r3, #2
 800ce2e:	687a      	ldr	r2, [r7, #4]
 800ce30:	4413      	add	r3, r2
 800ce32:	681a      	ldr	r2, [r3, #0]
 800ce34:	4921      	ldr	r1, [pc, #132]	; (800cebc <check_travel_limits+0xec>)
 800ce36:	68bb      	ldr	r3, [r7, #8]
 800ce38:	3318      	adds	r3, #24
 800ce3a:	009b      	lsls	r3, r3, #2
 800ce3c:	440b      	add	r3, r1
 800ce3e:	685b      	ldr	r3, [r3, #4]
 800ce40:	4619      	mov	r1, r3
 800ce42:	4610      	mov	r0, r2
 800ce44:	f7f4 f954 	bl	80010f0 <__aeabi_fcmplt>
 800ce48:	4603      	mov	r3, r0
 800ce4a:	2b00      	cmp	r3, #0
 800ce4c:	d111      	bne.n	800ce72 <check_travel_limits+0xa2>
 800ce4e:	68bb      	ldr	r3, [r7, #8]
 800ce50:	009b      	lsls	r3, r3, #2
 800ce52:	687a      	ldr	r2, [r7, #4]
 800ce54:	4413      	add	r3, r2
 800ce56:	681a      	ldr	r2, [r3, #0]
 800ce58:	4918      	ldr	r1, [pc, #96]	; (800cebc <check_travel_limits+0xec>)
 800ce5a:	68bb      	ldr	r3, [r7, #8]
 800ce5c:	331a      	adds	r3, #26
 800ce5e:	009b      	lsls	r3, r3, #2
 800ce60:	440b      	add	r3, r1
 800ce62:	689b      	ldr	r3, [r3, #8]
 800ce64:	4619      	mov	r1, r3
 800ce66:	4610      	mov	r0, r2
 800ce68:	f7f4 f960 	bl	800112c <__aeabi_fcmpgt>
 800ce6c:	4603      	mov	r3, r0
 800ce6e:	2b00      	cmp	r3, #0
 800ce70:	d001      	beq.n	800ce76 <check_travel_limits+0xa6>
 800ce72:	2301      	movs	r3, #1
 800ce74:	e000      	b.n	800ce78 <check_travel_limits+0xa8>
 800ce76:	2300      	movs	r3, #0
 800ce78:	73fb      	strb	r3, [r7, #15]
 800ce7a:	7bfb      	ldrb	r3, [r7, #15]
 800ce7c:	f003 0301 	and.w	r3, r3, #1
 800ce80:	73fb      	strb	r3, [r7, #15]
    } while(!failed && idx);
 800ce82:	7bfb      	ldrb	r3, [r7, #15]
 800ce84:	f083 0301 	eor.w	r3, r3, #1
 800ce88:	b2db      	uxtb	r3, r3
 800ce8a:	2b00      	cmp	r3, #0
 800ce8c:	d002      	beq.n	800ce94 <check_travel_limits+0xc4>
 800ce8e:	68bb      	ldr	r3, [r7, #8]
 800ce90:	2b00      	cmp	r3, #0
 800ce92:	d1b3      	bne.n	800cdfc <check_travel_limits+0x2c>

    return is_cartesian && !failed;
 800ce94:	78fb      	ldrb	r3, [r7, #3]
 800ce96:	2b00      	cmp	r3, #0
 800ce98:	d007      	beq.n	800ceaa <check_travel_limits+0xda>
 800ce9a:	7bfb      	ldrb	r3, [r7, #15]
 800ce9c:	f083 0301 	eor.w	r3, r3, #1
 800cea0:	b2db      	uxtb	r3, r3
 800cea2:	2b00      	cmp	r3, #0
 800cea4:	d001      	beq.n	800ceaa <check_travel_limits+0xda>
 800cea6:	2301      	movs	r3, #1
 800cea8:	e000      	b.n	800ceac <check_travel_limits+0xdc>
 800ceaa:	2300      	movs	r3, #0
 800ceac:	f003 0301 	and.w	r3, r3, #1
 800ceb0:	b2db      	uxtb	r3, r3
}
 800ceb2:	4618      	mov	r0, r3
 800ceb4:	3710      	adds	r7, #16
 800ceb6:	46bd      	mov	sp, r7
 800ceb8:	bd80      	pop	{r7, pc}
 800ceba:	bf00      	nop
 800cebc:	20000d3c 	.word	0x20000d3c

0800cec0 <check_arc_travel_limits>:

// Checks and reports if the arc exceeds machine travel limits. Returns false if check failed.
// NOTE: needs the work envelope to be a cuboid!
static bool check_arc_travel_limits (coord_data_t *target, coord_data_t *position, point_2d_t center, float radius, plane_t plane, int32_t turns)
{
 800cec0:	b580      	push	{r7, lr}
 800cec2:	b090      	sub	sp, #64	; 0x40
 800cec4:	af00      	add	r7, sp, #0
 800cec6:	60f8      	str	r0, [r7, #12]
 800cec8:	60b9      	str	r1, [r7, #8]
 800ceca:	4639      	mov	r1, r7
 800cecc:	e881 000c 	stmia.w	r1, {r2, r3}
        };
    } arc_x_t;

    static const axes_signals_t xyz = { .x = On, .y = On, .z = On };

    if((sys.soft_limits.mask & xyz.mask) == 0)
 800ced0:	4ba6      	ldr	r3, [pc, #664]	; (800d16c <check_arc_travel_limits+0x2ac>)
 800ced2:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 800ced6:	4ba6      	ldr	r3, [pc, #664]	; (800d170 <check_arc_travel_limits+0x2b0>)
 800ced8:	781b      	ldrb	r3, [r3, #0]
 800ceda:	4013      	ands	r3, r2
 800cedc:	b2db      	uxtb	r3, r3
 800cede:	2b00      	cmp	r3, #0
 800cee0:	d10a      	bne.n	800cef8 <check_arc_travel_limits+0x38>
        return grbl.check_travel_limits(target->values, sys.soft_limits, true);
 800cee2:	4ba4      	ldr	r3, [pc, #656]	; (800d174 <check_arc_travel_limits+0x2b4>)
 800cee4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800cee8:	68f8      	ldr	r0, [r7, #12]
 800ceea:	49a0      	ldr	r1, [pc, #640]	; (800d16c <check_arc_travel_limits+0x2ac>)
 800ceec:	2201      	movs	r2, #1
 800ceee:	f891 1095 	ldrb.w	r1, [r1, #149]	; 0x95
 800cef2:	4798      	blx	r3
 800cef4:	4603      	mov	r3, r0
 800cef6:	e266      	b.n	800d3c6 <check_arc_travel_limits+0x506>

    arc_x_t x = {0};
 800cef8:	2300      	movs	r3, #0
 800cefa:	63fb      	str	r3, [r7, #60]	; 0x3c
    point_2d_t start, end;

    // Set arc start and end points centered at 0,0 and convert CW arcs to CCW.
    if(turns > 0) { // CCW
 800cefc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cefe:	2b00      	cmp	r3, #0
 800cf00:	dd34      	ble.n	800cf6c <check_arc_travel_limits+0xac>
        start.x = position->values[plane.axis_0] - center.x;
 800cf02:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800cf06:	461a      	mov	r2, r3
 800cf08:	68bb      	ldr	r3, [r7, #8]
 800cf0a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf0e:	683a      	ldr	r2, [r7, #0]
 800cf10:	4611      	mov	r1, r2
 800cf12:	4618      	mov	r0, r3
 800cf14:	f7f3 fe44 	bl	8000ba0 <__aeabi_fsub>
 800cf18:	4603      	mov	r3, r0
 800cf1a:	637b      	str	r3, [r7, #52]	; 0x34
        start.y = position->values[plane.axis_1] - center.y;
 800cf1c:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800cf20:	461a      	mov	r2, r3
 800cf22:	68bb      	ldr	r3, [r7, #8]
 800cf24:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf28:	687a      	ldr	r2, [r7, #4]
 800cf2a:	4611      	mov	r1, r2
 800cf2c:	4618      	mov	r0, r3
 800cf2e:	f7f3 fe37 	bl	8000ba0 <__aeabi_fsub>
 800cf32:	4603      	mov	r3, r0
 800cf34:	63bb      	str	r3, [r7, #56]	; 0x38
        end.x = target->values[plane.axis_0] - center.x;
 800cf36:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800cf3a:	461a      	mov	r2, r3
 800cf3c:	68fb      	ldr	r3, [r7, #12]
 800cf3e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf42:	683a      	ldr	r2, [r7, #0]
 800cf44:	4611      	mov	r1, r2
 800cf46:	4618      	mov	r0, r3
 800cf48:	f7f3 fe2a 	bl	8000ba0 <__aeabi_fsub>
 800cf4c:	4603      	mov	r3, r0
 800cf4e:	62fb      	str	r3, [r7, #44]	; 0x2c
        end.y = target->values[plane.axis_1] - center.y;
 800cf50:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800cf54:	461a      	mov	r2, r3
 800cf56:	68fb      	ldr	r3, [r7, #12]
 800cf58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf5c:	687a      	ldr	r2, [r7, #4]
 800cf5e:	4611      	mov	r1, r2
 800cf60:	4618      	mov	r0, r3
 800cf62:	f7f3 fe1d 	bl	8000ba0 <__aeabi_fsub>
 800cf66:	4603      	mov	r3, r0
 800cf68:	633b      	str	r3, [r7, #48]	; 0x30
 800cf6a:	e033      	b.n	800cfd4 <check_arc_travel_limits+0x114>
    } else { // CW
        start.x = target->values[plane.axis_0] - center.x;
 800cf6c:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800cf70:	461a      	mov	r2, r3
 800cf72:	68fb      	ldr	r3, [r7, #12]
 800cf74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf78:	683a      	ldr	r2, [r7, #0]
 800cf7a:	4611      	mov	r1, r2
 800cf7c:	4618      	mov	r0, r3
 800cf7e:	f7f3 fe0f 	bl	8000ba0 <__aeabi_fsub>
 800cf82:	4603      	mov	r3, r0
 800cf84:	637b      	str	r3, [r7, #52]	; 0x34
        start.y = target->values[plane.axis_1] - center.y;
 800cf86:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800cf8a:	461a      	mov	r2, r3
 800cf8c:	68fb      	ldr	r3, [r7, #12]
 800cf8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cf92:	687a      	ldr	r2, [r7, #4]
 800cf94:	4611      	mov	r1, r2
 800cf96:	4618      	mov	r0, r3
 800cf98:	f7f3 fe02 	bl	8000ba0 <__aeabi_fsub>
 800cf9c:	4603      	mov	r3, r0
 800cf9e:	63bb      	str	r3, [r7, #56]	; 0x38
        end.x = position->values[plane.axis_0] - center.x;
 800cfa0:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800cfa4:	461a      	mov	r2, r3
 800cfa6:	68bb      	ldr	r3, [r7, #8]
 800cfa8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cfac:	683a      	ldr	r2, [r7, #0]
 800cfae:	4611      	mov	r1, r2
 800cfb0:	4618      	mov	r0, r3
 800cfb2:	f7f3 fdf5 	bl	8000ba0 <__aeabi_fsub>
 800cfb6:	4603      	mov	r3, r0
 800cfb8:	62fb      	str	r3, [r7, #44]	; 0x2c
        end.y = position->values[plane.axis_1] - center.y;
 800cfba:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800cfbe:	461a      	mov	r2, r3
 800cfc0:	68bb      	ldr	r3, [r7, #8]
 800cfc2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cfc6:	687a      	ldr	r2, [r7, #4]
 800cfc8:	4611      	mov	r1, r2
 800cfca:	4618      	mov	r0, r3
 800cfcc:	f7f3 fde8 	bl	8000ba0 <__aeabi_fsub>
 800cfd0:	4603      	mov	r3, r0
 800cfd2:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if(labs(turns > 1))
 800cfd4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cfd6:	2b01      	cmp	r3, #1
 800cfd8:	dd01      	ble.n	800cfde <check_arc_travel_limits+0x11e>
 800cfda:	2301      	movs	r3, #1
 800cfdc:	e000      	b.n	800cfe0 <check_arc_travel_limits+0x120>
 800cfde:	2300      	movs	r3, #0
 800cfe0:	2b00      	cmp	r3, #0
 800cfe2:	d002      	beq.n	800cfea <check_arc_travel_limits+0x12a>
        x.value = 0b1111;                   // Crosses all
 800cfe4:	230f      	movs	r3, #15
 800cfe6:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cfe8:	e0e0      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
    else if(start.y >= 0.0f) {
 800cfea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cfec:	f04f 0100 	mov.w	r1, #0
 800cff0:	4618      	mov	r0, r3
 800cff2:	f7f4 f891 	bl	8001118 <__aeabi_fcmpge>
 800cff6:	4603      	mov	r3, r0
 800cff8:	2b00      	cmp	r3, #0
 800cffa:	d069      	beq.n	800d0d0 <check_arc_travel_limits+0x210>
        if(start.x > 0.0f) {                // Starts in Q1
 800cffc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cffe:	f04f 0100 	mov.w	r1, #0
 800d002:	4618      	mov	r0, r3
 800d004:	f7f4 f892 	bl	800112c <__aeabi_fcmpgt>
 800d008:	4603      	mov	r3, r0
 800d00a:	2b00      	cmp	r3, #0
 800d00c:	d030      	beq.n	800d070 <check_arc_travel_limits+0x1b0>
            if(end.y >= 0.0f) {
 800d00e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d010:	f04f 0100 	mov.w	r1, #0
 800d014:	4618      	mov	r0, r3
 800d016:	f7f4 f87f 	bl	8001118 <__aeabi_fcmpge>
 800d01a:	4603      	mov	r3, r0
 800d01c:	2b00      	cmp	r3, #0
 800d01e:	d018      	beq.n	800d052 <check_arc_travel_limits+0x192>
                if(end.x <= 0.0f)
 800d020:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d022:	f04f 0100 	mov.w	r1, #0
 800d026:	4618      	mov	r0, r3
 800d028:	f7f4 f86c 	bl	8001104 <__aeabi_fcmple>
 800d02c:	4603      	mov	r3, r0
 800d02e:	2b00      	cmp	r3, #0
 800d030:	d002      	beq.n	800d038 <check_arc_travel_limits+0x178>
                    x.value = 0b0001;       // Ends in Q2
 800d032:	2301      	movs	r3, #1
 800d034:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d036:	e0b9      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
                else if(end.x >= start.x)
 800d038:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d03a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d03c:	4611      	mov	r1, r2
 800d03e:	4618      	mov	r0, r3
 800d040:	f7f4 f86a 	bl	8001118 <__aeabi_fcmpge>
 800d044:	4603      	mov	r3, r0
 800d046:	2b00      	cmp	r3, #0
 800d048:	f000 80b0 	beq.w	800d1ac <check_arc_travel_limits+0x2ec>
                    x.value = 0b1111;       // Ends in Q1, crosses all
 800d04c:	230f      	movs	r3, #15
 800d04e:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d050:	e0ac      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
            } else if(end.x <= 0.0f)
 800d052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d054:	f04f 0100 	mov.w	r1, #0
 800d058:	4618      	mov	r0, r3
 800d05a:	f7f4 f853 	bl	8001104 <__aeabi_fcmple>
 800d05e:	4603      	mov	r3, r0
 800d060:	2b00      	cmp	r3, #0
 800d062:	d002      	beq.n	800d06a <check_arc_travel_limits+0x1aa>
                x.value = 0b0011;           // Ends in Q3
 800d064:	2303      	movs	r3, #3
 800d066:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d068:	e0a0      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
            else
                x.value = 0b0111;           // Ends in Q4
 800d06a:	2307      	movs	r3, #7
 800d06c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d06e:	e09d      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        } else {                            // Starts in Q2
            if(end.y >= 0.0f) {
 800d070:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d072:	f04f 0100 	mov.w	r1, #0
 800d076:	4618      	mov	r0, r3
 800d078:	f7f4 f84e 	bl	8001118 <__aeabi_fcmpge>
 800d07c:	4603      	mov	r3, r0
 800d07e:	2b00      	cmp	r3, #0
 800d080:	d017      	beq.n	800d0b2 <check_arc_travel_limits+0x1f2>
                if(end.x > 0.0f)
 800d082:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d084:	f04f 0100 	mov.w	r1, #0
 800d088:	4618      	mov	r0, r3
 800d08a:	f7f4 f84f 	bl	800112c <__aeabi_fcmpgt>
 800d08e:	4603      	mov	r3, r0
 800d090:	2b00      	cmp	r3, #0
 800d092:	d002      	beq.n	800d09a <check_arc_travel_limits+0x1da>
                    x.value = 0b1110;       // Ends in Q1
 800d094:	230e      	movs	r3, #14
 800d096:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d098:	e088      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
                else if(end.x >= start.x)
 800d09a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d09c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d09e:	4611      	mov	r1, r2
 800d0a0:	4618      	mov	r0, r3
 800d0a2:	f7f4 f839 	bl	8001118 <__aeabi_fcmpge>
 800d0a6:	4603      	mov	r3, r0
 800d0a8:	2b00      	cmp	r3, #0
 800d0aa:	d07f      	beq.n	800d1ac <check_arc_travel_limits+0x2ec>
                    x.value = 0b1111;       // Ends in Q2, crosses all
 800d0ac:	230f      	movs	r3, #15
 800d0ae:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d0b0:	e07c      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
            } else if(end.x <= 0.0f)
 800d0b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d0b4:	f04f 0100 	mov.w	r1, #0
 800d0b8:	4618      	mov	r0, r3
 800d0ba:	f7f4 f823 	bl	8001104 <__aeabi_fcmple>
 800d0be:	4603      	mov	r3, r0
 800d0c0:	2b00      	cmp	r3, #0
 800d0c2:	d002      	beq.n	800d0ca <check_arc_travel_limits+0x20a>
                x.value = 0b0010;           // Ends in Q3
 800d0c4:	2302      	movs	r3, #2
 800d0c6:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d0c8:	e070      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
            else
                x.value = 0b0110;           // Ends in Q4
 800d0ca:	2306      	movs	r3, #6
 800d0cc:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d0ce:	e06d      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        }
    } else if(start.x < 0.0f) {             // Starts in Q3
 800d0d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d0d2:	f04f 0100 	mov.w	r1, #0
 800d0d6:	4618      	mov	r0, r3
 800d0d8:	f7f4 f80a 	bl	80010f0 <__aeabi_fcmplt>
 800d0dc:	4603      	mov	r3, r0
 800d0de:	2b00      	cmp	r3, #0
 800d0e0:	d02f      	beq.n	800d142 <check_arc_travel_limits+0x282>
        if(end.y < 0.0f) {
 800d0e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d0e4:	f04f 0100 	mov.w	r1, #0
 800d0e8:	4618      	mov	r0, r3
 800d0ea:	f7f4 f801 	bl	80010f0 <__aeabi_fcmplt>
 800d0ee:	4603      	mov	r3, r0
 800d0f0:	2b00      	cmp	r3, #0
 800d0f2:	d017      	beq.n	800d124 <check_arc_travel_limits+0x264>
            if(end.x > 0.0f)
 800d0f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d0f6:	f04f 0100 	mov.w	r1, #0
 800d0fa:	4618      	mov	r0, r3
 800d0fc:	f7f4 f816 	bl	800112c <__aeabi_fcmpgt>
 800d100:	4603      	mov	r3, r0
 800d102:	2b00      	cmp	r3, #0
 800d104:	d002      	beq.n	800d10c <check_arc_travel_limits+0x24c>
                x.value = 0b0100;           // Ends in Q4
 800d106:	2304      	movs	r3, #4
 800d108:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d10a:	e04f      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
            else if(end.x <= start.x)
 800d10c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d10e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d110:	4611      	mov	r1, r2
 800d112:	4618      	mov	r0, r3
 800d114:	f7f3 fff6 	bl	8001104 <__aeabi_fcmple>
 800d118:	4603      	mov	r3, r0
 800d11a:	2b00      	cmp	r3, #0
 800d11c:	d046      	beq.n	800d1ac <check_arc_travel_limits+0x2ec>
                x.value = 0b1111;           // Ends in Q3, crosses all
 800d11e:	230f      	movs	r3, #15
 800d120:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d122:	e043      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        } else if(end.x > 0.0f)
 800d124:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d126:	f04f 0100 	mov.w	r1, #0
 800d12a:	4618      	mov	r0, r3
 800d12c:	f7f3 fffe 	bl	800112c <__aeabi_fcmpgt>
 800d130:	4603      	mov	r3, r0
 800d132:	2b00      	cmp	r3, #0
 800d134:	d002      	beq.n	800d13c <check_arc_travel_limits+0x27c>
            x.value = 0b1100;               // Ends in Q1
 800d136:	230c      	movs	r3, #12
 800d138:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d13a:	e037      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        else
            x.value = 0b1101;               // Ends in Q2
 800d13c:	230d      	movs	r3, #13
 800d13e:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d140:	e034      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
    } else {                                // Starts in Q4
        if(end.y < 0.0f) {
 800d142:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d144:	f04f 0100 	mov.w	r1, #0
 800d148:	4618      	mov	r0, r3
 800d14a:	f7f3 ffd1 	bl	80010f0 <__aeabi_fcmplt>
 800d14e:	4603      	mov	r3, r0
 800d150:	2b00      	cmp	r3, #0
 800d152:	d01d      	beq.n	800d190 <check_arc_travel_limits+0x2d0>
            if(end.x < 0.0f)
 800d154:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d156:	f04f 0100 	mov.w	r1, #0
 800d15a:	4618      	mov	r0, r3
 800d15c:	f7f3 ffc8 	bl	80010f0 <__aeabi_fcmplt>
 800d160:	4603      	mov	r3, r0
 800d162:	2b00      	cmp	r3, #0
 800d164:	d008      	beq.n	800d178 <check_arc_travel_limits+0x2b8>
                x.value = 0b1011;           // Ends in Q3
 800d166:	230b      	movs	r3, #11
 800d168:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d16a:	e01f      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
 800d16c:	20000d3c 	.word	0x20000d3c
 800d170:	08030c88 	.word	0x08030c88
 800d174:	20000dd4 	.word	0x20000dd4
            else if(end.x <= start.x)
 800d178:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d17a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d17c:	4611      	mov	r1, r2
 800d17e:	4618      	mov	r0, r3
 800d180:	f7f3 ffc0 	bl	8001104 <__aeabi_fcmple>
 800d184:	4603      	mov	r3, r0
 800d186:	2b00      	cmp	r3, #0
 800d188:	d010      	beq.n	800d1ac <check_arc_travel_limits+0x2ec>
                x.value = 0b1111;           // Ends in Q4, crosses all
 800d18a:	230f      	movs	r3, #15
 800d18c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d18e:	e00d      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        } else if(end.x > 0.0f)
 800d190:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d192:	f04f 0100 	mov.w	r1, #0
 800d196:	4618      	mov	r0, r3
 800d198:	f7f3 ffc8 	bl	800112c <__aeabi_fcmpgt>
 800d19c:	4603      	mov	r3, r0
 800d19e:	2b00      	cmp	r3, #0
 800d1a0:	d002      	beq.n	800d1a8 <check_arc_travel_limits+0x2e8>
            x.value = 0b1000;               // Ends in Q1
 800d1a2:	2308      	movs	r3, #8
 800d1a4:	63fb      	str	r3, [r7, #60]	; 0x3c
 800d1a6:	e001      	b.n	800d1ac <check_arc_travel_limits+0x2ec>
        else
            x.value = 0b1001;               // Ends in Q2
 800d1a8:	2309      	movs	r3, #9
 800d1aa:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

    coord_data_t corner1, corner2;

    memcpy(&corner1, turns > 0 ? position : target, sizeof(coord_data_t));
 800d1ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d1ae:	2b00      	cmp	r3, #0
 800d1b0:	dd01      	ble.n	800d1b6 <check_arc_travel_limits+0x2f6>
 800d1b2:	68bb      	ldr	r3, [r7, #8]
 800d1b4:	e000      	b.n	800d1b8 <check_arc_travel_limits+0x2f8>
 800d1b6:	68fb      	ldr	r3, [r7, #12]
 800d1b8:	f107 0020 	add.w	r0, r7, #32
 800d1bc:	220c      	movs	r2, #12
 800d1be:	4619      	mov	r1, r3
 800d1c0:	f016 fe85 	bl	8023ece <memcpy>
    corner1.values[plane.axis_0] = x.neg_x ? center.x - radius : min(position->values[plane.axis_0], target->values[plane.axis_0]);
 800d1c4:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800d1c8:	f003 0302 	and.w	r3, r3, #2
 800d1cc:	b2db      	uxtb	r3, r3
 800d1ce:	2b00      	cmp	r3, #0
 800d1d0:	d007      	beq.n	800d1e2 <check_arc_travel_limits+0x322>
 800d1d2:	683b      	ldr	r3, [r7, #0]
 800d1d4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800d1d6:	4618      	mov	r0, r3
 800d1d8:	f7f3 fce2 	bl	8000ba0 <__aeabi_fsub>
 800d1dc:	4603      	mov	r3, r0
 800d1de:	461a      	mov	r2, r3
 800d1e0:	e01f      	b.n	800d222 <check_arc_travel_limits+0x362>
 800d1e2:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d1e6:	461a      	mov	r2, r3
 800d1e8:	68bb      	ldr	r3, [r7, #8]
 800d1ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d1ee:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d1f2:	4619      	mov	r1, r3
 800d1f4:	68fb      	ldr	r3, [r7, #12]
 800d1f6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800d1fa:	4619      	mov	r1, r3
 800d1fc:	4610      	mov	r0, r2
 800d1fe:	f7f3 ff77 	bl	80010f0 <__aeabi_fcmplt>
 800d202:	4603      	mov	r3, r0
 800d204:	2b00      	cmp	r3, #0
 800d206:	d006      	beq.n	800d216 <check_arc_travel_limits+0x356>
 800d208:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d20c:	461a      	mov	r2, r3
 800d20e:	68bb      	ldr	r3, [r7, #8]
 800d210:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d214:	e005      	b.n	800d222 <check_arc_travel_limits+0x362>
 800d216:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d21a:	461a      	mov	r2, r3
 800d21c:	68fb      	ldr	r3, [r7, #12]
 800d21e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d222:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d226:	009b      	lsls	r3, r3, #2
 800d228:	3340      	adds	r3, #64	; 0x40
 800d22a:	443b      	add	r3, r7
 800d22c:	f843 2c20 	str.w	r2, [r3, #-32]
    corner1.values[plane.axis_1] = x.neg_y ? center.y - radius : max(position->values[plane.axis_1], target->values[plane.axis_1]);
 800d230:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800d234:	f003 0304 	and.w	r3, r3, #4
 800d238:	b2db      	uxtb	r3, r3
 800d23a:	2b00      	cmp	r3, #0
 800d23c:	d007      	beq.n	800d24e <check_arc_travel_limits+0x38e>
 800d23e:	687b      	ldr	r3, [r7, #4]
 800d240:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800d242:	4618      	mov	r0, r3
 800d244:	f7f3 fcac 	bl	8000ba0 <__aeabi_fsub>
 800d248:	4603      	mov	r3, r0
 800d24a:	461a      	mov	r2, r3
 800d24c:	e01f      	b.n	800d28e <check_arc_travel_limits+0x3ce>
 800d24e:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d252:	461a      	mov	r2, r3
 800d254:	68bb      	ldr	r3, [r7, #8]
 800d256:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d25a:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d25e:	4619      	mov	r1, r3
 800d260:	68fb      	ldr	r3, [r7, #12]
 800d262:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800d266:	4619      	mov	r1, r3
 800d268:	4610      	mov	r0, r2
 800d26a:	f7f3 ff5f 	bl	800112c <__aeabi_fcmpgt>
 800d26e:	4603      	mov	r3, r0
 800d270:	2b00      	cmp	r3, #0
 800d272:	d006      	beq.n	800d282 <check_arc_travel_limits+0x3c2>
 800d274:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d278:	461a      	mov	r2, r3
 800d27a:	68bb      	ldr	r3, [r7, #8]
 800d27c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d280:	e005      	b.n	800d28e <check_arc_travel_limits+0x3ce>
 800d282:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d286:	461a      	mov	r2, r3
 800d288:	68fb      	ldr	r3, [r7, #12]
 800d28a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d28e:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d292:	009b      	lsls	r3, r3, #2
 800d294:	3340      	adds	r3, #64	; 0x40
 800d296:	443b      	add	r3, r7
 800d298:	f843 2c20 	str.w	r2, [r3, #-32]

    if(!grbl.check_travel_limits(corner1.values, sys.soft_limits, true))
 800d29c:	4b4c      	ldr	r3, [pc, #304]	; (800d3d0 <check_arc_travel_limits+0x510>)
 800d29e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d2a2:	494c      	ldr	r1, [pc, #304]	; (800d3d4 <check_arc_travel_limits+0x514>)
 800d2a4:	f107 0020 	add.w	r0, r7, #32
 800d2a8:	2201      	movs	r2, #1
 800d2aa:	f891 1095 	ldrb.w	r1, [r1, #149]	; 0x95
 800d2ae:	4798      	blx	r3
 800d2b0:	4603      	mov	r3, r0
 800d2b2:	f083 0301 	eor.w	r3, r3, #1
 800d2b6:	b2db      	uxtb	r3, r3
 800d2b8:	2b00      	cmp	r3, #0
 800d2ba:	d001      	beq.n	800d2c0 <check_arc_travel_limits+0x400>
        return false;
 800d2bc:	2300      	movs	r3, #0
 800d2be:	e082      	b.n	800d3c6 <check_arc_travel_limits+0x506>

    memcpy(&corner2, turns > 0 ? target : position, sizeof(coord_data_t));
 800d2c0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2c2:	2b00      	cmp	r3, #0
 800d2c4:	dd01      	ble.n	800d2ca <check_arc_travel_limits+0x40a>
 800d2c6:	68fb      	ldr	r3, [r7, #12]
 800d2c8:	e000      	b.n	800d2cc <check_arc_travel_limits+0x40c>
 800d2ca:	68bb      	ldr	r3, [r7, #8]
 800d2cc:	f107 0014 	add.w	r0, r7, #20
 800d2d0:	220c      	movs	r2, #12
 800d2d2:	4619      	mov	r1, r3
 800d2d4:	f016 fdfb 	bl	8023ece <memcpy>
    corner2.values[plane.axis_0] = x.pos_x ? center.x + radius : max(position->values[plane.axis_0], target->values[plane.axis_0]);
 800d2d8:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800d2dc:	f003 0308 	and.w	r3, r3, #8
 800d2e0:	b2db      	uxtb	r3, r3
 800d2e2:	2b00      	cmp	r3, #0
 800d2e4:	d007      	beq.n	800d2f6 <check_arc_travel_limits+0x436>
 800d2e6:	683b      	ldr	r3, [r7, #0]
 800d2e8:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800d2ea:	4618      	mov	r0, r3
 800d2ec:	f7f3 fc5a 	bl	8000ba4 <__addsf3>
 800d2f0:	4603      	mov	r3, r0
 800d2f2:	461a      	mov	r2, r3
 800d2f4:	e01f      	b.n	800d336 <check_arc_travel_limits+0x476>
 800d2f6:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d2fa:	461a      	mov	r2, r3
 800d2fc:	68bb      	ldr	r3, [r7, #8]
 800d2fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d302:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d306:	4619      	mov	r1, r3
 800d308:	68fb      	ldr	r3, [r7, #12]
 800d30a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800d30e:	4619      	mov	r1, r3
 800d310:	4610      	mov	r0, r2
 800d312:	f7f3 ff0b 	bl	800112c <__aeabi_fcmpgt>
 800d316:	4603      	mov	r3, r0
 800d318:	2b00      	cmp	r3, #0
 800d31a:	d006      	beq.n	800d32a <check_arc_travel_limits+0x46a>
 800d31c:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d320:	461a      	mov	r2, r3
 800d322:	68bb      	ldr	r3, [r7, #8]
 800d324:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d328:	e005      	b.n	800d336 <check_arc_travel_limits+0x476>
 800d32a:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d32e:	461a      	mov	r2, r3
 800d330:	68fb      	ldr	r3, [r7, #12]
 800d332:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d336:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 800d33a:	009b      	lsls	r3, r3, #2
 800d33c:	3340      	adds	r3, #64	; 0x40
 800d33e:	443b      	add	r3, r7
 800d340:	f843 2c2c 	str.w	r2, [r3, #-44]
    corner2.values[plane.axis_1] = x.pos_y ? center.y + radius : min(position->values[plane.axis_1], target->values[plane.axis_1]);
 800d344:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 800d348:	f003 0301 	and.w	r3, r3, #1
 800d34c:	b2db      	uxtb	r3, r3
 800d34e:	2b00      	cmp	r3, #0
 800d350:	d007      	beq.n	800d362 <check_arc_travel_limits+0x4a2>
 800d352:	687b      	ldr	r3, [r7, #4]
 800d354:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800d356:	4618      	mov	r0, r3
 800d358:	f7f3 fc24 	bl	8000ba4 <__addsf3>
 800d35c:	4603      	mov	r3, r0
 800d35e:	461a      	mov	r2, r3
 800d360:	e01f      	b.n	800d3a2 <check_arc_travel_limits+0x4e2>
 800d362:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d366:	461a      	mov	r2, r3
 800d368:	68bb      	ldr	r3, [r7, #8]
 800d36a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d36e:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d372:	4619      	mov	r1, r3
 800d374:	68fb      	ldr	r3, [r7, #12]
 800d376:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800d37a:	4619      	mov	r1, r3
 800d37c:	4610      	mov	r0, r2
 800d37e:	f7f3 feb7 	bl	80010f0 <__aeabi_fcmplt>
 800d382:	4603      	mov	r3, r0
 800d384:	2b00      	cmp	r3, #0
 800d386:	d006      	beq.n	800d396 <check_arc_travel_limits+0x4d6>
 800d388:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d38c:	461a      	mov	r2, r3
 800d38e:	68bb      	ldr	r3, [r7, #8]
 800d390:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d394:	e005      	b.n	800d3a2 <check_arc_travel_limits+0x4e2>
 800d396:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d39a:	461a      	mov	r2, r3
 800d39c:	68fb      	ldr	r3, [r7, #12]
 800d39e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800d3a2:	f897 304d 	ldrb.w	r3, [r7, #77]	; 0x4d
 800d3a6:	009b      	lsls	r3, r3, #2
 800d3a8:	3340      	adds	r3, #64	; 0x40
 800d3aa:	443b      	add	r3, r7
 800d3ac:	f843 2c2c 	str.w	r2, [r3, #-44]

   return grbl.check_travel_limits(corner2.values, sys.soft_limits, true);
 800d3b0:	4b07      	ldr	r3, [pc, #28]	; (800d3d0 <check_arc_travel_limits+0x510>)
 800d3b2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800d3b6:	4907      	ldr	r1, [pc, #28]	; (800d3d4 <check_arc_travel_limits+0x514>)
 800d3b8:	f107 0014 	add.w	r0, r7, #20
 800d3bc:	2201      	movs	r2, #1
 800d3be:	f891 1095 	ldrb.w	r1, [r1, #149]	; 0x95
 800d3c2:	4798      	blx	r3
 800d3c4:	4603      	mov	r3, r0
}
 800d3c6:	4618      	mov	r0, r3
 800d3c8:	3740      	adds	r7, #64	; 0x40
 800d3ca:	46bd      	mov	sp, r7
 800d3cc:	bd80      	pop	{r7, pc}
 800d3ce:	bf00      	nop
 800d3d0:	20000dd4 	.word	0x20000dd4
 800d3d4:	20000d3c 	.word	0x20000d3c

0800d3d8 <clip_3d_target>:

// Derived from code by Dimitrios Matthes & Vasileios Drakopoulos
// https://www.mdpi.com/1999-4893/16/4/201
static void clip_3d_target (coord_data_t *position, coord_data_t *target, work_envelope_t *envelope)
{
 800d3d8:	b590      	push	{r4, r7, lr}
 800d3da:	b089      	sub	sp, #36	; 0x24
 800d3dc:	af00      	add	r7, sp, #0
 800d3de:	60f8      	str	r0, [r7, #12]
 800d3e0:	60b9      	str	r1, [r7, #8]
 800d3e2:	607a      	str	r2, [r7, #4]
    float a = target->x - position->x;
 800d3e4:	68bb      	ldr	r3, [r7, #8]
 800d3e6:	681a      	ldr	r2, [r3, #0]
 800d3e8:	68fb      	ldr	r3, [r7, #12]
 800d3ea:	681b      	ldr	r3, [r3, #0]
 800d3ec:	4619      	mov	r1, r3
 800d3ee:	4610      	mov	r0, r2
 800d3f0:	f7f3 fbd6 	bl	8000ba0 <__aeabi_fsub>
 800d3f4:	4603      	mov	r3, r0
 800d3f6:	61fb      	str	r3, [r7, #28]
    float b = target->y - position->y;
 800d3f8:	68bb      	ldr	r3, [r7, #8]
 800d3fa:	685a      	ldr	r2, [r3, #4]
 800d3fc:	68fb      	ldr	r3, [r7, #12]
 800d3fe:	685b      	ldr	r3, [r3, #4]
 800d400:	4619      	mov	r1, r3
 800d402:	4610      	mov	r0, r2
 800d404:	f7f3 fbcc 	bl	8000ba0 <__aeabi_fsub>
 800d408:	4603      	mov	r3, r0
 800d40a:	61bb      	str	r3, [r7, #24]
    float c = target->z - position->z;
 800d40c:	68bb      	ldr	r3, [r7, #8]
 800d40e:	689a      	ldr	r2, [r3, #8]
 800d410:	68fb      	ldr	r3, [r7, #12]
 800d412:	689b      	ldr	r3, [r3, #8]
 800d414:	4619      	mov	r1, r3
 800d416:	4610      	mov	r0, r2
 800d418:	f7f3 fbc2 	bl	8000ba0 <__aeabi_fsub>
 800d41c:	4603      	mov	r3, r0
 800d41e:	617b      	str	r3, [r7, #20]

    if(target->x < envelope->min.x) {
 800d420:	68bb      	ldr	r3, [r7, #8]
 800d422:	681a      	ldr	r2, [r3, #0]
 800d424:	687b      	ldr	r3, [r7, #4]
 800d426:	681b      	ldr	r3, [r3, #0]
 800d428:	4619      	mov	r1, r3
 800d42a:	4610      	mov	r0, r2
 800d42c:	f7f3 fe60 	bl	80010f0 <__aeabi_fcmplt>
 800d430:	4603      	mov	r3, r0
 800d432:	2b00      	cmp	r3, #0
 800d434:	d042      	beq.n	800d4bc <clip_3d_target+0xe4>
        target->y = b / a * (envelope->min.x - position->x) + position->y;
 800d436:	69f9      	ldr	r1, [r7, #28]
 800d438:	69b8      	ldr	r0, [r7, #24]
 800d43a:	f7f3 fd6f 	bl	8000f1c <__aeabi_fdiv>
 800d43e:	4603      	mov	r3, r0
 800d440:	461c      	mov	r4, r3
 800d442:	687b      	ldr	r3, [r7, #4]
 800d444:	681a      	ldr	r2, [r3, #0]
 800d446:	68fb      	ldr	r3, [r7, #12]
 800d448:	681b      	ldr	r3, [r3, #0]
 800d44a:	4619      	mov	r1, r3
 800d44c:	4610      	mov	r0, r2
 800d44e:	f7f3 fba7 	bl	8000ba0 <__aeabi_fsub>
 800d452:	4603      	mov	r3, r0
 800d454:	4619      	mov	r1, r3
 800d456:	4620      	mov	r0, r4
 800d458:	f7f3 fcac 	bl	8000db4 <__aeabi_fmul>
 800d45c:	4603      	mov	r3, r0
 800d45e:	461a      	mov	r2, r3
 800d460:	68fb      	ldr	r3, [r7, #12]
 800d462:	685b      	ldr	r3, [r3, #4]
 800d464:	4619      	mov	r1, r3
 800d466:	4610      	mov	r0, r2
 800d468:	f7f3 fb9c 	bl	8000ba4 <__addsf3>
 800d46c:	4603      	mov	r3, r0
 800d46e:	461a      	mov	r2, r3
 800d470:	68bb      	ldr	r3, [r7, #8]
 800d472:	605a      	str	r2, [r3, #4]
        target->z = c / a * (envelope->min.x - position->x) + position->z;
 800d474:	69f9      	ldr	r1, [r7, #28]
 800d476:	6978      	ldr	r0, [r7, #20]
 800d478:	f7f3 fd50 	bl	8000f1c <__aeabi_fdiv>
 800d47c:	4603      	mov	r3, r0
 800d47e:	461c      	mov	r4, r3
 800d480:	687b      	ldr	r3, [r7, #4]
 800d482:	681a      	ldr	r2, [r3, #0]
 800d484:	68fb      	ldr	r3, [r7, #12]
 800d486:	681b      	ldr	r3, [r3, #0]
 800d488:	4619      	mov	r1, r3
 800d48a:	4610      	mov	r0, r2
 800d48c:	f7f3 fb88 	bl	8000ba0 <__aeabi_fsub>
 800d490:	4603      	mov	r3, r0
 800d492:	4619      	mov	r1, r3
 800d494:	4620      	mov	r0, r4
 800d496:	f7f3 fc8d 	bl	8000db4 <__aeabi_fmul>
 800d49a:	4603      	mov	r3, r0
 800d49c:	461a      	mov	r2, r3
 800d49e:	68fb      	ldr	r3, [r7, #12]
 800d4a0:	689b      	ldr	r3, [r3, #8]
 800d4a2:	4619      	mov	r1, r3
 800d4a4:	4610      	mov	r0, r2
 800d4a6:	f7f3 fb7d 	bl	8000ba4 <__addsf3>
 800d4aa:	4603      	mov	r3, r0
 800d4ac:	461a      	mov	r2, r3
 800d4ae:	68bb      	ldr	r3, [r7, #8]
 800d4b0:	609a      	str	r2, [r3, #8]
        target->x = envelope->min.x;
 800d4b2:	687b      	ldr	r3, [r7, #4]
 800d4b4:	681a      	ldr	r2, [r3, #0]
 800d4b6:	68bb      	ldr	r3, [r7, #8]
 800d4b8:	601a      	str	r2, [r3, #0]
 800d4ba:	e04c      	b.n	800d556 <clip_3d_target+0x17e>
    } else if(target->x > envelope->max.x) {
 800d4bc:	68bb      	ldr	r3, [r7, #8]
 800d4be:	681a      	ldr	r2, [r3, #0]
 800d4c0:	687b      	ldr	r3, [r7, #4]
 800d4c2:	68db      	ldr	r3, [r3, #12]
 800d4c4:	4619      	mov	r1, r3
 800d4c6:	4610      	mov	r0, r2
 800d4c8:	f7f3 fe30 	bl	800112c <__aeabi_fcmpgt>
 800d4cc:	4603      	mov	r3, r0
 800d4ce:	2b00      	cmp	r3, #0
 800d4d0:	d041      	beq.n	800d556 <clip_3d_target+0x17e>
        target->y = b / a * (envelope->max.x - position->x) + position->y;
 800d4d2:	69f9      	ldr	r1, [r7, #28]
 800d4d4:	69b8      	ldr	r0, [r7, #24]
 800d4d6:	f7f3 fd21 	bl	8000f1c <__aeabi_fdiv>
 800d4da:	4603      	mov	r3, r0
 800d4dc:	461c      	mov	r4, r3
 800d4de:	687b      	ldr	r3, [r7, #4]
 800d4e0:	68da      	ldr	r2, [r3, #12]
 800d4e2:	68fb      	ldr	r3, [r7, #12]
 800d4e4:	681b      	ldr	r3, [r3, #0]
 800d4e6:	4619      	mov	r1, r3
 800d4e8:	4610      	mov	r0, r2
 800d4ea:	f7f3 fb59 	bl	8000ba0 <__aeabi_fsub>
 800d4ee:	4603      	mov	r3, r0
 800d4f0:	4619      	mov	r1, r3
 800d4f2:	4620      	mov	r0, r4
 800d4f4:	f7f3 fc5e 	bl	8000db4 <__aeabi_fmul>
 800d4f8:	4603      	mov	r3, r0
 800d4fa:	461a      	mov	r2, r3
 800d4fc:	68fb      	ldr	r3, [r7, #12]
 800d4fe:	685b      	ldr	r3, [r3, #4]
 800d500:	4619      	mov	r1, r3
 800d502:	4610      	mov	r0, r2
 800d504:	f7f3 fb4e 	bl	8000ba4 <__addsf3>
 800d508:	4603      	mov	r3, r0
 800d50a:	461a      	mov	r2, r3
 800d50c:	68bb      	ldr	r3, [r7, #8]
 800d50e:	605a      	str	r2, [r3, #4]
        target->z = c / a * (envelope->max.x - position->x) + position->z;
 800d510:	69f9      	ldr	r1, [r7, #28]
 800d512:	6978      	ldr	r0, [r7, #20]
 800d514:	f7f3 fd02 	bl	8000f1c <__aeabi_fdiv>
 800d518:	4603      	mov	r3, r0
 800d51a:	461c      	mov	r4, r3
 800d51c:	687b      	ldr	r3, [r7, #4]
 800d51e:	68da      	ldr	r2, [r3, #12]
 800d520:	68fb      	ldr	r3, [r7, #12]
 800d522:	681b      	ldr	r3, [r3, #0]
 800d524:	4619      	mov	r1, r3
 800d526:	4610      	mov	r0, r2
 800d528:	f7f3 fb3a 	bl	8000ba0 <__aeabi_fsub>
 800d52c:	4603      	mov	r3, r0
 800d52e:	4619      	mov	r1, r3
 800d530:	4620      	mov	r0, r4
 800d532:	f7f3 fc3f 	bl	8000db4 <__aeabi_fmul>
 800d536:	4603      	mov	r3, r0
 800d538:	461a      	mov	r2, r3
 800d53a:	68fb      	ldr	r3, [r7, #12]
 800d53c:	689b      	ldr	r3, [r3, #8]
 800d53e:	4619      	mov	r1, r3
 800d540:	4610      	mov	r0, r2
 800d542:	f7f3 fb2f 	bl	8000ba4 <__addsf3>
 800d546:	4603      	mov	r3, r0
 800d548:	461a      	mov	r2, r3
 800d54a:	68bb      	ldr	r3, [r7, #8]
 800d54c:	609a      	str	r2, [r3, #8]
        target->x = envelope->max.x;
 800d54e:	687b      	ldr	r3, [r7, #4]
 800d550:	68da      	ldr	r2, [r3, #12]
 800d552:	68bb      	ldr	r3, [r7, #8]
 800d554:	601a      	str	r2, [r3, #0]
    }

    if(target->y < envelope->min.y) {
 800d556:	68bb      	ldr	r3, [r7, #8]
 800d558:	685a      	ldr	r2, [r3, #4]
 800d55a:	687b      	ldr	r3, [r7, #4]
 800d55c:	685b      	ldr	r3, [r3, #4]
 800d55e:	4619      	mov	r1, r3
 800d560:	4610      	mov	r0, r2
 800d562:	f7f3 fdc5 	bl	80010f0 <__aeabi_fcmplt>
 800d566:	4603      	mov	r3, r0
 800d568:	2b00      	cmp	r3, #0
 800d56a:	d042      	beq.n	800d5f2 <clip_3d_target+0x21a>
        target->x = a / b * (envelope->min.y - position->y) + position->x;
 800d56c:	69b9      	ldr	r1, [r7, #24]
 800d56e:	69f8      	ldr	r0, [r7, #28]
 800d570:	f7f3 fcd4 	bl	8000f1c <__aeabi_fdiv>
 800d574:	4603      	mov	r3, r0
 800d576:	461c      	mov	r4, r3
 800d578:	687b      	ldr	r3, [r7, #4]
 800d57a:	685a      	ldr	r2, [r3, #4]
 800d57c:	68fb      	ldr	r3, [r7, #12]
 800d57e:	685b      	ldr	r3, [r3, #4]
 800d580:	4619      	mov	r1, r3
 800d582:	4610      	mov	r0, r2
 800d584:	f7f3 fb0c 	bl	8000ba0 <__aeabi_fsub>
 800d588:	4603      	mov	r3, r0
 800d58a:	4619      	mov	r1, r3
 800d58c:	4620      	mov	r0, r4
 800d58e:	f7f3 fc11 	bl	8000db4 <__aeabi_fmul>
 800d592:	4603      	mov	r3, r0
 800d594:	461a      	mov	r2, r3
 800d596:	68fb      	ldr	r3, [r7, #12]
 800d598:	681b      	ldr	r3, [r3, #0]
 800d59a:	4619      	mov	r1, r3
 800d59c:	4610      	mov	r0, r2
 800d59e:	f7f3 fb01 	bl	8000ba4 <__addsf3>
 800d5a2:	4603      	mov	r3, r0
 800d5a4:	461a      	mov	r2, r3
 800d5a6:	68bb      	ldr	r3, [r7, #8]
 800d5a8:	601a      	str	r2, [r3, #0]
        target->z = c / b * (envelope->min.y - position->y) + position->z;
 800d5aa:	69b9      	ldr	r1, [r7, #24]
 800d5ac:	6978      	ldr	r0, [r7, #20]
 800d5ae:	f7f3 fcb5 	bl	8000f1c <__aeabi_fdiv>
 800d5b2:	4603      	mov	r3, r0
 800d5b4:	461c      	mov	r4, r3
 800d5b6:	687b      	ldr	r3, [r7, #4]
 800d5b8:	685a      	ldr	r2, [r3, #4]
 800d5ba:	68fb      	ldr	r3, [r7, #12]
 800d5bc:	685b      	ldr	r3, [r3, #4]
 800d5be:	4619      	mov	r1, r3
 800d5c0:	4610      	mov	r0, r2
 800d5c2:	f7f3 faed 	bl	8000ba0 <__aeabi_fsub>
 800d5c6:	4603      	mov	r3, r0
 800d5c8:	4619      	mov	r1, r3
 800d5ca:	4620      	mov	r0, r4
 800d5cc:	f7f3 fbf2 	bl	8000db4 <__aeabi_fmul>
 800d5d0:	4603      	mov	r3, r0
 800d5d2:	461a      	mov	r2, r3
 800d5d4:	68fb      	ldr	r3, [r7, #12]
 800d5d6:	689b      	ldr	r3, [r3, #8]
 800d5d8:	4619      	mov	r1, r3
 800d5da:	4610      	mov	r0, r2
 800d5dc:	f7f3 fae2 	bl	8000ba4 <__addsf3>
 800d5e0:	4603      	mov	r3, r0
 800d5e2:	461a      	mov	r2, r3
 800d5e4:	68bb      	ldr	r3, [r7, #8]
 800d5e6:	609a      	str	r2, [r3, #8]
        target->y = envelope->min.y;
 800d5e8:	687b      	ldr	r3, [r7, #4]
 800d5ea:	685a      	ldr	r2, [r3, #4]
 800d5ec:	68bb      	ldr	r3, [r7, #8]
 800d5ee:	605a      	str	r2, [r3, #4]
 800d5f0:	e04c      	b.n	800d68c <clip_3d_target+0x2b4>
    } else if(target->y > envelope->max.y) {
 800d5f2:	68bb      	ldr	r3, [r7, #8]
 800d5f4:	685a      	ldr	r2, [r3, #4]
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	691b      	ldr	r3, [r3, #16]
 800d5fa:	4619      	mov	r1, r3
 800d5fc:	4610      	mov	r0, r2
 800d5fe:	f7f3 fd95 	bl	800112c <__aeabi_fcmpgt>
 800d602:	4603      	mov	r3, r0
 800d604:	2b00      	cmp	r3, #0
 800d606:	d041      	beq.n	800d68c <clip_3d_target+0x2b4>
        target->x = a / b * (envelope->max.y - position->y) + position->x;
 800d608:	69b9      	ldr	r1, [r7, #24]
 800d60a:	69f8      	ldr	r0, [r7, #28]
 800d60c:	f7f3 fc86 	bl	8000f1c <__aeabi_fdiv>
 800d610:	4603      	mov	r3, r0
 800d612:	461c      	mov	r4, r3
 800d614:	687b      	ldr	r3, [r7, #4]
 800d616:	691a      	ldr	r2, [r3, #16]
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	685b      	ldr	r3, [r3, #4]
 800d61c:	4619      	mov	r1, r3
 800d61e:	4610      	mov	r0, r2
 800d620:	f7f3 fabe 	bl	8000ba0 <__aeabi_fsub>
 800d624:	4603      	mov	r3, r0
 800d626:	4619      	mov	r1, r3
 800d628:	4620      	mov	r0, r4
 800d62a:	f7f3 fbc3 	bl	8000db4 <__aeabi_fmul>
 800d62e:	4603      	mov	r3, r0
 800d630:	461a      	mov	r2, r3
 800d632:	68fb      	ldr	r3, [r7, #12]
 800d634:	681b      	ldr	r3, [r3, #0]
 800d636:	4619      	mov	r1, r3
 800d638:	4610      	mov	r0, r2
 800d63a:	f7f3 fab3 	bl	8000ba4 <__addsf3>
 800d63e:	4603      	mov	r3, r0
 800d640:	461a      	mov	r2, r3
 800d642:	68bb      	ldr	r3, [r7, #8]
 800d644:	601a      	str	r2, [r3, #0]
        target->z = c / b * (envelope->max.y - position->y) + position->z;
 800d646:	69b9      	ldr	r1, [r7, #24]
 800d648:	6978      	ldr	r0, [r7, #20]
 800d64a:	f7f3 fc67 	bl	8000f1c <__aeabi_fdiv>
 800d64e:	4603      	mov	r3, r0
 800d650:	461c      	mov	r4, r3
 800d652:	687b      	ldr	r3, [r7, #4]
 800d654:	691a      	ldr	r2, [r3, #16]
 800d656:	68fb      	ldr	r3, [r7, #12]
 800d658:	685b      	ldr	r3, [r3, #4]
 800d65a:	4619      	mov	r1, r3
 800d65c:	4610      	mov	r0, r2
 800d65e:	f7f3 fa9f 	bl	8000ba0 <__aeabi_fsub>
 800d662:	4603      	mov	r3, r0
 800d664:	4619      	mov	r1, r3
 800d666:	4620      	mov	r0, r4
 800d668:	f7f3 fba4 	bl	8000db4 <__aeabi_fmul>
 800d66c:	4603      	mov	r3, r0
 800d66e:	461a      	mov	r2, r3
 800d670:	68fb      	ldr	r3, [r7, #12]
 800d672:	689b      	ldr	r3, [r3, #8]
 800d674:	4619      	mov	r1, r3
 800d676:	4610      	mov	r0, r2
 800d678:	f7f3 fa94 	bl	8000ba4 <__addsf3>
 800d67c:	4603      	mov	r3, r0
 800d67e:	461a      	mov	r2, r3
 800d680:	68bb      	ldr	r3, [r7, #8]
 800d682:	609a      	str	r2, [r3, #8]
        target->y = envelope->max.y;
 800d684:	687b      	ldr	r3, [r7, #4]
 800d686:	691a      	ldr	r2, [r3, #16]
 800d688:	68bb      	ldr	r3, [r7, #8]
 800d68a:	605a      	str	r2, [r3, #4]
    }

    if(target->z < envelope->min.z) {
 800d68c:	68bb      	ldr	r3, [r7, #8]
 800d68e:	689a      	ldr	r2, [r3, #8]
 800d690:	687b      	ldr	r3, [r7, #4]
 800d692:	689b      	ldr	r3, [r3, #8]
 800d694:	4619      	mov	r1, r3
 800d696:	4610      	mov	r0, r2
 800d698:	f7f3 fd2a 	bl	80010f0 <__aeabi_fcmplt>
 800d69c:	4603      	mov	r3, r0
 800d69e:	2b00      	cmp	r3, #0
 800d6a0:	d042      	beq.n	800d728 <clip_3d_target+0x350>
        target->x = a / c * (envelope->min.z - position->z) + position->x;
 800d6a2:	6979      	ldr	r1, [r7, #20]
 800d6a4:	69f8      	ldr	r0, [r7, #28]
 800d6a6:	f7f3 fc39 	bl	8000f1c <__aeabi_fdiv>
 800d6aa:	4603      	mov	r3, r0
 800d6ac:	461c      	mov	r4, r3
 800d6ae:	687b      	ldr	r3, [r7, #4]
 800d6b0:	689a      	ldr	r2, [r3, #8]
 800d6b2:	68fb      	ldr	r3, [r7, #12]
 800d6b4:	689b      	ldr	r3, [r3, #8]
 800d6b6:	4619      	mov	r1, r3
 800d6b8:	4610      	mov	r0, r2
 800d6ba:	f7f3 fa71 	bl	8000ba0 <__aeabi_fsub>
 800d6be:	4603      	mov	r3, r0
 800d6c0:	4619      	mov	r1, r3
 800d6c2:	4620      	mov	r0, r4
 800d6c4:	f7f3 fb76 	bl	8000db4 <__aeabi_fmul>
 800d6c8:	4603      	mov	r3, r0
 800d6ca:	461a      	mov	r2, r3
 800d6cc:	68fb      	ldr	r3, [r7, #12]
 800d6ce:	681b      	ldr	r3, [r3, #0]
 800d6d0:	4619      	mov	r1, r3
 800d6d2:	4610      	mov	r0, r2
 800d6d4:	f7f3 fa66 	bl	8000ba4 <__addsf3>
 800d6d8:	4603      	mov	r3, r0
 800d6da:	461a      	mov	r2, r3
 800d6dc:	68bb      	ldr	r3, [r7, #8]
 800d6de:	601a      	str	r2, [r3, #0]
        target->y = b / c * (envelope->min.z - position->z) + position->y;
 800d6e0:	6979      	ldr	r1, [r7, #20]
 800d6e2:	69b8      	ldr	r0, [r7, #24]
 800d6e4:	f7f3 fc1a 	bl	8000f1c <__aeabi_fdiv>
 800d6e8:	4603      	mov	r3, r0
 800d6ea:	461c      	mov	r4, r3
 800d6ec:	687b      	ldr	r3, [r7, #4]
 800d6ee:	689a      	ldr	r2, [r3, #8]
 800d6f0:	68fb      	ldr	r3, [r7, #12]
 800d6f2:	689b      	ldr	r3, [r3, #8]
 800d6f4:	4619      	mov	r1, r3
 800d6f6:	4610      	mov	r0, r2
 800d6f8:	f7f3 fa52 	bl	8000ba0 <__aeabi_fsub>
 800d6fc:	4603      	mov	r3, r0
 800d6fe:	4619      	mov	r1, r3
 800d700:	4620      	mov	r0, r4
 800d702:	f7f3 fb57 	bl	8000db4 <__aeabi_fmul>
 800d706:	4603      	mov	r3, r0
 800d708:	461a      	mov	r2, r3
 800d70a:	68fb      	ldr	r3, [r7, #12]
 800d70c:	685b      	ldr	r3, [r3, #4]
 800d70e:	4619      	mov	r1, r3
 800d710:	4610      	mov	r0, r2
 800d712:	f7f3 fa47 	bl	8000ba4 <__addsf3>
 800d716:	4603      	mov	r3, r0
 800d718:	461a      	mov	r2, r3
 800d71a:	68bb      	ldr	r3, [r7, #8]
 800d71c:	605a      	str	r2, [r3, #4]
        target->z = envelope->min.z;
 800d71e:	687b      	ldr	r3, [r7, #4]
 800d720:	689a      	ldr	r2, [r3, #8]
 800d722:	68bb      	ldr	r3, [r7, #8]
 800d724:	609a      	str	r2, [r3, #8]
    } else if(target->z > envelope->max.z) {
        target->x = a / c * (envelope->max.z - position->z) + position->x;
        target->y = b / c * (envelope->max.z - position->z) + position->y;
        target->z = envelope->max.z;
    }
}
 800d726:	e04d      	b.n	800d7c4 <clip_3d_target+0x3ec>
    } else if(target->z > envelope->max.z) {
 800d728:	68bb      	ldr	r3, [r7, #8]
 800d72a:	689a      	ldr	r2, [r3, #8]
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	695b      	ldr	r3, [r3, #20]
 800d730:	4619      	mov	r1, r3
 800d732:	4610      	mov	r0, r2
 800d734:	f7f3 fcfa 	bl	800112c <__aeabi_fcmpgt>
 800d738:	4603      	mov	r3, r0
 800d73a:	2b00      	cmp	r3, #0
 800d73c:	d100      	bne.n	800d740 <clip_3d_target+0x368>
}
 800d73e:	e041      	b.n	800d7c4 <clip_3d_target+0x3ec>
        target->x = a / c * (envelope->max.z - position->z) + position->x;
 800d740:	6979      	ldr	r1, [r7, #20]
 800d742:	69f8      	ldr	r0, [r7, #28]
 800d744:	f7f3 fbea 	bl	8000f1c <__aeabi_fdiv>
 800d748:	4603      	mov	r3, r0
 800d74a:	461c      	mov	r4, r3
 800d74c:	687b      	ldr	r3, [r7, #4]
 800d74e:	695a      	ldr	r2, [r3, #20]
 800d750:	68fb      	ldr	r3, [r7, #12]
 800d752:	689b      	ldr	r3, [r3, #8]
 800d754:	4619      	mov	r1, r3
 800d756:	4610      	mov	r0, r2
 800d758:	f7f3 fa22 	bl	8000ba0 <__aeabi_fsub>
 800d75c:	4603      	mov	r3, r0
 800d75e:	4619      	mov	r1, r3
 800d760:	4620      	mov	r0, r4
 800d762:	f7f3 fb27 	bl	8000db4 <__aeabi_fmul>
 800d766:	4603      	mov	r3, r0
 800d768:	461a      	mov	r2, r3
 800d76a:	68fb      	ldr	r3, [r7, #12]
 800d76c:	681b      	ldr	r3, [r3, #0]
 800d76e:	4619      	mov	r1, r3
 800d770:	4610      	mov	r0, r2
 800d772:	f7f3 fa17 	bl	8000ba4 <__addsf3>
 800d776:	4603      	mov	r3, r0
 800d778:	461a      	mov	r2, r3
 800d77a:	68bb      	ldr	r3, [r7, #8]
 800d77c:	601a      	str	r2, [r3, #0]
        target->y = b / c * (envelope->max.z - position->z) + position->y;
 800d77e:	6979      	ldr	r1, [r7, #20]
 800d780:	69b8      	ldr	r0, [r7, #24]
 800d782:	f7f3 fbcb 	bl	8000f1c <__aeabi_fdiv>
 800d786:	4603      	mov	r3, r0
 800d788:	461c      	mov	r4, r3
 800d78a:	687b      	ldr	r3, [r7, #4]
 800d78c:	695a      	ldr	r2, [r3, #20]
 800d78e:	68fb      	ldr	r3, [r7, #12]
 800d790:	689b      	ldr	r3, [r3, #8]
 800d792:	4619      	mov	r1, r3
 800d794:	4610      	mov	r0, r2
 800d796:	f7f3 fa03 	bl	8000ba0 <__aeabi_fsub>
 800d79a:	4603      	mov	r3, r0
 800d79c:	4619      	mov	r1, r3
 800d79e:	4620      	mov	r0, r4
 800d7a0:	f7f3 fb08 	bl	8000db4 <__aeabi_fmul>
 800d7a4:	4603      	mov	r3, r0
 800d7a6:	461a      	mov	r2, r3
 800d7a8:	68fb      	ldr	r3, [r7, #12]
 800d7aa:	685b      	ldr	r3, [r3, #4]
 800d7ac:	4619      	mov	r1, r3
 800d7ae:	4610      	mov	r0, r2
 800d7b0:	f7f3 f9f8 	bl	8000ba4 <__addsf3>
 800d7b4:	4603      	mov	r3, r0
 800d7b6:	461a      	mov	r2, r3
 800d7b8:	68bb      	ldr	r3, [r7, #8]
 800d7ba:	605a      	str	r2, [r3, #4]
        target->z = envelope->max.z;
 800d7bc:	687b      	ldr	r3, [r7, #4]
 800d7be:	695a      	ldr	r2, [r3, #20]
 800d7c0:	68bb      	ldr	r3, [r7, #8]
 800d7c2:	609a      	str	r2, [r3, #8]
}
 800d7c4:	bf00      	nop
 800d7c6:	3724      	adds	r7, #36	; 0x24
 800d7c8:	46bd      	mov	sp, r7
 800d7ca:	bd90      	pop	{r4, r7, pc}

0800d7cc <apply_jog_limits>:

// Limits jog commands to be within machine limits, homed axes only.
static void apply_jog_limits (float *target, float *position)
{
 800d7cc:	b580      	push	{r7, lr}
 800d7ce:	b084      	sub	sp, #16
 800d7d0:	af00      	add	r7, sp, #0
 800d7d2:	6078      	str	r0, [r7, #4]
 800d7d4:	6039      	str	r1, [r7, #0]
    if(sys.homed.mask == 0)
 800d7d6:	4b5d      	ldr	r3, [pc, #372]	; (800d94c <apply_jog_limits+0x180>)
 800d7d8:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800d7dc:	2b00      	cmp	r3, #0
 800d7de:	f000 80b0 	beq.w	800d942 <apply_jog_limits+0x176>
        return;

    uint_fast8_t idx;

    if((sys.homed.mask & 0b111) == 0b111) {
 800d7e2:	4b5a      	ldr	r3, [pc, #360]	; (800d94c <apply_jog_limits+0x180>)
 800d7e4:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800d7e8:	f003 0307 	and.w	r3, r3, #7
 800d7ec:	2b07      	cmp	r3, #7
 800d7ee:	d12e      	bne.n	800d84e <apply_jog_limits+0x82>

        uint_fast8_t n_axes = 0;
 800d7f0:	2300      	movs	r3, #0
 800d7f2:	60bb      	str	r3, [r7, #8]

        idx = Z_AXIS + 1;
 800d7f4:	2303      	movs	r3, #3
 800d7f6:	60fb      	str	r3, [r7, #12]
        do {
            idx--;
 800d7f8:	68fb      	ldr	r3, [r7, #12]
 800d7fa:	3b01      	subs	r3, #1
 800d7fc:	60fb      	str	r3, [r7, #12]
            if(fabs(target[idx] - position[idx]) > 0.001f)
 800d7fe:	68fb      	ldr	r3, [r7, #12]
 800d800:	009b      	lsls	r3, r3, #2
 800d802:	687a      	ldr	r2, [r7, #4]
 800d804:	4413      	add	r3, r2
 800d806:	6818      	ldr	r0, [r3, #0]
 800d808:	68fb      	ldr	r3, [r7, #12]
 800d80a:	009b      	lsls	r3, r3, #2
 800d80c:	683a      	ldr	r2, [r7, #0]
 800d80e:	4413      	add	r3, r2
 800d810:	681b      	ldr	r3, [r3, #0]
 800d812:	4619      	mov	r1, r3
 800d814:	f7f3 f9c4 	bl	8000ba0 <__aeabi_fsub>
 800d818:	4603      	mov	r3, r0
 800d81a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800d81e:	494c      	ldr	r1, [pc, #304]	; (800d950 <apply_jog_limits+0x184>)
 800d820:	4618      	mov	r0, r3
 800d822:	f7f3 fc83 	bl	800112c <__aeabi_fcmpgt>
 800d826:	4603      	mov	r3, r0
 800d828:	2b00      	cmp	r3, #0
 800d82a:	d002      	beq.n	800d832 <apply_jog_limits+0x66>
                n_axes++;
 800d82c:	68bb      	ldr	r3, [r7, #8]
 800d82e:	3301      	adds	r3, #1
 800d830:	60bb      	str	r3, [r7, #8]
        } while(idx && n_axes < 2);
 800d832:	68fb      	ldr	r3, [r7, #12]
 800d834:	2b00      	cmp	r3, #0
 800d836:	d002      	beq.n	800d83e <apply_jog_limits+0x72>
 800d838:	68bb      	ldr	r3, [r7, #8]
 800d83a:	2b01      	cmp	r3, #1
 800d83c:	d9dc      	bls.n	800d7f8 <apply_jog_limits+0x2c>

        if(n_axes > 1)
 800d83e:	68bb      	ldr	r3, [r7, #8]
 800d840:	2b01      	cmp	r3, #1
 800d842:	d904      	bls.n	800d84e <apply_jog_limits+0x82>
            clip_3d_target((coord_data_t *)position, (coord_data_t *)target, &sys.work_envelope);
 800d844:	4a43      	ldr	r2, [pc, #268]	; (800d954 <apply_jog_limits+0x188>)
 800d846:	6879      	ldr	r1, [r7, #4]
 800d848:	6838      	ldr	r0, [r7, #0]
 800d84a:	f7ff fdc5 	bl	800d3d8 <clip_3d_target>
    }

    idx = N_AXIS;
 800d84e:	2303      	movs	r3, #3
 800d850:	60fb      	str	r3, [r7, #12]
    do {
        idx--;
 800d852:	68fb      	ldr	r3, [r7, #12]
 800d854:	3b01      	subs	r3, #1
 800d856:	60fb      	str	r3, [r7, #12]
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.axis[idx].max_travel < -0.0f)
 800d858:	4b3c      	ldr	r3, [pc, #240]	; (800d94c <apply_jog_limits+0x180>)
 800d85a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800d85e:	461a      	mov	r2, r3
 800d860:	68fb      	ldr	r3, [r7, #12]
 800d862:	fa22 f303 	lsr.w	r3, r2, r3
 800d866:	f003 0301 	and.w	r3, r3, #1
 800d86a:	2b00      	cmp	r3, #0
 800d86c:	d065      	beq.n	800d93a <apply_jog_limits+0x16e>
 800d86e:	493a      	ldr	r1, [pc, #232]	; (800d958 <apply_jog_limits+0x18c>)
 800d870:	68fa      	ldr	r2, [r7, #12]
 800d872:	4613      	mov	r3, r2
 800d874:	009b      	lsls	r3, r3, #2
 800d876:	4413      	add	r3, r2
 800d878:	009b      	lsls	r3, r3, #2
 800d87a:	440b      	add	r3, r1
 800d87c:	333c      	adds	r3, #60	; 0x3c
 800d87e:	681b      	ldr	r3, [r3, #0]
 800d880:	f04f 0100 	mov.w	r1, #0
 800d884:	4618      	mov	r0, r3
 800d886:	f7f3 fc33 	bl	80010f0 <__aeabi_fcmplt>
 800d88a:	4603      	mov	r3, r0
 800d88c:	2b00      	cmp	r3, #0
 800d88e:	d054      	beq.n	800d93a <apply_jog_limits+0x16e>
            target[idx] = max(min(target[idx], sys.work_envelope.max.values[idx]), sys.work_envelope.min.values[idx]);
 800d890:	68fb      	ldr	r3, [r7, #12]
 800d892:	009b      	lsls	r3, r3, #2
 800d894:	687a      	ldr	r2, [r7, #4]
 800d896:	4413      	add	r3, r2
 800d898:	681a      	ldr	r2, [r3, #0]
 800d89a:	492c      	ldr	r1, [pc, #176]	; (800d94c <apply_jog_limits+0x180>)
 800d89c:	68fb      	ldr	r3, [r7, #12]
 800d89e:	331a      	adds	r3, #26
 800d8a0:	009b      	lsls	r3, r3, #2
 800d8a2:	440b      	add	r3, r1
 800d8a4:	689b      	ldr	r3, [r3, #8]
 800d8a6:	4619      	mov	r1, r3
 800d8a8:	4610      	mov	r0, r2
 800d8aa:	f7f3 fc21 	bl	80010f0 <__aeabi_fcmplt>
 800d8ae:	4603      	mov	r3, r0
 800d8b0:	2b00      	cmp	r3, #0
 800d8b2:	d005      	beq.n	800d8c0 <apply_jog_limits+0xf4>
 800d8b4:	68fb      	ldr	r3, [r7, #12]
 800d8b6:	009b      	lsls	r3, r3, #2
 800d8b8:	687a      	ldr	r2, [r7, #4]
 800d8ba:	4413      	add	r3, r2
 800d8bc:	681a      	ldr	r2, [r3, #0]
 800d8be:	e005      	b.n	800d8cc <apply_jog_limits+0x100>
 800d8c0:	4a22      	ldr	r2, [pc, #136]	; (800d94c <apply_jog_limits+0x180>)
 800d8c2:	68fb      	ldr	r3, [r7, #12]
 800d8c4:	331a      	adds	r3, #26
 800d8c6:	009b      	lsls	r3, r3, #2
 800d8c8:	4413      	add	r3, r2
 800d8ca:	689a      	ldr	r2, [r3, #8]
 800d8cc:	491f      	ldr	r1, [pc, #124]	; (800d94c <apply_jog_limits+0x180>)
 800d8ce:	68fb      	ldr	r3, [r7, #12]
 800d8d0:	3318      	adds	r3, #24
 800d8d2:	009b      	lsls	r3, r3, #2
 800d8d4:	440b      	add	r3, r1
 800d8d6:	685b      	ldr	r3, [r3, #4]
 800d8d8:	4619      	mov	r1, r3
 800d8da:	4610      	mov	r0, r2
 800d8dc:	f7f3 fc26 	bl	800112c <__aeabi_fcmpgt>
 800d8e0:	4603      	mov	r3, r0
 800d8e2:	2b00      	cmp	r3, #0
 800d8e4:	d01e      	beq.n	800d924 <apply_jog_limits+0x158>
 800d8e6:	68fb      	ldr	r3, [r7, #12]
 800d8e8:	009b      	lsls	r3, r3, #2
 800d8ea:	687a      	ldr	r2, [r7, #4]
 800d8ec:	4413      	add	r3, r2
 800d8ee:	681a      	ldr	r2, [r3, #0]
 800d8f0:	4916      	ldr	r1, [pc, #88]	; (800d94c <apply_jog_limits+0x180>)
 800d8f2:	68fb      	ldr	r3, [r7, #12]
 800d8f4:	331a      	adds	r3, #26
 800d8f6:	009b      	lsls	r3, r3, #2
 800d8f8:	440b      	add	r3, r1
 800d8fa:	689b      	ldr	r3, [r3, #8]
 800d8fc:	4619      	mov	r1, r3
 800d8fe:	4610      	mov	r0, r2
 800d900:	f7f3 fbf6 	bl	80010f0 <__aeabi_fcmplt>
 800d904:	4603      	mov	r3, r0
 800d906:	2b00      	cmp	r3, #0
 800d908:	d005      	beq.n	800d916 <apply_jog_limits+0x14a>
 800d90a:	68fb      	ldr	r3, [r7, #12]
 800d90c:	009b      	lsls	r3, r3, #2
 800d90e:	687a      	ldr	r2, [r7, #4]
 800d910:	4413      	add	r3, r2
 800d912:	681b      	ldr	r3, [r3, #0]
 800d914:	e00c      	b.n	800d930 <apply_jog_limits+0x164>
 800d916:	4a0d      	ldr	r2, [pc, #52]	; (800d94c <apply_jog_limits+0x180>)
 800d918:	68fb      	ldr	r3, [r7, #12]
 800d91a:	331a      	adds	r3, #26
 800d91c:	009b      	lsls	r3, r3, #2
 800d91e:	4413      	add	r3, r2
 800d920:	689b      	ldr	r3, [r3, #8]
 800d922:	e005      	b.n	800d930 <apply_jog_limits+0x164>
 800d924:	4a09      	ldr	r2, [pc, #36]	; (800d94c <apply_jog_limits+0x180>)
 800d926:	68fb      	ldr	r3, [r7, #12]
 800d928:	3318      	adds	r3, #24
 800d92a:	009b      	lsls	r3, r3, #2
 800d92c:	4413      	add	r3, r2
 800d92e:	685b      	ldr	r3, [r3, #4]
 800d930:	68fa      	ldr	r2, [r7, #12]
 800d932:	0092      	lsls	r2, r2, #2
 800d934:	6879      	ldr	r1, [r7, #4]
 800d936:	440a      	add	r2, r1
 800d938:	6013      	str	r3, [r2, #0]
    } while(idx);
 800d93a:	68fb      	ldr	r3, [r7, #12]
 800d93c:	2b00      	cmp	r3, #0
 800d93e:	d188      	bne.n	800d852 <apply_jog_limits+0x86>
 800d940:	e000      	b.n	800d944 <apply_jog_limits+0x178>
        return;
 800d942:	bf00      	nop
}
 800d944:	3710      	adds	r7, #16
 800d946:	46bd      	mov	sp, r7
 800d948:	bd80      	pop	{r7, pc}
 800d94a:	bf00      	nop
 800d94c:	20000d3c 	.word	0x20000d3c
 800d950:	3a83126f 	.word	0x3a83126f
 800d954:	20000da0 	.word	0x20000da0
 800d958:	2000147c 	.word	0x2000147c

0800d95c <limits_init>:

void limits_init (void)
{
 800d95c:	b480      	push	{r7}
 800d95e:	af00      	add	r7, sp, #0
    hal.homing.get_feedrate = get_homing_rate;
 800d960:	4b0b      	ldr	r3, [pc, #44]	; (800d990 <limits_init+0x34>)
 800d962:	4a0c      	ldr	r2, [pc, #48]	; (800d994 <limits_init+0x38>)
 800d964:	665a      	str	r2, [r3, #100]	; 0x64
    grbl.check_travel_limits = check_travel_limits;
 800d966:	4b0c      	ldr	r3, [pc, #48]	; (800d998 <limits_init+0x3c>)
 800d968:	4a0c      	ldr	r2, [pc, #48]	; (800d99c <limits_init+0x40>)
 800d96a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    grbl.check_arc_travel_limits = check_arc_travel_limits;
 800d96e:	4b0a      	ldr	r3, [pc, #40]	; (800d998 <limits_init+0x3c>)
 800d970:	4a0b      	ldr	r2, [pc, #44]	; (800d9a0 <limits_init+0x44>)
 800d972:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
    grbl.apply_jog_limits = apply_jog_limits;
 800d976:	4b08      	ldr	r3, [pc, #32]	; (800d998 <limits_init+0x3c>)
 800d978:	4a0a      	ldr	r2, [pc, #40]	; (800d9a4 <limits_init+0x48>)
 800d97a:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    grbl.home_machine = homing_cycle;
 800d97e:	4b06      	ldr	r3, [pc, #24]	; (800d998 <limits_init+0x3c>)
 800d980:	4a09      	ldr	r2, [pc, #36]	; (800d9a8 <limits_init+0x4c>)
 800d982:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
}
 800d986:	bf00      	nop
 800d988:	46bd      	mov	sp, r7
 800d98a:	bc80      	pop	{r7}
 800d98c:	4770      	bx	lr
 800d98e:	bf00      	nop
 800d990:	20000ed0 	.word	0x20000ed0
 800d994:	0800cda1 	.word	0x0800cda1
 800d998:	20000dd4 	.word	0x20000dd4
 800d99c:	0800cdd1 	.word	0x0800cdd1
 800d9a0:	0800cec1 	.word	0x0800cec1
 800d9a4:	0800d7cd 	.word	0x0800d7cd
 800d9a8:	0800c3bd 	.word	0x0800c3bd

0800d9ac <message_get>:
    { .id = Message_ExecuteTPW, .text = "Perform a probe with $TPW first!", .type = Message_Warning},
    { .id = Message_ProbeProtected, .text = "Probe protection activated."}
};

const message_t *message_get (message_code_t id)
{
 800d9ac:	b480      	push	{r7}
 800d9ae:	b085      	sub	sp, #20
 800d9b0:	af00      	add	r7, sp, #0
 800d9b2:	4603      	mov	r3, r0
 800d9b4:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx = 0;
 800d9b6:	2300      	movs	r3, #0
 800d9b8:	60fb      	str	r3, [r7, #12]
    const message_t *msg = NULL;
 800d9ba:	2300      	movs	r3, #0
 800d9bc:	60bb      	str	r3, [r7, #8]

    do {
        if(messages[idx].id == id)
 800d9be:	4a0d      	ldr	r2, [pc, #52]	; (800d9f4 <message_get+0x48>)
 800d9c0:	68fb      	ldr	r3, [r7, #12]
 800d9c2:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
 800d9c6:	79fa      	ldrb	r2, [r7, #7]
 800d9c8:	429a      	cmp	r2, r3
 800d9ca:	d104      	bne.n	800d9d6 <message_get+0x2a>
            msg = &messages[idx];
 800d9cc:	68fb      	ldr	r3, [r7, #12]
 800d9ce:	00db      	lsls	r3, r3, #3
 800d9d0:	4a08      	ldr	r2, [pc, #32]	; (800d9f4 <message_get+0x48>)
 800d9d2:	4413      	add	r3, r2
 800d9d4:	60bb      	str	r3, [r7, #8]
    } while(msg == NULL && ++idx < Message_NextMessage);
 800d9d6:	68bb      	ldr	r3, [r7, #8]
 800d9d8:	2b00      	cmp	r3, #0
 800d9da:	d105      	bne.n	800d9e8 <message_get+0x3c>
 800d9dc:	68fb      	ldr	r3, [r7, #12]
 800d9de:	3301      	adds	r3, #1
 800d9e0:	60fb      	str	r3, [r7, #12]
 800d9e2:	68fb      	ldr	r3, [r7, #12]
 800d9e4:	2b15      	cmp	r3, #21
 800d9e6:	d9ea      	bls.n	800d9be <message_get+0x12>

    return msg;
 800d9e8:	68bb      	ldr	r3, [r7, #8]
}
 800d9ea:	4618      	mov	r0, r3
 800d9ec:	3714      	adds	r7, #20
 800d9ee:	46bd      	mov	sp, r7
 800d9f0:	bc80      	pop	{r7}
 800d9f2:	4770      	bx	lr
 800d9f4:	08030c8c 	.word	0x08030c8c

0800d9f8 <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The separation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
bool mc_line (float *target, plan_line_data_t *pl_data)
{
 800d9f8:	b590      	push	{r4, r7, lr}
 800d9fa:	b085      	sub	sp, #20
 800d9fc:	af00      	add	r7, sp, #0
 800d9fe:	6078      	str	r0, [r7, #4]
 800da00:	6039      	str	r1, [r7, #0]
#ifdef KINEMATICS_API
    float feed_rate = pl_data->feed_rate;
 800da02:	683b      	ldr	r3, [r7, #0]
 800da04:	681b      	ldr	r3, [r3, #0]
 800da06:	60fb      	str	r3, [r7, #12]
    pl_data->rate_multiplier = 1.0;
 800da08:	683b      	ldr	r3, [r7, #0]
 800da0a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 800da0e:	605a      	str	r2, [r3, #4]
    target = kinematics.segment_line(target, plan_get_position(), pl_data, true);
 800da10:	4b55      	ldr	r3, [pc, #340]	; (800db68 <mc_line+0x170>)
 800da12:	689c      	ldr	r4, [r3, #8]
 800da14:	f004 fbb6 	bl	8012184 <plan_get_position>
 800da18:	4601      	mov	r1, r0
 800da1a:	2301      	movs	r3, #1
 800da1c:	683a      	ldr	r2, [r7, #0]
 800da1e:	6878      	ldr	r0, [r7, #4]
 800da20:	47a0      	blx	r4
 800da22:	6078      	str	r0, [r7, #4]
#endif

    // If enabled, check for soft limit violations. Placed here all line motions are picked up
    // from everywhere in Grbl.
    if(!(pl_data->condition.target_validated && pl_data->condition.target_valid))
 800da24:	683b      	ldr	r3, [r7, #0]
 800da26:	7e5b      	ldrb	r3, [r3, #25]
 800da28:	f003 0302 	and.w	r3, r3, #2
 800da2c:	b2db      	uxtb	r3, r3
 800da2e:	2b00      	cmp	r3, #0
 800da30:	d006      	beq.n	800da40 <mc_line+0x48>
 800da32:	683b      	ldr	r3, [r7, #0]
 800da34:	7e5b      	ldrb	r3, [r3, #25]
 800da36:	f003 0301 	and.w	r3, r3, #1
 800da3a:	b2db      	uxtb	r3, r3
 800da3c:	2b00      	cmp	r3, #0
 800da3e:	d104      	bne.n	800da4a <mc_line+0x52>
        limits_soft_check(target, pl_data->condition);
 800da40:	683b      	ldr	r3, [r7, #0]
 800da42:	6999      	ldr	r1, [r3, #24]
 800da44:	6878      	ldr	r0, [r7, #4]
 800da46:	f7ff f8e9 	bl	800cc1c <limits_soft_check>

    // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
    if(state_get() != STATE_CHECK_MODE && protocol_execute_realtime()) {
 800da4a:	f00f ff39 	bl	801d8c0 <state_get>
 800da4e:	4603      	mov	r3, r0
 800da50:	2b02      	cmp	r3, #2
 800da52:	d071      	beq.n	800db38 <mc_line+0x140>
 800da54:	f005 f984 	bl	8012d60 <protocol_execute_realtime>
 800da58:	4603      	mov	r3, r0
 800da5a:	2b00      	cmp	r3, #0
 800da5c:	d06c      	beq.n	800db38 <mc_line+0x140>
        // indicates to Grbl what is a backlash compensation motion, so that Grbl executes the move but
        // doesn't update the machine position values. Since the position values used by the g-code
        // parser and planner are separate from the system machine positions, this is doable.

#ifdef KINEMATICS_API
      while(kinematics.segment_line(target, NULL, pl_data, false)) {
 800da5e:	e05e      	b.n	800db1e <mc_line+0x126>
#endif // Backlash comp

        // If the buffer is full: good! That means we are well ahead of the robot.
        // Remain in this loop until there is room in the buffer.
         do {
            if(!protocol_execute_realtime())    // Check for any run-time commands
 800da60:	f005 f97e 	bl	8012d60 <protocol_execute_realtime>
 800da64:	4603      	mov	r3, r0
 800da66:	f083 0301 	eor.w	r3, r3, #1
 800da6a:	b2db      	uxtb	r3, r3
 800da6c:	2b00      	cmp	r3, #0
 800da6e:	d001      	beq.n	800da74 <mc_line+0x7c>
                return false;                   // Bail, if system abort.
 800da70:	2300      	movs	r3, #0
 800da72:	e075      	b.n	800db60 <mc_line+0x168>
            if(plan_check_full_buffer())
 800da74:	f003 ff60 	bl	8011938 <plan_check_full_buffer>
 800da78:	4603      	mov	r3, r0
 800da7a:	2b00      	cmp	r3, #0
 800da7c:	d002      	beq.n	800da84 <mc_line+0x8c>
                protocol_auto_cycle_start();    // Auto-cycle start when buffer is full.
 800da7e:	f005 f95d 	bl	8012d3c <protocol_auto_cycle_start>
            if(!protocol_execute_realtime())    // Check for any run-time commands
 800da82:	e7ed      	b.n	800da60 <mc_line+0x68>
            else
                break;
 800da84:	bf00      	nop
        } while(true);

        // Plan and queue motion into planner buffer.
        // While in M3 laser mode also set spindle state and force a buffer sync
        // if there is a coincident position passed.
        if(!plan_buffer_line(target, pl_data) && pl_data->spindle.hal->cap.laser && pl_data->spindle.state.on && !pl_data->spindle.state.ccw) {
 800da86:	6839      	ldr	r1, [r7, #0]
 800da88:	6878      	ldr	r0, [r7, #4]
 800da8a:	f004 f8b5 	bl	8011bf8 <plan_buffer_line>
 800da8e:	4603      	mov	r3, r0
 800da90:	f083 0301 	eor.w	r3, r3, #1
 800da94:	b2db      	uxtb	r3, r3
 800da96:	2b00      	cmp	r3, #0
 800da98:	d021      	beq.n	800dade <mc_line+0xe6>
 800da9a:	683b      	ldr	r3, [r7, #0]
 800da9c:	695b      	ldr	r3, [r3, #20]
 800da9e:	7a9b      	ldrb	r3, [r3, #10]
 800daa0:	f003 0308 	and.w	r3, r3, #8
 800daa4:	b2db      	uxtb	r3, r3
 800daa6:	2b00      	cmp	r3, #0
 800daa8:	d019      	beq.n	800dade <mc_line+0xe6>
 800daaa:	683b      	ldr	r3, [r7, #0]
 800daac:	7b1b      	ldrb	r3, [r3, #12]
 800daae:	f003 0301 	and.w	r3, r3, #1
 800dab2:	b2db      	uxtb	r3, r3
 800dab4:	2b00      	cmp	r3, #0
 800dab6:	d012      	beq.n	800dade <mc_line+0xe6>
 800dab8:	683b      	ldr	r3, [r7, #0]
 800daba:	7b1b      	ldrb	r3, [r3, #12]
 800dabc:	f003 0302 	and.w	r3, r3, #2
 800dac0:	b2db      	uxtb	r3, r3
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	d10b      	bne.n	800dade <mc_line+0xe6>
            protocol_buffer_synchronize();
 800dac6:	f005 f91b 	bl	8012d00 <protocol_buffer_synchronize>
            pl_data->spindle.hal->set_state(pl_data->spindle.hal, pl_data->spindle.state, pl_data->spindle.rpm);
 800daca:	683b      	ldr	r3, [r7, #0]
 800dacc:	695b      	ldr	r3, [r3, #20]
 800dace:	6a1b      	ldr	r3, [r3, #32]
 800dad0:	683a      	ldr	r2, [r7, #0]
 800dad2:	6950      	ldr	r0, [r2, #20]
 800dad4:	683a      	ldr	r2, [r7, #0]
 800dad6:	6892      	ldr	r2, [r2, #8]
 800dad8:	6839      	ldr	r1, [r7, #0]
 800dada:	7b09      	ldrb	r1, [r1, #12]
 800dadc:	4798      	blx	r3
        }

#ifdef KINEMATICS_API
        if(pl_data->condition.jog_motion) {
 800dade:	683b      	ldr	r3, [r7, #0]
 800dae0:	7e1b      	ldrb	r3, [r3, #24]
 800dae2:	f003 0304 	and.w	r3, r3, #4
 800dae6:	b2db      	uxtb	r3, r3
 800dae8:	2b00      	cmp	r3, #0
 800daea:	d015      	beq.n	800db18 <mc_line+0x120>
            sys_state_t state = state_get();
 800daec:	f00f fee8 	bl	801d8c0 <state_get>
 800daf0:	60b8      	str	r0, [r7, #8]
            if ((state == STATE_IDLE || state == STATE_TOOL_CHANGE) && plan_get_current_block() != NULL) { // Check if there is a block to execute.
 800daf2:	68bb      	ldr	r3, [r7, #8]
 800daf4:	2b00      	cmp	r3, #0
 800daf6:	d003      	beq.n	800db00 <mc_line+0x108>
 800daf8:	68bb      	ldr	r3, [r7, #8]
 800dafa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800dafe:	d10b      	bne.n	800db18 <mc_line+0x120>
 800db00:	f003 feec 	bl	80118dc <plan_get_current_block>
 800db04:	4603      	mov	r3, r0
 800db06:	2b00      	cmp	r3, #0
 800db08:	d006      	beq.n	800db18 <mc_line+0x120>
                state_set(STATE_JOG);
 800db0a:	2020      	movs	r0, #32
 800db0c:	f00f fee2 	bl	801d8d4 <state_set>
                st_prep_buffer();
 800db10:	f011 fbe6 	bl	801f2e0 <st_prep_buffer>
                st_wake_up();  // NOTE: Manual start. No state machine required.
 800db14:	f010 ffbe 	bl	801ea94 <st_wake_up>
            }
        }

        pl_data->feed_rate = feed_rate;
 800db18:	683b      	ldr	r3, [r7, #0]
 800db1a:	68fa      	ldr	r2, [r7, #12]
 800db1c:	601a      	str	r2, [r3, #0]
      while(kinematics.segment_line(target, NULL, pl_data, false)) {
 800db1e:	4b12      	ldr	r3, [pc, #72]	; (800db68 <mc_line+0x170>)
 800db20:	689c      	ldr	r4, [r3, #8]
 800db22:	2300      	movs	r3, #0
 800db24:	683a      	ldr	r2, [r7, #0]
 800db26:	2100      	movs	r1, #0
 800db28:	6878      	ldr	r0, [r7, #4]
 800db2a:	47a0      	blx	r4
 800db2c:	4603      	mov	r3, r0
 800db2e:	2b00      	cmp	r3, #0
 800db30:	d196      	bne.n	800da60 <mc_line+0x68>
      } // while(kinematics.segment_line()

      pl_data->feed_rate = feed_rate;
 800db32:	683b      	ldr	r3, [r7, #0]
 800db34:	68fa      	ldr	r2, [r7, #12]
 800db36:	601a      	str	r2, [r3, #0]
#endif
    }

    return !ABORTED;
 800db38:	4b0c      	ldr	r3, [pc, #48]	; (800db6c <mc_line+0x174>)
 800db3a:	781b      	ldrb	r3, [r3, #0]
 800db3c:	f083 0301 	eor.w	r3, r3, #1
 800db40:	b2db      	uxtb	r3, r3
 800db42:	2b00      	cmp	r3, #0
 800db44:	d008      	beq.n	800db58 <mc_line+0x160>
 800db46:	4b09      	ldr	r3, [pc, #36]	; (800db6c <mc_line+0x174>)
 800db48:	785b      	ldrb	r3, [r3, #1]
 800db4a:	f083 0301 	eor.w	r3, r3, #1
 800db4e:	b2db      	uxtb	r3, r3
 800db50:	2b00      	cmp	r3, #0
 800db52:	d001      	beq.n	800db58 <mc_line+0x160>
 800db54:	2301      	movs	r3, #1
 800db56:	e000      	b.n	800db5a <mc_line+0x162>
 800db58:	2300      	movs	r3, #0
 800db5a:	f003 0301 	and.w	r3, r3, #1
 800db5e:	b2db      	uxtb	r3, r3
}
 800db60:	4618      	mov	r0, r3
 800db62:	3714      	adds	r7, #20
 800db64:	46bd      	mov	sp, r7
 800db66:	bd90      	pop	{r4, r7, pc}
 800db68:	20001088 	.word	0x20001088
 800db6c:	20000d3c 	.word	0x20000d3c

0800db70 <mc_arc>:
// for vector transformation direction and number of full turns to add (abs(turns) - 1).
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc (float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius, plane_t plane, int32_t turns)
{
 800db70:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800db74:	b0a8      	sub	sp, #160	; 0xa0
 800db76:	af04      	add	r7, sp, #16
 800db78:	60f8      	str	r0, [r7, #12]
 800db7a:	60b9      	str	r1, [r7, #8]
 800db7c:	607a      	str	r2, [r7, #4]
 800db7e:	603b      	str	r3, [r7, #0]
            double y;
        };
    } point_2dd_t;

    point_2dd_t rv = {  // Radius vector from center to current location
        .x = -(double)offset[plane.axis_0],
 800db80:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800db84:	009b      	lsls	r3, r3, #2
 800db86:	683a      	ldr	r2, [r7, #0]
 800db88:	4413      	add	r3, r2
 800db8a:	681b      	ldr	r3, [r3, #0]
 800db8c:	4618      	mov	r0, r3
 800db8e:	f7f2 fcc1 	bl	8000514 <__aeabi_f2d>
 800db92:	4602      	mov	r2, r0
 800db94:	460b      	mov	r3, r1
 800db96:	4690      	mov	r8, r2
 800db98:	f083 4900 	eor.w	r9, r3, #2147483648	; 0x80000000
    point_2dd_t rv = {  // Radius vector from center to current location
 800db9c:	e9c7 8912 	strd	r8, r9, [r7, #72]	; 0x48
        .y = -(double)offset[plane.axis_1]
 800dba0:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800dba4:	009b      	lsls	r3, r3, #2
 800dba6:	683a      	ldr	r2, [r7, #0]
 800dba8:	4413      	add	r3, r2
 800dbaa:	681b      	ldr	r3, [r3, #0]
 800dbac:	4618      	mov	r0, r3
 800dbae:	f7f2 fcb1 	bl	8000514 <__aeabi_f2d>
 800dbb2:	4602      	mov	r2, r0
 800dbb4:	460b      	mov	r3, r1
 800dbb6:	4614      	mov	r4, r2
 800dbb8:	f083 4500 	eor.w	r5, r3, #2147483648	; 0x80000000
    point_2dd_t rv = {  // Radius vector from center to current location
 800dbbc:	e9c7 4514 	strd	r4, r5, [r7, #80]	; 0x50
    };
    point_2dd_t center = {
        .x = (double)position[plane.axis_0] - rv.x,
 800dbc0:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800dbc4:	009b      	lsls	r3, r3, #2
 800dbc6:	687a      	ldr	r2, [r7, #4]
 800dbc8:	4413      	add	r3, r2
 800dbca:	681b      	ldr	r3, [r3, #0]
 800dbcc:	4618      	mov	r0, r3
 800dbce:	f7f2 fca1 	bl	8000514 <__aeabi_f2d>
 800dbd2:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800dbd6:	f7f2 fb3d 	bl	8000254 <__aeabi_dsub>
 800dbda:	4602      	mov	r2, r0
 800dbdc:	460b      	mov	r3, r1
    point_2dd_t center = {
 800dbde:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
        .y = (double)position[plane.axis_1] - rv.y
 800dbe2:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800dbe6:	009b      	lsls	r3, r3, #2
 800dbe8:	687a      	ldr	r2, [r7, #4]
 800dbea:	4413      	add	r3, r2
 800dbec:	681b      	ldr	r3, [r3, #0]
 800dbee:	4618      	mov	r0, r3
 800dbf0:	f7f2 fc90 	bl	8000514 <__aeabi_f2d>
 800dbf4:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 800dbf8:	f7f2 fb2c 	bl	8000254 <__aeabi_dsub>
 800dbfc:	4602      	mov	r2, r0
 800dbfe:	460b      	mov	r3, r1
    point_2dd_t center = {
 800dc00:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40
    };
    point_2dd_t rt = {
        .x = (double)target[plane.axis_0] - center.x,
 800dc04:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800dc08:	009b      	lsls	r3, r3, #2
 800dc0a:	68fa      	ldr	r2, [r7, #12]
 800dc0c:	4413      	add	r3, r2
 800dc0e:	681b      	ldr	r3, [r3, #0]
 800dc10:	4618      	mov	r0, r3
 800dc12:	f7f2 fc7f 	bl	8000514 <__aeabi_f2d>
 800dc16:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 800dc1a:	f7f2 fb1b 	bl	8000254 <__aeabi_dsub>
 800dc1e:	4602      	mov	r2, r0
 800dc20:	460b      	mov	r3, r1
    point_2dd_t rt = {
 800dc22:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28
        .y = (double)target[plane.axis_1] - center.y
 800dc26:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800dc2a:	009b      	lsls	r3, r3, #2
 800dc2c:	68fa      	ldr	r2, [r7, #12]
 800dc2e:	4413      	add	r3, r2
 800dc30:	681b      	ldr	r3, [r3, #0]
 800dc32:	4618      	mov	r0, r3
 800dc34:	f7f2 fc6e 	bl	8000514 <__aeabi_f2d>
 800dc38:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800dc3c:	f7f2 fb0a 	bl	8000254 <__aeabi_dsub>
 800dc40:	4602      	mov	r2, r0
 800dc42:	460b      	mov	r3, r1
    point_2dd_t rt = {
 800dc44:	e9c7 230c 	strd	r2, r3, [r7, #48]	; 0x30
    };
    // CCW angle between position and target from circle center. Only one atan2() trig computation required.
    float angular_travel = (float)atan2(rv.x * rt.y - rv.y * rt.x, rv.x * rt.x + rv.y * rt.y);
 800dc48:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 800dc4c:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800dc50:	f7f2 fcb8 	bl	80005c4 <__aeabi_dmul>
 800dc54:	4602      	mov	r2, r0
 800dc56:	460b      	mov	r3, r1
 800dc58:	4614      	mov	r4, r2
 800dc5a:	461d      	mov	r5, r3
 800dc5c:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 800dc60:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 800dc64:	f7f2 fcae 	bl	80005c4 <__aeabi_dmul>
 800dc68:	4602      	mov	r2, r0
 800dc6a:	460b      	mov	r3, r1
 800dc6c:	4620      	mov	r0, r4
 800dc6e:	4629      	mov	r1, r5
 800dc70:	f7f2 faf0 	bl	8000254 <__aeabi_dsub>
 800dc74:	4602      	mov	r2, r0
 800dc76:	460b      	mov	r3, r1
 800dc78:	4614      	mov	r4, r2
 800dc7a:	461d      	mov	r5, r3
 800dc7c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
 800dc80:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 800dc84:	f7f2 fc9e 	bl	80005c4 <__aeabi_dmul>
 800dc88:	4602      	mov	r2, r0
 800dc8a:	460b      	mov	r3, r1
 800dc8c:	4690      	mov	r8, r2
 800dc8e:	4699      	mov	r9, r3
 800dc90:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
 800dc94:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
 800dc98:	f7f2 fc94 	bl	80005c4 <__aeabi_dmul>
 800dc9c:	4602      	mov	r2, r0
 800dc9e:	460b      	mov	r3, r1
 800dca0:	4640      	mov	r0, r8
 800dca2:	4649      	mov	r1, r9
 800dca4:	f7f2 fad8 	bl	8000258 <__adddf3>
 800dca8:	4602      	mov	r2, r0
 800dcaa:	460b      	mov	r3, r1
 800dcac:	4620      	mov	r0, r4
 800dcae:	4629      	mov	r1, r5
 800dcb0:	f016 fe56 	bl	8024960 <atan2>
 800dcb4:	4602      	mov	r2, r0
 800dcb6:	460b      	mov	r3, r1
 800dcb8:	4610      	mov	r0, r2
 800dcba:	4619      	mov	r1, r3
 800dcbc:	f7f2 ff1c 	bl	8000af8 <__aeabi_d2f>
 800dcc0:	4603      	mov	r3, r0
 800dcc2:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    if (turns > 0) { // Correct atan2 output per direction
 800dcc6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800dcca:	2b00      	cmp	r3, #0
 800dccc:	dd1a      	ble.n	800dd04 <mc_arc+0x194>
        if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON)
 800dcce:	4992      	ldr	r1, [pc, #584]	; (800df18 <mc_arc+0x3a8>)
 800dcd0:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800dcd4:	f7f3 fa16 	bl	8001104 <__aeabi_fcmple>
 800dcd8:	4603      	mov	r3, r0
 800dcda:	2b00      	cmp	r3, #0
 800dcdc:	d02c      	beq.n	800dd38 <mc_arc+0x1c8>
            angular_travel += 2.0f * M_PI;
 800dcde:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800dce2:	f7f2 fc17 	bl	8000514 <__aeabi_f2d>
 800dce6:	a388      	add	r3, pc, #544	; (adr r3, 800df08 <mc_arc+0x398>)
 800dce8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800dcec:	f7f2 fab4 	bl	8000258 <__adddf3>
 800dcf0:	4602      	mov	r2, r0
 800dcf2:	460b      	mov	r3, r1
 800dcf4:	4610      	mov	r0, r2
 800dcf6:	4619      	mov	r1, r3
 800dcf8:	f7f2 fefe 	bl	8000af8 <__aeabi_d2f>
 800dcfc:	4603      	mov	r3, r0
 800dcfe:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800dd02:	e019      	b.n	800dd38 <mc_arc+0x1c8>
    } else if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON)
 800dd04:	4985      	ldr	r1, [pc, #532]	; (800df1c <mc_arc+0x3ac>)
 800dd06:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800dd0a:	f7f3 fa05 	bl	8001118 <__aeabi_fcmpge>
 800dd0e:	4603      	mov	r3, r0
 800dd10:	2b00      	cmp	r3, #0
 800dd12:	d011      	beq.n	800dd38 <mc_arc+0x1c8>
        angular_travel -= 2.0f * M_PI;
 800dd14:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800dd18:	f7f2 fbfc 	bl	8000514 <__aeabi_f2d>
 800dd1c:	a37a      	add	r3, pc, #488	; (adr r3, 800df08 <mc_arc+0x398>)
 800dd1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800dd22:	f7f2 fa97 	bl	8000254 <__aeabi_dsub>
 800dd26:	4602      	mov	r2, r0
 800dd28:	460b      	mov	r3, r1
 800dd2a:	4610      	mov	r0, r2
 800dd2c:	4619      	mov	r1, r3
 800dd2e:	f7f2 fee3 	bl	8000af8 <__aeabi_d2f>
 800dd32:	4603      	mov	r3, r0
 800dd34:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

    if(!pl_data->condition.target_validated && grbl.check_arc_travel_limits) {
 800dd38:	68bb      	ldr	r3, [r7, #8]
 800dd3a:	7e5b      	ldrb	r3, [r3, #25]
 800dd3c:	f003 0302 	and.w	r3, r3, #2
 800dd40:	b2db      	uxtb	r3, r3
 800dd42:	2b00      	cmp	r3, #0
 800dd44:	d138      	bne.n	800ddb8 <mc_arc+0x248>
 800dd46:	4b76      	ldr	r3, [pc, #472]	; (800df20 <mc_arc+0x3b0>)
 800dd48:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
 800dd4c:	2b00      	cmp	r3, #0
 800dd4e:	d033      	beq.n	800ddb8 <mc_arc+0x248>
        pl_data->condition.target_validated = On;
 800dd50:	68ba      	ldr	r2, [r7, #8]
 800dd52:	7e53      	ldrb	r3, [r2, #25]
 800dd54:	f043 0302 	orr.w	r3, r3, #2
 800dd58:	7653      	strb	r3, [r2, #25]
        pl_data->condition.target_valid = grbl.check_arc_travel_limits((coord_data_t *)target, (coord_data_t *)position,
 800dd5a:	4b71      	ldr	r3, [pc, #452]	; (800df20 <mc_arc+0x3b0>)
 800dd5c:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
                                                                        (point_2d_t){ .x = (float)center.x, .y = (float)center.y },
 800dd60:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
 800dd64:	4610      	mov	r0, r2
 800dd66:	4619      	mov	r1, r3
 800dd68:	f7f2 fec6 	bl	8000af8 <__aeabi_d2f>
 800dd6c:	4603      	mov	r3, r0
 800dd6e:	623b      	str	r3, [r7, #32]
 800dd70:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800dd74:	4610      	mov	r0, r2
 800dd76:	4619      	mov	r1, r3
 800dd78:	f7f2 febe 	bl	8000af8 <__aeabi_d2f>
 800dd7c:	4603      	mov	r3, r0
 800dd7e:	627b      	str	r3, [r7, #36]	; 0x24
        pl_data->condition.target_valid = grbl.check_arc_travel_limits((coord_data_t *)target, (coord_data_t *)position,
 800dd80:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800dd84:	9302      	str	r3, [sp, #8]
 800dd86:	ab01      	add	r3, sp, #4
 800dd88:	f107 02ac 	add.w	r2, r7, #172	; 0xac
 800dd8c:	6812      	ldr	r2, [r2, #0]
 800dd8e:	4611      	mov	r1, r2
 800dd90:	8019      	strh	r1, [r3, #0]
 800dd92:	3302      	adds	r3, #2
 800dd94:	0c12      	lsrs	r2, r2, #16
 800dd96:	701a      	strb	r2, [r3, #0]
 800dd98:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800dd9c:	9300      	str	r3, [sp, #0]
 800dd9e:	f107 0320 	add.w	r3, r7, #32
 800dda2:	cb0c      	ldmia	r3, {r2, r3}
 800dda4:	6879      	ldr	r1, [r7, #4]
 800dda6:	68f8      	ldr	r0, [r7, #12]
 800dda8:	47a0      	blx	r4
 800ddaa:	4603      	mov	r3, r0
 800ddac:	4619      	mov	r1, r3
 800ddae:	68ba      	ldr	r2, [r7, #8]
 800ddb0:	7e53      	ldrb	r3, [r2, #25]
 800ddb2:	f361 0300 	bfi	r3, r1, #0, #1
 800ddb6:	7653      	strb	r3, [r2, #25]
                                                                         radius, plane, turns);
    }

    if(labs(turns) > 1) {
 800ddb8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800ddbc:	2b00      	cmp	r3, #0
 800ddbe:	bfb8      	it	lt
 800ddc0:	425b      	neglt	r3, r3
 800ddc2:	2b01      	cmp	r3, #1
 800ddc4:	f340 80d2 	ble.w	800df6c <mc_arc+0x3fc>

        uint32_t n_turns = labs(turns) - 1;
 800ddc8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800ddcc:	2b00      	cmp	r3, #0
 800ddce:	bfb8      	it	lt
 800ddd0:	425b      	neglt	r3, r3
 800ddd2:	3b01      	subs	r3, #1
 800ddd4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        float arc_travel = 2.0f * M_PI * n_turns + angular_travel;
 800ddd8:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800dddc:	f7f2 fb78 	bl	80004d0 <__aeabi_ui2d>
 800dde0:	a349      	add	r3, pc, #292	; (adr r3, 800df08 <mc_arc+0x398>)
 800dde2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800dde6:	f7f2 fbed 	bl	80005c4 <__aeabi_dmul>
 800ddea:	4602      	mov	r2, r0
 800ddec:	460b      	mov	r3, r1
 800ddee:	4614      	mov	r4, r2
 800ddf0:	461d      	mov	r5, r3
 800ddf2:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800ddf6:	f7f2 fb8d 	bl	8000514 <__aeabi_f2d>
 800ddfa:	4602      	mov	r2, r0
 800ddfc:	460b      	mov	r3, r1
 800ddfe:	4620      	mov	r0, r4
 800de00:	4629      	mov	r1, r5
 800de02:	f7f2 fa29 	bl	8000258 <__adddf3>
 800de06:	4602      	mov	r2, r0
 800de08:	460b      	mov	r3, r1
 800de0a:	4610      	mov	r0, r2
 800de0c:	4619      	mov	r1, r3
 800de0e:	f7f2 fe73 	bl	8000af8 <__aeabi_d2f>
 800de12:	4603      	mov	r3, r0
 800de14:	67bb      	str	r3, [r7, #120]	; 0x78
            idx--;
            if(!(idx == plane.axis_0 || idx == plane.axis_1))
                linear_per_turn[idx] = (target[idx] - position[idx]) / arc_travel * 2.0f * M_PI;
        } while(idx);
#else
        float linear_per_turn = (target[plane.axis_linear] - position[plane.axis_linear]) / arc_travel * 2.0f * M_PI;
 800de16:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800de1a:	009b      	lsls	r3, r3, #2
 800de1c:	68fa      	ldr	r2, [r7, #12]
 800de1e:	4413      	add	r3, r2
 800de20:	6818      	ldr	r0, [r3, #0]
 800de22:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800de26:	009b      	lsls	r3, r3, #2
 800de28:	687a      	ldr	r2, [r7, #4]
 800de2a:	4413      	add	r3, r2
 800de2c:	681b      	ldr	r3, [r3, #0]
 800de2e:	4619      	mov	r1, r3
 800de30:	f7f2 feb6 	bl	8000ba0 <__aeabi_fsub>
 800de34:	4603      	mov	r3, r0
 800de36:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 800de38:	4618      	mov	r0, r3
 800de3a:	f7f3 f86f 	bl	8000f1c <__aeabi_fdiv>
 800de3e:	4603      	mov	r3, r0
 800de40:	4619      	mov	r1, r3
 800de42:	4618      	mov	r0, r3
 800de44:	f7f2 feae 	bl	8000ba4 <__addsf3>
 800de48:	4603      	mov	r3, r0
 800de4a:	4618      	mov	r0, r3
 800de4c:	f7f2 fb62 	bl	8000514 <__aeabi_f2d>
 800de50:	a32f      	add	r3, pc, #188	; (adr r3, 800df10 <mc_arc+0x3a0>)
 800de52:	e9d3 2300 	ldrd	r2, r3, [r3]
 800de56:	f7f2 fbb5 	bl	80005c4 <__aeabi_dmul>
 800de5a:	4602      	mov	r2, r0
 800de5c:	460b      	mov	r3, r1
 800de5e:	4610      	mov	r0, r2
 800de60:	4619      	mov	r1, r3
 800de62:	f7f2 fe49 	bl	8000af8 <__aeabi_d2f>
 800de66:	4603      	mov	r3, r0
 800de68:	677b      	str	r3, [r7, #116]	; 0x74
#endif

        memcpy(&arc_target, target, sizeof(coord_data_t));
 800de6a:	f107 0314 	add.w	r3, r7, #20
 800de6e:	220c      	movs	r2, #12
 800de70:	68f9      	ldr	r1, [r7, #12]
 800de72:	4618      	mov	r0, r3
 800de74:	f016 f82b 	bl	8023ece <memcpy>

        arc_target.values[plane.axis_0] = position[plane.axis_0];
 800de78:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800de7c:	009b      	lsls	r3, r3, #2
 800de7e:	687a      	ldr	r2, [r7, #4]
 800de80:	4413      	add	r3, r2
 800de82:	f897 20ac 	ldrb.w	r2, [r7, #172]	; 0xac
 800de86:	4611      	mov	r1, r2
 800de88:	681a      	ldr	r2, [r3, #0]
 800de8a:	008b      	lsls	r3, r1, #2
 800de8c:	3390      	adds	r3, #144	; 0x90
 800de8e:	443b      	add	r3, r7
 800de90:	f843 2c7c 	str.w	r2, [r3, #-124]
        arc_target.values[plane.axis_1] = position[plane.axis_1];
 800de94:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800de98:	009b      	lsls	r3, r3, #2
 800de9a:	687a      	ldr	r2, [r7, #4]
 800de9c:	4413      	add	r3, r2
 800de9e:	f897 20ad 	ldrb.w	r2, [r7, #173]	; 0xad
 800dea2:	4611      	mov	r1, r2
 800dea4:	681a      	ldr	r2, [r3, #0]
 800dea6:	008b      	lsls	r3, r1, #2
 800dea8:	3390      	adds	r3, #144	; 0x90
 800deaa:	443b      	add	r3, r7
 800deac:	f843 2c7c 	str.w	r2, [r3, #-124]
        arc_target.values[plane.axis_linear] = position[plane.axis_linear];
 800deb0:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800deb4:	009b      	lsls	r3, r3, #2
 800deb6:	687a      	ldr	r2, [r7, #4]
 800deb8:	4413      	add	r3, r2
 800deba:	f897 20ae 	ldrb.w	r2, [r7, #174]	; 0xae
 800debe:	4611      	mov	r1, r2
 800dec0:	681a      	ldr	r2, [r3, #0]
 800dec2:	008b      	lsls	r3, r1, #2
 800dec4:	3390      	adds	r3, #144	; 0x90
 800dec6:	443b      	add	r3, r7
 800dec8:	f843 2c7c 	str.w	r2, [r3, #-124]

        while(n_turns--) {
 800decc:	e047      	b.n	800df5e <mc_arc+0x3ee>
                idx--;
                if(!(idx == plane.axis_0 || idx == plane.axis_1))
                    arc_target.values[idx] += linear_per_turn[idx];
            } while(idx);
#else
            arc_target.values[plane.axis_linear] += linear_per_turn;
 800dece:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800ded2:	009b      	lsls	r3, r3, #2
 800ded4:	3390      	adds	r3, #144	; 0x90
 800ded6:	443b      	add	r3, r7
 800ded8:	f853 3c7c 	ldr.w	r3, [r3, #-124]
 800dedc:	f897 20ae 	ldrb.w	r2, [r7, #174]	; 0xae
 800dee0:	4614      	mov	r4, r2
 800dee2:	6f79      	ldr	r1, [r7, #116]	; 0x74
 800dee4:	4618      	mov	r0, r3
 800dee6:	f7f2 fe5d 	bl	8000ba4 <__addsf3>
 800deea:	4603      	mov	r3, r0
 800deec:	461a      	mov	r2, r3
 800deee:	00a3      	lsls	r3, r4, #2
 800def0:	3390      	adds	r3, #144	; 0x90
 800def2:	443b      	add	r3, r7
 800def4:	f843 2c7c 	str.w	r2, [r3, #-124]
#endif
            mc_arc(arc_target.values, pl_data, position, offset, radius, plane, turns > 0 ? 1 : -1);
 800def8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800defc:	2b00      	cmp	r3, #0
 800defe:	dd11      	ble.n	800df24 <mc_arc+0x3b4>
 800df00:	2301      	movs	r3, #1
 800df02:	e011      	b.n	800df28 <mc_arc+0x3b8>
 800df04:	f3af 8000 	nop.w
 800df08:	54442d18 	.word	0x54442d18
 800df0c:	401921fb 	.word	0x401921fb
 800df10:	54442d18 	.word	0x54442d18
 800df14:	400921fb 	.word	0x400921fb
 800df18:	350637bd 	.word	0x350637bd
 800df1c:	b50637bd 	.word	0xb50637bd
 800df20:	20000dd4 	.word	0x20000dd4
 800df24:	f04f 33ff 	mov.w	r3, #4294967295
 800df28:	f107 0014 	add.w	r0, r7, #20
 800df2c:	9302      	str	r3, [sp, #8]
 800df2e:	ab01      	add	r3, sp, #4
 800df30:	f107 02ac 	add.w	r2, r7, #172	; 0xac
 800df34:	6812      	ldr	r2, [r2, #0]
 800df36:	4611      	mov	r1, r2
 800df38:	8019      	strh	r1, [r3, #0]
 800df3a:	3302      	adds	r3, #2
 800df3c:	0c12      	lsrs	r2, r2, #16
 800df3e:	701a      	strb	r2, [r3, #0]
 800df40:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800df44:	9300      	str	r3, [sp, #0]
 800df46:	683b      	ldr	r3, [r7, #0]
 800df48:	687a      	ldr	r2, [r7, #4]
 800df4a:	68b9      	ldr	r1, [r7, #8]
 800df4c:	f7ff fe10 	bl	800db70 <mc_arc>
            memcpy(position, arc_target.values, sizeof(coord_data_t));
 800df50:	f107 0314 	add.w	r3, r7, #20
 800df54:	220c      	movs	r2, #12
 800df56:	4619      	mov	r1, r3
 800df58:	6878      	ldr	r0, [r7, #4]
 800df5a:	f015 ffb8 	bl	8023ece <memcpy>
        while(n_turns--) {
 800df5e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800df62:	1e5a      	subs	r2, r3, #1
 800df64:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
 800df68:	2b00      	cmp	r3, #0
 800df6a:	d1b0      	bne.n	800dece <mc_arc+0x35e>
    // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
    // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
    // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
    // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.

    uint_fast16_t segments = 0;
 800df6c:	2300      	movs	r3, #0
 800df6e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

    if(2.0f * radius > settings.arc_tolerance)
 800df72:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800df76:	4619      	mov	r1, r3
 800df78:	4618      	mov	r0, r3
 800df7a:	f7f2 fe13 	bl	8000ba4 <__addsf3>
 800df7e:	4603      	mov	r3, r0
 800df80:	461a      	mov	r2, r3
 800df82:	4b87      	ldr	r3, [pc, #540]	; (800e1a0 <mc_arc+0x630>)
 800df84:	689b      	ldr	r3, [r3, #8]
 800df86:	4619      	mov	r1, r3
 800df88:	4610      	mov	r0, r2
 800df8a:	f7f3 f8cf 	bl	800112c <__aeabi_fcmpgt>
 800df8e:	4603      	mov	r3, r0
 800df90:	2b00      	cmp	r3, #0
 800df92:	d037      	beq.n	800e004 <mc_arc+0x494>
        segments = (uint_fast16_t)floorf(fabsf(0.5f * angular_travel * radius) / sqrtf(settings.arc_tolerance * (2.0f * radius - settings.arc_tolerance)));
 800df94:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800df98:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800df9c:	f7f2 ff0a 	bl	8000db4 <__aeabi_fmul>
 800dfa0:	4603      	mov	r3, r0
 800dfa2:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 800dfa6:	4618      	mov	r0, r3
 800dfa8:	f7f2 ff04 	bl	8000db4 <__aeabi_fmul>
 800dfac:	4603      	mov	r3, r0
 800dfae:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 800dfb2:	4b7b      	ldr	r3, [pc, #492]	; (800e1a0 <mc_arc+0x630>)
 800dfb4:	689d      	ldr	r5, [r3, #8]
 800dfb6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800dfba:	4619      	mov	r1, r3
 800dfbc:	4618      	mov	r0, r3
 800dfbe:	f7f2 fdf1 	bl	8000ba4 <__addsf3>
 800dfc2:	4603      	mov	r3, r0
 800dfc4:	461a      	mov	r2, r3
 800dfc6:	4b76      	ldr	r3, [pc, #472]	; (800e1a0 <mc_arc+0x630>)
 800dfc8:	689b      	ldr	r3, [r3, #8]
 800dfca:	4619      	mov	r1, r3
 800dfcc:	4610      	mov	r0, r2
 800dfce:	f7f2 fde7 	bl	8000ba0 <__aeabi_fsub>
 800dfd2:	4603      	mov	r3, r0
 800dfd4:	4619      	mov	r1, r3
 800dfd6:	4628      	mov	r0, r5
 800dfd8:	f7f2 feec 	bl	8000db4 <__aeabi_fmul>
 800dfdc:	4603      	mov	r3, r0
 800dfde:	4618      	mov	r0, r3
 800dfe0:	f016 fd0d 	bl	80249fe <sqrtf>
 800dfe4:	4603      	mov	r3, r0
 800dfe6:	4619      	mov	r1, r3
 800dfe8:	4620      	mov	r0, r4
 800dfea:	f7f2 ff97 	bl	8000f1c <__aeabi_fdiv>
 800dfee:	4603      	mov	r3, r0
 800dff0:	4618      	mov	r0, r3
 800dff2:	f016 fe9b 	bl	8024d2c <floorf>
 800dff6:	4603      	mov	r3, r0
 800dff8:	4618      	mov	r0, r3
 800dffa:	f7f3 f8dd 	bl	80011b8 <__aeabi_f2uiz>
 800dffe:	4603      	mov	r3, r0
 800e000:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

    if(segments) {
 800e004:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e008:	2b00      	cmp	r3, #0
 800e00a:	f000 8181 	beq.w	800e310 <mc_arc+0x7a0>

        // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
        // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
        // all segments.
        if (pl_data->condition.inverse_time) {
 800e00e:	68bb      	ldr	r3, [r7, #8]
 800e010:	7e1b      	ldrb	r3, [r3, #24]
 800e012:	f003 0320 	and.w	r3, r3, #32
 800e016:	b2db      	uxtb	r3, r3
 800e018:	2b00      	cmp	r3, #0
 800e01a:	d013      	beq.n	800e044 <mc_arc+0x4d4>
            pl_data->feed_rate *= segments;
 800e01c:	68bb      	ldr	r3, [r7, #8]
 800e01e:	681c      	ldr	r4, [r3, #0]
 800e020:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e024:	f7f2 fe6e 	bl	8000d04 <__aeabi_ui2f>
 800e028:	4603      	mov	r3, r0
 800e02a:	4619      	mov	r1, r3
 800e02c:	4620      	mov	r0, r4
 800e02e:	f7f2 fec1 	bl	8000db4 <__aeabi_fmul>
 800e032:	4603      	mov	r3, r0
 800e034:	461a      	mov	r2, r3
 800e036:	68bb      	ldr	r3, [r7, #8]
 800e038:	601a      	str	r2, [r3, #0]
            pl_data->condition.inverse_time = Off; // Force as feed absolute mode over arc segments.
 800e03a:	68ba      	ldr	r2, [r7, #8]
 800e03c:	7e13      	ldrb	r3, [r2, #24]
 800e03e:	f36f 1345 	bfc	r3, #5, #1
 800e042:	7613      	strb	r3, [r2, #24]
        }

        float theta_per_segment = angular_travel / segments;
 800e044:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e048:	f7f2 fe5c 	bl	8000d04 <__aeabi_ui2f>
 800e04c:	4603      	mov	r3, r0
 800e04e:	4619      	mov	r1, r3
 800e050:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800e054:	f7f2 ff62 	bl	8000f1c <__aeabi_fdiv>
 800e058:	4603      	mov	r3, r0
 800e05a:	673b      	str	r3, [r7, #112]	; 0x70
            idx--;
            if(!(idx == plane.axis_0 || idx == plane.axis_1))
                linear_per_segment[idx] = (target[idx] - position[idx]) / segments;
        } while(idx);
#else
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 800e05c:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800e060:	009b      	lsls	r3, r3, #2
 800e062:	68fa      	ldr	r2, [r7, #12]
 800e064:	4413      	add	r3, r2
 800e066:	6818      	ldr	r0, [r3, #0]
 800e068:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800e06c:	009b      	lsls	r3, r3, #2
 800e06e:	687a      	ldr	r2, [r7, #4]
 800e070:	4413      	add	r3, r2
 800e072:	681b      	ldr	r3, [r3, #0]
 800e074:	4619      	mov	r1, r3
 800e076:	f7f2 fd93 	bl	8000ba0 <__aeabi_fsub>
 800e07a:	4603      	mov	r3, r0
 800e07c:	461c      	mov	r4, r3
 800e07e:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
 800e082:	f7f2 fe3f 	bl	8000d04 <__aeabi_ui2f>
 800e086:	4603      	mov	r3, r0
 800e088:	4619      	mov	r1, r3
 800e08a:	4620      	mov	r0, r4
 800e08c:	f7f2 ff46 	bl	8000f1c <__aeabi_fdiv>
 800e090:	4603      	mov	r3, r0
 800e092:	66fb      	str	r3, [r7, #108]	; 0x6c
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */

        // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
        float cos_T = 2.0f - theta_per_segment * theta_per_segment;
 800e094:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800e096:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800e098:	f7f2 fe8c 	bl	8000db4 <__aeabi_fmul>
 800e09c:	4603      	mov	r3, r0
 800e09e:	4619      	mov	r1, r3
 800e0a0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800e0a4:	f7f2 fd7c 	bl	8000ba0 <__aeabi_fsub>
 800e0a8:	4603      	mov	r3, r0
 800e0aa:	66bb      	str	r3, [r7, #104]	; 0x68
        float sin_T = theta_per_segment * 0.16666667f * (cos_T + 4.0f);
 800e0ac:	493d      	ldr	r1, [pc, #244]	; (800e1a4 <mc_arc+0x634>)
 800e0ae:	6f38      	ldr	r0, [r7, #112]	; 0x70
 800e0b0:	f7f2 fe80 	bl	8000db4 <__aeabi_fmul>
 800e0b4:	4603      	mov	r3, r0
 800e0b6:	461c      	mov	r4, r3
 800e0b8:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 800e0bc:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800e0be:	f7f2 fd71 	bl	8000ba4 <__addsf3>
 800e0c2:	4603      	mov	r3, r0
 800e0c4:	4619      	mov	r1, r3
 800e0c6:	4620      	mov	r0, r4
 800e0c8:	f7f2 fe74 	bl	8000db4 <__aeabi_fmul>
 800e0cc:	4603      	mov	r3, r0
 800e0ce:	667b      	str	r3, [r7, #100]	; 0x64
        cos_T *= 0.5f;
 800e0d0:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e0d4:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800e0d6:	f7f2 fe6d 	bl	8000db4 <__aeabi_fmul>
 800e0da:	4603      	mov	r3, r0
 800e0dc:	66bb      	str	r3, [r7, #104]	; 0x68

        float sin_Ti;
        float cos_Ti;
        float r_axisi;
        uint_fast16_t i, count = 0;
 800e0de:	2300      	movs	r3, #0
 800e0e0:	67fb      	str	r3, [r7, #124]	; 0x7c

        for (i = 1; i < segments; i++) { // Increment (segments-1).
 800e0e2:	2301      	movs	r3, #1
 800e0e4:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e0e8:	e10b      	b.n	800e302 <mc_arc+0x792>

            if (count < N_ARC_CORRECTION) {
 800e0ea:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e0ec:	2b0b      	cmp	r3, #11
 800e0ee:	d85b      	bhi.n	800e1a8 <mc_arc+0x638>
                // Apply vector rotation matrix.
                r_axisi = rv.x * sin_T + rv.y * cos_T;
 800e0f0:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	; 0x48
 800e0f4:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800e0f6:	f7f2 fa0d 	bl	8000514 <__aeabi_f2d>
 800e0fa:	4602      	mov	r2, r0
 800e0fc:	460b      	mov	r3, r1
 800e0fe:	4620      	mov	r0, r4
 800e100:	4629      	mov	r1, r5
 800e102:	f7f2 fa5f 	bl	80005c4 <__aeabi_dmul>
 800e106:	4602      	mov	r2, r0
 800e108:	460b      	mov	r3, r1
 800e10a:	4690      	mov	r8, r2
 800e10c:	4699      	mov	r9, r3
 800e10e:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	; 0x50
 800e112:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800e114:	f7f2 f9fe 	bl	8000514 <__aeabi_f2d>
 800e118:	4602      	mov	r2, r0
 800e11a:	460b      	mov	r3, r1
 800e11c:	4620      	mov	r0, r4
 800e11e:	4629      	mov	r1, r5
 800e120:	f7f2 fa50 	bl	80005c4 <__aeabi_dmul>
 800e124:	4602      	mov	r2, r0
 800e126:	460b      	mov	r3, r1
 800e128:	4640      	mov	r0, r8
 800e12a:	4649      	mov	r1, r9
 800e12c:	f7f2 f894 	bl	8000258 <__adddf3>
 800e130:	4602      	mov	r2, r0
 800e132:	460b      	mov	r3, r1
 800e134:	4610      	mov	r0, r2
 800e136:	4619      	mov	r1, r3
 800e138:	f7f2 fcde 	bl	8000af8 <__aeabi_d2f>
 800e13c:	4603      	mov	r3, r0
 800e13e:	65bb      	str	r3, [r7, #88]	; 0x58
                rv.x = rv.x * cos_T - rv.y * sin_T;
 800e140:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	; 0x48
 800e144:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800e146:	f7f2 f9e5 	bl	8000514 <__aeabi_f2d>
 800e14a:	4602      	mov	r2, r0
 800e14c:	460b      	mov	r3, r1
 800e14e:	4620      	mov	r0, r4
 800e150:	4629      	mov	r1, r5
 800e152:	f7f2 fa37 	bl	80005c4 <__aeabi_dmul>
 800e156:	4602      	mov	r2, r0
 800e158:	460b      	mov	r3, r1
 800e15a:	4690      	mov	r8, r2
 800e15c:	4699      	mov	r9, r3
 800e15e:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	; 0x50
 800e162:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800e164:	f7f2 f9d6 	bl	8000514 <__aeabi_f2d>
 800e168:	4602      	mov	r2, r0
 800e16a:	460b      	mov	r3, r1
 800e16c:	4620      	mov	r0, r4
 800e16e:	4629      	mov	r1, r5
 800e170:	f7f2 fa28 	bl	80005c4 <__aeabi_dmul>
 800e174:	4602      	mov	r2, r0
 800e176:	460b      	mov	r3, r1
 800e178:	4640      	mov	r0, r8
 800e17a:	4649      	mov	r1, r9
 800e17c:	f7f2 f86a 	bl	8000254 <__aeabi_dsub>
 800e180:	4602      	mov	r2, r0
 800e182:	460b      	mov	r3, r1
 800e184:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
                rv.y = r_axisi;
 800e188:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800e18a:	f7f2 f9c3 	bl	8000514 <__aeabi_f2d>
 800e18e:	4602      	mov	r2, r0
 800e190:	460b      	mov	r3, r1
 800e192:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
                count++;
 800e196:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e198:	3301      	adds	r3, #1
 800e19a:	67fb      	str	r3, [r7, #124]	; 0x7c
 800e19c:	e06c      	b.n	800e278 <mc_arc+0x708>
 800e19e:	bf00      	nop
 800e1a0:	2000147c 	.word	0x2000147c
 800e1a4:	3e2aaaab 	.word	0x3e2aaaab
            } else {
                // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
                // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
                cos_Ti = cosf(i * theta_per_segment);
 800e1a8:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 800e1ac:	f7f2 fdaa 	bl	8000d04 <__aeabi_ui2f>
 800e1b0:	4603      	mov	r3, r0
 800e1b2:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800e1b4:	4618      	mov	r0, r3
 800e1b6:	f7f2 fdfd 	bl	8000db4 <__aeabi_fmul>
 800e1ba:	4603      	mov	r3, r0
 800e1bc:	4618      	mov	r0, r3
 800e1be:	f016 fc39 	bl	8024a34 <cosf>
 800e1c2:	6638      	str	r0, [r7, #96]	; 0x60
                sin_Ti = sinf(i * theta_per_segment);
 800e1c4:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 800e1c8:	f7f2 fd9c 	bl	8000d04 <__aeabi_ui2f>
 800e1cc:	4603      	mov	r3, r0
 800e1ce:	6f39      	ldr	r1, [r7, #112]	; 0x70
 800e1d0:	4618      	mov	r0, r3
 800e1d2:	f7f2 fdef 	bl	8000db4 <__aeabi_fmul>
 800e1d6:	4603      	mov	r3, r0
 800e1d8:	4618      	mov	r0, r3
 800e1da:	f016 fc63 	bl	8024aa4 <sinf>
 800e1de:	65f8      	str	r0, [r7, #92]	; 0x5c
                rv.x = -offset[plane.axis_0] * cos_Ti + offset[plane.axis_1] * sin_Ti;
 800e1e0:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800e1e4:	009b      	lsls	r3, r3, #2
 800e1e6:	683a      	ldr	r2, [r7, #0]
 800e1e8:	4413      	add	r3, r2
 800e1ea:	681b      	ldr	r3, [r3, #0]
 800e1ec:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800e1f0:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800e1f2:	4618      	mov	r0, r3
 800e1f4:	f7f2 fdde 	bl	8000db4 <__aeabi_fmul>
 800e1f8:	4603      	mov	r3, r0
 800e1fa:	461c      	mov	r4, r3
 800e1fc:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800e200:	009b      	lsls	r3, r3, #2
 800e202:	683a      	ldr	r2, [r7, #0]
 800e204:	4413      	add	r3, r2
 800e206:	681b      	ldr	r3, [r3, #0]
 800e208:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e20a:	4618      	mov	r0, r3
 800e20c:	f7f2 fdd2 	bl	8000db4 <__aeabi_fmul>
 800e210:	4603      	mov	r3, r0
 800e212:	4619      	mov	r1, r3
 800e214:	4620      	mov	r0, r4
 800e216:	f7f2 fcc5 	bl	8000ba4 <__addsf3>
 800e21a:	4603      	mov	r3, r0
 800e21c:	4618      	mov	r0, r3
 800e21e:	f7f2 f979 	bl	8000514 <__aeabi_f2d>
 800e222:	4602      	mov	r2, r0
 800e224:	460b      	mov	r3, r1
 800e226:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
                rv.y = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
 800e22a:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800e22e:	009b      	lsls	r3, r3, #2
 800e230:	683a      	ldr	r2, [r7, #0]
 800e232:	4413      	add	r3, r2
 800e234:	681b      	ldr	r3, [r3, #0]
 800e236:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800e23a:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e23c:	4618      	mov	r0, r3
 800e23e:	f7f2 fdb9 	bl	8000db4 <__aeabi_fmul>
 800e242:	4603      	mov	r3, r0
 800e244:	461c      	mov	r4, r3
 800e246:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800e24a:	009b      	lsls	r3, r3, #2
 800e24c:	683a      	ldr	r2, [r7, #0]
 800e24e:	4413      	add	r3, r2
 800e250:	681b      	ldr	r3, [r3, #0]
 800e252:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800e254:	4618      	mov	r0, r3
 800e256:	f7f2 fdad 	bl	8000db4 <__aeabi_fmul>
 800e25a:	4603      	mov	r3, r0
 800e25c:	4619      	mov	r1, r3
 800e25e:	4620      	mov	r0, r4
 800e260:	f7f2 fc9e 	bl	8000ba0 <__aeabi_fsub>
 800e264:	4603      	mov	r3, r0
 800e266:	4618      	mov	r0, r3
 800e268:	f7f2 f954 	bl	8000514 <__aeabi_f2d>
 800e26c:	4602      	mov	r2, r0
 800e26e:	460b      	mov	r3, r1
 800e270:	e9c7 2314 	strd	r2, r3, [r7, #80]	; 0x50
                count = 0;
 800e274:	2300      	movs	r3, #0
 800e276:	67fb      	str	r3, [r7, #124]	; 0x7c
            }

            // Update arc_target location
            position[plane.axis_0] = center.x + rv.x;
 800e278:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 800e27c:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800e280:	f7f1 ffea 	bl	8000258 <__adddf3>
 800e284:	4602      	mov	r2, r0
 800e286:	460b      	mov	r3, r1
 800e288:	4610      	mov	r0, r2
 800e28a:	4619      	mov	r1, r3
 800e28c:	f897 30ac 	ldrb.w	r3, [r7, #172]	; 0xac
 800e290:	009b      	lsls	r3, r3, #2
 800e292:	687a      	ldr	r2, [r7, #4]
 800e294:	18d4      	adds	r4, r2, r3
 800e296:	f7f2 fc2f 	bl	8000af8 <__aeabi_d2f>
 800e29a:	4603      	mov	r3, r0
 800e29c:	6023      	str	r3, [r4, #0]
            position[plane.axis_1] = center.y + rv.y;
 800e29e:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 800e2a2:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	; 0x50
 800e2a6:	f7f1 ffd7 	bl	8000258 <__adddf3>
 800e2aa:	4602      	mov	r2, r0
 800e2ac:	460b      	mov	r3, r1
 800e2ae:	4610      	mov	r0, r2
 800e2b0:	4619      	mov	r1, r3
 800e2b2:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
 800e2b6:	009b      	lsls	r3, r3, #2
 800e2b8:	687a      	ldr	r2, [r7, #4]
 800e2ba:	18d4      	adds	r4, r2, r3
 800e2bc:	f7f2 fc1c 	bl	8000af8 <__aeabi_d2f>
 800e2c0:	4603      	mov	r3, r0
 800e2c2:	6023      	str	r3, [r4, #0]
                idx--;
                if(!(idx == plane.axis_0 || idx == plane.axis_1))
                    position[idx] += linear_per_segment[idx];
            } while(idx);
#else
            position[plane.axis_linear] += linear_per_segment;
 800e2c4:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800e2c8:	009b      	lsls	r3, r3, #2
 800e2ca:	687a      	ldr	r2, [r7, #4]
 800e2cc:	4413      	add	r3, r2
 800e2ce:	6818      	ldr	r0, [r3, #0]
 800e2d0:	f897 30ae 	ldrb.w	r3, [r7, #174]	; 0xae
 800e2d4:	009b      	lsls	r3, r3, #2
 800e2d6:	687a      	ldr	r2, [r7, #4]
 800e2d8:	18d4      	adds	r4, r2, r3
 800e2da:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
 800e2dc:	f7f2 fc62 	bl	8000ba4 <__addsf3>
 800e2e0:	4603      	mov	r3, r0
 800e2e2:	6023      	str	r3, [r4, #0]
#endif

            // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
            if(!mc_line(position, pl_data))
 800e2e4:	68b9      	ldr	r1, [r7, #8]
 800e2e6:	6878      	ldr	r0, [r7, #4]
 800e2e8:	f7ff fb86 	bl	800d9f8 <mc_line>
 800e2ec:	4603      	mov	r3, r0
 800e2ee:	f083 0301 	eor.w	r3, r3, #1
 800e2f2:	b2db      	uxtb	r3, r3
 800e2f4:	2b00      	cmp	r3, #0
 800e2f6:	d110      	bne.n	800e31a <mc_arc+0x7aa>
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 800e2f8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e2fc:	3301      	adds	r3, #1
 800e2fe:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e302:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800e306:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e30a:	429a      	cmp	r2, r3
 800e30c:	f4ff aeed 	bcc.w	800e0ea <mc_arc+0x57a>
                return;
        }
    }

    // Ensure last segment arrives at target location.
    mc_line(target, pl_data);
 800e310:	68b9      	ldr	r1, [r7, #8]
 800e312:	68f8      	ldr	r0, [r7, #12]
 800e314:	f7ff fb70 	bl	800d9f8 <mc_line>
 800e318:	e000      	b.n	800e31c <mc_arc+0x7ac>
                return;
 800e31a:	bf00      	nop
}
 800e31c:	3790      	adds	r7, #144	; 0x90
 800e31e:	46bd      	mov	sp, r7
 800e320:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800e324 <interp>:
// Bezier splines, from a pull request for Marlin
// By Giovanni Mascellani - https://github.com/giomasce/Marlin

// Compute the linear interpolation between two real numbers.
static inline float interp (const float a, const float b, const float t)
{
 800e324:	b590      	push	{r4, r7, lr}
 800e326:	b085      	sub	sp, #20
 800e328:	af00      	add	r7, sp, #0
 800e32a:	60f8      	str	r0, [r7, #12]
 800e32c:	60b9      	str	r1, [r7, #8]
 800e32e:	607a      	str	r2, [r7, #4]
    return (1.0f - t) * a + t * b;
 800e330:	6879      	ldr	r1, [r7, #4]
 800e332:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800e336:	f7f2 fc33 	bl	8000ba0 <__aeabi_fsub>
 800e33a:	4603      	mov	r3, r0
 800e33c:	68f9      	ldr	r1, [r7, #12]
 800e33e:	4618      	mov	r0, r3
 800e340:	f7f2 fd38 	bl	8000db4 <__aeabi_fmul>
 800e344:	4603      	mov	r3, r0
 800e346:	461c      	mov	r4, r3
 800e348:	68b9      	ldr	r1, [r7, #8]
 800e34a:	6878      	ldr	r0, [r7, #4]
 800e34c:	f7f2 fd32 	bl	8000db4 <__aeabi_fmul>
 800e350:	4603      	mov	r3, r0
 800e352:	4619      	mov	r1, r3
 800e354:	4620      	mov	r0, r4
 800e356:	f7f2 fc25 	bl	8000ba4 <__addsf3>
 800e35a:	4603      	mov	r3, r0
}
 800e35c:	4618      	mov	r0, r3
 800e35e:	3714      	adds	r7, #20
 800e360:	46bd      	mov	sp, r7
 800e362:	bd90      	pop	{r4, r7, pc}

0800e364 <eval_bezier>:
 * https://en.wikipedia.org/wiki/De_Casteljau's_algorithm), which is
 * easy to code and has good numerical stability (very important,
 * since Arudino works with limited precision real numbers).
 */
static inline float eval_bezier (const float a, const float b, const float c, const float d, const float t)
{
 800e364:	b580      	push	{r7, lr}
 800e366:	b08a      	sub	sp, #40	; 0x28
 800e368:	af00      	add	r7, sp, #0
 800e36a:	60f8      	str	r0, [r7, #12]
 800e36c:	60b9      	str	r1, [r7, #8]
 800e36e:	607a      	str	r2, [r7, #4]
 800e370:	603b      	str	r3, [r7, #0]
    const float iab = interp(a, b, t),
 800e372:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e374:	68b9      	ldr	r1, [r7, #8]
 800e376:	68f8      	ldr	r0, [r7, #12]
 800e378:	f7ff ffd4 	bl	800e324 <interp>
 800e37c:	6278      	str	r0, [r7, #36]	; 0x24
                ibc = interp(b, c, t),
 800e37e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e380:	6879      	ldr	r1, [r7, #4]
 800e382:	68b8      	ldr	r0, [r7, #8]
 800e384:	f7ff ffce 	bl	800e324 <interp>
 800e388:	6238      	str	r0, [r7, #32]
                icd = interp(c, d, t),
 800e38a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e38c:	6839      	ldr	r1, [r7, #0]
 800e38e:	6878      	ldr	r0, [r7, #4]
 800e390:	f7ff ffc8 	bl	800e324 <interp>
 800e394:	61f8      	str	r0, [r7, #28]
                iabc = interp(iab, ibc, t),
 800e396:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e398:	6a39      	ldr	r1, [r7, #32]
 800e39a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e39c:	f7ff ffc2 	bl	800e324 <interp>
 800e3a0:	61b8      	str	r0, [r7, #24]
                ibcd = interp(ibc, icd, t);
 800e3a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e3a4:	69f9      	ldr	r1, [r7, #28]
 800e3a6:	6a38      	ldr	r0, [r7, #32]
 800e3a8:	f7ff ffbc 	bl	800e324 <interp>
 800e3ac:	6178      	str	r0, [r7, #20]

    return interp(iabc, ibcd, t);
 800e3ae:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e3b0:	6979      	ldr	r1, [r7, #20]
 800e3b2:	69b8      	ldr	r0, [r7, #24]
 800e3b4:	f7ff ffb6 	bl	800e324 <interp>
 800e3b8:	4603      	mov	r3, r0
}
 800e3ba:	4618      	mov	r0, r3
 800e3bc:	3728      	adds	r7, #40	; 0x28
 800e3be:	46bd      	mov	sp, r7
 800e3c0:	bd80      	pop	{r7, pc}

0800e3c2 <dist1>:
/**
 * We approximate Euclidean distance with the sum of the coordinates
 * offset (so-called "norm 1"), which is quicker to compute.
 */
static inline float dist1 (const float x1, const float y1, const float x2, const float y2)
{
 800e3c2:	b590      	push	{r4, r7, lr}
 800e3c4:	b085      	sub	sp, #20
 800e3c6:	af00      	add	r7, sp, #0
 800e3c8:	60f8      	str	r0, [r7, #12]
 800e3ca:	60b9      	str	r1, [r7, #8]
 800e3cc:	607a      	str	r2, [r7, #4]
 800e3ce:	603b      	str	r3, [r7, #0]
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 800e3d0:	6879      	ldr	r1, [r7, #4]
 800e3d2:	68f8      	ldr	r0, [r7, #12]
 800e3d4:	f7f2 fbe4 	bl	8000ba0 <__aeabi_fsub>
 800e3d8:	4603      	mov	r3, r0
 800e3da:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 800e3de:	6839      	ldr	r1, [r7, #0]
 800e3e0:	68b8      	ldr	r0, [r7, #8]
 800e3e2:	f7f2 fbdd 	bl	8000ba0 <__aeabi_fsub>
 800e3e6:	4603      	mov	r3, r0
 800e3e8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e3ec:	4619      	mov	r1, r3
 800e3ee:	4620      	mov	r0, r4
 800e3f0:	f7f2 fbd8 	bl	8000ba4 <__addsf3>
 800e3f4:	4603      	mov	r3, r0
}
 800e3f6:	4618      	mov	r0, r3
 800e3f8:	3714      	adds	r7, #20
 800e3fa:	46bd      	mov	sp, r7
 800e3fc:	bd90      	pop	{r4, r7, pc}
	...

0800e400 <mc_cubic_b_spline>:
 * the mitigation offered by MIN_STEP and the small computational
 * power available on Arduino, I think it is not wise to implement it.
 */

void mc_cubic_b_spline (float *target, plan_line_data_t *pl_data, float *position, float *first, float *second)
{
 800e400:	b590      	push	{r4, r7, lr}
 800e402:	b09b      	sub	sp, #108	; 0x6c
 800e404:	af02      	add	r7, sp, #8
 800e406:	60f8      	str	r0, [r7, #12]
 800e408:	60b9      	str	r1, [r7, #8]
 800e40a:	607a      	str	r2, [r7, #4]
 800e40c:	603b      	str	r3, [r7, #0]
    float bez_target[N_AXIS];

    memcpy(bez_target, position, sizeof(float) * N_AXIS);
 800e40e:	f107 0314 	add.w	r3, r7, #20
 800e412:	220c      	movs	r2, #12
 800e414:	6879      	ldr	r1, [r7, #4]
 800e416:	4618      	mov	r0, r3
 800e418:	f015 fd59 	bl	8023ece <memcpy>

    float t = 0.0f, step = BEZIER_MAX_STEP;
 800e41c:	f04f 0300 	mov.w	r3, #0
 800e420:	65fb      	str	r3, [r7, #92]	; 0x5c
 800e422:	4b90      	ldr	r3, [pc, #576]	; (800e664 <mc_cubic_b_spline+0x264>)
 800e424:	65bb      	str	r3, [r7, #88]	; 0x58

    while (t < 1.0f) {
 800e426:	e13a      	b.n	800e69e <mc_cubic_b_spline+0x29e>

        // First try to reduce the step in order to make it sufficiently
        // close to a linear interpolation.
        bool did_reduce = false;
 800e428:	2300      	movs	r3, #0
 800e42a:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
        float new_t = t + step;
 800e42e:	6db9      	ldr	r1, [r7, #88]	; 0x58
 800e430:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800e432:	f7f2 fbb7 	bl	8000ba4 <__addsf3>
 800e436:	4603      	mov	r3, r0
 800e438:	653b      	str	r3, [r7, #80]	; 0x50

        if(new_t > 1.0f)
 800e43a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800e43e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800e440:	f7f2 fe74 	bl	800112c <__aeabi_fcmpgt>
 800e444:	4603      	mov	r3, r0
 800e446:	2b00      	cmp	r3, #0
 800e448:	d002      	beq.n	800e450 <mc_cubic_b_spline+0x50>
            new_t = 1.0f;
 800e44a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800e44e:	653b      	str	r3, [r7, #80]	; 0x50

        float new_pos0 = eval_bezier(position[X_AXIS], first[X_AXIS], second[X_AXIS], target[X_AXIS], new_t),
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	6818      	ldr	r0, [r3, #0]
 800e454:	683b      	ldr	r3, [r7, #0]
 800e456:	6819      	ldr	r1, [r3, #0]
 800e458:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e45a:	681a      	ldr	r2, [r3, #0]
 800e45c:	68fb      	ldr	r3, [r7, #12]
 800e45e:	681c      	ldr	r4, [r3, #0]
 800e460:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e462:	9300      	str	r3, [sp, #0]
 800e464:	4623      	mov	r3, r4
 800e466:	f7ff ff7d 	bl	800e364 <eval_bezier>
 800e46a:	64f8      	str	r0, [r7, #76]	; 0x4c
              new_pos1 = eval_bezier(position[Y_AXIS], first[Y_AXIS], second[Y_AXIS], target[Y_AXIS], new_t);
 800e46c:	687b      	ldr	r3, [r7, #4]
 800e46e:	3304      	adds	r3, #4
 800e470:	6818      	ldr	r0, [r3, #0]
 800e472:	683b      	ldr	r3, [r7, #0]
 800e474:	3304      	adds	r3, #4
 800e476:	6819      	ldr	r1, [r3, #0]
 800e478:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e47a:	3304      	adds	r3, #4
 800e47c:	681a      	ldr	r2, [r3, #0]
 800e47e:	68fb      	ldr	r3, [r7, #12]
 800e480:	3304      	adds	r3, #4
 800e482:	681c      	ldr	r4, [r3, #0]
 800e484:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e486:	9300      	str	r3, [sp, #0]
 800e488:	4623      	mov	r3, r4
 800e48a:	f7ff ff6b 	bl	800e364 <eval_bezier>
 800e48e:	64b8      	str	r0, [r7, #72]	; 0x48

        while(new_t - t >= (BEZIER_MIN_STEP)) {
 800e490:	e05c      	b.n	800e54c <mc_cubic_b_spline+0x14c>

//            if (new_t - t < (BEZIER_MIN_STEP))
//                break;

            const float candidate_t = 0.5f * (t + new_t),
 800e492:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800e494:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800e496:	f7f2 fb85 	bl	8000ba4 <__addsf3>
 800e49a:	4603      	mov	r3, r0
 800e49c:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e4a0:	4618      	mov	r0, r3
 800e4a2:	f7f2 fc87 	bl	8000db4 <__aeabi_fmul>
 800e4a6:	4603      	mov	r3, r0
 800e4a8:	647b      	str	r3, [r7, #68]	; 0x44
                      candidate_pos0 = eval_bezier(position[X_AXIS], first[X_AXIS], second[X_AXIS], target[X_AXIS], candidate_t),
 800e4aa:	687b      	ldr	r3, [r7, #4]
 800e4ac:	6818      	ldr	r0, [r3, #0]
 800e4ae:	683b      	ldr	r3, [r7, #0]
 800e4b0:	6819      	ldr	r1, [r3, #0]
 800e4b2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e4b4:	681a      	ldr	r2, [r3, #0]
 800e4b6:	68fb      	ldr	r3, [r7, #12]
 800e4b8:	681c      	ldr	r4, [r3, #0]
 800e4ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e4bc:	9300      	str	r3, [sp, #0]
 800e4be:	4623      	mov	r3, r4
 800e4c0:	f7ff ff50 	bl	800e364 <eval_bezier>
 800e4c4:	6438      	str	r0, [r7, #64]	; 0x40
                      candidate_pos1 = eval_bezier(position[Y_AXIS], first[Y_AXIS], second[Y_AXIS], target[Y_AXIS], candidate_t),
 800e4c6:	687b      	ldr	r3, [r7, #4]
 800e4c8:	3304      	adds	r3, #4
 800e4ca:	6818      	ldr	r0, [r3, #0]
 800e4cc:	683b      	ldr	r3, [r7, #0]
 800e4ce:	3304      	adds	r3, #4
 800e4d0:	6819      	ldr	r1, [r3, #0]
 800e4d2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e4d4:	3304      	adds	r3, #4
 800e4d6:	681a      	ldr	r2, [r3, #0]
 800e4d8:	68fb      	ldr	r3, [r7, #12]
 800e4da:	3304      	adds	r3, #4
 800e4dc:	681c      	ldr	r4, [r3, #0]
 800e4de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e4e0:	9300      	str	r3, [sp, #0]
 800e4e2:	4623      	mov	r3, r4
 800e4e4:	f7ff ff3e 	bl	800e364 <eval_bezier>
 800e4e8:	63f8      	str	r0, [r7, #60]	; 0x3c
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
 800e4ea:	697b      	ldr	r3, [r7, #20]
 800e4ec:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800e4ee:	4618      	mov	r0, r3
 800e4f0:	f7f2 fb58 	bl	8000ba4 <__addsf3>
 800e4f4:	4603      	mov	r3, r0
 800e4f6:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e4fa:	4618      	mov	r0, r3
 800e4fc:	f7f2 fc5a 	bl	8000db4 <__aeabi_fmul>
 800e500:	4603      	mov	r3, r0
 800e502:	63bb      	str	r3, [r7, #56]	; 0x38
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
 800e504:	69bb      	ldr	r3, [r7, #24]
 800e506:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800e508:	4618      	mov	r0, r3
 800e50a:	f7f2 fb4b 	bl	8000ba4 <__addsf3>
 800e50e:	4603      	mov	r3, r0
 800e510:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e514:	4618      	mov	r0, r3
 800e516:	f7f2 fc4d 	bl	8000db4 <__aeabi_fmul>
 800e51a:	4603      	mov	r3, r0
 800e51c:	637b      	str	r3, [r7, #52]	; 0x34

            if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (BEZIER_SIGMA))
 800e51e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e520:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e522:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800e524:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800e526:	f7ff ff4c 	bl	800e3c2 <dist1>
 800e52a:	4603      	mov	r3, r0
 800e52c:	494d      	ldr	r1, [pc, #308]	; (800e664 <mc_cubic_b_spline+0x264>)
 800e52e:	4618      	mov	r0, r3
 800e530:	f7f2 fde8 	bl	8001104 <__aeabi_fcmple>
 800e534:	4603      	mov	r3, r0
 800e536:	2b00      	cmp	r3, #0
 800e538:	d115      	bne.n	800e566 <mc_cubic_b_spline+0x166>
                break;

            new_t = candidate_t;
 800e53a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e53c:	653b      	str	r3, [r7, #80]	; 0x50
            new_pos0 = candidate_pos0;
 800e53e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e540:	64fb      	str	r3, [r7, #76]	; 0x4c
            new_pos1 = candidate_pos1;
 800e542:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e544:	64bb      	str	r3, [r7, #72]	; 0x48
            did_reduce = true;
 800e546:	2301      	movs	r3, #1
 800e548:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
        while(new_t - t >= (BEZIER_MIN_STEP)) {
 800e54c:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e54e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800e550:	f7f2 fb26 	bl	8000ba0 <__aeabi_fsub>
 800e554:	4603      	mov	r3, r0
 800e556:	4944      	ldr	r1, [pc, #272]	; (800e668 <mc_cubic_b_spline+0x268>)
 800e558:	4618      	mov	r0, r3
 800e55a:	f7f2 fddd 	bl	8001118 <__aeabi_fcmpge>
 800e55e:	4603      	mov	r3, r0
 800e560:	2b00      	cmp	r3, #0
 800e562:	d196      	bne.n	800e492 <mc_cubic_b_spline+0x92>
 800e564:	e000      	b.n	800e568 <mc_cubic_b_spline+0x168>
                break;
 800e566:	bf00      	nop
        }

        // If we did not reduce the step, maybe we should enlarge it.
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 800e568:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e56c:	f083 0301 	eor.w	r3, r3, #1
 800e570:	b2db      	uxtb	r3, r3
 800e572:	2b00      	cmp	r3, #0
 800e574:	d07b      	beq.n	800e66e <mc_cubic_b_spline+0x26e>
 800e576:	e065      	b.n	800e644 <mc_cubic_b_spline+0x244>

//            if (new_t - t > BEZIER_MAX_STEP)
//                break;

            const float candidate_t = t + 2.0f * (new_t - t);
 800e578:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e57a:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800e57c:	f7f2 fb10 	bl	8000ba0 <__aeabi_fsub>
 800e580:	4603      	mov	r3, r0
 800e582:	4619      	mov	r1, r3
 800e584:	4618      	mov	r0, r3
 800e586:	f7f2 fb0d 	bl	8000ba4 <__addsf3>
 800e58a:	4603      	mov	r3, r0
 800e58c:	4619      	mov	r1, r3
 800e58e:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800e590:	f7f2 fb08 	bl	8000ba4 <__addsf3>
 800e594:	4603      	mov	r3, r0
 800e596:	633b      	str	r3, [r7, #48]	; 0x30

            if (candidate_t >= 1.0f)
 800e598:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800e59c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800e59e:	f7f2 fdbb 	bl	8001118 <__aeabi_fcmpge>
 800e5a2:	4603      	mov	r3, r0
 800e5a4:	2b00      	cmp	r3, #0
 800e5a6:	d15a      	bne.n	800e65e <mc_cubic_b_spline+0x25e>
                break;

            const float candidate_pos0 = eval_bezier(position[X_AXIS], first[X_AXIS], second[X_AXIS], target[X_AXIS], candidate_t),
 800e5a8:	687b      	ldr	r3, [r7, #4]
 800e5aa:	6818      	ldr	r0, [r3, #0]
 800e5ac:	683b      	ldr	r3, [r7, #0]
 800e5ae:	6819      	ldr	r1, [r3, #0]
 800e5b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e5b2:	681a      	ldr	r2, [r3, #0]
 800e5b4:	68fb      	ldr	r3, [r7, #12]
 800e5b6:	681c      	ldr	r4, [r3, #0]
 800e5b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e5ba:	9300      	str	r3, [sp, #0]
 800e5bc:	4623      	mov	r3, r4
 800e5be:	f7ff fed1 	bl	800e364 <eval_bezier>
 800e5c2:	62f8      	str	r0, [r7, #44]	; 0x2c
                      candidate_pos1 = eval_bezier(position[Y_AXIS], first[Y_AXIS], second[Y_AXIS], target[Y_AXIS], candidate_t),
 800e5c4:	687b      	ldr	r3, [r7, #4]
 800e5c6:	3304      	adds	r3, #4
 800e5c8:	6818      	ldr	r0, [r3, #0]
 800e5ca:	683b      	ldr	r3, [r7, #0]
 800e5cc:	3304      	adds	r3, #4
 800e5ce:	6819      	ldr	r1, [r3, #0]
 800e5d0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e5d2:	3304      	adds	r3, #4
 800e5d4:	681a      	ldr	r2, [r3, #0]
 800e5d6:	68fb      	ldr	r3, [r7, #12]
 800e5d8:	3304      	adds	r3, #4
 800e5da:	681c      	ldr	r4, [r3, #0]
 800e5dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e5de:	9300      	str	r3, [sp, #0]
 800e5e0:	4623      	mov	r3, r4
 800e5e2:	f7ff febf 	bl	800e364 <eval_bezier>
 800e5e6:	62b8      	str	r0, [r7, #40]	; 0x28
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
 800e5e8:	697b      	ldr	r3, [r7, #20]
 800e5ea:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800e5ec:	4618      	mov	r0, r3
 800e5ee:	f7f2 fad9 	bl	8000ba4 <__addsf3>
 800e5f2:	4603      	mov	r3, r0
 800e5f4:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e5f8:	4618      	mov	r0, r3
 800e5fa:	f7f2 fbdb 	bl	8000db4 <__aeabi_fmul>
 800e5fe:	4603      	mov	r3, r0
 800e600:	627b      	str	r3, [r7, #36]	; 0x24
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
 800e602:	69bb      	ldr	r3, [r7, #24]
 800e604:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800e606:	4618      	mov	r0, r3
 800e608:	f7f2 facc 	bl	8000ba4 <__addsf3>
 800e60c:	4603      	mov	r3, r0
 800e60e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800e612:	4618      	mov	r0, r3
 800e614:	f7f2 fbce 	bl	8000db4 <__aeabi_fmul>
 800e618:	4603      	mov	r3, r0
 800e61a:	623b      	str	r3, [r7, #32]

            if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (BEZIER_SIGMA))
 800e61c:	6a3b      	ldr	r3, [r7, #32]
 800e61e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e620:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800e622:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800e624:	f7ff fecd 	bl	800e3c2 <dist1>
 800e628:	4603      	mov	r3, r0
 800e62a:	490e      	ldr	r1, [pc, #56]	; (800e664 <mc_cubic_b_spline+0x264>)
 800e62c:	4618      	mov	r0, r3
 800e62e:	f7f2 fd7d 	bl	800112c <__aeabi_fcmpgt>
 800e632:	4603      	mov	r3, r0
 800e634:	2b00      	cmp	r3, #0
 800e636:	d119      	bne.n	800e66c <mc_cubic_b_spline+0x26c>
                break;

            new_t = candidate_t;
 800e638:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e63a:	653b      	str	r3, [r7, #80]	; 0x50
            new_pos0 = candidate_pos0;
 800e63c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e63e:	64fb      	str	r3, [r7, #76]	; 0x4c
            new_pos1 = candidate_pos1;
 800e640:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e642:	64bb      	str	r3, [r7, #72]	; 0x48
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 800e644:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e646:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800e648:	f7f2 faaa 	bl	8000ba0 <__aeabi_fsub>
 800e64c:	4603      	mov	r3, r0
 800e64e:	4905      	ldr	r1, [pc, #20]	; (800e664 <mc_cubic_b_spline+0x264>)
 800e650:	4618      	mov	r0, r3
 800e652:	f7f2 fd57 	bl	8001104 <__aeabi_fcmple>
 800e656:	4603      	mov	r3, r0
 800e658:	2b00      	cmp	r3, #0
 800e65a:	d18d      	bne.n	800e578 <mc_cubic_b_spline+0x178>
 800e65c:	e007      	b.n	800e66e <mc_cubic_b_spline+0x26e>
                break;
 800e65e:	bf00      	nop
 800e660:	e005      	b.n	800e66e <mc_cubic_b_spline+0x26e>
 800e662:	bf00      	nop
 800e664:	3dcccccd 	.word	0x3dcccccd
 800e668:	3b03126f 	.word	0x3b03126f
                break;
 800e66c:	bf00      	nop
            assert(new_t - t >= (MIN_STEP) / 2.0);
            assert(new_t - t <= (MAX_STEP) * 2.0);
          }
        */

        step = new_t - t;
 800e66e:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800e670:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800e672:	f7f2 fa95 	bl	8000ba0 <__aeabi_fsub>
 800e676:	4603      	mov	r3, r0
 800e678:	65bb      	str	r3, [r7, #88]	; 0x58
        t = new_t;
 800e67a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e67c:	65fb      	str	r3, [r7, #92]	; 0x5c

        bez_target[X_AXIS] = new_pos0;
 800e67e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e680:	617b      	str	r3, [r7, #20]
        bez_target[Y_AXIS] = new_pos1;
 800e682:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e684:	61bb      	str	r3, [r7, #24]

        // Bail mid-spline on system abort. Runtime command check already performed by mc_line.
        if(!mc_line(bez_target, pl_data))
 800e686:	f107 0314 	add.w	r3, r7, #20
 800e68a:	68b9      	ldr	r1, [r7, #8]
 800e68c:	4618      	mov	r0, r3
 800e68e:	f7ff f9b3 	bl	800d9f8 <mc_line>
 800e692:	4603      	mov	r3, r0
 800e694:	f083 0301 	eor.w	r3, r3, #1
 800e698:	b2db      	uxtb	r3, r3
 800e69a:	2b00      	cmp	r3, #0
 800e69c:	d109      	bne.n	800e6b2 <mc_cubic_b_spline+0x2b2>
    while (t < 1.0f) {
 800e69e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800e6a2:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 800e6a4:	f7f2 fd24 	bl	80010f0 <__aeabi_fcmplt>
 800e6a8:	4603      	mov	r3, r0
 800e6aa:	2b00      	cmp	r3, #0
 800e6ac:	f47f aebc 	bne.w	800e428 <mc_cubic_b_spline+0x28>
 800e6b0:	e000      	b.n	800e6b4 <mc_cubic_b_spline+0x2b4>
            return;
 800e6b2:	bf00      	nop
    }
}
 800e6b4:	3764      	adds	r7, #100	; 0x64
 800e6b6:	46bd      	mov	sp, r7
 800e6b8:	bd90      	pop	{r4, r7, pc}
 800e6ba:	bf00      	nop

0800e6bc <mc_canned_drill>:

// end Bezier splines

void mc_canned_drill (motion_mode_t motion, float *target, plan_line_data_t *pl_data, float *position, plane_t plane, uint32_t repeats, gc_canned_t *canned)
{
 800e6bc:	b590      	push	{r4, r7, lr}
 800e6be:	b087      	sub	sp, #28
 800e6c0:	af00      	add	r7, sp, #0
 800e6c2:	60b9      	str	r1, [r7, #8]
 800e6c4:	607a      	str	r2, [r7, #4]
 800e6c6:	603b      	str	r3, [r7, #0]
 800e6c8:	4603      	mov	r3, r0
 800e6ca:	81fb      	strh	r3, [r7, #14]
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 800e6cc:	687a      	ldr	r2, [r7, #4]
 800e6ce:	7e13      	ldrb	r3, [r2, #24]
 800e6d0:	f043 0301 	orr.w	r3, r3, #1
 800e6d4:	7613      	strb	r3, [r2, #24]

    // if current Z < R, rapid move to R
    if(position[plane.axis_linear] < canned->retract_position) {
 800e6d6:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e6da:	009b      	lsls	r3, r3, #2
 800e6dc:	683a      	ldr	r2, [r7, #0]
 800e6de:	4413      	add	r3, r2
 800e6e0:	681a      	ldr	r2, [r3, #0]
 800e6e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6e4:	695b      	ldr	r3, [r3, #20]
 800e6e6:	4619      	mov	r1, r3
 800e6e8:	4610      	mov	r0, r2
 800e6ea:	f7f2 fd01 	bl	80010f0 <__aeabi_fcmplt>
 800e6ee:	4603      	mov	r3, r0
 800e6f0:	2b00      	cmp	r3, #0
 800e6f2:	d012      	beq.n	800e71a <mc_canned_drill+0x5e>
        position[plane.axis_linear] = canned->retract_position;
 800e6f4:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e6f8:	009b      	lsls	r3, r3, #2
 800e6fa:	683a      	ldr	r2, [r7, #0]
 800e6fc:	4413      	add	r3, r2
 800e6fe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e700:	6952      	ldr	r2, [r2, #20]
 800e702:	601a      	str	r2, [r3, #0]
        if(!mc_line(position, pl_data))
 800e704:	6879      	ldr	r1, [r7, #4]
 800e706:	6838      	ldr	r0, [r7, #0]
 800e708:	f7ff f976 	bl	800d9f8 <mc_line>
 800e70c:	4603      	mov	r3, r0
 800e70e:	f083 0301 	eor.w	r3, r3, #1
 800e712:	b2db      	uxtb	r3, r3
 800e714:	2b00      	cmp	r3, #0
 800e716:	f040 814e 	bne.w	800e9b6 <mc_canned_drill+0x2fa>
            return;
    }

    float position_linear = position[plane.axis_linear],
 800e71a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e71e:	009b      	lsls	r3, r3, #2
 800e720:	683a      	ldr	r2, [r7, #0]
 800e722:	4413      	add	r3, r2
 800e724:	681b      	ldr	r3, [r3, #0]
 800e726:	617b      	str	r3, [r7, #20]
          retract_to = canned->retract_mode == CCRetractMode_RPos ? canned->retract_position : position_linear;
 800e728:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e72a:	7e9b      	ldrb	r3, [r3, #26]
 800e72c:	2b01      	cmp	r3, #1
 800e72e:	d102      	bne.n	800e736 <mc_canned_drill+0x7a>
 800e730:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e732:	695b      	ldr	r3, [r3, #20]
 800e734:	e000      	b.n	800e738 <mc_canned_drill+0x7c>
 800e736:	697b      	ldr	r3, [r7, #20]
 800e738:	613b      	str	r3, [r7, #16]

    // rapid move to X, Y
    memcpy(position, target, sizeof(float) * N_AXIS);
 800e73a:	220c      	movs	r2, #12
 800e73c:	68b9      	ldr	r1, [r7, #8]
 800e73e:	6838      	ldr	r0, [r7, #0]
 800e740:	f015 fbc5 	bl	8023ece <memcpy>
    position[plane.axis_linear] = position_linear;
 800e744:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e748:	009b      	lsls	r3, r3, #2
 800e74a:	683a      	ldr	r2, [r7, #0]
 800e74c:	4413      	add	r3, r2
 800e74e:	697a      	ldr	r2, [r7, #20]
 800e750:	601a      	str	r2, [r3, #0]
    if(!mc_line(position, pl_data))
 800e752:	6879      	ldr	r1, [r7, #4]
 800e754:	6838      	ldr	r0, [r7, #0]
 800e756:	f7ff f94f 	bl	800d9f8 <mc_line>
 800e75a:	4603      	mov	r3, r0
 800e75c:	f083 0301 	eor.w	r3, r3, #1
 800e760:	b2db      	uxtb	r3, r3
 800e762:	2b00      	cmp	r3, #0
 800e764:	f040 8129 	bne.w	800e9ba <mc_canned_drill+0x2fe>
        return;

    while(repeats--) {
 800e768:	e119      	b.n	800e99e <mc_canned_drill+0x2e2>

        // if current Z > R, rapid move to R
        if(position[plane.axis_linear] > canned->retract_position) {
 800e76a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e76e:	009b      	lsls	r3, r3, #2
 800e770:	683a      	ldr	r2, [r7, #0]
 800e772:	4413      	add	r3, r2
 800e774:	681a      	ldr	r2, [r3, #0]
 800e776:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e778:	695b      	ldr	r3, [r3, #20]
 800e77a:	4619      	mov	r1, r3
 800e77c:	4610      	mov	r0, r2
 800e77e:	f7f2 fcd5 	bl	800112c <__aeabi_fcmpgt>
 800e782:	4603      	mov	r3, r0
 800e784:	2b00      	cmp	r3, #0
 800e786:	d012      	beq.n	800e7ae <mc_canned_drill+0xf2>
            position[plane.axis_linear] = canned->retract_position;
 800e788:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e78c:	009b      	lsls	r3, r3, #2
 800e78e:	683a      	ldr	r2, [r7, #0]
 800e790:	4413      	add	r3, r2
 800e792:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e794:	6952      	ldr	r2, [r2, #20]
 800e796:	601a      	str	r2, [r3, #0]
            if(!mc_line(position, pl_data))
 800e798:	6879      	ldr	r1, [r7, #4]
 800e79a:	6838      	ldr	r0, [r7, #0]
 800e79c:	f7ff f92c 	bl	800d9f8 <mc_line>
 800e7a0:	4603      	mov	r3, r0
 800e7a2:	f083 0301 	eor.w	r3, r3, #1
 800e7a6:	b2db      	uxtb	r3, r3
 800e7a8:	2b00      	cmp	r3, #0
 800e7aa:	f040 8108 	bne.w	800e9be <mc_canned_drill+0x302>
                return;
        }

        position_linear = position[plane.axis_linear];
 800e7ae:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e7b2:	009b      	lsls	r3, r3, #2
 800e7b4:	683a      	ldr	r2, [r7, #0]
 800e7b6:	4413      	add	r3, r2
 800e7b8:	681b      	ldr	r3, [r3, #0]
 800e7ba:	617b      	str	r3, [r7, #20]

        while(position_linear > canned->xyz[plane.axis_linear]) {
 800e7bc:	e0a1      	b.n	800e902 <mc_canned_drill+0x246>

            position_linear -= canned->delta;
 800e7be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e7c0:	68db      	ldr	r3, [r3, #12]
 800e7c2:	4619      	mov	r1, r3
 800e7c4:	6978      	ldr	r0, [r7, #20]
 800e7c6:	f7f2 f9eb 	bl	8000ba0 <__aeabi_fsub>
 800e7ca:	4603      	mov	r3, r0
 800e7cc:	617b      	str	r3, [r7, #20]
            if(position_linear < canned->xyz[plane.axis_linear])
 800e7ce:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e7d2:	461a      	mov	r2, r3
 800e7d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e7d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e7da:	4619      	mov	r1, r3
 800e7dc:	6978      	ldr	r0, [r7, #20]
 800e7de:	f7f2 fc87 	bl	80010f0 <__aeabi_fcmplt>
 800e7e2:	4603      	mov	r3, r0
 800e7e4:	2b00      	cmp	r3, #0
 800e7e6:	d006      	beq.n	800e7f6 <mc_canned_drill+0x13a>
                position_linear = canned->xyz[plane.axis_linear];
 800e7e8:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e7ec:	461a      	mov	r2, r3
 800e7ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e7f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e7f4:	617b      	str	r3, [r7, #20]

            pl_data->condition.rapid_motion = Off;
 800e7f6:	687a      	ldr	r2, [r7, #4]
 800e7f8:	7e13      	ldrb	r3, [r2, #24]
 800e7fa:	f36f 0300 	bfc	r3, #0, #1
 800e7fe:	7613      	strb	r3, [r2, #24]

            position[plane.axis_linear] = position_linear;
 800e800:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e804:	009b      	lsls	r3, r3, #2
 800e806:	683a      	ldr	r2, [r7, #0]
 800e808:	4413      	add	r3, r2
 800e80a:	697a      	ldr	r2, [r7, #20]
 800e80c:	601a      	str	r2, [r3, #0]
            if(!mc_line(position, pl_data)) // drill
 800e80e:	6879      	ldr	r1, [r7, #4]
 800e810:	6838      	ldr	r0, [r7, #0]
 800e812:	f7ff f8f1 	bl	800d9f8 <mc_line>
 800e816:	4603      	mov	r3, r0
 800e818:	f083 0301 	eor.w	r3, r3, #1
 800e81c:	b2db      	uxtb	r3, r3
 800e81e:	2b00      	cmp	r3, #0
 800e820:	f040 80cf 	bne.w	800e9c2 <mc_canned_drill+0x306>
                return;

            if(canned->dwell > 0.0f)
 800e824:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e826:	691b      	ldr	r3, [r3, #16]
 800e828:	f04f 0100 	mov.w	r1, #0
 800e82c:	4618      	mov	r0, r3
 800e82e:	f7f2 fc7d 	bl	800112c <__aeabi_fcmpgt>
 800e832:	4603      	mov	r3, r0
 800e834:	2b00      	cmp	r3, #0
 800e836:	d004      	beq.n	800e842 <mc_canned_drill+0x186>
                mc_dwell(canned->dwell);
 800e838:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e83a:	691b      	ldr	r3, [r3, #16]
 800e83c:	4618      	mov	r0, r3
 800e83e:	f000 fbaf 	bl	800efa0 <mc_dwell>

            if(canned->spindle_off)
 800e842:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e844:	7e5b      	ldrb	r3, [r3, #25]
 800e846:	2b00      	cmp	r3, #0
 800e848:	d009      	beq.n	800e85e <mc_canned_drill+0x1a2>
                pl_data->spindle.hal->set_state(pl_data->spindle.hal, (spindle_state_t){0}, 0.0f);
 800e84a:	687b      	ldr	r3, [r7, #4]
 800e84c:	695b      	ldr	r3, [r3, #20]
 800e84e:	6a1b      	ldr	r3, [r3, #32]
 800e850:	687a      	ldr	r2, [r7, #4]
 800e852:	6950      	ldr	r0, [r2, #20]
 800e854:	2200      	movs	r2, #0
 800e856:	4611      	mov	r1, r2
 800e858:	f04f 0200 	mov.w	r2, #0
 800e85c:	4798      	blx	r3

            // rapid retract
            switch(motion) {
 800e85e:	89fb      	ldrh	r3, [r7, #14]
 800e860:	2b49      	cmp	r3, #73	; 0x49
 800e862:	d128      	bne.n	800e8b6 <mc_canned_drill+0x1fa>

                case MotionMode_DrillChipBreak:
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 800e864:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e868:	009b      	lsls	r3, r3, #2
 800e86a:	683a      	ldr	r2, [r7, #0]
 800e86c:	4413      	add	r3, r2
 800e86e:	681a      	ldr	r2, [r3, #0]
 800e870:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e874:	4619      	mov	r1, r3
 800e876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e878:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
                                                   ? retract_to
                                                   : position[plane.axis_linear] + settings.g73_retract;
 800e87c:	4619      	mov	r1, r3
 800e87e:	4610      	mov	r0, r2
 800e880:	f7f2 fc2c 	bl	80010dc <__aeabi_fcmpeq>
 800e884:	4603      	mov	r3, r0
 800e886:	2b00      	cmp	r3, #0
 800e888:	d10d      	bne.n	800e8a6 <mc_canned_drill+0x1ea>
 800e88a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e88e:	009b      	lsls	r3, r3, #2
 800e890:	683a      	ldr	r2, [r7, #0]
 800e892:	4413      	add	r3, r2
 800e894:	681b      	ldr	r3, [r3, #0]
 800e896:	4a4f      	ldr	r2, [pc, #316]	; (800e9d4 <mc_canned_drill+0x318>)
 800e898:	68d2      	ldr	r2, [r2, #12]
 800e89a:	4611      	mov	r1, r2
 800e89c:	4618      	mov	r0, r3
 800e89e:	f7f2 f981 	bl	8000ba4 <__addsf3>
 800e8a2:	4603      	mov	r3, r0
 800e8a4:	e000      	b.n	800e8a8 <mc_canned_drill+0x1ec>
 800e8a6:	693b      	ldr	r3, [r7, #16]
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 800e8a8:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
 800e8ac:	0092      	lsls	r2, r2, #2
 800e8ae:	6839      	ldr	r1, [r7, #0]
 800e8b0:	440a      	add	r2, r1
 800e8b2:	6013      	str	r3, [r2, #0]
                    break;
 800e8b4:	e007      	b.n	800e8c6 <mc_canned_drill+0x20a>

                default:
                    position[plane.axis_linear] = retract_to;
 800e8b6:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e8ba:	009b      	lsls	r3, r3, #2
 800e8bc:	683a      	ldr	r2, [r7, #0]
 800e8be:	4413      	add	r3, r2
 800e8c0:	693a      	ldr	r2, [r7, #16]
 800e8c2:	601a      	str	r2, [r3, #0]
                    break;
 800e8c4:	bf00      	nop
            }

            pl_data->condition.rapid_motion = canned->rapid_retract;
 800e8c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8c8:	7e19      	ldrb	r1, [r3, #24]
 800e8ca:	687a      	ldr	r2, [r7, #4]
 800e8cc:	7e13      	ldrb	r3, [r2, #24]
 800e8ce:	f361 0300 	bfi	r3, r1, #0, #1
 800e8d2:	7613      	strb	r3, [r2, #24]
            if(!mc_line(position, pl_data))
 800e8d4:	6879      	ldr	r1, [r7, #4]
 800e8d6:	6838      	ldr	r0, [r7, #0]
 800e8d8:	f7ff f88e 	bl	800d9f8 <mc_line>
 800e8dc:	4603      	mov	r3, r0
 800e8de:	f083 0301 	eor.w	r3, r3, #1
 800e8e2:	b2db      	uxtb	r3, r3
 800e8e4:	2b00      	cmp	r3, #0
 800e8e6:	d16e      	bne.n	800e9c6 <mc_canned_drill+0x30a>
                return;

            if(canned->spindle_off)
 800e8e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8ea:	7e5b      	ldrb	r3, [r3, #25]
 800e8ec:	2b00      	cmp	r3, #0
 800e8ee:	d008      	beq.n	800e902 <mc_canned_drill+0x246>
                spindle_sync(pl_data->spindle.hal, gc_state.modal.spindle.state, pl_data->spindle.rpm);
 800e8f0:	687b      	ldr	r3, [r7, #4]
 800e8f2:	6958      	ldr	r0, [r3, #20]
 800e8f4:	687b      	ldr	r3, [r7, #4]
 800e8f6:	689b      	ldr	r3, [r3, #8]
 800e8f8:	4937      	ldr	r1, [pc, #220]	; (800e9d8 <mc_canned_drill+0x31c>)
 800e8fa:	461a      	mov	r2, r3
 800e8fc:	7e89      	ldrb	r1, [r1, #26]
 800e8fe:	f00e fa79 	bl	801cdf4 <spindle_sync>
        while(position_linear > canned->xyz[plane.axis_linear]) {
 800e902:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800e906:	461a      	mov	r2, r3
 800e908:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e90a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e90e:	4619      	mov	r1, r3
 800e910:	6978      	ldr	r0, [r7, #20]
 800e912:	f7f2 fc0b 	bl	800112c <__aeabi_fcmpgt>
 800e916:	4603      	mov	r3, r0
 800e918:	2b00      	cmp	r3, #0
 800e91a:	f47f af50 	bne.w	800e7be <mc_canned_drill+0x102>
        }

        pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 800e91e:	687a      	ldr	r2, [r7, #4]
 800e920:	7e13      	ldrb	r3, [r2, #24]
 800e922:	f043 0301 	orr.w	r3, r3, #1
 800e926:	7613      	strb	r3, [r2, #24]

       // rapid move to next position if incremental mode
        if(repeats && gc_state.modal.distance_incremental) {
 800e928:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e92a:	2b00      	cmp	r3, #0
 800e92c:	d037      	beq.n	800e99e <mc_canned_drill+0x2e2>
 800e92e:	4b2a      	ldr	r3, [pc, #168]	; (800e9d8 <mc_canned_drill+0x31c>)
 800e930:	791b      	ldrb	r3, [r3, #4]
 800e932:	2b00      	cmp	r3, #0
 800e934:	d033      	beq.n	800e99e <mc_canned_drill+0x2e2>
            position[plane.axis_0] += canned->xyz[plane.axis_0];
 800e936:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800e93a:	009b      	lsls	r3, r3, #2
 800e93c:	683a      	ldr	r2, [r7, #0]
 800e93e:	4413      	add	r3, r2
 800e940:	6818      	ldr	r0, [r3, #0]
 800e942:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800e946:	461a      	mov	r2, r3
 800e948:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e94a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800e94e:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800e952:	009b      	lsls	r3, r3, #2
 800e954:	683a      	ldr	r2, [r7, #0]
 800e956:	18d4      	adds	r4, r2, r3
 800e958:	f7f2 f924 	bl	8000ba4 <__addsf3>
 800e95c:	4603      	mov	r3, r0
 800e95e:	6023      	str	r3, [r4, #0]
            position[plane.axis_1] += canned->xyz[plane.axis_1];
 800e960:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800e964:	009b      	lsls	r3, r3, #2
 800e966:	683a      	ldr	r2, [r7, #0]
 800e968:	4413      	add	r3, r2
 800e96a:	6818      	ldr	r0, [r3, #0]
 800e96c:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800e970:	461a      	mov	r2, r3
 800e972:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e974:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800e978:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 800e97c:	009b      	lsls	r3, r3, #2
 800e97e:	683a      	ldr	r2, [r7, #0]
 800e980:	18d4      	adds	r4, r2, r3
 800e982:	f7f2 f90f 	bl	8000ba4 <__addsf3>
 800e986:	4603      	mov	r3, r0
 800e988:	6023      	str	r3, [r4, #0]
            if(!mc_line(position, pl_data))
 800e98a:	6879      	ldr	r1, [r7, #4]
 800e98c:	6838      	ldr	r0, [r7, #0]
 800e98e:	f7ff f833 	bl	800d9f8 <mc_line>
 800e992:	4603      	mov	r3, r0
 800e994:	f083 0301 	eor.w	r3, r3, #1
 800e998:	b2db      	uxtb	r3, r3
 800e99a:	2b00      	cmp	r3, #0
 800e99c:	d115      	bne.n	800e9ca <mc_canned_drill+0x30e>
    while(repeats--) {
 800e99e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e9a0:	1e5a      	subs	r2, r3, #1
 800e9a2:	62fa      	str	r2, [r7, #44]	; 0x2c
 800e9a4:	2b00      	cmp	r3, #0
 800e9a6:	f47f aee0 	bne.w	800e76a <mc_canned_drill+0xae>
                return;
        }
    }

    memcpy(target, position, sizeof(float) * N_AXIS);
 800e9aa:	220c      	movs	r2, #12
 800e9ac:	6839      	ldr	r1, [r7, #0]
 800e9ae:	68b8      	ldr	r0, [r7, #8]
 800e9b0:	f015 fa8d 	bl	8023ece <memcpy>
 800e9b4:	e00a      	b.n	800e9cc <mc_canned_drill+0x310>
            return;
 800e9b6:	bf00      	nop
 800e9b8:	e008      	b.n	800e9cc <mc_canned_drill+0x310>
        return;
 800e9ba:	bf00      	nop
 800e9bc:	e006      	b.n	800e9cc <mc_canned_drill+0x310>
                return;
 800e9be:	bf00      	nop
 800e9c0:	e004      	b.n	800e9cc <mc_canned_drill+0x310>
                return;
 800e9c2:	bf00      	nop
 800e9c4:	e002      	b.n	800e9cc <mc_canned_drill+0x310>
                return;
 800e9c6:	bf00      	nop
 800e9c8:	e000      	b.n	800e9cc <mc_canned_drill+0x310>
                return;
 800e9ca:	bf00      	nop
}
 800e9cc:	371c      	adds	r7, #28
 800e9ce:	46bd      	mov	sp, r7
 800e9d0:	bd90      	pop	{r4, r7, pc}
 800e9d2:	bf00      	nop
 800e9d4:	2000147c 	.word	0x2000147c
 800e9d8:	20000bb0 	.word	0x20000bb0

0800e9dc <calc_thread_doc>:

// Calculates depth-of-cut (DOC) for a given threading pass.
inline static float calc_thread_doc (uint_fast16_t pass, float cut_depth, float inv_degression)
{
 800e9dc:	b580      	push	{r7, lr}
 800e9de:	b084      	sub	sp, #16
 800e9e0:	af00      	add	r7, sp, #0
 800e9e2:	60f8      	str	r0, [r7, #12]
 800e9e4:	60b9      	str	r1, [r7, #8]
 800e9e6:	607a      	str	r2, [r7, #4]
    return cut_depth * powf((float)pass, inv_degression);
 800e9e8:	68f8      	ldr	r0, [r7, #12]
 800e9ea:	f7f2 f98b 	bl	8000d04 <__aeabi_ui2f>
 800e9ee:	4603      	mov	r3, r0
 800e9f0:	6879      	ldr	r1, [r7, #4]
 800e9f2:	4618      	mov	r0, r3
 800e9f4:	f015 ffb6 	bl	8024964 <powf>
 800e9f8:	4603      	mov	r3, r0
 800e9fa:	68b9      	ldr	r1, [r7, #8]
 800e9fc:	4618      	mov	r0, r3
 800e9fe:	f7f2 f9d9 	bl	8000db4 <__aeabi_fmul>
 800ea02:	4603      	mov	r3, r0
}
 800ea04:	4618      	mov	r0, r3
 800ea06:	3710      	adds	r7, #16
 800ea08:	46bd      	mov	sp, r7
 800ea0a:	bd80      	pop	{r7, pc}

0800ea0c <mc_thread>:
// R - depth regression, Q - compound slide angle, H - spring passes, E - taper, L - taper end

// TODO: change pitch to follow any tapers

void mc_thread (plan_line_data_t *pl_data, float *position, gc_thread_data *thread, bool feed_hold_disabled)
{
 800ea0c:	b590      	push	{r4, r7, lr}
 800ea0e:	b091      	sub	sp, #68	; 0x44
 800ea10:	af00      	add	r7, sp, #0
 800ea12:	60f8      	str	r0, [r7, #12]
 800ea14:	60b9      	str	r1, [r7, #8]
 800ea16:	607a      	str	r2, [r7, #4]
 800ea18:	70fb      	strb	r3, [r7, #3]
    uint_fast16_t pass = 1, passes = 0;
 800ea1a:	2301      	movs	r3, #1
 800ea1c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ea1e:	2300      	movs	r3, #0
 800ea20:	63bb      	str	r3, [r7, #56]	; 0x38
    float doc = thread->initial_depth, inv_degression = 1.0f / thread->depth_degression, thread_length;
 800ea22:	687b      	ldr	r3, [r7, #4]
 800ea24:	68db      	ldr	r3, [r3, #12]
 800ea26:	637b      	str	r3, [r7, #52]	; 0x34
 800ea28:	687b      	ldr	r3, [r7, #4]
 800ea2a:	695b      	ldr	r3, [r3, #20]
 800ea2c:	4619      	mov	r1, r3
 800ea2e:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800ea32:	f7f2 fa73 	bl	8000f1c <__aeabi_fdiv>
 800ea36:	4603      	mov	r3, r0
 800ea38:	62bb      	str	r3, [r7, #40]	; 0x28
    float entry_taper_length = thread->end_taper_type & Taper_Entry ? thread->end_taper_length : 0.0f;
 800ea3a:	687b      	ldr	r3, [r7, #4]
 800ea3c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ea40:	f003 0301 	and.w	r3, r3, #1
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	d002      	beq.n	800ea4e <mc_thread+0x42>
 800ea48:	687b      	ldr	r3, [r7, #4]
 800ea4a:	69db      	ldr	r3, [r3, #28]
 800ea4c:	e001      	b.n	800ea52 <mc_thread+0x46>
 800ea4e:	f04f 0300 	mov.w	r3, #0
 800ea52:	633b      	str	r3, [r7, #48]	; 0x30
    float exit_taper_length = thread->end_taper_type & Taper_Exit ? thread->end_taper_length : 0.0f;
 800ea54:	687b      	ldr	r3, [r7, #4]
 800ea56:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ea5a:	f003 0302 	and.w	r3, r3, #2
 800ea5e:	2b00      	cmp	r3, #0
 800ea60:	d002      	beq.n	800ea68 <mc_thread+0x5c>
 800ea62:	687b      	ldr	r3, [r7, #4]
 800ea64:	69db      	ldr	r3, [r3, #28]
 800ea66:	e001      	b.n	800ea6c <mc_thread+0x60>
 800ea68:	f04f 0300 	mov.w	r3, #0
 800ea6c:	62fb      	str	r3, [r7, #44]	; 0x2c
    float infeed_factor = tanf(thread->infeed_angle * RADDEG);
 800ea6e:	687b      	ldr	r3, [r7, #4]
 800ea70:	6a1b      	ldr	r3, [r3, #32]
 800ea72:	496f      	ldr	r1, [pc, #444]	; (800ec30 <mc_thread+0x224>)
 800ea74:	4618      	mov	r0, r3
 800ea76:	f7f2 f99d 	bl	8000db4 <__aeabi_fmul>
 800ea7a:	4603      	mov	r3, r0
 800ea7c:	4618      	mov	r0, r3
 800ea7e:	f016 f84b 	bl	8024b18 <tanf>
 800ea82:	6278      	str	r0, [r7, #36]	; 0x24
    float target[N_AXIS], start_z = position[Z_AXIS] + thread->depth * infeed_factor;
 800ea84:	68bb      	ldr	r3, [r7, #8]
 800ea86:	3308      	adds	r3, #8
 800ea88:	681c      	ldr	r4, [r3, #0]
 800ea8a:	687b      	ldr	r3, [r7, #4]
 800ea8c:	691b      	ldr	r3, [r3, #16]
 800ea8e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ea90:	4618      	mov	r0, r3
 800ea92:	f7f2 f98f 	bl	8000db4 <__aeabi_fmul>
 800ea96:	4603      	mov	r3, r0
 800ea98:	4619      	mov	r1, r3
 800ea9a:	4620      	mov	r0, r4
 800ea9c:	f7f2 f882 	bl	8000ba4 <__addsf3>
 800eaa0:	4603      	mov	r3, r0
 800eaa2:	623b      	str	r3, [r7, #32]

    memcpy(target, position, sizeof(float) * N_AXIS);
 800eaa4:	f107 0310 	add.w	r3, r7, #16
 800eaa8:	220c      	movs	r2, #12
 800eaaa:	68b9      	ldr	r1, [r7, #8]
 800eaac:	4618      	mov	r0, r3
 800eaae:	f015 fa0e 	bl	8023ece <memcpy>

    // Calculate number of passes
    while(calc_thread_doc(++passes, doc, inv_degression) < thread->depth);
 800eab2:	bf00      	nop
 800eab4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eab6:	3301      	adds	r3, #1
 800eab8:	63bb      	str	r3, [r7, #56]	; 0x38
 800eaba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800eabc:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800eabe:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800eac0:	f7ff ff8c 	bl	800e9dc <calc_thread_doc>
 800eac4:	4602      	mov	r2, r0
 800eac6:	687b      	ldr	r3, [r7, #4]
 800eac8:	691b      	ldr	r3, [r3, #16]
 800eaca:	4619      	mov	r1, r3
 800eacc:	4610      	mov	r0, r2
 800eace:	f7f2 fb0f 	bl	80010f0 <__aeabi_fcmplt>
 800ead2:	4603      	mov	r3, r0
 800ead4:	2b00      	cmp	r3, #0
 800ead6:	d1ed      	bne.n	800eab4 <mc_thread+0xa8>

    passes += thread->spring_passes + 1;
 800ead8:	687b      	ldr	r3, [r7, #4]
 800eada:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800eadc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eade:	4413      	add	r3, r2
 800eae0:	3301      	adds	r3, #1
 800eae2:	63bb      	str	r3, [r7, #56]	; 0x38

    if((thread_length = thread->z_final - position[Z_AXIS]) > 0.0f) {
 800eae4:	687b      	ldr	r3, [r7, #4]
 800eae6:	685a      	ldr	r2, [r3, #4]
 800eae8:	68bb      	ldr	r3, [r7, #8]
 800eaea:	3308      	adds	r3, #8
 800eaec:	681b      	ldr	r3, [r3, #0]
 800eaee:	4619      	mov	r1, r3
 800eaf0:	4610      	mov	r0, r2
 800eaf2:	f7f2 f855 	bl	8000ba0 <__aeabi_fsub>
 800eaf6:	4603      	mov	r3, r0
 800eaf8:	61fb      	str	r3, [r7, #28]
 800eafa:	f04f 0100 	mov.w	r1, #0
 800eafe:	69f8      	ldr	r0, [r7, #28]
 800eb00:	f7f2 fb14 	bl	800112c <__aeabi_fcmpgt>
 800eb04:	4603      	mov	r3, r0
 800eb06:	2b00      	cmp	r3, #0
 800eb08:	d015      	beq.n	800eb36 <mc_thread+0x12a>
        if(thread->end_taper_type & Taper_Entry)
 800eb0a:	687b      	ldr	r3, [r7, #4]
 800eb0c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800eb10:	f003 0301 	and.w	r3, r3, #1
 800eb14:	2b00      	cmp	r3, #0
 800eb16:	d003      	beq.n	800eb20 <mc_thread+0x114>
            entry_taper_length = -entry_taper_length;
 800eb18:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eb1a:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800eb1e:	633b      	str	r3, [r7, #48]	; 0x30
        if(thread->end_taper_type & Taper_Exit)
 800eb20:	687b      	ldr	r3, [r7, #4]
 800eb22:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800eb26:	f003 0302 	and.w	r3, r3, #2
 800eb2a:	2b00      	cmp	r3, #0
 800eb2c:	d003      	beq.n	800eb36 <mc_thread+0x12a>
            exit_taper_length = - exit_taper_length;
 800eb2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eb30:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800eb34:	62fb      	str	r3, [r7, #44]	; 0x2c
    }

    thread_length += entry_taper_length + exit_taper_length;
 800eb36:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800eb38:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800eb3a:	f7f2 f833 	bl	8000ba4 <__addsf3>
 800eb3e:	4603      	mov	r3, r0
 800eb40:	4619      	mov	r1, r3
 800eb42:	69f8      	ldr	r0, [r7, #28]
 800eb44:	f7f2 f82e 	bl	8000ba4 <__addsf3>
 800eb48:	4603      	mov	r3, r0
 800eb4a:	61fb      	str	r3, [r7, #28]

    if(thread->main_taper_height != 0.0f)
 800eb4c:	687b      	ldr	r3, [r7, #4]
 800eb4e:	699b      	ldr	r3, [r3, #24]
 800eb50:	f04f 0100 	mov.w	r1, #0
 800eb54:	4618      	mov	r0, r3
 800eb56:	f7f2 fac1 	bl	80010dc <__aeabi_fcmpeq>
 800eb5a:	4603      	mov	r3, r0
 800eb5c:	2b00      	cmp	r3, #0
 800eb5e:	d119      	bne.n	800eb94 <mc_thread+0x188>
        thread->main_taper_height = thread->main_taper_height * thread_length / (thread_length - (entry_taper_length + exit_taper_length));
 800eb60:	687b      	ldr	r3, [r7, #4]
 800eb62:	699b      	ldr	r3, [r3, #24]
 800eb64:	69f9      	ldr	r1, [r7, #28]
 800eb66:	4618      	mov	r0, r3
 800eb68:	f7f2 f924 	bl	8000db4 <__aeabi_fmul>
 800eb6c:	4603      	mov	r3, r0
 800eb6e:	461c      	mov	r4, r3
 800eb70:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800eb72:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800eb74:	f7f2 f816 	bl	8000ba4 <__addsf3>
 800eb78:	4603      	mov	r3, r0
 800eb7a:	4619      	mov	r1, r3
 800eb7c:	69f8      	ldr	r0, [r7, #28]
 800eb7e:	f7f2 f80f 	bl	8000ba0 <__aeabi_fsub>
 800eb82:	4603      	mov	r3, r0
 800eb84:	4619      	mov	r1, r3
 800eb86:	4620      	mov	r0, r4
 800eb88:	f7f2 f9c8 	bl	8000f1c <__aeabi_fdiv>
 800eb8c:	4603      	mov	r3, r0
 800eb8e:	461a      	mov	r2, r3
 800eb90:	687b      	ldr	r3, [r7, #4]
 800eb92:	619a      	str	r2, [r3, #24]

    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 800eb94:	68fa      	ldr	r2, [r7, #12]
 800eb96:	7e13      	ldrb	r3, [r2, #24]
 800eb98:	f043 0301 	orr.w	r3, r3, #1
 800eb9c:	7613      	strb	r3, [r2, #24]
    float acc_distance = pl_data->feed_rate * pl_data->spindle.hal->get_data(SpindleData_RPM)->rpm / settings.acceleration[Z_AXIS];
    acc_distance = acc_distance * acc_distance * settings.acceleration[Z_AXIS] * 0.5f;
     */

    // Initial Z-move for compound slide angle offset.
    if(infeed_factor != 0.0f) {
 800eb9e:	f04f 0100 	mov.w	r1, #0
 800eba2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800eba4:	f7f2 fa9a 	bl	80010dc <__aeabi_fcmpeq>
 800eba8:	4603      	mov	r3, r0
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d117      	bne.n	800ebde <mc_thread+0x1d2>
        target[Z_AXIS] = start_z - doc * infeed_factor;
 800ebae:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ebb0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ebb2:	f7f2 f8ff 	bl	8000db4 <__aeabi_fmul>
 800ebb6:	4603      	mov	r3, r0
 800ebb8:	4619      	mov	r1, r3
 800ebba:	6a38      	ldr	r0, [r7, #32]
 800ebbc:	f7f1 fff0 	bl	8000ba0 <__aeabi_fsub>
 800ebc0:	4603      	mov	r3, r0
 800ebc2:	61bb      	str	r3, [r7, #24]
        if(!mc_line(target, pl_data))
 800ebc4:	f107 0310 	add.w	r3, r7, #16
 800ebc8:	68f9      	ldr	r1, [r7, #12]
 800ebca:	4618      	mov	r0, r3
 800ebcc:	f7fe ff14 	bl	800d9f8 <mc_line>
 800ebd0:	4603      	mov	r3, r0
 800ebd2:	f083 0301 	eor.w	r3, r3, #1
 800ebd6:	b2db      	uxtb	r3, r3
 800ebd8:	2b00      	cmp	r3, #0
 800ebda:	f040 8162 	bne.w	800eea2 <mc_thread+0x496>
            return;
    }

    while(--passes) {
 800ebde:	e158      	b.n	800ee92 <mc_thread+0x486>

        if(thread->end_taper_type & Taper_Entry)
 800ebe0:	687b      	ldr	r3, [r7, #4]
 800ebe2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ebe6:	f003 0301 	and.w	r3, r3, #1
 800ebea:	2b00      	cmp	r3, #0
 800ebec:	d022      	beq.n	800ec34 <mc_thread+0x228>
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 800ebee:	68bb      	ldr	r3, [r7, #8]
 800ebf0:	681c      	ldr	r4, [r3, #0]
 800ebf2:	687b      	ldr	r3, [r7, #4]
 800ebf4:	689b      	ldr	r3, [r3, #8]
 800ebf6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800ebf8:	4618      	mov	r0, r3
 800ebfa:	f7f1 ffd3 	bl	8000ba4 <__addsf3>
 800ebfe:	4603      	mov	r3, r0
 800ec00:	461a      	mov	r2, r3
 800ec02:	687b      	ldr	r3, [r7, #4]
 800ec04:	691b      	ldr	r3, [r3, #16]
 800ec06:	4619      	mov	r1, r3
 800ec08:	4610      	mov	r0, r2
 800ec0a:	f7f1 ffc9 	bl	8000ba0 <__aeabi_fsub>
 800ec0e:	4603      	mov	r3, r0
 800ec10:	461a      	mov	r2, r3
 800ec12:	687b      	ldr	r3, [r7, #4]
 800ec14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec16:	4619      	mov	r1, r3
 800ec18:	4610      	mov	r0, r2
 800ec1a:	f7f2 f8cb 	bl	8000db4 <__aeabi_fmul>
 800ec1e:	4603      	mov	r3, r0
 800ec20:	4619      	mov	r1, r3
 800ec22:	4620      	mov	r0, r4
 800ec24:	f7f1 ffbe 	bl	8000ba4 <__addsf3>
 800ec28:	4603      	mov	r3, r0
 800ec2a:	613b      	str	r3, [r7, #16]
 800ec2c:	e019      	b.n	800ec62 <mc_thread+0x256>
 800ec2e:	bf00      	nop
 800ec30:	3c8efa35 	.word	0x3c8efa35
        else
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 800ec34:	68bb      	ldr	r3, [r7, #8]
 800ec36:	681c      	ldr	r4, [r3, #0]
 800ec38:	687b      	ldr	r3, [r7, #4]
 800ec3a:	689b      	ldr	r3, [r3, #8]
 800ec3c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800ec3e:	4618      	mov	r0, r3
 800ec40:	f7f1 ffb0 	bl	8000ba4 <__addsf3>
 800ec44:	4603      	mov	r3, r0
 800ec46:	461a      	mov	r2, r3
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ec4c:	4619      	mov	r1, r3
 800ec4e:	4610      	mov	r0, r2
 800ec50:	f7f2 f8b0 	bl	8000db4 <__aeabi_fmul>
 800ec54:	4603      	mov	r3, r0
 800ec56:	4619      	mov	r1, r3
 800ec58:	4620      	mov	r0, r4
 800ec5a:	f7f1 ffa3 	bl	8000ba4 <__addsf3>
 800ec5e:	4603      	mov	r3, r0
 800ec60:	613b      	str	r3, [r7, #16]

        if(!mc_line(target, pl_data))
 800ec62:	f107 0310 	add.w	r3, r7, #16
 800ec66:	68f9      	ldr	r1, [r7, #12]
 800ec68:	4618      	mov	r0, r3
 800ec6a:	f7fe fec5 	bl	800d9f8 <mc_line>
 800ec6e:	4603      	mov	r3, r0
 800ec70:	f083 0301 	eor.w	r3, r3, #1
 800ec74:	b2db      	uxtb	r3, r3
 800ec76:	2b00      	cmp	r3, #0
 800ec78:	f040 8115 	bne.w	800eea6 <mc_thread+0x49a>
            return;

        if(!protocol_buffer_synchronize() && state_get() != STATE_IDLE) // Wait until any previous moves are finished.
 800ec7c:	f004 f840 	bl	8012d00 <protocol_buffer_synchronize>
 800ec80:	4603      	mov	r3, r0
 800ec82:	f083 0301 	eor.w	r3, r3, #1
 800ec86:	b2db      	uxtb	r3, r3
 800ec88:	2b00      	cmp	r3, #0
 800ec8a:	d005      	beq.n	800ec98 <mc_thread+0x28c>
 800ec8c:	f00e fe18 	bl	801d8c0 <state_get>
 800ec90:	4603      	mov	r3, r0
 800ec92:	2b00      	cmp	r3, #0
 800ec94:	f040 8109 	bne.w	800eeaa <mc_thread+0x49e>
            return;

        pl_data->condition.rapid_motion = Off;      // Clear rapid motion condition flag,
 800ec98:	68fa      	ldr	r2, [r7, #12]
 800ec9a:	7e13      	ldrb	r3, [r2, #24]
 800ec9c:	f36f 0300 	bfc	r3, #0, #1
 800eca0:	7613      	strb	r3, [r2, #24]
        pl_data->spindle.state.synchronized = On;   // enable spindle sync for cut
 800eca2:	68fa      	ldr	r2, [r7, #12]
 800eca4:	7b13      	ldrb	r3, [r2, #12]
 800eca6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ecaa:	7313      	strb	r3, [r2, #12]
        pl_data->overrides.feed_hold_disable = On;  // and disable feed hold
 800ecac:	68fa      	ldr	r2, [r7, #12]
 800ecae:	7f13      	ldrb	r3, [r2, #28]
 800ecb0:	f043 0302 	orr.w	r3, r3, #2
 800ecb4:	7713      	strb	r3, [r2, #28]

        // Cut thread pass

        // 1. Entry taper
        if(thread->end_taper_type & Taper_Entry) {
 800ecb6:	687b      	ldr	r3, [r7, #4]
 800ecb8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ecbc:	f003 0301 	and.w	r3, r3, #1
 800ecc0:	2b00      	cmp	r3, #0
 800ecc2:	d023      	beq.n	800ed0c <mc_thread+0x300>

            target[X_AXIS] += thread->depth * thread->cut_direction;
 800ecc4:	693c      	ldr	r4, [r7, #16]
 800ecc6:	687b      	ldr	r3, [r7, #4]
 800ecc8:	691a      	ldr	r2, [r3, #16]
 800ecca:	687b      	ldr	r3, [r7, #4]
 800eccc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ecce:	4619      	mov	r1, r3
 800ecd0:	4610      	mov	r0, r2
 800ecd2:	f7f2 f86f 	bl	8000db4 <__aeabi_fmul>
 800ecd6:	4603      	mov	r3, r0
 800ecd8:	4619      	mov	r1, r3
 800ecda:	4620      	mov	r0, r4
 800ecdc:	f7f1 ff62 	bl	8000ba4 <__addsf3>
 800ece0:	4603      	mov	r3, r0
 800ece2:	613b      	str	r3, [r7, #16]
            target[Z_AXIS] -= entry_taper_length;
 800ece4:	69bb      	ldr	r3, [r7, #24]
 800ece6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800ece8:	4618      	mov	r0, r3
 800ecea:	f7f1 ff59 	bl	8000ba0 <__aeabi_fsub>
 800ecee:	4603      	mov	r3, r0
 800ecf0:	61bb      	str	r3, [r7, #24]
            if(!mc_line(target, pl_data))
 800ecf2:	f107 0310 	add.w	r3, r7, #16
 800ecf6:	68f9      	ldr	r1, [r7, #12]
 800ecf8:	4618      	mov	r0, r3
 800ecfa:	f7fe fe7d 	bl	800d9f8 <mc_line>
 800ecfe:	4603      	mov	r3, r0
 800ed00:	f083 0301 	eor.w	r3, r3, #1
 800ed04:	b2db      	uxtb	r3, r3
 800ed06:	2b00      	cmp	r3, #0
 800ed08:	f040 80d1 	bne.w	800eeae <mc_thread+0x4a2>
                return;
        }

        // 2. Main part
        target[Z_AXIS] += thread_length;
 800ed0c:	69bb      	ldr	r3, [r7, #24]
 800ed0e:	69f9      	ldr	r1, [r7, #28]
 800ed10:	4618      	mov	r0, r3
 800ed12:	f7f1 ff47 	bl	8000ba4 <__addsf3>
 800ed16:	4603      	mov	r3, r0
 800ed18:	61bb      	str	r3, [r7, #24]
        if(!mc_line(target, pl_data))
 800ed1a:	f107 0310 	add.w	r3, r7, #16
 800ed1e:	68f9      	ldr	r1, [r7, #12]
 800ed20:	4618      	mov	r0, r3
 800ed22:	f7fe fe69 	bl	800d9f8 <mc_line>
 800ed26:	4603      	mov	r3, r0
 800ed28:	f083 0301 	eor.w	r3, r3, #1
 800ed2c:	b2db      	uxtb	r3, r3
 800ed2e:	2b00      	cmp	r3, #0
 800ed30:	f040 80bf 	bne.w	800eeb2 <mc_thread+0x4a6>
            return;

        // 3. Exit taper
        if(thread->end_taper_type & Taper_Exit) {
 800ed34:	687b      	ldr	r3, [r7, #4]
 800ed36:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800ed3a:	f003 0302 	and.w	r3, r3, #2
 800ed3e:	2b00      	cmp	r3, #0
 800ed40:	d023      	beq.n	800ed8a <mc_thread+0x37e>

            target[X_AXIS] -= thread->depth * thread->cut_direction;
 800ed42:	693c      	ldr	r4, [r7, #16]
 800ed44:	687b      	ldr	r3, [r7, #4]
 800ed46:	691a      	ldr	r2, [r3, #16]
 800ed48:	687b      	ldr	r3, [r7, #4]
 800ed4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed4c:	4619      	mov	r1, r3
 800ed4e:	4610      	mov	r0, r2
 800ed50:	f7f2 f830 	bl	8000db4 <__aeabi_fmul>
 800ed54:	4603      	mov	r3, r0
 800ed56:	4619      	mov	r1, r3
 800ed58:	4620      	mov	r0, r4
 800ed5a:	f7f1 ff21 	bl	8000ba0 <__aeabi_fsub>
 800ed5e:	4603      	mov	r3, r0
 800ed60:	613b      	str	r3, [r7, #16]
            target[Z_AXIS] -= exit_taper_length;
 800ed62:	69bb      	ldr	r3, [r7, #24]
 800ed64:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ed66:	4618      	mov	r0, r3
 800ed68:	f7f1 ff1a 	bl	8000ba0 <__aeabi_fsub>
 800ed6c:	4603      	mov	r3, r0
 800ed6e:	61bb      	str	r3, [r7, #24]
            if(!mc_line(target, pl_data))
 800ed70:	f107 0310 	add.w	r3, r7, #16
 800ed74:	68f9      	ldr	r1, [r7, #12]
 800ed76:	4618      	mov	r0, r3
 800ed78:	f7fe fe3e 	bl	800d9f8 <mc_line>
 800ed7c:	4603      	mov	r3, r0
 800ed7e:	f083 0301 	eor.w	r3, r3, #1
 800ed82:	b2db      	uxtb	r3, r3
 800ed84:	2b00      	cmp	r3, #0
 800ed86:	f040 8096 	bne.w	800eeb6 <mc_thread+0x4aa>
                return;
        }

        pl_data->condition.rapid_motion = On;       // Set rapid motion condition flag and
 800ed8a:	68fa      	ldr	r2, [r7, #12]
 800ed8c:	7e13      	ldrb	r3, [r2, #24]
 800ed8e:	f043 0301 	orr.w	r3, r3, #1
 800ed92:	7613      	strb	r3, [r2, #24]
        pl_data->spindle.state.synchronized = Off;  // disable spindle sync for retract & reposition
 800ed94:	68fa      	ldr	r2, [r7, #12]
 800ed96:	7b13      	ldrb	r3, [r2, #12]
 800ed98:	f36f 13c7 	bfc	r3, #7, #1
 800ed9c:	7313      	strb	r3, [r2, #12]

        if(passes > 1) {
 800ed9e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eda0:	2b01      	cmp	r3, #1
 800eda2:	d964      	bls.n	800ee6e <mc_thread+0x462>

            // Get DOC of next pass.
            doc = calc_thread_doc(++pass, thread->initial_depth, inv_degression);
 800eda4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800eda6:	3301      	adds	r3, #1
 800eda8:	63fb      	str	r3, [r7, #60]	; 0x3c
 800edaa:	687b      	ldr	r3, [r7, #4]
 800edac:	68db      	ldr	r3, [r3, #12]
 800edae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800edb0:	4619      	mov	r1, r3
 800edb2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800edb4:	f7ff fe12 	bl	800e9dc <calc_thread_doc>
 800edb8:	6378      	str	r0, [r7, #52]	; 0x34
            doc = min(doc, thread->depth);
 800edba:	687b      	ldr	r3, [r7, #4]
 800edbc:	691b      	ldr	r3, [r3, #16]
 800edbe:	4619      	mov	r1, r3
 800edc0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800edc2:	f7f2 f995 	bl	80010f0 <__aeabi_fcmplt>
 800edc6:	4603      	mov	r3, r0
 800edc8:	2b00      	cmp	r3, #0
 800edca:	d001      	beq.n	800edd0 <mc_thread+0x3c4>
 800edcc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edce:	e001      	b.n	800edd4 <mc_thread+0x3c8>
 800edd0:	687b      	ldr	r3, [r7, #4]
 800edd2:	691b      	ldr	r3, [r3, #16]
 800edd4:	637b      	str	r3, [r7, #52]	; 0x34

            // 4. Retract
            target[X_AXIS] = position[X_AXIS] + (doc - thread->depth) * thread->cut_direction;
 800edd6:	68bb      	ldr	r3, [r7, #8]
 800edd8:	681c      	ldr	r4, [r3, #0]
 800edda:	687b      	ldr	r3, [r7, #4]
 800eddc:	691b      	ldr	r3, [r3, #16]
 800edde:	4619      	mov	r1, r3
 800ede0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ede2:	f7f1 fedd 	bl	8000ba0 <__aeabi_fsub>
 800ede6:	4603      	mov	r3, r0
 800ede8:	461a      	mov	r2, r3
 800edea:	687b      	ldr	r3, [r7, #4]
 800edec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800edee:	4619      	mov	r1, r3
 800edf0:	4610      	mov	r0, r2
 800edf2:	f7f1 ffdf 	bl	8000db4 <__aeabi_fmul>
 800edf6:	4603      	mov	r3, r0
 800edf8:	4619      	mov	r1, r3
 800edfa:	4620      	mov	r0, r4
 800edfc:	f7f1 fed2 	bl	8000ba4 <__addsf3>
 800ee00:	4603      	mov	r3, r0
 800ee02:	613b      	str	r3, [r7, #16]
            if(!mc_line(target, pl_data))
 800ee04:	f107 0310 	add.w	r3, r7, #16
 800ee08:	68f9      	ldr	r1, [r7, #12]
 800ee0a:	4618      	mov	r0, r3
 800ee0c:	f7fe fdf4 	bl	800d9f8 <mc_line>
 800ee10:	4603      	mov	r3, r0
 800ee12:	f083 0301 	eor.w	r3, r3, #1
 800ee16:	b2db      	uxtb	r3, r3
 800ee18:	2b00      	cmp	r3, #0
 800ee1a:	d14e      	bne.n	800eeba <mc_thread+0x4ae>
                return;

            // Restore disable feed hold status for reposition move.
            pl_data->overrides.feed_hold_disable = feed_hold_disabled;
 800ee1c:	68fa      	ldr	r2, [r7, #12]
 800ee1e:	7f13      	ldrb	r3, [r2, #28]
 800ee20:	78f9      	ldrb	r1, [r7, #3]
 800ee22:	f361 0341 	bfi	r3, r1, #1, #1
 800ee26:	7713      	strb	r3, [r2, #28]

            // 5. Back to start, add compound slide angle offset when commanded.
            target[Z_AXIS] = start_z - (infeed_factor != 0.0f ? doc * infeed_factor : 0.0f);
 800ee28:	f04f 0100 	mov.w	r1, #0
 800ee2c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ee2e:	f7f2 f955 	bl	80010dc <__aeabi_fcmpeq>
 800ee32:	4603      	mov	r3, r0
 800ee34:	2b00      	cmp	r3, #0
 800ee36:	d105      	bne.n	800ee44 <mc_thread+0x438>
 800ee38:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ee3a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ee3c:	f7f1 ffba 	bl	8000db4 <__aeabi_fmul>
 800ee40:	4603      	mov	r3, r0
 800ee42:	e001      	b.n	800ee48 <mc_thread+0x43c>
 800ee44:	f04f 0300 	mov.w	r3, #0
 800ee48:	4619      	mov	r1, r3
 800ee4a:	6a38      	ldr	r0, [r7, #32]
 800ee4c:	f7f1 fea8 	bl	8000ba0 <__aeabi_fsub>
 800ee50:	4603      	mov	r3, r0
 800ee52:	61bb      	str	r3, [r7, #24]
            if(!mc_line(target, pl_data))
 800ee54:	f107 0310 	add.w	r3, r7, #16
 800ee58:	68f9      	ldr	r1, [r7, #12]
 800ee5a:	4618      	mov	r0, r3
 800ee5c:	f7fe fdcc 	bl	800d9f8 <mc_line>
 800ee60:	4603      	mov	r3, r0
 800ee62:	f083 0301 	eor.w	r3, r3, #1
 800ee66:	b2db      	uxtb	r3, r3
 800ee68:	2b00      	cmp	r3, #0
 800ee6a:	d012      	beq.n	800ee92 <mc_thread+0x486>
                return;
 800ee6c:	e028      	b.n	800eec0 <mc_thread+0x4b4>

        } else {

            doc = thread->depth;
 800ee6e:	687b      	ldr	r3, [r7, #4]
 800ee70:	691b      	ldr	r3, [r3, #16]
 800ee72:	637b      	str	r3, [r7, #52]	; 0x34
            target[X_AXIS] = position[X_AXIS];
 800ee74:	68bb      	ldr	r3, [r7, #8]
 800ee76:	681b      	ldr	r3, [r3, #0]
 800ee78:	613b      	str	r3, [r7, #16]
            if(!mc_line(target, pl_data))
 800ee7a:	f107 0310 	add.w	r3, r7, #16
 800ee7e:	68f9      	ldr	r1, [r7, #12]
 800ee80:	4618      	mov	r0, r3
 800ee82:	f7fe fdb9 	bl	800d9f8 <mc_line>
 800ee86:	4603      	mov	r3, r0
 800ee88:	f083 0301 	eor.w	r3, r3, #1
 800ee8c:	b2db      	uxtb	r3, r3
 800ee8e:	2b00      	cmp	r3, #0
 800ee90:	d115      	bne.n	800eebe <mc_thread+0x4b2>
    while(--passes) {
 800ee92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee94:	3b01      	subs	r3, #1
 800ee96:	63bb      	str	r3, [r7, #56]	; 0x38
 800ee98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee9a:	2b00      	cmp	r3, #0
 800ee9c:	f47f aea0 	bne.w	800ebe0 <mc_thread+0x1d4>
 800eea0:	e00e      	b.n	800eec0 <mc_thread+0x4b4>
            return;
 800eea2:	bf00      	nop
 800eea4:	e00c      	b.n	800eec0 <mc_thread+0x4b4>
            return;
 800eea6:	bf00      	nop
 800eea8:	e00a      	b.n	800eec0 <mc_thread+0x4b4>
            return;
 800eeaa:	bf00      	nop
 800eeac:	e008      	b.n	800eec0 <mc_thread+0x4b4>
                return;
 800eeae:	bf00      	nop
 800eeb0:	e006      	b.n	800eec0 <mc_thread+0x4b4>
            return;
 800eeb2:	bf00      	nop
 800eeb4:	e004      	b.n	800eec0 <mc_thread+0x4b4>
                return;
 800eeb6:	bf00      	nop
 800eeb8:	e002      	b.n	800eec0 <mc_thread+0x4b4>
                return;
 800eeba:	bf00      	nop
 800eebc:	e000      	b.n	800eec0 <mc_thread+0x4b4>
                return;
 800eebe:	bf00      	nop
        }
    }
}
 800eec0:	3744      	adds	r7, #68	; 0x44
 800eec2:	46bd      	mov	sp, r7
 800eec4:	bd90      	pop	{r4, r7, pc}
 800eec6:	bf00      	nop

0800eec8 <mc_jog_execute>:

// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
status_code_t mc_jog_execute (plan_line_data_t *pl_data, parser_block_t *gc_block, float *position)
{
 800eec8:	b580      	push	{r7, lr}
 800eeca:	b084      	sub	sp, #16
 800eecc:	af00      	add	r7, sp, #0
 800eece:	60f8      	str	r0, [r7, #12]
 800eed0:	60b9      	str	r1, [r7, #8]
 800eed2:	607a      	str	r2, [r7, #4]
    // Initialize planner data struct for jogging motions.
    // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
    pl_data->feed_rate = gc_block->values.f;
 800eed4:	68bb      	ldr	r3, [r7, #8]
 800eed6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800eed8:	68fb      	ldr	r3, [r7, #12]
 800eeda:	601a      	str	r2, [r3, #0]
    pl_data->condition.no_feed_override =
    pl_data->condition.jog_motion =
    pl_data->condition.target_valid =
    pl_data->condition.target_validated = On;
 800eedc:	68fa      	ldr	r2, [r7, #12]
 800eede:	7e53      	ldrb	r3, [r2, #25]
 800eee0:	f043 0302 	orr.w	r3, r3, #2
 800eee4:	7653      	strb	r3, [r2, #25]
 800eee6:	68fb      	ldr	r3, [r7, #12]
 800eee8:	7e5b      	ldrb	r3, [r3, #25]
 800eeea:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800eeee:	b2d9      	uxtb	r1, r3
    pl_data->condition.target_valid =
 800eef0:	68fa      	ldr	r2, [r7, #12]
 800eef2:	7e53      	ldrb	r3, [r2, #25]
 800eef4:	f361 0300 	bfi	r3, r1, #0, #1
 800eef8:	7653      	strb	r3, [r2, #25]
 800eefa:	68fb      	ldr	r3, [r7, #12]
 800eefc:	7e5b      	ldrb	r3, [r3, #25]
 800eefe:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800ef02:	b2d9      	uxtb	r1, r3
    pl_data->condition.jog_motion =
 800ef04:	68fa      	ldr	r2, [r7, #12]
 800ef06:	7e13      	ldrb	r3, [r2, #24]
 800ef08:	f361 0382 	bfi	r3, r1, #2, #1
 800ef0c:	7613      	strb	r3, [r2, #24]
 800ef0e:	68fb      	ldr	r3, [r7, #12]
 800ef10:	7e1b      	ldrb	r3, [r3, #24]
 800ef12:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800ef16:	b2d9      	uxtb	r1, r3
    pl_data->condition.no_feed_override =
 800ef18:	68fa      	ldr	r2, [r7, #12]
 800ef1a:	7e13      	ldrb	r3, [r2, #24]
 800ef1c:	f361 1304 	bfi	r3, r1, #4, #1
 800ef20:	7613      	strb	r3, [r2, #24]
    pl_data->line_number = gc_block->values.n;
 800ef22:	68bb      	ldr	r3, [r7, #8]
 800ef24:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800ef28:	68fb      	ldr	r3, [r7, #12]
 800ef2a:	621a      	str	r2, [r3, #32]

    if(settings.limits.flags.jog_soft_limited)
 800ef2c:	4b19      	ldr	r3, [pc, #100]	; (800ef94 <mc_jog_execute+0xcc>)
 800ef2e:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 800ef32:	f003 0308 	and.w	r3, r3, #8
 800ef36:	b2db      	uxtb	r3, r3
 800ef38:	2b00      	cmp	r3, #0
 800ef3a:	d008      	beq.n	800ef4e <mc_jog_execute+0x86>
        grbl.apply_jog_limits(gc_block->values.xyz, position);
 800ef3c:	4b16      	ldr	r3, [pc, #88]	; (800ef98 <mc_jog_execute+0xd0>)
 800ef3e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800ef42:	68ba      	ldr	r2, [r7, #8]
 800ef44:	3260      	adds	r2, #96	; 0x60
 800ef46:	6879      	ldr	r1, [r7, #4]
 800ef48:	4610      	mov	r0, r2
 800ef4a:	4798      	blx	r3
 800ef4c:	e017      	b.n	800ef7e <mc_jog_execute+0xb6>
    else if(sys.soft_limits.mask && !grbl.check_travel_limits(gc_block->values.xyz, sys.soft_limits, true))
 800ef4e:	4b13      	ldr	r3, [pc, #76]	; (800ef9c <mc_jog_execute+0xd4>)
 800ef50:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 800ef54:	2b00      	cmp	r3, #0
 800ef56:	d012      	beq.n	800ef7e <mc_jog_execute+0xb6>
 800ef58:	4b0f      	ldr	r3, [pc, #60]	; (800ef98 <mc_jog_execute+0xd0>)
 800ef5a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ef5e:	68ba      	ldr	r2, [r7, #8]
 800ef60:	f102 0060 	add.w	r0, r2, #96	; 0x60
 800ef64:	490d      	ldr	r1, [pc, #52]	; (800ef9c <mc_jog_execute+0xd4>)
 800ef66:	2201      	movs	r2, #1
 800ef68:	f891 1095 	ldrb.w	r1, [r1, #149]	; 0x95
 800ef6c:	4798      	blx	r3
 800ef6e:	4603      	mov	r3, r0
 800ef70:	f083 0301 	eor.w	r3, r3, #1
 800ef74:	b2db      	uxtb	r3, r3
 800ef76:	2b00      	cmp	r3, #0
 800ef78:	d001      	beq.n	800ef7e <mc_jog_execute+0xb6>
        return Status_TravelExceeded;
 800ef7a:	230f      	movs	r3, #15
 800ef7c:	e006      	b.n	800ef8c <mc_jog_execute+0xc4>

    // Valid jog command. Plan, set state, and execute.
    mc_line(gc_block->values.xyz, pl_data);
 800ef7e:	68bb      	ldr	r3, [r7, #8]
 800ef80:	3360      	adds	r3, #96	; 0x60
 800ef82:	68f9      	ldr	r1, [r7, #12]
 800ef84:	4618      	mov	r0, r3
 800ef86:	f7fe fd37 	bl	800d9f8 <mc_line>
        st_prep_buffer();
        st_wake_up();  // NOTE: Manual start. No state machine required.
    }
#endif

    return Status_OK;
 800ef8a:	2300      	movs	r3, #0
}
 800ef8c:	4618      	mov	r0, r3
 800ef8e:	3710      	adds	r7, #16
 800ef90:	46bd      	mov	sp, r7
 800ef92:	bd80      	pop	{r7, pc}
 800ef94:	2000147c 	.word	0x2000147c
 800ef98:	20000dd4 	.word	0x20000dd4
 800ef9c:	20000d3c 	.word	0x20000d3c

0800efa0 <mc_dwell>:

// Execute dwell in seconds.
void mc_dwell (float seconds)
{
 800efa0:	b580      	push	{r7, lr}
 800efa2:	b082      	sub	sp, #8
 800efa4:	af00      	add	r7, sp, #0
 800efa6:	6078      	str	r0, [r7, #4]
    if (state_get() != STATE_CHECK_MODE) {
 800efa8:	f00e fc8a 	bl	801d8c0 <state_get>
 800efac:	4603      	mov	r3, r0
 800efae:	2b02      	cmp	r3, #2
 800efb0:	d005      	beq.n	800efbe <mc_dwell+0x1e>
        protocol_buffer_synchronize();
 800efb2:	f003 fea5 	bl	8012d00 <protocol_buffer_synchronize>
        delay_sec(seconds, DelayMode_Dwell);
 800efb6:	2100      	movs	r1, #0
 800efb8:	6878      	ldr	r0, [r7, #4]
 800efba:	f001 fbe3 	bl	8010784 <delay_sec>
    }
}
 800efbe:	bf00      	nop
 800efc0:	3708      	adds	r7, #8
 800efc2:	46bd      	mov	sp, r7
 800efc4:	bd80      	pop	{r7, pc}
	...

0800efc8 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
status_code_t mc_homing_cycle (axes_signals_t cycle)
{
 800efc8:	b580      	push	{r7, lr}
 800efca:	b088      	sub	sp, #32
 800efcc:	af00      	add	r7, sp, #0
 800efce:	7138      	strb	r0, [r7, #4]
    bool home_all = cycle.mask == 0;
 800efd0:	793b      	ldrb	r3, [r7, #4]
 800efd2:	2b00      	cmp	r3, #0
 800efd4:	bf0c      	ite	eq
 800efd6:	2301      	moveq	r3, #1
 800efd8:	2300      	movne	r3, #0
 800efda:	74fb      	strb	r3, [r7, #19]
    status_code_t homed_status = Status_OK;
 800efdc:	2300      	movs	r3, #0
 800efde:	77fb      	strb	r3, [r7, #31]

    memset(&sys.last_event.limits, 0, sizeof(limit_signals_t));
 800efe0:	2204      	movs	r2, #4
 800efe2:	2100      	movs	r1, #0
 800efe4:	489a      	ldr	r0, [pc, #616]	; (800f250 <mc_homing_cycle+0x288>)
 800efe6:	f014 fe16 	bl	8023c16 <memset>

    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 800efea:	4b9a      	ldr	r3, [pc, #616]	; (800f254 <mc_homing_cycle+0x28c>)
 800efec:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800eff0:	f003 0310 	and.w	r3, r3, #16
 800eff4:	b2db      	uxtb	r3, r3
 800eff6:	2b00      	cmp	r3, #0
 800eff8:	d024      	beq.n	800f044 <mc_homing_cycle+0x7c>
 800effa:	7cfb      	ldrb	r3, [r7, #19]
 800effc:	2b00      	cmp	r3, #0
 800effe:	d004      	beq.n	800f00a <mc_homing_cycle+0x42>
 800f000:	4b95      	ldr	r3, [pc, #596]	; (800f258 <mc_homing_cycle+0x290>)
 800f002:	7e9b      	ldrb	r3, [r3, #26]
 800f004:	2b00      	cmp	r3, #0
 800f006:	d007      	beq.n	800f018 <mc_homing_cycle+0x50>
 800f008:	e01c      	b.n	800f044 <mc_homing_cycle+0x7c>
 800f00a:	793a      	ldrb	r2, [r7, #4]
 800f00c:	4b92      	ldr	r3, [pc, #584]	; (800f258 <mc_homing_cycle+0x290>)
 800f00e:	7e9b      	ldrb	r3, [r3, #26]
 800f010:	4013      	ands	r3, r2
 800f012:	b2db      	uxtb	r3, r3
 800f014:	2b00      	cmp	r3, #0
 800f016:	d115      	bne.n	800f044 <mc_homing_cycle+0x7c>

        if(home_all)
 800f018:	7cfb      	ldrb	r3, [r7, #19]
 800f01a:	2b00      	cmp	r3, #0
 800f01c:	d001      	beq.n	800f022 <mc_homing_cycle+0x5a>
            cycle.mask = AXES_BITMASK;
 800f01e:	2307      	movs	r3, #7
 800f020:	713b      	strb	r3, [r7, #4]

        tc_clear_tlo_reference(cycle);
 800f022:	7938      	ldrb	r0, [r7, #4]
 800f024:	f013 fd82 	bl	8022b2c <tc_clear_tlo_reference>

        sys.homed.mask |= cycle.mask;
 800f028:	4b8b      	ldr	r3, [pc, #556]	; (800f258 <mc_homing_cycle+0x290>)
 800f02a:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 800f02e:	793b      	ldrb	r3, [r7, #4]
 800f030:	4313      	orrs	r3, r2
 800f032:	b2da      	uxtb	r2, r3
 800f034:	4b88      	ldr	r3, [pc, #544]	; (800f258 <mc_homing_cycle+0x290>)
 800f036:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#ifdef KINEMATICS_API
        kinematics.limits_set_machine_positions(cycle);
 800f03a:	4b88      	ldr	r3, [pc, #544]	; (800f25c <mc_homing_cycle+0x294>)
 800f03c:	695b      	ldr	r3, [r3, #20]
 800f03e:	7938      	ldrb	r0, [r7, #4]
 800f040:	4798      	blx	r3
 800f042:	e0d7      	b.n	800f1f4 <mc_homing_cycle+0x22c>
#else
        limits_set_machine_positions(cycle, false);
#endif
    } else {

        if(settings.homing.seek_rate <= 0.0f)
 800f044:	4b83      	ldr	r3, [pc, #524]	; (800f254 <mc_homing_cycle+0x28c>)
 800f046:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800f04a:	f04f 0100 	mov.w	r1, #0
 800f04e:	4618      	mov	r0, r3
 800f050:	f7f2 f858 	bl	8001104 <__aeabi_fcmple>
 800f054:	4603      	mov	r3, r0
 800f056:	2b00      	cmp	r3, #0
 800f058:	d001      	beq.n	800f05e <mc_homing_cycle+0x96>
            return Status_HomingDisabled;
 800f05a:	2305      	movs	r3, #5
 800f05c:	e169      	b.n	800f332 <mc_homing_cycle+0x36a>

        // Check and abort homing cycle, if hard limits are already enabled. Helps prevent problems
        // with machines with limits wired on both ends of travel to one limit pin.
        // TODO: Move the pin-specific LIMIT_BIT call to limits.c as a function.
        if (settings.limits.flags.two_switches && hal.home_cap.a.mask == 0 && limit_signals_merge(hal.limits.get_state()).value) {
 800f05e:	4b7d      	ldr	r3, [pc, #500]	; (800f254 <mc_homing_cycle+0x28c>)
 800f060:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 800f064:	f003 0310 	and.w	r3, r3, #16
 800f068:	b2db      	uxtb	r3, r3
 800f06a:	2b00      	cmp	r3, #0
 800f06c:	d019      	beq.n	800f0a2 <mc_homing_cycle+0xda>
 800f06e:	4b7c      	ldr	r3, [pc, #496]	; (800f260 <mc_homing_cycle+0x298>)
 800f070:	f893 31b2 	ldrb.w	r3, [r3, #434]	; 0x1b2
 800f074:	2b00      	cmp	r3, #0
 800f076:	d114      	bne.n	800f0a2 <mc_homing_cycle+0xda>
 800f078:	4b79      	ldr	r3, [pc, #484]	; (800f260 <mc_homing_cycle+0x298>)
 800f07a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f07c:	4798      	blx	r3
 800f07e:	4603      	mov	r3, r0
 800f080:	60bb      	str	r3, [r7, #8]
 800f082:	68b8      	ldr	r0, [r7, #8]
 800f084:	f7fc ff64 	bl	800bf50 <limit_signals_merge>
 800f088:	4603      	mov	r3, r0
 800f08a:	b2db      	uxtb	r3, r3
 800f08c:	2b00      	cmp	r3, #0
 800f08e:	d008      	beq.n	800f0a2 <mc_homing_cycle+0xda>
            mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 800f090:	f000 fb2a 	bl	800f6e8 <mc_reset>
            system_set_exec_alarm(Alarm_HardLimit);
 800f094:	4b72      	ldr	r3, [pc, #456]	; (800f260 <mc_homing_cycle+0x298>)
 800f096:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f098:	2101      	movs	r1, #1
 800f09a:	4872      	ldr	r0, [pc, #456]	; (800f264 <mc_homing_cycle+0x29c>)
 800f09c:	4798      	blx	r3
            return Status_Unhandled;
 800f09e:	2354      	movs	r3, #84	; 0x54
 800f0a0:	e147      	b.n	800f332 <mc_homing_cycle+0x36a>
        }

#ifdef KINEMATICS_API
        if(kinematics.homing_cycle_validate) {
 800f0a2:	4b6e      	ldr	r3, [pc, #440]	; (800f25c <mc_homing_cycle+0x294>)
 800f0a4:	699b      	ldr	r3, [r3, #24]
 800f0a6:	2b00      	cmp	r3, #0
 800f0a8:	d03c      	beq.n	800f124 <mc_homing_cycle+0x15c>

            uint_fast8_t idx = N_AXIS;
 800f0aa:	2303      	movs	r3, #3
 800f0ac:	61bb      	str	r3, [r7, #24]

            if (!home_all) { // Perform homing cycle based on mask.
 800f0ae:	7cfb      	ldrb	r3, [r7, #19]
 800f0b0:	f083 0301 	eor.w	r3, r3, #1
 800f0b4:	b2db      	uxtb	r3, r3
 800f0b6:	2b00      	cmp	r3, #0
 800f0b8:	d010      	beq.n	800f0dc <mc_homing_cycle+0x114>
                if(!kinematics.homing_cycle_validate(cycle)) {
 800f0ba:	4b68      	ldr	r3, [pc, #416]	; (800f25c <mc_homing_cycle+0x294>)
 800f0bc:	699b      	ldr	r3, [r3, #24]
 800f0be:	7938      	ldrb	r0, [r7, #4]
 800f0c0:	4798      	blx	r3
 800f0c2:	4603      	mov	r3, r0
 800f0c4:	f083 0301 	eor.w	r3, r3, #1
 800f0c8:	b2db      	uxtb	r3, r3
 800f0ca:	2b00      	cmp	r3, #0
 800f0cc:	d02a      	beq.n	800f124 <mc_homing_cycle+0x15c>
                    system_set_exec_alarm(Alarm_HomingFail);
 800f0ce:	4b64      	ldr	r3, [pc, #400]	; (800f260 <mc_homing_cycle+0x298>)
 800f0d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f0d2:	2112      	movs	r1, #18
 800f0d4:	4863      	ldr	r0, [pc, #396]	; (800f264 <mc_homing_cycle+0x29c>)
 800f0d6:	4798      	blx	r3
                    return Status_Unhandled;
 800f0d8:	2354      	movs	r3, #84	; 0x54
 800f0da:	e12a      	b.n	800f332 <mc_homing_cycle+0x36a>
                }
            } else do {
                if(settings.homing.cycle[--idx].mask) {
 800f0dc:	69bb      	ldr	r3, [r7, #24]
 800f0de:	3b01      	subs	r3, #1
 800f0e0:	61bb      	str	r3, [r7, #24]
 800f0e2:	4a5c      	ldr	r2, [pc, #368]	; (800f254 <mc_homing_cycle+0x28c>)
 800f0e4:	69bb      	ldr	r3, [r7, #24]
 800f0e6:	4413      	add	r3, r2
 800f0e8:	f203 1315 	addw	r3, r3, #277	; 0x115
 800f0ec:	781b      	ldrb	r3, [r3, #0]
 800f0ee:	2b00      	cmp	r3, #0
 800f0f0:	d015      	beq.n	800f11e <mc_homing_cycle+0x156>
                    if(!kinematics.homing_cycle_validate(settings.homing.cycle[idx])) {
 800f0f2:	4b5a      	ldr	r3, [pc, #360]	; (800f25c <mc_homing_cycle+0x294>)
 800f0f4:	699b      	ldr	r3, [r3, #24]
 800f0f6:	4957      	ldr	r1, [pc, #348]	; (800f254 <mc_homing_cycle+0x28c>)
 800f0f8:	69ba      	ldr	r2, [r7, #24]
 800f0fa:	440a      	add	r2, r1
 800f0fc:	f202 1215 	addw	r2, r2, #277	; 0x115
 800f100:	7810      	ldrb	r0, [r2, #0]
 800f102:	4798      	blx	r3
 800f104:	4603      	mov	r3, r0
 800f106:	f083 0301 	eor.w	r3, r3, #1
 800f10a:	b2db      	uxtb	r3, r3
 800f10c:	2b00      	cmp	r3, #0
 800f10e:	d006      	beq.n	800f11e <mc_homing_cycle+0x156>
                        system_set_exec_alarm(Alarm_HomingFail);
 800f110:	4b53      	ldr	r3, [pc, #332]	; (800f260 <mc_homing_cycle+0x298>)
 800f112:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f114:	2112      	movs	r1, #18
 800f116:	4853      	ldr	r0, [pc, #332]	; (800f264 <mc_homing_cycle+0x29c>)
 800f118:	4798      	blx	r3
                        return Status_Unhandled;
 800f11a:	2354      	movs	r3, #84	; 0x54
 800f11c:	e109      	b.n	800f332 <mc_homing_cycle+0x36a>
                    }
                }
            } while(idx);
 800f11e:	69bb      	ldr	r3, [r7, #24]
 800f120:	2b00      	cmp	r3, #0
 800f122:	d1db      	bne.n	800f0dc <mc_homing_cycle+0x114>

        }
#endif

        state_set(STATE_HOMING);                        // Set homing system state.
 800f124:	2004      	movs	r0, #4
 800f126:	f00e fbd5 	bl	801d8d4 <state_set>
#if COMPATIBILITY_LEVEL == 0
        system_set_exec_state_flag(EXEC_STATUS_REPORT); // Force a status report and
 800f12a:	4b4d      	ldr	r3, [pc, #308]	; (800f260 <mc_homing_cycle+0x298>)
 800f12c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f12e:	2101      	movs	r1, #1
 800f130:	484d      	ldr	r0, [pc, #308]	; (800f268 <mc_homing_cycle+0x2a0>)
 800f132:	4798      	blx	r3
        delay_sec(0.1f, DelayMode_Dwell);               // delay a bit to get it sent (or perhaps wait a bit for a request?)
 800f134:	2100      	movs	r1, #0
 800f136:	484d      	ldr	r0, [pc, #308]	; (800f26c <mc_homing_cycle+0x2a4>)
 800f138:	f001 fb24 	bl	8010784 <delay_sec>
#endif
        // Turn off spindle and coolant (and update parser state)
        if(spindle_is_on())
 800f13c:	f00d fff8 	bl	801d130 <spindle_is_on>
 800f140:	4603      	mov	r3, r0
 800f142:	2b00      	cmp	r3, #0
 800f144:	d001      	beq.n	800f14a <mc_homing_cycle+0x182>
            gc_spindle_off();
 800f146:	f7f6 fe29 	bl	8005d9c <gc_spindle_off>

        if(hal.coolant.get_state().mask)
 800f14a:	4b45      	ldr	r3, [pc, #276]	; (800f260 <mc_homing_cycle+0x298>)
 800f14c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f14e:	4798      	blx	r3
 800f150:	4603      	mov	r3, r0
 800f152:	b2db      	uxtb	r3, r3
 800f154:	2b00      	cmp	r3, #0
 800f156:	d001      	beq.n	800f15c <mc_homing_cycle+0x194>
            gc_coolant_off();
 800f158:	f7f6 fe32 	bl	8005dc0 <gc_coolant_off>

        // ---------------------------------------------------------------------------
        // Perform homing routine. NOTE: Special motion case. Only system reset works.

        if (!home_all) // Perform homing cycle based on mask.
 800f15c:	7cfb      	ldrb	r3, [r7, #19]
 800f15e:	f083 0301 	eor.w	r3, r3, #1
 800f162:	b2db      	uxtb	r3, r3
 800f164:	2b00      	cmp	r3, #0
 800f166:	d005      	beq.n	800f174 <mc_homing_cycle+0x1ac>
            homed_status = limits_go_home(cycle);
 800f168:	7938      	ldrb	r0, [r7, #4]
 800f16a:	f7fd fccd 	bl	800cb08 <limits_go_home>
 800f16e:	4603      	mov	r3, r0
 800f170:	77fb      	strb	r3, [r7, #31]
 800f172:	e02f      	b.n	800f1d4 <mc_homing_cycle+0x20c>
        else {

            uint_fast8_t idx = 0;
 800f174:	2300      	movs	r3, #0
 800f176:	617b      	str	r3, [r7, #20]

            sys.homed.mask &= ~sys.homing.mask;
 800f178:	4b37      	ldr	r3, [pc, #220]	; (800f258 <mc_homing_cycle+0x290>)
 800f17a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800f17e:	b25a      	sxtb	r2, r3
 800f180:	4b35      	ldr	r3, [pc, #212]	; (800f258 <mc_homing_cycle+0x290>)
 800f182:	7e9b      	ldrb	r3, [r3, #26]
 800f184:	b25b      	sxtb	r3, r3
 800f186:	43db      	mvns	r3, r3
 800f188:	b25b      	sxtb	r3, r3
 800f18a:	4013      	ands	r3, r2
 800f18c:	b25b      	sxtb	r3, r3
 800f18e:	b2da      	uxtb	r2, r3
 800f190:	4b31      	ldr	r3, [pc, #196]	; (800f258 <mc_homing_cycle+0x290>)
 800f192:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

            do {
                if(settings.homing.cycle[idx].mask) {
 800f196:	4a2f      	ldr	r2, [pc, #188]	; (800f254 <mc_homing_cycle+0x28c>)
 800f198:	697b      	ldr	r3, [r7, #20]
 800f19a:	4413      	add	r3, r2
 800f19c:	f203 1315 	addw	r3, r3, #277	; 0x115
 800f1a0:	781b      	ldrb	r3, [r3, #0]
 800f1a2:	2b00      	cmp	r3, #0
 800f1a4:	d00e      	beq.n	800f1c4 <mc_homing_cycle+0x1fc>
                    cycle.mask = settings.homing.cycle[idx].mask;
 800f1a6:	4a2b      	ldr	r2, [pc, #172]	; (800f254 <mc_homing_cycle+0x28c>)
 800f1a8:	697b      	ldr	r3, [r7, #20]
 800f1aa:	4413      	add	r3, r2
 800f1ac:	f203 1315 	addw	r3, r3, #277	; 0x115
 800f1b0:	781b      	ldrb	r3, [r3, #0]
 800f1b2:	713b      	strb	r3, [r7, #4]
                    if((homed_status = limits_go_home(cycle)) != Status_OK)
 800f1b4:	7938      	ldrb	r0, [r7, #4]
 800f1b6:	f7fd fca7 	bl	800cb08 <limits_go_home>
 800f1ba:	4603      	mov	r3, r0
 800f1bc:	77fb      	strb	r3, [r7, #31]
 800f1be:	7ffb      	ldrb	r3, [r7, #31]
 800f1c0:	2b00      	cmp	r3, #0
 800f1c2:	d106      	bne.n	800f1d2 <mc_homing_cycle+0x20a>
                        break;
                }
            } while(++idx < N_AXIS);
 800f1c4:	697b      	ldr	r3, [r7, #20]
 800f1c6:	3301      	adds	r3, #1
 800f1c8:	617b      	str	r3, [r7, #20]
 800f1ca:	697b      	ldr	r3, [r7, #20]
 800f1cc:	2b02      	cmp	r3, #2
 800f1ce:	d9e2      	bls.n	800f196 <mc_homing_cycle+0x1ce>
 800f1d0:	e000      	b.n	800f1d4 <mc_homing_cycle+0x20c>
                        break;
 800f1d2:	bf00      	nop
        }

        // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
        // NOTE: always call at end of homing regadless of setting, may be used to disable
        // sensorless homing or switch back to limit switches input (if different from homing switches)
        hal.limits.enable(settings.limits.flags.hard_enabled, (axes_signals_t){0});
 800f1d4:	4b22      	ldr	r3, [pc, #136]	; (800f260 <mc_homing_cycle+0x298>)
 800f1d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f1d8:	4a1e      	ldr	r2, [pc, #120]	; (800f254 <mc_homing_cycle+0x28c>)
 800f1da:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 800f1de:	f3c2 0200 	ubfx	r2, r2, #0, #1
 800f1e2:	b2d2      	uxtb	r2, r2
 800f1e4:	2a00      	cmp	r2, #0
 800f1e6:	bf14      	ite	ne
 800f1e8:	2201      	movne	r2, #1
 800f1ea:	2200      	moveq	r2, #0
 800f1ec:	b2d2      	uxtb	r2, r2
 800f1ee:	2100      	movs	r1, #0
 800f1f0:	4610      	mov	r0, r2
 800f1f2:	4798      	blx	r3
    }

    if(cycle.mask) {
 800f1f4:	793b      	ldrb	r3, [r7, #4]
 800f1f6:	2b00      	cmp	r3, #0
 800f1f8:	d05d      	beq.n	800f2b6 <mc_homing_cycle+0x2ee>

        if(!protocol_execute_realtime()) {  // Check for reset and set system abort.
 800f1fa:	f003 fdb1 	bl	8012d60 <protocol_execute_realtime>
 800f1fe:	4603      	mov	r3, r0
 800f200:	f083 0301 	eor.w	r3, r3, #1
 800f204:	b2db      	uxtb	r3, r3
 800f206:	2b00      	cmp	r3, #0
 800f208:	d00b      	beq.n	800f222 <mc_homing_cycle+0x25a>

            if(grbl.on_homing_completed)
 800f20a:	4b19      	ldr	r3, [pc, #100]	; (800f270 <mc_homing_cycle+0x2a8>)
 800f20c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f210:	2b00      	cmp	r3, #0
 800f212:	d004      	beq.n	800f21e <mc_homing_cycle+0x256>
                grbl.on_homing_completed(false);
 800f214:	4b16      	ldr	r3, [pc, #88]	; (800f270 <mc_homing_cycle+0x2a8>)
 800f216:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f21a:	2000      	movs	r0, #0
 800f21c:	4798      	blx	r3

            return Status_Unhandled;        // Did not complete. Alarm state set by mc_alarm.
 800f21e:	2354      	movs	r3, #84	; 0x54
 800f220:	e087      	b.n	800f332 <mc_homing_cycle+0x36a>
        }

        if(homed_status != Status_OK) {
 800f222:	7ffb      	ldrb	r3, [r7, #31]
 800f224:	2b00      	cmp	r3, #0
 800f226:	d025      	beq.n	800f274 <mc_homing_cycle+0x2ac>

            if(state_get() == STATE_HOMING)
 800f228:	f00e fb4a 	bl	801d8c0 <state_get>
 800f22c:	4603      	mov	r3, r0
 800f22e:	2b04      	cmp	r3, #4
 800f230:	d102      	bne.n	800f238 <mc_homing_cycle+0x270>
                state_set(STATE_IDLE);
 800f232:	2000      	movs	r0, #0
 800f234:	f00e fb4e 	bl	801d8d4 <state_set>

            if(grbl.on_homing_completed)
 800f238:	4b0d      	ldr	r3, [pc, #52]	; (800f270 <mc_homing_cycle+0x2a8>)
 800f23a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f23e:	2b00      	cmp	r3, #0
 800f240:	d004      	beq.n	800f24c <mc_homing_cycle+0x284>
                grbl.on_homing_completed(false);
 800f242:	4b0b      	ldr	r3, [pc, #44]	; (800f270 <mc_homing_cycle+0x2a8>)
 800f244:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f248:	2000      	movs	r0, #0
 800f24a:	4798      	blx	r3

            return homed_status;
 800f24c:	7ffb      	ldrb	r3, [r7, #31]
 800f24e:	e070      	b.n	800f332 <mc_homing_cycle+0x36a>
 800f250:	20000dbe 	.word	0x20000dbe
 800f254:	2000147c 	.word	0x2000147c
 800f258:	20000d3c 	.word	0x20000d3c
 800f25c:	20001088 	.word	0x20001088
 800f260:	20000ed0 	.word	0x20000ed0
 800f264:	20000d88 	.word	0x20000d88
 800f268:	20000d84 	.word	0x20000d84
 800f26c:	3dcccccd 	.word	0x3dcccccd
 800f270:	20000dd4 	.word	0x20000dd4
        }

        if(home_all && settings.homing.flags.manual)
 800f274:	7cfb      	ldrb	r3, [r7, #19]
 800f276:	2b00      	cmp	r3, #0
 800f278:	d017      	beq.n	800f2aa <mc_homing_cycle+0x2e2>
 800f27a:	4b30      	ldr	r3, [pc, #192]	; (800f33c <mc_homing_cycle+0x374>)
 800f27c:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 800f280:	f003 0310 	and.w	r3, r3, #16
 800f284:	b2db      	uxtb	r3, r3
 800f286:	2b00      	cmp	r3, #0
 800f288:	d00f      	beq.n	800f2aa <mc_homing_cycle+0x2e2>
        {
            cycle.mask = AXES_BITMASK & ~sys.homing.mask;
 800f28a:	4b2d      	ldr	r3, [pc, #180]	; (800f340 <mc_homing_cycle+0x378>)
 800f28c:	7e9b      	ldrb	r3, [r3, #26]
 800f28e:	43db      	mvns	r3, r3
 800f290:	b2db      	uxtb	r3, r3
 800f292:	f003 0307 	and.w	r3, r3, #7
 800f296:	b2db      	uxtb	r3, r3
 800f298:	713b      	strb	r3, [r7, #4]
            sys.homed.mask = AXES_BITMASK;
 800f29a:	4b29      	ldr	r3, [pc, #164]	; (800f340 <mc_homing_cycle+0x378>)
 800f29c:	2207      	movs	r2, #7
 800f29e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#ifdef KINEMATICS_API
            kinematics.limits_set_machine_positions(cycle);
 800f2a2:	4b28      	ldr	r3, [pc, #160]	; (800f344 <mc_homing_cycle+0x37c>)
 800f2a4:	695b      	ldr	r3, [r3, #20]
 800f2a6:	7938      	ldrb	r0, [r7, #4]
 800f2a8:	4798      	blx	r3

        // Homing cycle complete! Setup system for normal operation.
        // ---------------------------------------------------------

        // Sync gcode parser and planner positions to homed position.
        sync_position();
 800f2aa:	f002 ff9b 	bl	80121e4 <plan_sync_position>
 800f2ae:	4926      	ldr	r1, [pc, #152]	; (800f348 <mc_homing_cycle+0x380>)
 800f2b0:	4826      	ldr	r0, [pc, #152]	; (800f34c <mc_homing_cycle+0x384>)
 800f2b2:	f012 fdad 	bl	8021e10 <system_convert_array_steps_to_mpos>
    }

    system_add_rt_report(Report_Homed);
 800f2b6:	2004      	movs	r0, #4
 800f2b8:	f012 fe70 	bl	8021f9c <system_add_rt_report>

    homed_status = settings.limits.flags.hard_enabled &&
 800f2bc:	4b1f      	ldr	r3, [pc, #124]	; (800f33c <mc_homing_cycle+0x374>)
 800f2be:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 800f2c2:	f003 0301 	and.w	r3, r3, #1
 800f2c6:	b2db      	uxtb	r3, r3
                    settings.limits.flags.check_at_init &&
                     (limit_signals_merge(hal.limits.get_state()).value & sys.hard_limits.mask)
                    ? Status_LimitsEngaged
                    : Status_OK;
 800f2c8:	2b00      	cmp	r3, #0
 800f2ca:	d01a      	beq.n	800f302 <mc_homing_cycle+0x33a>
    homed_status = settings.limits.flags.hard_enabled &&
 800f2cc:	4b1b      	ldr	r3, [pc, #108]	; (800f33c <mc_homing_cycle+0x374>)
 800f2ce:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 800f2d2:	f003 0304 	and.w	r3, r3, #4
 800f2d6:	b2db      	uxtb	r3, r3
 800f2d8:	2b00      	cmp	r3, #0
 800f2da:	d012      	beq.n	800f302 <mc_homing_cycle+0x33a>
                     (limit_signals_merge(hal.limits.get_state()).value & sys.hard_limits.mask)
 800f2dc:	4b1c      	ldr	r3, [pc, #112]	; (800f350 <mc_homing_cycle+0x388>)
 800f2de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f2e0:	4798      	blx	r3
 800f2e2:	4603      	mov	r3, r0
 800f2e4:	60fb      	str	r3, [r7, #12]
 800f2e6:	68f8      	ldr	r0, [r7, #12]
 800f2e8:	f7fc fe32 	bl	800bf50 <limit_signals_merge>
 800f2ec:	4603      	mov	r3, r0
 800f2ee:	b2da      	uxtb	r2, r3
 800f2f0:	4b13      	ldr	r3, [pc, #76]	; (800f340 <mc_homing_cycle+0x378>)
 800f2f2:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
                    settings.limits.flags.check_at_init &&
 800f2f6:	4013      	ands	r3, r2
 800f2f8:	b2db      	uxtb	r3, r3
 800f2fa:	2b00      	cmp	r3, #0
 800f2fc:	d001      	beq.n	800f302 <mc_homing_cycle+0x33a>
                    : Status_OK;
 800f2fe:	232d      	movs	r3, #45	; 0x2d
 800f300:	e000      	b.n	800f304 <mc_homing_cycle+0x33c>
 800f302:	2300      	movs	r3, #0
    homed_status = settings.limits.flags.hard_enabled &&
 800f304:	77fb      	strb	r3, [r7, #31]

    if(homed_status == Status_OK)
 800f306:	7ffb      	ldrb	r3, [r7, #31]
 800f308:	2b00      	cmp	r3, #0
 800f30a:	d101      	bne.n	800f310 <mc_homing_cycle+0x348>
        limits_set_work_envelope();
 800f30c:	f7fc fe8a 	bl	800c024 <limits_set_work_envelope>

    if(grbl.on_homing_completed)
 800f310:	4b10      	ldr	r3, [pc, #64]	; (800f354 <mc_homing_cycle+0x38c>)
 800f312:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f316:	2b00      	cmp	r3, #0
 800f318:	d00a      	beq.n	800f330 <mc_homing_cycle+0x368>
        grbl.on_homing_completed(homed_status == Status_OK);
 800f31a:	4b0e      	ldr	r3, [pc, #56]	; (800f354 <mc_homing_cycle+0x38c>)
 800f31c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800f320:	7ffa      	ldrb	r2, [r7, #31]
 800f322:	2a00      	cmp	r2, #0
 800f324:	bf0c      	ite	eq
 800f326:	2201      	moveq	r2, #1
 800f328:	2200      	movne	r2, #0
 800f32a:	b2d2      	uxtb	r2, r2
 800f32c:	4610      	mov	r0, r2
 800f32e:	4798      	blx	r3

    return homed_status;
 800f330:	7ffb      	ldrb	r3, [r7, #31]
}
 800f332:	4618      	mov	r0, r3
 800f334:	3720      	adds	r7, #32
 800f336:	46bd      	mov	sp, r7
 800f338:	bd80      	pop	{r7, pc}
 800f33a:	bf00      	nop
 800f33c:	2000147c 	.word	0x2000147c
 800f340:	20000d3c 	.word	0x20000d3c
 800f344:	20001088 	.word	0x20001088
 800f348:	20000dc4 	.word	0x20000dc4
 800f34c:	20000c0c 	.word	0x20000c0c
 800f350:	20000ed0 	.word	0x20000ed0
 800f354:	20000dd4 	.word	0x20000dd4

0800f358 <mc_probe_cycle>:

// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
gc_probe_t mc_probe_cycle (float *target, plan_line_data_t *pl_data, gc_parser_flags_t parser_flags)
{
 800f358:	b590      	push	{r4, r7, lr}
 800f35a:	b08d      	sub	sp, #52	; 0x34
 800f35c:	af00      	add	r7, sp, #0
 800f35e:	60f8      	str	r0, [r7, #12]
 800f360:	60b9      	str	r1, [r7, #8]
 800f362:	80ba      	strh	r2, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 800f364:	2303      	movs	r3, #3
 800f366:	62fb      	str	r3, [r7, #44]	; 0x2c

    // TODO: Need to update this cycle so it obeys a non-auto cycle start.
    if (state_get() == STATE_CHECK_MODE)
 800f368:	f00e faaa 	bl	801d8c0 <state_get>
 800f36c:	4603      	mov	r3, r0
 800f36e:	2b02      	cmp	r3, #2
 800f370:	d101      	bne.n	800f376 <mc_probe_cycle+0x1e>
        return GCProbe_CheckMode;
 800f372:	2300      	movs	r3, #0
 800f374:	e15b      	b.n	800f62e <mc_probe_cycle+0x2d6>

    do {
        idx--;
 800f376:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f378:	3b01      	subs	r3, #1
 800f37a:	62fb      	str	r3, [r7, #44]	; 0x2c
        sys.probe_position[idx] = lroundf(target[idx] * settings.axis[idx].steps_per_mm);
 800f37c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f37e:	009b      	lsls	r3, r3, #2
 800f380:	68fa      	ldr	r2, [r7, #12]
 800f382:	4413      	add	r3, r2
 800f384:	6818      	ldr	r0, [r3, #0]
 800f386:	49ac      	ldr	r1, [pc, #688]	; (800f638 <mc_probe_cycle+0x2e0>)
 800f388:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f38a:	4613      	mov	r3, r2
 800f38c:	009b      	lsls	r3, r3, #2
 800f38e:	4413      	add	r3, r2
 800f390:	009b      	lsls	r3, r3, #2
 800f392:	440b      	add	r3, r1
 800f394:	3330      	adds	r3, #48	; 0x30
 800f396:	681b      	ldr	r3, [r3, #0]
 800f398:	4619      	mov	r1, r3
 800f39a:	f7f1 fd0b 	bl	8000db4 <__aeabi_fmul>
 800f39e:	4603      	mov	r3, r0
 800f3a0:	4618      	mov	r0, r3
 800f3a2:	f015 fbe7 	bl	8024b74 <lroundf>
 800f3a6:	4602      	mov	r2, r0
 800f3a8:	49a4      	ldr	r1, [pc, #656]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f3aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f3ac:	330e      	adds	r3, #14
 800f3ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    } while(idx);
 800f3b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f3b4:	2b00      	cmp	r3, #0
 800f3b6:	d1de      	bne.n	800f376 <mc_probe_cycle+0x1e>

    sys.probe_coordsys_id = gc_state.modal.coord_system.id;
 800f3b8:	4ba1      	ldr	r3, [pc, #644]	; (800f640 <mc_probe_cycle+0x2e8>)
 800f3ba:	7d1a      	ldrb	r2, [r3, #20]
 800f3bc:	4b9f      	ldr	r3, [pc, #636]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f3be:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

    // Finish all queued commands and empty planner buffer before starting probe cycle.
    if (!protocol_buffer_synchronize())
 800f3c2:	f003 fc9d 	bl	8012d00 <protocol_buffer_synchronize>
 800f3c6:	4603      	mov	r3, r0
 800f3c8:	f083 0301 	eor.w	r3, r3, #1
 800f3cc:	b2db      	uxtb	r3, r3
 800f3ce:	2b00      	cmp	r3, #0
 800f3d0:	d001      	beq.n	800f3d6 <mc_probe_cycle+0x7e>
        return GCProbe_Abort; // Return if system reset has been issued.
 800f3d2:	2302      	movs	r3, #2
 800f3d4:	e12b      	b.n	800f62e <mc_probe_cycle+0x2d6>

    // Initialize probing control variables
    sys.flags.probe_succeeded = Off; // Re-initialize probe history before beginning cycle.
 800f3d6:	4a99      	ldr	r2, [pc, #612]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f3d8:	7d93      	ldrb	r3, [r2, #22]
 800f3da:	f36f 0341 	bfc	r3, #1, #1
 800f3de:	7593      	strb	r3, [r2, #22]
    hal.probe.configure(parser_flags.probe_is_away, true);
 800f3e0:	4b98      	ldr	r3, [pc, #608]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f3e2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800f3e6:	793a      	ldrb	r2, [r7, #4]
 800f3e8:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800f3ec:	b2d2      	uxtb	r2, r2
 800f3ee:	2a00      	cmp	r2, #0
 800f3f0:	bf14      	ite	ne
 800f3f2:	2201      	movne	r2, #1
 800f3f4:	2200      	moveq	r2, #0
 800f3f6:	b2d2      	uxtb	r2, r2
 800f3f8:	2101      	movs	r1, #1
 800f3fa:	4610      	mov	r0, r2
 800f3fc:	4798      	blx	r3

#if COMPATIBILITY_LEVEL <= 1
    bool at_g59_3 = false, probe_fixture = grbl.on_probe_fixture != NULL && state_get() != STATE_TOOL_CHANGE && (sys.homed.mask & (X_AXIS_BIT|Y_AXIS_BIT));
 800f3fe:	2300      	movs	r3, #0
 800f400:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 800f404:	4b90      	ldr	r3, [pc, #576]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f406:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800f40a:	2b00      	cmp	r3, #0
 800f40c:	d00e      	beq.n	800f42c <mc_probe_cycle+0xd4>
 800f40e:	f00e fa57 	bl	801d8c0 <state_get>
 800f412:	4603      	mov	r3, r0
 800f414:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f418:	d008      	beq.n	800f42c <mc_probe_cycle+0xd4>
 800f41a:	4b88      	ldr	r3, [pc, #544]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f41c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800f420:	f003 0303 	and.w	r3, r3, #3
 800f424:	2b00      	cmp	r3, #0
 800f426:	d001      	beq.n	800f42c <mc_probe_cycle+0xd4>
 800f428:	2301      	movs	r3, #1
 800f42a:	e000      	b.n	800f42e <mc_probe_cycle+0xd6>
 800f42c:	2300      	movs	r3, #0
 800f42e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 800f432:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800f436:	f003 0301 	and.w	r3, r3, #1
 800f43a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    if(probe_fixture)
 800f43e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800f442:	2b00      	cmp	r3, #0
 800f444:	d00f      	beq.n	800f466 <mc_probe_cycle+0x10e>
        grbl.on_probe_fixture(NULL, at_g59_3 = system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
 800f446:	4b80      	ldr	r3, [pc, #512]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f448:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
 800f44c:	497f      	ldr	r1, [pc, #508]	; (800f64c <mc_probe_cycle+0x2f4>)
 800f44e:	2008      	movs	r0, #8
 800f450:	f012 fcee 	bl	8021e30 <system_xy_at_fixture>
 800f454:	4603      	mov	r3, r0
 800f456:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 800f45a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800f45e:	2201      	movs	r2, #1
 800f460:	4619      	mov	r1, r3
 800f462:	2000      	movs	r0, #0
 800f464:	47a0      	blx	r4
#endif

    // After syncing, check if probe is already triggered or not connected. If so, halt and issue alarm.
    // NOTE: This probe initialization error applies to all probing cycles.
    probe_state_t probe = hal.probe.get_state();
 800f466:	4b77      	ldr	r3, [pc, #476]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f468:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800f46c:	4798      	blx	r3
 800f46e:	4603      	mov	r3, r0
 800f470:	f887 3020 	strb.w	r3, [r7, #32]
    if (probe.triggered || !probe.connected) { // Check probe state.
 800f474:	f897 3020 	ldrb.w	r3, [r7, #32]
 800f478:	f003 0301 	and.w	r3, r3, #1
 800f47c:	b2db      	uxtb	r3, r3
 800f47e:	2b00      	cmp	r3, #0
 800f480:	d106      	bne.n	800f490 <mc_probe_cycle+0x138>
 800f482:	f897 3020 	ldrb.w	r3, [r7, #32]
 800f486:	f003 0302 	and.w	r3, r3, #2
 800f48a:	b2db      	uxtb	r3, r3
 800f48c:	2b00      	cmp	r3, #0
 800f48e:	d10e      	bne.n	800f4ae <mc_probe_cycle+0x156>
        system_set_exec_alarm(Alarm_ProbeFailInitial);
 800f490:	4b6c      	ldr	r3, [pc, #432]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f492:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f494:	2104      	movs	r1, #4
 800f496:	486e      	ldr	r0, [pc, #440]	; (800f650 <mc_probe_cycle+0x2f8>)
 800f498:	4798      	blx	r3
        protocol_execute_realtime();
 800f49a:	f003 fc61 	bl	8012d60 <protocol_execute_realtime>
        hal.probe.configure(false, false); // Re-initialize invert mask before returning.
 800f49e:	4b69      	ldr	r3, [pc, #420]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f4a0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800f4a4:	2100      	movs	r1, #0
 800f4a6:	2000      	movs	r0, #0
 800f4a8:	4798      	blx	r3
        return GCProbe_FailInit; // Nothing else to do but bail.
 800f4aa:	2302      	movs	r3, #2
 800f4ac:	e0bf      	b.n	800f62e <mc_probe_cycle+0x2d6>
    }

    if(grbl.on_probe_start) {
 800f4ae:	4b66      	ldr	r3, [pc, #408]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f4b0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800f4b4:	2b00      	cmp	r3, #0
 800f4b6:	d03a      	beq.n	800f52e <mc_probe_cycle+0x1d6>

        uint_fast8_t idx = N_AXIS;
 800f4b8:	2303      	movs	r3, #3
 800f4ba:	627b      	str	r3, [r7, #36]	; 0x24
        axes_signals_t axes = {0};
 800f4bc:	2300      	movs	r3, #0
 800f4be:	773b      	strb	r3, [r7, #28]
        coord_data_t position;

        system_convert_array_steps_to_mpos(position.values, sys.position);
 800f4c0:	f107 0310 	add.w	r3, r7, #16
 800f4c4:	4963      	ldr	r1, [pc, #396]	; (800f654 <mc_probe_cycle+0x2fc>)
 800f4c6:	4618      	mov	r0, r3
 800f4c8:	f012 fca2 	bl	8021e10 <system_convert_array_steps_to_mpos>

        do {
            idx--;
 800f4cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f4ce:	3b01      	subs	r3, #1
 800f4d0:	627b      	str	r3, [r7, #36]	; 0x24
            if(fabsf(target[idx] - position.values[idx]) > TOLERANCE_EQUAL)
 800f4d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f4d4:	009b      	lsls	r3, r3, #2
 800f4d6:	68fa      	ldr	r2, [r7, #12]
 800f4d8:	4413      	add	r3, r2
 800f4da:	681a      	ldr	r2, [r3, #0]
 800f4dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f4de:	009b      	lsls	r3, r3, #2
 800f4e0:	3330      	adds	r3, #48	; 0x30
 800f4e2:	443b      	add	r3, r7
 800f4e4:	f853 3c20 	ldr.w	r3, [r3, #-32]
 800f4e8:	4619      	mov	r1, r3
 800f4ea:	4610      	mov	r0, r2
 800f4ec:	f7f1 fb58 	bl	8000ba0 <__aeabi_fsub>
 800f4f0:	4603      	mov	r3, r0
 800f4f2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800f4f6:	4958      	ldr	r1, [pc, #352]	; (800f658 <mc_probe_cycle+0x300>)
 800f4f8:	4618      	mov	r0, r3
 800f4fa:	f7f1 fe17 	bl	800112c <__aeabi_fcmpgt>
 800f4fe:	4603      	mov	r3, r0
 800f500:	2b00      	cmp	r3, #0
 800f502:	d008      	beq.n	800f516 <mc_probe_cycle+0x1be>
                bit_true(axes.mask, bit(idx));
 800f504:	7f3a      	ldrb	r2, [r7, #28]
 800f506:	2101      	movs	r1, #1
 800f508:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f50a:	fa01 f303 	lsl.w	r3, r1, r3
 800f50e:	b2db      	uxtb	r3, r3
 800f510:	4313      	orrs	r3, r2
 800f512:	b2db      	uxtb	r3, r3
 800f514:	773b      	strb	r3, [r7, #28]
        } while(idx--);
 800f516:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f518:	1e5a      	subs	r2, r3, #1
 800f51a:	627a      	str	r2, [r7, #36]	; 0x24
 800f51c:	2b00      	cmp	r3, #0
 800f51e:	d1d5      	bne.n	800f4cc <mc_probe_cycle+0x174>

        grbl.on_probe_start(axes, target, pl_data);
 800f520:	4b49      	ldr	r3, [pc, #292]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f522:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800f526:	68ba      	ldr	r2, [r7, #8]
 800f528:	68f9      	ldr	r1, [r7, #12]
 800f52a:	7f38      	ldrb	r0, [r7, #28]
 800f52c:	4798      	blx	r3
    }

    // Setup and queue probing motion. Auto cycle-start should not start the cycle.
    if(!mc_line(target, pl_data))
 800f52e:	68b9      	ldr	r1, [r7, #8]
 800f530:	68f8      	ldr	r0, [r7, #12]
 800f532:	f7fe fa61 	bl	800d9f8 <mc_line>
 800f536:	4603      	mov	r3, r0
 800f538:	f083 0301 	eor.w	r3, r3, #1
 800f53c:	b2db      	uxtb	r3, r3
 800f53e:	2b00      	cmp	r3, #0
 800f540:	d001      	beq.n	800f546 <mc_probe_cycle+0x1ee>
        return GCProbe_Abort;
 800f542:	2302      	movs	r3, #2
 800f544:	e073      	b.n	800f62e <mc_probe_cycle+0x2d6>

    // Activate the probing state monitor in the stepper module.
    sys.probing_state = Probing_Active;
 800f546:	4b3d      	ldr	r3, [pc, #244]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f548:	2201      	movs	r2, #1
 800f54a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

    // Perform probing cycle. Wait here until probe is triggered or motion completes.
    system_set_exec_state_flag(EXEC_CYCLE_START);
 800f54e:	4b3d      	ldr	r3, [pc, #244]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f550:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f552:	2102      	movs	r1, #2
 800f554:	4841      	ldr	r0, [pc, #260]	; (800f65c <mc_probe_cycle+0x304>)
 800f556:	4798      	blx	r3
    do {
        if(!protocol_execute_realtime()) // Check for system abort
 800f558:	f003 fc02 	bl	8012d60 <protocol_execute_realtime>
 800f55c:	4603      	mov	r3, r0
 800f55e:	f083 0301 	eor.w	r3, r3, #1
 800f562:	b2db      	uxtb	r3, r3
 800f564:	2b00      	cmp	r3, #0
 800f566:	d001      	beq.n	800f56c <mc_probe_cycle+0x214>
            return GCProbe_Abort;
 800f568:	2302      	movs	r3, #2
 800f56a:	e060      	b.n	800f62e <mc_probe_cycle+0x2d6>
    } while (!(state_get() == STATE_IDLE || state_get() == STATE_TOOL_CHANGE));
 800f56c:	f00e f9a8 	bl	801d8c0 <state_get>
 800f570:	4603      	mov	r3, r0
 800f572:	2b00      	cmp	r3, #0
 800f574:	d005      	beq.n	800f582 <mc_probe_cycle+0x22a>
 800f576:	f00e f9a3 	bl	801d8c0 <state_get>
 800f57a:	4603      	mov	r3, r0
 800f57c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f580:	d1ea      	bne.n	800f558 <mc_probe_cycle+0x200>

    // Probing cycle complete!

    // Set state variables and error out, if the probe failed and cycle with error is enabled.
    if(sys.probing_state == Probing_Active) {
 800f582:	4b2e      	ldr	r3, [pc, #184]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f584:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800f588:	b2db      	uxtb	r3, r3
 800f58a:	2b01      	cmp	r3, #1
 800f58c:	d112      	bne.n	800f5b4 <mc_probe_cycle+0x25c>
        memcpy(sys.probe_position, sys.position, sizeof(sys.position));
 800f58e:	4b2b      	ldr	r3, [pc, #172]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f590:	4a2a      	ldr	r2, [pc, #168]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f592:	3338      	adds	r3, #56	; 0x38
 800f594:	3288      	adds	r2, #136	; 0x88
 800f596:	ca07      	ldmia	r2, {r0, r1, r2}
 800f598:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        if(!parser_flags.probe_is_no_error)
 800f59c:	793b      	ldrb	r3, [r7, #4]
 800f59e:	f003 0310 	and.w	r3, r3, #16
 800f5a2:	b2db      	uxtb	r3, r3
 800f5a4:	2b00      	cmp	r3, #0
 800f5a6:	d10a      	bne.n	800f5be <mc_probe_cycle+0x266>
            system_set_exec_alarm(Alarm_ProbeFailContact);
 800f5a8:	4b26      	ldr	r3, [pc, #152]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f5aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f5ac:	2105      	movs	r1, #5
 800f5ae:	4828      	ldr	r0, [pc, #160]	; (800f650 <mc_probe_cycle+0x2f8>)
 800f5b0:	4798      	blx	r3
 800f5b2:	e004      	b.n	800f5be <mc_probe_cycle+0x266>
    } else
        sys.flags.probe_succeeded = On; // Indicate to system the probing cycle completed successfully.
 800f5b4:	4a21      	ldr	r2, [pc, #132]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f5b6:	7d93      	ldrb	r3, [r2, #22]
 800f5b8:	f043 0302 	orr.w	r3, r3, #2
 800f5bc:	7593      	strb	r3, [r2, #22]

    sys.probing_state = Probing_Off;    // Ensure probe state monitor is disabled.
 800f5be:	4b1f      	ldr	r3, [pc, #124]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f5c0:	2200      	movs	r2, #0
 800f5c2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    hal.probe.configure(false, false);  // Re-initialize invert mask.
 800f5c6:	4b1f      	ldr	r3, [pc, #124]	; (800f644 <mc_probe_cycle+0x2ec>)
 800f5c8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 800f5cc:	2100      	movs	r1, #0
 800f5ce:	2000      	movs	r0, #0
 800f5d0:	4798      	blx	r3
    protocol_execute_realtime();        // Check and execute run-time commands
 800f5d2:	f003 fbc5 	bl	8012d60 <protocol_execute_realtime>

#if COMPATIBILITY_LEVEL <= 1
    if(probe_fixture)
 800f5d6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800f5da:	2b00      	cmp	r3, #0
 800f5dc:	d007      	beq.n	800f5ee <mc_probe_cycle+0x296>
        grbl.on_probe_fixture(NULL, at_g59_3, false);
 800f5de:	4b1a      	ldr	r3, [pc, #104]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f5e0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800f5e4:	f897 102b 	ldrb.w	r1, [r7, #43]	; 0x2b
 800f5e8:	2200      	movs	r2, #0
 800f5ea:	2000      	movs	r0, #0
 800f5ec:	4798      	blx	r3
#endif

    // Reset the stepper and planner buffers to remove the remainder of the probe motion.
    st_reset();             // Reset step segment buffer.
 800f5ee:	f00f fcdb 	bl	801efa8 <st_reset>
    plan_reset();           // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 800f5f2:	f002 f895 	bl	8011720 <plan_reset>
    plan_sync_position();   // Sync planner position to current machine position.
 800f5f6:	f002 fdf5 	bl	80121e4 <plan_sync_position>
#if ENABLE_BACKLASH_COMPENSATION
    mc_sync_backlash_position();
#endif

    // All done! Output the probe position as message if configured.
    if(settings.status_report.probe_coordinates)
 800f5fa:	4b0f      	ldr	r3, [pc, #60]	; (800f638 <mc_probe_cycle+0x2e0>)
 800f5fc:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 800f600:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f604:	b2db      	uxtb	r3, r3
 800f606:	2b00      	cmp	r3, #0
 800f608:	d001      	beq.n	800f60e <mc_probe_cycle+0x2b6>
        report_probe_parameters();
 800f60a:	f005 fab7 	bl	8014b7c <report_probe_parameters>

    if(grbl.on_probe_completed)
 800f60e:	4b0e      	ldr	r3, [pc, #56]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f610:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800f614:	2b00      	cmp	r3, #0
 800f616:	d003      	beq.n	800f620 <mc_probe_cycle+0x2c8>
        grbl.on_probe_completed();
 800f618:	4b0b      	ldr	r3, [pc, #44]	; (800f648 <mc_probe_cycle+0x2f0>)
 800f61a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800f61e:	4798      	blx	r3

    // Successful probe cycle or Failed to trigger probe within travel. With or without error.
    return sys.flags.probe_succeeded ? GCProbe_Found : GCProbe_FailEnd;
 800f620:	4b06      	ldr	r3, [pc, #24]	; (800f63c <mc_probe_cycle+0x2e4>)
 800f622:	7d9b      	ldrb	r3, [r3, #22]
 800f624:	085b      	lsrs	r3, r3, #1
 800f626:	b2db      	uxtb	r3, r3
 800f628:	f003 0301 	and.w	r3, r3, #1
 800f62c:	b2db      	uxtb	r3, r3
}
 800f62e:	4618      	mov	r0, r3
 800f630:	3734      	adds	r7, #52	; 0x34
 800f632:	46bd      	mov	sp, r7
 800f634:	bd90      	pop	{r4, r7, pc}
 800f636:	bf00      	nop
 800f638:	2000147c 	.word	0x2000147c
 800f63c:	20000d3c 	.word	0x20000d3c
 800f640:	20000bb0 	.word	0x20000bb0
 800f644:	20000ed0 	.word	0x20000ed0
 800f648:	20000dd4 	.word	0x20000dd4
 800f64c:	40a00000 	.word	0x40a00000
 800f650:	20000d88 	.word	0x20000d88
 800f654:	20000dc4 	.word	0x20000dc4
 800f658:	38d1b717 	.word	0x38d1b717
 800f65c:	20000d84 	.word	0x20000d84

0800f660 <mc_parking_motion>:


// Plans and executes the single special motion case for parking. Independent of main planner buffer.
// NOTE: Uses the always free planner ring buffer head to store motion parameters for execution.
bool mc_parking_motion (float *parking_target, plan_line_data_t *pl_data)
{
 800f660:	b580      	push	{r7, lr}
 800f662:	b084      	sub	sp, #16
 800f664:	af00      	add	r7, sp, #0
 800f666:	6078      	str	r0, [r7, #4]
 800f668:	6039      	str	r1, [r7, #0]
    bool ok;

    if (sys.abort)
 800f66a:	4b12      	ldr	r3, [pc, #72]	; (800f6b4 <mc_parking_motion+0x54>)
 800f66c:	781b      	ldrb	r3, [r3, #0]
 800f66e:	2b00      	cmp	r3, #0
 800f670:	d001      	beq.n	800f676 <mc_parking_motion+0x16>
        return false; // Block during abort.
 800f672:	2300      	movs	r3, #0
 800f674:	e019      	b.n	800f6aa <mc_parking_motion+0x4a>

    if ((ok = plan_buffer_line(parking_target, pl_data))) {
 800f676:	6839      	ldr	r1, [r7, #0]
 800f678:	6878      	ldr	r0, [r7, #4]
 800f67a:	f002 fabd 	bl	8011bf8 <plan_buffer_line>
 800f67e:	4603      	mov	r3, r0
 800f680:	73fb      	strb	r3, [r7, #15]
 800f682:	7bfb      	ldrb	r3, [r7, #15]
 800f684:	2b00      	cmp	r3, #0
 800f686:	d00f      	beq.n	800f6a8 <mc_parking_motion+0x48>
        sys.step_control.execute_sys_motion = On;
 800f688:	4a0a      	ldr	r2, [pc, #40]	; (800f6b4 <mc_parking_motion+0x54>)
 800f68a:	7e13      	ldrb	r3, [r2, #24]
 800f68c:	f043 0304 	orr.w	r3, r3, #4
 800f690:	7613      	strb	r3, [r2, #24]
        sys.step_control.end_motion = Off;  // Allow parking motion to execute, if feed hold is active.
 800f692:	4a08      	ldr	r2, [pc, #32]	; (800f6b4 <mc_parking_motion+0x54>)
 800f694:	7e13      	ldrb	r3, [r2, #24]
 800f696:	f36f 0300 	bfc	r3, #0, #1
 800f69a:	7613      	strb	r3, [r2, #24]
        st_parking_setup_buffer();          // Setup step segment buffer for special parking motion case.
 800f69c:	f00f fd92 	bl	801f1c4 <st_parking_setup_buffer>
        st_prep_buffer();
 800f6a0:	f00f fe1e 	bl	801f2e0 <st_prep_buffer>
        st_wake_up();
 800f6a4:	f00f f9f6 	bl	801ea94 <st_wake_up>
    }

    return ok;
 800f6a8:	7bfb      	ldrb	r3, [r7, #15]
}
 800f6aa:	4618      	mov	r0, r3
 800f6ac:	3710      	adds	r7, #16
 800f6ae:	46bd      	mov	sp, r7
 800f6b0:	bd80      	pop	{r7, pc}
 800f6b2:	bf00      	nop
 800f6b4:	20000d3c 	.word	0x20000d3c

0800f6b8 <mc_override_ctrl_update>:

void mc_override_ctrl_update (gc_override_flags_t override_state)
{
 800f6b8:	b580      	push	{r7, lr}
 800f6ba:	b082      	sub	sp, #8
 800f6bc:	af00      	add	r7, sp, #0
 800f6be:	7138      	strb	r0, [r7, #4]
// Finish all queued commands before altering override control state
    protocol_buffer_synchronize();
 800f6c0:	f003 fb1e 	bl	8012d00 <protocol_buffer_synchronize>
    if (!sys.abort)
 800f6c4:	4b07      	ldr	r3, [pc, #28]	; (800f6e4 <mc_override_ctrl_update+0x2c>)
 800f6c6:	781b      	ldrb	r3, [r3, #0]
 800f6c8:	f083 0301 	eor.w	r3, r3, #1
 800f6cc:	b2db      	uxtb	r3, r3
 800f6ce:	2b00      	cmp	r3, #0
 800f6d0:	d003      	beq.n	800f6da <mc_override_ctrl_update+0x22>
        sys.override.control = override_state;
 800f6d2:	4a04      	ldr	r2, [pc, #16]	; (800f6e4 <mc_override_ctrl_update+0x2c>)
 800f6d4:	793b      	ldrb	r3, [r7, #4]
 800f6d6:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
}
 800f6da:	bf00      	nop
 800f6dc:	3708      	adds	r7, #8
 800f6de:	46bd      	mov	sp, r7
 800f6e0:	bd80      	pop	{r7, pc}
 800f6e2:	bf00      	nop
 800f6e4:	20000d3c 	.word	0x20000d3c

0800f6e8 <mc_reset>:
// active processes in the system. This also checks if a system reset is issued while Grbl
// is in a motion state. If so, kills the steppers and sets the system alarm to flag position
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
ISR_CODE void ISR_FUNC(mc_reset)(void)
{
 800f6e8:	b580      	push	{r7, lr}
 800f6ea:	af00      	add	r7, sp, #0
    // Only this function can set the system reset. Helps prevent multiple kill calls.
    if (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 800f6ec:	4b37      	ldr	r3, [pc, #220]	; (800f7cc <mc_reset+0xe4>)
 800f6ee:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800f6f0:	f003 0320 	and.w	r3, r3, #32
 800f6f4:	2b00      	cmp	r3, #0
 800f6f6:	d166      	bne.n	800f7c6 <mc_reset+0xde>

        system_set_exec_state_flag(EXEC_RESET);
 800f6f8:	4b35      	ldr	r3, [pc, #212]	; (800f7d0 <mc_reset+0xe8>)
 800f6fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f6fc:	2120      	movs	r1, #32
 800f6fe:	4835      	ldr	r0, [pc, #212]	; (800f7d4 <mc_reset+0xec>)
 800f700:	4798      	blx	r3

        if(hal.stream.suspend_read)
 800f702:	4b33      	ldr	r3, [pc, #204]	; (800f7d0 <mc_reset+0xe8>)
 800f704:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800f708:	2b00      	cmp	r3, #0
 800f70a:	d004      	beq.n	800f716 <mc_reset+0x2e>
            hal.stream.suspend_read(false);
 800f70c:	4b30      	ldr	r3, [pc, #192]	; (800f7d0 <mc_reset+0xe8>)
 800f70e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800f712:	2000      	movs	r0, #0
 800f714:	4798      	blx	r3

        // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
        // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
        // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
        // violated, by which, all bets are off.
        if ((state_get() & (STATE_CYCLE|STATE_HOMING|STATE_JOG)) || sys.step_control.execute_hold || sys.step_control.execute_sys_motion) {
 800f716:	f00e f8d3 	bl	801d8c0 <state_get>
 800f71a:	4603      	mov	r3, r0
 800f71c:	f003 032c 	and.w	r3, r3, #44	; 0x2c
 800f720:	2b00      	cmp	r3, #0
 800f722:	d10d      	bne.n	800f740 <mc_reset+0x58>
 800f724:	4b29      	ldr	r3, [pc, #164]	; (800f7cc <mc_reset+0xe4>)
 800f726:	7e1b      	ldrb	r3, [r3, #24]
 800f728:	f003 0302 	and.w	r3, r3, #2
 800f72c:	b2db      	uxtb	r3, r3
 800f72e:	2b00      	cmp	r3, #0
 800f730:	d106      	bne.n	800f740 <mc_reset+0x58>
 800f732:	4b26      	ldr	r3, [pc, #152]	; (800f7cc <mc_reset+0xe4>)
 800f734:	7e1b      	ldrb	r3, [r3, #24]
 800f736:	f003 0304 	and.w	r3, r3, #4
 800f73a:	b2db      	uxtb	r3, r3
 800f73c:	2b00      	cmp	r3, #0
 800f73e:	d018      	beq.n	800f772 <mc_reset+0x8a>

            sys.position_lost = true;
 800f740:	4b22      	ldr	r3, [pc, #136]	; (800f7cc <mc_reset+0xe4>)
 800f742:	2201      	movs	r2, #1
 800f744:	70da      	strb	r2, [r3, #3]

            if (state_get() != STATE_HOMING)
 800f746:	f00e f8bb 	bl	801d8c0 <state_get>
 800f74a:	4603      	mov	r3, r0
 800f74c:	2b04      	cmp	r3, #4
 800f74e:	d005      	beq.n	800f75c <mc_reset+0x74>
                system_set_exec_alarm(Alarm_AbortCycle);
 800f750:	4b1f      	ldr	r3, [pc, #124]	; (800f7d0 <mc_reset+0xe8>)
 800f752:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f754:	2103      	movs	r1, #3
 800f756:	4820      	ldr	r0, [pc, #128]	; (800f7d8 <mc_reset+0xf0>)
 800f758:	4798      	blx	r3
 800f75a:	e008      	b.n	800f76e <mc_reset+0x86>
            else if (!sys.rt_exec_alarm)
 800f75c:	4b1b      	ldr	r3, [pc, #108]	; (800f7cc <mc_reset+0xe4>)
 800f75e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f760:	2b00      	cmp	r3, #0
 800f762:	d104      	bne.n	800f76e <mc_reset+0x86>
                system_set_exec_alarm(Alarm_HomingFailReset);
 800f764:	4b1a      	ldr	r3, [pc, #104]	; (800f7d0 <mc_reset+0xe8>)
 800f766:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f768:	2106      	movs	r1, #6
 800f76a:	481b      	ldr	r0, [pc, #108]	; (800f7d8 <mc_reset+0xf0>)
 800f76c:	4798      	blx	r3

            st_go_idle(); // Force kill steppers. Position has likely been lost.
 800f76e:	f00f f9a5 	bl	801eabc <st_go_idle>
        }

        if(hal.control.get_state().e_stop)
 800f772:	4b17      	ldr	r3, [pc, #92]	; (800f7d0 <mc_reset+0xe8>)
 800f774:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f776:	4798      	blx	r3
 800f778:	4603      	mov	r3, r0
 800f77a:	b2db      	uxtb	r3, r3
 800f77c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f780:	b2db      	uxtb	r3, r3
 800f782:	2b00      	cmp	r3, #0
 800f784:	d005      	beq.n	800f792 <mc_reset+0xaa>
            system_set_exec_alarm(Alarm_EStop);
 800f786:	4b12      	ldr	r3, [pc, #72]	; (800f7d0 <mc_reset+0xe8>)
 800f788:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f78a:	210a      	movs	r1, #10
 800f78c:	4812      	ldr	r0, [pc, #72]	; (800f7d8 <mc_reset+0xf0>)
 800f78e:	4798      	blx	r3
 800f790:	e010      	b.n	800f7b4 <mc_reset+0xcc>
        else if(hal.control.get_state().motor_fault)
 800f792:	4b0f      	ldr	r3, [pc, #60]	; (800f7d0 <mc_reset+0xe8>)
 800f794:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800f796:	4798      	blx	r3
 800f798:	4603      	mov	r3, r0
 800f79a:	f3c3 2307 	ubfx	r3, r3, #8, #8
 800f79e:	b2db      	uxtb	r3, r3
 800f7a0:	f003 0301 	and.w	r3, r3, #1
 800f7a4:	b2db      	uxtb	r3, r3
 800f7a6:	2b00      	cmp	r3, #0
 800f7a8:	d004      	beq.n	800f7b4 <mc_reset+0xcc>
            system_set_exec_alarm(Alarm_MotorFault);
 800f7aa:	4b09      	ldr	r3, [pc, #36]	; (800f7d0 <mc_reset+0xe8>)
 800f7ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f7ae:	2111      	movs	r1, #17
 800f7b0:	4809      	ldr	r0, [pc, #36]	; (800f7d8 <mc_reset+0xf0>)
 800f7b2:	4798      	blx	r3

        if(grbl.on_reset)
 800f7b4:	4b09      	ldr	r3, [pc, #36]	; (800f7dc <mc_reset+0xf4>)
 800f7b6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800f7ba:	2b00      	cmp	r3, #0
 800f7bc:	d003      	beq.n	800f7c6 <mc_reset+0xde>
            grbl.on_reset();
 800f7be:	4b07      	ldr	r3, [pc, #28]	; (800f7dc <mc_reset+0xf4>)
 800f7c0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800f7c4:	4798      	blx	r3
    }
}
 800f7c6:	bf00      	nop
 800f7c8:	bd80      	pop	{r7, pc}
 800f7ca:	bf00      	nop
 800f7cc:	20000d3c 	.word	0x20000d3c
 800f7d0:	20000ed0 	.word	0x20000ed0
 800f7d4:	20000d84 	.word	0x20000d84
 800f7d8:	20000d88 	.word	0x20000d88
 800f7dc:	20000dd4 	.word	0x20000dd4

0800f7e0 <my_plugin_init>:
*/

#ifndef ADD_MY_PLUGIN

__attribute__((weak)) void my_plugin_init (void)
{
 800f7e0:	b480      	push	{r7}
 800f7e2:	af00      	add	r7, sp, #0
    // NOOP
}
 800f7e4:	bf00      	nop
 800f7e6:	46bd      	mov	sp, r7
 800f7e8:	bc80      	pop	{r7}
 800f7ea:	4770      	bx	lr

0800f7ec <_relative_pos>:

ngc_rw_param_t *rw_params = NULL;
ngc_named_rw_param_t *rw_global_params = NULL;

static float _relative_pos (uint_fast8_t axis)
{
 800f7ec:	b590      	push	{r4, r7, lr}
 800f7ee:	b085      	sub	sp, #20
 800f7f0:	af00      	add	r7, sp, #0
 800f7f2:	6078      	str	r0, [r7, #4]
    float value;

    if(axis < N_AXIS) {
 800f7f4:	687b      	ldr	r3, [r7, #4]
 800f7f6:	2b02      	cmp	r3, #2
 800f7f8:	d82e      	bhi.n	800f858 <_relative_pos+0x6c>
        value = sys.position[axis] / settings.axis[axis].steps_per_mm - gc_get_offset(axis);
 800f7fa:	4a1b      	ldr	r2, [pc, #108]	; (800f868 <_relative_pos+0x7c>)
 800f7fc:	687b      	ldr	r3, [r7, #4]
 800f7fe:	3322      	adds	r3, #34	; 0x22
 800f800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f804:	4618      	mov	r0, r3
 800f806:	f7f1 fa81 	bl	8000d0c <__aeabi_i2f>
 800f80a:	4918      	ldr	r1, [pc, #96]	; (800f86c <_relative_pos+0x80>)
 800f80c:	687a      	ldr	r2, [r7, #4]
 800f80e:	4613      	mov	r3, r2
 800f810:	009b      	lsls	r3, r3, #2
 800f812:	4413      	add	r3, r2
 800f814:	009b      	lsls	r3, r3, #2
 800f816:	440b      	add	r3, r1
 800f818:	3330      	adds	r3, #48	; 0x30
 800f81a:	681b      	ldr	r3, [r3, #0]
 800f81c:	4619      	mov	r1, r3
 800f81e:	f7f1 fb7d 	bl	8000f1c <__aeabi_fdiv>
 800f822:	4603      	mov	r3, r0
 800f824:	461c      	mov	r4, r3
 800f826:	6878      	ldr	r0, [r7, #4]
 800f828:	f7f6 f8d8 	bl	80059dc <gc_get_offset>
 800f82c:	4603      	mov	r3, r0
 800f82e:	4619      	mov	r1, r3
 800f830:	4620      	mov	r0, r4
 800f832:	f7f1 f9b5 	bl	8000ba0 <__aeabi_fsub>
 800f836:	4603      	mov	r3, r0
 800f838:	60fb      	str	r3, [r7, #12]
        if(settings.flags.report_inches)
 800f83a:	4b0c      	ldr	r3, [pc, #48]	; (800f86c <_relative_pos+0x80>)
 800f83c:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 800f840:	f003 0301 	and.w	r3, r3, #1
 800f844:	b2db      	uxtb	r3, r3
 800f846:	2b00      	cmp	r3, #0
 800f848:	d009      	beq.n	800f85e <_relative_pos+0x72>
            value *= 25.4f;
 800f84a:	4909      	ldr	r1, [pc, #36]	; (800f870 <_relative_pos+0x84>)
 800f84c:	68f8      	ldr	r0, [r7, #12]
 800f84e:	f7f1 fab1 	bl	8000db4 <__aeabi_fmul>
 800f852:	4603      	mov	r3, r0
 800f854:	60fb      	str	r3, [r7, #12]
 800f856:	e002      	b.n	800f85e <_relative_pos+0x72>
    } else
        value = 0.0f;
 800f858:	f04f 0300 	mov.w	r3, #0
 800f85c:	60fb      	str	r3, [r7, #12]

    return value;
 800f85e:	68fb      	ldr	r3, [r7, #12]
}
 800f860:	4618      	mov	r0, r3
 800f862:	3714      	adds	r7, #20
 800f864:	46bd      	mov	sp, r7
 800f866:	bd90      	pop	{r4, r7, pc}
 800f868:	20000d3c 	.word	0x20000d3c
 800f86c:	2000147c 	.word	0x2000147c
 800f870:	41cb3333 	.word	0x41cb3333

0800f874 <probe_coord>:

// numbered parameters

static float probe_coord (ngc_param_id_t id)
{
 800f874:	b580      	push	{r7, lr}
 800f876:	b088      	sub	sp, #32
 800f878:	af00      	add	r7, sp, #0
 800f87a:	4603      	mov	r3, r0
 800f87c:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 800f87e:	f04f 0300 	mov.w	r3, #0
 800f882:	61fb      	str	r3, [r7, #28]
    uint_fast8_t axis = (id % 10) - 1;
 800f884:	88fa      	ldrh	r2, [r7, #6]
 800f886:	4b31      	ldr	r3, [pc, #196]	; (800f94c <probe_coord+0xd8>)
 800f888:	fba3 1302 	umull	r1, r3, r3, r2
 800f88c:	08d9      	lsrs	r1, r3, #3
 800f88e:	460b      	mov	r3, r1
 800f890:	009b      	lsls	r3, r3, #2
 800f892:	440b      	add	r3, r1
 800f894:	005b      	lsls	r3, r3, #1
 800f896:	1ad3      	subs	r3, r2, r3
 800f898:	b29b      	uxth	r3, r3
 800f89a:	3b01      	subs	r3, #1
 800f89c:	61bb      	str	r3, [r7, #24]
    coord_system_t data;

    if(axis < N_AXIS && (sys.probe_coordsys_id == gc_state.modal.coord_system.id || settings_read_coord_data(sys.probe_coordsys_id, &data.xyz))) {
 800f89e:	69bb      	ldr	r3, [r7, #24]
 800f8a0:	2b02      	cmp	r3, #2
 800f8a2:	d84e      	bhi.n	800f942 <probe_coord+0xce>
 800f8a4:	4b2a      	ldr	r3, [pc, #168]	; (800f950 <probe_coord+0xdc>)
 800f8a6:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 800f8aa:	4b2a      	ldr	r3, [pc, #168]	; (800f954 <probe_coord+0xe0>)
 800f8ac:	7d1b      	ldrb	r3, [r3, #20]
 800f8ae:	429a      	cmp	r2, r3
 800f8b0:	d00b      	beq.n	800f8ca <probe_coord+0x56>
 800f8b2:	4b27      	ldr	r3, [pc, #156]	; (800f950 <probe_coord+0xdc>)
 800f8b4:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800f8b8:	f107 0208 	add.w	r2, r7, #8
 800f8bc:	4611      	mov	r1, r2
 800f8be:	4618      	mov	r0, r3
 800f8c0:	f00b f9aa 	bl	801ac18 <settings_read_coord_data>
 800f8c4:	4603      	mov	r3, r0
 800f8c6:	2b00      	cmp	r3, #0
 800f8c8:	d03b      	beq.n	800f942 <probe_coord+0xce>
        value = sys.probe_position[axis] / settings.axis[axis].steps_per_mm -
 800f8ca:	4a21      	ldr	r2, [pc, #132]	; (800f950 <probe_coord+0xdc>)
 800f8cc:	69bb      	ldr	r3, [r7, #24]
 800f8ce:	330e      	adds	r3, #14
 800f8d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f8d4:	4618      	mov	r0, r3
 800f8d6:	f7f1 fa19 	bl	8000d0c <__aeabi_i2f>
 800f8da:	491f      	ldr	r1, [pc, #124]	; (800f958 <probe_coord+0xe4>)
 800f8dc:	69ba      	ldr	r2, [r7, #24]
 800f8de:	4613      	mov	r3, r2
 800f8e0:	009b      	lsls	r3, r3, #2
 800f8e2:	4413      	add	r3, r2
 800f8e4:	009b      	lsls	r3, r3, #2
 800f8e6:	440b      	add	r3, r1
 800f8e8:	3330      	adds	r3, #48	; 0x30
 800f8ea:	681b      	ldr	r3, [r3, #0]
 800f8ec:	4619      	mov	r1, r3
 800f8ee:	f7f1 fb15 	bl	8000f1c <__aeabi_fdiv>
 800f8f2:	4603      	mov	r3, r0
 800f8f4:	4618      	mov	r0, r3
                 (sys.probe_coordsys_id == gc_state.modal.coord_system.id ? gc_state.modal.coord_system.xyz[axis] : data.xyz[axis]);
 800f8f6:	4b16      	ldr	r3, [pc, #88]	; (800f950 <probe_coord+0xdc>)
 800f8f8:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 800f8fc:	4b15      	ldr	r3, [pc, #84]	; (800f954 <probe_coord+0xe0>)
 800f8fe:	7d1b      	ldrb	r3, [r3, #20]
 800f900:	429a      	cmp	r2, r3
 800f902:	d105      	bne.n	800f910 <probe_coord+0x9c>
 800f904:	4a13      	ldr	r2, [pc, #76]	; (800f954 <probe_coord+0xe0>)
 800f906:	69bb      	ldr	r3, [r7, #24]
 800f908:	3302      	adds	r3, #2
 800f90a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f90e:	e005      	b.n	800f91c <probe_coord+0xa8>
 800f910:	69bb      	ldr	r3, [r7, #24]
 800f912:	009b      	lsls	r3, r3, #2
 800f914:	3320      	adds	r3, #32
 800f916:	443b      	add	r3, r7
 800f918:	f853 3c18 	ldr.w	r3, [r3, #-24]
        value = sys.probe_position[axis] / settings.axis[axis].steps_per_mm -
 800f91c:	4619      	mov	r1, r3
 800f91e:	f7f1 f93f 	bl	8000ba0 <__aeabi_fsub>
 800f922:	4603      	mov	r3, r0
 800f924:	61fb      	str	r3, [r7, #28]
        if(settings.flags.report_inches)
 800f926:	4b0c      	ldr	r3, [pc, #48]	; (800f958 <probe_coord+0xe4>)
 800f928:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 800f92c:	f003 0301 	and.w	r3, r3, #1
 800f930:	b2db      	uxtb	r3, r3
 800f932:	2b00      	cmp	r3, #0
 800f934:	d005      	beq.n	800f942 <probe_coord+0xce>
            value *= 25.4f;
 800f936:	4909      	ldr	r1, [pc, #36]	; (800f95c <probe_coord+0xe8>)
 800f938:	69f8      	ldr	r0, [r7, #28]
 800f93a:	f7f1 fa3b 	bl	8000db4 <__aeabi_fmul>
 800f93e:	4603      	mov	r3, r0
 800f940:	61fb      	str	r3, [r7, #28]
    }

    return value;
 800f942:	69fb      	ldr	r3, [r7, #28]
}
 800f944:	4618      	mov	r0, r3
 800f946:	3720      	adds	r7, #32
 800f948:	46bd      	mov	sp, r7
 800f94a:	bd80      	pop	{r7, pc}
 800f94c:	cccccccd 	.word	0xcccccccd
 800f950:	20000d3c 	.word	0x20000d3c
 800f954:	20000bb0 	.word	0x20000bb0
 800f958:	2000147c 	.word	0x2000147c
 800f95c:	41cb3333 	.word	0x41cb3333

0800f960 <scaling_factors>:

static float scaling_factors (ngc_param_id_t id)
{
 800f960:	b580      	push	{r7, lr}
 800f962:	b084      	sub	sp, #16
 800f964:	af00      	add	r7, sp, #0
 800f966:	4603      	mov	r3, r0
 800f968:	80fb      	strh	r3, [r7, #6]
    float *factors = gc_get_scaling();
 800f96a:	f7f6 f801 	bl	8005970 <gc_get_scaling>
 800f96e:	60f8      	str	r0, [r7, #12]
    uint_fast8_t axis = id % 10;
 800f970:	88fa      	ldrh	r2, [r7, #6]
 800f972:	4b0e      	ldr	r3, [pc, #56]	; (800f9ac <scaling_factors+0x4c>)
 800f974:	fba3 1302 	umull	r1, r3, r3, r2
 800f978:	08d9      	lsrs	r1, r3, #3
 800f97a:	460b      	mov	r3, r1
 800f97c:	009b      	lsls	r3, r3, #2
 800f97e:	440b      	add	r3, r1
 800f980:	005b      	lsls	r3, r3, #1
 800f982:	1ad3      	subs	r3, r2, r3
 800f984:	b29b      	uxth	r3, r3
 800f986:	60bb      	str	r3, [r7, #8]

    return axis <= N_AXIS ? factors[axis - 1] : 0.0f;
 800f988:	68bb      	ldr	r3, [r7, #8]
 800f98a:	2b03      	cmp	r3, #3
 800f98c:	d808      	bhi.n	800f9a0 <scaling_factors+0x40>
 800f98e:	68bb      	ldr	r3, [r7, #8]
 800f990:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f994:	3b01      	subs	r3, #1
 800f996:	009b      	lsls	r3, r3, #2
 800f998:	68fa      	ldr	r2, [r7, #12]
 800f99a:	4413      	add	r3, r2
 800f99c:	681b      	ldr	r3, [r3, #0]
 800f99e:	e001      	b.n	800f9a4 <scaling_factors+0x44>
 800f9a0:	f04f 0300 	mov.w	r3, #0
}
 800f9a4:	4618      	mov	r0, r3
 800f9a6:	3710      	adds	r7, #16
 800f9a8:	46bd      	mov	sp, r7
 800f9aa:	bd80      	pop	{r7, pc}
 800f9ac:	cccccccd 	.word	0xcccccccd

0800f9b0 <probe_result>:

static float probe_result (ngc_param_id_t id)
{
 800f9b0:	b480      	push	{r7}
 800f9b2:	b083      	sub	sp, #12
 800f9b4:	af00      	add	r7, sp, #0
 800f9b6:	4603      	mov	r3, r0
 800f9b8:	80fb      	strh	r3, [r7, #6]
    return sys.flags.probe_succeeded ? 1.0f : 0.0f;
 800f9ba:	4b08      	ldr	r3, [pc, #32]	; (800f9dc <probe_result+0x2c>)
 800f9bc:	7d9b      	ldrb	r3, [r3, #22]
 800f9be:	f003 0302 	and.w	r3, r3, #2
 800f9c2:	b2db      	uxtb	r3, r3
 800f9c4:	2b00      	cmp	r3, #0
 800f9c6:	d002      	beq.n	800f9ce <probe_result+0x1e>
 800f9c8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800f9cc:	e001      	b.n	800f9d2 <probe_result+0x22>
 800f9ce:	f04f 0300 	mov.w	r3, #0
}
 800f9d2:	4618      	mov	r0, r3
 800f9d4:	370c      	adds	r7, #12
 800f9d6:	46bd      	mov	sp, r7
 800f9d8:	bc80      	pop	{r7}
 800f9da:	4770      	bx	lr
 800f9dc:	20000d3c 	.word	0x20000d3c

0800f9e0 <m66_result>:

    return axis <= N_AXIS ? sys.home_position[axis - 1] : 0.0f;
}
*/
static float m66_result (ngc_param_id_t id)
{
 800f9e0:	b580      	push	{r7, lr}
 800f9e2:	b082      	sub	sp, #8
 800f9e4:	af00      	add	r7, sp, #0
 800f9e6:	4603      	mov	r3, r0
 800f9e8:	80fb      	strh	r3, [r7, #6]
    return (float)sys.var5399;
 800f9ea:	4b05      	ldr	r3, [pc, #20]	; (800fa00 <m66_result+0x20>)
 800f9ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800f9ee:	4618      	mov	r0, r3
 800f9f0:	f7f1 f98c 	bl	8000d0c <__aeabi_i2f>
 800f9f4:	4603      	mov	r3, r0
}
 800f9f6:	4618      	mov	r0, r3
 800f9f8:	3708      	adds	r7, #8
 800f9fa:	46bd      	mov	sp, r7
 800f9fc:	bd80      	pop	{r7, pc}
 800f9fe:	bf00      	nop
 800fa00:	20000d3c 	.word	0x20000d3c

0800fa04 <tool_number>:

static float tool_number (ngc_param_id_t id)
{
 800fa04:	b580      	push	{r7, lr}
 800fa06:	b082      	sub	sp, #8
 800fa08:	af00      	add	r7, sp, #0
 800fa0a:	4603      	mov	r3, r0
 800fa0c:	80fb      	strh	r3, [r7, #6]
    return (float)gc_state.tool->tool_id;
 800fa0e:	4b06      	ldr	r3, [pc, #24]	; (800fa28 <tool_number+0x24>)
 800fa10:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fa14:	691b      	ldr	r3, [r3, #16]
 800fa16:	4618      	mov	r0, r3
 800fa18:	f7f1 f974 	bl	8000d04 <__aeabi_ui2f>
 800fa1c:	4603      	mov	r3, r0
}
 800fa1e:	4618      	mov	r0, r3
 800fa20:	3708      	adds	r7, #8
 800fa22:	46bd      	mov	sp, r7
 800fa24:	bd80      	pop	{r7, pc}
 800fa26:	bf00      	nop
 800fa28:	20000bb0 	.word	0x20000bb0

0800fa2c <tool_offset>:

static float tool_offset (ngc_param_id_t id)
{
 800fa2c:	b480      	push	{r7}
 800fa2e:	b085      	sub	sp, #20
 800fa30:	af00      	add	r7, sp, #0
 800fa32:	4603      	mov	r3, r0
 800fa34:	80fb      	strh	r3, [r7, #6]
    uint_fast8_t axis = id % 10;
 800fa36:	88fa      	ldrh	r2, [r7, #6]
 800fa38:	4b0d      	ldr	r3, [pc, #52]	; (800fa70 <tool_offset+0x44>)
 800fa3a:	fba3 1302 	umull	r1, r3, r3, r2
 800fa3e:	08d9      	lsrs	r1, r3, #3
 800fa40:	460b      	mov	r3, r1
 800fa42:	009b      	lsls	r3, r3, #2
 800fa44:	440b      	add	r3, r1
 800fa46:	005b      	lsls	r3, r3, #1
 800fa48:	1ad3      	subs	r3, r2, r3
 800fa4a:	b29b      	uxth	r3, r3
 800fa4c:	60fb      	str	r3, [r7, #12]

    return axis <= N_AXIS ? gc_state.tool_length_offset[axis] : 0.0f;
 800fa4e:	68fb      	ldr	r3, [r7, #12]
 800fa50:	2b03      	cmp	r3, #3
 800fa52:	d806      	bhi.n	800fa62 <tool_offset+0x36>
 800fa54:	4a07      	ldr	r2, [pc, #28]	; (800fa74 <tool_offset+0x48>)
 800fa56:	68fb      	ldr	r3, [r7, #12]
 800fa58:	3320      	adds	r3, #32
 800fa5a:	009b      	lsls	r3, r3, #2
 800fa5c:	4413      	add	r3, r2
 800fa5e:	685b      	ldr	r3, [r3, #4]
 800fa60:	e001      	b.n	800fa66 <tool_offset+0x3a>
 800fa62:	f04f 0300 	mov.w	r3, #0
}
 800fa66:	4618      	mov	r0, r3
 800fa68:	3714      	adds	r7, #20
 800fa6a:	46bd      	mov	sp, r7
 800fa6c:	bc80      	pop	{r7}
 800fa6e:	4770      	bx	lr
 800fa70:	cccccccd 	.word	0xcccccccd
 800fa74:	20000bb0 	.word	0x20000bb0

0800fa78 <g28_home>:

static float g28_home (ngc_param_id_t id)
{
 800fa78:	b580      	push	{r7, lr}
 800fa7a:	b088      	sub	sp, #32
 800fa7c:	af00      	add	r7, sp, #0
 800fa7e:	4603      	mov	r3, r0
 800fa80:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 800fa82:	f04f 0300 	mov.w	r3, #0
 800fa86:	61fb      	str	r3, [r7, #28]
    uint_fast8_t axis = id % 10;
 800fa88:	88fa      	ldrh	r2, [r7, #6]
 800fa8a:	4b12      	ldr	r3, [pc, #72]	; (800fad4 <g28_home+0x5c>)
 800fa8c:	fba3 1302 	umull	r1, r3, r3, r2
 800fa90:	08d9      	lsrs	r1, r3, #3
 800fa92:	460b      	mov	r3, r1
 800fa94:	009b      	lsls	r3, r3, #2
 800fa96:	440b      	add	r3, r1
 800fa98:	005b      	lsls	r3, r3, #1
 800fa9a:	1ad3      	subs	r3, r2, r3
 800fa9c:	b29b      	uxth	r3, r3
 800fa9e:	61bb      	str	r3, [r7, #24]
    coord_system_t data;

    if(axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G28, &data.xyz))
 800faa0:	69bb      	ldr	r3, [r7, #24]
 800faa2:	2b03      	cmp	r3, #3
 800faa4:	d810      	bhi.n	800fac8 <g28_home+0x50>
 800faa6:	f107 0308 	add.w	r3, r7, #8
 800faaa:	4619      	mov	r1, r3
 800faac:	2009      	movs	r0, #9
 800faae:	f00b f8b3 	bl	801ac18 <settings_read_coord_data>
 800fab2:	4603      	mov	r3, r0
 800fab4:	2b00      	cmp	r3, #0
 800fab6:	d007      	beq.n	800fac8 <g28_home+0x50>
        value = data.xyz[axis - 1];
 800fab8:	69bb      	ldr	r3, [r7, #24]
 800faba:	3b01      	subs	r3, #1
 800fabc:	009b      	lsls	r3, r3, #2
 800fabe:	3320      	adds	r3, #32
 800fac0:	443b      	add	r3, r7
 800fac2:	f853 3c18 	ldr.w	r3, [r3, #-24]
 800fac6:	61fb      	str	r3, [r7, #28]

    return value;
 800fac8:	69fb      	ldr	r3, [r7, #28]
}
 800faca:	4618      	mov	r0, r3
 800facc:	3720      	adds	r7, #32
 800face:	46bd      	mov	sp, r7
 800fad0:	bd80      	pop	{r7, pc}
 800fad2:	bf00      	nop
 800fad4:	cccccccd 	.word	0xcccccccd

0800fad8 <g30_home>:

static float g30_home (ngc_param_id_t id)
{
 800fad8:	b580      	push	{r7, lr}
 800fada:	b088      	sub	sp, #32
 800fadc:	af00      	add	r7, sp, #0
 800fade:	4603      	mov	r3, r0
 800fae0:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 800fae2:	f04f 0300 	mov.w	r3, #0
 800fae6:	61fb      	str	r3, [r7, #28]
    uint_fast8_t axis = id % 10;
 800fae8:	88fa      	ldrh	r2, [r7, #6]
 800faea:	4b12      	ldr	r3, [pc, #72]	; (800fb34 <g30_home+0x5c>)
 800faec:	fba3 1302 	umull	r1, r3, r3, r2
 800faf0:	08d9      	lsrs	r1, r3, #3
 800faf2:	460b      	mov	r3, r1
 800faf4:	009b      	lsls	r3, r3, #2
 800faf6:	440b      	add	r3, r1
 800faf8:	005b      	lsls	r3, r3, #1
 800fafa:	1ad3      	subs	r3, r2, r3
 800fafc:	b29b      	uxth	r3, r3
 800fafe:	61bb      	str	r3, [r7, #24]
    coord_system_t data;

#if COMPATIBILITY_LEVEL > 1
    if(id <= CoordinateSystem_G59) {
#endif
    if (axis <= N_AXIS && settings_read_coord_data(CoordinateSystem_G30, &data.xyz))
 800fb00:	69bb      	ldr	r3, [r7, #24]
 800fb02:	2b03      	cmp	r3, #3
 800fb04:	d810      	bhi.n	800fb28 <g30_home+0x50>
 800fb06:	f107 0308 	add.w	r3, r7, #8
 800fb0a:	4619      	mov	r1, r3
 800fb0c:	200a      	movs	r0, #10
 800fb0e:	f00b f883 	bl	801ac18 <settings_read_coord_data>
 800fb12:	4603      	mov	r3, r0
 800fb14:	2b00      	cmp	r3, #0
 800fb16:	d007      	beq.n	800fb28 <g30_home+0x50>
        value = data.xyz[axis - 1];
 800fb18:	69bb      	ldr	r3, [r7, #24]
 800fb1a:	3b01      	subs	r3, #1
 800fb1c:	009b      	lsls	r3, r3, #2
 800fb1e:	3320      	adds	r3, #32
 800fb20:	443b      	add	r3, r7
 800fb22:	f853 3c18 	ldr.w	r3, [r3, #-24]
 800fb26:	61fb      	str	r3, [r7, #28]
#if COMPATIBILITY_LEVEL > 1
    }
#endif

    return value;
 800fb28:	69fb      	ldr	r3, [r7, #28]
}
 800fb2a:	4618      	mov	r0, r3
 800fb2c:	3720      	adds	r7, #32
 800fb2e:	46bd      	mov	sp, r7
 800fb30:	bd80      	pop	{r7, pc}
 800fb32:	bf00      	nop
 800fb34:	cccccccd 	.word	0xcccccccd

0800fb38 <coord_system>:

static float coord_system (ngc_param_id_t id)
{
 800fb38:	b580      	push	{r7, lr}
 800fb3a:	b082      	sub	sp, #8
 800fb3c:	af00      	add	r7, sp, #0
 800fb3e:	4603      	mov	r3, r0
 800fb40:	80fb      	strh	r3, [r7, #6]
    return (float)gc_state.modal.coord_system.id + 1;
 800fb42:	4b08      	ldr	r3, [pc, #32]	; (800fb64 <coord_system+0x2c>)
 800fb44:	7d1b      	ldrb	r3, [r3, #20]
 800fb46:	4618      	mov	r0, r3
 800fb48:	f7f1 f8dc 	bl	8000d04 <__aeabi_ui2f>
 800fb4c:	4603      	mov	r3, r0
 800fb4e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800fb52:	4618      	mov	r0, r3
 800fb54:	f7f1 f826 	bl	8000ba4 <__addsf3>
 800fb58:	4603      	mov	r3, r0
}
 800fb5a:	4618      	mov	r0, r3
 800fb5c:	3708      	adds	r7, #8
 800fb5e:	46bd      	mov	sp, r7
 800fb60:	bd80      	pop	{r7, pc}
 800fb62:	bf00      	nop
 800fb64:	20000bb0 	.word	0x20000bb0

0800fb68 <coord_system_offset>:

static float coord_system_offset (ngc_param_id_t id)
{
 800fb68:	b580      	push	{r7, lr}
 800fb6a:	b088      	sub	sp, #32
 800fb6c:	af00      	add	r7, sp, #0
 800fb6e:	4603      	mov	r3, r0
 800fb70:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 800fb72:	f04f 0300 	mov.w	r3, #0
 800fb76:	61fb      	str	r3, [r7, #28]
    uint_fast8_t axis = id % 10;
 800fb78:	88fa      	ldrh	r2, [r7, #6]
 800fb7a:	4b1d      	ldr	r3, [pc, #116]	; (800fbf0 <coord_system_offset+0x88>)
 800fb7c:	fba3 1302 	umull	r1, r3, r3, r2
 800fb80:	08d9      	lsrs	r1, r3, #3
 800fb82:	460b      	mov	r3, r1
 800fb84:	009b      	lsls	r3, r3, #2
 800fb86:	440b      	add	r3, r1
 800fb88:	005b      	lsls	r3, r3, #1
 800fb8a:	1ad3      	subs	r3, r2, r3
 800fb8c:	b29b      	uxth	r3, r3
 800fb8e:	61bb      	str	r3, [r7, #24]
    coord_system_t data;

    id = (id - 5220 - axis - (id == 0 ? 10 : 0)) / 20;
 800fb90:	88fa      	ldrh	r2, [r7, #6]
 800fb92:	69bb      	ldr	r3, [r7, #24]
 800fb94:	1ad2      	subs	r2, r2, r3
 800fb96:	88fb      	ldrh	r3, [r7, #6]
 800fb98:	2b00      	cmp	r3, #0
 800fb9a:	d101      	bne.n	800fba0 <coord_system_offset+0x38>
 800fb9c:	230a      	movs	r3, #10
 800fb9e:	e000      	b.n	800fba2 <coord_system_offset+0x3a>
 800fba0:	2300      	movs	r3, #0
 800fba2:	1ad3      	subs	r3, r2, r3
 800fba4:	f5a3 53a3 	sub.w	r3, r3, #5216	; 0x1460
 800fba8:	3b04      	subs	r3, #4
 800fbaa:	4a11      	ldr	r2, [pc, #68]	; (800fbf0 <coord_system_offset+0x88>)
 800fbac:	fba2 2303 	umull	r2, r3, r2, r3
 800fbb0:	091b      	lsrs	r3, r3, #4
 800fbb2:	80fb      	strh	r3, [r7, #6]

    if (axis > 0 && axis <= N_AXIS && settings_read_coord_data((coord_system_id_t)id, &data.xyz))
 800fbb4:	69bb      	ldr	r3, [r7, #24]
 800fbb6:	2b00      	cmp	r3, #0
 800fbb8:	d015      	beq.n	800fbe6 <coord_system_offset+0x7e>
 800fbba:	69bb      	ldr	r3, [r7, #24]
 800fbbc:	2b03      	cmp	r3, #3
 800fbbe:	d812      	bhi.n	800fbe6 <coord_system_offset+0x7e>
 800fbc0:	88fb      	ldrh	r3, [r7, #6]
 800fbc2:	b2db      	uxtb	r3, r3
 800fbc4:	f107 0208 	add.w	r2, r7, #8
 800fbc8:	4611      	mov	r1, r2
 800fbca:	4618      	mov	r0, r3
 800fbcc:	f00b f824 	bl	801ac18 <settings_read_coord_data>
 800fbd0:	4603      	mov	r3, r0
 800fbd2:	2b00      	cmp	r3, #0
 800fbd4:	d007      	beq.n	800fbe6 <coord_system_offset+0x7e>
        value = data.xyz[axis - 1];
 800fbd6:	69bb      	ldr	r3, [r7, #24]
 800fbd8:	3b01      	subs	r3, #1
 800fbda:	009b      	lsls	r3, r3, #2
 800fbdc:	3320      	adds	r3, #32
 800fbde:	443b      	add	r3, r7
 800fbe0:	f853 3c18 	ldr.w	r3, [r3, #-24]
 800fbe4:	61fb      	str	r3, [r7, #28]

    return value;
 800fbe6:	69fb      	ldr	r3, [r7, #28]
}
 800fbe8:	4618      	mov	r0, r3
 800fbea:	3720      	adds	r7, #32
 800fbec:	46bd      	mov	sp, r7
 800fbee:	bd80      	pop	{r7, pc}
 800fbf0:	cccccccd 	.word	0xcccccccd

0800fbf4 <g92_offset_applied>:

static float g92_offset_applied (ngc_param_id_t id)
{
 800fbf4:	b580      	push	{r7, lr}
 800fbf6:	b082      	sub	sp, #8
 800fbf8:	af00      	add	r7, sp, #0
 800fbfa:	4603      	mov	r3, r0
 800fbfc:	80fb      	strh	r3, [r7, #6]
    return (float)gc_state.g92_coord_offset_applied;
 800fbfe:	4b05      	ldr	r3, [pc, #20]	; (800fc14 <g92_offset_applied+0x20>)
 800fc00:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
 800fc04:	4618      	mov	r0, r3
 800fc06:	f7f1 f87d 	bl	8000d04 <__aeabi_ui2f>
 800fc0a:	4603      	mov	r3, r0
}
 800fc0c:	4618      	mov	r0, r3
 800fc0e:	3708      	adds	r7, #8
 800fc10:	46bd      	mov	sp, r7
 800fc12:	bd80      	pop	{r7, pc}
 800fc14:	20000bb0 	.word	0x20000bb0

0800fc18 <g92_offset>:

static float g92_offset (ngc_param_id_t id)
{
 800fc18:	b480      	push	{r7}
 800fc1a:	b085      	sub	sp, #20
 800fc1c:	af00      	add	r7, sp, #0
 800fc1e:	4603      	mov	r3, r0
 800fc20:	80fb      	strh	r3, [r7, #6]
    uint_fast8_t axis = id % 10;
 800fc22:	88fa      	ldrh	r2, [r7, #6]
 800fc24:	4b0d      	ldr	r3, [pc, #52]	; (800fc5c <g92_offset+0x44>)
 800fc26:	fba3 1302 	umull	r1, r3, r3, r2
 800fc2a:	08d9      	lsrs	r1, r3, #3
 800fc2c:	460b      	mov	r3, r1
 800fc2e:	009b      	lsls	r3, r3, #2
 800fc30:	440b      	add	r3, r1
 800fc32:	005b      	lsls	r3, r3, #1
 800fc34:	1ad3      	subs	r3, r2, r3
 800fc36:	b29b      	uxth	r3, r3
 800fc38:	60fb      	str	r3, [r7, #12]

    return axis <= N_AXIS ? gc_state.g92_coord_offset [axis - 1] : 0.0f;
 800fc3a:	68fb      	ldr	r3, [r7, #12]
 800fc3c:	2b03      	cmp	r3, #3
 800fc3e:	d806      	bhi.n	800fc4e <g92_offset+0x36>
 800fc40:	68fb      	ldr	r3, [r7, #12]
 800fc42:	3b01      	subs	r3, #1
 800fc44:	4a06      	ldr	r2, [pc, #24]	; (800fc60 <g92_offset+0x48>)
 800fc46:	331e      	adds	r3, #30
 800fc48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800fc4c:	e001      	b.n	800fc52 <g92_offset+0x3a>
 800fc4e:	f04f 0300 	mov.w	r3, #0
}
 800fc52:	4618      	mov	r0, r3
 800fc54:	3714      	adds	r7, #20
 800fc56:	46bd      	mov	sp, r7
 800fc58:	bc80      	pop	{r7}
 800fc5a:	4770      	bx	lr
 800fc5c:	cccccccd 	.word	0xcccccccd
 800fc60:	20000bb0 	.word	0x20000bb0

0800fc64 <work_position>:

static float work_position (ngc_param_id_t id)
{
 800fc64:	b580      	push	{r7, lr}
 800fc66:	b084      	sub	sp, #16
 800fc68:	af00      	add	r7, sp, #0
 800fc6a:	4603      	mov	r3, r0
 800fc6c:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 800fc6e:	f04f 0300 	mov.w	r3, #0
 800fc72:	60fb      	str	r3, [r7, #12]
    uint_fast8_t axis = id % 10;
 800fc74:	88fa      	ldrh	r2, [r7, #6]
 800fc76:	4b0b      	ldr	r3, [pc, #44]	; (800fca4 <work_position+0x40>)
 800fc78:	fba3 1302 	umull	r1, r3, r3, r2
 800fc7c:	08d9      	lsrs	r1, r3, #3
 800fc7e:	460b      	mov	r3, r1
 800fc80:	009b      	lsls	r3, r3, #2
 800fc82:	440b      	add	r3, r1
 800fc84:	005b      	lsls	r3, r3, #1
 800fc86:	1ad3      	subs	r3, r2, r3
 800fc88:	b29b      	uxth	r3, r3
 800fc8a:	60bb      	str	r3, [r7, #8]

    if(axis < N_AXIS)
 800fc8c:	68bb      	ldr	r3, [r7, #8]
 800fc8e:	2b02      	cmp	r3, #2
 800fc90:	d803      	bhi.n	800fc9a <work_position+0x36>
        value = _relative_pos(axis);
 800fc92:	68b8      	ldr	r0, [r7, #8]
 800fc94:	f7ff fdaa 	bl	800f7ec <_relative_pos>
 800fc98:	60f8      	str	r0, [r7, #12]

    return value;
 800fc9a:	68fb      	ldr	r3, [r7, #12]
}
 800fc9c:	4618      	mov	r0, r3
 800fc9e:	3710      	adds	r7, #16
 800fca0:	46bd      	mov	sp, r7
 800fca2:	bd80      	pop	{r7, pc}
 800fca4:	cccccccd 	.word	0xcccccccd

0800fca8 <ngc_param_get>:
    { .id_min = 5401, .id_max = 5409, .get = tool_offset },        // LinuxCNC
    { .id_min = 5420, .id_max = 5428, .get = work_position }       // LinuxCNC
};

bool ngc_param_get (ngc_param_id_t id, float *value)
{
 800fca8:	b580      	push	{r7, lr}
 800fcaa:	b086      	sub	sp, #24
 800fcac:	af00      	add	r7, sp, #0
 800fcae:	4603      	mov	r3, r0
 800fcb0:	6039      	str	r1, [r7, #0]
 800fcb2:	80fb      	strh	r3, [r7, #6]
    bool found = id > 0 && id < ngc_ro_params[0].id_min;
 800fcb4:	88fb      	ldrh	r3, [r7, #6]
 800fcb6:	2b00      	cmp	r3, #0
 800fcb8:	d006      	beq.n	800fcc8 <ngc_param_get+0x20>
 800fcba:	f241 32c5 	movw	r2, #5061	; 0x13c5
 800fcbe:	88fb      	ldrh	r3, [r7, #6]
 800fcc0:	4293      	cmp	r3, r2
 800fcc2:	d201      	bcs.n	800fcc8 <ngc_param_get+0x20>
 800fcc4:	2301      	movs	r3, #1
 800fcc6:	e000      	b.n	800fcca <ngc_param_get+0x22>
 800fcc8:	2300      	movs	r3, #0
 800fcca:	75fb      	strb	r3, [r7, #23]
 800fccc:	7dfb      	ldrb	r3, [r7, #23]
 800fcce:	f003 0301 	and.w	r3, r3, #1
 800fcd2:	75fb      	strb	r3, [r7, #23]
    uint_fast8_t idx = sizeof(ngc_ro_params) / sizeof(ngc_ro_param_t);
 800fcd4:	2315      	movs	r3, #21
 800fcd6:	613b      	str	r3, [r7, #16]

    *value = 0.0f;
 800fcd8:	683b      	ldr	r3, [r7, #0]
 800fcda:	f04f 0200 	mov.w	r2, #0
 800fcde:	601a      	str	r2, [r3, #0]

    if(found) {
 800fce0:	7dfb      	ldrb	r3, [r7, #23]
 800fce2:	2b00      	cmp	r3, #0
 800fce4:	d016      	beq.n	800fd14 <ngc_param_get+0x6c>
        ngc_rw_param_t *rw_param = rw_params;
 800fce6:	4b26      	ldr	r3, [pc, #152]	; (800fd80 <ngc_param_get+0xd8>)
 800fce8:	681b      	ldr	r3, [r3, #0]
 800fcea:	60fb      	str	r3, [r7, #12]
        while(rw_param) {
 800fcec:	e00e      	b.n	800fd0c <ngc_param_get+0x64>
            if(rw_param->id == id) {
 800fcee:	68fb      	ldr	r3, [r7, #12]
 800fcf0:	881b      	ldrh	r3, [r3, #0]
 800fcf2:	88fa      	ldrh	r2, [r7, #6]
 800fcf4:	429a      	cmp	r2, r3
 800fcf6:	d106      	bne.n	800fd06 <ngc_param_get+0x5e>
                *value = rw_param->value;
 800fcf8:	68fb      	ldr	r3, [r7, #12]
 800fcfa:	685a      	ldr	r2, [r3, #4]
 800fcfc:	683b      	ldr	r3, [r7, #0]
 800fcfe:	601a      	str	r2, [r3, #0]
                rw_param = NULL;
 800fd00:	2300      	movs	r3, #0
 800fd02:	60fb      	str	r3, [r7, #12]
 800fd04:	e002      	b.n	800fd0c <ngc_param_get+0x64>
            } else
                rw_param = rw_param->next;
 800fd06:	68fb      	ldr	r3, [r7, #12]
 800fd08:	689b      	ldr	r3, [r3, #8]
 800fd0a:	60fb      	str	r3, [r7, #12]
        while(rw_param) {
 800fd0c:	68fb      	ldr	r3, [r7, #12]
 800fd0e:	2b00      	cmp	r3, #0
 800fd10:	d1ed      	bne.n	800fcee <ngc_param_get+0x46>
 800fd12:	e030      	b.n	800fd76 <ngc_param_get+0xce>
        }
    } else do {
        idx--;
 800fd14:	693b      	ldr	r3, [r7, #16]
 800fd16:	3b01      	subs	r3, #1
 800fd18:	613b      	str	r3, [r7, #16]
        if((found = id >= ngc_ro_params[idx].id_min && id <= ngc_ro_params[idx].id_max))
 800fd1a:	4a1a      	ldr	r2, [pc, #104]	; (800fd84 <ngc_param_get+0xdc>)
 800fd1c:	693b      	ldr	r3, [r7, #16]
 800fd1e:	f832 3033 	ldrh.w	r3, [r2, r3, lsl #3]
 800fd22:	88fa      	ldrh	r2, [r7, #6]
 800fd24:	429a      	cmp	r2, r3
 800fd26:	d309      	bcc.n	800fd3c <ngc_param_get+0x94>
 800fd28:	4a16      	ldr	r2, [pc, #88]	; (800fd84 <ngc_param_get+0xdc>)
 800fd2a:	693b      	ldr	r3, [r7, #16]
 800fd2c:	00db      	lsls	r3, r3, #3
 800fd2e:	4413      	add	r3, r2
 800fd30:	885b      	ldrh	r3, [r3, #2]
 800fd32:	88fa      	ldrh	r2, [r7, #6]
 800fd34:	429a      	cmp	r2, r3
 800fd36:	d801      	bhi.n	800fd3c <ngc_param_get+0x94>
 800fd38:	2301      	movs	r3, #1
 800fd3a:	e000      	b.n	800fd3e <ngc_param_get+0x96>
 800fd3c:	2300      	movs	r3, #0
 800fd3e:	75fb      	strb	r3, [r7, #23]
 800fd40:	7dfb      	ldrb	r3, [r7, #23]
 800fd42:	f003 0301 	and.w	r3, r3, #1
 800fd46:	75fb      	strb	r3, [r7, #23]
 800fd48:	7dfb      	ldrb	r3, [r7, #23]
 800fd4a:	2b00      	cmp	r3, #0
 800fd4c:	d00a      	beq.n	800fd64 <ngc_param_get+0xbc>
            *value = ngc_ro_params[idx].get(id);
 800fd4e:	4a0d      	ldr	r2, [pc, #52]	; (800fd84 <ngc_param_get+0xdc>)
 800fd50:	693b      	ldr	r3, [r7, #16]
 800fd52:	00db      	lsls	r3, r3, #3
 800fd54:	4413      	add	r3, r2
 800fd56:	685b      	ldr	r3, [r3, #4]
 800fd58:	88fa      	ldrh	r2, [r7, #6]
 800fd5a:	4610      	mov	r0, r2
 800fd5c:	4798      	blx	r3
 800fd5e:	4602      	mov	r2, r0
 800fd60:	683b      	ldr	r3, [r7, #0]
 800fd62:	601a      	str	r2, [r3, #0]
    } while(idx && !found);
 800fd64:	693b      	ldr	r3, [r7, #16]
 800fd66:	2b00      	cmp	r3, #0
 800fd68:	d005      	beq.n	800fd76 <ngc_param_get+0xce>
 800fd6a:	7dfb      	ldrb	r3, [r7, #23]
 800fd6c:	f083 0301 	eor.w	r3, r3, #1
 800fd70:	b2db      	uxtb	r3, r3
 800fd72:	2b00      	cmp	r3, #0
 800fd74:	d1ce      	bne.n	800fd14 <ngc_param_get+0x6c>

    return found;
 800fd76:	7dfb      	ldrb	r3, [r7, #23]
}
 800fd78:	4618      	mov	r0, r3
 800fd7a:	3718      	adds	r7, #24
 800fd7c:	46bd      	mov	sp, r7
 800fd7e:	bd80      	pop	{r7, pc}
 800fd80:	200010ac 	.word	0x200010ac
 800fd84:	08030d3c 	.word	0x08030d3c

0800fd88 <ngc_named_param_get_by_id>:


// Named parameters

float ngc_named_param_get_by_id (ncg_name_param_id_t id)
{
 800fd88:	b580      	push	{r7, lr}
 800fd8a:	b084      	sub	sp, #16
 800fd8c:	af00      	add	r7, sp, #0
 800fd8e:	4603      	mov	r3, r0
 800fd90:	71fb      	strb	r3, [r7, #7]
    float value;

    switch(id) {
 800fd92:	79fb      	ldrb	r3, [r7, #7]
 800fd94:	2b2c      	cmp	r3, #44	; 0x2c
 800fd96:	f200 81e0 	bhi.w	801015a <ngc_named_param_get_by_id+0x3d2>
 800fd9a:	a201      	add	r2, pc, #4	; (adr r2, 800fda0 <ngc_named_param_get_by_id+0x18>)
 800fd9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fda0:	0800fe55 	.word	0x0800fe55
 800fda4:	0800fe5b 	.word	0x0800fe5b
 800fda8:	0800fe63 	.word	0x0800fe63
 800fdac:	0800fe73 	.word	0x0800fe73
 800fdb0:	0800fe8d 	.word	0x0800fe8d
 800fdb4:	0800fea9 	.word	0x0800fea9
 800fdb8:	0800feaf 	.word	0x0800feaf
 800fdbc:	0800fec5 	.word	0x0800fec5
 800fdc0:	0800fedb 	.word	0x0800fedb
 800fdc4:	0800fef1 	.word	0x0800fef1
 800fdc8:	0800ff07 	.word	0x0800ff07
 800fdcc:	0800ff1d 	.word	0x0800ff1d
 800fdd0:	0800ff33 	.word	0x0800ff33
 800fdd4:	0800ff49 	.word	0x0800ff49
 800fdd8:	0800ff79 	.word	0x0800ff79
 800fddc:	0800ff8f 	.word	0x0800ff8f
 800fde0:	0800ffa5 	.word	0x0800ffa5
 800fde4:	0800ffbb 	.word	0x0800ffbb
 800fde8:	0800ffd1 	.word	0x0800ffd1
 800fdec:	0800ffe7 	.word	0x0800ffe7
 800fdf0:	0800ffef 	.word	0x0800ffef
 800fdf4:	08010005 	.word	0x08010005
 800fdf8:	0801001b 	.word	0x0801001b
 800fdfc:	08010037 	.word	0x08010037
 800fe00:	08010053 	.word	0x08010053
 800fe04:	0801006f 	.word	0x0801006f
 800fe08:	0801008b 	.word	0x0801008b
 800fe0c:	080100a7 	.word	0x080100a7
 800fe10:	080100c3 	.word	0x080100c3
 800fe14:	080100d9 	.word	0x080100d9
 800fe18:	080100f5 	.word	0x080100f5
 800fe1c:	080100fd 	.word	0x080100fd
 800fe20:	08010105 	.word	0x08010105
 800fe24:	08010105 	.word	0x08010105
 800fe28:	08010105 	.word	0x08010105
 800fe2c:	08010105 	.word	0x08010105
 800fe30:	08010105 	.word	0x08010105
 800fe34:	08010105 	.word	0x08010105
 800fe38:	08010105 	.word	0x08010105
 800fe3c:	08010105 	.word	0x08010105
 800fe40:	08010105 	.word	0x08010105
 800fe44:	08010113 	.word	0x08010113
 800fe48:	08010127 	.word	0x08010127
 800fe4c:	0801012f 	.word	0x0801012f
 800fe50:	08010153 	.word	0x08010153

        case NGCParam_vmajor:
            value = 1.1f;
 800fe54:	4b9d      	ldr	r3, [pc, #628]	; (80100cc <ngc_named_param_get_by_id+0x344>)
 800fe56:	60fb      	str	r3, [r7, #12]
            break;
 800fe58:	e181      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_vminor:
            value = 0.0f; // TODO: derive from version letter?
 800fe5a:	f04f 0300 	mov.w	r3, #0
 800fe5e:	60fb      	str	r3, [r7, #12]
            break;
 800fe60:	e17d      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_line:
            value = (float)gc_state.line_number;
 800fe62:	4b9b      	ldr	r3, [pc, #620]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fe64:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800fe66:	4618      	mov	r0, r3
 800fe68:	f7f0 ff50 	bl	8000d0c <__aeabi_i2f>
 800fe6c:	4603      	mov	r3, r0
 800fe6e:	60fb      	str	r3, [r7, #12]
            break;
 800fe70:	e175      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_motion_mode:
            value = (float)(gc_state.modal.motion * 10); // TODO: Fix G38.x
 800fe72:	4b97      	ldr	r3, [pc, #604]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fe74:	881b      	ldrh	r3, [r3, #0]
 800fe76:	461a      	mov	r2, r3
 800fe78:	4613      	mov	r3, r2
 800fe7a:	009b      	lsls	r3, r3, #2
 800fe7c:	4413      	add	r3, r2
 800fe7e:	005b      	lsls	r3, r3, #1
 800fe80:	4618      	mov	r0, r3
 800fe82:	f7f0 ff43 	bl	8000d0c <__aeabi_i2f>
 800fe86:	4603      	mov	r3, r0
 800fe88:	60fb      	str	r3, [r7, #12]
            break;
 800fe8a:	e168      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_plane:
            value = (float)(170 + gc_state.modal.plane_select * 10);
 800fe8c:	4b90      	ldr	r3, [pc, #576]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fe8e:	799b      	ldrb	r3, [r3, #6]
 800fe90:	461a      	mov	r2, r3
 800fe92:	4613      	mov	r3, r2
 800fe94:	009b      	lsls	r3, r3, #2
 800fe96:	4413      	add	r3, r2
 800fe98:	005b      	lsls	r3, r3, #1
 800fe9a:	33aa      	adds	r3, #170	; 0xaa
 800fe9c:	4618      	mov	r0, r3
 800fe9e:	f7f0 ff35 	bl	8000d0c <__aeabi_i2f>
 800fea2:	4603      	mov	r3, r0
 800fea4:	60fb      	str	r3, [r7, #12]
            break;
 800fea6:	e15a      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_ccomp:
            value = 400.0f;
 800fea8:	4b8a      	ldr	r3, [pc, #552]	; (80100d4 <ngc_named_param_get_by_id+0x34c>)
 800feaa:	60fb      	str	r3, [r7, #12]
            break;
 800feac:	e157      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_metric:
            value = gc_state.modal.units_imperial ? 0.0f : 1.0f;
 800feae:	4b88      	ldr	r3, [pc, #544]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800feb0:	78db      	ldrb	r3, [r3, #3]
 800feb2:	2b00      	cmp	r3, #0
 800feb4:	d002      	beq.n	800febc <ngc_named_param_get_by_id+0x134>
 800feb6:	f04f 0300 	mov.w	r3, #0
 800feba:	e001      	b.n	800fec0 <ngc_named_param_get_by_id+0x138>
 800febc:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800fec0:	60fb      	str	r3, [r7, #12]
            break;
 800fec2:	e14c      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_imperial:
            value = gc_state.modal.units_imperial ? 1.0f : 0.0f;
 800fec4:	4b82      	ldr	r3, [pc, #520]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fec6:	78db      	ldrb	r3, [r3, #3]
 800fec8:	2b00      	cmp	r3, #0
 800feca:	d002      	beq.n	800fed2 <ngc_named_param_get_by_id+0x14a>
 800fecc:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800fed0:	e001      	b.n	800fed6 <ngc_named_param_get_by_id+0x14e>
 800fed2:	f04f 0300 	mov.w	r3, #0
 800fed6:	60fb      	str	r3, [r7, #12]
            break;
 800fed8:	e141      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_absolute:
            value = gc_state.modal.distance_incremental ? 0.0f : 1.0f;
 800feda:	4b7d      	ldr	r3, [pc, #500]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fedc:	791b      	ldrb	r3, [r3, #4]
 800fede:	2b00      	cmp	r3, #0
 800fee0:	d002      	beq.n	800fee8 <ngc_named_param_get_by_id+0x160>
 800fee2:	f04f 0300 	mov.w	r3, #0
 800fee6:	e001      	b.n	800feec <ngc_named_param_get_by_id+0x164>
 800fee8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800feec:	60fb      	str	r3, [r7, #12]
            break;
 800feee:	e136      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_incremental:
            value = gc_state.modal.distance_incremental ? 1.0f : 0.0f;
 800fef0:	4b77      	ldr	r3, [pc, #476]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fef2:	791b      	ldrb	r3, [r3, #4]
 800fef4:	2b00      	cmp	r3, #0
 800fef6:	d002      	beq.n	800fefe <ngc_named_param_get_by_id+0x176>
 800fef8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800fefc:	e001      	b.n	800ff02 <ngc_named_param_get_by_id+0x17a>
 800fefe:	f04f 0300 	mov.w	r3, #0
 800ff02:	60fb      	str	r3, [r7, #12]
            break;
 800ff04:	e12b      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_inverse_time:
            value = gc_state.modal.feed_mode == FeedMode_InverseTime ? 1.0f : 0.0f;
 800ff06:	4b72      	ldr	r3, [pc, #456]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff08:	789b      	ldrb	r3, [r3, #2]
 800ff0a:	2b01      	cmp	r3, #1
 800ff0c:	d102      	bne.n	800ff14 <ngc_named_param_get_by_id+0x18c>
 800ff0e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ff12:	e001      	b.n	800ff18 <ngc_named_param_get_by_id+0x190>
 800ff14:	f04f 0300 	mov.w	r3, #0
 800ff18:	60fb      	str	r3, [r7, #12]
            break;
 800ff1a:	e120      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_units_per_minute:
            value = gc_state.modal.feed_mode == FeedMode_UnitsPerMin ? 1.0f : 0.0f;
 800ff1c:	4b6c      	ldr	r3, [pc, #432]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff1e:	789b      	ldrb	r3, [r3, #2]
 800ff20:	2b00      	cmp	r3, #0
 800ff22:	d102      	bne.n	800ff2a <ngc_named_param_get_by_id+0x1a2>
 800ff24:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ff28:	e001      	b.n	800ff2e <ngc_named_param_get_by_id+0x1a6>
 800ff2a:	f04f 0300 	mov.w	r3, #0
 800ff2e:	60fb      	str	r3, [r7, #12]
            break;
 800ff30:	e115      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_units_per_rev:
            value = gc_state.modal.feed_mode == FeedMode_UnitsPerRev ? 1.0f : 0.0f;
 800ff32:	4b67      	ldr	r3, [pc, #412]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff34:	789b      	ldrb	r3, [r3, #2]
 800ff36:	2b02      	cmp	r3, #2
 800ff38:	d102      	bne.n	800ff40 <ngc_named_param_get_by_id+0x1b8>
 800ff3a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ff3e:	e001      	b.n	800ff44 <ngc_named_param_get_by_id+0x1bc>
 800ff40:	f04f 0300 	mov.w	r3, #0
 800ff44:	60fb      	str	r3, [r7, #12]
            break;
 800ff46:	e10a      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_coord_system:
            {
                uint_fast16_t id = gc_state.modal.coord_system.id * 10;
 800ff48:	4b61      	ldr	r3, [pc, #388]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff4a:	7d1b      	ldrb	r3, [r3, #20]
 800ff4c:	461a      	mov	r2, r3
 800ff4e:	4613      	mov	r3, r2
 800ff50:	009b      	lsls	r3, r3, #2
 800ff52:	4413      	add	r3, r2
 800ff54:	005b      	lsls	r3, r3, #1
 800ff56:	60bb      	str	r3, [r7, #8]

                if(id > (CoordinateSystem_G59 * 10))
 800ff58:	68bb      	ldr	r3, [r7, #8]
 800ff5a:	2b32      	cmp	r3, #50	; 0x32
 800ff5c:	d903      	bls.n	800ff66 <ngc_named_param_get_by_id+0x1de>
                    id = (CoordinateSystem_G59 * 10) + gc_state.modal.coord_system.id - CoordinateSystem_G59;
 800ff5e:	4b5c      	ldr	r3, [pc, #368]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff60:	7d1b      	ldrb	r3, [r3, #20]
 800ff62:	332d      	adds	r3, #45	; 0x2d
 800ff64:	60bb      	str	r3, [r7, #8]

                value = (float)(540 + id);
 800ff66:	68bb      	ldr	r3, [r7, #8]
 800ff68:	f503 7307 	add.w	r3, r3, #540	; 0x21c
 800ff6c:	4618      	mov	r0, r3
 800ff6e:	f7f0 fec9 	bl	8000d04 <__aeabi_ui2f>
 800ff72:	4603      	mov	r3, r0
 800ff74:	60fb      	str	r3, [r7, #12]
            }
            break;
 800ff76:	e0f2      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_tool_offset:
            value = gc_state.modal.tool_offset_mode >= ToolLengthOffset_Enable ? 1.0f : 0.0f;
 800ff78:	4b55      	ldr	r3, [pc, #340]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff7a:	79db      	ldrb	r3, [r3, #7]
 800ff7c:	2b00      	cmp	r3, #0
 800ff7e:	d002      	beq.n	800ff86 <ngc_named_param_get_by_id+0x1fe>
 800ff80:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ff84:	e001      	b.n	800ff8a <ngc_named_param_get_by_id+0x202>
 800ff86:	f04f 0300 	mov.w	r3, #0
 800ff8a:	60fb      	str	r3, [r7, #12]
            break;
 800ff8c:	e0e7      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_retract_r_plane:
            value = gc_state.modal.retract_mode == CCRetractMode_Previous ? 1.0f : 0.0f;
 800ff8e:	4b50      	ldr	r3, [pc, #320]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ff90:	7f5b      	ldrb	r3, [r3, #29]
 800ff92:	2b00      	cmp	r3, #0
 800ff94:	d102      	bne.n	800ff9c <ngc_named_param_get_by_id+0x214>
 800ff96:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ff9a:	e001      	b.n	800ffa0 <ngc_named_param_get_by_id+0x218>
 800ff9c:	f04f 0300 	mov.w	r3, #0
 800ffa0:	60fb      	str	r3, [r7, #12]
            break;
 800ffa2:	e0dc      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_retract_old_z:
            value = gc_state.modal.retract_mode == CCRetractMode_RPos ? 1.0f : 0.0f;
 800ffa4:	4b4a      	ldr	r3, [pc, #296]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ffa6:	7f5b      	ldrb	r3, [r3, #29]
 800ffa8:	2b01      	cmp	r3, #1
 800ffaa:	d102      	bne.n	800ffb2 <ngc_named_param_get_by_id+0x22a>
 800ffac:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ffb0:	e001      	b.n	800ffb6 <ngc_named_param_get_by_id+0x22e>
 800ffb2:	f04f 0300 	mov.w	r3, #0
 800ffb6:	60fb      	str	r3, [r7, #12]
            break;
 800ffb8:	e0d1      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_spindle_rpm_mode:
            value = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? 1.0f : 0.0f;
 800ffba:	4b45      	ldr	r3, [pc, #276]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ffbc:	7edb      	ldrb	r3, [r3, #27]
 800ffbe:	2b00      	cmp	r3, #0
 800ffc0:	d102      	bne.n	800ffc8 <ngc_named_param_get_by_id+0x240>
 800ffc2:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ffc6:	e001      	b.n	800ffcc <ngc_named_param_get_by_id+0x244>
 800ffc8:	f04f 0300 	mov.w	r3, #0
 800ffcc:	60fb      	str	r3, [r7, #12]
            break;
 800ffce:	e0c6      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_spindle_css_mode:
            value = gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_CSS ? 1.0f : 0.0f;
 800ffd0:	4b3f      	ldr	r3, [pc, #252]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800ffd2:	7edb      	ldrb	r3, [r3, #27]
 800ffd4:	2b01      	cmp	r3, #1
 800ffd6:	d102      	bne.n	800ffde <ngc_named_param_get_by_id+0x256>
 800ffd8:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800ffdc:	e001      	b.n	800ffe2 <ngc_named_param_get_by_id+0x25a>
 800ffde:	f04f 0300 	mov.w	r3, #0
 800ffe2:	60fb      	str	r3, [r7, #12]
            break;
 800ffe4:	e0bb      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_ijk_absolute_mode:
            value = 0.0f;
 800ffe6:	f04f 0300 	mov.w	r3, #0
 800ffea:	60fb      	str	r3, [r7, #12]
            break;
 800ffec:	e0b7      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_lathe_diameter_mode:
            value = gc_state.modal.diameter_mode ? 1.0f : 0.0f;
 800ffee:	4b38      	ldr	r3, [pc, #224]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 800fff0:	795b      	ldrb	r3, [r3, #5]
 800fff2:	2b00      	cmp	r3, #0
 800fff4:	d002      	beq.n	800fffc <ngc_named_param_get_by_id+0x274>
 800fff6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800fffa:	e001      	b.n	8010000 <ngc_named_param_get_by_id+0x278>
 800fffc:	f04f 0300 	mov.w	r3, #0
 8010000:	60fb      	str	r3, [r7, #12]
            break;
 8010002:	e0ac      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_lathe_radius_mode:
            value = gc_state.modal.diameter_mode ? 0.0f : 1.0f;
 8010004:	4b32      	ldr	r3, [pc, #200]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 8010006:	795b      	ldrb	r3, [r3, #5]
 8010008:	2b00      	cmp	r3, #0
 801000a:	d002      	beq.n	8010012 <ngc_named_param_get_by_id+0x28a>
 801000c:	f04f 0300 	mov.w	r3, #0
 8010010:	e001      	b.n	8010016 <ngc_named_param_get_by_id+0x28e>
 8010012:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8010016:	60fb      	str	r3, [r7, #12]
            break;
 8010018:	e0a1      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_spindle_on:
            value = gc_state.modal.spindle.state.on ? 1.0f : 0.0f;
 801001a:	4b2d      	ldr	r3, [pc, #180]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 801001c:	7e9b      	ldrb	r3, [r3, #26]
 801001e:	f003 0301 	and.w	r3, r3, #1
 8010022:	b2db      	uxtb	r3, r3
 8010024:	2b00      	cmp	r3, #0
 8010026:	d002      	beq.n	801002e <ngc_named_param_get_by_id+0x2a6>
 8010028:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 801002c:	e001      	b.n	8010032 <ngc_named_param_get_by_id+0x2aa>
 801002e:	f04f 0300 	mov.w	r3, #0
 8010032:	60fb      	str	r3, [r7, #12]
            break;
 8010034:	e093      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_spindle_cw:
            value = gc_state.modal.spindle.state.ccw ? 1.0f : 0.0f;
 8010036:	4b26      	ldr	r3, [pc, #152]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 8010038:	7e9b      	ldrb	r3, [r3, #26]
 801003a:	f003 0302 	and.w	r3, r3, #2
 801003e:	b2db      	uxtb	r3, r3
 8010040:	2b00      	cmp	r3, #0
 8010042:	d002      	beq.n	801004a <ngc_named_param_get_by_id+0x2c2>
 8010044:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8010048:	e001      	b.n	801004e <ngc_named_param_get_by_id+0x2c6>
 801004a:	f04f 0300 	mov.w	r3, #0
 801004e:	60fb      	str	r3, [r7, #12]
            break;
 8010050:	e085      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_mist:
            value = gc_state.modal.coolant.mist ? 1.0f : 0.0f;
 8010052:	4b1f      	ldr	r3, [pc, #124]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 8010054:	7e5b      	ldrb	r3, [r3, #25]
 8010056:	f003 0302 	and.w	r3, r3, #2
 801005a:	b2db      	uxtb	r3, r3
 801005c:	2b00      	cmp	r3, #0
 801005e:	d002      	beq.n	8010066 <ngc_named_param_get_by_id+0x2de>
 8010060:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8010064:	e001      	b.n	801006a <ngc_named_param_get_by_id+0x2e2>
 8010066:	f04f 0300 	mov.w	r3, #0
 801006a:	60fb      	str	r3, [r7, #12]
            break;
 801006c:	e077      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_flood:
            value = gc_state.modal.coolant.flood ? 1.0f : 0.0f;
 801006e:	4b18      	ldr	r3, [pc, #96]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 8010070:	7e5b      	ldrb	r3, [r3, #25]
 8010072:	f003 0301 	and.w	r3, r3, #1
 8010076:	b2db      	uxtb	r3, r3
 8010078:	2b00      	cmp	r3, #0
 801007a:	d002      	beq.n	8010082 <ngc_named_param_get_by_id+0x2fa>
 801007c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8010080:	e001      	b.n	8010086 <ngc_named_param_get_by_id+0x2fe>
 8010082:	f04f 0300 	mov.w	r3, #0
 8010086:	60fb      	str	r3, [r7, #12]
            break;
 8010088:	e069      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_speed_override:
            value = gc_state.modal.override_ctrl.spindle_rpm_disable ? 0.0f : 1.0f;
 801008a:	4b11      	ldr	r3, [pc, #68]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 801008c:	7f1b      	ldrb	r3, [r3, #28]
 801008e:	f003 0304 	and.w	r3, r3, #4
 8010092:	b2db      	uxtb	r3, r3
 8010094:	2b00      	cmp	r3, #0
 8010096:	d002      	beq.n	801009e <ngc_named_param_get_by_id+0x316>
 8010098:	f04f 0300 	mov.w	r3, #0
 801009c:	e001      	b.n	80100a2 <ngc_named_param_get_by_id+0x31a>
 801009e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80100a2:	60fb      	str	r3, [r7, #12]
            break;
 80100a4:	e05b      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_feed_override:
            value = gc_state.modal.override_ctrl.feed_rate_disable ? 0.0f : 1.0f;
 80100a6:	4b0a      	ldr	r3, [pc, #40]	; (80100d0 <ngc_named_param_get_by_id+0x348>)
 80100a8:	7f1b      	ldrb	r3, [r3, #28]
 80100aa:	f003 0301 	and.w	r3, r3, #1
 80100ae:	b2db      	uxtb	r3, r3
 80100b0:	2b00      	cmp	r3, #0
 80100b2:	d002      	beq.n	80100ba <ngc_named_param_get_by_id+0x332>
 80100b4:	f04f 0300 	mov.w	r3, #0
 80100b8:	e001      	b.n	80100be <ngc_named_param_get_by_id+0x336>
 80100ba:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80100be:	60fb      	str	r3, [r7, #12]
            break;
 80100c0:	e04d      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_adaptive_feed:
            value = 0.0f;
 80100c2:	f04f 0300 	mov.w	r3, #0
 80100c6:	60fb      	str	r3, [r7, #12]
            break;
 80100c8:	e049      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>
 80100ca:	bf00      	nop
 80100cc:	3f8ccccd 	.word	0x3f8ccccd
 80100d0:	20000bb0 	.word	0x20000bb0
 80100d4:	43c80000 	.word	0x43c80000

        case NGCParam_feed_hold:
            value = gc_state.modal.override_ctrl.feed_hold_disable ? 0.0f : 1.0f;
 80100d8:	4b23      	ldr	r3, [pc, #140]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 80100da:	7f1b      	ldrb	r3, [r3, #28]
 80100dc:	f003 0302 	and.w	r3, r3, #2
 80100e0:	b2db      	uxtb	r3, r3
 80100e2:	2b00      	cmp	r3, #0
 80100e4:	d002      	beq.n	80100ec <ngc_named_param_get_by_id+0x364>
 80100e6:	f04f 0300 	mov.w	r3, #0
 80100ea:	e001      	b.n	80100f0 <ngc_named_param_get_by_id+0x368>
 80100ec:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80100f0:	60fb      	str	r3, [r7, #12]
            break;
 80100f2:	e034      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_feed:
            value = gc_state.feed_rate;
 80100f4:	4b1c      	ldr	r3, [pc, #112]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 80100f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80100f8:	60fb      	str	r3, [r7, #12]
            break;
 80100fa:	e030      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_rpm:
            value = gc_state.spindle.rpm;
 80100fc:	4b1a      	ldr	r3, [pc, #104]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 80100fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010100:	60fb      	str	r3, [r7, #12]
            break;
 8010102:	e02c      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>
        case NGCParam_u:
            //no break
        case NGCParam_v:
            //no break
        case NGCParam_w:
            value = _relative_pos(id - NGCParam_x);
 8010104:	79fb      	ldrb	r3, [r7, #7]
 8010106:	3b20      	subs	r3, #32
 8010108:	4618      	mov	r0, r3
 801010a:	f7ff fb6f 	bl	800f7ec <_relative_pos>
 801010e:	60f8      	str	r0, [r7, #12]
            break;
 8010110:	e025      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_current_tool:
            value = (float)gc_state.tool->tool_id;
 8010112:	4b15      	ldr	r3, [pc, #84]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 8010114:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010118:	691b      	ldr	r3, [r3, #16]
 801011a:	4618      	mov	r0, r3
 801011c:	f7f0 fdf2 	bl	8000d04 <__aeabi_ui2f>
 8010120:	4603      	mov	r3, r0
 8010122:	60fb      	str	r3, [r7, #12]
            break;
 8010124:	e01b      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_current_pocket:
            value = 0.0f;
 8010126:	f04f 0300 	mov.w	r3, #0
 801012a:	60fb      	str	r3, [r7, #12]
            break;
 801012c:	e017      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_selected_tool:
            value = gc_state.tool_pending != gc_state.tool->tool_id ? (float)gc_state.tool_pending : -1.0f;
 801012e:	4b0e      	ldr	r3, [pc, #56]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 8010130:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8010132:	4b0d      	ldr	r3, [pc, #52]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 8010134:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010138:	691b      	ldr	r3, [r3, #16]
 801013a:	429a      	cmp	r2, r3
 801013c:	d006      	beq.n	801014c <ngc_named_param_get_by_id+0x3c4>
 801013e:	4b0a      	ldr	r3, [pc, #40]	; (8010168 <ngc_named_param_get_by_id+0x3e0>)
 8010140:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8010142:	4618      	mov	r0, r3
 8010144:	f7f0 fdde 	bl	8000d04 <__aeabi_ui2f>
 8010148:	4603      	mov	r3, r0
 801014a:	e000      	b.n	801014e <ngc_named_param_get_by_id+0x3c6>
 801014c:	4b07      	ldr	r3, [pc, #28]	; (801016c <ngc_named_param_get_by_id+0x3e4>)
 801014e:	60fb      	str	r3, [r7, #12]
            break;
 8010150:	e005      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        case NGCParam_selected_pocket:
            value = 0.0f;
 8010152:	f04f 0300 	mov.w	r3, #0
 8010156:	60fb      	str	r3, [r7, #12]
            break;
 8010158:	e001      	b.n	801015e <ngc_named_param_get_by_id+0x3d6>

        default:
            value = NAN;
 801015a:	4b05      	ldr	r3, [pc, #20]	; (8010170 <ngc_named_param_get_by_id+0x3e8>)
 801015c:	60fb      	str	r3, [r7, #12]
    }

    return value;
 801015e:	68fb      	ldr	r3, [r7, #12]
}
 8010160:	4618      	mov	r0, r3
 8010162:	3710      	adds	r7, #16
 8010164:	46bd      	mov	sp, r7
 8010166:	bd80      	pop	{r7, pc}
 8010168:	20000bb0 	.word	0x20000bb0
 801016c:	bf800000 	.word	0xbf800000
 8010170:	7fc00000 	.word	0x7fc00000

08010174 <ngc_named_param_get>:

bool ngc_named_param_get (char *name, float *value)
{
 8010174:	b580      	push	{r7, lr}
 8010176:	b088      	sub	sp, #32
 8010178:	af00      	add	r7, sp, #0
 801017a:	6078      	str	r0, [r7, #4]
 801017c:	6039      	str	r1, [r7, #0]
    char c, *s = name;
 801017e:	687b      	ldr	r3, [r7, #4]
 8010180:	61fb      	str	r3, [r7, #28]
    bool found = false;
 8010182:	2300      	movs	r3, #0
 8010184:	76fb      	strb	r3, [r7, #27]
    uint_fast8_t idx = sizeof(ngc_named_ro_param) / sizeof(ngc_named_ro_param_t);
 8010186:	232d      	movs	r3, #45	; 0x2d
 8010188:	617b      	str	r3, [r7, #20]

    // Lowercase name
    while((c = *s))
 801018a:	e00f      	b.n	80101ac <ngc_named_param_get+0x38>
        *s++ = LCAPS(c);
 801018c:	7bfb      	ldrb	r3, [r7, #15]
 801018e:	2b40      	cmp	r3, #64	; 0x40
 8010190:	d907      	bls.n	80101a2 <ngc_named_param_get+0x2e>
 8010192:	7bfb      	ldrb	r3, [r7, #15]
 8010194:	2b5a      	cmp	r3, #90	; 0x5a
 8010196:	d804      	bhi.n	80101a2 <ngc_named_param_get+0x2e>
 8010198:	7bfb      	ldrb	r3, [r7, #15]
 801019a:	f043 0320 	orr.w	r3, r3, #32
 801019e:	b2da      	uxtb	r2, r3
 80101a0:	e000      	b.n	80101a4 <ngc_named_param_get+0x30>
 80101a2:	7bfa      	ldrb	r2, [r7, #15]
 80101a4:	69fb      	ldr	r3, [r7, #28]
 80101a6:	1c59      	adds	r1, r3, #1
 80101a8:	61f9      	str	r1, [r7, #28]
 80101aa:	701a      	strb	r2, [r3, #0]
    while((c = *s))
 80101ac:	69fb      	ldr	r3, [r7, #28]
 80101ae:	781b      	ldrb	r3, [r3, #0]
 80101b0:	73fb      	strb	r3, [r7, #15]
 80101b2:	7bfb      	ldrb	r3, [r7, #15]
 80101b4:	2b00      	cmp	r3, #0
 80101b6:	d1e9      	bne.n	801018c <ngc_named_param_get+0x18>

    *value = 0.0f;
 80101b8:	683b      	ldr	r3, [r7, #0]
 80101ba:	f04f 0200 	mov.w	r2, #0
 80101be:	601a      	str	r2, [r3, #0]

     if(*name == '_') do {
 80101c0:	687b      	ldr	r3, [r7, #4]
 80101c2:	781b      	ldrb	r3, [r3, #0]
 80101c4:	2b5f      	cmp	r3, #95	; 0x5f
 80101c6:	d12f      	bne.n	8010228 <ngc_named_param_get+0xb4>
        idx--;
 80101c8:	697b      	ldr	r3, [r7, #20]
 80101ca:	3b01      	subs	r3, #1
 80101cc:	617b      	str	r3, [r7, #20]
        if((found = !strcmp(name, ngc_named_ro_param[idx].name)))
 80101ce:	492d      	ldr	r1, [pc, #180]	; (8010284 <ngc_named_param_get+0x110>)
 80101d0:	697a      	ldr	r2, [r7, #20]
 80101d2:	4613      	mov	r3, r2
 80101d4:	005b      	lsls	r3, r3, #1
 80101d6:	4413      	add	r3, r2
 80101d8:	009b      	lsls	r3, r3, #2
 80101da:	440b      	add	r3, r1
 80101dc:	681b      	ldr	r3, [r3, #0]
 80101de:	4619      	mov	r1, r3
 80101e0:	6878      	ldr	r0, [r7, #4]
 80101e2:	f7f0 f821 	bl	8000228 <strcmp>
 80101e6:	4603      	mov	r3, r0
 80101e8:	2b00      	cmp	r3, #0
 80101ea:	bf0c      	ite	eq
 80101ec:	2301      	moveq	r3, #1
 80101ee:	2300      	movne	r3, #0
 80101f0:	76fb      	strb	r3, [r7, #27]
 80101f2:	7efb      	ldrb	r3, [r7, #27]
 80101f4:	2b00      	cmp	r3, #0
 80101f6:	d00e      	beq.n	8010216 <ngc_named_param_get+0xa2>
            *value = ngc_named_param_get_by_id(ngc_named_ro_param[idx].id);
 80101f8:	4922      	ldr	r1, [pc, #136]	; (8010284 <ngc_named_param_get+0x110>)
 80101fa:	697a      	ldr	r2, [r7, #20]
 80101fc:	4613      	mov	r3, r2
 80101fe:	005b      	lsls	r3, r3, #1
 8010200:	4413      	add	r3, r2
 8010202:	009b      	lsls	r3, r3, #2
 8010204:	440b      	add	r3, r1
 8010206:	3304      	adds	r3, #4
 8010208:	781b      	ldrb	r3, [r3, #0]
 801020a:	4618      	mov	r0, r3
 801020c:	f7ff fdbc 	bl	800fd88 <ngc_named_param_get_by_id>
 8010210:	4602      	mov	r2, r0
 8010212:	683b      	ldr	r3, [r7, #0]
 8010214:	601a      	str	r2, [r3, #0]
    } while(idx && !found);
 8010216:	697b      	ldr	r3, [r7, #20]
 8010218:	2b00      	cmp	r3, #0
 801021a:	d005      	beq.n	8010228 <ngc_named_param_get+0xb4>
 801021c:	7efb      	ldrb	r3, [r7, #27]
 801021e:	f083 0301 	eor.w	r3, r3, #1
 8010222:	b2db      	uxtb	r3, r3
 8010224:	2b00      	cmp	r3, #0
 8010226:	d1cf      	bne.n	80101c8 <ngc_named_param_get+0x54>

    if(!found) {
 8010228:	7efb      	ldrb	r3, [r7, #27]
 801022a:	f083 0301 	eor.w	r3, r3, #1
 801022e:	b2db      	uxtb	r3, r3
 8010230:	2b00      	cmp	r3, #0
 8010232:	d022      	beq.n	801027a <ngc_named_param_get+0x106>
        ngc_named_rw_param_t *rw_param = rw_global_params;
 8010234:	4b14      	ldr	r3, [pc, #80]	; (8010288 <ngc_named_param_get+0x114>)
 8010236:	681b      	ldr	r3, [r3, #0]
 8010238:	613b      	str	r3, [r7, #16]
        while(rw_param && !found) {
 801023a:	e015      	b.n	8010268 <ngc_named_param_get+0xf4>
            if((found = !strcmp(rw_param->name, name)))
 801023c:	693b      	ldr	r3, [r7, #16]
 801023e:	6879      	ldr	r1, [r7, #4]
 8010240:	4618      	mov	r0, r3
 8010242:	f7ef fff1 	bl	8000228 <strcmp>
 8010246:	4603      	mov	r3, r0
 8010248:	2b00      	cmp	r3, #0
 801024a:	bf0c      	ite	eq
 801024c:	2301      	moveq	r3, #1
 801024e:	2300      	movne	r3, #0
 8010250:	76fb      	strb	r3, [r7, #27]
 8010252:	7efb      	ldrb	r3, [r7, #27]
 8010254:	2b00      	cmp	r3, #0
 8010256:	d004      	beq.n	8010262 <ngc_named_param_get+0xee>
                *value = rw_param->value;
 8010258:	693b      	ldr	r3, [r7, #16]
 801025a:	699a      	ldr	r2, [r3, #24]
 801025c:	683b      	ldr	r3, [r7, #0]
 801025e:	601a      	str	r2, [r3, #0]
 8010260:	e002      	b.n	8010268 <ngc_named_param_get+0xf4>
            else
                rw_param = rw_param->next;
 8010262:	693b      	ldr	r3, [r7, #16]
 8010264:	69db      	ldr	r3, [r3, #28]
 8010266:	613b      	str	r3, [r7, #16]
        while(rw_param && !found) {
 8010268:	693b      	ldr	r3, [r7, #16]
 801026a:	2b00      	cmp	r3, #0
 801026c:	d005      	beq.n	801027a <ngc_named_param_get+0x106>
 801026e:	7efb      	ldrb	r3, [r7, #27]
 8010270:	f083 0301 	eor.w	r3, r3, #1
 8010274:	b2db      	uxtb	r3, r3
 8010276:	2b00      	cmp	r3, #0
 8010278:	d1e0      	bne.n	801023c <ngc_named_param_get+0xc8>
        }
    }

    return found;
 801027a:	7efb      	ldrb	r3, [r7, #27]
}
 801027c:	4618      	mov	r0, r3
 801027e:	3720      	adds	r7, #32
 8010280:	46bd      	mov	sp, r7
 8010282:	bd80      	pop	{r7, pc}
 8010284:	08030de4 	.word	0x08030de4
 8010288:	200010b0 	.word	0x200010b0

0801028c <uitoa>:
#endif
};

// Converts an uint32 variable to string.
char *uitoa (uint32_t n)
{
 801028c:	b480      	push	{r7}
 801028e:	b085      	sub	sp, #20
 8010290:	af00      	add	r7, sp, #0
 8010292:	6078      	str	r0, [r7, #4]
    char *bptr = buf + sizeof(buf);
 8010294:	4b19      	ldr	r3, [pc, #100]	; (80102fc <uitoa+0x70>)
 8010296:	60fb      	str	r3, [r7, #12]

    *--bptr = '\0';
 8010298:	68fb      	ldr	r3, [r7, #12]
 801029a:	3b01      	subs	r3, #1
 801029c:	60fb      	str	r3, [r7, #12]
 801029e:	68fb      	ldr	r3, [r7, #12]
 80102a0:	2200      	movs	r2, #0
 80102a2:	701a      	strb	r2, [r3, #0]

    if (n == 0)
 80102a4:	687b      	ldr	r3, [r7, #4]
 80102a6:	2b00      	cmp	r3, #0
 80102a8:	d11e      	bne.n	80102e8 <uitoa+0x5c>
        *--bptr = '0';
 80102aa:	68fb      	ldr	r3, [r7, #12]
 80102ac:	3b01      	subs	r3, #1
 80102ae:	60fb      	str	r3, [r7, #12]
 80102b0:	68fb      	ldr	r3, [r7, #12]
 80102b2:	2230      	movs	r2, #48	; 0x30
 80102b4:	701a      	strb	r2, [r3, #0]
 80102b6:	e01a      	b.n	80102ee <uitoa+0x62>
    else while (n) {
        *--bptr = '0' + (n % 10);
 80102b8:	6879      	ldr	r1, [r7, #4]
 80102ba:	4b11      	ldr	r3, [pc, #68]	; (8010300 <uitoa+0x74>)
 80102bc:	fba3 2301 	umull	r2, r3, r3, r1
 80102c0:	08da      	lsrs	r2, r3, #3
 80102c2:	4613      	mov	r3, r2
 80102c4:	009b      	lsls	r3, r3, #2
 80102c6:	4413      	add	r3, r2
 80102c8:	005b      	lsls	r3, r3, #1
 80102ca:	1aca      	subs	r2, r1, r3
 80102cc:	b2d3      	uxtb	r3, r2
 80102ce:	68fa      	ldr	r2, [r7, #12]
 80102d0:	3a01      	subs	r2, #1
 80102d2:	60fa      	str	r2, [r7, #12]
 80102d4:	3330      	adds	r3, #48	; 0x30
 80102d6:	b2da      	uxtb	r2, r3
 80102d8:	68fb      	ldr	r3, [r7, #12]
 80102da:	701a      	strb	r2, [r3, #0]
        n /= 10;
 80102dc:	687b      	ldr	r3, [r7, #4]
 80102de:	4a08      	ldr	r2, [pc, #32]	; (8010300 <uitoa+0x74>)
 80102e0:	fba2 2303 	umull	r2, r3, r2, r3
 80102e4:	08db      	lsrs	r3, r3, #3
 80102e6:	607b      	str	r3, [r7, #4]
    else while (n) {
 80102e8:	687b      	ldr	r3, [r7, #4]
 80102ea:	2b00      	cmp	r3, #0
 80102ec:	d1e4      	bne.n	80102b8 <uitoa+0x2c>
    }

    return bptr;
 80102ee:	68fb      	ldr	r3, [r7, #12]
}
 80102f0:	4618      	mov	r0, r3
 80102f2:	3714      	adds	r7, #20
 80102f4:	46bd      	mov	sp, r7
 80102f6:	bc80      	pop	{r7}
 80102f8:	4770      	bx	lr
 80102fa:	bf00      	nop
 80102fc:	200010c3 	.word	0x200010c3
 8010300:	cccccccd 	.word	0xcccccccd

08010304 <ftoa>:

// Convert float to string by immediately converting to integers.
// Number of decimal places, which are tracked by a counter, must be set by the user.
// The integers is then efficiently converted to a string.
char *ftoa (float n, uint8_t decimal_places)
{
 8010304:	b590      	push	{r4, r7, lr}
 8010306:	b089      	sub	sp, #36	; 0x24
 8010308:	af00      	add	r7, sp, #0
 801030a:	6078      	str	r0, [r7, #4]
 801030c:	460b      	mov	r3, r1
 801030e:	70fb      	strb	r3, [r7, #3]
    bool isNegative;
    char *bptr = buf + sizeof(buf);
 8010310:	4b5a      	ldr	r3, [pc, #360]	; (801047c <ftoa+0x178>)
 8010312:	61fb      	str	r3, [r7, #28]

    *--bptr = '\0';
 8010314:	69fb      	ldr	r3, [r7, #28]
 8010316:	3b01      	subs	r3, #1
 8010318:	61fb      	str	r3, [r7, #28]
 801031a:	69fb      	ldr	r3, [r7, #28]
 801031c:	2200      	movs	r2, #0
 801031e:	701a      	strb	r2, [r3, #0]

    if ((isNegative = n < 0.0f))
 8010320:	2301      	movs	r3, #1
 8010322:	461c      	mov	r4, r3
 8010324:	f04f 0100 	mov.w	r1, #0
 8010328:	6878      	ldr	r0, [r7, #4]
 801032a:	f7f0 fee1 	bl	80010f0 <__aeabi_fcmplt>
 801032e:	4603      	mov	r3, r0
 8010330:	2b00      	cmp	r3, #0
 8010332:	d101      	bne.n	8010338 <ftoa+0x34>
 8010334:	2300      	movs	r3, #0
 8010336:	461c      	mov	r4, r3
 8010338:	73fc      	strb	r4, [r7, #15]
 801033a:	7bfb      	ldrb	r3, [r7, #15]
 801033c:	2b00      	cmp	r3, #0
 801033e:	d003      	beq.n	8010348 <ftoa+0x44>
        n = -n;
 8010340:	687b      	ldr	r3, [r7, #4]
 8010342:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8010346:	607b      	str	r3, [r7, #4]

    n += froundvalues[decimal_places];
 8010348:	78fb      	ldrb	r3, [r7, #3]
 801034a:	4a4d      	ldr	r2, [pc, #308]	; (8010480 <ftoa+0x17c>)
 801034c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010350:	4619      	mov	r1, r3
 8010352:	6878      	ldr	r0, [r7, #4]
 8010354:	f7f0 fc26 	bl	8000ba4 <__addsf3>
 8010358:	4603      	mov	r3, r0
 801035a:	607b      	str	r3, [r7, #4]

    uint32_t a = (uint32_t)n;
 801035c:	6878      	ldr	r0, [r7, #4]
 801035e:	f7f0 ff2b 	bl	80011b8 <__aeabi_f2uiz>
 8010362:	4603      	mov	r3, r0
 8010364:	61bb      	str	r3, [r7, #24]

    if (decimal_places) {
 8010366:	78fb      	ldrb	r3, [r7, #3]
 8010368:	2b00      	cmp	r3, #0
 801036a:	d04e      	beq.n	801040a <ftoa+0x106>

        n -= (float)a;
 801036c:	69b8      	ldr	r0, [r7, #24]
 801036e:	f7f0 fcc9 	bl	8000d04 <__aeabi_ui2f>
 8010372:	4603      	mov	r3, r0
 8010374:	4619      	mov	r1, r3
 8010376:	6878      	ldr	r0, [r7, #4]
 8010378:	f7f0 fc12 	bl	8000ba0 <__aeabi_fsub>
 801037c:	4603      	mov	r3, r0
 801037e:	607b      	str	r3, [r7, #4]

        uint_fast8_t decimals = decimal_places;
 8010380:	78fb      	ldrb	r3, [r7, #3]
 8010382:	617b      	str	r3, [r7, #20]
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 8010384:	e008      	b.n	8010398 <ftoa+0x94>
            n *= 100.0f;
 8010386:	493f      	ldr	r1, [pc, #252]	; (8010484 <ftoa+0x180>)
 8010388:	6878      	ldr	r0, [r7, #4]
 801038a:	f7f0 fd13 	bl	8000db4 <__aeabi_fmul>
 801038e:	4603      	mov	r3, r0
 8010390:	607b      	str	r3, [r7, #4]
            decimals -= 2;
 8010392:	697b      	ldr	r3, [r7, #20]
 8010394:	3b02      	subs	r3, #2
 8010396:	617b      	str	r3, [r7, #20]
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 8010398:	697b      	ldr	r3, [r7, #20]
 801039a:	2b01      	cmp	r3, #1
 801039c:	d8f3      	bhi.n	8010386 <ftoa+0x82>
        }

        if (decimals)
 801039e:	697b      	ldr	r3, [r7, #20]
 80103a0:	2b00      	cmp	r3, #0
 80103a2:	d005      	beq.n	80103b0 <ftoa+0xac>
            n *= 10.0f;
 80103a4:	4938      	ldr	r1, [pc, #224]	; (8010488 <ftoa+0x184>)
 80103a6:	6878      	ldr	r0, [r7, #4]
 80103a8:	f7f0 fd04 	bl	8000db4 <__aeabi_fmul>
 80103ac:	4603      	mov	r3, r0
 80103ae:	607b      	str	r3, [r7, #4]

        uint32_t b = (uint32_t)n;
 80103b0:	6878      	ldr	r0, [r7, #4]
 80103b2:	f7f0 ff01 	bl	80011b8 <__aeabi_f2uiz>
 80103b6:	4603      	mov	r3, r0
 80103b8:	613b      	str	r3, [r7, #16]

        while(decimal_places--) {
 80103ba:	e021      	b.n	8010400 <ftoa+0xfc>
            if(b) {
 80103bc:	693b      	ldr	r3, [r7, #16]
 80103be:	2b00      	cmp	r3, #0
 80103c0:	d018      	beq.n	80103f4 <ftoa+0xf0>
                *--bptr = (b % 10) + '0'; // Get digit
 80103c2:	6939      	ldr	r1, [r7, #16]
 80103c4:	4b31      	ldr	r3, [pc, #196]	; (801048c <ftoa+0x188>)
 80103c6:	fba3 2301 	umull	r2, r3, r3, r1
 80103ca:	08da      	lsrs	r2, r3, #3
 80103cc:	4613      	mov	r3, r2
 80103ce:	009b      	lsls	r3, r3, #2
 80103d0:	4413      	add	r3, r2
 80103d2:	005b      	lsls	r3, r3, #1
 80103d4:	1aca      	subs	r2, r1, r3
 80103d6:	b2d3      	uxtb	r3, r2
 80103d8:	69fa      	ldr	r2, [r7, #28]
 80103da:	3a01      	subs	r2, #1
 80103dc:	61fa      	str	r2, [r7, #28]
 80103de:	3330      	adds	r3, #48	; 0x30
 80103e0:	b2da      	uxtb	r2, r3
 80103e2:	69fb      	ldr	r3, [r7, #28]
 80103e4:	701a      	strb	r2, [r3, #0]
                b /= 10;
 80103e6:	693b      	ldr	r3, [r7, #16]
 80103e8:	4a28      	ldr	r2, [pc, #160]	; (801048c <ftoa+0x188>)
 80103ea:	fba2 2303 	umull	r2, r3, r2, r3
 80103ee:	08db      	lsrs	r3, r3, #3
 80103f0:	613b      	str	r3, [r7, #16]
 80103f2:	e005      	b.n	8010400 <ftoa+0xfc>
            } else
                *--bptr = '0';
 80103f4:	69fb      	ldr	r3, [r7, #28]
 80103f6:	3b01      	subs	r3, #1
 80103f8:	61fb      	str	r3, [r7, #28]
 80103fa:	69fb      	ldr	r3, [r7, #28]
 80103fc:	2230      	movs	r2, #48	; 0x30
 80103fe:	701a      	strb	r2, [r3, #0]
        while(decimal_places--) {
 8010400:	78fb      	ldrb	r3, [r7, #3]
 8010402:	1e5a      	subs	r2, r3, #1
 8010404:	70fa      	strb	r2, [r7, #3]
 8010406:	2b00      	cmp	r3, #0
 8010408:	d1d8      	bne.n	80103bc <ftoa+0xb8>
        }
    }

    *--bptr = '.'; // Always add decimal point (TODO: is this really needed?)
 801040a:	69fb      	ldr	r3, [r7, #28]
 801040c:	3b01      	subs	r3, #1
 801040e:	61fb      	str	r3, [r7, #28]
 8010410:	69fb      	ldr	r3, [r7, #28]
 8010412:	222e      	movs	r2, #46	; 0x2e
 8010414:	701a      	strb	r2, [r3, #0]

    if(a == 0)
 8010416:	69bb      	ldr	r3, [r7, #24]
 8010418:	2b00      	cmp	r3, #0
 801041a:	d11e      	bne.n	801045a <ftoa+0x156>
        *--bptr = '0';
 801041c:	69fb      	ldr	r3, [r7, #28]
 801041e:	3b01      	subs	r3, #1
 8010420:	61fb      	str	r3, [r7, #28]
 8010422:	69fb      	ldr	r3, [r7, #28]
 8010424:	2230      	movs	r2, #48	; 0x30
 8010426:	701a      	strb	r2, [r3, #0]
 8010428:	e01a      	b.n	8010460 <ftoa+0x15c>

    else while(a) {
        *--bptr = (a % 10) + '0'; // Get digit
 801042a:	69b9      	ldr	r1, [r7, #24]
 801042c:	4b17      	ldr	r3, [pc, #92]	; (801048c <ftoa+0x188>)
 801042e:	fba3 2301 	umull	r2, r3, r3, r1
 8010432:	08da      	lsrs	r2, r3, #3
 8010434:	4613      	mov	r3, r2
 8010436:	009b      	lsls	r3, r3, #2
 8010438:	4413      	add	r3, r2
 801043a:	005b      	lsls	r3, r3, #1
 801043c:	1aca      	subs	r2, r1, r3
 801043e:	b2d3      	uxtb	r3, r2
 8010440:	69fa      	ldr	r2, [r7, #28]
 8010442:	3a01      	subs	r2, #1
 8010444:	61fa      	str	r2, [r7, #28]
 8010446:	3330      	adds	r3, #48	; 0x30
 8010448:	b2da      	uxtb	r2, r3
 801044a:	69fb      	ldr	r3, [r7, #28]
 801044c:	701a      	strb	r2, [r3, #0]
        a /= 10;
 801044e:	69bb      	ldr	r3, [r7, #24]
 8010450:	4a0e      	ldr	r2, [pc, #56]	; (801048c <ftoa+0x188>)
 8010452:	fba2 2303 	umull	r2, r3, r2, r3
 8010456:	08db      	lsrs	r3, r3, #3
 8010458:	61bb      	str	r3, [r7, #24]
    else while(a) {
 801045a:	69bb      	ldr	r3, [r7, #24]
 801045c:	2b00      	cmp	r3, #0
 801045e:	d1e4      	bne.n	801042a <ftoa+0x126>
    }

    if(isNegative)
 8010460:	7bfb      	ldrb	r3, [r7, #15]
 8010462:	2b00      	cmp	r3, #0
 8010464:	d005      	beq.n	8010472 <ftoa+0x16e>
        *--bptr = '-';
 8010466:	69fb      	ldr	r3, [r7, #28]
 8010468:	3b01      	subs	r3, #1
 801046a:	61fb      	str	r3, [r7, #28]
 801046c:	69fb      	ldr	r3, [r7, #28]
 801046e:	222d      	movs	r2, #45	; 0x2d
 8010470:	701a      	strb	r2, [r3, #0]

    return bptr;
 8010472:	69fb      	ldr	r3, [r7, #28]
}
 8010474:	4618      	mov	r0, r3
 8010476:	3724      	adds	r7, #36	; 0x24
 8010478:	46bd      	mov	sp, r7
 801047a:	bd90      	pop	{r4, r7, pc}
 801047c:	200010c3 	.word	0x200010c3
 8010480:	08031000 	.word	0x08031000
 8010484:	42c80000 	.word	0x42c80000
 8010488:	41200000 	.word	0x41200000
 801048c:	cccccccd 	.word	0xcccccccd

08010490 <read_uint>:

// Extracts an unsigned integer value from a string.
status_code_t read_uint (char *line, uint_fast8_t *char_counter, uint32_t *uint_ptr)
{
 8010490:	b480      	push	{r7}
 8010492:	b08b      	sub	sp, #44	; 0x2c
 8010494:	af00      	add	r7, sp, #0
 8010496:	60f8      	str	r0, [r7, #12]
 8010498:	60b9      	str	r1, [r7, #8]
 801049a:	607a      	str	r2, [r7, #4]
    char *ptr = line + *char_counter;
 801049c:	68bb      	ldr	r3, [r7, #8]
 801049e:	681b      	ldr	r3, [r3, #0]
 80104a0:	68fa      	ldr	r2, [r7, #12]
 80104a2:	4413      	add	r3, r2
 80104a4:	627b      	str	r3, [r7, #36]	; 0x24
    int_fast8_t exp = 0;
 80104a6:	2300      	movs	r3, #0
 80104a8:	623b      	str	r3, [r7, #32]
    uint_fast8_t ndigit = 0, c;
 80104aa:	2300      	movs	r3, #0
 80104ac:	61fb      	str	r3, [r7, #28]
    uint32_t intval = 0;
 80104ae:	2300      	movs	r3, #0
 80104b0:	617b      	str	r3, [r7, #20]
    bool isdecimal = false, ok = false;
 80104b2:	2300      	movs	r3, #0
 80104b4:	74fb      	strb	r3, [r7, #19]
 80104b6:	2300      	movs	r3, #0
 80104b8:	74bb      	strb	r3, [r7, #18]

    // Grab first character and increment pointer. No spaces assumed in line.
    c = *ptr++;
 80104ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80104bc:	1c5a      	adds	r2, r3, #1
 80104be:	627a      	str	r2, [r7, #36]	; 0x24
 80104c0:	781b      	ldrb	r3, [r3, #0]
 80104c2:	61bb      	str	r3, [r7, #24]

    if (c == '-')
 80104c4:	69bb      	ldr	r3, [r7, #24]
 80104c6:	2b2d      	cmp	r3, #45	; 0x2d
 80104c8:	d101      	bne.n	80104ce <read_uint+0x3e>
        return Status_NegativeValue;
 80104ca:	2304      	movs	r3, #4
 80104cc:	e06b      	b.n	80105a6 <read_uint+0x116>

    // Skip initial sign character
    if (c == '+')
 80104ce:	69bb      	ldr	r3, [r7, #24]
 80104d0:	2b2b      	cmp	r3, #43	; 0x2b
 80104d2:	d152      	bne.n	801057a <read_uint+0xea>
        c = *ptr++;
 80104d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80104d6:	1c5a      	adds	r2, r3, #1
 80104d8:	627a      	str	r2, [r7, #36]	; 0x24
 80104da:	781b      	ldrb	r3, [r3, #0]
 80104dc:	61bb      	str	r3, [r7, #24]

    // Extract number into fast integer. Track decimal in terms of exponent value.
    while(c) {
 80104de:	e04c      	b.n	801057a <read_uint+0xea>
        c -= '0';
 80104e0:	69bb      	ldr	r3, [r7, #24]
 80104e2:	3b30      	subs	r3, #48	; 0x30
 80104e4:	61bb      	str	r3, [r7, #24]
        if (c <= 9) {
 80104e6:	69bb      	ldr	r3, [r7, #24]
 80104e8:	2b09      	cmp	r3, #9
 80104ea:	d835      	bhi.n	8010558 <read_uint+0xc8>
            ok = true;
 80104ec:	2301      	movs	r3, #1
 80104ee:	74bb      	strb	r3, [r7, #18]
            if(!isdecimal && (c != 0 || intval))
 80104f0:	7cfb      	ldrb	r3, [r7, #19]
 80104f2:	f083 0301 	eor.w	r3, r3, #1
 80104f6:	b2db      	uxtb	r3, r3
 80104f8:	2b00      	cmp	r3, #0
 80104fa:	d008      	beq.n	801050e <read_uint+0x7e>
 80104fc:	69bb      	ldr	r3, [r7, #24]
 80104fe:	2b00      	cmp	r3, #0
 8010500:	d102      	bne.n	8010508 <read_uint+0x78>
 8010502:	697b      	ldr	r3, [r7, #20]
 8010504:	2b00      	cmp	r3, #0
 8010506:	d002      	beq.n	801050e <read_uint+0x7e>
                ndigit++;
 8010508:	69fb      	ldr	r3, [r7, #28]
 801050a:	3301      	adds	r3, #1
 801050c:	61fb      	str	r3, [r7, #28]
            if (isdecimal && c != 0)
 801050e:	7cfb      	ldrb	r3, [r7, #19]
 8010510:	2b00      	cmp	r3, #0
 8010512:	d004      	beq.n	801051e <read_uint+0x8e>
 8010514:	69bb      	ldr	r3, [r7, #24]
 8010516:	2b00      	cmp	r3, #0
 8010518:	d001      	beq.n	801051e <read_uint+0x8e>
                return Status_GcodeCommandValueNotInteger;
 801051a:	2317      	movs	r3, #23
 801051c:	e043      	b.n	80105a6 <read_uint+0x116>

            if ((ndigit <= 9 || c <= 4) && intval <= 429496729) {
 801051e:	69fb      	ldr	r3, [r7, #28]
 8010520:	2b09      	cmp	r3, #9
 8010522:	d902      	bls.n	801052a <read_uint+0x9a>
 8010524:	69bb      	ldr	r3, [r7, #24]
 8010526:	2b04      	cmp	r3, #4
 8010528:	d80c      	bhi.n	8010544 <read_uint+0xb4>
 801052a:	697b      	ldr	r3, [r7, #20]
 801052c:	4a20      	ldr	r2, [pc, #128]	; (80105b0 <read_uint+0x120>)
 801052e:	4293      	cmp	r3, r2
 8010530:	d808      	bhi.n	8010544 <read_uint+0xb4>
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
 8010532:	697b      	ldr	r3, [r7, #20]
 8010534:	009a      	lsls	r2, r3, #2
 8010536:	697b      	ldr	r3, [r7, #20]
 8010538:	4413      	add	r3, r2
 801053a:	005b      	lsls	r3, r3, #1
 801053c:	69ba      	ldr	r2, [r7, #24]
 801053e:	4413      	add	r3, r2
 8010540:	617b      	str	r3, [r7, #20]
 8010542:	e015      	b.n	8010570 <read_uint+0xe0>
            } else if (!isdecimal)
 8010544:	7cfb      	ldrb	r3, [r7, #19]
 8010546:	f083 0301 	eor.w	r3, r3, #1
 801054a:	b2db      	uxtb	r3, r3
 801054c:	2b00      	cmp	r3, #0
 801054e:	d00f      	beq.n	8010570 <read_uint+0xe0>
                exp++;  // Drop overflow digits
 8010550:	6a3b      	ldr	r3, [r7, #32]
 8010552:	3301      	adds	r3, #1
 8010554:	623b      	str	r3, [r7, #32]
 8010556:	e00b      	b.n	8010570 <read_uint+0xe0>
        } else if (c == (uint_fast8_t)('.' - '0') && !isdecimal)
 8010558:	69bb      	ldr	r3, [r7, #24]
 801055a:	f113 0f02 	cmn.w	r3, #2
 801055e:	d10f      	bne.n	8010580 <read_uint+0xf0>
 8010560:	7cfb      	ldrb	r3, [r7, #19]
 8010562:	f083 0301 	eor.w	r3, r3, #1
 8010566:	b2db      	uxtb	r3, r3
 8010568:	2b00      	cmp	r3, #0
 801056a:	d009      	beq.n	8010580 <read_uint+0xf0>
            isdecimal = true;
 801056c:	2301      	movs	r3, #1
 801056e:	74fb      	strb	r3, [r7, #19]
         else
            break;

        c = *ptr++;
 8010570:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010572:	1c5a      	adds	r2, r3, #1
 8010574:	627a      	str	r2, [r7, #36]	; 0x24
 8010576:	781b      	ldrb	r3, [r3, #0]
 8010578:	61bb      	str	r3, [r7, #24]
    while(c) {
 801057a:	69bb      	ldr	r3, [r7, #24]
 801057c:	2b00      	cmp	r3, #0
 801057e:	d1af      	bne.n	80104e0 <read_uint+0x50>
    }

    // Return if no digits have been read.

    if (!ok)
 8010580:	7cbb      	ldrb	r3, [r7, #18]
 8010582:	f083 0301 	eor.w	r3, r3, #1
 8010586:	b2db      	uxtb	r3, r3
 8010588:	2b00      	cmp	r3, #0
 801058a:	d001      	beq.n	8010590 <read_uint+0x100>
        return Status_BadNumberFormat;
 801058c:	2302      	movs	r3, #2
 801058e:	e00a      	b.n	80105a6 <read_uint+0x116>

    *uint_ptr = intval; // Assign value.
 8010590:	687b      	ldr	r3, [r7, #4]
 8010592:	697a      	ldr	r2, [r7, #20]
 8010594:	601a      	str	r2, [r3, #0]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 8010596:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010598:	68fb      	ldr	r3, [r7, #12]
 801059a:	1ad3      	subs	r3, r2, r3
 801059c:	3b01      	subs	r3, #1
 801059e:	461a      	mov	r2, r3
 80105a0:	68bb      	ldr	r3, [r7, #8]
 80105a2:	601a      	str	r2, [r3, #0]

    return Status_OK;
 80105a4:	2300      	movs	r3, #0
}
 80105a6:	4618      	mov	r0, r3
 80105a8:	372c      	adds	r7, #44	; 0x2c
 80105aa:	46bd      	mov	sp, r7
 80105ac:	bc80      	pop	{r7}
 80105ae:	4770      	bx	lr
 80105b0:	19999999 	.word	0x19999999

080105b4 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
bool read_float (char *line, uint_fast8_t *char_counter, float *float_ptr)
{
 80105b4:	b580      	push	{r7, lr}
 80105b6:	b08c      	sub	sp, #48	; 0x30
 80105b8:	af00      	add	r7, sp, #0
 80105ba:	60f8      	str	r0, [r7, #12]
 80105bc:	60b9      	str	r1, [r7, #8]
 80105be:	607a      	str	r2, [r7, #4]
    char *ptr = line + *char_counter;
 80105c0:	68bb      	ldr	r3, [r7, #8]
 80105c2:	681b      	ldr	r3, [r3, #0]
 80105c4:	68fa      	ldr	r2, [r7, #12]
 80105c6:	4413      	add	r3, r2
 80105c8:	62fb      	str	r3, [r7, #44]	; 0x2c
    int_fast8_t exp = 0;
 80105ca:	2300      	movs	r3, #0
 80105cc:	62bb      	str	r3, [r7, #40]	; 0x28
    uint_fast8_t ndigit = 0, c;
 80105ce:	2300      	movs	r3, #0
 80105d0:	627b      	str	r3, [r7, #36]	; 0x24
    uint32_t intval = 0;
 80105d2:	2300      	movs	r3, #0
 80105d4:	61fb      	str	r3, [r7, #28]
    bool isnegative, isdecimal = false, ok = false;
 80105d6:	2300      	movs	r3, #0
 80105d8:	76fb      	strb	r3, [r7, #27]
 80105da:	2300      	movs	r3, #0
 80105dc:	76bb      	strb	r3, [r7, #26]

    // Grab first character and increment pointer. No spaces assumed in line.
    c = *ptr++;
 80105de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80105e0:	1c5a      	adds	r2, r3, #1
 80105e2:	62fa      	str	r2, [r7, #44]	; 0x2c
 80105e4:	781b      	ldrb	r3, [r3, #0]
 80105e6:	623b      	str	r3, [r7, #32]

    // Capture initial sign character
    if ((isnegative = (c == '-')) || c == '+')
 80105e8:	6a3b      	ldr	r3, [r7, #32]
 80105ea:	2b2d      	cmp	r3, #45	; 0x2d
 80105ec:	bf0c      	ite	eq
 80105ee:	2301      	moveq	r3, #1
 80105f0:	2300      	movne	r3, #0
 80105f2:	74fb      	strb	r3, [r7, #19]
 80105f4:	7cfb      	ldrb	r3, [r7, #19]
 80105f6:	2b00      	cmp	r3, #0
 80105f8:	d102      	bne.n	8010600 <read_float+0x4c>
 80105fa:	6a3b      	ldr	r3, [r7, #32]
 80105fc:	2b2b      	cmp	r3, #43	; 0x2b
 80105fe:	d143      	bne.n	8010688 <read_float+0xd4>
        c = *ptr++;
 8010600:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010602:	1c5a      	adds	r2, r3, #1
 8010604:	62fa      	str	r2, [r7, #44]	; 0x2c
 8010606:	781b      	ldrb	r3, [r3, #0]
 8010608:	623b      	str	r3, [r7, #32]

    // Extract number into fast integer. Track decimal in terms of exponent value.
    while(c) {
 801060a:	e03d      	b.n	8010688 <read_float+0xd4>
        c -= '0';
 801060c:	6a3b      	ldr	r3, [r7, #32]
 801060e:	3b30      	subs	r3, #48	; 0x30
 8010610:	623b      	str	r3, [r7, #32]
        if (c <= 9) {
 8010612:	6a3b      	ldr	r3, [r7, #32]
 8010614:	2b09      	cmp	r3, #9
 8010616:	d826      	bhi.n	8010666 <read_float+0xb2>
            ok = true;
 8010618:	2301      	movs	r3, #1
 801061a:	76bb      	strb	r3, [r7, #26]
            if(c != 0 || intval)
 801061c:	6a3b      	ldr	r3, [r7, #32]
 801061e:	2b00      	cmp	r3, #0
 8010620:	d102      	bne.n	8010628 <read_float+0x74>
 8010622:	69fb      	ldr	r3, [r7, #28]
 8010624:	2b00      	cmp	r3, #0
 8010626:	d002      	beq.n	801062e <read_float+0x7a>
                ndigit++;
 8010628:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801062a:	3301      	adds	r3, #1
 801062c:	627b      	str	r3, [r7, #36]	; 0x24
            if (ndigit <= MAX_INT_DIGITS) {
 801062e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010630:	2b09      	cmp	r3, #9
 8010632:	d80e      	bhi.n	8010652 <read_float+0x9e>
                if (isdecimal)
 8010634:	7efb      	ldrb	r3, [r7, #27]
 8010636:	2b00      	cmp	r3, #0
 8010638:	d002      	beq.n	8010640 <read_float+0x8c>
                    exp--;
 801063a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801063c:	3b01      	subs	r3, #1
 801063e:	62bb      	str	r3, [r7, #40]	; 0x28
                intval = (((intval << 2) + intval) << 1) + c; // intval * 10 + c
 8010640:	69fb      	ldr	r3, [r7, #28]
 8010642:	009a      	lsls	r2, r3, #2
 8010644:	69fb      	ldr	r3, [r7, #28]
 8010646:	4413      	add	r3, r2
 8010648:	005b      	lsls	r3, r3, #1
 801064a:	6a3a      	ldr	r2, [r7, #32]
 801064c:	4413      	add	r3, r2
 801064e:	61fb      	str	r3, [r7, #28]
 8010650:	e015      	b.n	801067e <read_float+0xca>
            } else if (!isdecimal)
 8010652:	7efb      	ldrb	r3, [r7, #27]
 8010654:	f083 0301 	eor.w	r3, r3, #1
 8010658:	b2db      	uxtb	r3, r3
 801065a:	2b00      	cmp	r3, #0
 801065c:	d00f      	beq.n	801067e <read_float+0xca>
                exp++;  // Drop overflow digits
 801065e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010660:	3301      	adds	r3, #1
 8010662:	62bb      	str	r3, [r7, #40]	; 0x28
 8010664:	e00b      	b.n	801067e <read_float+0xca>
        } else if (c == (uint_fast8_t)('.' - '0') && !isdecimal)
 8010666:	6a3b      	ldr	r3, [r7, #32]
 8010668:	f113 0f02 	cmn.w	r3, #2
 801066c:	d10f      	bne.n	801068e <read_float+0xda>
 801066e:	7efb      	ldrb	r3, [r7, #27]
 8010670:	f083 0301 	eor.w	r3, r3, #1
 8010674:	b2db      	uxtb	r3, r3
 8010676:	2b00      	cmp	r3, #0
 8010678:	d009      	beq.n	801068e <read_float+0xda>
            isdecimal = true;
 801067a:	2301      	movs	r3, #1
 801067c:	76fb      	strb	r3, [r7, #27]
         else
            break;

        c = *ptr++;
 801067e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010680:	1c5a      	adds	r2, r3, #1
 8010682:	62fa      	str	r2, [r7, #44]	; 0x2c
 8010684:	781b      	ldrb	r3, [r3, #0]
 8010686:	623b      	str	r3, [r7, #32]
    while(c) {
 8010688:	6a3b      	ldr	r3, [r7, #32]
 801068a:	2b00      	cmp	r3, #0
 801068c:	d1be      	bne.n	801060c <read_float+0x58>
    }

    // Return if no digits have been read.
    if (!ok)
 801068e:	7ebb      	ldrb	r3, [r7, #26]
 8010690:	f083 0301 	eor.w	r3, r3, #1
 8010694:	b2db      	uxtb	r3, r3
 8010696:	2b00      	cmp	r3, #0
 8010698:	d001      	beq.n	801069e <read_float+0xea>
        return false;
 801069a:	2300      	movs	r3, #0
 801069c:	e045      	b.n	801072a <read_float+0x176>

    // Convert integer into floating point.
    float fval = (float)intval;
 801069e:	69f8      	ldr	r0, [r7, #28]
 80106a0:	f7f0 fb30 	bl	8000d04 <__aeabi_ui2f>
 80106a4:	4603      	mov	r3, r0
 80106a6:	617b      	str	r3, [r7, #20]

    // Apply decimal. Should perform no more than two floating point multiplications for the
    // expected range of E0 to E-4.
    if (fval != 0.0f) {
 80106a8:	f04f 0100 	mov.w	r1, #0
 80106ac:	6978      	ldr	r0, [r7, #20]
 80106ae:	f7f0 fd15 	bl	80010dc <__aeabi_fcmpeq>
 80106b2:	4603      	mov	r3, r0
 80106b4:	2b00      	cmp	r3, #0
 80106b6:	d126      	bne.n	8010706 <read_float+0x152>
        while (exp <= -2) {
 80106b8:	e008      	b.n	80106cc <read_float+0x118>
            fval *= 0.01f;
 80106ba:	491e      	ldr	r1, [pc, #120]	; (8010734 <read_float+0x180>)
 80106bc:	6978      	ldr	r0, [r7, #20]
 80106be:	f7f0 fb79 	bl	8000db4 <__aeabi_fmul>
 80106c2:	4603      	mov	r3, r0
 80106c4:	617b      	str	r3, [r7, #20]
            exp += 2;
 80106c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106c8:	3302      	adds	r3, #2
 80106ca:	62bb      	str	r3, [r7, #40]	; 0x28
        while (exp <= -2) {
 80106cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 80106d2:	dbf2      	blt.n	80106ba <read_float+0x106>
        }
        if (exp < 0)
 80106d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106d6:	2b00      	cmp	r3, #0
 80106d8:	da06      	bge.n	80106e8 <read_float+0x134>
            fval *= 0.1f;
 80106da:	4917      	ldr	r1, [pc, #92]	; (8010738 <read_float+0x184>)
 80106dc:	6978      	ldr	r0, [r7, #20]
 80106de:	f7f0 fb69 	bl	8000db4 <__aeabi_fmul>
 80106e2:	4603      	mov	r3, r0
 80106e4:	617b      	str	r3, [r7, #20]
 80106e6:	e00e      	b.n	8010706 <read_float+0x152>
        else if (exp > 0) do {
 80106e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106ea:	2b00      	cmp	r3, #0
 80106ec:	dd0b      	ble.n	8010706 <read_float+0x152>
            fval *= 10.0f;
 80106ee:	4913      	ldr	r1, [pc, #76]	; (801073c <read_float+0x188>)
 80106f0:	6978      	ldr	r0, [r7, #20]
 80106f2:	f7f0 fb5f 	bl	8000db4 <__aeabi_fmul>
 80106f6:	4603      	mov	r3, r0
 80106f8:	617b      	str	r3, [r7, #20]
        } while (--exp > 0);
 80106fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106fc:	3b01      	subs	r3, #1
 80106fe:	62bb      	str	r3, [r7, #40]	; 0x28
 8010700:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010702:	2b00      	cmp	r3, #0
 8010704:	dcf3      	bgt.n	80106ee <read_float+0x13a>
    }

    // Assign floating point value with correct sign.
    *float_ptr = isnegative ? - fval : fval;
 8010706:	7cfb      	ldrb	r3, [r7, #19]
 8010708:	2b00      	cmp	r3, #0
 801070a:	d003      	beq.n	8010714 <read_float+0x160>
 801070c:	697b      	ldr	r3, [r7, #20]
 801070e:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8010712:	e000      	b.n	8010716 <read_float+0x162>
 8010714:	697b      	ldr	r3, [r7, #20]
 8010716:	687a      	ldr	r2, [r7, #4]
 8010718:	6013      	str	r3, [r2, #0]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 801071a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801071c:	68fb      	ldr	r3, [r7, #12]
 801071e:	1ad3      	subs	r3, r2, r3
 8010720:	3b01      	subs	r3, #1
 8010722:	461a      	mov	r2, r3
 8010724:	68bb      	ldr	r3, [r7, #8]
 8010726:	601a      	str	r2, [r3, #0]

    return true;
 8010728:	2301      	movs	r3, #1
}
 801072a:	4618      	mov	r0, r3
 801072c:	3730      	adds	r7, #48	; 0x30
 801072e:	46bd      	mov	sp, r7
 8010730:	bd80      	pop	{r7, pc}
 8010732:	bf00      	nop
 8010734:	3c23d70a 	.word	0x3c23d70a
 8010738:	3dcccccd 	.word	0x3dcccccd
 801073c:	41200000 	.word	0x41200000

08010740 <isintf>:

// Returns true if float value is a whole number (integer)
bool isintf (float value)
{
 8010740:	b590      	push	{r4, r7, lr}
 8010742:	b083      	sub	sp, #12
 8010744:	af00      	add	r7, sp, #0
 8010746:	6078      	str	r0, [r7, #4]
    return value != NAN && fabsf(value - truncf(value)) < 0.001f;
 8010748:	6878      	ldr	r0, [r7, #4]
 801074a:	f014 fb53 	bl	8024df4 <truncf>
 801074e:	4603      	mov	r3, r0
 8010750:	4619      	mov	r1, r3
 8010752:	6878      	ldr	r0, [r7, #4]
 8010754:	f7f0 fa24 	bl	8000ba0 <__aeabi_fsub>
 8010758:	4603      	mov	r3, r0
 801075a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801075e:	2201      	movs	r2, #1
 8010760:	4614      	mov	r4, r2
 8010762:	4907      	ldr	r1, [pc, #28]	; (8010780 <isintf+0x40>)
 8010764:	4618      	mov	r0, r3
 8010766:	f7f0 fcc3 	bl	80010f0 <__aeabi_fcmplt>
 801076a:	4603      	mov	r3, r0
 801076c:	2b00      	cmp	r3, #0
 801076e:	d101      	bne.n	8010774 <isintf+0x34>
 8010770:	2300      	movs	r3, #0
 8010772:	461c      	mov	r4, r3
 8010774:	b2e3      	uxtb	r3, r4
}
 8010776:	4618      	mov	r0, r3
 8010778:	370c      	adds	r7, #12
 801077a:	46bd      	mov	sp, r7
 801077c:	bd90      	pop	{r4, r7, pc}
 801077e:	bf00      	nop
 8010780:	3a83126f 	.word	0x3a83126f

08010784 <delay_sec>:

// Non-blocking delay function used for general operation and suspend features.
void delay_sec (float seconds, delaymode_t mode)
{
 8010784:	b580      	push	{r7, lr}
 8010786:	b084      	sub	sp, #16
 8010788:	af00      	add	r7, sp, #0
 801078a:	6078      	str	r0, [r7, #4]
 801078c:	460b      	mov	r3, r1
 801078e:	70fb      	strb	r3, [r7, #3]
    uint_fast16_t i = (uint_fast16_t)ceilf((1000.0f / DWELL_TIME_STEP) * seconds) + 1;
 8010790:	4919      	ldr	r1, [pc, #100]	; (80107f8 <delay_sec+0x74>)
 8010792:	6878      	ldr	r0, [r7, #4]
 8010794:	f7f0 fb0e 	bl	8000db4 <__aeabi_fmul>
 8010798:	4603      	mov	r3, r0
 801079a:	4618      	mov	r0, r3
 801079c:	f014 fa86 	bl	8024cac <ceilf>
 80107a0:	4603      	mov	r3, r0
 80107a2:	4618      	mov	r0, r3
 80107a4:	f7f0 fd08 	bl	80011b8 <__aeabi_f2uiz>
 80107a8:	4603      	mov	r3, r0
 80107aa:	3301      	adds	r3, #1
 80107ac:	60fb      	str	r3, [r7, #12]

    while (--i && !sys.abort) {
 80107ae:	e011      	b.n	80107d4 <delay_sec+0x50>
        if (mode == DelayMode_Dwell) {
 80107b0:	78fb      	ldrb	r3, [r7, #3]
 80107b2:	2b00      	cmp	r3, #0
 80107b4:	d102      	bne.n	80107bc <delay_sec+0x38>
            protocol_execute_realtime();
 80107b6:	f002 fad3 	bl	8012d60 <protocol_execute_realtime>
 80107ba:	e006      	b.n	80107ca <delay_sec+0x46>
        } else { // DelayMode_SysSuspend
          // Execute rt_system() only to avoid nesting suspend loops.
          protocol_exec_rt_system();
 80107bc:	f002 fbaa 	bl	8012f14 <protocol_exec_rt_system>
          if (state_door_reopened()) // Bail, if safety door reopens.
 80107c0:	f00d f842 	bl	801d848 <state_door_reopened>
 80107c4:	4603      	mov	r3, r0
 80107c6:	2b00      	cmp	r3, #0
 80107c8:	d112      	bne.n	80107f0 <delay_sec+0x6c>
              return;
        }
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 80107ca:	4b0c      	ldr	r3, [pc, #48]	; (80107fc <delay_sec+0x78>)
 80107cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80107ce:	2100      	movs	r1, #0
 80107d0:	2032      	movs	r0, #50	; 0x32
 80107d2:	4798      	blx	r3
    while (--i && !sys.abort) {
 80107d4:	68fb      	ldr	r3, [r7, #12]
 80107d6:	3b01      	subs	r3, #1
 80107d8:	60fb      	str	r3, [r7, #12]
 80107da:	68fb      	ldr	r3, [r7, #12]
 80107dc:	2b00      	cmp	r3, #0
 80107de:	d008      	beq.n	80107f2 <delay_sec+0x6e>
 80107e0:	4b07      	ldr	r3, [pc, #28]	; (8010800 <delay_sec+0x7c>)
 80107e2:	781b      	ldrb	r3, [r3, #0]
 80107e4:	f083 0301 	eor.w	r3, r3, #1
 80107e8:	b2db      	uxtb	r3, r3
 80107ea:	2b00      	cmp	r3, #0
 80107ec:	d1e0      	bne.n	80107b0 <delay_sec+0x2c>
 80107ee:	e000      	b.n	80107f2 <delay_sec+0x6e>
              return;
 80107f0:	bf00      	nop
    }
}
 80107f2:	3710      	adds	r7, #16
 80107f4:	46bd      	mov	sp, r7
 80107f6:	bd80      	pop	{r7, pc}
 80107f8:	41a00000 	.word	0x41a00000
 80107fc:	20000ed0 	.word	0x20000ed0
 8010800:	20000d3c 	.word	0x20000d3c

08010804 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector (float *vector)
{
 8010804:	b590      	push	{r4, r7, lr}
 8010806:	b087      	sub	sp, #28
 8010808:	af00      	add	r7, sp, #0
 801080a:	6078      	str	r0, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 801080c:	2303      	movs	r3, #3
 801080e:	617b      	str	r3, [r7, #20]
    float magnitude = 0.0f, inv_magnitude;
 8010810:	f04f 0300 	mov.w	r3, #0
 8010814:	613b      	str	r3, [r7, #16]

    do {
        if (vector[--idx] != 0.0f)
 8010816:	697b      	ldr	r3, [r7, #20]
 8010818:	3b01      	subs	r3, #1
 801081a:	617b      	str	r3, [r7, #20]
 801081c:	697b      	ldr	r3, [r7, #20]
 801081e:	009b      	lsls	r3, r3, #2
 8010820:	687a      	ldr	r2, [r7, #4]
 8010822:	4413      	add	r3, r2
 8010824:	681b      	ldr	r3, [r3, #0]
 8010826:	f04f 0100 	mov.w	r1, #0
 801082a:	4618      	mov	r0, r3
 801082c:	f7f0 fc56 	bl	80010dc <__aeabi_fcmpeq>
 8010830:	4603      	mov	r3, r0
 8010832:	2b00      	cmp	r3, #0
 8010834:	d113      	bne.n	801085e <convert_delta_vector_to_unit_vector+0x5a>
            magnitude += vector[idx] * vector[idx];
 8010836:	697b      	ldr	r3, [r7, #20]
 8010838:	009b      	lsls	r3, r3, #2
 801083a:	687a      	ldr	r2, [r7, #4]
 801083c:	4413      	add	r3, r2
 801083e:	6818      	ldr	r0, [r3, #0]
 8010840:	697b      	ldr	r3, [r7, #20]
 8010842:	009b      	lsls	r3, r3, #2
 8010844:	687a      	ldr	r2, [r7, #4]
 8010846:	4413      	add	r3, r2
 8010848:	681b      	ldr	r3, [r3, #0]
 801084a:	4619      	mov	r1, r3
 801084c:	f7f0 fab2 	bl	8000db4 <__aeabi_fmul>
 8010850:	4603      	mov	r3, r0
 8010852:	4619      	mov	r1, r3
 8010854:	6938      	ldr	r0, [r7, #16]
 8010856:	f7f0 f9a5 	bl	8000ba4 <__addsf3>
 801085a:	4603      	mov	r3, r0
 801085c:	613b      	str	r3, [r7, #16]
    } while(idx);
 801085e:	697b      	ldr	r3, [r7, #20]
 8010860:	2b00      	cmp	r3, #0
 8010862:	d1d8      	bne.n	8010816 <convert_delta_vector_to_unit_vector+0x12>

    idx = N_AXIS;
 8010864:	2303      	movs	r3, #3
 8010866:	617b      	str	r3, [r7, #20]
    magnitude = sqrtf(magnitude);
 8010868:	6938      	ldr	r0, [r7, #16]
 801086a:	f014 f8c8 	bl	80249fe <sqrtf>
 801086e:	6138      	str	r0, [r7, #16]
    inv_magnitude = 1.0f / magnitude;
 8010870:	6939      	ldr	r1, [r7, #16]
 8010872:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8010876:	f7f0 fb51 	bl	8000f1c <__aeabi_fdiv>
 801087a:	4603      	mov	r3, r0
 801087c:	60fb      	str	r3, [r7, #12]

    do {
        vector[--idx] *= inv_magnitude;
 801087e:	697b      	ldr	r3, [r7, #20]
 8010880:	3b01      	subs	r3, #1
 8010882:	617b      	str	r3, [r7, #20]
 8010884:	697b      	ldr	r3, [r7, #20]
 8010886:	009a      	lsls	r2, r3, #2
 8010888:	6879      	ldr	r1, [r7, #4]
 801088a:	440a      	add	r2, r1
 801088c:	6810      	ldr	r0, [r2, #0]
 801088e:	009b      	lsls	r3, r3, #2
 8010890:	687a      	ldr	r2, [r7, #4]
 8010892:	18d4      	adds	r4, r2, r3
 8010894:	68f9      	ldr	r1, [r7, #12]
 8010896:	f7f0 fa8d 	bl	8000db4 <__aeabi_fmul>
 801089a:	4603      	mov	r3, r0
 801089c:	6023      	str	r3, [r4, #0]
    } while(idx);
 801089e:	697b      	ldr	r3, [r7, #20]
 80108a0:	2b00      	cmp	r3, #0
 80108a2:	d1ec      	bne.n	801087e <convert_delta_vector_to_unit_vector+0x7a>

    return magnitude;
 80108a4:	693b      	ldr	r3, [r7, #16]
}
 80108a6:	4618      	mov	r0, r3
 80108a8:	371c      	adds	r7, #28
 80108aa:	46bd      	mov	sp, r7
 80108ac:	bd90      	pop	{r4, r7, pc}
	...

080108b0 <get_datetime>:

// parse ISO8601 datetime: YYYY-MM-DDTHH:MM:SSZxxx
struct tm *get_datetime (const char *s)
{
 80108b0:	b580      	push	{r7, lr}
 80108b2:	b086      	sub	sp, #24
 80108b4:	af00      	add	r7, sp, #0
 80108b6:	6078      	str	r0, [r7, #4]
    static struct tm dt;
    PROGMEM static const uint8_t mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    char *s1 = (char *)s, c;
 80108b8:	687b      	ldr	r3, [r7, #4]
 80108ba:	617b      	str	r3, [r7, #20]
    uint_fast16_t idx = 0, value = 0;
 80108bc:	2300      	movs	r3, #0
 80108be:	613b      	str	r3, [r7, #16]
 80108c0:	2300      	movs	r3, #0
 80108c2:	60fb      	str	r3, [r7, #12]

    memset(&dt, 0, sizeof(struct tm));
 80108c4:	2224      	movs	r2, #36	; 0x24
 80108c6:	2100      	movs	r1, #0
 80108c8:	4878      	ldr	r0, [pc, #480]	; (8010aac <get_datetime+0x1fc>)
 80108ca:	f013 f9a4 	bl	8023c16 <memset>
    dt.tm_year = dt.tm_mon = dt.tm_mday = dt.tm_hour = dt.tm_min = dt.tm_sec = -1;
 80108ce:	4b77      	ldr	r3, [pc, #476]	; (8010aac <get_datetime+0x1fc>)
 80108d0:	f04f 32ff 	mov.w	r2, #4294967295
 80108d4:	601a      	str	r2, [r3, #0]
 80108d6:	4b75      	ldr	r3, [pc, #468]	; (8010aac <get_datetime+0x1fc>)
 80108d8:	681b      	ldr	r3, [r3, #0]
 80108da:	4a74      	ldr	r2, [pc, #464]	; (8010aac <get_datetime+0x1fc>)
 80108dc:	6053      	str	r3, [r2, #4]
 80108de:	4b73      	ldr	r3, [pc, #460]	; (8010aac <get_datetime+0x1fc>)
 80108e0:	685b      	ldr	r3, [r3, #4]
 80108e2:	4a72      	ldr	r2, [pc, #456]	; (8010aac <get_datetime+0x1fc>)
 80108e4:	6093      	str	r3, [r2, #8]
 80108e6:	4b71      	ldr	r3, [pc, #452]	; (8010aac <get_datetime+0x1fc>)
 80108e8:	689b      	ldr	r3, [r3, #8]
 80108ea:	4a70      	ldr	r2, [pc, #448]	; (8010aac <get_datetime+0x1fc>)
 80108ec:	60d3      	str	r3, [r2, #12]
 80108ee:	4b6f      	ldr	r3, [pc, #444]	; (8010aac <get_datetime+0x1fc>)
 80108f0:	68db      	ldr	r3, [r3, #12]
 80108f2:	4a6e      	ldr	r2, [pc, #440]	; (8010aac <get_datetime+0x1fc>)
 80108f4:	6113      	str	r3, [r2, #16]
 80108f6:	4b6d      	ldr	r3, [pc, #436]	; (8010aac <get_datetime+0x1fc>)
 80108f8:	691b      	ldr	r3, [r3, #16]
 80108fa:	4a6c      	ldr	r2, [pc, #432]	; (8010aac <get_datetime+0x1fc>)
 80108fc:	6153      	str	r3, [r2, #20]

    do {
        c = *s1++;
 80108fe:	697b      	ldr	r3, [r7, #20]
 8010900:	1c5a      	adds	r2, r3, #1
 8010902:	617a      	str	r2, [r7, #20]
 8010904:	781b      	ldrb	r3, [r3, #0]
 8010906:	72fb      	strb	r3, [r7, #11]

        if(isdigit(c))
 8010908:	7afb      	ldrb	r3, [r7, #11]
 801090a:	3301      	adds	r3, #1
 801090c:	4a68      	ldr	r2, [pc, #416]	; (8010ab0 <get_datetime+0x200>)
 801090e:	4413      	add	r3, r2
 8010910:	781b      	ldrb	r3, [r3, #0]
 8010912:	f003 0304 	and.w	r3, r3, #4
 8010916:	2b00      	cmp	r3, #0
 8010918:	d00a      	beq.n	8010930 <get_datetime+0x80>
            value = (value * 10) + c - '0';
 801091a:	68fa      	ldr	r2, [r7, #12]
 801091c:	4613      	mov	r3, r2
 801091e:	009b      	lsls	r3, r3, #2
 8010920:	4413      	add	r3, r2
 8010922:	005b      	lsls	r3, r3, #1
 8010924:	461a      	mov	r2, r3
 8010926:	7afb      	ldrb	r3, [r7, #11]
 8010928:	4413      	add	r3, r2
 801092a:	3b30      	subs	r3, #48	; 0x30
 801092c:	60fb      	str	r3, [r7, #12]
 801092e:	e09e      	b.n	8010a6e <get_datetime+0x1be>

        else if(!(c == '-' || c == ':' || c == 'T' || c == 'Z' || c == '\0'))
 8010930:	7afb      	ldrb	r3, [r7, #11]
 8010932:	2b2d      	cmp	r3, #45	; 0x2d
 8010934:	d00c      	beq.n	8010950 <get_datetime+0xa0>
 8010936:	7afb      	ldrb	r3, [r7, #11]
 8010938:	2b3a      	cmp	r3, #58	; 0x3a
 801093a:	d009      	beq.n	8010950 <get_datetime+0xa0>
 801093c:	7afb      	ldrb	r3, [r7, #11]
 801093e:	2b54      	cmp	r3, #84	; 0x54
 8010940:	d006      	beq.n	8010950 <get_datetime+0xa0>
 8010942:	7afb      	ldrb	r3, [r7, #11]
 8010944:	2b5a      	cmp	r3, #90	; 0x5a
 8010946:	d003      	beq.n	8010950 <get_datetime+0xa0>
 8010948:	7afb      	ldrb	r3, [r7, #11]
 801094a:	2b00      	cmp	r3, #0
 801094c:	f040 8093 	bne.w	8010a76 <get_datetime+0x1c6>
            break;

        else {
            switch(idx) {
 8010950:	693b      	ldr	r3, [r7, #16]
 8010952:	2b05      	cmp	r3, #5
 8010954:	f200 8086 	bhi.w	8010a64 <get_datetime+0x1b4>
 8010958:	a201      	add	r2, pc, #4	; (adr r2, 8010960 <get_datetime+0xb0>)
 801095a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801095e:	bf00      	nop
 8010960:	08010979 	.word	0x08010979
 8010964:	080109a1 	.word	0x080109a1
 8010968:	080109bf 	.word	0x080109bf
 801096c:	08010a0d 	.word	0x08010a0d
 8010970:	08010a21 	.word	0x08010a21
 8010974:	08010a35 	.word	0x08010a35
                case 0:
                    if(c == '-' && value >= 1970 && value <= 2099)
 8010978:	7afb      	ldrb	r3, [r7, #11]
 801097a:	2b2d      	cmp	r3, #45	; 0x2d
 801097c:	d167      	bne.n	8010a4e <get_datetime+0x19e>
 801097e:	68fb      	ldr	r3, [r7, #12]
 8010980:	f240 72b1 	movw	r2, #1969	; 0x7b1
 8010984:	4293      	cmp	r3, r2
 8010986:	d962      	bls.n	8010a4e <get_datetime+0x19e>
 8010988:	68fb      	ldr	r3, [r7, #12]
 801098a:	f640 0233 	movw	r2, #2099	; 0x833
 801098e:	4293      	cmp	r3, r2
 8010990:	d85d      	bhi.n	8010a4e <get_datetime+0x19e>
                        dt.tm_year = value - 1900;
 8010992:	68fb      	ldr	r3, [r7, #12]
 8010994:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 8010998:	461a      	mov	r2, r3
 801099a:	4b44      	ldr	r3, [pc, #272]	; (8010aac <get_datetime+0x1fc>)
 801099c:	615a      	str	r2, [r3, #20]
                    break;
 801099e:	e056      	b.n	8010a4e <get_datetime+0x19e>

                case 1:
                    if(c == '-' && value >= 1 && value <= 12)
 80109a0:	7afb      	ldrb	r3, [r7, #11]
 80109a2:	2b2d      	cmp	r3, #45	; 0x2d
 80109a4:	d155      	bne.n	8010a52 <get_datetime+0x1a2>
 80109a6:	68fb      	ldr	r3, [r7, #12]
 80109a8:	2b00      	cmp	r3, #0
 80109aa:	d052      	beq.n	8010a52 <get_datetime+0x1a2>
 80109ac:	68fb      	ldr	r3, [r7, #12]
 80109ae:	2b0c      	cmp	r3, #12
 80109b0:	d84f      	bhi.n	8010a52 <get_datetime+0x1a2>
                        dt.tm_mon = value - 1;
 80109b2:	68fb      	ldr	r3, [r7, #12]
 80109b4:	3b01      	subs	r3, #1
 80109b6:	461a      	mov	r2, r3
 80109b8:	4b3c      	ldr	r3, [pc, #240]	; (8010aac <get_datetime+0x1fc>)
 80109ba:	611a      	str	r2, [r3, #16]
                    break;
 80109bc:	e049      	b.n	8010a52 <get_datetime+0x1a2>

                case 2:
                    if(c == 'T' && value >= 1 && value <= (mdays[dt.tm_mon >= 0 ? dt.tm_mon : 0] + (dt.tm_mon == 1 && dt.tm_year != 100 && (dt.tm_year % 4) == 0 ? 1 : 0)))
 80109be:	7afb      	ldrb	r3, [r7, #11]
 80109c0:	2b54      	cmp	r3, #84	; 0x54
 80109c2:	d148      	bne.n	8010a56 <get_datetime+0x1a6>
 80109c4:	68fb      	ldr	r3, [r7, #12]
 80109c6:	2b00      	cmp	r3, #0
 80109c8:	d045      	beq.n	8010a56 <get_datetime+0x1a6>
 80109ca:	4b38      	ldr	r3, [pc, #224]	; (8010aac <get_datetime+0x1fc>)
 80109cc:	691b      	ldr	r3, [r3, #16]
 80109ce:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80109d2:	4a38      	ldr	r2, [pc, #224]	; (8010ab4 <get_datetime+0x204>)
 80109d4:	5cd3      	ldrb	r3, [r2, r3]
 80109d6:	461a      	mov	r2, r3
 80109d8:	4b34      	ldr	r3, [pc, #208]	; (8010aac <get_datetime+0x1fc>)
 80109da:	691b      	ldr	r3, [r3, #16]
 80109dc:	2b01      	cmp	r3, #1
 80109de:	d10b      	bne.n	80109f8 <get_datetime+0x148>
 80109e0:	4b32      	ldr	r3, [pc, #200]	; (8010aac <get_datetime+0x1fc>)
 80109e2:	695b      	ldr	r3, [r3, #20]
 80109e4:	2b64      	cmp	r3, #100	; 0x64
 80109e6:	d007      	beq.n	80109f8 <get_datetime+0x148>
 80109e8:	4b30      	ldr	r3, [pc, #192]	; (8010aac <get_datetime+0x1fc>)
 80109ea:	695b      	ldr	r3, [r3, #20]
 80109ec:	f003 0303 	and.w	r3, r3, #3
 80109f0:	2b00      	cmp	r3, #0
 80109f2:	d101      	bne.n	80109f8 <get_datetime+0x148>
 80109f4:	2301      	movs	r3, #1
 80109f6:	e000      	b.n	80109fa <get_datetime+0x14a>
 80109f8:	2300      	movs	r3, #0
 80109fa:	4413      	add	r3, r2
 80109fc:	461a      	mov	r2, r3
 80109fe:	68fb      	ldr	r3, [r7, #12]
 8010a00:	4293      	cmp	r3, r2
 8010a02:	d828      	bhi.n	8010a56 <get_datetime+0x1a6>
                        dt.tm_mday = value;
 8010a04:	68fb      	ldr	r3, [r7, #12]
 8010a06:	4a29      	ldr	r2, [pc, #164]	; (8010aac <get_datetime+0x1fc>)
 8010a08:	60d3      	str	r3, [r2, #12]
                    break;
 8010a0a:	e024      	b.n	8010a56 <get_datetime+0x1a6>

                case 3:
                    if(c == ':' && value <= 23)
 8010a0c:	7afb      	ldrb	r3, [r7, #11]
 8010a0e:	2b3a      	cmp	r3, #58	; 0x3a
 8010a10:	d123      	bne.n	8010a5a <get_datetime+0x1aa>
 8010a12:	68fb      	ldr	r3, [r7, #12]
 8010a14:	2b17      	cmp	r3, #23
 8010a16:	d820      	bhi.n	8010a5a <get_datetime+0x1aa>
                        dt.tm_hour = value;
 8010a18:	68fb      	ldr	r3, [r7, #12]
 8010a1a:	4a24      	ldr	r2, [pc, #144]	; (8010aac <get_datetime+0x1fc>)
 8010a1c:	6093      	str	r3, [r2, #8]
                    break;
 8010a1e:	e01c      	b.n	8010a5a <get_datetime+0x1aa>

                case 4:
                    if(c == ':' && value <= 59)
 8010a20:	7afb      	ldrb	r3, [r7, #11]
 8010a22:	2b3a      	cmp	r3, #58	; 0x3a
 8010a24:	d11b      	bne.n	8010a5e <get_datetime+0x1ae>
 8010a26:	68fb      	ldr	r3, [r7, #12]
 8010a28:	2b3b      	cmp	r3, #59	; 0x3b
 8010a2a:	d818      	bhi.n	8010a5e <get_datetime+0x1ae>
                        dt.tm_min = value;
 8010a2c:	68fb      	ldr	r3, [r7, #12]
 8010a2e:	4a1f      	ldr	r2, [pc, #124]	; (8010aac <get_datetime+0x1fc>)
 8010a30:	6053      	str	r3, [r2, #4]
                    break;
 8010a32:	e014      	b.n	8010a5e <get_datetime+0x1ae>

                case 5:
                    if((c == 'Z' || c == '\0') && value <= 59)
 8010a34:	7afb      	ldrb	r3, [r7, #11]
 8010a36:	2b5a      	cmp	r3, #90	; 0x5a
 8010a38:	d002      	beq.n	8010a40 <get_datetime+0x190>
 8010a3a:	7afb      	ldrb	r3, [r7, #11]
 8010a3c:	2b00      	cmp	r3, #0
 8010a3e:	d110      	bne.n	8010a62 <get_datetime+0x1b2>
 8010a40:	68fb      	ldr	r3, [r7, #12]
 8010a42:	2b3b      	cmp	r3, #59	; 0x3b
 8010a44:	d80d      	bhi.n	8010a62 <get_datetime+0x1b2>
                        dt.tm_sec = value;
 8010a46:	68fb      	ldr	r3, [r7, #12]
 8010a48:	4a18      	ldr	r2, [pc, #96]	; (8010aac <get_datetime+0x1fc>)
 8010a4a:	6013      	str	r3, [r2, #0]
                    break;
 8010a4c:	e009      	b.n	8010a62 <get_datetime+0x1b2>
                    break;
 8010a4e:	bf00      	nop
 8010a50:	e008      	b.n	8010a64 <get_datetime+0x1b4>
                    break;
 8010a52:	bf00      	nop
 8010a54:	e006      	b.n	8010a64 <get_datetime+0x1b4>
                    break;
 8010a56:	bf00      	nop
 8010a58:	e004      	b.n	8010a64 <get_datetime+0x1b4>
                    break;
 8010a5a:	bf00      	nop
 8010a5c:	e002      	b.n	8010a64 <get_datetime+0x1b4>
                    break;
 8010a5e:	bf00      	nop
 8010a60:	e000      	b.n	8010a64 <get_datetime+0x1b4>
                    break;
 8010a62:	bf00      	nop
            }
            idx++;
 8010a64:	693b      	ldr	r3, [r7, #16]
 8010a66:	3301      	adds	r3, #1
 8010a68:	613b      	str	r3, [r7, #16]
            value = 0;
 8010a6a:	2300      	movs	r3, #0
 8010a6c:	60fb      	str	r3, [r7, #12]
        }
    } while(c);
 8010a6e:	7afb      	ldrb	r3, [r7, #11]
 8010a70:	2b00      	cmp	r3, #0
 8010a72:	f47f af44 	bne.w	80108fe <get_datetime+0x4e>

    return (dt.tm_year | dt.tm_mon | dt.tm_mday | dt.tm_hour | dt.tm_min | dt.tm_sec) > 0 ? &dt : NULL;
 8010a76:	4b0d      	ldr	r3, [pc, #52]	; (8010aac <get_datetime+0x1fc>)
 8010a78:	695a      	ldr	r2, [r3, #20]
 8010a7a:	4b0c      	ldr	r3, [pc, #48]	; (8010aac <get_datetime+0x1fc>)
 8010a7c:	691b      	ldr	r3, [r3, #16]
 8010a7e:	431a      	orrs	r2, r3
 8010a80:	4b0a      	ldr	r3, [pc, #40]	; (8010aac <get_datetime+0x1fc>)
 8010a82:	68db      	ldr	r3, [r3, #12]
 8010a84:	431a      	orrs	r2, r3
 8010a86:	4b09      	ldr	r3, [pc, #36]	; (8010aac <get_datetime+0x1fc>)
 8010a88:	689b      	ldr	r3, [r3, #8]
 8010a8a:	431a      	orrs	r2, r3
 8010a8c:	4b07      	ldr	r3, [pc, #28]	; (8010aac <get_datetime+0x1fc>)
 8010a8e:	685b      	ldr	r3, [r3, #4]
 8010a90:	431a      	orrs	r2, r3
 8010a92:	4b06      	ldr	r3, [pc, #24]	; (8010aac <get_datetime+0x1fc>)
 8010a94:	681b      	ldr	r3, [r3, #0]
 8010a96:	4313      	orrs	r3, r2
 8010a98:	2b00      	cmp	r3, #0
 8010a9a:	dd01      	ble.n	8010aa0 <get_datetime+0x1f0>
 8010a9c:	4b03      	ldr	r3, [pc, #12]	; (8010aac <get_datetime+0x1fc>)
 8010a9e:	e000      	b.n	8010aa2 <get_datetime+0x1f2>
 8010aa0:	2300      	movs	r3, #0
}
 8010aa2:	4618      	mov	r0, r3
 8010aa4:	3718      	adds	r7, #24
 8010aa6:	46bd      	mov	sp, r7
 8010aa8:	bd80      	pop	{r7, pc}
 8010aaa:	bf00      	nop
 8010aac:	200010c4 	.word	0x200010c4
 8010ab0:	08032e2d 	.word	0x08032e2d
 8010ab4:	08031038 	.word	0x08031038

08010ab8 <calc_checksum>:

// calculate checksum byte for data
uint8_t calc_checksum (uint8_t *data, uint32_t size) {
 8010ab8:	b480      	push	{r7}
 8010aba:	b085      	sub	sp, #20
 8010abc:	af00      	add	r7, sp, #0
 8010abe:	6078      	str	r0, [r7, #4]
 8010ac0:	6039      	str	r1, [r7, #0]

    uint8_t checksum = 0;
 8010ac2:	2300      	movs	r3, #0
 8010ac4:	73fb      	strb	r3, [r7, #15]

    while(size--) {
 8010ac6:	e010      	b.n	8010aea <calc_checksum+0x32>
        checksum = (checksum << 1) | (checksum >> 7);
 8010ac8:	7bfb      	ldrb	r3, [r7, #15]
 8010aca:	005b      	lsls	r3, r3, #1
 8010acc:	b25a      	sxtb	r2, r3
 8010ace:	7bfb      	ldrb	r3, [r7, #15]
 8010ad0:	09db      	lsrs	r3, r3, #7
 8010ad2:	b2db      	uxtb	r3, r3
 8010ad4:	b25b      	sxtb	r3, r3
 8010ad6:	4313      	orrs	r3, r2
 8010ad8:	b25b      	sxtb	r3, r3
 8010ada:	73fb      	strb	r3, [r7, #15]
        checksum += *(data++);
 8010adc:	687b      	ldr	r3, [r7, #4]
 8010ade:	1c5a      	adds	r2, r3, #1
 8010ae0:	607a      	str	r2, [r7, #4]
 8010ae2:	781a      	ldrb	r2, [r3, #0]
 8010ae4:	7bfb      	ldrb	r3, [r7, #15]
 8010ae6:	4413      	add	r3, r2
 8010ae8:	73fb      	strb	r3, [r7, #15]
    while(size--) {
 8010aea:	683b      	ldr	r3, [r7, #0]
 8010aec:	1e5a      	subs	r2, r3, #1
 8010aee:	603a      	str	r2, [r7, #0]
 8010af0:	2b00      	cmp	r3, #0
 8010af2:	d1e9      	bne.n	8010ac8 <calc_checksum+0x10>
    }

    return checksum;
 8010af4:	7bfb      	ldrb	r3, [r7, #15]
}
 8010af6:	4618      	mov	r0, r3
 8010af8:	3714      	adds	r7, #20
 8010afa:	46bd      	mov	sp, r7
 8010afc:	bc80      	pop	{r7}
 8010afe:	4770      	bx	lr

08010b00 <dummy_handler>:

    return s;
}

void dummy_handler (void)
{
 8010b00:	b480      	push	{r7}
 8010b02:	af00      	add	r7, sp, #0
    // NOOP
}
 8010b04:	bf00      	nop
 8010b06:	46bd      	mov	sp, r7
 8010b08:	bc80      	pop	{r7}
 8010b0a:	4770      	bx	lr

08010b0c <ram_get_byte>:
#endif
    {0, 0, 0} // list termination - do not remove
};

inline static uint8_t ram_get_byte (uint32_t addr)
{
 8010b0c:	b480      	push	{r7}
 8010b0e:	b083      	sub	sp, #12
 8010b10:	af00      	add	r7, sp, #0
 8010b12:	6078      	str	r0, [r7, #4]
    return nvsbuffer[addr];
 8010b14:	4b04      	ldr	r3, [pc, #16]	; (8010b28 <ram_get_byte+0x1c>)
 8010b16:	681a      	ldr	r2, [r3, #0]
 8010b18:	687b      	ldr	r3, [r7, #4]
 8010b1a:	4413      	add	r3, r2
 8010b1c:	781b      	ldrb	r3, [r3, #0]
}
 8010b1e:	4618      	mov	r0, r3
 8010b20:	370c      	adds	r7, #12
 8010b22:	46bd      	mov	sp, r7
 8010b24:	bc80      	pop	{r7}
 8010b26:	4770      	bx	lr
 8010b28:	200010e8 	.word	0x200010e8

08010b2c <ram_put_byte>:

inline static void ram_put_byte (uint32_t addr, uint8_t new_value)
{
 8010b2c:	b480      	push	{r7}
 8010b2e:	b083      	sub	sp, #12
 8010b30:	af00      	add	r7, sp, #0
 8010b32:	6078      	str	r0, [r7, #4]
 8010b34:	460b      	mov	r3, r1
 8010b36:	70fb      	strb	r3, [r7, #3]
    if(addr == 0)
 8010b38:	687b      	ldr	r3, [r7, #4]
 8010b3a:	2b00      	cmp	r3, #0
 8010b3c:	d102      	bne.n	8010b44 <ram_put_byte+0x18>
        settings_dirty.version = true;
 8010b3e:	4b12      	ldr	r3, [pc, #72]	; (8010b88 <ram_put_byte+0x5c>)
 8010b40:	2201      	movs	r2, #1
 8010b42:	705a      	strb	r2, [r3, #1]
    dirty = dirty || nvsbuffer[addr] != new_value || addr == 0;
 8010b44:	4b11      	ldr	r3, [pc, #68]	; (8010b8c <ram_put_byte+0x60>)
 8010b46:	781b      	ldrb	r3, [r3, #0]
 8010b48:	2b00      	cmp	r3, #0
 8010b4a:	d10a      	bne.n	8010b62 <ram_put_byte+0x36>
 8010b4c:	4b10      	ldr	r3, [pc, #64]	; (8010b90 <ram_put_byte+0x64>)
 8010b4e:	681a      	ldr	r2, [r3, #0]
 8010b50:	687b      	ldr	r3, [r7, #4]
 8010b52:	4413      	add	r3, r2
 8010b54:	781b      	ldrb	r3, [r3, #0]
 8010b56:	78fa      	ldrb	r2, [r7, #3]
 8010b58:	429a      	cmp	r2, r3
 8010b5a:	d102      	bne.n	8010b62 <ram_put_byte+0x36>
 8010b5c:	687b      	ldr	r3, [r7, #4]
 8010b5e:	2b00      	cmp	r3, #0
 8010b60:	d101      	bne.n	8010b66 <ram_put_byte+0x3a>
 8010b62:	2301      	movs	r3, #1
 8010b64:	e000      	b.n	8010b68 <ram_put_byte+0x3c>
 8010b66:	2300      	movs	r3, #0
 8010b68:	f003 0301 	and.w	r3, r3, #1
 8010b6c:	b2da      	uxtb	r2, r3
 8010b6e:	4b07      	ldr	r3, [pc, #28]	; (8010b8c <ram_put_byte+0x60>)
 8010b70:	701a      	strb	r2, [r3, #0]
    nvsbuffer[addr] = new_value;
 8010b72:	4b07      	ldr	r3, [pc, #28]	; (8010b90 <ram_put_byte+0x64>)
 8010b74:	681a      	ldr	r2, [r3, #0]
 8010b76:	687b      	ldr	r3, [r7, #4]
 8010b78:	4413      	add	r3, r2
 8010b7a:	78fa      	ldrb	r2, [r7, #3]
 8010b7c:	701a      	strb	r2, [r3, #0]
}
 8010b7e:	bf00      	nop
 8010b80:	370c      	adds	r7, #12
 8010b82:	46bd      	mov	sp, r7
 8010b84:	bc80      	pop	{r7}
 8010b86:	4770      	bx	lr
 8010b88:	2000111c 	.word	0x2000111c
 8010b8c:	20001118 	.word	0x20001118
 8010b90:	200010e8 	.word	0x200010e8

08010b94 <memcpy_to_ram>:

static nvs_transfer_result_t memcpy_to_ram (uint32_t destination, uint8_t *source, uint32_t size, bool with_checksum)
{
 8010b94:	b590      	push	{r4, r7, lr}
 8010b96:	b087      	sub	sp, #28
 8010b98:	af00      	add	r7, sp, #0
 8010b9a:	60f8      	str	r0, [r7, #12]
 8010b9c:	60b9      	str	r1, [r7, #8]
 8010b9e:	607a      	str	r2, [r7, #4]
 8010ba0:	70fb      	strb	r3, [r7, #3]
    if(hal.nvs.driver_area.address && destination > hal.nvs.driver_area.address + hal.nvs.driver_area.size)
 8010ba2:	4b66      	ldr	r3, [pc, #408]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010ba4:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010ba8:	2b00      	cmp	r3, #0
 8010baa:	d014      	beq.n	8010bd6 <memcpy_to_ram+0x42>
 8010bac:	4b63      	ldr	r3, [pc, #396]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010bae:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010bb2:	461a      	mov	r2, r3
 8010bb4:	4b61      	ldr	r3, [pc, #388]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010bb6:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 8010bba:	4413      	add	r3, r2
 8010bbc:	461a      	mov	r2, r3
 8010bbe:	68fb      	ldr	r3, [r7, #12]
 8010bc0:	4293      	cmp	r3, r2
 8010bc2:	d908      	bls.n	8010bd6 <memcpy_to_ram+0x42>
        return physical_nvs.memcpy_to_nvs(destination, source, size, with_checksum);
 8010bc4:	4b5e      	ldr	r3, [pc, #376]	; (8010d40 <memcpy_to_ram+0x1ac>)
 8010bc6:	69dc      	ldr	r4, [r3, #28]
 8010bc8:	78fb      	ldrb	r3, [r7, #3]
 8010bca:	687a      	ldr	r2, [r7, #4]
 8010bcc:	68b9      	ldr	r1, [r7, #8]
 8010bce:	68f8      	ldr	r0, [r7, #12]
 8010bd0:	47a0      	blx	r4
 8010bd2:	4603      	mov	r3, r0
 8010bd4:	e0ad      	b.n	8010d32 <memcpy_to_ram+0x19e>

    uint32_t dest = destination;
 8010bd6:	68fb      	ldr	r3, [r7, #12]
 8010bd8:	617b      	str	r3, [r7, #20]
    uint8_t checksum = with_checksum ? calc_checksum(source, size) : 0;
 8010bda:	78fb      	ldrb	r3, [r7, #3]
 8010bdc:	2b00      	cmp	r3, #0
 8010bde:	d005      	beq.n	8010bec <memcpy_to_ram+0x58>
 8010be0:	6879      	ldr	r1, [r7, #4]
 8010be2:	68b8      	ldr	r0, [r7, #8]
 8010be4:	f7ff ff68 	bl	8010ab8 <calc_checksum>
 8010be8:	4603      	mov	r3, r0
 8010bea:	e000      	b.n	8010bee <memcpy_to_ram+0x5a>
 8010bec:	2300      	movs	r3, #0
 8010bee:	74bb      	strb	r3, [r7, #18]

    dirty = false;
 8010bf0:	4b54      	ldr	r3, [pc, #336]	; (8010d44 <memcpy_to_ram+0x1b0>)
 8010bf2:	2200      	movs	r2, #0
 8010bf4:	701a      	strb	r2, [r3, #0]

    for(; size > 0; size--)
 8010bf6:	e00d      	b.n	8010c14 <memcpy_to_ram+0x80>
        ram_put_byte(dest++, *(source++));
 8010bf8:	697a      	ldr	r2, [r7, #20]
 8010bfa:	1c53      	adds	r3, r2, #1
 8010bfc:	617b      	str	r3, [r7, #20]
 8010bfe:	68bb      	ldr	r3, [r7, #8]
 8010c00:	1c59      	adds	r1, r3, #1
 8010c02:	60b9      	str	r1, [r7, #8]
 8010c04:	781b      	ldrb	r3, [r3, #0]
 8010c06:	4619      	mov	r1, r3
 8010c08:	4610      	mov	r0, r2
 8010c0a:	f7ff ff8f 	bl	8010b2c <ram_put_byte>
    for(; size > 0; size--)
 8010c0e:	687b      	ldr	r3, [r7, #4]
 8010c10:	3b01      	subs	r3, #1
 8010c12:	607b      	str	r3, [r7, #4]
 8010c14:	687b      	ldr	r3, [r7, #4]
 8010c16:	2b00      	cmp	r3, #0
 8010c18:	d1ee      	bne.n	8010bf8 <memcpy_to_ram+0x64>

    if(with_checksum)
 8010c1a:	78fb      	ldrb	r3, [r7, #3]
 8010c1c:	2b00      	cmp	r3, #0
 8010c1e:	d004      	beq.n	8010c2a <memcpy_to_ram+0x96>
        ram_put_byte(dest, checksum);
 8010c20:	7cbb      	ldrb	r3, [r7, #18]
 8010c22:	4619      	mov	r1, r3
 8010c24:	6978      	ldr	r0, [r7, #20]
 8010c26:	f7ff ff81 	bl	8010b2c <ram_put_byte>

    if(settings_dirty.version || source == hal.nvs.driver_area.mem_address)
 8010c2a:	4b47      	ldr	r3, [pc, #284]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010c2c:	785b      	ldrb	r3, [r3, #1]
 8010c2e:	2b00      	cmp	r3, #0
 8010c30:	d105      	bne.n	8010c3e <memcpy_to_ram+0xaa>
 8010c32:	4b42      	ldr	r3, [pc, #264]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010c34:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 8010c38:	68ba      	ldr	r2, [r7, #8]
 8010c3a:	429a      	cmp	r2, r3
 8010c3c:	d102      	bne.n	8010c44 <memcpy_to_ram+0xb0>
        dirty = true;
 8010c3e:	4b41      	ldr	r3, [pc, #260]	; (8010d44 <memcpy_to_ram+0x1b0>)
 8010c40:	2201      	movs	r2, #1
 8010c42:	701a      	strb	r2, [r3, #0]

    if(dirty && physical_nvs.type != NVS_None) {
 8010c44:	4b3f      	ldr	r3, [pc, #252]	; (8010d44 <memcpy_to_ram+0x1b0>)
 8010c46:	781b      	ldrb	r3, [r3, #0]
 8010c48:	2b00      	cmp	r3, #0
 8010c4a:	d071      	beq.n	8010d30 <memcpy_to_ram+0x19c>
 8010c4c:	4b3c      	ldr	r3, [pc, #240]	; (8010d40 <memcpy_to_ram+0x1ac>)
 8010c4e:	781b      	ldrb	r3, [r3, #0]
 8010c50:	2b00      	cmp	r3, #0
 8010c52:	d06d      	beq.n	8010d30 <memcpy_to_ram+0x19c>

        uint8_t idx = 0;
 8010c54:	2300      	movs	r3, #0
 8010c56:	74fb      	strb	r3, [r7, #19]

        settings_dirty.is_dirty = true;
 8010c58:	4b3b      	ldr	r3, [pc, #236]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010c5a:	2201      	movs	r2, #1
 8010c5c:	701a      	strb	r2, [r3, #0]

        if(hal.nvs.driver_area.address && destination >= hal.nvs.driver_area.address)
 8010c5e:	4b37      	ldr	r3, [pc, #220]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010c60:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010c64:	2b00      	cmp	r3, #0
 8010c66:	d00a      	beq.n	8010c7e <memcpy_to_ram+0xea>
 8010c68:	4b34      	ldr	r3, [pc, #208]	; (8010d3c <memcpy_to_ram+0x1a8>)
 8010c6a:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010c6e:	461a      	mov	r2, r3
 8010c70:	68fb      	ldr	r3, [r7, #12]
 8010c72:	4293      	cmp	r3, r2
 8010c74:	d303      	bcc.n	8010c7e <memcpy_to_ram+0xea>
            settings_dirty.driver_settings = true;
 8010c76:	4b34      	ldr	r3, [pc, #208]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010c78:	2201      	movs	r2, #1
 8010c7a:	711a      	strb	r2, [r3, #4]
 8010c7c:	e058      	b.n	8010d30 <memcpy_to_ram+0x19c>

        else {

            do {
                if(target[idx].addr == destination)
 8010c7e:	7cfb      	ldrb	r3, [r7, #19]
 8010c80:	4a32      	ldr	r2, [pc, #200]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010c82:	f832 3023 	ldrh.w	r3, [r2, r3, lsl #2]
 8010c86:	461a      	mov	r2, r3
 8010c88:	68fb      	ldr	r3, [r7, #12]
 8010c8a:	4293      	cmp	r3, r2
 8010c8c:	d009      	beq.n	8010ca2 <memcpy_to_ram+0x10e>
                    break;
            } while(target[++idx].addr);
 8010c8e:	7cfb      	ldrb	r3, [r7, #19]
 8010c90:	3301      	adds	r3, #1
 8010c92:	74fb      	strb	r3, [r7, #19]
 8010c94:	7cfb      	ldrb	r3, [r7, #19]
 8010c96:	4a2d      	ldr	r2, [pc, #180]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010c98:	f832 3023 	ldrh.w	r3, [r2, r3, lsl #2]
 8010c9c:	2b00      	cmp	r3, #0
 8010c9e:	d1ee      	bne.n	8010c7e <memcpy_to_ram+0xea>
 8010ca0:	e000      	b.n	8010ca4 <memcpy_to_ram+0x110>
                    break;
 8010ca2:	bf00      	nop

            if(target[idx].addr) switch(target[idx].type) {
 8010ca4:	7cfb      	ldrb	r3, [r7, #19]
 8010ca6:	4a29      	ldr	r2, [pc, #164]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010ca8:	f832 3023 	ldrh.w	r3, [r2, r3, lsl #2]
 8010cac:	2b00      	cmp	r3, #0
 8010cae:	d03f      	beq.n	8010d30 <memcpy_to_ram+0x19c>
 8010cb0:	7cfb      	ldrb	r3, [r7, #19]
 8010cb2:	4a26      	ldr	r2, [pc, #152]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010cb4:	009b      	lsls	r3, r3, #2
 8010cb6:	4413      	add	r3, r2
 8010cb8:	789b      	ldrb	r3, [r3, #2]
 8010cba:	2b04      	cmp	r3, #4
 8010cbc:	d838      	bhi.n	8010d30 <memcpy_to_ram+0x19c>
 8010cbe:	a201      	add	r2, pc, #4	; (adr r2, 8010cc4 <memcpy_to_ram+0x130>)
 8010cc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010cc4:	08010cd9 	.word	0x08010cd9
 8010cc8:	08010d31 	.word	0x08010d31
 8010ccc:	08010ce1 	.word	0x08010ce1
 8010cd0:	08010d05 	.word	0x08010d05
 8010cd4:	08010d29 	.word	0x08010d29

                case NVS_GROUP_GLOBAL:
                    settings_dirty.global_settings = true;
 8010cd8:	4b1b      	ldr	r3, [pc, #108]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010cda:	2201      	movs	r2, #1
 8010cdc:	709a      	strb	r2, [r3, #2]
                    break;
 8010cde:	e027      	b.n	8010d30 <memcpy_to_ram+0x19c>
                case NVS_GROUP_TOOLS:
                    settings_dirty.tool_data |= (1 << target[idx].offset);
                    break;
#endif
                case NVS_GROUP_PARAMETERS:
                    settings_dirty.coord_data |= (1 << target[idx].offset);
 8010ce0:	4b19      	ldr	r3, [pc, #100]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010ce2:	88db      	ldrh	r3, [r3, #6]
 8010ce4:	b21a      	sxth	r2, r3
 8010ce6:	7cfb      	ldrb	r3, [r7, #19]
 8010ce8:	4918      	ldr	r1, [pc, #96]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010cea:	009b      	lsls	r3, r3, #2
 8010cec:	440b      	add	r3, r1
 8010cee:	78db      	ldrb	r3, [r3, #3]
 8010cf0:	4619      	mov	r1, r3
 8010cf2:	2301      	movs	r3, #1
 8010cf4:	408b      	lsls	r3, r1
 8010cf6:	b21b      	sxth	r3, r3
 8010cf8:	4313      	orrs	r3, r2
 8010cfa:	b21b      	sxth	r3, r3
 8010cfc:	b29a      	uxth	r2, r3
 8010cfe:	4b12      	ldr	r3, [pc, #72]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010d00:	80da      	strh	r2, [r3, #6]
                    break;
 8010d02:	e015      	b.n	8010d30 <memcpy_to_ram+0x19c>

                case NVS_GROUP_STARTUP:
                    settings_dirty.startup_lines |= (1 << target[idx].offset);
 8010d04:	4b10      	ldr	r3, [pc, #64]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010d06:	795b      	ldrb	r3, [r3, #5]
 8010d08:	b25a      	sxtb	r2, r3
 8010d0a:	7cfb      	ldrb	r3, [r7, #19]
 8010d0c:	490f      	ldr	r1, [pc, #60]	; (8010d4c <memcpy_to_ram+0x1b8>)
 8010d0e:	009b      	lsls	r3, r3, #2
 8010d10:	440b      	add	r3, r1
 8010d12:	78db      	ldrb	r3, [r3, #3]
 8010d14:	4619      	mov	r1, r3
 8010d16:	2301      	movs	r3, #1
 8010d18:	408b      	lsls	r3, r1
 8010d1a:	b25b      	sxtb	r3, r3
 8010d1c:	4313      	orrs	r3, r2
 8010d1e:	b25b      	sxtb	r3, r3
 8010d20:	b2da      	uxtb	r2, r3
 8010d22:	4b09      	ldr	r3, [pc, #36]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010d24:	715a      	strb	r2, [r3, #5]
                    break;
 8010d26:	e003      	b.n	8010d30 <memcpy_to_ram+0x19c>

                case NVS_GROUP_BUILD:
                    settings_dirty.build_info = true;
 8010d28:	4b07      	ldr	r3, [pc, #28]	; (8010d48 <memcpy_to_ram+0x1b4>)
 8010d2a:	2201      	movs	r2, #1
 8010d2c:	70da      	strb	r2, [r3, #3]
                    break;
 8010d2e:	bf00      	nop
            }
        }
    }

    return NVS_TransferResult_OK;
 8010d30:	2302      	movs	r3, #2
}
 8010d32:	4618      	mov	r0, r3
 8010d34:	371c      	adds	r7, #28
 8010d36:	46bd      	mov	sp, r7
 8010d38:	bd90      	pop	{r4, r7, pc}
 8010d3a:	bf00      	nop
 8010d3c:	20000ed0 	.word	0x20000ed0
 8010d40:	200010ec 	.word	0x200010ec
 8010d44:	20001118 	.word	0x20001118
 8010d48:	2000111c 	.word	0x2000111c
 8010d4c:	08031044 	.word	0x08031044

08010d50 <memcpy_from_ram>:

static nvs_transfer_result_t memcpy_from_ram (uint8_t *destination, uint32_t source, uint32_t size, bool with_checksum)
{
 8010d50:	b590      	push	{r4, r7, lr}
 8010d52:	b087      	sub	sp, #28
 8010d54:	af00      	add	r7, sp, #0
 8010d56:	60f8      	str	r0, [r7, #12]
 8010d58:	60b9      	str	r1, [r7, #8]
 8010d5a:	607a      	str	r2, [r7, #4]
 8010d5c:	70fb      	strb	r3, [r7, #3]
    if(hal.nvs.driver_area.address && source > hal.nvs.driver_area.address + hal.nvs.driver_area.size)
 8010d5e:	4b27      	ldr	r3, [pc, #156]	; (8010dfc <memcpy_from_ram+0xac>)
 8010d60:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010d64:	2b00      	cmp	r3, #0
 8010d66:	d014      	beq.n	8010d92 <memcpy_from_ram+0x42>
 8010d68:	4b24      	ldr	r3, [pc, #144]	; (8010dfc <memcpy_from_ram+0xac>)
 8010d6a:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 8010d6e:	461a      	mov	r2, r3
 8010d70:	4b22      	ldr	r3, [pc, #136]	; (8010dfc <memcpy_from_ram+0xac>)
 8010d72:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 8010d76:	4413      	add	r3, r2
 8010d78:	461a      	mov	r2, r3
 8010d7a:	68bb      	ldr	r3, [r7, #8]
 8010d7c:	4293      	cmp	r3, r2
 8010d7e:	d908      	bls.n	8010d92 <memcpy_from_ram+0x42>
        return physical_nvs.memcpy_from_nvs(destination, source, size, with_checksum);
 8010d80:	4b1f      	ldr	r3, [pc, #124]	; (8010e00 <memcpy_from_ram+0xb0>)
 8010d82:	6a1c      	ldr	r4, [r3, #32]
 8010d84:	78fb      	ldrb	r3, [r7, #3]
 8010d86:	687a      	ldr	r2, [r7, #4]
 8010d88:	68b9      	ldr	r1, [r7, #8]
 8010d8a:	68f8      	ldr	r0, [r7, #12]
 8010d8c:	47a0      	blx	r4
 8010d8e:	4603      	mov	r3, r0
 8010d90:	e030      	b.n	8010df4 <memcpy_from_ram+0xa4>

    uint8_t checksum = with_checksum ? calc_checksum(&nvsbuffer[source], size) : 0;
 8010d92:	78fb      	ldrb	r3, [r7, #3]
 8010d94:	2b00      	cmp	r3, #0
 8010d96:	d009      	beq.n	8010dac <memcpy_from_ram+0x5c>
 8010d98:	4b1a      	ldr	r3, [pc, #104]	; (8010e04 <memcpy_from_ram+0xb4>)
 8010d9a:	681a      	ldr	r2, [r3, #0]
 8010d9c:	68bb      	ldr	r3, [r7, #8]
 8010d9e:	4413      	add	r3, r2
 8010da0:	6879      	ldr	r1, [r7, #4]
 8010da2:	4618      	mov	r0, r3
 8010da4:	f7ff fe88 	bl	8010ab8 <calc_checksum>
 8010da8:	4603      	mov	r3, r0
 8010daa:	e000      	b.n	8010dae <memcpy_from_ram+0x5e>
 8010dac:	2300      	movs	r3, #0
 8010dae:	75fb      	strb	r3, [r7, #23]

    for(; size > 0; size--)
 8010db0:	e00d      	b.n	8010dce <memcpy_from_ram+0x7e>
        *(destination++) = ram_get_byte(source++);
 8010db2:	68bb      	ldr	r3, [r7, #8]
 8010db4:	1c5a      	adds	r2, r3, #1
 8010db6:	60ba      	str	r2, [r7, #8]
 8010db8:	68fc      	ldr	r4, [r7, #12]
 8010dba:	1c62      	adds	r2, r4, #1
 8010dbc:	60fa      	str	r2, [r7, #12]
 8010dbe:	4618      	mov	r0, r3
 8010dc0:	f7ff fea4 	bl	8010b0c <ram_get_byte>
 8010dc4:	4603      	mov	r3, r0
 8010dc6:	7023      	strb	r3, [r4, #0]
    for(; size > 0; size--)
 8010dc8:	687b      	ldr	r3, [r7, #4]
 8010dca:	3b01      	subs	r3, #1
 8010dcc:	607b      	str	r3, [r7, #4]
 8010dce:	687b      	ldr	r3, [r7, #4]
 8010dd0:	2b00      	cmp	r3, #0
 8010dd2:	d1ee      	bne.n	8010db2 <memcpy_from_ram+0x62>

    return with_checksum ? (checksum == ram_get_byte(source) ? NVS_TransferResult_OK : NVS_TransferResult_Failed) : NVS_TransferResult_OK;
 8010dd4:	78fb      	ldrb	r3, [r7, #3]
 8010dd6:	2b00      	cmp	r3, #0
 8010dd8:	d00b      	beq.n	8010df2 <memcpy_from_ram+0xa2>
 8010dda:	68b8      	ldr	r0, [r7, #8]
 8010ddc:	f7ff fe96 	bl	8010b0c <ram_get_byte>
 8010de0:	4603      	mov	r3, r0
 8010de2:	461a      	mov	r2, r3
 8010de4:	7dfb      	ldrb	r3, [r7, #23]
 8010de6:	4293      	cmp	r3, r2
 8010de8:	d101      	bne.n	8010dee <memcpy_from_ram+0x9e>
 8010dea:	2302      	movs	r3, #2
 8010dec:	e002      	b.n	8010df4 <memcpy_from_ram+0xa4>
 8010dee:	2300      	movs	r3, #0
 8010df0:	e000      	b.n	8010df4 <memcpy_from_ram+0xa4>
 8010df2:	2302      	movs	r3, #2
}
 8010df4:	4618      	mov	r0, r3
 8010df6:	371c      	adds	r7, #28
 8010df8:	46bd      	mov	sp, r7
 8010dfa:	bd90      	pop	{r4, r7, pc}
 8010dfc:	20000ed0 	.word	0x20000ed0
 8010e00:	200010ec 	.word	0x200010ec
 8010e04:	200010e8 	.word	0x200010e8

08010e08 <nvs_warning>:

static void nvs_warning (sys_state_t state)
{
 8010e08:	b580      	push	{r7, lr}
 8010e0a:	b082      	sub	sp, #8
 8010e0c:	af00      	add	r7, sp, #0
 8010e0e:	6078      	str	r0, [r7, #4]
    report_message("Not enough heap for NVS buffer!", Message_Warning);
 8010e10:	2102      	movs	r1, #2
 8010e12:	4803      	ldr	r0, [pc, #12]	; (8010e20 <nvs_warning+0x18>)
 8010e14:	f003 fb70 	bl	80144f8 <report_message>
}
 8010e18:	bf00      	nop
 8010e1a:	3708      	adds	r7, #8
 8010e1c:	46bd      	mov	sp, r7
 8010e1e:	bd80      	pop	{r7, pc}
 8010e20:	0802a01c 	.word	0x0802a01c

08010e24 <nvs_buffer_alloc>:

// Try to allocate RAM from heap for buffer/emulation.
bool nvs_buffer_alloc (void)
{
 8010e24:	b580      	push	{r7, lr}
 8010e26:	af00      	add	r7, sp, #0
    assert(NVS_SIZE >= GRBL_NVS_SIZE);

    if((nvsbuffer = malloc(NVS_SIZE)))
 8010e28:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8010e2c:	f012 fb44 	bl	80234b8 <malloc>
 8010e30:	4603      	mov	r3, r0
 8010e32:	461a      	mov	r2, r3
 8010e34:	4b0b      	ldr	r3, [pc, #44]	; (8010e64 <nvs_buffer_alloc+0x40>)
 8010e36:	601a      	str	r2, [r3, #0]
 8010e38:	4b0a      	ldr	r3, [pc, #40]	; (8010e64 <nvs_buffer_alloc+0x40>)
 8010e3a:	681b      	ldr	r3, [r3, #0]
 8010e3c:	2b00      	cmp	r3, #0
 8010e3e:	d007      	beq.n	8010e50 <nvs_buffer_alloc+0x2c>
        memset(nvsbuffer, 0xFF, NVS_SIZE);
 8010e40:	4b08      	ldr	r3, [pc, #32]	; (8010e64 <nvs_buffer_alloc+0x40>)
 8010e42:	681b      	ldr	r3, [r3, #0]
 8010e44:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8010e48:	21ff      	movs	r1, #255	; 0xff
 8010e4a:	4618      	mov	r0, r3
 8010e4c:	f012 fee3 	bl	8023c16 <memset>

    return nvsbuffer != NULL;
 8010e50:	4b04      	ldr	r3, [pc, #16]	; (8010e64 <nvs_buffer_alloc+0x40>)
 8010e52:	681b      	ldr	r3, [r3, #0]
 8010e54:	2b00      	cmp	r3, #0
 8010e56:	bf14      	ite	ne
 8010e58:	2301      	movne	r3, #1
 8010e5a:	2300      	moveq	r3, #0
 8010e5c:	b2db      	uxtb	r3, r3
}
 8010e5e:	4618      	mov	r0, r3
 8010e60:	bd80      	pop	{r7, pc}
 8010e62:	bf00      	nop
 8010e64:	200010e8 	.word	0x200010e8

08010e68 <nvs_buffer_free>:

void nvs_buffer_free (void)
{
 8010e68:	b580      	push	{r7, lr}
 8010e6a:	af00      	add	r7, sp, #0
    if(nvsbuffer) {
 8010e6c:	4b06      	ldr	r3, [pc, #24]	; (8010e88 <nvs_buffer_free+0x20>)
 8010e6e:	681b      	ldr	r3, [r3, #0]
 8010e70:	2b00      	cmp	r3, #0
 8010e72:	d006      	beq.n	8010e82 <nvs_buffer_free+0x1a>
        nvs_buffer_sync_physical();
 8010e74:	f000 f8ba 	bl	8010fec <nvs_buffer_sync_physical>
        free(nvsbuffer);
 8010e78:	4b03      	ldr	r3, [pc, #12]	; (8010e88 <nvs_buffer_free+0x20>)
 8010e7a:	681b      	ldr	r3, [r3, #0]
 8010e7c:	4618      	mov	r0, r3
 8010e7e:	f012 fb23 	bl	80234c8 <free>
    }
}
 8010e82:	bf00      	nop
 8010e84:	bd80      	pop	{r7, pc}
 8010e86:	bf00      	nop
 8010e88:	200010e8 	.word	0x200010e8

08010e8c <nvs_buffer_init>:
//
// Switch over to RAM based copy.
// Changes to RAM based copy will be written to physical storage when grblHAL is in IDLE state.
bool nvs_buffer_init (void)
{
 8010e8c:	b5b0      	push	{r4, r5, r7, lr}
 8010e8e:	af00      	add	r7, sp, #0
    hal.nvs.size = ((hal.nvs.size - 1) | 0x03) + 1; // Ensure NVS area ends on a word boundary
 8010e90:	4b4b      	ldr	r3, [pc, #300]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010e92:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
 8010e96:	3b01      	subs	r3, #1
 8010e98:	f043 0303 	orr.w	r3, r3, #3
 8010e9c:	3301      	adds	r3, #1
 8010e9e:	4a48      	ldr	r2, [pc, #288]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010ea0:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148

    if(nvsbuffer) {
 8010ea4:	4b47      	ldr	r3, [pc, #284]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010ea6:	681b      	ldr	r3, [r3, #0]
 8010ea8:	2b00      	cmp	r3, #0
 8010eaa:	d077      	beq.n	8010f9c <nvs_buffer_init+0x110>

        memcpy(&physical_nvs, &hal.nvs, sizeof(nvs_io_t)); // save pointers to physical storage handler functions
 8010eac:	4a46      	ldr	r2, [pc, #280]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010eae:	4b44      	ldr	r3, [pc, #272]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010eb0:	4615      	mov	r5, r2
 8010eb2:	f503 74a2 	add.w	r4, r3, #324	; 0x144
 8010eb6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8010eb8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8010eba:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8010ebc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8010ebe:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8010ec2:	e885 0007 	stmia.w	r5, {r0, r1, r2}

        // Copy physical storage content to RAM when available
        if(physical_nvs.type == NVS_Flash)
 8010ec6:	4b40      	ldr	r3, [pc, #256]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010ec8:	781b      	ldrb	r3, [r3, #0]
 8010eca:	2b03      	cmp	r3, #3
 8010ecc:	d106      	bne.n	8010edc <nvs_buffer_init+0x50>
            physical_nvs.memcpy_from_flash(nvsbuffer);
 8010ece:	4b3e      	ldr	r3, [pc, #248]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010ed0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010ed2:	4a3c      	ldr	r2, [pc, #240]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010ed4:	6812      	ldr	r2, [r2, #0]
 8010ed6:	4610      	mov	r0, r2
 8010ed8:	4798      	blx	r3
 8010eda:	e010      	b.n	8010efe <nvs_buffer_init+0x72>
        else if(physical_nvs.type != NVS_None)
 8010edc:	4b3a      	ldr	r3, [pc, #232]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010ede:	781b      	ldrb	r3, [r3, #0]
 8010ee0:	2b00      	cmp	r3, #0
 8010ee2:	d00c      	beq.n	8010efe <nvs_buffer_init+0x72>
            physical_nvs.memcpy_from_nvs(nvsbuffer, 0, GRBL_NVS_SIZE + hal.nvs.driver_area.size, false);
 8010ee4:	4b38      	ldr	r3, [pc, #224]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010ee6:	6a1c      	ldr	r4, [r3, #32]
 8010ee8:	4b36      	ldr	r3, [pc, #216]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010eea:	6818      	ldr	r0, [r3, #0]
 8010eec:	4b34      	ldr	r3, [pc, #208]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010eee:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 8010ef2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010ef6:	461a      	mov	r2, r3
 8010ef8:	2300      	movs	r3, #0
 8010efa:	2100      	movs	r1, #0
 8010efc:	47a0      	blx	r4

        // Switch hal to use RAM version of non-volatile storage data
        hal.nvs.type = NVS_Emulated;
 8010efe:	4b30      	ldr	r3, [pc, #192]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f00:	2204      	movs	r2, #4
 8010f02:	f883 2144 	strb.w	r2, [r3, #324]	; 0x144
        hal.nvs.get_byte = &ram_get_byte;
 8010f06:	4b2e      	ldr	r3, [pc, #184]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f08:	4a30      	ldr	r2, [pc, #192]	; (8010fcc <nvs_buffer_init+0x140>)
 8010f0a:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
        hal.nvs.put_byte = &ram_put_byte;
 8010f0e:	4b2c      	ldr	r3, [pc, #176]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f10:	4a2f      	ldr	r2, [pc, #188]	; (8010fd0 <nvs_buffer_init+0x144>)
 8010f12:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
        hal.nvs.memcpy_to_nvs = &memcpy_to_ram;
 8010f16:	4b2a      	ldr	r3, [pc, #168]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f18:	4a2e      	ldr	r2, [pc, #184]	; (8010fd4 <nvs_buffer_init+0x148>)
 8010f1a:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
        hal.nvs.memcpy_from_nvs = &memcpy_from_ram;
 8010f1e:	4b28      	ldr	r3, [pc, #160]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f20:	4a2d      	ldr	r2, [pc, #180]	; (8010fd8 <nvs_buffer_init+0x14c>)
 8010f22:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
        hal.nvs.memcpy_from_flash = NULL;
 8010f26:	4b26      	ldr	r3, [pc, #152]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f28:	2200      	movs	r2, #0
 8010f2a:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
        hal.nvs.memcpy_to_flash = NULL;
 8010f2e:	4b24      	ldr	r3, [pc, #144]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f30:	2200      	movs	r2, #0
 8010f32:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c

        // If no physical storage available or if NVS import fails copy default settings to RAM
        // and write out to physical storage when available.
        if(physical_nvs.type == NVS_None || ram_get_byte(0) != SETTINGS_VERSION) {
 8010f36:	4b24      	ldr	r3, [pc, #144]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f38:	781b      	ldrb	r3, [r3, #0]
 8010f3a:	2b00      	cmp	r3, #0
 8010f3c:	d005      	beq.n	8010f4a <nvs_buffer_init+0xbe>
 8010f3e:	2000      	movs	r0, #0
 8010f40:	f7ff fde4 	bl	8010b0c <ram_get_byte>
 8010f44:	4603      	mov	r3, r0
 8010f46:	2b16      	cmp	r3, #22
 8010f48:	d02b      	beq.n	8010fa2 <nvs_buffer_init+0x116>
            settings_restore(settings_all);
 8010f4a:	4b24      	ldr	r3, [pc, #144]	; (8010fdc <nvs_buffer_init+0x150>)
 8010f4c:	7818      	ldrb	r0, [r3, #0]
 8010f4e:	f009 ff2b 	bl	801ada8 <settings_restore>
            if(physical_nvs.type == NVS_Flash)
 8010f52:	4b1d      	ldr	r3, [pc, #116]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f54:	781b      	ldrb	r3, [r3, #0]
 8010f56:	2b03      	cmp	r3, #3
 8010f58:	d106      	bne.n	8010f68 <nvs_buffer_init+0xdc>
                physical_nvs.memcpy_to_flash(nvsbuffer);
 8010f5a:	4b1b      	ldr	r3, [pc, #108]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010f5e:	4a19      	ldr	r2, [pc, #100]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010f60:	6812      	ldr	r2, [r2, #0]
 8010f62:	4610      	mov	r0, r2
 8010f64:	4798      	blx	r3
 8010f66:	e010      	b.n	8010f8a <nvs_buffer_init+0xfe>
            else if(physical_nvs.memcpy_to_nvs)
 8010f68:	4b17      	ldr	r3, [pc, #92]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f6a:	69db      	ldr	r3, [r3, #28]
 8010f6c:	2b00      	cmp	r3, #0
 8010f6e:	d00c      	beq.n	8010f8a <nvs_buffer_init+0xfe>
                physical_nvs.memcpy_to_nvs(0, nvsbuffer, GRBL_NVS_SIZE + hal.nvs.driver_area.size, false);
 8010f70:	4b15      	ldr	r3, [pc, #84]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f72:	69dc      	ldr	r4, [r3, #28]
 8010f74:	4b13      	ldr	r3, [pc, #76]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010f76:	6819      	ldr	r1, [r3, #0]
 8010f78:	4b11      	ldr	r3, [pc, #68]	; (8010fc0 <nvs_buffer_init+0x134>)
 8010f7a:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 8010f7e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010f82:	461a      	mov	r2, r3
 8010f84:	2300      	movs	r3, #0
 8010f86:	2000      	movs	r0, #0
 8010f88:	47a0      	blx	r4
            if(physical_nvs.type != NVS_None)
 8010f8a:	4b0f      	ldr	r3, [pc, #60]	; (8010fc8 <nvs_buffer_init+0x13c>)
 8010f8c:	781b      	ldrb	r3, [r3, #0]
 8010f8e:	2b00      	cmp	r3, #0
 8010f90:	d007      	beq.n	8010fa2 <nvs_buffer_init+0x116>
                grbl.report.status_message(Status_SettingReadFail);
 8010f92:	4b13      	ldr	r3, [pc, #76]	; (8010fe0 <nvs_buffer_init+0x154>)
 8010f94:	689b      	ldr	r3, [r3, #8]
 8010f96:	2007      	movs	r0, #7
 8010f98:	4798      	blx	r3
 8010f9a:	e002      	b.n	8010fa2 <nvs_buffer_init+0x116>
        }
    } else
        protocol_enqueue_rt_command(nvs_warning);
 8010f9c:	4811      	ldr	r0, [pc, #68]	; (8010fe4 <nvs_buffer_init+0x158>)
 8010f9e:	f002 ff25 	bl	8013dec <protocol_enqueue_rt_command>

    // Clear settings dirty flags
    memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8010fa2:	2208      	movs	r2, #8
 8010fa4:	2100      	movs	r1, #0
 8010fa6:	4810      	ldr	r0, [pc, #64]	; (8010fe8 <nvs_buffer_init+0x15c>)
 8010fa8:	f012 fe35 	bl	8023c16 <memset>

    return nvsbuffer != NULL;
 8010fac:	4b05      	ldr	r3, [pc, #20]	; (8010fc4 <nvs_buffer_init+0x138>)
 8010fae:	681b      	ldr	r3, [r3, #0]
 8010fb0:	2b00      	cmp	r3, #0
 8010fb2:	bf14      	ite	ne
 8010fb4:	2301      	movne	r3, #1
 8010fb6:	2300      	moveq	r3, #0
 8010fb8:	b2db      	uxtb	r3, r3
}
 8010fba:	4618      	mov	r0, r3
 8010fbc:	bdb0      	pop	{r4, r5, r7, pc}
 8010fbe:	bf00      	nop
 8010fc0:	20000ed0 	.word	0x20000ed0
 8010fc4:	200010e8 	.word	0x200010e8
 8010fc8:	200010ec 	.word	0x200010ec
 8010fcc:	08010b0d 	.word	0x08010b0d
 8010fd0:	08010b2d 	.word	0x08010b2d
 8010fd4:	08010b95 	.word	0x08010b95
 8010fd8:	08010d51 	.word	0x08010d51
 8010fdc:	08031468 	.word	0x08031468
 8010fe0:	20000dd4 	.word	0x20000dd4
 8010fe4:	08010e09 	.word	0x08010e09
 8010fe8:	2000111c 	.word	0x2000111c

08010fec <nvs_buffer_sync_physical>:
    return addr;
}

// Write RAM changes to physical storage
void nvs_buffer_sync_physical (void)
{
 8010fec:	b590      	push	{r4, r7, lr}
 8010fee:	b085      	sub	sp, #20
 8010ff0:	af00      	add	r7, sp, #0
    if(!settings_dirty.is_dirty)
 8010ff2:	4b9c      	ldr	r3, [pc, #624]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8010ff4:	781b      	ldrb	r3, [r3, #0]
 8010ff6:	f083 0301 	eor.w	r3, r3, #1
 8010ffa:	b2db      	uxtb	r3, r3
 8010ffc:	2b00      	cmp	r3, #0
 8010ffe:	f040 812d 	bne.w	801125c <nvs_buffer_sync_physical+0x270>
        return;

    if(physical_nvs.memcpy_to_nvs) {
 8011002:	4b99      	ldr	r3, [pc, #612]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 8011004:	69db      	ldr	r3, [r3, #28]
 8011006:	2b00      	cmp	r3, #0
 8011008:	f000 8103 	beq.w	8011212 <nvs_buffer_sync_physical+0x226>

        if(settings_dirty.version)
 801100c:	4b95      	ldr	r3, [pc, #596]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801100e:	785b      	ldrb	r3, [r3, #1]
 8011010:	2b00      	cmp	r3, #0
 8011012:	d00f      	beq.n	8011034 <nvs_buffer_sync_physical+0x48>
            settings_dirty.version = physical_nvs.memcpy_to_nvs(0, nvsbuffer, 1, false) != NVS_TransferResult_OK;
 8011014:	4b94      	ldr	r3, [pc, #592]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 8011016:	69dc      	ldr	r4, [r3, #28]
 8011018:	4b94      	ldr	r3, [pc, #592]	; (801126c <nvs_buffer_sync_physical+0x280>)
 801101a:	6819      	ldr	r1, [r3, #0]
 801101c:	2300      	movs	r3, #0
 801101e:	2201      	movs	r2, #1
 8011020:	2000      	movs	r0, #0
 8011022:	47a0      	blx	r4
 8011024:	4603      	mov	r3, r0
 8011026:	2b02      	cmp	r3, #2
 8011028:	bf14      	ite	ne
 801102a:	2301      	movne	r3, #1
 801102c:	2300      	moveq	r3, #0
 801102e:	b2da      	uxtb	r2, r3
 8011030:	4b8c      	ldr	r3, [pc, #560]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011032:	705a      	strb	r2, [r3, #1]

        if(settings_dirty.global_settings)
 8011034:	4b8b      	ldr	r3, [pc, #556]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011036:	789b      	ldrb	r3, [r3, #2]
 8011038:	2b00      	cmp	r3, #0
 801103a:	d011      	beq.n	8011060 <nvs_buffer_sync_physical+0x74>
            settings_dirty.global_settings = physical_nvs.memcpy_to_nvs(NVS_ADDR_GLOBAL, (uint8_t *)(nvsbuffer + NVS_ADDR_GLOBAL), sizeof(settings_t) + NVS_CRC_BYTES, false) != NVS_TransferResult_OK;
 801103c:	4b8a      	ldr	r3, [pc, #552]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 801103e:	69dc      	ldr	r4, [r3, #28]
 8011040:	4b8a      	ldr	r3, [pc, #552]	; (801126c <nvs_buffer_sync_physical+0x280>)
 8011042:	681b      	ldr	r3, [r3, #0]
 8011044:	1c59      	adds	r1, r3, #1
 8011046:	2300      	movs	r3, #0
 8011048:	f240 126d 	movw	r2, #365	; 0x16d
 801104c:	2001      	movs	r0, #1
 801104e:	47a0      	blx	r4
 8011050:	4603      	mov	r3, r0
 8011052:	2b02      	cmp	r3, #2
 8011054:	bf14      	ite	ne
 8011056:	2301      	movne	r3, #1
 8011058:	2300      	moveq	r3, #0
 801105a:	b2da      	uxtb	r2, r3
 801105c:	4b81      	ldr	r3, [pc, #516]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801105e:	709a      	strb	r2, [r3, #2]

        if(settings_dirty.build_info)
 8011060:	4b80      	ldr	r3, [pc, #512]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011062:	78db      	ldrb	r3, [r3, #3]
 8011064:	2b00      	cmp	r3, #0
 8011066:	d012      	beq.n	801108e <nvs_buffer_sync_physical+0xa2>
            settings_dirty.build_info = physical_nvs.memcpy_to_nvs(NVS_ADDR_BUILD_INFO, (uint8_t *)(nvsbuffer + NVS_ADDR_BUILD_INFO), sizeof(stored_line_t) + NVS_CRC_BYTES, false) != NVS_TransferResult_OK;
 8011068:	4b7f      	ldr	r3, [pc, #508]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 801106a:	69dc      	ldr	r4, [r3, #28]
 801106c:	4b7f      	ldr	r3, [pc, #508]	; (801126c <nvs_buffer_sync_physical+0x280>)
 801106e:	681b      	ldr	r3, [r3, #0]
 8011070:	f203 31ae 	addw	r1, r3, #942	; 0x3ae
 8011074:	2300      	movs	r3, #0
 8011076:	2247      	movs	r2, #71	; 0x47
 8011078:	f240 30ae 	movw	r0, #942	; 0x3ae
 801107c:	47a0      	blx	r4
 801107e:	4603      	mov	r3, r0
 8011080:	2b02      	cmp	r3, #2
 8011082:	bf14      	ite	ne
 8011084:	2301      	movne	r3, #1
 8011086:	2300      	moveq	r3, #0
 8011088:	b2da      	uxtb	r2, r3
 801108a:	4b76      	ldr	r3, [pc, #472]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801108c:	70da      	strb	r2, [r3, #3]

        uint_fast8_t idx = N_STARTUP_LINE, offset;
 801108e:	2302      	movs	r3, #2
 8011090:	60fb      	str	r3, [r7, #12]
        if(settings_dirty.startup_lines) do {
 8011092:	4b74      	ldr	r3, [pc, #464]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011094:	795b      	ldrb	r3, [r3, #5]
 8011096:	2b00      	cmp	r3, #0
 8011098:	d03f      	beq.n	801111a <nvs_buffer_sync_physical+0x12e>
            idx--;
 801109a:	68fb      	ldr	r3, [r7, #12]
 801109c:	3b01      	subs	r3, #1
 801109e:	60fb      	str	r3, [r7, #12]
            if(bit_istrue(settings_dirty.startup_lines, bit(idx))) {
 80110a0:	4b70      	ldr	r3, [pc, #448]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80110a2:	795b      	ldrb	r3, [r3, #5]
 80110a4:	461a      	mov	r2, r3
 80110a6:	68fb      	ldr	r3, [r7, #12]
 80110a8:	fa22 f303 	lsr.w	r3, r2, r3
 80110ac:	f003 0301 	and.w	r3, r3, #1
 80110b0:	2b00      	cmp	r3, #0
 80110b2:	d02f      	beq.n	8011114 <nvs_buffer_sync_physical+0x128>
                bit_false(settings_dirty.startup_lines, bit(idx));
 80110b4:	4b6b      	ldr	r3, [pc, #428]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80110b6:	795a      	ldrb	r2, [r3, #5]
 80110b8:	2101      	movs	r1, #1
 80110ba:	68fb      	ldr	r3, [r7, #12]
 80110bc:	fa01 f303 	lsl.w	r3, r1, r3
 80110c0:	b2db      	uxtb	r3, r3
 80110c2:	43db      	mvns	r3, r3
 80110c4:	b2db      	uxtb	r3, r3
 80110c6:	4013      	ands	r3, r2
 80110c8:	b2da      	uxtb	r2, r3
 80110ca:	4b66      	ldr	r3, [pc, #408]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80110cc:	715a      	strb	r2, [r3, #5]
                offset = NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES);
 80110ce:	68fa      	ldr	r2, [r7, #12]
 80110d0:	4613      	mov	r3, r2
 80110d2:	00db      	lsls	r3, r3, #3
 80110d4:	4413      	add	r3, r2
 80110d6:	00db      	lsls	r3, r3, #3
 80110d8:	1a9b      	subs	r3, r3, r2
 80110da:	f203 331f 	addw	r3, r3, #799	; 0x31f
 80110de:	607b      	str	r3, [r7, #4]
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(stored_line_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
 80110e0:	4b61      	ldr	r3, [pc, #388]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 80110e2:	69dc      	ldr	r4, [r3, #28]
 80110e4:	4b61      	ldr	r3, [pc, #388]	; (801126c <nvs_buffer_sync_physical+0x280>)
 80110e6:	681a      	ldr	r2, [r3, #0]
 80110e8:	687b      	ldr	r3, [r7, #4]
 80110ea:	18d1      	adds	r1, r2, r3
 80110ec:	2300      	movs	r3, #0
 80110ee:	2247      	movs	r2, #71	; 0x47
 80110f0:	6878      	ldr	r0, [r7, #4]
 80110f2:	47a0      	blx	r4
 80110f4:	4603      	mov	r3, r0
 80110f6:	2b02      	cmp	r3, #2
 80110f8:	d10c      	bne.n	8011114 <nvs_buffer_sync_physical+0x128>
                    bit_false(settings_dirty.startup_lines, bit(idx));
 80110fa:	4b5a      	ldr	r3, [pc, #360]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80110fc:	795a      	ldrb	r2, [r3, #5]
 80110fe:	2101      	movs	r1, #1
 8011100:	68fb      	ldr	r3, [r7, #12]
 8011102:	fa01 f303 	lsl.w	r3, r1, r3
 8011106:	b2db      	uxtb	r3, r3
 8011108:	43db      	mvns	r3, r3
 801110a:	b2db      	uxtb	r3, r3
 801110c:	4013      	ands	r3, r2
 801110e:	b2da      	uxtb	r2, r3
 8011110:	4b54      	ldr	r3, [pc, #336]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011112:	715a      	strb	r2, [r3, #5]
            }
        } while(idx);
 8011114:	68fb      	ldr	r3, [r7, #12]
 8011116:	2b00      	cmp	r3, #0
 8011118:	d1bf      	bne.n	801109a <nvs_buffer_sync_physical+0xae>

        idx = N_CoordinateSystems;
 801111a:	230c      	movs	r3, #12
 801111c:	60fb      	str	r3, [r7, #12]
        if(settings_dirty.coord_data) do {
 801111e:	4b51      	ldr	r3, [pc, #324]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011120:	88db      	ldrh	r3, [r3, #6]
 8011122:	2b00      	cmp	r3, #0
 8011124:	d031      	beq.n	801118a <nvs_buffer_sync_physical+0x19e>
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
 8011126:	4b4f      	ldr	r3, [pc, #316]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011128:	88db      	ldrh	r3, [r3, #6]
 801112a:	461a      	mov	r2, r3
 801112c:	68fb      	ldr	r3, [r7, #12]
 801112e:	fa22 f303 	lsr.w	r3, r2, r3
 8011132:	f003 0301 	and.w	r3, r3, #1
 8011136:	2b00      	cmp	r3, #0
 8011138:	d022      	beq.n	8011180 <nvs_buffer_sync_physical+0x194>
                offset = NVS_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + NVS_CRC_BYTES);
 801113a:	68fa      	ldr	r2, [r7, #12]
 801113c:	4613      	mov	r3, r2
 801113e:	005b      	lsls	r3, r3, #1
 8011140:	4413      	add	r3, r2
 8011142:	009b      	lsls	r3, r3, #2
 8011144:	4413      	add	r3, r2
 8011146:	f503 7300 	add.w	r3, r3, #512	; 0x200
 801114a:	607b      	str	r3, [r7, #4]
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(coord_data_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
 801114c:	4b46      	ldr	r3, [pc, #280]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 801114e:	69dc      	ldr	r4, [r3, #28]
 8011150:	4b46      	ldr	r3, [pc, #280]	; (801126c <nvs_buffer_sync_physical+0x280>)
 8011152:	681a      	ldr	r2, [r3, #0]
 8011154:	687b      	ldr	r3, [r7, #4]
 8011156:	18d1      	adds	r1, r2, r3
 8011158:	2300      	movs	r3, #0
 801115a:	220d      	movs	r2, #13
 801115c:	6878      	ldr	r0, [r7, #4]
 801115e:	47a0      	blx	r4
 8011160:	4603      	mov	r3, r0
 8011162:	2b02      	cmp	r3, #2
 8011164:	d10c      	bne.n	8011180 <nvs_buffer_sync_physical+0x194>
                    bit_false(settings_dirty.coord_data, bit(idx));
 8011166:	4b3f      	ldr	r3, [pc, #252]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011168:	88da      	ldrh	r2, [r3, #6]
 801116a:	2101      	movs	r1, #1
 801116c:	68fb      	ldr	r3, [r7, #12]
 801116e:	fa01 f303 	lsl.w	r3, r1, r3
 8011172:	b29b      	uxth	r3, r3
 8011174:	43db      	mvns	r3, r3
 8011176:	b29b      	uxth	r3, r3
 8011178:	4013      	ands	r3, r2
 801117a:	b29a      	uxth	r2, r3
 801117c:	4b39      	ldr	r3, [pc, #228]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801117e:	80da      	strh	r2, [r3, #6]
            }
        } while(idx--);
 8011180:	68fb      	ldr	r3, [r7, #12]
 8011182:	1e5a      	subs	r2, r3, #1
 8011184:	60fa      	str	r2, [r7, #12]
 8011186:	2b00      	cmp	r3, #0
 8011188:	d1cd      	bne.n	8011126 <nvs_buffer_sync_physical+0x13a>

        if(settings_dirty.driver_settings) {
 801118a:	4b36      	ldr	r3, [pc, #216]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801118c:	791b      	ldrb	r3, [r3, #4]
 801118e:	2b00      	cmp	r3, #0
 8011190:	d022      	beq.n	80111d8 <nvs_buffer_sync_physical+0x1ec>
            if(hal.nvs.driver_area.size > 0)
 8011192:	4b37      	ldr	r3, [pc, #220]	; (8011270 <nvs_buffer_sync_physical+0x284>)
 8011194:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 8011198:	2b00      	cmp	r3, #0
 801119a:	d01a      	beq.n	80111d2 <nvs_buffer_sync_physical+0x1e6>
                settings_dirty.driver_settings = physical_nvs.memcpy_to_nvs(hal.nvs.driver_area.address, (uint8_t *)(nvsbuffer + hal.nvs.driver_area.address), hal.nvs.driver_area.size, false) != NVS_TransferResult_OK;
 801119c:	4b32      	ldr	r3, [pc, #200]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 801119e:	69dc      	ldr	r4, [r3, #28]
 80111a0:	4b33      	ldr	r3, [pc, #204]	; (8011270 <nvs_buffer_sync_physical+0x284>)
 80111a2:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
 80111a6:	4618      	mov	r0, r3
 80111a8:	4b30      	ldr	r3, [pc, #192]	; (801126c <nvs_buffer_sync_physical+0x280>)
 80111aa:	681b      	ldr	r3, [r3, #0]
 80111ac:	4a30      	ldr	r2, [pc, #192]	; (8011270 <nvs_buffer_sync_physical+0x284>)
 80111ae:	f8b2 2154 	ldrh.w	r2, [r2, #340]	; 0x154
 80111b2:	1899      	adds	r1, r3, r2
 80111b4:	4b2e      	ldr	r3, [pc, #184]	; (8011270 <nvs_buffer_sync_physical+0x284>)
 80111b6:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
 80111ba:	461a      	mov	r2, r3
 80111bc:	2300      	movs	r3, #0
 80111be:	47a0      	blx	r4
 80111c0:	4603      	mov	r3, r0
 80111c2:	2b02      	cmp	r3, #2
 80111c4:	bf14      	ite	ne
 80111c6:	2301      	movne	r3, #1
 80111c8:	2300      	moveq	r3, #0
 80111ca:	b2da      	uxtb	r2, r3
 80111cc:	4b25      	ldr	r3, [pc, #148]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111ce:	711a      	strb	r2, [r3, #4]
 80111d0:	e002      	b.n	80111d8 <nvs_buffer_sync_physical+0x1ec>
            else
                settings_dirty.driver_settings = false;
 80111d2:	4b24      	ldr	r3, [pc, #144]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111d4:	2200      	movs	r2, #0
 80111d6:	711a      	strb	r2, [r3, #4]
                if(physical_nvs.memcpy_to_nvs(offset, (uint8_t *)(nvsbuffer + offset), sizeof(tool_data_t) + NVS_CRC_BYTES, false) == NVS_TransferResult_OK)
                    bit_false(settings_dirty.tool_data, bit(idx));
            }
        } while(idx);
#endif
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 80111d8:	4b22      	ldr	r3, [pc, #136]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111da:	88db      	ldrh	r3, [r3, #6]
                                   settings_dirty.global_settings ||
                                    settings_dirty.driver_settings ||
                                     settings_dirty.startup_lines ||
 80111dc:	2b00      	cmp	r3, #0
 80111de:	d10f      	bne.n	8011200 <nvs_buffer_sync_physical+0x214>
                                   settings_dirty.global_settings ||
 80111e0:	4b20      	ldr	r3, [pc, #128]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111e2:	789b      	ldrb	r3, [r3, #2]
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 80111e4:	2b00      	cmp	r3, #0
 80111e6:	d10b      	bne.n	8011200 <nvs_buffer_sync_physical+0x214>
                                    settings_dirty.driver_settings ||
 80111e8:	4b1e      	ldr	r3, [pc, #120]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111ea:	791b      	ldrb	r3, [r3, #4]
                                   settings_dirty.global_settings ||
 80111ec:	2b00      	cmp	r3, #0
 80111ee:	d107      	bne.n	8011200 <nvs_buffer_sync_physical+0x214>
                                     settings_dirty.startup_lines ||
 80111f0:	4b1c      	ldr	r3, [pc, #112]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111f2:	795b      	ldrb	r3, [r3, #5]
                                    settings_dirty.driver_settings ||
 80111f4:	2b00      	cmp	r3, #0
 80111f6:	d103      	bne.n	8011200 <nvs_buffer_sync_physical+0x214>
#if N_TOOLS
                                      settings_dirty.tool_data ||
#endif
                                       settings_dirty.build_info;
 80111f8:	4b1a      	ldr	r3, [pc, #104]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 80111fa:	78db      	ldrb	r3, [r3, #3]
                                     settings_dirty.startup_lines ||
 80111fc:	2b00      	cmp	r3, #0
 80111fe:	d001      	beq.n	8011204 <nvs_buffer_sync_physical+0x218>
 8011200:	2301      	movs	r3, #1
 8011202:	e000      	b.n	8011206 <nvs_buffer_sync_physical+0x21a>
 8011204:	2300      	movs	r3, #0
 8011206:	f003 0301 	and.w	r3, r3, #1
 801120a:	b2da      	uxtb	r2, r3
        settings_dirty.is_dirty = settings_dirty.coord_data ||
 801120c:	4b15      	ldr	r3, [pc, #84]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 801120e:	701a      	strb	r2, [r3, #0]
 8011210:	e025      	b.n	801125e <nvs_buffer_sync_physical+0x272>

    } else if(physical_nvs.memcpy_to_flash) {
 8011212:	4b15      	ldr	r3, [pc, #84]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 8011214:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011216:	2b00      	cmp	r3, #0
 8011218:	d021      	beq.n	801125e <nvs_buffer_sync_physical+0x272>
        uint_fast8_t retries = 4;
 801121a:	2304      	movs	r3, #4
 801121c:	60bb      	str	r3, [r7, #8]
        do {
            if(physical_nvs.memcpy_to_flash(nvsbuffer))
 801121e:	4b12      	ldr	r3, [pc, #72]	; (8011268 <nvs_buffer_sync_physical+0x27c>)
 8011220:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011222:	4a12      	ldr	r2, [pc, #72]	; (801126c <nvs_buffer_sync_physical+0x280>)
 8011224:	6812      	ldr	r2, [r2, #0]
 8011226:	4610      	mov	r0, r2
 8011228:	4798      	blx	r3
 801122a:	4603      	mov	r3, r0
 801122c:	2b00      	cmp	r3, #0
 801122e:	d002      	beq.n	8011236 <nvs_buffer_sync_physical+0x24a>
                retries = 0;
 8011230:	2300      	movs	r3, #0
 8011232:	60bb      	str	r3, [r7, #8]
 8011234:	e009      	b.n	801124a <nvs_buffer_sync_physical+0x25e>
            else if(--retries == 0)
 8011236:	68bb      	ldr	r3, [r7, #8]
 8011238:	3b01      	subs	r3, #1
 801123a:	60bb      	str	r3, [r7, #8]
 801123c:	68bb      	ldr	r3, [r7, #8]
 801123e:	2b00      	cmp	r3, #0
 8011240:	d103      	bne.n	801124a <nvs_buffer_sync_physical+0x25e>
                report_message("Settings write failed!", Message_Warning);
 8011242:	2102      	movs	r1, #2
 8011244:	480b      	ldr	r0, [pc, #44]	; (8011274 <nvs_buffer_sync_physical+0x288>)
 8011246:	f003 f957 	bl	80144f8 <report_message>
        } while(retries);
 801124a:	68bb      	ldr	r3, [r7, #8]
 801124c:	2b00      	cmp	r3, #0
 801124e:	d1e6      	bne.n	801121e <nvs_buffer_sync_physical+0x232>
        memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8011250:	2208      	movs	r2, #8
 8011252:	2100      	movs	r1, #0
 8011254:	4803      	ldr	r0, [pc, #12]	; (8011264 <nvs_buffer_sync_physical+0x278>)
 8011256:	f012 fcde 	bl	8023c16 <memset>
 801125a:	e000      	b.n	801125e <nvs_buffer_sync_physical+0x272>
        return;
 801125c:	bf00      	nop
    }
}
 801125e:	3714      	adds	r7, #20
 8011260:	46bd      	mov	sp, r7
 8011262:	bd90      	pop	{r4, r7, pc}
 8011264:	2000111c 	.word	0x2000111c
 8011268:	200010ec 	.word	0x200010ec
 801126c:	200010e8 	.word	0x200010e8
 8011270:	20000ed0 	.word	0x20000ed0
 8011274:	0802a03c 	.word	0x0802a03c

08011278 <nvs_buffer_get_physical>:

nvs_io_t *nvs_buffer_get_physical (void)
{
 8011278:	b480      	push	{r7}
 801127a:	af00      	add	r7, sp, #0
    return hal.nvs.type == NVS_Emulated ? &physical_nvs : &hal.nvs;
 801127c:	4b05      	ldr	r3, [pc, #20]	; (8011294 <nvs_buffer_get_physical+0x1c>)
 801127e:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 8011282:	2b04      	cmp	r3, #4
 8011284:	d101      	bne.n	801128a <nvs_buffer_get_physical+0x12>
 8011286:	4b04      	ldr	r3, [pc, #16]	; (8011298 <nvs_buffer_get_physical+0x20>)
 8011288:	e000      	b.n	801128c <nvs_buffer_get_physical+0x14>
 801128a:	4b04      	ldr	r3, [pc, #16]	; (801129c <nvs_buffer_get_physical+0x24>)
}
 801128c:	4618      	mov	r0, r3
 801128e:	46bd      	mov	sp, r7
 8011290:	bc80      	pop	{r7}
 8011292:	4770      	bx	lr
 8011294:	20000ed0 	.word	0x20000ed0
 8011298:	200010ec 	.word	0x200010ec
 801129c:	20001014 	.word	0x20001014

080112a0 <enqueue_feed_override>:
} override_queue_t;

static override_queue_t feed = {0}, spindle = {0}, coolant = {0};

ISR_CODE void ISR_FUNC(enqueue_feed_override)(uint8_t cmd)
{
 80112a0:	b480      	push	{r7}
 80112a2:	b085      	sub	sp, #20
 80112a4:	af00      	add	r7, sp, #0
 80112a6:	4603      	mov	r3, r0
 80112a8:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = (feed.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 80112aa:	4b0c      	ldr	r3, [pc, #48]	; (80112dc <enqueue_feed_override+0x3c>)
 80112ac:	681b      	ldr	r3, [r3, #0]
 80112ae:	3301      	adds	r3, #1
 80112b0:	f003 030f 	and.w	r3, r3, #15
 80112b4:	60fb      	str	r3, [r7, #12]

    if(bptr != feed.tail) {         // If not buffer full
 80112b6:	4b09      	ldr	r3, [pc, #36]	; (80112dc <enqueue_feed_override+0x3c>)
 80112b8:	685b      	ldr	r3, [r3, #4]
 80112ba:	68fa      	ldr	r2, [r7, #12]
 80112bc:	429a      	cmp	r2, r3
 80112be:	d008      	beq.n	80112d2 <enqueue_feed_override+0x32>
        feed.buf[feed.head] = cmd;  // add data to buffer
 80112c0:	4b06      	ldr	r3, [pc, #24]	; (80112dc <enqueue_feed_override+0x3c>)
 80112c2:	681b      	ldr	r3, [r3, #0]
 80112c4:	4a05      	ldr	r2, [pc, #20]	; (80112dc <enqueue_feed_override+0x3c>)
 80112c6:	4413      	add	r3, r2
 80112c8:	79fa      	ldrb	r2, [r7, #7]
 80112ca:	721a      	strb	r2, [r3, #8]
        feed.head = bptr;           // and update pointer
 80112cc:	4a03      	ldr	r2, [pc, #12]	; (80112dc <enqueue_feed_override+0x3c>)
 80112ce:	68fb      	ldr	r3, [r7, #12]
 80112d0:	6013      	str	r3, [r2, #0]
    }
}
 80112d2:	bf00      	nop
 80112d4:	3714      	adds	r7, #20
 80112d6:	46bd      	mov	sp, r7
 80112d8:	bc80      	pop	{r7}
 80112da:	4770      	bx	lr
 80112dc:	20001124 	.word	0x20001124

080112e0 <get_feed_override>:

// Returns 0 if no commands enqueued
uint8_t get_feed_override (void)
{
 80112e0:	b480      	push	{r7}
 80112e2:	b083      	sub	sp, #12
 80112e4:	af00      	add	r7, sp, #0
    uint8_t data = 0;
 80112e6:	2300      	movs	r3, #0
 80112e8:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = feed.tail;
 80112ea:	4b0d      	ldr	r3, [pc, #52]	; (8011320 <get_feed_override+0x40>)
 80112ec:	685b      	ldr	r3, [r3, #4]
 80112ee:	603b      	str	r3, [r7, #0]

    if(bptr != feed.head) {
 80112f0:	4b0b      	ldr	r3, [pc, #44]	; (8011320 <get_feed_override+0x40>)
 80112f2:	681b      	ldr	r3, [r3, #0]
 80112f4:	683a      	ldr	r2, [r7, #0]
 80112f6:	429a      	cmp	r2, r3
 80112f8:	d00b      	beq.n	8011312 <get_feed_override+0x32>
        data = feed.buf[bptr++];                    // Get next character, increment tmp pointer
 80112fa:	683b      	ldr	r3, [r7, #0]
 80112fc:	1c5a      	adds	r2, r3, #1
 80112fe:	603a      	str	r2, [r7, #0]
 8011300:	4a07      	ldr	r2, [pc, #28]	; (8011320 <get_feed_override+0x40>)
 8011302:	4413      	add	r3, r2
 8011304:	7a1b      	ldrb	r3, [r3, #8]
 8011306:	71fb      	strb	r3, [r7, #7]
        feed.tail = bptr & (OVERRIDE_BUFSIZE - 1);  // and update pointer
 8011308:	683b      	ldr	r3, [r7, #0]
 801130a:	f003 030f 	and.w	r3, r3, #15
 801130e:	4a04      	ldr	r2, [pc, #16]	; (8011320 <get_feed_override+0x40>)
 8011310:	6053      	str	r3, [r2, #4]
    }

    return data;
 8011312:	79fb      	ldrb	r3, [r7, #7]
}
 8011314:	4618      	mov	r0, r3
 8011316:	370c      	adds	r7, #12
 8011318:	46bd      	mov	sp, r7
 801131a:	bc80      	pop	{r7}
 801131c:	4770      	bx	lr
 801131e:	bf00      	nop
 8011320:	20001124 	.word	0x20001124

08011324 <enqueue_spindle_override>:

ISR_CODE void ISR_FUNC(enqueue_spindle_override)(uint8_t cmd)
{
 8011324:	b480      	push	{r7}
 8011326:	b085      	sub	sp, #20
 8011328:	af00      	add	r7, sp, #0
 801132a:	4603      	mov	r3, r0
 801132c:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = (spindle.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 801132e:	4b0c      	ldr	r3, [pc, #48]	; (8011360 <enqueue_spindle_override+0x3c>)
 8011330:	681b      	ldr	r3, [r3, #0]
 8011332:	3301      	adds	r3, #1
 8011334:	f003 030f 	and.w	r3, r3, #15
 8011338:	60fb      	str	r3, [r7, #12]

    if(bptr != spindle.tail) {              // If not buffer full
 801133a:	4b09      	ldr	r3, [pc, #36]	; (8011360 <enqueue_spindle_override+0x3c>)
 801133c:	685b      	ldr	r3, [r3, #4]
 801133e:	68fa      	ldr	r2, [r7, #12]
 8011340:	429a      	cmp	r2, r3
 8011342:	d008      	beq.n	8011356 <enqueue_spindle_override+0x32>
        spindle.buf[spindle.head] = cmd;    // add data to buffer
 8011344:	4b06      	ldr	r3, [pc, #24]	; (8011360 <enqueue_spindle_override+0x3c>)
 8011346:	681b      	ldr	r3, [r3, #0]
 8011348:	4a05      	ldr	r2, [pc, #20]	; (8011360 <enqueue_spindle_override+0x3c>)
 801134a:	4413      	add	r3, r2
 801134c:	79fa      	ldrb	r2, [r7, #7]
 801134e:	721a      	strb	r2, [r3, #8]
        spindle.head = bptr;                // and update pointer
 8011350:	4a03      	ldr	r2, [pc, #12]	; (8011360 <enqueue_spindle_override+0x3c>)
 8011352:	68fb      	ldr	r3, [r7, #12]
 8011354:	6013      	str	r3, [r2, #0]
    }
}
 8011356:	bf00      	nop
 8011358:	3714      	adds	r7, #20
 801135a:	46bd      	mov	sp, r7
 801135c:	bc80      	pop	{r7}
 801135e:	4770      	bx	lr
 8011360:	2000113c 	.word	0x2000113c

08011364 <get_spindle_override>:

// Returns 0 if no commands enqueued
uint8_t get_spindle_override (void)
{
 8011364:	b480      	push	{r7}
 8011366:	b083      	sub	sp, #12
 8011368:	af00      	add	r7, sp, #0
    uint8_t data = 0;
 801136a:	2300      	movs	r3, #0
 801136c:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = spindle.tail;
 801136e:	4b0d      	ldr	r3, [pc, #52]	; (80113a4 <get_spindle_override+0x40>)
 8011370:	685b      	ldr	r3, [r3, #4]
 8011372:	603b      	str	r3, [r7, #0]

    if(bptr != spindle.head) {
 8011374:	4b0b      	ldr	r3, [pc, #44]	; (80113a4 <get_spindle_override+0x40>)
 8011376:	681b      	ldr	r3, [r3, #0]
 8011378:	683a      	ldr	r2, [r7, #0]
 801137a:	429a      	cmp	r2, r3
 801137c:	d00b      	beq.n	8011396 <get_spindle_override+0x32>
        data = spindle.buf[bptr++];                     // Get next character, increment tmp pointer
 801137e:	683b      	ldr	r3, [r7, #0]
 8011380:	1c5a      	adds	r2, r3, #1
 8011382:	603a      	str	r2, [r7, #0]
 8011384:	4a07      	ldr	r2, [pc, #28]	; (80113a4 <get_spindle_override+0x40>)
 8011386:	4413      	add	r3, r2
 8011388:	7a1b      	ldrb	r3, [r3, #8]
 801138a:	71fb      	strb	r3, [r7, #7]
        spindle.tail = bptr & (OVERRIDE_BUFSIZE - 1);   // and update pointer
 801138c:	683b      	ldr	r3, [r7, #0]
 801138e:	f003 030f 	and.w	r3, r3, #15
 8011392:	4a04      	ldr	r2, [pc, #16]	; (80113a4 <get_spindle_override+0x40>)
 8011394:	6053      	str	r3, [r2, #4]
    }

    return data;
 8011396:	79fb      	ldrb	r3, [r7, #7]
}
 8011398:	4618      	mov	r0, r3
 801139a:	370c      	adds	r7, #12
 801139c:	46bd      	mov	sp, r7
 801139e:	bc80      	pop	{r7}
 80113a0:	4770      	bx	lr
 80113a2:	bf00      	nop
 80113a4:	2000113c 	.word	0x2000113c

080113a8 <enqueue_coolant_override>:

ISR_CODE void ISR_FUNC(enqueue_coolant_override)(uint8_t cmd)
{
 80113a8:	b480      	push	{r7}
 80113aa:	b085      	sub	sp, #20
 80113ac:	af00      	add	r7, sp, #0
 80113ae:	4603      	mov	r3, r0
 80113b0:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = (coolant.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 80113b2:	4b0c      	ldr	r3, [pc, #48]	; (80113e4 <enqueue_coolant_override+0x3c>)
 80113b4:	681b      	ldr	r3, [r3, #0]
 80113b6:	3301      	adds	r3, #1
 80113b8:	f003 030f 	and.w	r3, r3, #15
 80113bc:	60fb      	str	r3, [r7, #12]

    if(bptr != coolant.tail) {              // If not buffer full
 80113be:	4b09      	ldr	r3, [pc, #36]	; (80113e4 <enqueue_coolant_override+0x3c>)
 80113c0:	685b      	ldr	r3, [r3, #4]
 80113c2:	68fa      	ldr	r2, [r7, #12]
 80113c4:	429a      	cmp	r2, r3
 80113c6:	d008      	beq.n	80113da <enqueue_coolant_override+0x32>
        coolant.buf[coolant.head] = cmd;    // add data to buffer
 80113c8:	4b06      	ldr	r3, [pc, #24]	; (80113e4 <enqueue_coolant_override+0x3c>)
 80113ca:	681b      	ldr	r3, [r3, #0]
 80113cc:	4a05      	ldr	r2, [pc, #20]	; (80113e4 <enqueue_coolant_override+0x3c>)
 80113ce:	4413      	add	r3, r2
 80113d0:	79fa      	ldrb	r2, [r7, #7]
 80113d2:	721a      	strb	r2, [r3, #8]
        coolant.head = bptr;                // and update pointer
 80113d4:	4a03      	ldr	r2, [pc, #12]	; (80113e4 <enqueue_coolant_override+0x3c>)
 80113d6:	68fb      	ldr	r3, [r7, #12]
 80113d8:	6013      	str	r3, [r2, #0]
    }
}
 80113da:	bf00      	nop
 80113dc:	3714      	adds	r7, #20
 80113de:	46bd      	mov	sp, r7
 80113e0:	bc80      	pop	{r7}
 80113e2:	4770      	bx	lr
 80113e4:	20001154 	.word	0x20001154

080113e8 <get_coolant_override>:

// Returns 0 if no commands enqueued
uint8_t get_coolant_override (void)
{
 80113e8:	b480      	push	{r7}
 80113ea:	b083      	sub	sp, #12
 80113ec:	af00      	add	r7, sp, #0
    uint8_t data = 0;
 80113ee:	2300      	movs	r3, #0
 80113f0:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t bptr = coolant.tail;
 80113f2:	4b0d      	ldr	r3, [pc, #52]	; (8011428 <get_coolant_override+0x40>)
 80113f4:	685b      	ldr	r3, [r3, #4]
 80113f6:	603b      	str	r3, [r7, #0]

    if(bptr != coolant.head) {
 80113f8:	4b0b      	ldr	r3, [pc, #44]	; (8011428 <get_coolant_override+0x40>)
 80113fa:	681b      	ldr	r3, [r3, #0]
 80113fc:	683a      	ldr	r2, [r7, #0]
 80113fe:	429a      	cmp	r2, r3
 8011400:	d00b      	beq.n	801141a <get_coolant_override+0x32>
        data = coolant.buf[bptr++];                   // Get next character, increment tmp pointer
 8011402:	683b      	ldr	r3, [r7, #0]
 8011404:	1c5a      	adds	r2, r3, #1
 8011406:	603a      	str	r2, [r7, #0]
 8011408:	4a07      	ldr	r2, [pc, #28]	; (8011428 <get_coolant_override+0x40>)
 801140a:	4413      	add	r3, r2
 801140c:	7a1b      	ldrb	r3, [r3, #8]
 801140e:	71fb      	strb	r3, [r7, #7]
        coolant.tail = bptr & (OVERRIDE_BUFSIZE - 1); // and update pointer
 8011410:	683b      	ldr	r3, [r7, #0]
 8011412:	f003 030f 	and.w	r3, r3, #15
 8011416:	4a04      	ldr	r2, [pc, #16]	; (8011428 <get_coolant_override+0x40>)
 8011418:	6053      	str	r3, [r2, #4]
    }

    return data;
 801141a:	79fb      	ldrb	r3, [r7, #7]
}
 801141c:	4618      	mov	r0, r3
 801141e:	370c      	adds	r7, #12
 8011420:	46bd      	mov	sp, r7
 8011422:	bc80      	pop	{r7}
 8011424:	4770      	bx	lr
 8011426:	bf00      	nop
 8011428:	20001154 	.word	0x20001154

0801142c <flush_override_buffers>:

void flush_override_buffers (void)
{
 801142c:	b480      	push	{r7}
 801142e:	af00      	add	r7, sp, #0
    feed.head = feed.tail = spindle.head = spindle.tail = coolant.head = coolant.tail = 0;
 8011430:	2300      	movs	r3, #0
 8011432:	4a08      	ldr	r2, [pc, #32]	; (8011454 <flush_override_buffers+0x28>)
 8011434:	6053      	str	r3, [r2, #4]
 8011436:	4a07      	ldr	r2, [pc, #28]	; (8011454 <flush_override_buffers+0x28>)
 8011438:	6013      	str	r3, [r2, #0]
 801143a:	4a07      	ldr	r2, [pc, #28]	; (8011458 <flush_override_buffers+0x2c>)
 801143c:	6053      	str	r3, [r2, #4]
 801143e:	4a06      	ldr	r2, [pc, #24]	; (8011458 <flush_override_buffers+0x2c>)
 8011440:	6013      	str	r3, [r2, #0]
 8011442:	4a06      	ldr	r2, [pc, #24]	; (801145c <flush_override_buffers+0x30>)
 8011444:	6053      	str	r3, [r2, #4]
 8011446:	4a05      	ldr	r2, [pc, #20]	; (801145c <flush_override_buffers+0x30>)
 8011448:	6013      	str	r3, [r2, #0]
}
 801144a:	bf00      	nop
 801144c:	46bd      	mov	sp, r7
 801144e:	bc80      	pop	{r7}
 8011450:	4770      	bx	lr
 8011452:	bf00      	nop
 8011454:	20001154 	.word	0x20001154
 8011458:	2000113c 	.word	0x2000113c
 801145c:	20001124 	.word	0x20001124

08011460 <planner_recalculate>:
  to compute an optimal plan, so select carefully. ARM versions should have enough memory and speed for
  look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate (void)
{
 8011460:	b590      	push	{r4, r7, lr}
 8011462:	b085      	sub	sp, #20
 8011464:	af00      	add	r7, sp, #0
    // Initialize block pointer to the last block in the planner buffer.
    plan_block_t *block = block_buffer_head->prev;
 8011466:	4b72      	ldr	r3, [pc, #456]	; (8011630 <planner_recalculate+0x1d0>)
 8011468:	681b      	ldr	r3, [r3, #0]
 801146a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801146c:	60fb      	str	r3, [r7, #12]

    // Bail. Can't do anything with one only one plan-able block.
    if (block == block_buffer_planned)
 801146e:	4b71      	ldr	r3, [pc, #452]	; (8011634 <planner_recalculate+0x1d4>)
 8011470:	681b      	ldr	r3, [r3, #0]
 8011472:	68fa      	ldr	r2, [r7, #12]
 8011474:	429a      	cmp	r2, r3
 8011476:	f000 80d7 	beq.w	8011628 <planner_recalculate+0x1c8>
    // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
    // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
    // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
    float entry_speed_sqr;
    plan_block_t *next;
    plan_block_t *current = block;
 801147a:	68fb      	ldr	r3, [r7, #12]
 801147c:	607b      	str	r3, [r7, #4]

    // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 801147e:	687b      	ldr	r3, [r7, #4]
 8011480:	6a1c      	ldr	r4, [r3, #32]
 8011482:	687b      	ldr	r3, [r7, #4]
 8011484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011486:	4619      	mov	r1, r3
 8011488:	4618      	mov	r0, r3
 801148a:	f7ef fb8b 	bl	8000ba4 <__addsf3>
 801148e:	4603      	mov	r3, r0
 8011490:	461a      	mov	r2, r3
 8011492:	687b      	ldr	r3, [r7, #4]
 8011494:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011496:	4619      	mov	r1, r3
 8011498:	4610      	mov	r0, r2
 801149a:	f7ef fc8b 	bl	8000db4 <__aeabi_fmul>
 801149e:	4603      	mov	r3, r0
 80114a0:	4619      	mov	r1, r3
 80114a2:	4620      	mov	r0, r4
 80114a4:	f7ef fe24 	bl	80010f0 <__aeabi_fcmplt>
 80114a8:	4603      	mov	r3, r0
 80114aa:	2b00      	cmp	r3, #0
 80114ac:	d002      	beq.n	80114b4 <planner_recalculate+0x54>
 80114ae:	687b      	ldr	r3, [r7, #4]
 80114b0:	6a1b      	ldr	r3, [r3, #32]
 80114b2:	e00e      	b.n	80114d2 <planner_recalculate+0x72>
 80114b4:	687b      	ldr	r3, [r7, #4]
 80114b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80114b8:	4619      	mov	r1, r3
 80114ba:	4618      	mov	r0, r3
 80114bc:	f7ef fb72 	bl	8000ba4 <__addsf3>
 80114c0:	4603      	mov	r3, r0
 80114c2:	461a      	mov	r2, r3
 80114c4:	687b      	ldr	r3, [r7, #4]
 80114c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80114c8:	4619      	mov	r1, r3
 80114ca:	4610      	mov	r0, r2
 80114cc:	f7ef fc72 	bl	8000db4 <__aeabi_fmul>
 80114d0:	4603      	mov	r3, r0
 80114d2:	687a      	ldr	r2, [r7, #4]
 80114d4:	61d3      	str	r3, [r2, #28]

    block = block->prev;
 80114d6:	68fb      	ldr	r3, [r7, #12]
 80114d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80114da:	60fb      	str	r3, [r7, #12]
    if (block == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 80114dc:	4b55      	ldr	r3, [pc, #340]	; (8011634 <planner_recalculate+0x1d4>)
 80114de:	681b      	ldr	r3, [r3, #0]
 80114e0:	68fa      	ldr	r2, [r7, #12]
 80114e2:	429a      	cmp	r2, r3
 80114e4:	d147      	bne.n	8011576 <planner_recalculate+0x116>
        // Check if the first block is the tail. If so, notify stepper to update its current parameters.
        if (block == block_buffer_tail)
 80114e6:	4b54      	ldr	r3, [pc, #336]	; (8011638 <planner_recalculate+0x1d8>)
 80114e8:	681b      	ldr	r3, [r3, #0]
 80114ea:	68fa      	ldr	r2, [r7, #12]
 80114ec:	429a      	cmp	r2, r3
 80114ee:	d147      	bne.n	8011580 <planner_recalculate+0x120>
            st_update_plan_block_parameters();
 80114f0:	f00d fe48 	bl	801f184 <st_update_plan_block_parameters>
 80114f4:	e044      	b.n	8011580 <planner_recalculate+0x120>
    } else while (block != block_buffer_planned) { // Three or more plan-able blocks

        next = current;
 80114f6:	687b      	ldr	r3, [r7, #4]
 80114f8:	60bb      	str	r3, [r7, #8]
        current = block;
 80114fa:	68fb      	ldr	r3, [r7, #12]
 80114fc:	607b      	str	r3, [r7, #4]
        block = block->prev;
 80114fe:	68fb      	ldr	r3, [r7, #12]
 8011500:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011502:	60fb      	str	r3, [r7, #12]

        // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
        if (block == block_buffer_tail)
 8011504:	4b4c      	ldr	r3, [pc, #304]	; (8011638 <planner_recalculate+0x1d8>)
 8011506:	681b      	ldr	r3, [r3, #0]
 8011508:	68fa      	ldr	r2, [r7, #12]
 801150a:	429a      	cmp	r2, r3
 801150c:	d101      	bne.n	8011512 <planner_recalculate+0xb2>
            st_update_plan_block_parameters();
 801150e:	f00d fe39 	bl	801f184 <st_update_plan_block_parameters>

        // Compute maximum entry speed decelerating over the current block from its exit speed.
        if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 8011512:	687b      	ldr	r3, [r7, #4]
 8011514:	69da      	ldr	r2, [r3, #28]
 8011516:	687b      	ldr	r3, [r7, #4]
 8011518:	6a1b      	ldr	r3, [r3, #32]
 801151a:	4619      	mov	r1, r3
 801151c:	4610      	mov	r0, r2
 801151e:	f7ef fddd 	bl	80010dc <__aeabi_fcmpeq>
 8011522:	4603      	mov	r3, r0
 8011524:	2b00      	cmp	r3, #0
 8011526:	d000      	beq.n	801152a <planner_recalculate+0xca>
 8011528:	e025      	b.n	8011576 <planner_recalculate+0x116>
            entry_speed_sqr = next->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 801152a:	68bb      	ldr	r3, [r7, #8]
 801152c:	69dc      	ldr	r4, [r3, #28]
 801152e:	687b      	ldr	r3, [r7, #4]
 8011530:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011532:	4619      	mov	r1, r3
 8011534:	4618      	mov	r0, r3
 8011536:	f7ef fb35 	bl	8000ba4 <__addsf3>
 801153a:	4603      	mov	r3, r0
 801153c:	461a      	mov	r2, r3
 801153e:	687b      	ldr	r3, [r7, #4]
 8011540:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011542:	4619      	mov	r1, r3
 8011544:	4610      	mov	r0, r2
 8011546:	f7ef fc35 	bl	8000db4 <__aeabi_fmul>
 801154a:	4603      	mov	r3, r0
 801154c:	4619      	mov	r1, r3
 801154e:	4620      	mov	r0, r4
 8011550:	f7ef fb28 	bl	8000ba4 <__addsf3>
 8011554:	4603      	mov	r3, r0
 8011556:	603b      	str	r3, [r7, #0]
            current->entry_speed_sqr = entry_speed_sqr < current->max_entry_speed_sqr ? entry_speed_sqr : current->max_entry_speed_sqr;
 8011558:	687b      	ldr	r3, [r7, #4]
 801155a:	6a1b      	ldr	r3, [r3, #32]
 801155c:	4619      	mov	r1, r3
 801155e:	6838      	ldr	r0, [r7, #0]
 8011560:	f7ef fdc6 	bl	80010f0 <__aeabi_fcmplt>
 8011564:	4603      	mov	r3, r0
 8011566:	2b00      	cmp	r3, #0
 8011568:	d001      	beq.n	801156e <planner_recalculate+0x10e>
 801156a:	683b      	ldr	r3, [r7, #0]
 801156c:	e001      	b.n	8011572 <planner_recalculate+0x112>
 801156e:	687b      	ldr	r3, [r7, #4]
 8011570:	6a1b      	ldr	r3, [r3, #32]
 8011572:	687a      	ldr	r2, [r7, #4]
 8011574:	61d3      	str	r3, [r2, #28]
    } else while (block != block_buffer_planned) { // Three or more plan-able blocks
 8011576:	4b2f      	ldr	r3, [pc, #188]	; (8011634 <planner_recalculate+0x1d4>)
 8011578:	681b      	ldr	r3, [r3, #0]
 801157a:	68fa      	ldr	r2, [r7, #12]
 801157c:	429a      	cmp	r2, r3
 801157e:	d1ba      	bne.n	80114f6 <planner_recalculate+0x96>
        }
    }

    // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
    // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
    next = block_buffer_planned; // Begin at buffer planned pointer
 8011580:	4b2c      	ldr	r3, [pc, #176]	; (8011634 <planner_recalculate+0x1d4>)
 8011582:	681b      	ldr	r3, [r3, #0]
 8011584:	60bb      	str	r3, [r7, #8]
    block = block_buffer_planned->next;
 8011586:	4b2b      	ldr	r3, [pc, #172]	; (8011634 <planner_recalculate+0x1d4>)
 8011588:	681b      	ldr	r3, [r3, #0]
 801158a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801158c:	60fb      	str	r3, [r7, #12]

    while (block != block_buffer_head) {
 801158e:	e045      	b.n	801161c <planner_recalculate+0x1bc>

        current = next;
 8011590:	68bb      	ldr	r3, [r7, #8]
 8011592:	607b      	str	r3, [r7, #4]
        next = block;
 8011594:	68fb      	ldr	r3, [r7, #12]
 8011596:	60bb      	str	r3, [r7, #8]

        // Any acceleration detected in the forward pass automatically moves the optimal planned
        // pointer forward, since everything before this is all optimal. In other words, nothing
        // can improve the plan from the buffer tail to the planned pointer by logic.
        if (current->entry_speed_sqr < next->entry_speed_sqr) {
 8011598:	687b      	ldr	r3, [r7, #4]
 801159a:	69da      	ldr	r2, [r3, #28]
 801159c:	68bb      	ldr	r3, [r7, #8]
 801159e:	69db      	ldr	r3, [r3, #28]
 80115a0:	4619      	mov	r1, r3
 80115a2:	4610      	mov	r0, r2
 80115a4:	f7ef fda4 	bl	80010f0 <__aeabi_fcmplt>
 80115a8:	4603      	mov	r3, r0
 80115aa:	2b00      	cmp	r3, #0
 80115ac:	d025      	beq.n	80115fa <planner_recalculate+0x19a>
            entry_speed_sqr = current->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 80115ae:	687b      	ldr	r3, [r7, #4]
 80115b0:	69dc      	ldr	r4, [r3, #28]
 80115b2:	687b      	ldr	r3, [r7, #4]
 80115b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80115b6:	4619      	mov	r1, r3
 80115b8:	4618      	mov	r0, r3
 80115ba:	f7ef faf3 	bl	8000ba4 <__addsf3>
 80115be:	4603      	mov	r3, r0
 80115c0:	461a      	mov	r2, r3
 80115c2:	687b      	ldr	r3, [r7, #4]
 80115c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80115c6:	4619      	mov	r1, r3
 80115c8:	4610      	mov	r0, r2
 80115ca:	f7ef fbf3 	bl	8000db4 <__aeabi_fmul>
 80115ce:	4603      	mov	r3, r0
 80115d0:	4619      	mov	r1, r3
 80115d2:	4620      	mov	r0, r4
 80115d4:	f7ef fae6 	bl	8000ba4 <__addsf3>
 80115d8:	4603      	mov	r3, r0
 80115da:	603b      	str	r3, [r7, #0]
        // If true, current block is full-acceleration and we can move the planned pointer forward.
            if (entry_speed_sqr < next->entry_speed_sqr) {
 80115dc:	68bb      	ldr	r3, [r7, #8]
 80115de:	69db      	ldr	r3, [r3, #28]
 80115e0:	4619      	mov	r1, r3
 80115e2:	6838      	ldr	r0, [r7, #0]
 80115e4:	f7ef fd84 	bl	80010f0 <__aeabi_fcmplt>
 80115e8:	4603      	mov	r3, r0
 80115ea:	2b00      	cmp	r3, #0
 80115ec:	d005      	beq.n	80115fa <planner_recalculate+0x19a>
                next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 80115ee:	68bb      	ldr	r3, [r7, #8]
 80115f0:	683a      	ldr	r2, [r7, #0]
 80115f2:	61da      	str	r2, [r3, #28]
                block_buffer_planned = block; // Set optimal plan pointer.
 80115f4:	4a0f      	ldr	r2, [pc, #60]	; (8011634 <planner_recalculate+0x1d4>)
 80115f6:	68fb      	ldr	r3, [r7, #12]
 80115f8:	6013      	str	r3, [r2, #0]

        // Any block set at its maximum entry speed also creates an optimal plan up to this
        // point in the buffer. When the plan is bracketed by either the beginning of the
        // buffer and a maximum entry speed or two maximum entry speeds, every block in between
        // cannot logically be further improved. Hence, we don't have to recompute them anymore.
        if (next->entry_speed_sqr == next->max_entry_speed_sqr)
 80115fa:	68bb      	ldr	r3, [r7, #8]
 80115fc:	69da      	ldr	r2, [r3, #28]
 80115fe:	68bb      	ldr	r3, [r7, #8]
 8011600:	6a1b      	ldr	r3, [r3, #32]
 8011602:	4619      	mov	r1, r3
 8011604:	4610      	mov	r0, r2
 8011606:	f7ef fd69 	bl	80010dc <__aeabi_fcmpeq>
 801160a:	4603      	mov	r3, r0
 801160c:	2b00      	cmp	r3, #0
 801160e:	d002      	beq.n	8011616 <planner_recalculate+0x1b6>
            block_buffer_planned = block;
 8011610:	4a08      	ldr	r2, [pc, #32]	; (8011634 <planner_recalculate+0x1d4>)
 8011612:	68fb      	ldr	r3, [r7, #12]
 8011614:	6013      	str	r3, [r2, #0]

        block = block->next;
 8011616:	68fb      	ldr	r3, [r7, #12]
 8011618:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801161a:	60fb      	str	r3, [r7, #12]
    while (block != block_buffer_head) {
 801161c:	4b04      	ldr	r3, [pc, #16]	; (8011630 <planner_recalculate+0x1d0>)
 801161e:	681b      	ldr	r3, [r3, #0]
 8011620:	68fa      	ldr	r2, [r7, #12]
 8011622:	429a      	cmp	r2, r3
 8011624:	d1b4      	bne.n	8011590 <planner_recalculate+0x130>
 8011626:	e000      	b.n	801162a <planner_recalculate+0x1ca>
        return;
 8011628:	bf00      	nop
    }
}
 801162a:	3714      	adds	r7, #20
 801162c:	46bd      	mov	sp, r7
 801162e:	bd90      	pop	{r4, r7, pc}
 8011630:	20001178 	.word	0x20001178
 8011634:	20001180 	.word	0x20001180
 8011638:	20001174 	.word	0x20001174

0801163c <plan_cleanup>:

inline static void plan_cleanup (plan_block_t *block)
{
 801163c:	b580      	push	{r7, lr}
 801163e:	b084      	sub	sp, #16
 8011640:	af00      	add	r7, sp, #0
 8011642:	6078      	str	r0, [r7, #4]
    if(block->message) {
 8011644:	687b      	ldr	r3, [r7, #4]
 8011646:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011648:	2b00      	cmp	r3, #0
 801164a:	d014      	beq.n	8011676 <plan_cleanup+0x3a>
        free(block->message);
 801164c:	687b      	ldr	r3, [r7, #4]
 801164e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011650:	4618      	mov	r0, r3
 8011652:	f011 ff39 	bl	80234c8 <free>
        block->message = NULL;
 8011656:	687b      	ldr	r3, [r7, #4]
 8011658:	2200      	movs	r2, #0
 801165a:	64da      	str	r2, [r3, #76]	; 0x4c
    }

    while(block->output_commands) {
 801165c:	e00b      	b.n	8011676 <plan_cleanup+0x3a>
        output_command_t *next = block->output_commands->next;
 801165e:	687b      	ldr	r3, [r7, #4]
 8011660:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011662:	689b      	ldr	r3, [r3, #8]
 8011664:	60fb      	str	r3, [r7, #12]
        free(block->output_commands);
 8011666:	687b      	ldr	r3, [r7, #4]
 8011668:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801166a:	4618      	mov	r0, r3
 801166c:	f011 ff2c 	bl	80234c8 <free>
        block->output_commands = next;
 8011670:	687b      	ldr	r3, [r7, #4]
 8011672:	68fa      	ldr	r2, [r7, #12]
 8011674:	651a      	str	r2, [r3, #80]	; 0x50
    while(block->output_commands) {
 8011676:	687b      	ldr	r3, [r7, #4]
 8011678:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801167a:	2b00      	cmp	r3, #0
 801167c:	d1ef      	bne.n	801165e <plan_cleanup+0x22>
    }
}
 801167e:	bf00      	nop
 8011680:	bf00      	nop
 8011682:	3710      	adds	r7, #16
 8011684:	46bd      	mov	sp, r7
 8011686:	bd80      	pop	{r7, pc}

08011688 <plan_reset_buffer>:


inline static void plan_reset_buffer (void)
{
 8011688:	b580      	push	{r7, lr}
 801168a:	af00      	add	r7, sp, #0
    if(block_buffer_tail) {
 801168c:	4b13      	ldr	r3, [pc, #76]	; (80116dc <plan_reset_buffer+0x54>)
 801168e:	681b      	ldr	r3, [r3, #0]
 8011690:	2b00      	cmp	r3, #0
 8011692:	d010      	beq.n	80116b6 <plan_reset_buffer+0x2e>
        // Free memory for any pending messages and output commands after soft reset
        while(block_buffer_tail != block_buffer_head) {
 8011694:	e009      	b.n	80116aa <plan_reset_buffer+0x22>
            plan_cleanup(block_buffer_tail);
 8011696:	4b11      	ldr	r3, [pc, #68]	; (80116dc <plan_reset_buffer+0x54>)
 8011698:	681b      	ldr	r3, [r3, #0]
 801169a:	4618      	mov	r0, r3
 801169c:	f7ff ffce 	bl	801163c <plan_cleanup>
            block_buffer_tail = block_buffer_tail->next;
 80116a0:	4b0e      	ldr	r3, [pc, #56]	; (80116dc <plan_reset_buffer+0x54>)
 80116a2:	681b      	ldr	r3, [r3, #0]
 80116a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80116a6:	4a0d      	ldr	r2, [pc, #52]	; (80116dc <plan_reset_buffer+0x54>)
 80116a8:	6013      	str	r3, [r2, #0]
        while(block_buffer_tail != block_buffer_head) {
 80116aa:	4b0c      	ldr	r3, [pc, #48]	; (80116dc <plan_reset_buffer+0x54>)
 80116ac:	681a      	ldr	r2, [r3, #0]
 80116ae:	4b0c      	ldr	r3, [pc, #48]	; (80116e0 <plan_reset_buffer+0x58>)
 80116b0:	681b      	ldr	r3, [r3, #0]
 80116b2:	429a      	cmp	r2, r3
 80116b4:	d1ef      	bne.n	8011696 <plan_reset_buffer+0xe>
        }
    }

    block_buffer_tail = block_buffer_head = block_buffer;   // Empty = tail == head
 80116b6:	4b0b      	ldr	r3, [pc, #44]	; (80116e4 <plan_reset_buffer+0x5c>)
 80116b8:	681b      	ldr	r3, [r3, #0]
 80116ba:	4a09      	ldr	r2, [pc, #36]	; (80116e0 <plan_reset_buffer+0x58>)
 80116bc:	6013      	str	r3, [r2, #0]
 80116be:	4b08      	ldr	r3, [pc, #32]	; (80116e0 <plan_reset_buffer+0x58>)
 80116c0:	681b      	ldr	r3, [r3, #0]
 80116c2:	4a06      	ldr	r2, [pc, #24]	; (80116dc <plan_reset_buffer+0x54>)
 80116c4:	6013      	str	r3, [r2, #0]
    next_buffer_head = block_buffer_head->next;             // = next block
 80116c6:	4b06      	ldr	r3, [pc, #24]	; (80116e0 <plan_reset_buffer+0x58>)
 80116c8:	681b      	ldr	r3, [r3, #0]
 80116ca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80116cc:	4a06      	ldr	r2, [pc, #24]	; (80116e8 <plan_reset_buffer+0x60>)
 80116ce:	6013      	str	r3, [r2, #0]
    block_buffer_planned = block_buffer_tail;               // = block_buffer_tail
 80116d0:	4b02      	ldr	r3, [pc, #8]	; (80116dc <plan_reset_buffer+0x54>)
 80116d2:	681b      	ldr	r3, [r3, #0]
 80116d4:	4a05      	ldr	r2, [pc, #20]	; (80116ec <plan_reset_buffer+0x64>)
 80116d6:	6013      	str	r3, [r2, #0]
}
 80116d8:	bf00      	nop
 80116da:	bd80      	pop	{r7, pc}
 80116dc:	20001174 	.word	0x20001174
 80116e0:	20001178 	.word	0x20001178
 80116e4:	20001170 	.word	0x20001170
 80116e8:	2000117c 	.word	0x2000117c
 80116ec:	20001180 	.word	0x20001180

080116f0 <planner_warning>:

static void planner_warning (sys_state_t state)
{
 80116f0:	b580      	push	{r7, lr}
 80116f2:	b082      	sub	sp, #8
 80116f4:	af00      	add	r7, sp, #0
 80116f6:	6078      	str	r0, [r7, #4]
    report_message("Planner buffer size was reduced!", Message_Plain);
 80116f8:	2100      	movs	r1, #0
 80116fa:	4803      	ldr	r0, [pc, #12]	; (8011708 <planner_warning+0x18>)
 80116fc:	f002 fefc 	bl	80144f8 <report_message>
}
 8011700:	bf00      	nop
 8011702:	3708      	adds	r7, #8
 8011704:	46bd      	mov	sp, r7
 8011706:	bd80      	pop	{r7, pc}
 8011708:	0802a600 	.word	0x0802a600

0801170c <plan_get_buffer_size>:

uint_fast16_t plan_get_buffer_size (void)
{
 801170c:	b480      	push	{r7}
 801170e:	af00      	add	r7, sp, #0
    return block_buffer_size;
 8011710:	4b02      	ldr	r3, [pc, #8]	; (801171c <plan_get_buffer_size+0x10>)
 8011712:	681b      	ldr	r3, [r3, #0]
}
 8011714:	4618      	mov	r0, r3
 8011716:	46bd      	mov	sp, r7
 8011718:	bc80      	pop	{r7}
 801171a:	4770      	bx	lr
 801171c:	2000116c 	.word	0x2000116c

08011720 <plan_reset>:

bool plan_reset (void)
{
 8011720:	b590      	push	{r4, r7, lr}
 8011722:	b083      	sub	sp, #12
 8011724:	af00      	add	r7, sp, #0
    if(block_buffer == NULL) {
 8011726:	4b4e      	ldr	r3, [pc, #312]	; (8011860 <plan_reset+0x140>)
 8011728:	681b      	ldr	r3, [r3, #0]
 801172a:	2b00      	cmp	r3, #0
 801172c:	d128      	bne.n	8011780 <plan_reset+0x60>

        block_buffer_size = settings.planner_buffer_blocks;
 801172e:	4b4d      	ldr	r3, [pc, #308]	; (8011864 <plan_reset+0x144>)
 8011730:	8adb      	ldrh	r3, [r3, #22]
 8011732:	461a      	mov	r2, r3
 8011734:	4b4c      	ldr	r3, [pc, #304]	; (8011868 <plan_reset+0x148>)
 8011736:	601a      	str	r2, [r3, #0]

        while((block_buffer = malloc((block_buffer_size + 1) * sizeof(plan_block_t))) == NULL) {
 8011738:	e00f      	b.n	801175a <plan_reset+0x3a>
            if(block_buffer_size > 40)
 801173a:	4b4b      	ldr	r3, [pc, #300]	; (8011868 <plan_reset+0x148>)
 801173c:	681b      	ldr	r3, [r3, #0]
 801173e:	2b28      	cmp	r3, #40	; 0x28
 8011740:	d91d      	bls.n	801177e <plan_reset+0x5e>
                block_buffer_size -= block_buffer_size >= 250 ? 100 : 10;
 8011742:	4b49      	ldr	r3, [pc, #292]	; (8011868 <plan_reset+0x148>)
 8011744:	681a      	ldr	r2, [r3, #0]
 8011746:	4b48      	ldr	r3, [pc, #288]	; (8011868 <plan_reset+0x148>)
 8011748:	681b      	ldr	r3, [r3, #0]
 801174a:	2bf9      	cmp	r3, #249	; 0xf9
 801174c:	d901      	bls.n	8011752 <plan_reset+0x32>
 801174e:	2364      	movs	r3, #100	; 0x64
 8011750:	e000      	b.n	8011754 <plan_reset+0x34>
 8011752:	230a      	movs	r3, #10
 8011754:	1ad3      	subs	r3, r2, r3
 8011756:	4a44      	ldr	r2, [pc, #272]	; (8011868 <plan_reset+0x148>)
 8011758:	6013      	str	r3, [r2, #0]
        while((block_buffer = malloc((block_buffer_size + 1) * sizeof(plan_block_t))) == NULL) {
 801175a:	4b43      	ldr	r3, [pc, #268]	; (8011868 <plan_reset+0x148>)
 801175c:	681b      	ldr	r3, [r3, #0]
 801175e:	3301      	adds	r3, #1
 8011760:	225c      	movs	r2, #92	; 0x5c
 8011762:	fb02 f303 	mul.w	r3, r2, r3
 8011766:	4618      	mov	r0, r3
 8011768:	f011 fea6 	bl	80234b8 <malloc>
 801176c:	4603      	mov	r3, r0
 801176e:	461a      	mov	r2, r3
 8011770:	4b3b      	ldr	r3, [pc, #236]	; (8011860 <plan_reset+0x140>)
 8011772:	601a      	str	r2, [r3, #0]
 8011774:	4b3a      	ldr	r3, [pc, #232]	; (8011860 <plan_reset+0x140>)
 8011776:	681b      	ldr	r3, [r3, #0]
 8011778:	2b00      	cmp	r3, #0
 801177a:	d0de      	beq.n	801173a <plan_reset+0x1a>
 801177c:	e000      	b.n	8011780 <plan_reset+0x60>
            else
                break;
 801177e:	bf00      	nop
        }
    }

    if(block_buffer_size != settings.planner_buffer_blocks)
 8011780:	4b38      	ldr	r3, [pc, #224]	; (8011864 <plan_reset+0x144>)
 8011782:	8adb      	ldrh	r3, [r3, #22]
 8011784:	461a      	mov	r2, r3
 8011786:	4b38      	ldr	r3, [pc, #224]	; (8011868 <plan_reset+0x148>)
 8011788:	681b      	ldr	r3, [r3, #0]
 801178a:	429a      	cmp	r2, r3
 801178c:	d002      	beq.n	8011794 <plan_reset+0x74>
        protocol_enqueue_rt_command(planner_warning);
 801178e:	4837      	ldr	r0, [pc, #220]	; (801186c <plan_reset+0x14c>)
 8011790:	f002 fb2c 	bl	8013dec <protocol_enqueue_rt_command>

    if(block_buffer == NULL)
 8011794:	4b32      	ldr	r3, [pc, #200]	; (8011860 <plan_reset+0x140>)
 8011796:	681b      	ldr	r3, [r3, #0]
 8011798:	2b00      	cmp	r3, #0
 801179a:	d101      	bne.n	80117a0 <plan_reset+0x80>
        return false;
 801179c:	2300      	movs	r3, #0
 801179e:	e05a      	b.n	8011856 <plan_reset+0x136>

    if(block_buffer_tail) {
 80117a0:	4b33      	ldr	r3, [pc, #204]	; (8011870 <plan_reset+0x150>)
 80117a2:	681b      	ldr	r3, [r3, #0]
 80117a4:	2b00      	cmp	r3, #0
 80117a6:	d013      	beq.n	80117d0 <plan_reset+0xb0>
        // Free memory for any pending messages and output commands after soft reset
        while(block_buffer_tail != block_buffer_head) {
 80117a8:	e009      	b.n	80117be <plan_reset+0x9e>
            plan_cleanup(block_buffer_tail);
 80117aa:	4b31      	ldr	r3, [pc, #196]	; (8011870 <plan_reset+0x150>)
 80117ac:	681b      	ldr	r3, [r3, #0]
 80117ae:	4618      	mov	r0, r3
 80117b0:	f7ff ff44 	bl	801163c <plan_cleanup>
            block_buffer_tail = block_buffer_tail->next;
 80117b4:	4b2e      	ldr	r3, [pc, #184]	; (8011870 <plan_reset+0x150>)
 80117b6:	681b      	ldr	r3, [r3, #0]
 80117b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80117ba:	4a2d      	ldr	r2, [pc, #180]	; (8011870 <plan_reset+0x150>)
 80117bc:	6013      	str	r3, [r2, #0]
        while(block_buffer_tail != block_buffer_head) {
 80117be:	4b2c      	ldr	r3, [pc, #176]	; (8011870 <plan_reset+0x150>)
 80117c0:	681a      	ldr	r2, [r3, #0]
 80117c2:	4b2c      	ldr	r3, [pc, #176]	; (8011874 <plan_reset+0x154>)
 80117c4:	681b      	ldr	r3, [r3, #0]
 80117c6:	429a      	cmp	r2, r3
 80117c8:	d1ef      	bne.n	80117aa <plan_reset+0x8a>
        }
        block_buffer_tail = NULL;
 80117ca:	4b29      	ldr	r3, [pc, #164]	; (8011870 <plan_reset+0x150>)
 80117cc:	2200      	movs	r2, #0
 80117ce:	601a      	str	r2, [r3, #0]
    }

    memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 80117d0:	221c      	movs	r2, #28
 80117d2:	2100      	movs	r1, #0
 80117d4:	4828      	ldr	r0, [pc, #160]	; (8011878 <plan_reset+0x158>)
 80117d6:	f012 fa1e 	bl	8023c16 <memset>

    // Set up stepper block ringbuffer as circular doubly linked list
    uint_fast8_t idx;
    for(idx = 0 ; idx <= block_buffer_size ; idx++) {
 80117da:	2300      	movs	r3, #0
 80117dc:	607b      	str	r3, [r7, #4]
 80117de:	e032      	b.n	8011846 <plan_reset+0x126>
        block_buffer[idx].prev = &block_buffer[idx == 0 ? block_buffer_size : idx - 1];
 80117e0:	4b1f      	ldr	r3, [pc, #124]	; (8011860 <plan_reset+0x140>)
 80117e2:	6819      	ldr	r1, [r3, #0]
 80117e4:	687b      	ldr	r3, [r7, #4]
 80117e6:	2b00      	cmp	r3, #0
 80117e8:	d105      	bne.n	80117f6 <plan_reset+0xd6>
 80117ea:	4b1f      	ldr	r3, [pc, #124]	; (8011868 <plan_reset+0x148>)
 80117ec:	681b      	ldr	r3, [r3, #0]
 80117ee:	225c      	movs	r2, #92	; 0x5c
 80117f0:	fb02 f303 	mul.w	r3, r2, r3
 80117f4:	e004      	b.n	8011800 <plan_reset+0xe0>
 80117f6:	687b      	ldr	r3, [r7, #4]
 80117f8:	225c      	movs	r2, #92	; 0x5c
 80117fa:	fb02 f303 	mul.w	r3, r2, r3
 80117fe:	3b5c      	subs	r3, #92	; 0x5c
 8011800:	4a17      	ldr	r2, [pc, #92]	; (8011860 <plan_reset+0x140>)
 8011802:	6810      	ldr	r0, [r2, #0]
 8011804:	687a      	ldr	r2, [r7, #4]
 8011806:	245c      	movs	r4, #92	; 0x5c
 8011808:	fb04 f202 	mul.w	r2, r4, r2
 801180c:	4402      	add	r2, r0
 801180e:	440b      	add	r3, r1
 8011810:	6553      	str	r3, [r2, #84]	; 0x54
        block_buffer[idx].next = &block_buffer[idx == block_buffer_size ? 0 : idx + 1];
 8011812:	4b13      	ldr	r3, [pc, #76]	; (8011860 <plan_reset+0x140>)
 8011814:	6819      	ldr	r1, [r3, #0]
 8011816:	4b14      	ldr	r3, [pc, #80]	; (8011868 <plan_reset+0x148>)
 8011818:	681b      	ldr	r3, [r3, #0]
 801181a:	687a      	ldr	r2, [r7, #4]
 801181c:	429a      	cmp	r2, r3
 801181e:	d005      	beq.n	801182c <plan_reset+0x10c>
 8011820:	687b      	ldr	r3, [r7, #4]
 8011822:	3301      	adds	r3, #1
 8011824:	225c      	movs	r2, #92	; 0x5c
 8011826:	fb02 f303 	mul.w	r3, r2, r3
 801182a:	e000      	b.n	801182e <plan_reset+0x10e>
 801182c:	2300      	movs	r3, #0
 801182e:	4a0c      	ldr	r2, [pc, #48]	; (8011860 <plan_reset+0x140>)
 8011830:	6810      	ldr	r0, [r2, #0]
 8011832:	687a      	ldr	r2, [r7, #4]
 8011834:	245c      	movs	r4, #92	; 0x5c
 8011836:	fb04 f202 	mul.w	r2, r4, r2
 801183a:	4402      	add	r2, r0
 801183c:	440b      	add	r3, r1
 801183e:	6593      	str	r3, [r2, #88]	; 0x58
    for(idx = 0 ; idx <= block_buffer_size ; idx++) {
 8011840:	687b      	ldr	r3, [r7, #4]
 8011842:	3301      	adds	r3, #1
 8011844:	607b      	str	r3, [r7, #4]
 8011846:	4b08      	ldr	r3, [pc, #32]	; (8011868 <plan_reset+0x148>)
 8011848:	681b      	ldr	r3, [r3, #0]
 801184a:	687a      	ldr	r2, [r7, #4]
 801184c:	429a      	cmp	r2, r3
 801184e:	d9c7      	bls.n	80117e0 <plan_reset+0xc0>
    }

    plan_reset_buffer();
 8011850:	f7ff ff1a 	bl	8011688 <plan_reset_buffer>

    return true;
 8011854:	2301      	movs	r3, #1
}
 8011856:	4618      	mov	r0, r3
 8011858:	370c      	adds	r7, #12
 801185a:	46bd      	mov	sp, r7
 801185c:	bd90      	pop	{r4, r7, pc}
 801185e:	bf00      	nop
 8011860:	20001170 	.word	0x20001170
 8011864:	2000147c 	.word	0x2000147c
 8011868:	2000116c 	.word	0x2000116c
 801186c:	080116f1 	.word	0x080116f1
 8011870:	20001174 	.word	0x20001174
 8011874:	20001178 	.word	0x20001178
 8011878:	20001184 	.word	0x20001184

0801187c <plan_discard_current_block>:


void plan_discard_current_block (void)
{
 801187c:	b580      	push	{r7, lr}
 801187e:	af00      	add	r7, sp, #0
    if (block_buffer_tail != block_buffer_head) { // Discard non-empty buffer.
 8011880:	4b0e      	ldr	r3, [pc, #56]	; (80118bc <plan_discard_current_block+0x40>)
 8011882:	681a      	ldr	r2, [r3, #0]
 8011884:	4b0e      	ldr	r3, [pc, #56]	; (80118c0 <plan_discard_current_block+0x44>)
 8011886:	681b      	ldr	r3, [r3, #0]
 8011888:	429a      	cmp	r2, r3
 801188a:	d014      	beq.n	80118b6 <plan_discard_current_block+0x3a>
        plan_cleanup(block_buffer_tail);
 801188c:	4b0b      	ldr	r3, [pc, #44]	; (80118bc <plan_discard_current_block+0x40>)
 801188e:	681b      	ldr	r3, [r3, #0]
 8011890:	4618      	mov	r0, r3
 8011892:	f7ff fed3 	bl	801163c <plan_cleanup>
        // Push block_buffer_planned pointer, if encountered.
        if (block_buffer_tail == block_buffer_planned)
 8011896:	4b09      	ldr	r3, [pc, #36]	; (80118bc <plan_discard_current_block+0x40>)
 8011898:	681a      	ldr	r2, [r3, #0]
 801189a:	4b0a      	ldr	r3, [pc, #40]	; (80118c4 <plan_discard_current_block+0x48>)
 801189c:	681b      	ldr	r3, [r3, #0]
 801189e:	429a      	cmp	r2, r3
 80118a0:	d104      	bne.n	80118ac <plan_discard_current_block+0x30>
            block_buffer_planned = block_buffer_tail->next;
 80118a2:	4b06      	ldr	r3, [pc, #24]	; (80118bc <plan_discard_current_block+0x40>)
 80118a4:	681b      	ldr	r3, [r3, #0]
 80118a6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80118a8:	4a06      	ldr	r2, [pc, #24]	; (80118c4 <plan_discard_current_block+0x48>)
 80118aa:	6013      	str	r3, [r2, #0]
        block_buffer_tail = block_buffer_tail->next;
 80118ac:	4b03      	ldr	r3, [pc, #12]	; (80118bc <plan_discard_current_block+0x40>)
 80118ae:	681b      	ldr	r3, [r3, #0]
 80118b0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80118b2:	4a02      	ldr	r2, [pc, #8]	; (80118bc <plan_discard_current_block+0x40>)
 80118b4:	6013      	str	r3, [r2, #0]
    }
}
 80118b6:	bf00      	nop
 80118b8:	bd80      	pop	{r7, pc}
 80118ba:	bf00      	nop
 80118bc:	20001174 	.word	0x20001174
 80118c0:	20001178 	.word	0x20001178
 80118c4:	20001180 	.word	0x20001180

080118c8 <plan_get_system_motion_block>:


// Returns address of planner buffer block used by system motions. Called by segment generator.
plan_block_t *plan_get_system_motion_block (void)
{
 80118c8:	b480      	push	{r7}
 80118ca:	af00      	add	r7, sp, #0
    return block_buffer_head;
 80118cc:	4b02      	ldr	r3, [pc, #8]	; (80118d8 <plan_get_system_motion_block+0x10>)
 80118ce:	681b      	ldr	r3, [r3, #0]
}
 80118d0:	4618      	mov	r0, r3
 80118d2:	46bd      	mov	sp, r7
 80118d4:	bc80      	pop	{r7}
 80118d6:	4770      	bx	lr
 80118d8:	20001178 	.word	0x20001178

080118dc <plan_get_current_block>:


// Returns address of first planner block, if available. Called by various main program functions.
plan_block_t *plan_get_current_block (void)
{
 80118dc:	b480      	push	{r7}
 80118de:	af00      	add	r7, sp, #0
    return block_buffer_head == block_buffer_tail ? NULL : block_buffer_tail;
 80118e0:	4b06      	ldr	r3, [pc, #24]	; (80118fc <plan_get_current_block+0x20>)
 80118e2:	681a      	ldr	r2, [r3, #0]
 80118e4:	4b06      	ldr	r3, [pc, #24]	; (8011900 <plan_get_current_block+0x24>)
 80118e6:	681b      	ldr	r3, [r3, #0]
 80118e8:	429a      	cmp	r2, r3
 80118ea:	d002      	beq.n	80118f2 <plan_get_current_block+0x16>
 80118ec:	4b04      	ldr	r3, [pc, #16]	; (8011900 <plan_get_current_block+0x24>)
 80118ee:	681b      	ldr	r3, [r3, #0]
 80118f0:	e000      	b.n	80118f4 <plan_get_current_block+0x18>
 80118f2:	2300      	movs	r3, #0
}
 80118f4:	4618      	mov	r0, r3
 80118f6:	46bd      	mov	sp, r7
 80118f8:	bc80      	pop	{r7}
 80118fa:	4770      	bx	lr
 80118fc:	20001178 	.word	0x20001178
 8011900:	20001174 	.word	0x20001174

08011904 <plan_get_exec_block_exit_speed_sqr>:


inline float plan_get_exec_block_exit_speed_sqr (void)
{
 8011904:	b480      	push	{r7}
 8011906:	b083      	sub	sp, #12
 8011908:	af00      	add	r7, sp, #0
    plan_block_t *block = block_buffer_tail->next;
 801190a:	4b09      	ldr	r3, [pc, #36]	; (8011930 <plan_get_exec_block_exit_speed_sqr+0x2c>)
 801190c:	681b      	ldr	r3, [r3, #0]
 801190e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8011910:	607b      	str	r3, [r7, #4]
    return block == block_buffer_head ? 0.0f : block->entry_speed_sqr;
 8011912:	4b08      	ldr	r3, [pc, #32]	; (8011934 <plan_get_exec_block_exit_speed_sqr+0x30>)
 8011914:	681b      	ldr	r3, [r3, #0]
 8011916:	687a      	ldr	r2, [r7, #4]
 8011918:	429a      	cmp	r2, r3
 801191a:	d002      	beq.n	8011922 <plan_get_exec_block_exit_speed_sqr+0x1e>
 801191c:	687b      	ldr	r3, [r7, #4]
 801191e:	69db      	ldr	r3, [r3, #28]
 8011920:	e001      	b.n	8011926 <plan_get_exec_block_exit_speed_sqr+0x22>
 8011922:	f04f 0300 	mov.w	r3, #0
}
 8011926:	4618      	mov	r0, r3
 8011928:	370c      	adds	r7, #12
 801192a:	46bd      	mov	sp, r7
 801192c:	bc80      	pop	{r7}
 801192e:	4770      	bx	lr
 8011930:	20001174 	.word	0x20001174
 8011934:	20001178 	.word	0x20001178

08011938 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
bool plan_check_full_buffer (void)
{
 8011938:	b480      	push	{r7}
 801193a:	af00      	add	r7, sp, #0
    return block_buffer_tail == next_buffer_head;
 801193c:	4b06      	ldr	r3, [pc, #24]	; (8011958 <plan_check_full_buffer+0x20>)
 801193e:	681a      	ldr	r2, [r3, #0]
 8011940:	4b06      	ldr	r3, [pc, #24]	; (801195c <plan_check_full_buffer+0x24>)
 8011942:	681b      	ldr	r3, [r3, #0]
 8011944:	429a      	cmp	r2, r3
 8011946:	bf0c      	ite	eq
 8011948:	2301      	moveq	r3, #1
 801194a:	2300      	movne	r3, #0
 801194c:	b2db      	uxtb	r3, r3
}
 801194e:	4618      	mov	r0, r3
 8011950:	46bd      	mov	sp, r7
 8011952:	bc80      	pop	{r7}
 8011954:	4770      	bx	lr
 8011956:	bf00      	nop
 8011958:	20001174 	.word	0x20001174
 801195c:	2000117c 	.word	0x2000117c

08011960 <plan_compute_profile_nominal_speed>:


// Computes and returns block nominal speed based on running condition and override values.
// NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
float plan_compute_profile_nominal_speed (plan_block_t *block)
{
 8011960:	b590      	push	{r4, r7, lr}
 8011962:	b085      	sub	sp, #20
 8011964:	af00      	add	r7, sp, #0
 8011966:	6078      	str	r0, [r7, #4]
    float nominal_speed = block->spindle.state.synchronized ? block->programmed_rate * block->spindle.hal->get_data(SpindleData_RPM)->rpm : block->programmed_rate;
 8011968:	687b      	ldr	r3, [r7, #4]
 801196a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801196e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011972:	b2db      	uxtb	r3, r3
 8011974:	2b00      	cmp	r3, #0
 8011976:	d00e      	beq.n	8011996 <plan_compute_profile_nominal_speed+0x36>
 8011978:	687b      	ldr	r3, [r7, #4]
 801197a:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 801197c:	687b      	ldr	r3, [r7, #4]
 801197e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011980:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011982:	2001      	movs	r0, #1
 8011984:	4798      	blx	r3
 8011986:	4603      	mov	r3, r0
 8011988:	681b      	ldr	r3, [r3, #0]
 801198a:	4619      	mov	r1, r3
 801198c:	4620      	mov	r0, r4
 801198e:	f7ef fa11 	bl	8000db4 <__aeabi_fmul>
 8011992:	4603      	mov	r3, r0
 8011994:	e001      	b.n	801199a <plan_compute_profile_nominal_speed+0x3a>
 8011996:	687b      	ldr	r3, [r7, #4]
 8011998:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801199a:	60fb      	str	r3, [r7, #12]

    if (block->condition.rapid_motion)
 801199c:	687b      	ldr	r3, [r7, #4]
 801199e:	7d1b      	ldrb	r3, [r3, #20]
 80119a0:	f003 0301 	and.w	r3, r3, #1
 80119a4:	b2db      	uxtb	r3, r3
 80119a6:	2b00      	cmp	r3, #0
 80119a8:	d011      	beq.n	80119ce <plan_compute_profile_nominal_speed+0x6e>
        nominal_speed *= (0.01f * (float)sys.override.rapid_rate);
 80119aa:	4b23      	ldr	r3, [pc, #140]	; (8011a38 <plan_compute_profile_nominal_speed+0xd8>)
 80119ac:	6a1b      	ldr	r3, [r3, #32]
 80119ae:	4618      	mov	r0, r3
 80119b0:	f7ef f9a8 	bl	8000d04 <__aeabi_ui2f>
 80119b4:	4603      	mov	r3, r0
 80119b6:	4921      	ldr	r1, [pc, #132]	; (8011a3c <plan_compute_profile_nominal_speed+0xdc>)
 80119b8:	4618      	mov	r0, r3
 80119ba:	f7ef f9fb 	bl	8000db4 <__aeabi_fmul>
 80119be:	4603      	mov	r3, r0
 80119c0:	4619      	mov	r1, r3
 80119c2:	68f8      	ldr	r0, [r7, #12]
 80119c4:	f7ef f9f6 	bl	8000db4 <__aeabi_fmul>
 80119c8:	4603      	mov	r3, r0
 80119ca:	60fb      	str	r3, [r7, #12]
 80119cc:	e023      	b.n	8011a16 <plan_compute_profile_nominal_speed+0xb6>
    else {
        if (!block->condition.no_feed_override)
 80119ce:	687b      	ldr	r3, [r7, #4]
 80119d0:	7d1b      	ldrb	r3, [r3, #20]
 80119d2:	f003 0310 	and.w	r3, r3, #16
 80119d6:	b2db      	uxtb	r3, r3
 80119d8:	2b00      	cmp	r3, #0
 80119da:	d110      	bne.n	80119fe <plan_compute_profile_nominal_speed+0x9e>
            nominal_speed *= (0.01f * (float)sys.override.feed_rate);
 80119dc:	4b16      	ldr	r3, [pc, #88]	; (8011a38 <plan_compute_profile_nominal_speed+0xd8>)
 80119de:	69db      	ldr	r3, [r3, #28]
 80119e0:	4618      	mov	r0, r3
 80119e2:	f7ef f98f 	bl	8000d04 <__aeabi_ui2f>
 80119e6:	4603      	mov	r3, r0
 80119e8:	4914      	ldr	r1, [pc, #80]	; (8011a3c <plan_compute_profile_nominal_speed+0xdc>)
 80119ea:	4618      	mov	r0, r3
 80119ec:	f7ef f9e2 	bl	8000db4 <__aeabi_fmul>
 80119f0:	4603      	mov	r3, r0
 80119f2:	4619      	mov	r1, r3
 80119f4:	68f8      	ldr	r0, [r7, #12]
 80119f6:	f7ef f9dd 	bl	8000db4 <__aeabi_fmul>
 80119fa:	4603      	mov	r3, r0
 80119fc:	60fb      	str	r3, [r7, #12]
        if (nominal_speed > block->rapid_rate)
 80119fe:	687b      	ldr	r3, [r7, #4]
 8011a00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011a02:	4619      	mov	r1, r3
 8011a04:	68f8      	ldr	r0, [r7, #12]
 8011a06:	f7ef fb91 	bl	800112c <__aeabi_fcmpgt>
 8011a0a:	4603      	mov	r3, r0
 8011a0c:	2b00      	cmp	r3, #0
 8011a0e:	d002      	beq.n	8011a16 <plan_compute_profile_nominal_speed+0xb6>
            nominal_speed = block->rapid_rate;
 8011a10:	687b      	ldr	r3, [r7, #4]
 8011a12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011a14:	60fb      	str	r3, [r7, #12]
    }

// TODO: if nominal speed is outside bounds when synchronized motion is on then (?? retract and) abort, ignore overrides?
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 8011a16:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8011a1a:	68f8      	ldr	r0, [r7, #12]
 8011a1c:	f7ef fb86 	bl	800112c <__aeabi_fcmpgt>
 8011a20:	4603      	mov	r3, r0
 8011a22:	2b00      	cmp	r3, #0
 8011a24:	d001      	beq.n	8011a2a <plan_compute_profile_nominal_speed+0xca>
 8011a26:	68fb      	ldr	r3, [r7, #12]
 8011a28:	e001      	b.n	8011a2e <plan_compute_profile_nominal_speed+0xce>
 8011a2a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
}
 8011a2e:	4618      	mov	r0, r3
 8011a30:	3714      	adds	r7, #20
 8011a32:	46bd      	mov	sp, r7
 8011a34:	bd90      	pop	{r4, r7, pc}
 8011a36:	bf00      	nop
 8011a38:	20000d3c 	.word	0x20000d3c
 8011a3c:	3c23d70a 	.word	0x3c23d70a

08011a40 <plan_compute_profile_parameters>:


// Computes and updates the max entry speed (sqr) of the block, based on the minimum of the junction's
// previous and current nominal speeds and max junction speed.
inline static float plan_compute_profile_parameters (plan_block_t *block, float nominal_speed, float prev_nominal_speed)
{
 8011a40:	b580      	push	{r7, lr}
 8011a42:	b084      	sub	sp, #16
 8011a44:	af00      	add	r7, sp, #0
 8011a46:	60f8      	str	r0, [r7, #12]
 8011a48:	60b9      	str	r1, [r7, #8]
 8011a4a:	607a      	str	r2, [r7, #4]
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 8011a4c:	6879      	ldr	r1, [r7, #4]
 8011a4e:	68b8      	ldr	r0, [r7, #8]
 8011a50:	f7ef fb6c 	bl	800112c <__aeabi_fcmpgt>
 8011a54:	4603      	mov	r3, r0
 8011a56:	2b00      	cmp	r3, #0
 8011a58:	d006      	beq.n	8011a68 <plan_compute_profile_parameters+0x28>
 8011a5a:	6879      	ldr	r1, [r7, #4]
 8011a5c:	6878      	ldr	r0, [r7, #4]
 8011a5e:	f7ef f9a9 	bl	8000db4 <__aeabi_fmul>
 8011a62:	4603      	mov	r3, r0
 8011a64:	461a      	mov	r2, r3
 8011a66:	e005      	b.n	8011a74 <plan_compute_profile_parameters+0x34>
 8011a68:	68b9      	ldr	r1, [r7, #8]
 8011a6a:	68b8      	ldr	r0, [r7, #8]
 8011a6c:	f7ef f9a2 	bl	8000db4 <__aeabi_fmul>
 8011a70:	4603      	mov	r3, r0
 8011a72:	461a      	mov	r2, r3
 8011a74:	68fb      	ldr	r3, [r7, #12]
 8011a76:	621a      	str	r2, [r3, #32]
    if (block->max_entry_speed_sqr > block->max_junction_speed_sqr)
 8011a78:	68fb      	ldr	r3, [r7, #12]
 8011a7a:	6a1a      	ldr	r2, [r3, #32]
 8011a7c:	68fb      	ldr	r3, [r7, #12]
 8011a7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8011a80:	4619      	mov	r1, r3
 8011a82:	4610      	mov	r0, r2
 8011a84:	f7ef fb52 	bl	800112c <__aeabi_fcmpgt>
 8011a88:	4603      	mov	r3, r0
 8011a8a:	2b00      	cmp	r3, #0
 8011a8c:	d003      	beq.n	8011a96 <plan_compute_profile_parameters+0x56>
        block->max_entry_speed_sqr = block->max_junction_speed_sqr;
 8011a8e:	68fb      	ldr	r3, [r7, #12]
 8011a90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8011a92:	68fb      	ldr	r3, [r7, #12]
 8011a94:	621a      	str	r2, [r3, #32]
    return nominal_speed;
 8011a96:	68bb      	ldr	r3, [r7, #8]
}
 8011a98:	4618      	mov	r0, r3
 8011a9a:	3710      	adds	r7, #16
 8011a9c:	46bd      	mov	sp, r7
 8011a9e:	bd80      	pop	{r7, pc}

08011aa0 <limit_acceleration_by_axis_maximum>:

static inline float limit_acceleration_by_axis_maximum (float *unit_vec)
{
 8011aa0:	b580      	push	{r7, lr}
 8011aa2:	b084      	sub	sp, #16
 8011aa4:	af00      	add	r7, sp, #0
 8011aa6:	6078      	str	r0, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 8011aa8:	2303      	movs	r3, #3
 8011aaa:	60fb      	str	r3, [r7, #12]
    float limit_value = SOME_LARGE_VALUE;
 8011aac:	4b25      	ldr	r3, [pc, #148]	; (8011b44 <limit_acceleration_by_axis_maximum+0xa4>)
 8011aae:	60bb      	str	r3, [r7, #8]

    do {
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 8011ab0:	68fb      	ldr	r3, [r7, #12]
 8011ab2:	3b01      	subs	r3, #1
 8011ab4:	60fb      	str	r3, [r7, #12]
 8011ab6:	68fb      	ldr	r3, [r7, #12]
 8011ab8:	009b      	lsls	r3, r3, #2
 8011aba:	687a      	ldr	r2, [r7, #4]
 8011abc:	4413      	add	r3, r2
 8011abe:	681b      	ldr	r3, [r3, #0]
 8011ac0:	f04f 0100 	mov.w	r1, #0
 8011ac4:	4618      	mov	r0, r3
 8011ac6:	f7ef fb09 	bl	80010dc <__aeabi_fcmpeq>
 8011aca:	4603      	mov	r3, r0
 8011acc:	2b00      	cmp	r3, #0
 8011ace:	d131      	bne.n	8011b34 <limit_acceleration_by_axis_maximum+0x94>
            limit_value = min(limit_value, fabsf(settings.axis[idx].acceleration / unit_vec[idx]));
 8011ad0:	491d      	ldr	r1, [pc, #116]	; (8011b48 <limit_acceleration_by_axis_maximum+0xa8>)
 8011ad2:	68fa      	ldr	r2, [r7, #12]
 8011ad4:	4613      	mov	r3, r2
 8011ad6:	009b      	lsls	r3, r3, #2
 8011ad8:	4413      	add	r3, r2
 8011ada:	009b      	lsls	r3, r3, #2
 8011adc:	440b      	add	r3, r1
 8011ade:	3338      	adds	r3, #56	; 0x38
 8011ae0:	6818      	ldr	r0, [r3, #0]
 8011ae2:	68fb      	ldr	r3, [r7, #12]
 8011ae4:	009b      	lsls	r3, r3, #2
 8011ae6:	687a      	ldr	r2, [r7, #4]
 8011ae8:	4413      	add	r3, r2
 8011aea:	681b      	ldr	r3, [r3, #0]
 8011aec:	4619      	mov	r1, r3
 8011aee:	f7ef fa15 	bl	8000f1c <__aeabi_fdiv>
 8011af2:	4603      	mov	r3, r0
 8011af4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8011af8:	4619      	mov	r1, r3
 8011afa:	68b8      	ldr	r0, [r7, #8]
 8011afc:	f7ef faf8 	bl	80010f0 <__aeabi_fcmplt>
 8011b00:	4603      	mov	r3, r0
 8011b02:	2b00      	cmp	r3, #0
 8011b04:	d001      	beq.n	8011b0a <limit_acceleration_by_axis_maximum+0x6a>
 8011b06:	68bb      	ldr	r3, [r7, #8]
 8011b08:	e013      	b.n	8011b32 <limit_acceleration_by_axis_maximum+0x92>
 8011b0a:	490f      	ldr	r1, [pc, #60]	; (8011b48 <limit_acceleration_by_axis_maximum+0xa8>)
 8011b0c:	68fa      	ldr	r2, [r7, #12]
 8011b0e:	4613      	mov	r3, r2
 8011b10:	009b      	lsls	r3, r3, #2
 8011b12:	4413      	add	r3, r2
 8011b14:	009b      	lsls	r3, r3, #2
 8011b16:	440b      	add	r3, r1
 8011b18:	3338      	adds	r3, #56	; 0x38
 8011b1a:	6818      	ldr	r0, [r3, #0]
 8011b1c:	68fb      	ldr	r3, [r7, #12]
 8011b1e:	009b      	lsls	r3, r3, #2
 8011b20:	687a      	ldr	r2, [r7, #4]
 8011b22:	4413      	add	r3, r2
 8011b24:	681b      	ldr	r3, [r3, #0]
 8011b26:	4619      	mov	r1, r3
 8011b28:	f7ef f9f8 	bl	8000f1c <__aeabi_fdiv>
 8011b2c:	4603      	mov	r3, r0
 8011b2e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8011b32:	60bb      	str	r3, [r7, #8]
    } while(idx);
 8011b34:	68fb      	ldr	r3, [r7, #12]
 8011b36:	2b00      	cmp	r3, #0
 8011b38:	d1ba      	bne.n	8011ab0 <limit_acceleration_by_axis_maximum+0x10>

    return limit_value;
 8011b3a:	68bb      	ldr	r3, [r7, #8]
}
 8011b3c:	4618      	mov	r0, r3
 8011b3e:	3710      	adds	r7, #16
 8011b40:	46bd      	mov	sp, r7
 8011b42:	bd80      	pop	{r7, pc}
 8011b44:	7e967699 	.word	0x7e967699
 8011b48:	2000147c 	.word	0x2000147c

08011b4c <limit_max_rate_by_axis_maximum>:

static inline float limit_max_rate_by_axis_maximum (float *unit_vec)
{
 8011b4c:	b580      	push	{r7, lr}
 8011b4e:	b084      	sub	sp, #16
 8011b50:	af00      	add	r7, sp, #0
 8011b52:	6078      	str	r0, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 8011b54:	2303      	movs	r3, #3
 8011b56:	60fb      	str	r3, [r7, #12]
    float limit_value = SOME_LARGE_VALUE;
 8011b58:	4b25      	ldr	r3, [pc, #148]	; (8011bf0 <limit_max_rate_by_axis_maximum+0xa4>)
 8011b5a:	60bb      	str	r3, [r7, #8]

    do {
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 8011b5c:	68fb      	ldr	r3, [r7, #12]
 8011b5e:	3b01      	subs	r3, #1
 8011b60:	60fb      	str	r3, [r7, #12]
 8011b62:	68fb      	ldr	r3, [r7, #12]
 8011b64:	009b      	lsls	r3, r3, #2
 8011b66:	687a      	ldr	r2, [r7, #4]
 8011b68:	4413      	add	r3, r2
 8011b6a:	681b      	ldr	r3, [r3, #0]
 8011b6c:	f04f 0100 	mov.w	r1, #0
 8011b70:	4618      	mov	r0, r3
 8011b72:	f7ef fab3 	bl	80010dc <__aeabi_fcmpeq>
 8011b76:	4603      	mov	r3, r0
 8011b78:	2b00      	cmp	r3, #0
 8011b7a:	d131      	bne.n	8011be0 <limit_max_rate_by_axis_maximum+0x94>
            limit_value = min(limit_value, fabsf(settings.axis[idx].max_rate / unit_vec[idx]));
 8011b7c:	491d      	ldr	r1, [pc, #116]	; (8011bf4 <limit_max_rate_by_axis_maximum+0xa8>)
 8011b7e:	68fa      	ldr	r2, [r7, #12]
 8011b80:	4613      	mov	r3, r2
 8011b82:	009b      	lsls	r3, r3, #2
 8011b84:	4413      	add	r3, r2
 8011b86:	009b      	lsls	r3, r3, #2
 8011b88:	440b      	add	r3, r1
 8011b8a:	3334      	adds	r3, #52	; 0x34
 8011b8c:	6818      	ldr	r0, [r3, #0]
 8011b8e:	68fb      	ldr	r3, [r7, #12]
 8011b90:	009b      	lsls	r3, r3, #2
 8011b92:	687a      	ldr	r2, [r7, #4]
 8011b94:	4413      	add	r3, r2
 8011b96:	681b      	ldr	r3, [r3, #0]
 8011b98:	4619      	mov	r1, r3
 8011b9a:	f7ef f9bf 	bl	8000f1c <__aeabi_fdiv>
 8011b9e:	4603      	mov	r3, r0
 8011ba0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8011ba4:	4619      	mov	r1, r3
 8011ba6:	68b8      	ldr	r0, [r7, #8]
 8011ba8:	f7ef faa2 	bl	80010f0 <__aeabi_fcmplt>
 8011bac:	4603      	mov	r3, r0
 8011bae:	2b00      	cmp	r3, #0
 8011bb0:	d001      	beq.n	8011bb6 <limit_max_rate_by_axis_maximum+0x6a>
 8011bb2:	68bb      	ldr	r3, [r7, #8]
 8011bb4:	e013      	b.n	8011bde <limit_max_rate_by_axis_maximum+0x92>
 8011bb6:	490f      	ldr	r1, [pc, #60]	; (8011bf4 <limit_max_rate_by_axis_maximum+0xa8>)
 8011bb8:	68fa      	ldr	r2, [r7, #12]
 8011bba:	4613      	mov	r3, r2
 8011bbc:	009b      	lsls	r3, r3, #2
 8011bbe:	4413      	add	r3, r2
 8011bc0:	009b      	lsls	r3, r3, #2
 8011bc2:	440b      	add	r3, r1
 8011bc4:	3334      	adds	r3, #52	; 0x34
 8011bc6:	6818      	ldr	r0, [r3, #0]
 8011bc8:	68fb      	ldr	r3, [r7, #12]
 8011bca:	009b      	lsls	r3, r3, #2
 8011bcc:	687a      	ldr	r2, [r7, #4]
 8011bce:	4413      	add	r3, r2
 8011bd0:	681b      	ldr	r3, [r3, #0]
 8011bd2:	4619      	mov	r1, r3
 8011bd4:	f7ef f9a2 	bl	8000f1c <__aeabi_fdiv>
 8011bd8:	4603      	mov	r3, r0
 8011bda:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8011bde:	60bb      	str	r3, [r7, #8]
    } while(idx);
 8011be0:	68fb      	ldr	r3, [r7, #12]
 8011be2:	2b00      	cmp	r3, #0
 8011be4:	d1ba      	bne.n	8011b5c <limit_max_rate_by_axis_maximum+0x10>

    return limit_value;
 8011be6:	68bb      	ldr	r3, [r7, #8]
}
 8011be8:	4618      	mov	r0, r3
 8011bea:	3710      	adds	r7, #16
 8011bec:	46bd      	mov	sp, r7
 8011bee:	bd80      	pop	{r7, pc}
 8011bf0:	7e967699 	.word	0x7e967699
 8011bf4:	2000147c 	.word	0x2000147c

08011bf8 <plan_buffer_line>:
   The system motion condition tells the planner to plan a motion in the always unused block buffer
   head. It avoids changing the planner state and preserves the buffer to ensure subsequent gcode
   motions are still planned correctly, while the stepper module only points to the block buffer head
   to execute the special system motion. */
bool plan_buffer_line (float *target, plan_line_data_t *pl_data)
{
 8011bf8:	b5b0      	push	{r4, r5, r7, lr}
 8011bfa:	b096      	sub	sp, #88	; 0x58
 8011bfc:	af00      	add	r7, sp, #0
 8011bfe:	6078      	str	r0, [r7, #4]
 8011c00:	6039      	str	r1, [r7, #0]
    // Prepare and initialize new block. Copy relevant pl_data for block execution.
    plan_block_t *block = block_buffer_head;
 8011c02:	4b83      	ldr	r3, [pc, #524]	; (8011e10 <plan_buffer_line+0x218>)
 8011c04:	681b      	ldr	r3, [r3, #0]
 8011c06:	64fb      	str	r3, [r7, #76]	; 0x4c
#if N_AXIS > 3 && ROTARY_FIX
    axes_signals_t motion = {0};
#endif

//    plan_cleanup(block);
    memset(block, 0, sizeof(plan_block_t) - 2 * sizeof(plan_block_t *));    // Zero all block values (except linked list pointers).
 8011c08:	2254      	movs	r2, #84	; 0x54
 8011c0a:	2100      	movs	r1, #0
 8011c0c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8011c0e:	f012 f802 	bl	8023c16 <memset>
    memcpy(&block->spindle, &pl_data->spindle, sizeof(spindle_t));          // Copy spindle data (RPM etc)
 8011c12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c14:	f103 003c 	add.w	r0, r3, #60	; 0x3c
 8011c18:	683b      	ldr	r3, [r7, #0]
 8011c1a:	3308      	adds	r3, #8
 8011c1c:	2210      	movs	r2, #16
 8011c1e:	4619      	mov	r1, r3
 8011c20:	f012 f955 	bl	8023ece <memcpy>
    block->condition = pl_data->condition;
 8011c24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c26:	683a      	ldr	r2, [r7, #0]
 8011c28:	6992      	ldr	r2, [r2, #24]
 8011c2a:	615a      	str	r2, [r3, #20]
    block->overrides = pl_data->overrides;
 8011c2c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c2e:	683a      	ldr	r2, [r7, #0]
 8011c30:	7f12      	ldrb	r2, [r2, #28]
 8011c32:	745a      	strb	r2, [r3, #17]
    block->line_number = pl_data->line_number;
 8011c34:	683b      	ldr	r3, [r7, #0]
 8011c36:	6a1a      	ldr	r2, [r3, #32]
 8011c38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c3a:	619a      	str	r2, [r3, #24]
    block->output_commands = pl_data->output_commands;
 8011c3c:	683b      	ldr	r3, [r7, #0]
 8011c3e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8011c40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c42:	651a      	str	r2, [r3, #80]	; 0x50
    block->message = pl_data->message;
 8011c44:	683b      	ldr	r3, [r7, #0]
 8011c46:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8011c48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c4a:	64da      	str	r2, [r3, #76]	; 0x4c
    pl_data->message = NULL;
 8011c4c:	683b      	ldr	r3, [r7, #0]
 8011c4e:	2200      	movs	r2, #0
 8011c50:	625a      	str	r2, [r3, #36]	; 0x24

    // Copy position data based on type of motion being planned.
    memcpy(position_steps, block->condition.system_motion ? sys.position : pl.position, sizeof(position_steps));
 8011c52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011c54:	7d1b      	ldrb	r3, [r3, #20]
 8011c56:	f003 0302 	and.w	r3, r3, #2
 8011c5a:	b2db      	uxtb	r3, r3
 8011c5c:	2b00      	cmp	r3, #0
 8011c5e:	d001      	beq.n	8011c64 <plan_buffer_line+0x6c>
 8011c60:	496c      	ldr	r1, [pc, #432]	; (8011e14 <plan_buffer_line+0x21c>)
 8011c62:	e000      	b.n	8011c66 <plan_buffer_line+0x6e>
 8011c64:	496c      	ldr	r1, [pc, #432]	; (8011e18 <plan_buffer_line+0x220>)
 8011c66:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8011c6a:	220c      	movs	r2, #12
 8011c6c:	4618      	mov	r0, r3
 8011c6e:	f012 f92e 	bl	8023ece <memcpy>

    // Compute and store initial move distance data.

    idx = N_AXIS;
 8011c72:	2303      	movs	r3, #3
 8011c74:	657b      	str	r3, [r7, #84]	; 0x54
    do {
        idx--;
 8011c76:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011c78:	3b01      	subs	r3, #1
 8011c7a:	657b      	str	r3, [r7, #84]	; 0x54
        // Calculate target position in absolute steps, number of steps for each axis, and determine max step events.
        // Also, compute individual axes distance for move and prep unit vector calculations.
        // NOTE: Computes true distance from converted step values.

        target_steps[idx] = lroundf(target[idx] * settings.axis[idx].steps_per_mm);
 8011c7c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011c7e:	009b      	lsls	r3, r3, #2
 8011c80:	687a      	ldr	r2, [r7, #4]
 8011c82:	4413      	add	r3, r2
 8011c84:	6818      	ldr	r0, [r3, #0]
 8011c86:	4965      	ldr	r1, [pc, #404]	; (8011e1c <plan_buffer_line+0x224>)
 8011c88:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011c8a:	4613      	mov	r3, r2
 8011c8c:	009b      	lsls	r3, r3, #2
 8011c8e:	4413      	add	r3, r2
 8011c90:	009b      	lsls	r3, r3, #2
 8011c92:	440b      	add	r3, r1
 8011c94:	3330      	adds	r3, #48	; 0x30
 8011c96:	681b      	ldr	r3, [r3, #0]
 8011c98:	4619      	mov	r1, r3
 8011c9a:	f7ef f88b 	bl	8000db4 <__aeabi_fmul>
 8011c9e:	4603      	mov	r3, r0
 8011ca0:	4618      	mov	r0, r3
 8011ca2:	f012 ff67 	bl	8024b74 <lroundf>
 8011ca6:	4602      	mov	r2, r0
 8011ca8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011caa:	009b      	lsls	r3, r3, #2
 8011cac:	3358      	adds	r3, #88	; 0x58
 8011cae:	443b      	add	r3, r7
 8011cb0:	f843 2c28 	str.w	r2, [r3, #-40]
        if((delta_steps = target_steps[idx] - position_steps[idx])) {
 8011cb4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011cb6:	009b      	lsls	r3, r3, #2
 8011cb8:	3358      	adds	r3, #88	; 0x58
 8011cba:	443b      	add	r3, r7
 8011cbc:	f853 2c28 	ldr.w	r2, [r3, #-40]
 8011cc0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011cc2:	009b      	lsls	r3, r3, #2
 8011cc4:	3358      	adds	r3, #88	; 0x58
 8011cc6:	443b      	add	r3, r7
 8011cc8:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8011ccc:	1ad3      	subs	r3, r2, r3
 8011cce:	64bb      	str	r3, [r7, #72]	; 0x48
 8011cd0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011cd2:	2b00      	cmp	r3, #0
 8011cd4:	d02b      	beq.n	8011d2e <plan_buffer_line+0x136>
            block->steps[idx] = labs(delta_steps);
 8011cd6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011cd8:	2b00      	cmp	r3, #0
 8011cda:	bfb8      	it	lt
 8011cdc:	425b      	neglt	r3, r3
 8011cde:	4619      	mov	r1, r3
 8011ce0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011ce2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011ce4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            block->step_event_count = max(block->step_event_count, block->steps[idx]);
 8011ce8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011cea:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011cec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8011cf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011cf2:	68db      	ldr	r3, [r3, #12]
 8011cf4:	429a      	cmp	r2, r3
 8011cf6:	bf38      	it	cc
 8011cf8:	461a      	movcc	r2, r3
 8011cfa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011cfc:	60da      	str	r2, [r3, #12]
            unit_vec[idx] = (float)delta_steps / settings.axis[idx].steps_per_mm; // Store unit vector numerator
 8011cfe:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8011d00:	f7ef f804 	bl	8000d0c <__aeabi_i2f>
 8011d04:	4945      	ldr	r1, [pc, #276]	; (8011e1c <plan_buffer_line+0x224>)
 8011d06:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011d08:	4613      	mov	r3, r2
 8011d0a:	009b      	lsls	r3, r3, #2
 8011d0c:	4413      	add	r3, r2
 8011d0e:	009b      	lsls	r3, r3, #2
 8011d10:	440b      	add	r3, r1
 8011d12:	3330      	adds	r3, #48	; 0x30
 8011d14:	681b      	ldr	r3, [r3, #0]
 8011d16:	4619      	mov	r1, r3
 8011d18:	f7ef f900 	bl	8000f1c <__aeabi_fdiv>
 8011d1c:	4603      	mov	r3, r0
 8011d1e:	461a      	mov	r2, r3
 8011d20:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011d22:	009b      	lsls	r3, r3, #2
 8011d24:	3358      	adds	r3, #88	; 0x58
 8011d26:	443b      	add	r3, r7
 8011d28:	f843 2c40 	str.w	r2, [r3, #-64]
 8011d2c:	e00c      	b.n	8011d48 <plan_buffer_line+0x150>
#if N_AXIS > 3  && ROTARY_FIX
            motion.mask |= bit(idx);
#endif
        } else {
            block->steps[idx] = 0;
 8011d2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d30:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011d32:	2100      	movs	r1, #0
 8011d34:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            unit_vec[idx] = 0.0f; // Store unit vector numerator
 8011d38:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011d3a:	009b      	lsls	r3, r3, #2
 8011d3c:	3358      	adds	r3, #88	; 0x58
 8011d3e:	443b      	add	r3, r7
 8011d40:	f04f 0200 	mov.w	r2, #0
 8011d44:	f843 2c40 	str.w	r2, [r3, #-64]
        }

        // Set direction bits. Bit enabled always means direction is negative.
        if (delta_steps < 0)
 8011d48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011d4a:	2b00      	cmp	r3, #0
 8011d4c:	da0a      	bge.n	8011d64 <plan_buffer_line+0x16c>
            block->direction_bits.mask |= bit(idx);
 8011d4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d50:	7c1a      	ldrb	r2, [r3, #16]
 8011d52:	2101      	movs	r1, #1
 8011d54:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011d56:	fa01 f303 	lsl.w	r3, r1, r3
 8011d5a:	b2db      	uxtb	r3, r3
 8011d5c:	4313      	orrs	r3, r2
 8011d5e:	b2da      	uxtb	r2, r3
 8011d60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d62:	741a      	strb	r2, [r3, #16]

    } while(idx);
 8011d64:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011d66:	2b00      	cmp	r3, #0
 8011d68:	d185      	bne.n	8011c76 <plan_buffer_line+0x7e>

    // Calculate RPMs to be used for Constant Surface Speed (CSS) calculations.
    if(block->spindle.css) {
 8011d6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d6c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011d6e:	2b00      	cmp	r3, #0
 8011d70:	f000 80aa 	beq.w	8011ec8 <plan_buffer_line+0x2d0>

        float pos;

        if((pos = (float)position_steps[block->spindle.css->axis] / settings.axis[block->spindle.css->axis].steps_per_mm - block->spindle.css->tool_offset) > 0.0f) {
 8011d74:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011d78:	695b      	ldr	r3, [r3, #20]
 8011d7a:	009b      	lsls	r3, r3, #2
 8011d7c:	3358      	adds	r3, #88	; 0x58
 8011d7e:	443b      	add	r3, r7
 8011d80:	f853 3c34 	ldr.w	r3, [r3, #-52]
 8011d84:	4618      	mov	r0, r3
 8011d86:	f7ee ffc1 	bl	8000d0c <__aeabi_i2f>
 8011d8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011d8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011d8e:	695a      	ldr	r2, [r3, #20]
 8011d90:	4922      	ldr	r1, [pc, #136]	; (8011e1c <plan_buffer_line+0x224>)
 8011d92:	4613      	mov	r3, r2
 8011d94:	009b      	lsls	r3, r3, #2
 8011d96:	4413      	add	r3, r2
 8011d98:	009b      	lsls	r3, r3, #2
 8011d9a:	440b      	add	r3, r1
 8011d9c:	3330      	adds	r3, #48	; 0x30
 8011d9e:	681b      	ldr	r3, [r3, #0]
 8011da0:	4619      	mov	r1, r3
 8011da2:	f7ef f8bb 	bl	8000f1c <__aeabi_fdiv>
 8011da6:	4603      	mov	r3, r0
 8011da8:	461a      	mov	r2, r3
 8011daa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011dac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011dae:	691b      	ldr	r3, [r3, #16]
 8011db0:	4619      	mov	r1, r3
 8011db2:	4610      	mov	r0, r2
 8011db4:	f7ee fef4 	bl	8000ba0 <__aeabi_fsub>
 8011db8:	4603      	mov	r3, r0
 8011dba:	647b      	str	r3, [r7, #68]	; 0x44
 8011dbc:	f04f 0100 	mov.w	r1, #0
 8011dc0:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011dc2:	f7ef f9b3 	bl	800112c <__aeabi_fcmpgt>
 8011dc6:	4603      	mov	r3, r0
 8011dc8:	2b00      	cmp	r3, #0
 8011dca:	d02b      	beq.n	8011e24 <plan_buffer_line+0x22c>
            if((block->spindle.rpm = block->spindle.css->surface_speed / (pos * (float)(2.0f * M_PI))) > block->spindle.css->max_rpm)
 8011dcc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011dce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011dd0:	681c      	ldr	r4, [r3, #0]
 8011dd2:	4913      	ldr	r1, [pc, #76]	; (8011e20 <plan_buffer_line+0x228>)
 8011dd4:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011dd6:	f7ee ffed 	bl	8000db4 <__aeabi_fmul>
 8011dda:	4603      	mov	r3, r0
 8011ddc:	4619      	mov	r1, r3
 8011dde:	4620      	mov	r0, r4
 8011de0:	f7ef f89c 	bl	8000f1c <__aeabi_fdiv>
 8011de4:	4603      	mov	r3, r0
 8011de6:	461a      	mov	r2, r3
 8011de8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011dea:	63da      	str	r2, [r3, #60]	; 0x3c
 8011dec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011dee:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8011df0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011df2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011df4:	68db      	ldr	r3, [r3, #12]
 8011df6:	4619      	mov	r1, r3
 8011df8:	4610      	mov	r0, r2
 8011dfa:	f7ef f997 	bl	800112c <__aeabi_fcmpgt>
 8011dfe:	4603      	mov	r3, r0
 8011e00:	2b00      	cmp	r3, #0
 8011e02:	d014      	beq.n	8011e2e <plan_buffer_line+0x236>
                block->spindle.rpm = block->spindle.css->max_rpm;
 8011e04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e08:	68da      	ldr	r2, [r3, #12]
 8011e0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e0c:	63da      	str	r2, [r3, #60]	; 0x3c
 8011e0e:	e00e      	b.n	8011e2e <plan_buffer_line+0x236>
 8011e10:	20001178 	.word	0x20001178
 8011e14:	20000dc4 	.word	0x20000dc4
 8011e18:	20001184 	.word	0x20001184
 8011e1c:	2000147c 	.word	0x2000147c
 8011e20:	40c90fdb 	.word	0x40c90fdb
        } else
            block->spindle.rpm = block->spindle.css->max_rpm;
 8011e24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e28:	68da      	ldr	r2, [r3, #12]
 8011e2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e2c:	63da      	str	r2, [r3, #60]	; 0x3c

        if((pos = target[block->spindle.css->axis] - block->spindle.css->tool_offset) > 0.0f) {
 8011e2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e32:	695b      	ldr	r3, [r3, #20]
 8011e34:	009b      	lsls	r3, r3, #2
 8011e36:	687a      	ldr	r2, [r7, #4]
 8011e38:	4413      	add	r3, r2
 8011e3a:	681a      	ldr	r2, [r3, #0]
 8011e3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e3e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e40:	691b      	ldr	r3, [r3, #16]
 8011e42:	4619      	mov	r1, r3
 8011e44:	4610      	mov	r0, r2
 8011e46:	f7ee feab 	bl	8000ba0 <__aeabi_fsub>
 8011e4a:	4603      	mov	r3, r0
 8011e4c:	647b      	str	r3, [r7, #68]	; 0x44
 8011e4e:	f04f 0100 	mov.w	r1, #0
 8011e52:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011e54:	f7ef f96a 	bl	800112c <__aeabi_fcmpgt>
 8011e58:	4603      	mov	r3, r0
 8011e5a:	2b00      	cmp	r3, #0
 8011e5c:	d022      	beq.n	8011ea4 <plan_buffer_line+0x2ac>
            if((block->spindle.css->target_rpm = block->spindle.css->surface_speed / (pos * (float)(2.0f * M_PI))) > block->spindle.css->max_rpm)
 8011e5e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e62:	681d      	ldr	r5, [r3, #0]
 8011e64:	4990      	ldr	r1, [pc, #576]	; (80120a8 <plan_buffer_line+0x4b0>)
 8011e66:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011e68:	f7ee ffa4 	bl	8000db4 <__aeabi_fmul>
 8011e6c:	4603      	mov	r3, r0
 8011e6e:	461a      	mov	r2, r3
 8011e70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e72:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8011e74:	4611      	mov	r1, r2
 8011e76:	4628      	mov	r0, r5
 8011e78:	f7ef f850 	bl	8000f1c <__aeabi_fdiv>
 8011e7c:	4603      	mov	r3, r0
 8011e7e:	6063      	str	r3, [r4, #4]
 8011e80:	6862      	ldr	r2, [r4, #4]
 8011e82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e86:	68db      	ldr	r3, [r3, #12]
 8011e88:	4619      	mov	r1, r3
 8011e8a:	4610      	mov	r0, r2
 8011e8c:	f7ef f94e 	bl	800112c <__aeabi_fcmpgt>
 8011e90:	4603      	mov	r3, r0
 8011e92:	2b00      	cmp	r3, #0
 8011e94:	d00c      	beq.n	8011eb0 <plan_buffer_line+0x2b8>
                block->spindle.css->target_rpm = block->spindle.css->max_rpm;
 8011e96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e98:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8011e9a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011e9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011e9e:	68d2      	ldr	r2, [r2, #12]
 8011ea0:	605a      	str	r2, [r3, #4]
 8011ea2:	e005      	b.n	8011eb0 <plan_buffer_line+0x2b8>
        } else
            block->spindle.css->target_rpm = block->spindle.css->max_rpm;
 8011ea4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011ea6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8011ea8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011eaa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011eac:	68d2      	ldr	r2, [r2, #12]
 8011eae:	605a      	str	r2, [r3, #4]

        block->spindle.css->delta_rpm = block->spindle.css->target_rpm - block->spindle.rpm;
 8011eb0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011eb2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8011eb4:	685a      	ldr	r2, [r3, #4]
 8011eb6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011eb8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8011eba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011ebc:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8011ebe:	4610      	mov	r0, r2
 8011ec0:	f7ee fe6e 	bl	8000ba0 <__aeabi_fsub>
 8011ec4:	4603      	mov	r3, r0
 8011ec6:	60a3      	str	r3, [r4, #8]
    }

    // Bail if this is a zero-length block. Highly unlikely to occur.
    if (block->step_event_count == 0)
 8011ec8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011eca:	68db      	ldr	r3, [r3, #12]
 8011ecc:	2b00      	cmp	r3, #0
 8011ece:	d101      	bne.n	8011ed4 <plan_buffer_line+0x2dc>
        return false;
 8011ed0:	2300      	movs	r3, #0
 8011ed2:	e14a      	b.n	801216a <plan_buffer_line+0x572>

    pl_data->message = NULL;         // Indicate message is already queued for display on execution
 8011ed4:	683b      	ldr	r3, [r7, #0]
 8011ed6:	2200      	movs	r2, #0
 8011ed8:	625a      	str	r2, [r3, #36]	; 0x24
    pl_data->output_commands = NULL; // Indicate commands are already queued for execution
 8011eda:	683b      	ldr	r3, [r7, #0]
 8011edc:	2200      	movs	r2, #0
 8011ede:	629a      	str	r2, [r3, #40]	; 0x28
#else
    // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
    // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
#endif

    block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 8011ee0:	f107 0318 	add.w	r3, r7, #24
 8011ee4:	4618      	mov	r0, r3
 8011ee6:	f7fe fc8d 	bl	8010804 <convert_delta_vector_to_unit_vector>
 8011eea:	4602      	mov	r2, r0
 8011eec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011eee:	629a      	str	r2, [r3, #40]	; 0x28
    block->acceleration = limit_acceleration_by_axis_maximum(unit_vec);
 8011ef0:	f107 0318 	add.w	r3, r7, #24
 8011ef4:	4618      	mov	r0, r3
 8011ef6:	f7ff fdd3 	bl	8011aa0 <limit_acceleration_by_axis_maximum>
 8011efa:	4602      	mov	r2, r0
 8011efc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011efe:	625a      	str	r2, [r3, #36]	; 0x24
    block->rapid_rate = limit_max_rate_by_axis_maximum(unit_vec);
 8011f00:	f107 0318 	add.w	r3, r7, #24
 8011f04:	4618      	mov	r0, r3
 8011f06:	f7ff fe21 	bl	8011b4c <limit_max_rate_by_axis_maximum>
 8011f0a:	4602      	mov	r2, r0
 8011f0c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f0e:	631a      	str	r2, [r3, #48]	; 0x30

    // Store programmed rate.
    if (block->condition.rapid_motion)
 8011f10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f12:	7d1b      	ldrb	r3, [r3, #20]
 8011f14:	f003 0301 	and.w	r3, r3, #1
 8011f18:	b2db      	uxtb	r3, r3
 8011f1a:	2b00      	cmp	r3, #0
 8011f1c:	d004      	beq.n	8011f28 <plan_buffer_line+0x330>
        block->programmed_rate = block->rapid_rate;
 8011f1e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f20:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8011f22:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f24:	635a      	str	r2, [r3, #52]	; 0x34
 8011f26:	e01a      	b.n	8011f5e <plan_buffer_line+0x366>
    else {
        block->programmed_rate = pl_data->feed_rate;
 8011f28:	683b      	ldr	r3, [r7, #0]
 8011f2a:	681a      	ldr	r2, [r3, #0]
 8011f2c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f2e:	635a      	str	r2, [r3, #52]	; 0x34
#ifdef KINEMATICS_API
        block->rate_multiplier = pl_data->rate_multiplier;
 8011f30:	683b      	ldr	r3, [r7, #0]
 8011f32:	685a      	ldr	r2, [r3, #4]
 8011f34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f36:	639a      	str	r2, [r3, #56]	; 0x38
#endif
        if (block->condition.inverse_time)
 8011f38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f3a:	7d1b      	ldrb	r3, [r3, #20]
 8011f3c:	f003 0320 	and.w	r3, r3, #32
 8011f40:	b2db      	uxtb	r3, r3
 8011f42:	2b00      	cmp	r3, #0
 8011f44:	d00b      	beq.n	8011f5e <plan_buffer_line+0x366>
            block->programmed_rate *= block->millimeters;
 8011f46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f48:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8011f4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011f4e:	4619      	mov	r1, r3
 8011f50:	4610      	mov	r0, r2
 8011f52:	f7ee ff2f 	bl	8000db4 <__aeabi_fmul>
 8011f56:	4603      	mov	r3, r0
 8011f58:	461a      	mov	r2, r3
 8011f5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f5c:	635a      	str	r2, [r3, #52]	; 0x34
    }

    // TODO: Need to check this method handling zero junction speeds when starting from rest.
    if ((block_buffer_head == block_buffer_tail) || (block->condition.system_motion)) {
 8011f5e:	4b53      	ldr	r3, [pc, #332]	; (80120ac <plan_buffer_line+0x4b4>)
 8011f60:	681a      	ldr	r2, [r3, #0]
 8011f62:	4b53      	ldr	r3, [pc, #332]	; (80120b0 <plan_buffer_line+0x4b8>)
 8011f64:	681b      	ldr	r3, [r3, #0]
 8011f66:	429a      	cmp	r2, r3
 8011f68:	d006      	beq.n	8011f78 <plan_buffer_line+0x380>
 8011f6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f6c:	7d1b      	ldrb	r3, [r3, #20]
 8011f6e:	f003 0302 	and.w	r3, r3, #2
 8011f72:	b2db      	uxtb	r3, r3
 8011f74:	2b00      	cmp	r3, #0
 8011f76:	d008      	beq.n	8011f8a <plan_buffer_line+0x392>

        // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
        // If system motion, the system motion block always is assumed to start from rest and end at a complete stop.
        block->entry_speed_sqr = 0.0f;
 8011f78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f7a:	f04f 0200 	mov.w	r2, #0
 8011f7e:	61da      	str	r2, [r3, #28]
        block->max_junction_speed_sqr = 0.0f; // Starting from rest. Enforce start from zero velocity.
 8011f80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011f82:	f04f 0200 	mov.w	r2, #0
 8011f86:	62da      	str	r2, [r3, #44]	; 0x2c
 8011f88:	e0b9      	b.n	80120fe <plan_buffer_line+0x506>
        // changed dynamically during operation nor can the line move geometry. This must be kept in
        // memory in the event of a feedrate override changing the nominal speeds of blocks, which can
        // change the overall maximum entry speed conditions of all blocks.

        float junction_unit_vec[N_AXIS];
        float junction_cos_theta = 0.0f;
 8011f8a:	f04f 0300 	mov.w	r3, #0
 8011f8e:	653b      	str	r3, [r7, #80]	; 0x50

        idx = N_AXIS;
 8011f90:	2303      	movs	r3, #3
 8011f92:	657b      	str	r3, [r7, #84]	; 0x54
        do {
            idx--;
 8011f94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011f96:	3b01      	subs	r3, #1
 8011f98:	657b      	str	r3, [r7, #84]	; 0x54
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 8011f9a:	4a46      	ldr	r2, [pc, #280]	; (80120b4 <plan_buffer_line+0x4bc>)
 8011f9c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011f9e:	3302      	adds	r3, #2
 8011fa0:	009b      	lsls	r3, r3, #2
 8011fa2:	4413      	add	r3, r2
 8011fa4:	685a      	ldr	r2, [r3, #4]
 8011fa6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011fa8:	009b      	lsls	r3, r3, #2
 8011faa:	3358      	adds	r3, #88	; 0x58
 8011fac:	443b      	add	r3, r7
 8011fae:	f853 3c40 	ldr.w	r3, [r3, #-64]
 8011fb2:	4619      	mov	r1, r3
 8011fb4:	4610      	mov	r0, r2
 8011fb6:	f7ee fefd 	bl	8000db4 <__aeabi_fmul>
 8011fba:	4603      	mov	r3, r0
 8011fbc:	4619      	mov	r1, r3
 8011fbe:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8011fc0:	f7ee fdee 	bl	8000ba0 <__aeabi_fsub>
 8011fc4:	4603      	mov	r3, r0
 8011fc6:	653b      	str	r3, [r7, #80]	; 0x50
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 8011fc8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011fca:	009b      	lsls	r3, r3, #2
 8011fcc:	3358      	adds	r3, #88	; 0x58
 8011fce:	443b      	add	r3, r7
 8011fd0:	f853 2c40 	ldr.w	r2, [r3, #-64]
 8011fd4:	4937      	ldr	r1, [pc, #220]	; (80120b4 <plan_buffer_line+0x4bc>)
 8011fd6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011fd8:	3302      	adds	r3, #2
 8011fda:	009b      	lsls	r3, r3, #2
 8011fdc:	440b      	add	r3, r1
 8011fde:	685b      	ldr	r3, [r3, #4]
 8011fe0:	4619      	mov	r1, r3
 8011fe2:	4610      	mov	r0, r2
 8011fe4:	f7ee fddc 	bl	8000ba0 <__aeabi_fsub>
 8011fe8:	4603      	mov	r3, r0
 8011fea:	461a      	mov	r2, r3
 8011fec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011fee:	009b      	lsls	r3, r3, #2
 8011ff0:	3358      	adds	r3, #88	; 0x58
 8011ff2:	443b      	add	r3, r7
 8011ff4:	f843 2c4c 	str.w	r2, [r3, #-76]
        } while(idx);
 8011ff8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011ffa:	2b00      	cmp	r3, #0
 8011ffc:	d1ca      	bne.n	8011f94 <plan_buffer_line+0x39c>

        // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
        if (junction_cos_theta > 0.999999f)
 8011ffe:	492e      	ldr	r1, [pc, #184]	; (80120b8 <plan_buffer_line+0x4c0>)
 8012000:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8012002:	f7ef f893 	bl	800112c <__aeabi_fcmpgt>
 8012006:	4603      	mov	r3, r0
 8012008:	2b00      	cmp	r3, #0
 801200a:	d004      	beq.n	8012016 <plan_buffer_line+0x41e>
            //  For a 0 degree acute junction, just set minimum junction speed.
            block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED;
 801200c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801200e:	f04f 0200 	mov.w	r2, #0
 8012012:	62da      	str	r2, [r3, #44]	; 0x2c
 8012014:	e073      	b.n	80120fe <plan_buffer_line+0x506>
        else if (junction_cos_theta < -0.999999f) {
 8012016:	4929      	ldr	r1, [pc, #164]	; (80120bc <plan_buffer_line+0x4c4>)
 8012018:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801201a:	f7ef f869 	bl	80010f0 <__aeabi_fcmplt>
 801201e:	4603      	mov	r3, r0
 8012020:	2b00      	cmp	r3, #0
 8012022:	d003      	beq.n	801202c <plan_buffer_line+0x434>
            // Junction is a straight line or 180 degrees. Junction speed is infinite.
            block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 8012024:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012026:	4a26      	ldr	r2, [pc, #152]	; (80120c0 <plan_buffer_line+0x4c8>)
 8012028:	62da      	str	r2, [r3, #44]	; 0x2c
 801202a:	e068      	b.n	80120fe <plan_buffer_line+0x506>
        } else {
            convert_delta_vector_to_unit_vector(junction_unit_vec);
 801202c:	f107 030c 	add.w	r3, r7, #12
 8012030:	4618      	mov	r0, r3
 8012032:	f7fe fbe7 	bl	8010804 <convert_delta_vector_to_unit_vector>
            float junction_acceleration = limit_acceleration_by_axis_maximum(junction_unit_vec);
 8012036:	f107 030c 	add.w	r3, r7, #12
 801203a:	4618      	mov	r0, r3
 801203c:	f7ff fd30 	bl	8011aa0 <limit_acceleration_by_axis_maximum>
 8012040:	6438      	str	r0, [r7, #64]	; 0x40
            float sin_theta_d2 = sqrtf(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 8012042:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8012044:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8012048:	f7ee fdaa 	bl	8000ba0 <__aeabi_fsub>
 801204c:	4603      	mov	r3, r0
 801204e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8012052:	4618      	mov	r0, r3
 8012054:	f7ee feae 	bl	8000db4 <__aeabi_fmul>
 8012058:	4603      	mov	r3, r0
 801205a:	4618      	mov	r0, r3
 801205c:	f012 fccf 	bl	80249fe <sqrtf>
 8012060:	63f8      	str	r0, [r7, #60]	; 0x3c
            block->max_junction_speed_sqr = max(MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED,
 8012062:	4b18      	ldr	r3, [pc, #96]	; (80120c4 <plan_buffer_line+0x4cc>)
 8012064:	685b      	ldr	r3, [r3, #4]
 8012066:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8012068:	4618      	mov	r0, r3
 801206a:	f7ee fea3 	bl	8000db4 <__aeabi_fmul>
 801206e:	4603      	mov	r3, r0
 8012070:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8012072:	4618      	mov	r0, r3
 8012074:	f7ee fe9e 	bl	8000db4 <__aeabi_fmul>
 8012078:	4603      	mov	r3, r0
 801207a:	461c      	mov	r4, r3
 801207c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801207e:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8012082:	f7ee fd8d 	bl	8000ba0 <__aeabi_fsub>
 8012086:	4603      	mov	r3, r0
 8012088:	4619      	mov	r1, r3
 801208a:	4620      	mov	r0, r4
 801208c:	f7ee ff46 	bl	8000f1c <__aeabi_fdiv>
 8012090:	4603      	mov	r3, r0
 8012092:	f04f 0100 	mov.w	r1, #0
 8012096:	4618      	mov	r0, r3
 8012098:	f7ef f82a 	bl	80010f0 <__aeabi_fcmplt>
 801209c:	4603      	mov	r3, r0
 801209e:	2b00      	cmp	r3, #0
 80120a0:	d012      	beq.n	80120c8 <plan_buffer_line+0x4d0>
 80120a2:	f04f 0200 	mov.w	r2, #0
 80120a6:	e028      	b.n	80120fa <plan_buffer_line+0x502>
 80120a8:	40c90fdb 	.word	0x40c90fdb
 80120ac:	20001178 	.word	0x20001178
 80120b0:	20001174 	.word	0x20001174
 80120b4:	20001184 	.word	0x20001184
 80120b8:	3f7fffef 	.word	0x3f7fffef
 80120bc:	bf7fffef 	.word	0xbf7fffef
 80120c0:	7e967699 	.word	0x7e967699
 80120c4:	2000147c 	.word	0x2000147c
 80120c8:	4b2a      	ldr	r3, [pc, #168]	; (8012174 <plan_buffer_line+0x57c>)
 80120ca:	685b      	ldr	r3, [r3, #4]
 80120cc:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80120ce:	4618      	mov	r0, r3
 80120d0:	f7ee fe70 	bl	8000db4 <__aeabi_fmul>
 80120d4:	4603      	mov	r3, r0
 80120d6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80120d8:	4618      	mov	r0, r3
 80120da:	f7ee fe6b 	bl	8000db4 <__aeabi_fmul>
 80120de:	4603      	mov	r3, r0
 80120e0:	461c      	mov	r4, r3
 80120e2:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80120e4:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80120e8:	f7ee fd5a 	bl	8000ba0 <__aeabi_fsub>
 80120ec:	4603      	mov	r3, r0
 80120ee:	4619      	mov	r1, r3
 80120f0:	4620      	mov	r0, r4
 80120f2:	f7ee ff13 	bl	8000f1c <__aeabi_fdiv>
 80120f6:	4603      	mov	r3, r0
 80120f8:	461a      	mov	r2, r3
 80120fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80120fc:	62da      	str	r2, [r3, #44]	; 0x2c
                                                  (junction_acceleration * settings.junction_deviation * sin_theta_d2) / (1.0f - sin_theta_d2));
        }
    }

    // Block system motion from updating this data to ensure next g-code motion is computed correctly.
    if (!block->condition.system_motion) {
 80120fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012100:	7d1b      	ldrb	r3, [r3, #20]
 8012102:	f003 0302 	and.w	r3, r3, #2
 8012106:	b2db      	uxtb	r3, r3
 8012108:	2b00      	cmp	r3, #0
 801210a:	d12d      	bne.n	8012168 <plan_buffer_line+0x570>

        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 801210c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801210e:	f7ff fc27 	bl	8011960 <plan_compute_profile_nominal_speed>
 8012112:	4601      	mov	r1, r0
 8012114:	4b18      	ldr	r3, [pc, #96]	; (8012178 <plan_buffer_line+0x580>)
 8012116:	699b      	ldr	r3, [r3, #24]
 8012118:	461a      	mov	r2, r3
 801211a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801211c:	f7ff fc90 	bl	8011a40 <plan_compute_profile_parameters>
 8012120:	4603      	mov	r3, r0
 8012122:	4a15      	ldr	r2, [pc, #84]	; (8012178 <plan_buffer_line+0x580>)
 8012124:	6193      	str	r3, [r2, #24]

        if(!block->condition.backlash_motion) {
 8012126:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012128:	7d1b      	ldrb	r3, [r3, #20]
 801212a:	f003 0308 	and.w	r3, r3, #8
 801212e:	b2db      	uxtb	r3, r3
 8012130:	2b00      	cmp	r3, #0
 8012132:	d10e      	bne.n	8012152 <plan_buffer_line+0x55a>
            // Update previous path unit_vector and planner position.
            memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 8012134:	4b10      	ldr	r3, [pc, #64]	; (8012178 <plan_buffer_line+0x580>)
 8012136:	330c      	adds	r3, #12
 8012138:	f107 0218 	add.w	r2, r7, #24
 801213c:	ca07      	ldmia	r2, {r0, r1, r2}
 801213e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 8012142:	4b0d      	ldr	r3, [pc, #52]	; (8012178 <plan_buffer_line+0x580>)
 8012144:	461c      	mov	r4, r3
 8012146:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801214a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801214e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        }
        // New block is all set. Update buffer head and next buffer head indices.
        block_buffer_head = next_buffer_head;
 8012152:	4b0a      	ldr	r3, [pc, #40]	; (801217c <plan_buffer_line+0x584>)
 8012154:	681b      	ldr	r3, [r3, #0]
 8012156:	4a0a      	ldr	r2, [pc, #40]	; (8012180 <plan_buffer_line+0x588>)
 8012158:	6013      	str	r3, [r2, #0]
        next_buffer_head = block_buffer_head->next;
 801215a:	4b09      	ldr	r3, [pc, #36]	; (8012180 <plan_buffer_line+0x588>)
 801215c:	681b      	ldr	r3, [r3, #0]
 801215e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012160:	4a06      	ldr	r2, [pc, #24]	; (801217c <plan_buffer_line+0x584>)
 8012162:	6013      	str	r3, [r2, #0]

        // Finish up by recalculating the plan with the new block.
        planner_recalculate();
 8012164:	f7ff f97c 	bl	8011460 <planner_recalculate>
    }

    return true;
 8012168:	2301      	movs	r3, #1
}
 801216a:	4618      	mov	r0, r3
 801216c:	3758      	adds	r7, #88	; 0x58
 801216e:	46bd      	mov	sp, r7
 8012170:	bdb0      	pop	{r4, r5, r7, pc}
 8012172:	bf00      	nop
 8012174:	2000147c 	.word	0x2000147c
 8012178:	20001184 	.word	0x20001184
 801217c:	2000117c 	.word	0x2000117c
 8012180:	20001178 	.word	0x20001178

08012184 <plan_get_position>:


// Get the planner position vectors.
float *plan_get_position (void)
{
 8012184:	b580      	push	{r7, lr}
 8012186:	b082      	sub	sp, #8
 8012188:	af00      	add	r7, sp, #0
    static float position[N_AXIS];

    uint_fast8_t idx = N_AXIS;
 801218a:	2303      	movs	r3, #3
 801218c:	607b      	str	r3, [r7, #4]

    do {
        idx--;
 801218e:	687b      	ldr	r3, [r7, #4]
 8012190:	3b01      	subs	r3, #1
 8012192:	607b      	str	r3, [r7, #4]
        position[idx] = pl.position[idx] / settings.axis[idx].steps_per_mm;
 8012194:	4a10      	ldr	r2, [pc, #64]	; (80121d8 <plan_get_position+0x54>)
 8012196:	687b      	ldr	r3, [r7, #4]
 8012198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801219c:	4618      	mov	r0, r3
 801219e:	f7ee fdb5 	bl	8000d0c <__aeabi_i2f>
 80121a2:	490e      	ldr	r1, [pc, #56]	; (80121dc <plan_get_position+0x58>)
 80121a4:	687a      	ldr	r2, [r7, #4]
 80121a6:	4613      	mov	r3, r2
 80121a8:	009b      	lsls	r3, r3, #2
 80121aa:	4413      	add	r3, r2
 80121ac:	009b      	lsls	r3, r3, #2
 80121ae:	440b      	add	r3, r1
 80121b0:	3330      	adds	r3, #48	; 0x30
 80121b2:	681b      	ldr	r3, [r3, #0]
 80121b4:	4619      	mov	r1, r3
 80121b6:	f7ee feb1 	bl	8000f1c <__aeabi_fdiv>
 80121ba:	4603      	mov	r3, r0
 80121bc:	4619      	mov	r1, r3
 80121be:	4a08      	ldr	r2, [pc, #32]	; (80121e0 <plan_get_position+0x5c>)
 80121c0:	687b      	ldr	r3, [r7, #4]
 80121c2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    } while(idx);
 80121c6:	687b      	ldr	r3, [r7, #4]
 80121c8:	2b00      	cmp	r3, #0
 80121ca:	d1e0      	bne.n	801218e <plan_get_position+0xa>

    return position;
 80121cc:	4b04      	ldr	r3, [pc, #16]	; (80121e0 <plan_get_position+0x5c>)
}
 80121ce:	4618      	mov	r0, r3
 80121d0:	3708      	adds	r7, #8
 80121d2:	46bd      	mov	sp, r7
 80121d4:	bd80      	pop	{r7, pc}
 80121d6:	bf00      	nop
 80121d8:	20001184 	.word	0x20001184
 80121dc:	2000147c 	.word	0x2000147c
 80121e0:	200011a0 	.word	0x200011a0

080121e4 <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position (void)
{
 80121e4:	b490      	push	{r4, r7}
 80121e6:	af00      	add	r7, sp, #0
    memcpy(pl.position, sys.position, sizeof(pl.position));
 80121e8:	4a05      	ldr	r2, [pc, #20]	; (8012200 <plan_sync_position+0x1c>)
 80121ea:	4b06      	ldr	r3, [pc, #24]	; (8012204 <plan_sync_position+0x20>)
 80121ec:	4614      	mov	r4, r2
 80121ee:	3388      	adds	r3, #136	; 0x88
 80121f0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80121f4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
#if ENABLE_BACKLASH_COMPENSATION
    mc_sync_backlash_position();
#endif
}
 80121f8:	bf00      	nop
 80121fa:	46bd      	mov	sp, r7
 80121fc:	bc90      	pop	{r4, r7}
 80121fe:	4770      	bx	lr
 8012200:	20001184 	.word	0x20001184
 8012204:	20000d3c 	.word	0x20000d3c

08012208 <plan_get_block_buffer_available>:


// Returns the number of available blocks are in the planner buffer.
uint_fast16_t plan_get_block_buffer_available (void)
{
 8012208:	b480      	push	{r7}
 801220a:	af00      	add	r7, sp, #0
    return (uint_fast16_t)(block_buffer_head >= block_buffer_tail
 801220c:	4b10      	ldr	r3, [pc, #64]	; (8012250 <plan_get_block_buffer_available+0x48>)
 801220e:	681a      	ldr	r2, [r3, #0]
 8012210:	4b10      	ldr	r3, [pc, #64]	; (8012254 <plan_get_block_buffer_available+0x4c>)
 8012212:	681b      	ldr	r3, [r3, #0]
 8012214:	429a      	cmp	r2, r3
 8012216:	d30c      	bcc.n	8012232 <plan_get_block_buffer_available+0x2a>
                            ? (block_buffer_size - (block_buffer_head - block_buffer_tail))
 8012218:	4b0f      	ldr	r3, [pc, #60]	; (8012258 <plan_get_block_buffer_available+0x50>)
 801221a:	681b      	ldr	r3, [r3, #0]
 801221c:	4a0c      	ldr	r2, [pc, #48]	; (8012250 <plan_get_block_buffer_available+0x48>)
 801221e:	6811      	ldr	r1, [r2, #0]
 8012220:	4a0c      	ldr	r2, [pc, #48]	; (8012254 <plan_get_block_buffer_available+0x4c>)
 8012222:	6812      	ldr	r2, [r2, #0]
 8012224:	1a8a      	subs	r2, r1, r2
 8012226:	1092      	asrs	r2, r2, #2
 8012228:	490c      	ldr	r1, [pc, #48]	; (801225c <plan_get_block_buffer_available+0x54>)
 801222a:	fb01 f202 	mul.w	r2, r1, r2
    return (uint_fast16_t)(block_buffer_head >= block_buffer_tail
 801222e:	1a9b      	subs	r3, r3, r2
 8012230:	e009      	b.n	8012246 <plan_get_block_buffer_available+0x3e>
                            : ((block_buffer_tail - block_buffer_head) - 1));
 8012232:	4b08      	ldr	r3, [pc, #32]	; (8012254 <plan_get_block_buffer_available+0x4c>)
 8012234:	681a      	ldr	r2, [r3, #0]
 8012236:	4b06      	ldr	r3, [pc, #24]	; (8012250 <plan_get_block_buffer_available+0x48>)
 8012238:	681b      	ldr	r3, [r3, #0]
 801223a:	1ad3      	subs	r3, r2, r3
 801223c:	109b      	asrs	r3, r3, #2
 801223e:	4a07      	ldr	r2, [pc, #28]	; (801225c <plan_get_block_buffer_available+0x54>)
 8012240:	fb02 f303 	mul.w	r3, r2, r3
 8012244:	3b01      	subs	r3, #1
}
 8012246:	4618      	mov	r0, r3
 8012248:	46bd      	mov	sp, r7
 801224a:	bc80      	pop	{r7}
 801224c:	4770      	bx	lr
 801224e:	bf00      	nop
 8012250:	20001178 	.word	0x20001178
 8012254:	20001174 	.word	0x20001174
 8012258:	2000116c 	.word	0x2000116c
 801225c:	e9bd37a7 	.word	0xe9bd37a7

08012260 <plan_cycle_reinitialize>:


// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize (void)
{
 8012260:	b580      	push	{r7, lr}
 8012262:	af00      	add	r7, sp, #0
    // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
    st_update_plan_block_parameters();
 8012264:	f00c ff8e 	bl	801f184 <st_update_plan_block_parameters>
    block_buffer_planned = block_buffer_tail;
 8012268:	4b03      	ldr	r3, [pc, #12]	; (8012278 <plan_cycle_reinitialize+0x18>)
 801226a:	681b      	ldr	r3, [r3, #0]
 801226c:	4a03      	ldr	r2, [pc, #12]	; (801227c <plan_cycle_reinitialize+0x1c>)
 801226e:	6013      	str	r3, [r2, #0]
    planner_recalculate();
 8012270:	f7ff f8f6 	bl	8011460 <planner_recalculate>
}
 8012274:	bf00      	nop
 8012276:	bd80      	pop	{r7, pc}
 8012278:	20001174 	.word	0x20001174
 801227c:	20001180 	.word	0x20001180

08012280 <plan_update_velocity_profile_parameters>:

// Re-calculates buffered motions profile parameters upon a motion-based override change.
static bool plan_update_velocity_profile_parameters (void)
{
 8012280:	b580      	push	{r7, lr}
 8012282:	b082      	sub	sp, #8
 8012284:	af00      	add	r7, sp, #0
    if(block_buffer_tail != block_buffer_head) {
 8012286:	4b17      	ldr	r3, [pc, #92]	; (80122e4 <plan_update_velocity_profile_parameters+0x64>)
 8012288:	681a      	ldr	r2, [r3, #0]
 801228a:	4b17      	ldr	r3, [pc, #92]	; (80122e8 <plan_update_velocity_profile_parameters+0x68>)
 801228c:	681b      	ldr	r3, [r3, #0]
 801228e:	429a      	cmp	r2, r3
 8012290:	d01a      	beq.n	80122c8 <plan_update_velocity_profile_parameters+0x48>

        plan_block_t *block = block_buffer_tail;
 8012292:	4b14      	ldr	r3, [pc, #80]	; (80122e4 <plan_update_velocity_profile_parameters+0x64>)
 8012294:	681b      	ldr	r3, [r3, #0]
 8012296:	607b      	str	r3, [r7, #4]
        float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 8012298:	4b14      	ldr	r3, [pc, #80]	; (80122ec <plan_update_velocity_profile_parameters+0x6c>)
 801229a:	603b      	str	r3, [r7, #0]

        while (block != block_buffer_head) {
 801229c:	e00c      	b.n	80122b8 <plan_update_velocity_profile_parameters+0x38>
            prev_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), prev_nominal_speed);
 801229e:	6878      	ldr	r0, [r7, #4]
 80122a0:	f7ff fb5e 	bl	8011960 <plan_compute_profile_nominal_speed>
 80122a4:	4603      	mov	r3, r0
 80122a6:	683a      	ldr	r2, [r7, #0]
 80122a8:	4619      	mov	r1, r3
 80122aa:	6878      	ldr	r0, [r7, #4]
 80122ac:	f7ff fbc8 	bl	8011a40 <plan_compute_profile_parameters>
 80122b0:	6038      	str	r0, [r7, #0]
            block = block->next;
 80122b2:	687b      	ldr	r3, [r7, #4]
 80122b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80122b6:	607b      	str	r3, [r7, #4]
        while (block != block_buffer_head) {
 80122b8:	4b0b      	ldr	r3, [pc, #44]	; (80122e8 <plan_update_velocity_profile_parameters+0x68>)
 80122ba:	681b      	ldr	r3, [r3, #0]
 80122bc:	687a      	ldr	r2, [r7, #4]
 80122be:	429a      	cmp	r2, r3
 80122c0:	d1ed      	bne.n	801229e <plan_update_velocity_profile_parameters+0x1e>
        }

        pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming block.
 80122c2:	4a0b      	ldr	r2, [pc, #44]	; (80122f0 <plan_update_velocity_profile_parameters+0x70>)
 80122c4:	683b      	ldr	r3, [r7, #0]
 80122c6:	6193      	str	r3, [r2, #24]
    }

    return block_buffer_tail != block_buffer_head;
 80122c8:	4b06      	ldr	r3, [pc, #24]	; (80122e4 <plan_update_velocity_profile_parameters+0x64>)
 80122ca:	681a      	ldr	r2, [r3, #0]
 80122cc:	4b06      	ldr	r3, [pc, #24]	; (80122e8 <plan_update_velocity_profile_parameters+0x68>)
 80122ce:	681b      	ldr	r3, [r3, #0]
 80122d0:	429a      	cmp	r2, r3
 80122d2:	bf14      	ite	ne
 80122d4:	2301      	movne	r3, #1
 80122d6:	2300      	moveq	r3, #0
 80122d8:	b2db      	uxtb	r3, r3
}
 80122da:	4618      	mov	r0, r3
 80122dc:	3708      	adds	r7, #8
 80122de:	46bd      	mov	sp, r7
 80122e0:	bd80      	pop	{r7, pc}
 80122e2:	bf00      	nop
 80122e4:	20001174 	.word	0x20001174
 80122e8:	20001178 	.word	0x20001178
 80122ec:	7e967699 	.word	0x7e967699
 80122f0:	20001184 	.word	0x20001184

080122f4 <plan_feed_override>:

// Set feed overrides
void plan_feed_override (override_t feed_override, override_t rapid_override)
{
 80122f4:	b580      	push	{r7, lr}
 80122f6:	b084      	sub	sp, #16
 80122f8:	af00      	add	r7, sp, #0
 80122fa:	6078      	str	r0, [r7, #4]
 80122fc:	6039      	str	r1, [r7, #0]
    bool feedrate_changed = false, rapidrate_changed = false;
 80122fe:	2300      	movs	r3, #0
 8012300:	73bb      	strb	r3, [r7, #14]
 8012302:	2300      	movs	r3, #0
 8012304:	73fb      	strb	r3, [r7, #15]

    if(sys.override.control.feed_rate_disable)
 8012306:	4b27      	ldr	r3, [pc, #156]	; (80123a4 <plan_feed_override+0xb0>)
 8012308:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801230c:	f003 0301 	and.w	r3, r3, #1
 8012310:	b2db      	uxtb	r3, r3
 8012312:	2b00      	cmp	r3, #0
 8012314:	d142      	bne.n	801239c <plan_feed_override+0xa8>
        return;

    feed_override = constrain(feed_override, MIN_FEED_RATE_OVERRIDE, MAX_FEED_RATE_OVERRIDE);
 8012316:	687b      	ldr	r3, [r7, #4]
 8012318:	2b09      	cmp	r3, #9
 801231a:	d904      	bls.n	8012326 <plan_feed_override+0x32>
 801231c:	687b      	ldr	r3, [r7, #4]
 801231e:	2bc8      	cmp	r3, #200	; 0xc8
 8012320:	bf28      	it	cs
 8012322:	23c8      	movcs	r3, #200	; 0xc8
 8012324:	e000      	b.n	8012328 <plan_feed_override+0x34>
 8012326:	230a      	movs	r3, #10
 8012328:	607b      	str	r3, [r7, #4]

    if((feedrate_changed = feed_override != sys.override.feed_rate) ||
 801232a:	4b1e      	ldr	r3, [pc, #120]	; (80123a4 <plan_feed_override+0xb0>)
 801232c:	69db      	ldr	r3, [r3, #28]
 801232e:	687a      	ldr	r2, [r7, #4]
 8012330:	429a      	cmp	r2, r3
 8012332:	bf14      	ite	ne
 8012334:	2301      	movne	r3, #1
 8012336:	2300      	moveq	r3, #0
 8012338:	73bb      	strb	r3, [r7, #14]
 801233a:	7bbb      	ldrb	r3, [r7, #14]
 801233c:	2b00      	cmp	r3, #0
 801233e:	d10a      	bne.n	8012356 <plan_feed_override+0x62>
         (rapidrate_changed = rapid_override != sys.override.rapid_rate)) {
 8012340:	4b18      	ldr	r3, [pc, #96]	; (80123a4 <plan_feed_override+0xb0>)
 8012342:	6a1b      	ldr	r3, [r3, #32]
 8012344:	683a      	ldr	r2, [r7, #0]
 8012346:	429a      	cmp	r2, r3
 8012348:	bf14      	ite	ne
 801234a:	2301      	movne	r3, #1
 801234c:	2300      	moveq	r3, #0
 801234e:	73fb      	strb	r3, [r7, #15]
    if((feedrate_changed = feed_override != sys.override.feed_rate) ||
 8012350:	7bfb      	ldrb	r3, [r7, #15]
 8012352:	2b00      	cmp	r3, #0
 8012354:	d023      	beq.n	801239e <plan_feed_override+0xaa>
        sys.override.feed_rate = feed_override;
 8012356:	4a13      	ldr	r2, [pc, #76]	; (80123a4 <plan_feed_override+0xb0>)
 8012358:	687b      	ldr	r3, [r7, #4]
 801235a:	61d3      	str	r3, [r2, #28]
        sys.override.rapid_rate = rapid_override;
 801235c:	4a11      	ldr	r2, [pc, #68]	; (80123a4 <plan_feed_override+0xb0>)
 801235e:	683b      	ldr	r3, [r7, #0]
 8012360:	6213      	str	r3, [r2, #32]
        system_add_rt_report(Report_Overrides); // Set to report change immediately
 8012362:	2040      	movs	r0, #64	; 0x40
 8012364:	f00f fe1a 	bl	8021f9c <system_add_rt_report>
        if(plan_update_velocity_profile_parameters())
 8012368:	f7ff ff8a 	bl	8012280 <plan_update_velocity_profile_parameters>
 801236c:	4603      	mov	r3, r0
 801236e:	2b00      	cmp	r3, #0
 8012370:	d001      	beq.n	8012376 <plan_feed_override+0x82>
            plan_cycle_reinitialize();
 8012372:	f7ff ff75 	bl	8012260 <plan_cycle_reinitialize>
        if(grbl.on_override_changed) {
 8012376:	4b0c      	ldr	r3, [pc, #48]	; (80123a8 <plan_feed_override+0xb4>)
 8012378:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801237a:	2b00      	cmp	r3, #0
 801237c:	d00f      	beq.n	801239e <plan_feed_override+0xaa>
            if(feedrate_changed)
 801237e:	7bbb      	ldrb	r3, [r7, #14]
 8012380:	2b00      	cmp	r3, #0
 8012382:	d003      	beq.n	801238c <plan_feed_override+0x98>
                grbl.on_override_changed(OverrideChanged_FeedRate);
 8012384:	4b08      	ldr	r3, [pc, #32]	; (80123a8 <plan_feed_override+0xb4>)
 8012386:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012388:	2000      	movs	r0, #0
 801238a:	4798      	blx	r3
            if(rapidrate_changed)
 801238c:	7bfb      	ldrb	r3, [r7, #15]
 801238e:	2b00      	cmp	r3, #0
 8012390:	d005      	beq.n	801239e <plan_feed_override+0xaa>
                grbl.on_override_changed(OverrideChanged_RapidRate);
 8012392:	4b05      	ldr	r3, [pc, #20]	; (80123a8 <plan_feed_override+0xb4>)
 8012394:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8012396:	2000      	movs	r0, #0
 8012398:	4798      	blx	r3
 801239a:	e000      	b.n	801239e <plan_feed_override+0xaa>
        return;
 801239c:	bf00      	nop
        }
    }
}
 801239e:	3710      	adds	r7, #16
 80123a0:	46bd      	mov	sp, r7
 80123a2:	bd80      	pop	{r7, pc}
 80123a4:	20000d3c 	.word	0x20000d3c
 80123a8:	20000dd4 	.word	0x20000dd4

080123ac <plan_data_init>:

void plan_data_init (plan_line_data_t *plan_data)
{
 80123ac:	b580      	push	{r7, lr}
 80123ae:	b082      	sub	sp, #8
 80123b0:	af00      	add	r7, sp, #0
 80123b2:	6078      	str	r0, [r7, #4]
    memset(plan_data, 0, sizeof(plan_line_data_t));
 80123b4:	222c      	movs	r2, #44	; 0x2c
 80123b6:	2100      	movs	r1, #0
 80123b8:	6878      	ldr	r0, [r7, #4]
 80123ba:	f011 fc2c 	bl	8023c16 <memset>
    plan_data->spindle.hal = gc_state.spindle.hal ? gc_state.spindle.hal : spindle_get(0);
 80123be:	4b16      	ldr	r3, [pc, #88]	; (8012418 <plan_data_init+0x6c>)
 80123c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80123c2:	2b00      	cmp	r3, #0
 80123c4:	d002      	beq.n	80123cc <plan_data_init+0x20>
 80123c6:	4b14      	ldr	r3, [pc, #80]	; (8012418 <plan_data_init+0x6c>)
 80123c8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80123ca:	e003      	b.n	80123d4 <plan_data_init+0x28>
 80123cc:	2000      	movs	r0, #0
 80123ce:	f00a fb95 	bl	801cafc <spindle_get>
 80123d2:	4603      	mov	r3, r0
 80123d4:	687a      	ldr	r2, [r7, #4]
 80123d6:	6153      	str	r3, [r2, #20]
    plan_data->condition.target_validated = plan_data->condition.target_valid = sys.soft_limits.mask == 0;
 80123d8:	4b10      	ldr	r3, [pc, #64]	; (801241c <plan_data_init+0x70>)
 80123da:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80123de:	2b00      	cmp	r3, #0
 80123e0:	bf0c      	ite	eq
 80123e2:	2301      	moveq	r3, #1
 80123e4:	2300      	movne	r3, #0
 80123e6:	b2d9      	uxtb	r1, r3
 80123e8:	687a      	ldr	r2, [r7, #4]
 80123ea:	7e53      	ldrb	r3, [r2, #25]
 80123ec:	f361 0300 	bfi	r3, r1, #0, #1
 80123f0:	7653      	strb	r3, [r2, #25]
 80123f2:	687b      	ldr	r3, [r7, #4]
 80123f4:	7e5b      	ldrb	r3, [r3, #25]
 80123f6:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80123fa:	b2d9      	uxtb	r1, r3
 80123fc:	687a      	ldr	r2, [r7, #4]
 80123fe:	7e53      	ldrb	r3, [r2, #25]
 8012400:	f361 0341 	bfi	r3, r1, #1, #1
 8012404:	7653      	strb	r3, [r2, #25]
#ifdef KINEMATICS_API
    plan_data->rate_multiplier = 1.0;
 8012406:	687b      	ldr	r3, [r7, #4]
 8012408:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 801240c:	605a      	str	r2, [r3, #4]
#endif
}
 801240e:	bf00      	nop
 8012410:	3708      	adds	r7, #8
 8012412:	46bd      	mov	sp, r7
 8012414:	bd80      	pop	{r7, pc}
 8012416:	bf00      	nop
 8012418:	20000bb0 	.word	0x20000bb0
 801241c:	20000d3c 	.word	0x20000d3c

08012420 <protocol_enqueue_gcode>:
static void protocol_exec_rt_suspend (sys_state_t state);
static void protocol_execute_rt_commands (void);

// add gcode to execute not originating from normal input stream
bool protocol_enqueue_gcode (char *gcode)
{
 8012420:	b580      	push	{r7, lr}
 8012422:	b084      	sub	sp, #16
 8012424:	af00      	add	r7, sp, #0
 8012426:	6078      	str	r0, [r7, #4]
    bool ok = xcommand[0] == '\0' &&
 8012428:	4b22      	ldr	r3, [pc, #136]	; (80124b4 <protocol_enqueue_gcode+0x94>)
 801242a:	781b      	ldrb	r3, [r3, #0]
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 801242c:	2b00      	cmp	r3, #0
 801242e:	d113      	bne.n	8012458 <protocol_enqueue_gcode+0x38>
 8012430:	f00b fa46 	bl	801d8c0 <state_get>
 8012434:	4603      	mov	r3, r0
    bool ok = xcommand[0] == '\0' &&
 8012436:	2b00      	cmp	r3, #0
 8012438:	d006      	beq.n	8012448 <protocol_enqueue_gcode+0x28>
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 801243a:	f00b fa41 	bl	801d8c0 <state_get>
 801243e:	4603      	mov	r3, r0
 8012440:	f403 7308 	and.w	r3, r3, #544	; 0x220
 8012444:	2b00      	cmp	r3, #0
 8012446:	d007      	beq.n	8012458 <protocol_enqueue_gcode+0x38>
                 bit_isfalse(sys.rt_exec_state, EXEC_MOTION_CANCEL);
 8012448:	4b1b      	ldr	r3, [pc, #108]	; (80124b8 <protocol_enqueue_gcode+0x98>)
 801244a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801244c:	f003 0380 	and.w	r3, r3, #128	; 0x80
               (state_get() == STATE_IDLE || (state_get() & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 8012450:	2b00      	cmp	r3, #0
 8012452:	d101      	bne.n	8012458 <protocol_enqueue_gcode+0x38>
 8012454:	2301      	movs	r3, #1
 8012456:	e000      	b.n	801245a <protocol_enqueue_gcode+0x3a>
 8012458:	2300      	movs	r3, #0
    bool ok = xcommand[0] == '\0' &&
 801245a:	73fb      	strb	r3, [r7, #15]
 801245c:	7bfb      	ldrb	r3, [r7, #15]
 801245e:	f003 0301 	and.w	r3, r3, #1
 8012462:	73fb      	strb	r3, [r7, #15]

    if(ok && gc_state.file_run)
 8012464:	7bfb      	ldrb	r3, [r7, #15]
 8012466:	2b00      	cmp	r3, #0
 8012468:	d018      	beq.n	801249c <protocol_enqueue_gcode+0x7c>
 801246a:	4b14      	ldr	r3, [pc, #80]	; (80124bc <protocol_enqueue_gcode+0x9c>)
 801246c:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8012470:	2b00      	cmp	r3, #0
 8012472:	d013      	beq.n	801249c <protocol_enqueue_gcode+0x7c>
        ok = gc_state.modal.program_flow != ProgramFlow_Running || strncmp((char *)gcode, "$J=", 3);
 8012474:	4b11      	ldr	r3, [pc, #68]	; (80124bc <protocol_enqueue_gcode+0x9c>)
 8012476:	7e1b      	ldrb	r3, [r3, #24]
 8012478:	2b00      	cmp	r3, #0
 801247a:	d107      	bne.n	801248c <protocol_enqueue_gcode+0x6c>
 801247c:	2203      	movs	r2, #3
 801247e:	4910      	ldr	r1, [pc, #64]	; (80124c0 <protocol_enqueue_gcode+0xa0>)
 8012480:	6878      	ldr	r0, [r7, #4]
 8012482:	f011 fbec 	bl	8023c5e <strncmp>
 8012486:	4603      	mov	r3, r0
 8012488:	2b00      	cmp	r3, #0
 801248a:	d001      	beq.n	8012490 <protocol_enqueue_gcode+0x70>
 801248c:	2301      	movs	r3, #1
 801248e:	e000      	b.n	8012492 <protocol_enqueue_gcode+0x72>
 8012490:	2300      	movs	r3, #0
 8012492:	73fb      	strb	r3, [r7, #15]
 8012494:	7bfb      	ldrb	r3, [r7, #15]
 8012496:	f003 0301 	and.w	r3, r3, #1
 801249a:	73fb      	strb	r3, [r7, #15]

    if(ok)
 801249c:	7bfb      	ldrb	r3, [r7, #15]
 801249e:	2b00      	cmp	r3, #0
 80124a0:	d003      	beq.n	80124aa <protocol_enqueue_gcode+0x8a>
        strcpy(xcommand, gcode);
 80124a2:	6879      	ldr	r1, [r7, #4]
 80124a4:	4803      	ldr	r0, [pc, #12]	; (80124b4 <protocol_enqueue_gcode+0x94>)
 80124a6:	f011 fd0a 	bl	8023ebe <strcpy>

    return ok;
 80124aa:	7bfb      	ldrb	r3, [r7, #15]
}
 80124ac:	4618      	mov	r0, r3
 80124ae:	3710      	adds	r7, #16
 80124b0:	46bd      	mov	sp, r7
 80124b2:	bd80      	pop	{r7, pc}
 80124b4:	200012b4 	.word	0x200012b4
 80124b8:	20000d3c 	.word	0x20000d3c
 80124bc:	20000bb0 	.word	0x20000bb0
 80124c0:	0802abd0 	.word	0x0802abd0

080124c4 <recheck_line>:

static bool recheck_line (char *line, line_flags_t *flags)
{
 80124c4:	b480      	push	{r7}
 80124c6:	b085      	sub	sp, #20
 80124c8:	af00      	add	r7, sp, #0
 80124ca:	6078      	str	r0, [r7, #4]
 80124cc:	6039      	str	r1, [r7, #0]
    bool keep_rt_commands = false, first_char = true;
 80124ce:	2300      	movs	r3, #0
 80124d0:	73fb      	strb	r3, [r7, #15]
 80124d2:	2301      	movs	r3, #1
 80124d4:	73bb      	strb	r3, [r7, #14]

    flags->value = 0;
 80124d6:	683b      	ldr	r3, [r7, #0]
 80124d8:	2200      	movs	r2, #0
 80124da:	701a      	strb	r2, [r3, #0]

    if(*line != '\0') do {
 80124dc:	687b      	ldr	r3, [r7, #4]
 80124de:	781b      	ldrb	r3, [r3, #0]
 80124e0:	2b00      	cmp	r3, #0
 80124e2:	f000 809e 	beq.w	8012622 <recheck_line+0x15e>

        switch(*line) {
 80124e6:	687b      	ldr	r3, [r7, #4]
 80124e8:	781b      	ldrb	r3, [r3, #0]
 80124ea:	2b3b      	cmp	r3, #59	; 0x3b
 80124ec:	dc3a      	bgt.n	8012564 <recheck_line+0xa0>
 80124ee:	2b24      	cmp	r3, #36	; 0x24
 80124f0:	f2c0 808d 	blt.w	801260e <recheck_line+0x14a>
 80124f4:	3b24      	subs	r3, #36	; 0x24
 80124f6:	2b17      	cmp	r3, #23
 80124f8:	f200 8089 	bhi.w	801260e <recheck_line+0x14a>
 80124fc:	a201      	add	r2, pc, #4	; (adr r2, 8012504 <recheck_line+0x40>)
 80124fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012502:	bf00      	nop
 8012504:	08012569 	.word	0x08012569
 8012508:	0801260f 	.word	0x0801260f
 801250c:	0801260f 	.word	0x0801260f
 8012510:	0801260f 	.word	0x0801260f
 8012514:	08012575 	.word	0x08012575
 8012518:	080125c5 	.word	0x080125c5
 801251c:	0801260f 	.word	0x0801260f
 8012520:	0801260f 	.word	0x0801260f
 8012524:	0801260f 	.word	0x0801260f
 8012528:	0801260f 	.word	0x0801260f
 801252c:	0801260f 	.word	0x0801260f
 8012530:	0801260f 	.word	0x0801260f
 8012534:	0801260f 	.word	0x0801260f
 8012538:	0801260f 	.word	0x0801260f
 801253c:	0801260f 	.word	0x0801260f
 8012540:	0801260f 	.word	0x0801260f
 8012544:	0801260f 	.word	0x0801260f
 8012548:	0801260f 	.word	0x0801260f
 801254c:	0801260f 	.word	0x0801260f
 8012550:	0801260f 	.word	0x0801260f
 8012554:	0801260f 	.word	0x0801260f
 8012558:	0801260f 	.word	0x0801260f
 801255c:	0801260f 	.word	0x0801260f
 8012560:	080125e3 	.word	0x080125e3
 8012564:	2b5b      	cmp	r3, #91	; 0x5b
 8012566:	d152      	bne.n	801260e <recheck_line+0x14a>

            case '$':
            case '[':
                if(first_char)
 8012568:	7bbb      	ldrb	r3, [r7, #14]
 801256a:	2b00      	cmp	r3, #0
 801256c:	d048      	beq.n	8012600 <recheck_line+0x13c>
                    keep_rt_commands = true;
 801256e:	2301      	movs	r3, #1
 8012570:	73fb      	strb	r3, [r7, #15]
                break;
 8012572:	e045      	b.n	8012600 <recheck_line+0x13c>

            case '(':
                if(!keep_rt_commands && (flags->comment_parentheses = !flags->comment_semicolon))
 8012574:	7bfb      	ldrb	r3, [r7, #15]
 8012576:	f083 0301 	eor.w	r3, r3, #1
 801257a:	b2db      	uxtb	r3, r3
 801257c:	2b00      	cmp	r3, #0
 801257e:	d041      	beq.n	8012604 <recheck_line+0x140>
 8012580:	683b      	ldr	r3, [r7, #0]
 8012582:	781b      	ldrb	r3, [r3, #0]
 8012584:	f003 0304 	and.w	r3, r3, #4
 8012588:	b2db      	uxtb	r3, r3
 801258a:	2b00      	cmp	r3, #0
 801258c:	bf0c      	ite	eq
 801258e:	2301      	moveq	r3, #1
 8012590:	2300      	movne	r3, #0
 8012592:	b2d9      	uxtb	r1, r3
 8012594:	683a      	ldr	r2, [r7, #0]
 8012596:	7813      	ldrb	r3, [r2, #0]
 8012598:	f361 0341 	bfi	r3, r1, #1, #1
 801259c:	7013      	strb	r3, [r2, #0]
 801259e:	683b      	ldr	r3, [r7, #0]
 80125a0:	781b      	ldrb	r3, [r3, #0]
 80125a2:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80125a6:	b2db      	uxtb	r3, r3
 80125a8:	2b00      	cmp	r3, #0
 80125aa:	d02b      	beq.n	8012604 <recheck_line+0x140>
                    keep_rt_commands = !hal.driver_cap.no_gcode_message_handling; // Suspend real-time processing of printable command characters.
 80125ac:	4b20      	ldr	r3, [pc, #128]	; (8012630 <recheck_line+0x16c>)
 80125ae:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 80125b2:	f003 0308 	and.w	r3, r3, #8
 80125b6:	b2db      	uxtb	r3, r3
 80125b8:	2b00      	cmp	r3, #0
 80125ba:	bf0c      	ite	eq
 80125bc:	2301      	moveq	r3, #1
 80125be:	2300      	movne	r3, #0
 80125c0:	73fb      	strb	r3, [r7, #15]
                break;
 80125c2:	e01f      	b.n	8012604 <recheck_line+0x140>

            case ')':
                if(!flags->comment_semicolon)
 80125c4:	683b      	ldr	r3, [r7, #0]
 80125c6:	781b      	ldrb	r3, [r3, #0]
 80125c8:	f003 0304 	and.w	r3, r3, #4
 80125cc:	b2db      	uxtb	r3, r3
 80125ce:	2b00      	cmp	r3, #0
 80125d0:	d11a      	bne.n	8012608 <recheck_line+0x144>
                    flags->comment_parentheses = keep_rt_commands = false;
 80125d2:	2300      	movs	r3, #0
 80125d4:	73fb      	strb	r3, [r7, #15]
 80125d6:	683a      	ldr	r2, [r7, #0]
 80125d8:	7813      	ldrb	r3, [r2, #0]
 80125da:	f36f 0341 	bfc	r3, #1, #1
 80125de:	7013      	strb	r3, [r2, #0]
                break;
 80125e0:	e012      	b.n	8012608 <recheck_line+0x144>

            case ';':
                if(!flags->comment_parentheses) {
 80125e2:	683b      	ldr	r3, [r7, #0]
 80125e4:	781b      	ldrb	r3, [r3, #0]
 80125e6:	f003 0302 	and.w	r3, r3, #2
 80125ea:	b2db      	uxtb	r3, r3
 80125ec:	2b00      	cmp	r3, #0
 80125ee:	d10d      	bne.n	801260c <recheck_line+0x148>
                    keep_rt_commands = false;
 80125f0:	2300      	movs	r3, #0
 80125f2:	73fb      	strb	r3, [r7, #15]
                    flags->comment_semicolon = On;
 80125f4:	683a      	ldr	r2, [r7, #0]
 80125f6:	7813      	ldrb	r3, [r2, #0]
 80125f8:	f043 0304 	orr.w	r3, r3, #4
 80125fc:	7013      	strb	r3, [r2, #0]
                }
                break;
 80125fe:	e005      	b.n	801260c <recheck_line+0x148>
                break;
 8012600:	bf00      	nop
 8012602:	e004      	b.n	801260e <recheck_line+0x14a>
                break;
 8012604:	bf00      	nop
 8012606:	e002      	b.n	801260e <recheck_line+0x14a>
                break;
 8012608:	bf00      	nop
 801260a:	e000      	b.n	801260e <recheck_line+0x14a>
                break;
 801260c:	bf00      	nop
        }

        first_char = false;
 801260e:	2300      	movs	r3, #0
 8012610:	73bb      	strb	r3, [r7, #14]

    } while(*++line != '\0');
 8012612:	687b      	ldr	r3, [r7, #4]
 8012614:	3301      	adds	r3, #1
 8012616:	607b      	str	r3, [r7, #4]
 8012618:	687b      	ldr	r3, [r7, #4]
 801261a:	781b      	ldrb	r3, [r3, #0]
 801261c:	2b00      	cmp	r3, #0
 801261e:	f47f af62 	bne.w	80124e6 <recheck_line+0x22>

    return keep_rt_commands;
 8012622:	7bfb      	ldrb	r3, [r7, #15]
}
 8012624:	4618      	mov	r0, r3
 8012626:	3714      	adds	r7, #20
 8012628:	46bd      	mov	sp, r7
 801262a:	bc80      	pop	{r7}
 801262c:	4770      	bx	lr
 801262e:	bf00      	nop
 8012630:	20000ed0 	.word	0x20000ed0

08012634 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
bool protocol_main_loop (void)
{
 8012634:	b580      	push	{r7, lr}
 8012636:	b084      	sub	sp, #16
 8012638:	af00      	add	r7, sp, #0
    if(sys.alarm == Alarm_SelftestFailed) {
 801263a:	4ba4      	ldr	r3, [pc, #656]	; (80128cc <protocol_main_loop+0x298>)
 801263c:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8012640:	2b10      	cmp	r3, #16
 8012642:	d107      	bne.n	8012654 <protocol_main_loop+0x20>
        sys.alarm = Alarm_None;
 8012644:	4ba1      	ldr	r3, [pc, #644]	; (80128cc <protocol_main_loop+0x298>)
 8012646:	2200      	movs	r2, #0
 8012648:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        system_raise_alarm(Alarm_SelftestFailed);
 801264c:	2010      	movs	r0, #16
 801264e:	f00f fc39 	bl	8021ec4 <system_raise_alarm>
 8012652:	e0e9      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if (hal.control.get_state().e_stop) {
 8012654:	4b9e      	ldr	r3, [pc, #632]	; (80128d0 <protocol_main_loop+0x29c>)
 8012656:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8012658:	4798      	blx	r3
 801265a:	4603      	mov	r3, r0
 801265c:	b2db      	uxtb	r3, r3
 801265e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012662:	b2db      	uxtb	r3, r3
 8012664:	2b00      	cmp	r3, #0
 8012666:	d007      	beq.n	8012678 <protocol_main_loop+0x44>
        // Check for e-stop active. Blocks everything until cleared.
        system_raise_alarm(Alarm_EStop);
 8012668:	200a      	movs	r0, #10
 801266a:	f00f fc2b 	bl	8021ec4 <system_raise_alarm>
        grbl.report.feedback_message(Message_EStop);
 801266e:	4b99      	ldr	r3, [pc, #612]	; (80128d4 <protocol_main_loop+0x2a0>)
 8012670:	68db      	ldr	r3, [r3, #12]
 8012672:	200c      	movs	r0, #12
 8012674:	4798      	blx	r3
 8012676:	e0d7      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if(hal.control.get_state().motor_fault) {
 8012678:	4b95      	ldr	r3, [pc, #596]	; (80128d0 <protocol_main_loop+0x29c>)
 801267a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801267c:	4798      	blx	r3
 801267e:	4603      	mov	r3, r0
 8012680:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8012684:	b2db      	uxtb	r3, r3
 8012686:	f003 0301 	and.w	r3, r3, #1
 801268a:	b2db      	uxtb	r3, r3
 801268c:	2b00      	cmp	r3, #0
 801268e:	d007      	beq.n	80126a0 <protocol_main_loop+0x6c>
        // Check for motor fault active. Blocks everything until cleared.
        system_raise_alarm(Alarm_MotorFault);
 8012690:	2011      	movs	r0, #17
 8012692:	f00f fc17 	bl	8021ec4 <system_raise_alarm>
        grbl.report.feedback_message(Message_MotorFault);
 8012696:	4b8f      	ldr	r3, [pc, #572]	; (80128d4 <protocol_main_loop+0x2a0>)
 8012698:	68db      	ldr	r3, [r3, #12]
 801269a:	2010      	movs	r0, #16
 801269c:	4798      	blx	r3
 801269e:	e0c3      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if(settings.probe.enable_protection && hal.control.get_state().probe_triggered) {
 80126a0:	4b8d      	ldr	r3, [pc, #564]	; (80128d8 <protocol_main_loop+0x2a4>)
 80126a2:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80126a6:	f003 0320 	and.w	r3, r3, #32
 80126aa:	b2db      	uxtb	r3, r3
 80126ac:	2b00      	cmp	r3, #0
 80126ae:	d013      	beq.n	80126d8 <protocol_main_loop+0xa4>
 80126b0:	4b87      	ldr	r3, [pc, #540]	; (80128d0 <protocol_main_loop+0x29c>)
 80126b2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80126b4:	4798      	blx	r3
 80126b6:	4603      	mov	r3, r0
 80126b8:	f3c3 2307 	ubfx	r3, r3, #8, #8
 80126bc:	b2db      	uxtb	r3, r3
 80126be:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80126c2:	b2db      	uxtb	r3, r3
 80126c4:	2b00      	cmp	r3, #0
 80126c6:	d007      	beq.n	80126d8 <protocol_main_loop+0xa4>
        system_raise_alarm(Alarm_ProbeProtect);
 80126c8:	200d      	movs	r0, #13
 80126ca:	f00f fbfb 	bl	8021ec4 <system_raise_alarm>
        grbl.report.feedback_message(Message_ProbeProtected);
 80126ce:	4b81      	ldr	r3, [pc, #516]	; (80128d4 <protocol_main_loop+0x2a0>)
 80126d0:	68db      	ldr	r3, [r3, #12]
 80126d2:	2015      	movs	r0, #21
 80126d4:	4798      	blx	r3
 80126d6:	e0a7      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if (limits_homing_required()) {
 80126d8:	f7fa fb26 	bl	800cd28 <limits_homing_required>
 80126dc:	4603      	mov	r3, r0
 80126de:	2b00      	cmp	r3, #0
 80126e0:	d007      	beq.n	80126f2 <protocol_main_loop+0xbe>
        // by setting Grbl's alarm state. Alarm locks out all g-code commands, including the
        // startup scripts, but allows access to settings and internal commands.
        // Only a successful homing cycle '$H' will disable the alarm.
        // NOTE: The startup script will run after successful completion of the homing cycle. Prevents motion startup
        // blocks from crashing into things uncontrollably. Very bad.
        system_raise_alarm(Alarm_HomingRequired);
 80126e2:	200b      	movs	r0, #11
 80126e4:	f00f fbee 	bl	8021ec4 <system_raise_alarm>
        grbl.report.feedback_message(Message_HomingCycleRequired);
 80126e8:	4b7a      	ldr	r3, [pc, #488]	; (80128d4 <protocol_main_loop+0x2a0>)
 80126ea:	68db      	ldr	r3, [r3, #12]
 80126ec:	200d      	movs	r0, #13
 80126ee:	4798      	blx	r3
 80126f0:	e09a      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if (settings.limits.flags.hard_enabled &&
 80126f2:	4b79      	ldr	r3, [pc, #484]	; (80128d8 <protocol_main_loop+0x2a4>)
 80126f4:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 80126f8:	f003 0301 	and.w	r3, r3, #1
 80126fc:	b2db      	uxtb	r3, r3
 80126fe:	2b00      	cmp	r3, #0
 8012700:	d035      	beq.n	801276e <protocol_main_loop+0x13a>
 8012702:	4b75      	ldr	r3, [pc, #468]	; (80128d8 <protocol_main_loop+0x2a4>)
 8012704:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8012708:	f003 0304 	and.w	r3, r3, #4
 801270c:	b2db      	uxtb	r3, r3
 801270e:	2b00      	cmp	r3, #0
 8012710:	d02d      	beq.n	801276e <protocol_main_loop+0x13a>
                settings.limits.flags.check_at_init &&
                 (limit_signals_merge(hal.limits.get_state()).value & sys.hard_limits.mask)) {
 8012712:	4b6f      	ldr	r3, [pc, #444]	; (80128d0 <protocol_main_loop+0x29c>)
 8012714:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012716:	4798      	blx	r3
 8012718:	4603      	mov	r3, r0
 801271a:	60bb      	str	r3, [r7, #8]
 801271c:	68b8      	ldr	r0, [r7, #8]
 801271e:	f7f9 fc17 	bl	800bf50 <limit_signals_merge>
 8012722:	4603      	mov	r3, r0
 8012724:	b2da      	uxtb	r2, r3
 8012726:	4b69      	ldr	r3, [pc, #420]	; (80128cc <protocol_main_loop+0x298>)
 8012728:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
                settings.limits.flags.check_at_init &&
 801272c:	4013      	ands	r3, r2
 801272e:	b2db      	uxtb	r3, r3
 8012730:	2b00      	cmp	r3, #0
 8012732:	d01c      	beq.n	801276e <protocol_main_loop+0x13a>
        if(sys.alarm == Alarm_LimitsEngaged && hal.control.get_state().limits_override)
 8012734:	4b65      	ldr	r3, [pc, #404]	; (80128cc <protocol_main_loop+0x298>)
 8012736:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 801273a:	2b0c      	cmp	r3, #12
 801273c:	d10f      	bne.n	801275e <protocol_main_loop+0x12a>
 801273e:	4b64      	ldr	r3, [pc, #400]	; (80128d0 <protocol_main_loop+0x29c>)
 8012740:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8012742:	4798      	blx	r3
 8012744:	4603      	mov	r3, r0
 8012746:	f3c3 2307 	ubfx	r3, r3, #8, #8
 801274a:	b2db      	uxtb	r3, r3
 801274c:	f003 0304 	and.w	r3, r3, #4
 8012750:	b2db      	uxtb	r3, r3
 8012752:	2b00      	cmp	r3, #0
 8012754:	d003      	beq.n	801275e <protocol_main_loop+0x12a>
            state_set(STATE_IDLE); // Clear alarm state to enable limit switch pulloff.
 8012756:	2000      	movs	r0, #0
 8012758:	f00b f8bc 	bl	801d8d4 <state_set>
        if(sys.alarm == Alarm_LimitsEngaged && hal.control.get_state().limits_override)
 801275c:	e064      	b.n	8012828 <protocol_main_loop+0x1f4>
        else {
            // Check that no limit switches are engaged to make sure everything is good to go.
            system_raise_alarm(Alarm_LimitsEngaged);
 801275e:	200c      	movs	r0, #12
 8012760:	f00f fbb0 	bl	8021ec4 <system_raise_alarm>
            grbl.report.feedback_message(Message_CheckLimits);
 8012764:	4b5b      	ldr	r3, [pc, #364]	; (80128d4 <protocol_main_loop+0x2a0>)
 8012766:	68db      	ldr	r3, [r3, #12]
 8012768:	2007      	movs	r0, #7
 801276a:	4798      	blx	r3
        if(sys.alarm == Alarm_LimitsEngaged && hal.control.get_state().limits_override)
 801276c:	e05c      	b.n	8012828 <protocol_main_loop+0x1f4>
        }
    } else if(sys.cold_start && (settings.flags.force_initialization_alarm || hal.control.get_state().reset)) {
 801276e:	4b57      	ldr	r3, [pc, #348]	; (80128cc <protocol_main_loop+0x298>)
 8012770:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8012774:	2b00      	cmp	r3, #0
 8012776:	d019      	beq.n	80127ac <protocol_main_loop+0x178>
 8012778:	4b57      	ldr	r3, [pc, #348]	; (80128d8 <protocol_main_loop+0x2a4>)
 801277a:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801277e:	f003 0320 	and.w	r3, r3, #32
 8012782:	b2db      	uxtb	r3, r3
 8012784:	2b00      	cmp	r3, #0
 8012786:	d109      	bne.n	801279c <protocol_main_loop+0x168>
 8012788:	4b51      	ldr	r3, [pc, #324]	; (80128d0 <protocol_main_loop+0x29c>)
 801278a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801278c:	4798      	blx	r3
 801278e:	4603      	mov	r3, r0
 8012790:	b2db      	uxtb	r3, r3
 8012792:	f003 0301 	and.w	r3, r3, #1
 8012796:	b2db      	uxtb	r3, r3
 8012798:	2b00      	cmp	r3, #0
 801279a:	d007      	beq.n	80127ac <protocol_main_loop+0x178>
        state_set(STATE_ALARM); // Ensure alarm state is set.
 801279c:	2001      	movs	r0, #1
 801279e:	f00b f899 	bl	801d8d4 <state_set>
        grbl.report.feedback_message(Message_AlarmLock);
 80127a2:	4b4c      	ldr	r3, [pc, #304]	; (80128d4 <protocol_main_loop+0x2a0>)
 80127a4:	68db      	ldr	r3, [r3, #12]
 80127a6:	2002      	movs	r0, #2
 80127a8:	4798      	blx	r3
 80127aa:	e03d      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else if (state_get() & (STATE_ALARM|STATE_SLEEP)) {
 80127ac:	f00b f888 	bl	801d8c0 <state_get>
 80127b0:	4603      	mov	r3, r0
 80127b2:	f003 0381 	and.w	r3, r3, #129	; 0x81
 80127b6:	2b00      	cmp	r3, #0
 80127b8:	d010      	beq.n	80127dc <protocol_main_loop+0x1a8>
        // Check for and report alarm state after a reset, error, or an initial power up.
        // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
        // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
        if(sys.alarm == Alarm_HomingRequired)
 80127ba:	4b44      	ldr	r3, [pc, #272]	; (80128cc <protocol_main_loop+0x298>)
 80127bc:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 80127c0:	2b0b      	cmp	r3, #11
 80127c2:	d103      	bne.n	80127cc <protocol_main_loop+0x198>
            sys.alarm = Alarm_None; // Clear Alarm_HomingRequired as the lock has been overridden by a soft reset.
 80127c4:	4b41      	ldr	r3, [pc, #260]	; (80128cc <protocol_main_loop+0x298>)
 80127c6:	2200      	movs	r2, #0
 80127c8:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
        state_set(STATE_ALARM); // Ensure alarm state is set.
 80127cc:	2001      	movs	r0, #1
 80127ce:	f00b f881 	bl	801d8d4 <state_set>
        grbl.report.feedback_message(Message_AlarmLock);
 80127d2:	4b40      	ldr	r3, [pc, #256]	; (80128d4 <protocol_main_loop+0x2a0>)
 80127d4:	68db      	ldr	r3, [r3, #12]
 80127d6:	2002      	movs	r0, #2
 80127d8:	4798      	blx	r3
 80127da:	e025      	b.n	8012828 <protocol_main_loop+0x1f4>
    } else {
        state_set(STATE_IDLE);
 80127dc:	2000      	movs	r0, #0
 80127de:	f00b f879 	bl	801d8d4 <state_set>
#ifndef NO_SAFETY_DOOR_SUPPORT
        // Check if the safety door is open.
        if (hal.signals_cap.safety_door_ajar && !settings.safety_door.flags.ignore_when_idle && hal.control.get_state().safety_door_ajar) {
 80127e2:	4b3b      	ldr	r3, [pc, #236]	; (80128d0 <protocol_main_loop+0x29c>)
 80127e4:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 80127e8:	f003 0308 	and.w	r3, r3, #8
 80127ec:	b2db      	uxtb	r3, r3
 80127ee:	2b00      	cmp	r3, #0
 80127f0:	d018      	beq.n	8012824 <protocol_main_loop+0x1f0>
 80127f2:	4b39      	ldr	r3, [pc, #228]	; (80128d8 <protocol_main_loop+0x2a4>)
 80127f4:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 80127f8:	f003 0301 	and.w	r3, r3, #1
 80127fc:	b2db      	uxtb	r3, r3
 80127fe:	2b00      	cmp	r3, #0
 8012800:	d110      	bne.n	8012824 <protocol_main_loop+0x1f0>
 8012802:	4b33      	ldr	r3, [pc, #204]	; (80128d0 <protocol_main_loop+0x29c>)
 8012804:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8012806:	4798      	blx	r3
 8012808:	4603      	mov	r3, r0
 801280a:	b2db      	uxtb	r3, r3
 801280c:	f003 0308 	and.w	r3, r3, #8
 8012810:	b2db      	uxtb	r3, r3
 8012812:	2b00      	cmp	r3, #0
 8012814:	d006      	beq.n	8012824 <protocol_main_loop+0x1f0>
            system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8012816:	4b2e      	ldr	r3, [pc, #184]	; (80128d0 <protocol_main_loop+0x29c>)
 8012818:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801281a:	2140      	movs	r1, #64	; 0x40
 801281c:	482f      	ldr	r0, [pc, #188]	; (80128dc <protocol_main_loop+0x2a8>)
 801281e:	4798      	blx	r3
            protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
 8012820:	f000 fa9e 	bl	8012d60 <protocol_execute_realtime>
        }
#endif
        // All systems go!
        system_execute_startup(); // Execute startup script.
 8012824:	f00e f9d2 	bl	8020bcc <system_execute_startup>
    }

    // Ensure spindle and coolant is switched off on a cold start
    if(sys.cold_start) {
 8012828:	4b28      	ldr	r3, [pc, #160]	; (80128cc <protocol_main_loop+0x298>)
 801282a:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 801282e:	2b00      	cmp	r3, #0
 8012830:	d017      	beq.n	8012862 <protocol_main_loop+0x22e>
        spindle_all_off();
 8012832:	f00a fc4d 	bl	801d0d0 <spindle_all_off>
        hal.coolant.set_state((coolant_state_t){0});
 8012836:	4b26      	ldr	r3, [pc, #152]	; (80128d0 <protocol_main_loop+0x29c>)
 8012838:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801283a:	2200      	movs	r2, #0
 801283c:	4610      	mov	r0, r2
 801283e:	4798      	blx	r3
        if(realtime_queue.head != realtime_queue.tail)
 8012840:	4b27      	ldr	r3, [pc, #156]	; (80128e0 <protocol_main_loop+0x2ac>)
 8012842:	681a      	ldr	r2, [r3, #0]
 8012844:	4b26      	ldr	r3, [pc, #152]	; (80128e0 <protocol_main_loop+0x2ac>)
 8012846:	685b      	ldr	r3, [r3, #4]
 8012848:	429a      	cmp	r2, r3
 801284a:	d005      	beq.n	8012858 <protocol_main_loop+0x224>
            system_set_exec_state_flag(EXEC_RT_COMMAND);  // execute any boot up commands
 801284c:	4b20      	ldr	r3, [pc, #128]	; (80128d0 <protocol_main_loop+0x29c>)
 801284e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012850:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8012854:	4821      	ldr	r0, [pc, #132]	; (80128dc <protocol_main_loop+0x2a8>)
 8012856:	4798      	blx	r3
        sys.cold_start = false;
 8012858:	4b1c      	ldr	r3, [pc, #112]	; (80128cc <protocol_main_loop+0x298>)
 801285a:	2200      	movs	r2, #0
 801285c:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
 8012860:	e004      	b.n	801286c <protocol_main_loop+0x238>
    } else
        memset(&realtime_queue, 0, sizeof(realtime_queue_t));
 8012862:	2248      	movs	r2, #72	; 0x48
 8012864:	2100      	movs	r1, #0
 8012866:	481e      	ldr	r0, [pc, #120]	; (80128e0 <protocol_main_loop+0x2ac>)
 8012868:	f011 f9d5 	bl	8023c16 <memset>
    // Primary loop! Upon a system abort, this exits back to main() to reset the system.
    // This is also where Grbl idles while waiting for something to do.
    // ---------------------------------------------------------------------------------

    int16_t c;
    char eol = '\0';
 801286c:	2300      	movs	r3, #0
 801286e:	73fb      	strb	r3, [r7, #15]
    line_flags_t line_flags = {0};
 8012870:	2300      	movs	r3, #0
 8012872:	713b      	strb	r3, [r7, #4]

    xcommand[0] = '\0';
 8012874:	4b1b      	ldr	r3, [pc, #108]	; (80128e4 <protocol_main_loop+0x2b0>)
 8012876:	2200      	movs	r2, #0
 8012878:	701a      	strb	r2, [r3, #0]
    char_counter = 0;
 801287a:	4b1b      	ldr	r3, [pc, #108]	; (80128e8 <protocol_main_loop+0x2b4>)
 801287c:	2200      	movs	r2, #0
 801287e:	601a      	str	r2, [r3, #0]
    keep_rt_commands = false;
 8012880:	4b1a      	ldr	r3, [pc, #104]	; (80128ec <protocol_main_loop+0x2b8>)
 8012882:	2200      	movs	r2, #0
 8012884:	701a      	strb	r2, [r3, #0]

    while(true) {

        // Process one line of incoming stream data, as the data becomes available. Performs an
        // initial filtering by removing leading spaces and control characters.
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8012886:	e1d4      	b.n	8012c32 <protocol_main_loop+0x5fe>

            if(c == ASCII_CAN) {
 8012888:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801288c:	2b18      	cmp	r3, #24
 801288e:	d131      	bne.n	80128f4 <protocol_main_loop+0x2c0>

                eol = xcommand[0] = '\0';
 8012890:	4b14      	ldr	r3, [pc, #80]	; (80128e4 <protocol_main_loop+0x2b0>)
 8012892:	2200      	movs	r2, #0
 8012894:	701a      	strb	r2, [r3, #0]
 8012896:	4b13      	ldr	r3, [pc, #76]	; (80128e4 <protocol_main_loop+0x2b0>)
 8012898:	781b      	ldrb	r3, [r3, #0]
 801289a:	73fb      	strb	r3, [r7, #15]
                keep_rt_commands = false;
 801289c:	4b13      	ldr	r3, [pc, #76]	; (80128ec <protocol_main_loop+0x2b8>)
 801289e:	2200      	movs	r2, #0
 80128a0:	701a      	strb	r2, [r3, #0]
                char_counter = line_flags.value = 0;
 80128a2:	2300      	movs	r3, #0
 80128a4:	713b      	strb	r3, [r7, #4]
 80128a6:	4b10      	ldr	r3, [pc, #64]	; (80128e8 <protocol_main_loop+0x2b4>)
 80128a8:	2200      	movs	r2, #0
 80128aa:	601a      	str	r2, [r3, #0]
                gc_state.last_error = Status_OK;
 80128ac:	4b10      	ldr	r3, [pc, #64]	; (80128f0 <protocol_main_loop+0x2bc>)
 80128ae:	2200      	movs	r2, #0
 80128b0:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75

                if (state_get() == STATE_JOG) // Block all other states from invoking motion cancel.
 80128b4:	f00b f804 	bl	801d8c0 <state_get>
 80128b8:	4603      	mov	r3, r0
 80128ba:	2b20      	cmp	r3, #32
 80128bc:	f040 81b9 	bne.w	8012c32 <protocol_main_loop+0x5fe>
                    system_set_exec_state_flag(EXEC_MOTION_CANCEL);
 80128c0:	4b03      	ldr	r3, [pc, #12]	; (80128d0 <protocol_main_loop+0x29c>)
 80128c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80128c4:	2180      	movs	r1, #128	; 0x80
 80128c6:	4805      	ldr	r0, [pc, #20]	; (80128dc <protocol_main_loop+0x2a8>)
 80128c8:	4798      	blx	r3
 80128ca:	e1b2      	b.n	8012c32 <protocol_main_loop+0x5fe>
 80128cc:	20000d3c 	.word	0x20000d3c
 80128d0:	20000ed0 	.word	0x20000ed0
 80128d4:	20000dd4 	.word	0x20000dd4
 80128d8:	2000147c 	.word	0x2000147c
 80128dc:	20000d84 	.word	0x20000d84
 80128e0:	200013b8 	.word	0x200013b8
 80128e4:	200012b4 	.word	0x200012b4
 80128e8:	200011ac 	.word	0x200011ac
 80128ec:	200013b5 	.word	0x200013b5
 80128f0:	20000bb0 	.word	0x20000bb0

            } else if ((c == '\n') || (c == '\r')) { // End of line reached
 80128f4:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80128f8:	2b0a      	cmp	r3, #10
 80128fa:	d004      	beq.n	8012906 <protocol_main_loop+0x2d2>
 80128fc:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012900:	2b0d      	cmp	r3, #13
 8012902:	f040 80a3 	bne.w	8012a4c <protocol_main_loop+0x418>

                // Check for possible secondary end of line character, do not process as empty line
                // if part of crlf (or lfcr pair) as this produces a possibly unwanted double response
                if(char_counter == 0 && eol && eol != c) {
 8012906:	4ba7      	ldr	r3, [pc, #668]	; (8012ba4 <protocol_main_loop+0x570>)
 8012908:	681b      	ldr	r3, [r3, #0]
 801290a:	2b00      	cmp	r3, #0
 801290c:	d10a      	bne.n	8012924 <protocol_main_loop+0x2f0>
 801290e:	7bfb      	ldrb	r3, [r7, #15]
 8012910:	2b00      	cmp	r3, #0
 8012912:	d007      	beq.n	8012924 <protocol_main_loop+0x2f0>
 8012914:	7bfa      	ldrb	r2, [r7, #15]
 8012916:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801291a:	429a      	cmp	r2, r3
 801291c:	d002      	beq.n	8012924 <protocol_main_loop+0x2f0>
                    eol = '\0';
 801291e:	2300      	movs	r3, #0
 8012920:	73fb      	strb	r3, [r7, #15]
                    continue;
 8012922:	e186      	b.n	8012c32 <protocol_main_loop+0x5fe>
                } else
                    eol = (char)c;
 8012924:	89bb      	ldrh	r3, [r7, #12]
 8012926:	73fb      	strb	r3, [r7, #15]

                if(!protocol_execute_realtime()) // Runtime command check point.
 8012928:	f000 fa1a 	bl	8012d60 <protocol_execute_realtime>
 801292c:	4603      	mov	r3, r0
 801292e:	f083 0301 	eor.w	r3, r3, #1
 8012932:	b2db      	uxtb	r3, r3
 8012934:	2b00      	cmp	r3, #0
 8012936:	d00a      	beq.n	801294e <protocol_main_loop+0x31a>
                    return !sys.flags.exit;      // Bail to calling function upon system abort
 8012938:	4b9b      	ldr	r3, [pc, #620]	; (8012ba8 <protocol_main_loop+0x574>)
 801293a:	7d9b      	ldrb	r3, [r3, #22]
 801293c:	f003 0308 	and.w	r3, r3, #8
 8012940:	b2db      	uxtb	r3, r3
 8012942:	2b00      	cmp	r3, #0
 8012944:	bf0c      	ite	eq
 8012946:	2301      	moveq	r3, #1
 8012948:	2300      	movne	r3, #0
 801294a:	b2db      	uxtb	r3, r3
 801294c:	e1c3      	b.n	8012cd6 <protocol_main_loop+0x6a2>

                line[char_counter] = '\0'; // Set string termination character.
 801294e:	4b95      	ldr	r3, [pc, #596]	; (8012ba4 <protocol_main_loop+0x570>)
 8012950:	681b      	ldr	r3, [r3, #0]
 8012952:	4a96      	ldr	r2, [pc, #600]	; (8012bac <protocol_main_loop+0x578>)
 8012954:	2100      	movs	r1, #0
 8012956:	54d1      	strb	r1, [r2, r3]
              #if REPORT_ECHO_LINE_RECEIVED
                report_echo_line_received(line);
              #endif

                // Direct and execute one line of formatted input, and report status of execution.
                if (line_flags.overflow) // Report line overflow error.
 8012958:	793b      	ldrb	r3, [r7, #4]
 801295a:	f003 0301 	and.w	r3, r3, #1
 801295e:	b2db      	uxtb	r3, r3
 8012960:	2b00      	cmp	r3, #0
 8012962:	d004      	beq.n	801296e <protocol_main_loop+0x33a>
                    gc_state.last_error = Status_Overflow;
 8012964:	4b92      	ldr	r3, [pc, #584]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012966:	220b      	movs	r2, #11
 8012968:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
 801296c:	e054      	b.n	8012a18 <protocol_main_loop+0x3e4>
                else if(*line == '\0') // Empty line. For syncing purposes.
 801296e:	4b8f      	ldr	r3, [pc, #572]	; (8012bac <protocol_main_loop+0x578>)
 8012970:	781b      	ldrb	r3, [r3, #0]
 8012972:	2b00      	cmp	r3, #0
 8012974:	d104      	bne.n	8012980 <protocol_main_loop+0x34c>
                    gc_state.last_error = Status_OK;
 8012976:	4b8e      	ldr	r3, [pc, #568]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012978:	2200      	movs	r2, #0
 801297a:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
 801297e:	e04b      	b.n	8012a18 <protocol_main_loop+0x3e4>
                else if(*line == '$') {// Grbl '$' system command
 8012980:	4b8a      	ldr	r3, [pc, #552]	; (8012bac <protocol_main_loop+0x578>)
 8012982:	781b      	ldrb	r3, [r3, #0]
 8012984:	2b24      	cmp	r3, #36	; 0x24
 8012986:	d114      	bne.n	80129b2 <protocol_main_loop+0x37e>
                    if((gc_state.last_error = system_execute_line(line)) == Status_LimitsEngaged) {
 8012988:	4888      	ldr	r0, [pc, #544]	; (8012bac <protocol_main_loop+0x578>)
 801298a:	f00f f8ad 	bl	8021ae8 <system_execute_line>
 801298e:	4603      	mov	r3, r0
 8012990:	461a      	mov	r2, r3
 8012992:	4b87      	ldr	r3, [pc, #540]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012994:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
 8012998:	4b85      	ldr	r3, [pc, #532]	; (8012bb0 <protocol_main_loop+0x57c>)
 801299a:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 801299e:	2b2d      	cmp	r3, #45	; 0x2d
 80129a0:	d13a      	bne.n	8012a18 <protocol_main_loop+0x3e4>
                        system_raise_alarm(Alarm_LimitsEngaged);
 80129a2:	200c      	movs	r0, #12
 80129a4:	f00f fa8e 	bl	8021ec4 <system_raise_alarm>
                        grbl.report.feedback_message(Message_CheckLimits);
 80129a8:	4b82      	ldr	r3, [pc, #520]	; (8012bb4 <protocol_main_loop+0x580>)
 80129aa:	68db      	ldr	r3, [r3, #12]
 80129ac:	2007      	movs	r0, #7
 80129ae:	4798      	blx	r3
 80129b0:	e032      	b.n	8012a18 <protocol_main_loop+0x3e4>
                    }
                } else if(*line == '[' && grbl.on_user_command)
 80129b2:	4b7e      	ldr	r3, [pc, #504]	; (8012bac <protocol_main_loop+0x578>)
 80129b4:	781b      	ldrb	r3, [r3, #0]
 80129b6:	2b5b      	cmp	r3, #91	; 0x5b
 80129b8:	d10f      	bne.n	80129da <protocol_main_loop+0x3a6>
 80129ba:	4b7e      	ldr	r3, [pc, #504]	; (8012bb4 <protocol_main_loop+0x580>)
 80129bc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80129c0:	2b00      	cmp	r3, #0
 80129c2:	d00a      	beq.n	80129da <protocol_main_loop+0x3a6>
                    gc_state.last_error = grbl.on_user_command(line);
 80129c4:	4b7b      	ldr	r3, [pc, #492]	; (8012bb4 <protocol_main_loop+0x580>)
 80129c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80129ca:	4878      	ldr	r0, [pc, #480]	; (8012bac <protocol_main_loop+0x578>)
 80129cc:	4798      	blx	r3
 80129ce:	4603      	mov	r3, r0
 80129d0:	461a      	mov	r2, r3
 80129d2:	4b77      	ldr	r3, [pc, #476]	; (8012bb0 <protocol_main_loop+0x57c>)
 80129d4:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
 80129d8:	e01e      	b.n	8012a18 <protocol_main_loop+0x3e4>
                else if (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog mode.
 80129da:	f00a ff71 	bl	801d8c0 <state_get>
 80129de:	4602      	mov	r2, r0
 80129e0:	f240 1321 	movw	r3, #289	; 0x121
 80129e4:	4013      	ands	r3, r2
 80129e6:	2b00      	cmp	r3, #0
 80129e8:	d004      	beq.n	80129f4 <protocol_main_loop+0x3c0>
                    gc_state.last_error = Status_SystemGClock;
 80129ea:	4b71      	ldr	r3, [pc, #452]	; (8012bb0 <protocol_main_loop+0x57c>)
 80129ec:	2209      	movs	r2, #9
 80129ee:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
 80129f2:	e011      	b.n	8012a18 <protocol_main_loop+0x3e4>
#if COMPATIBILITY_LEVEL == 0
                else if(gc_state.last_error == Status_OK || gc_state.last_error == Status_GcodeToolChangePending) { // Parse and execute g-code block.
 80129f4:	4b6e      	ldr	r3, [pc, #440]	; (8012bb0 <protocol_main_loop+0x57c>)
 80129f6:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 80129fa:	2b00      	cmp	r3, #0
 80129fc:	d004      	beq.n	8012a08 <protocol_main_loop+0x3d4>
 80129fe:	4b6c      	ldr	r3, [pc, #432]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012a00:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
 8012a04:	2b28      	cmp	r3, #40	; 0x28
 8012a06:	d107      	bne.n	8012a18 <protocol_main_loop+0x3e4>
#else
                else { // Parse and execute g-code block.

#endif
                    gc_state.last_error = gc_execute_block(line);
 8012a08:	4868      	ldr	r0, [pc, #416]	; (8012bac <protocol_main_loop+0x578>)
 8012a0a:	f7f3 fc07 	bl	800621c <gc_execute_block>
 8012a0e:	4603      	mov	r3, r0
 8012a10:	461a      	mov	r2, r3
 8012a12:	4b67      	ldr	r3, [pc, #412]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012a14:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
                // the speed is not limited to 115200 baud. An example is native USB streaming.
#if CHECK_MODE_DELAY
                if(state_get() == STATE_CHECK_MODE)
                    hal.delay_ms(CHECK_MODE_DELAY, NULL);
#endif
                if(ABORTED)
 8012a18:	4b63      	ldr	r3, [pc, #396]	; (8012ba8 <protocol_main_loop+0x574>)
 8012a1a:	781b      	ldrb	r3, [r3, #0]
 8012a1c:	2b00      	cmp	r3, #0
 8012a1e:	f040 8114 	bne.w	8012c4a <protocol_main_loop+0x616>
 8012a22:	4b61      	ldr	r3, [pc, #388]	; (8012ba8 <protocol_main_loop+0x574>)
 8012a24:	785b      	ldrb	r3, [r3, #1]
 8012a26:	2b00      	cmp	r3, #0
 8012a28:	f040 810f 	bne.w	8012c4a <protocol_main_loop+0x616>
                    break;
                else
                    grbl.report.status_message(gc_state.last_error);
 8012a2c:	4b61      	ldr	r3, [pc, #388]	; (8012bb4 <protocol_main_loop+0x580>)
 8012a2e:	689b      	ldr	r3, [r3, #8]
 8012a30:	4a5f      	ldr	r2, [pc, #380]	; (8012bb0 <protocol_main_loop+0x57c>)
 8012a32:	f892 2075 	ldrb.w	r2, [r2, #117]	; 0x75
 8012a36:	4610      	mov	r0, r2
 8012a38:	4798      	blx	r3

                // Reset tracking data for next line.
                keep_rt_commands = false;
 8012a3a:	4b5f      	ldr	r3, [pc, #380]	; (8012bb8 <protocol_main_loop+0x584>)
 8012a3c:	2200      	movs	r2, #0
 8012a3e:	701a      	strb	r2, [r3, #0]
                char_counter = line_flags.value = 0;
 8012a40:	2300      	movs	r3, #0
 8012a42:	713b      	strb	r3, [r7, #4]
 8012a44:	4b57      	ldr	r3, [pc, #348]	; (8012ba4 <protocol_main_loop+0x570>)
 8012a46:	2200      	movs	r2, #0
 8012a48:	601a      	str	r2, [r3, #0]
 8012a4a:	e0f2      	b.n	8012c32 <protocol_main_loop+0x5fe>

            } else if (c != ASCII_BS && c <= (char_counter > 0 ? ' ' - 1 : ' '))
 8012a4c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012a50:	2b08      	cmp	r3, #8
 8012a52:	d00b      	beq.n	8012a6c <protocol_main_loop+0x438>
 8012a54:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012a58:	4a52      	ldr	r2, [pc, #328]	; (8012ba4 <protocol_main_loop+0x570>)
 8012a5a:	6812      	ldr	r2, [r2, #0]
 8012a5c:	2a00      	cmp	r2, #0
 8012a5e:	d001      	beq.n	8012a64 <protocol_main_loop+0x430>
 8012a60:	221f      	movs	r2, #31
 8012a62:	e000      	b.n	8012a66 <protocol_main_loop+0x432>
 8012a64:	2220      	movs	r2, #32
 8012a66:	429a      	cmp	r2, r3
 8012a68:	db00      	blt.n	8012a6c <protocol_main_loop+0x438>
                continue; // Strip control characters and leading whitespace.
 8012a6a:	e0e2      	b.n	8012c32 <protocol_main_loop+0x5fe>
            else {
                switch(c) {
 8012a6c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012a70:	2b7f      	cmp	r3, #127	; 0x7f
 8012a72:	f000 80a5 	beq.w	8012bc0 <protocol_main_loop+0x58c>
 8012a76:	2b7f      	cmp	r3, #127	; 0x7f
 8012a78:	f300 80c1 	bgt.w	8012bfe <protocol_main_loop+0x5ca>
 8012a7c:	2b5b      	cmp	r3, #91	; 0x5b
 8012a7e:	d045      	beq.n	8012b0c <protocol_main_loop+0x4d8>
 8012a80:	2b5b      	cmp	r3, #91	; 0x5b
 8012a82:	f300 80bc 	bgt.w	8012bfe <protocol_main_loop+0x5ca>
 8012a86:	2b08      	cmp	r3, #8
 8012a88:	f000 809a 	beq.w	8012bc0 <protocol_main_loop+0x58c>
 8012a8c:	2b08      	cmp	r3, #8
 8012a8e:	f2c0 80b6 	blt.w	8012bfe <protocol_main_loop+0x5ca>
 8012a92:	2b3b      	cmp	r3, #59	; 0x3b
 8012a94:	f300 80b3 	bgt.w	8012bfe <protocol_main_loop+0x5ca>
 8012a98:	2b24      	cmp	r3, #36	; 0x24
 8012a9a:	f2c0 80b0 	blt.w	8012bfe <protocol_main_loop+0x5ca>
 8012a9e:	3b24      	subs	r3, #36	; 0x24
 8012aa0:	2b17      	cmp	r3, #23
 8012aa2:	f200 80ac 	bhi.w	8012bfe <protocol_main_loop+0x5ca>
 8012aa6:	a201      	add	r2, pc, #4	; (adr r2, 8012aac <protocol_main_loop+0x478>)
 8012aa8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012aac:	08012b0d 	.word	0x08012b0d
 8012ab0:	08012bff 	.word	0x08012bff
 8012ab4:	08012bff 	.word	0x08012bff
 8012ab8:	08012bff 	.word	0x08012bff
 8012abc:	08012b1d 	.word	0x08012b1d
 8012ac0:	08012b6d 	.word	0x08012b6d
 8012ac4:	08012bff 	.word	0x08012bff
 8012ac8:	08012bff 	.word	0x08012bff
 8012acc:	08012bff 	.word	0x08012bff
 8012ad0:	08012bff 	.word	0x08012bff
 8012ad4:	08012bff 	.word	0x08012bff
 8012ad8:	08012bff 	.word	0x08012bff
 8012adc:	08012bff 	.word	0x08012bff
 8012ae0:	08012bff 	.word	0x08012bff
 8012ae4:	08012bff 	.word	0x08012bff
 8012ae8:	08012bff 	.word	0x08012bff
 8012aec:	08012bff 	.word	0x08012bff
 8012af0:	08012bff 	.word	0x08012bff
 8012af4:	08012bff 	.word	0x08012bff
 8012af8:	08012bff 	.word	0x08012bff
 8012afc:	08012bff 	.word	0x08012bff
 8012b00:	08012bff 	.word	0x08012bff
 8012b04:	08012bff 	.word	0x08012bff
 8012b08:	08012b89 	.word	0x08012b89

                    case '$':
                    case '[':
                        if(char_counter == 0)
 8012b0c:	4b25      	ldr	r3, [pc, #148]	; (8012ba4 <protocol_main_loop+0x570>)
 8012b0e:	681b      	ldr	r3, [r3, #0]
 8012b10:	2b00      	cmp	r3, #0
 8012b12:	d16d      	bne.n	8012bf0 <protocol_main_loop+0x5bc>
                            keep_rt_commands = true;
 8012b14:	4b28      	ldr	r3, [pc, #160]	; (8012bb8 <protocol_main_loop+0x584>)
 8012b16:	2201      	movs	r2, #1
 8012b18:	701a      	strb	r2, [r3, #0]
                        break;
 8012b1a:	e069      	b.n	8012bf0 <protocol_main_loop+0x5bc>

                    case '(':
                        if(!keep_rt_commands && (line_flags.comment_parentheses = !line_flags.comment_semicolon))
 8012b1c:	4b26      	ldr	r3, [pc, #152]	; (8012bb8 <protocol_main_loop+0x584>)
 8012b1e:	781b      	ldrb	r3, [r3, #0]
 8012b20:	f083 0301 	eor.w	r3, r3, #1
 8012b24:	b2db      	uxtb	r3, r3
 8012b26:	2b00      	cmp	r3, #0
 8012b28:	d064      	beq.n	8012bf4 <protocol_main_loop+0x5c0>
 8012b2a:	793b      	ldrb	r3, [r7, #4]
 8012b2c:	f003 0304 	and.w	r3, r3, #4
 8012b30:	b2db      	uxtb	r3, r3
 8012b32:	2b00      	cmp	r3, #0
 8012b34:	bf0c      	ite	eq
 8012b36:	2301      	moveq	r3, #1
 8012b38:	2300      	movne	r3, #0
 8012b3a:	b2da      	uxtb	r2, r3
 8012b3c:	793b      	ldrb	r3, [r7, #4]
 8012b3e:	f362 0341 	bfi	r3, r2, #1, #1
 8012b42:	713b      	strb	r3, [r7, #4]
 8012b44:	793b      	ldrb	r3, [r7, #4]
 8012b46:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8012b4a:	b2db      	uxtb	r3, r3
 8012b4c:	2b00      	cmp	r3, #0
 8012b4e:	d051      	beq.n	8012bf4 <protocol_main_loop+0x5c0>
                            keep_rt_commands = !hal.driver_cap.no_gcode_message_handling; // Suspend real-time processing of printable command characters.
 8012b50:	4b1a      	ldr	r3, [pc, #104]	; (8012bbc <protocol_main_loop+0x588>)
 8012b52:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8012b56:	f003 0308 	and.w	r3, r3, #8
 8012b5a:	b2db      	uxtb	r3, r3
 8012b5c:	2b00      	cmp	r3, #0
 8012b5e:	bf0c      	ite	eq
 8012b60:	2301      	moveq	r3, #1
 8012b62:	2300      	movne	r3, #0
 8012b64:	b2da      	uxtb	r2, r3
 8012b66:	4b14      	ldr	r3, [pc, #80]	; (8012bb8 <protocol_main_loop+0x584>)
 8012b68:	701a      	strb	r2, [r3, #0]
                        break;
 8012b6a:	e043      	b.n	8012bf4 <protocol_main_loop+0x5c0>

                    case ')':
                        if(!line_flags.comment_semicolon)
 8012b6c:	793b      	ldrb	r3, [r7, #4]
 8012b6e:	f003 0304 	and.w	r3, r3, #4
 8012b72:	b2db      	uxtb	r3, r3
 8012b74:	2b00      	cmp	r3, #0
 8012b76:	d13f      	bne.n	8012bf8 <protocol_main_loop+0x5c4>
                            line_flags.comment_parentheses = keep_rt_commands = false;
 8012b78:	4b0f      	ldr	r3, [pc, #60]	; (8012bb8 <protocol_main_loop+0x584>)
 8012b7a:	2200      	movs	r2, #0
 8012b7c:	701a      	strb	r2, [r3, #0]
 8012b7e:	793b      	ldrb	r3, [r7, #4]
 8012b80:	f36f 0341 	bfc	r3, #1, #1
 8012b84:	713b      	strb	r3, [r7, #4]
                        break;
 8012b86:	e037      	b.n	8012bf8 <protocol_main_loop+0x5c4>

                    case ';':
                        if(!line_flags.comment_parentheses) {
 8012b88:	793b      	ldrb	r3, [r7, #4]
 8012b8a:	f003 0302 	and.w	r3, r3, #2
 8012b8e:	b2db      	uxtb	r3, r3
 8012b90:	2b00      	cmp	r3, #0
 8012b92:	d133      	bne.n	8012bfc <protocol_main_loop+0x5c8>
                            keep_rt_commands = false;
 8012b94:	4b08      	ldr	r3, [pc, #32]	; (8012bb8 <protocol_main_loop+0x584>)
 8012b96:	2200      	movs	r2, #0
 8012b98:	701a      	strb	r2, [r3, #0]
                            line_flags.comment_semicolon = On;
 8012b9a:	793b      	ldrb	r3, [r7, #4]
 8012b9c:	f043 0304 	orr.w	r3, r3, #4
 8012ba0:	713b      	strb	r3, [r7, #4]
                        }
                        break;
 8012ba2:	e02b      	b.n	8012bfc <protocol_main_loop+0x5c8>
 8012ba4:	200011ac 	.word	0x200011ac
 8012ba8:	20000d3c 	.word	0x20000d3c
 8012bac:	200011b0 	.word	0x200011b0
 8012bb0:	20000bb0 	.word	0x20000bb0
 8012bb4:	20000dd4 	.word	0x20000dd4
 8012bb8:	200013b5 	.word	0x200013b5
 8012bbc:	20000ed0 	.word	0x20000ed0

                    case ASCII_BS:
                    case ASCII_DEL:
                        if(char_counter) {
 8012bc0:	4b47      	ldr	r3, [pc, #284]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012bc2:	681b      	ldr	r3, [r3, #0]
 8012bc4:	2b00      	cmp	r3, #0
 8012bc6:	d034      	beq.n	8012c32 <protocol_main_loop+0x5fe>
                            line[--char_counter] = '\0';
 8012bc8:	4b45      	ldr	r3, [pc, #276]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012bca:	681b      	ldr	r3, [r3, #0]
 8012bcc:	3b01      	subs	r3, #1
 8012bce:	4a44      	ldr	r2, [pc, #272]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012bd0:	6013      	str	r3, [r2, #0]
 8012bd2:	4b43      	ldr	r3, [pc, #268]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012bd4:	681b      	ldr	r3, [r3, #0]
 8012bd6:	4a43      	ldr	r2, [pc, #268]	; (8012ce4 <protocol_main_loop+0x6b0>)
 8012bd8:	2100      	movs	r1, #0
 8012bda:	54d1      	strb	r1, [r2, r3]
                            keep_rt_commands = recheck_line(line, &line_flags);
 8012bdc:	1d3b      	adds	r3, r7, #4
 8012bde:	4619      	mov	r1, r3
 8012be0:	4840      	ldr	r0, [pc, #256]	; (8012ce4 <protocol_main_loop+0x6b0>)
 8012be2:	f7ff fc6f 	bl	80124c4 <recheck_line>
 8012be6:	4603      	mov	r3, r0
 8012be8:	461a      	mov	r2, r3
 8012bea:	4b3f      	ldr	r3, [pc, #252]	; (8012ce8 <protocol_main_loop+0x6b4>)
 8012bec:	701a      	strb	r2, [r3, #0]
                        }
                        continue;
 8012bee:	e020      	b.n	8012c32 <protocol_main_loop+0x5fe>
                        break;
 8012bf0:	bf00      	nop
 8012bf2:	e004      	b.n	8012bfe <protocol_main_loop+0x5ca>
                        break;
 8012bf4:	bf00      	nop
 8012bf6:	e002      	b.n	8012bfe <protocol_main_loop+0x5ca>
                        break;
 8012bf8:	bf00      	nop
 8012bfa:	e000      	b.n	8012bfe <protocol_main_loop+0x5ca>
                        break;
 8012bfc:	bf00      	nop
                }
                if(!(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 8012bfe:	4b38      	ldr	r3, [pc, #224]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012c00:	681b      	ldr	r3, [r3, #0]
 8012c02:	2bff      	cmp	r3, #255	; 0xff
 8012c04:	bf8c      	ite	hi
 8012c06:	2301      	movhi	r3, #1
 8012c08:	2300      	movls	r3, #0
 8012c0a:	b2da      	uxtb	r2, r3
 8012c0c:	793b      	ldrb	r3, [r7, #4]
 8012c0e:	f362 0300 	bfi	r3, r2, #0, #1
 8012c12:	713b      	strb	r3, [r7, #4]
 8012c14:	793b      	ldrb	r3, [r7, #4]
 8012c16:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8012c1a:	b2db      	uxtb	r3, r3
 8012c1c:	2b00      	cmp	r3, #0
 8012c1e:	d108      	bne.n	8012c32 <protocol_main_loop+0x5fe>
                    line[char_counter++] = c;
 8012c20:	4b2f      	ldr	r3, [pc, #188]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012c22:	681b      	ldr	r3, [r3, #0]
 8012c24:	1c5a      	adds	r2, r3, #1
 8012c26:	492e      	ldr	r1, [pc, #184]	; (8012ce0 <protocol_main_loop+0x6ac>)
 8012c28:	600a      	str	r2, [r1, #0]
 8012c2a:	89ba      	ldrh	r2, [r7, #12]
 8012c2c:	b2d1      	uxtb	r1, r2
 8012c2e:	4a2d      	ldr	r2, [pc, #180]	; (8012ce4 <protocol_main_loop+0x6b0>)
 8012c30:	54d1      	strb	r1, [r2, r3]
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8012c32:	4b2e      	ldr	r3, [pc, #184]	; (8012cec <protocol_main_loop+0x6b8>)
 8012c34:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8012c38:	4798      	blx	r3
 8012c3a:	4603      	mov	r3, r0
 8012c3c:	81bb      	strh	r3, [r7, #12]
 8012c3e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012c42:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012c46:	f47f ae1f 	bne.w	8012888 <protocol_main_loop+0x254>
            }
        }

        // Handle extra command (internal stream)
        if(xcommand[0] != '\0') {
 8012c4a:	4b29      	ldr	r3, [pc, #164]	; (8012cf0 <protocol_main_loop+0x6bc>)
 8012c4c:	781b      	ldrb	r3, [r3, #0]
 8012c4e:	2b00      	cmp	r3, #0
 8012c50:	d01a      	beq.n	8012c88 <protocol_main_loop+0x654>

            if (xcommand[0] == '$') // Grbl '$' system command
 8012c52:	4b27      	ldr	r3, [pc, #156]	; (8012cf0 <protocol_main_loop+0x6bc>)
 8012c54:	781b      	ldrb	r3, [r3, #0]
 8012c56:	2b24      	cmp	r3, #36	; 0x24
 8012c58:	d103      	bne.n	8012c62 <protocol_main_loop+0x62e>
                system_execute_line(xcommand);
 8012c5a:	4825      	ldr	r0, [pc, #148]	; (8012cf0 <protocol_main_loop+0x6bc>)
 8012c5c:	f00e ff44 	bl	8021ae8 <system_execute_line>
 8012c60:	e00f      	b.n	8012c82 <protocol_main_loop+0x64e>
            else if (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog state.
 8012c62:	f00a fe2d 	bl	801d8c0 <state_get>
 8012c66:	4602      	mov	r2, r0
 8012c68:	f240 1321 	movw	r3, #289	; 0x121
 8012c6c:	4013      	ands	r3, r2
 8012c6e:	2b00      	cmp	r3, #0
 8012c70:	d004      	beq.n	8012c7c <protocol_main_loop+0x648>
                grbl.report.status_message(Status_SystemGClock);
 8012c72:	4b20      	ldr	r3, [pc, #128]	; (8012cf4 <protocol_main_loop+0x6c0>)
 8012c74:	689b      	ldr	r3, [r3, #8]
 8012c76:	2009      	movs	r0, #9
 8012c78:	4798      	blx	r3
 8012c7a:	e002      	b.n	8012c82 <protocol_main_loop+0x64e>
            else // Parse and execute g-code block.
                gc_execute_block(xcommand);
 8012c7c:	481c      	ldr	r0, [pc, #112]	; (8012cf0 <protocol_main_loop+0x6bc>)
 8012c7e:	f7f3 facd 	bl	800621c <gc_execute_block>

            xcommand[0] = '\0';
 8012c82:	4b1b      	ldr	r3, [pc, #108]	; (8012cf0 <protocol_main_loop+0x6bc>)
 8012c84:	2200      	movs	r2, #0
 8012c86:	701a      	strb	r2, [r3, #0]
        }

        // If there are no more characters in the input stream buffer to be processed and executed,
        // this indicates that g-code streaming has either filled the planner buffer or has
        // completed. In either case, auto-cycle start, if enabled, any queued moves.
        protocol_auto_cycle_start();
 8012c88:	f000 f858 	bl	8012d3c <protocol_auto_cycle_start>

        if(!protocol_execute_realtime() && sys.abort) // Runtime command check point.
 8012c8c:	f000 f868 	bl	8012d60 <protocol_execute_realtime>
 8012c90:	4603      	mov	r3, r0
 8012c92:	f083 0301 	eor.w	r3, r3, #1
 8012c96:	b2db      	uxtb	r3, r3
 8012c98:	2b00      	cmp	r3, #0
 8012c9a:	d00e      	beq.n	8012cba <protocol_main_loop+0x686>
 8012c9c:	4b16      	ldr	r3, [pc, #88]	; (8012cf8 <protocol_main_loop+0x6c4>)
 8012c9e:	781b      	ldrb	r3, [r3, #0]
 8012ca0:	2b00      	cmp	r3, #0
 8012ca2:	d00a      	beq.n	8012cba <protocol_main_loop+0x686>
            return !sys.flags.exit;                   // Bail to main() program loop to reset system.
 8012ca4:	4b14      	ldr	r3, [pc, #80]	; (8012cf8 <protocol_main_loop+0x6c4>)
 8012ca6:	7d9b      	ldrb	r3, [r3, #22]
 8012ca8:	f003 0308 	and.w	r3, r3, #8
 8012cac:	b2db      	uxtb	r3, r3
 8012cae:	2b00      	cmp	r3, #0
 8012cb0:	bf0c      	ite	eq
 8012cb2:	2301      	moveq	r3, #1
 8012cb4:	2300      	movne	r3, #0
 8012cb6:	b2db      	uxtb	r3, r3
 8012cb8:	e00d      	b.n	8012cd6 <protocol_main_loop+0x6a2>

        sys.cancel = false;
 8012cba:	4b0f      	ldr	r3, [pc, #60]	; (8012cf8 <protocol_main_loop+0x6c4>)
 8012cbc:	2200      	movs	r2, #0
 8012cbe:	705a      	strb	r2, [r3, #1]

        // Check for sleep conditions and execute auto-park, if timeout duration elapses.
        if(settings.flags.sleep_enable)
 8012cc0:	4b0e      	ldr	r3, [pc, #56]	; (8012cfc <protocol_main_loop+0x6c8>)
 8012cc2:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8012cc6:	f003 0308 	and.w	r3, r3, #8
 8012cca:	b2db      	uxtb	r3, r3
 8012ccc:	2b00      	cmp	r3, #0
 8012cce:	d0b0      	beq.n	8012c32 <protocol_main_loop+0x5fe>
            sleep_check();
 8012cd0:	f009 fa16 	bl	801c100 <sleep_check>
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8012cd4:	e7ad      	b.n	8012c32 <protocol_main_loop+0x5fe>
    }
}
 8012cd6:	4618      	mov	r0, r3
 8012cd8:	3710      	adds	r7, #16
 8012cda:	46bd      	mov	sp, r7
 8012cdc:	bd80      	pop	{r7, pc}
 8012cde:	bf00      	nop
 8012ce0:	200011ac 	.word	0x200011ac
 8012ce4:	200011b0 	.word	0x200011b0
 8012ce8:	200013b5 	.word	0x200013b5
 8012cec:	20000ed0 	.word	0x20000ed0
 8012cf0:	200012b4 	.word	0x200012b4
 8012cf4:	20000dd4 	.word	0x20000dd4
 8012cf8:	20000d3c 	.word	0x20000d3c
 8012cfc:	2000147c 	.word	0x2000147c

08012d00 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
bool protocol_buffer_synchronize (void)
{
 8012d00:	b580      	push	{r7, lr}
 8012d02:	b082      	sub	sp, #8
 8012d04:	af00      	add	r7, sp, #0
    bool ok = true;
 8012d06:	2301      	movs	r3, #1
 8012d08:	71fb      	strb	r3, [r7, #7]
    // If system is queued, ensure cycle resumes if the auto start flag is present.
    protocol_auto_cycle_start();
 8012d0a:	f000 f817 	bl	8012d3c <protocol_auto_cycle_start>
    while ((ok = protocol_execute_realtime()) && (plan_get_current_block() || state_get() == STATE_CYCLE));
 8012d0e:	bf00      	nop
 8012d10:	f000 f826 	bl	8012d60 <protocol_execute_realtime>
 8012d14:	4603      	mov	r3, r0
 8012d16:	71fb      	strb	r3, [r7, #7]
 8012d18:	79fb      	ldrb	r3, [r7, #7]
 8012d1a:	2b00      	cmp	r3, #0
 8012d1c:	d009      	beq.n	8012d32 <protocol_buffer_synchronize+0x32>
 8012d1e:	f7fe fddd 	bl	80118dc <plan_get_current_block>
 8012d22:	4603      	mov	r3, r0
 8012d24:	2b00      	cmp	r3, #0
 8012d26:	d1f3      	bne.n	8012d10 <protocol_buffer_synchronize+0x10>
 8012d28:	f00a fdca 	bl	801d8c0 <state_get>
 8012d2c:	4603      	mov	r3, r0
 8012d2e:	2b08      	cmp	r3, #8
 8012d30:	d0ee      	beq.n	8012d10 <protocol_buffer_synchronize+0x10>

    return ok;
 8012d32:	79fb      	ldrb	r3, [r7, #7]
}
 8012d34:	4618      	mov	r0, r3
 8012d36:	3708      	adds	r7, #8
 8012d38:	46bd      	mov	sp, r7
 8012d3a:	bd80      	pop	{r7, pc}

08012d3c <protocol_auto_cycle_start>:
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start (void)
{
 8012d3c:	b580      	push	{r7, lr}
 8012d3e:	af00      	add	r7, sp, #0
    if (plan_get_current_block() != NULL) // Check if there are any blocks in the buffer.
 8012d40:	f7fe fdcc 	bl	80118dc <plan_get_current_block>
 8012d44:	4603      	mov	r3, r0
 8012d46:	2b00      	cmp	r3, #0
 8012d48:	d004      	beq.n	8012d54 <protocol_auto_cycle_start+0x18>
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 8012d4a:	4b03      	ldr	r3, [pc, #12]	; (8012d58 <protocol_auto_cycle_start+0x1c>)
 8012d4c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012d4e:	2102      	movs	r1, #2
 8012d50:	4802      	ldr	r0, [pc, #8]	; (8012d5c <protocol_auto_cycle_start+0x20>)
 8012d52:	4798      	blx	r3
}
 8012d54:	bf00      	nop
 8012d56:	bd80      	pop	{r7, pc}
 8012d58:	20000ed0 	.word	0x20000ed0
 8012d5c:	20000d84 	.word	0x20000d84

08012d60 <protocol_execute_realtime>:
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or input stream events, pinouts,
// limit switches, or the main program.
// Returns false if aborted
bool protocol_execute_realtime (void)
{
 8012d60:	b580      	push	{r7, lr}
 8012d62:	b082      	sub	sp, #8
 8012d64:	af00      	add	r7, sp, #0
    if(protocol_exec_rt_system()) {
 8012d66:	f000 f8d5 	bl	8012f14 <protocol_exec_rt_system>
 8012d6a:	4603      	mov	r3, r0
 8012d6c:	2b00      	cmp	r3, #0
 8012d6e:	d020      	beq.n	8012db2 <protocol_execute_realtime+0x52>

        sys_state_t state = state_get();
 8012d70:	f00a fda6 	bl	801d8c0 <state_get>
 8012d74:	6078      	str	r0, [r7, #4]

        if(sys.suspend)
 8012d76:	4b1b      	ldr	r3, [pc, #108]	; (8012de4 <protocol_execute_realtime+0x84>)
 8012d78:	789b      	ldrb	r3, [r3, #2]
 8012d7a:	2b00      	cmp	r3, #0
 8012d7c:	d002      	beq.n	8012d84 <protocol_execute_realtime+0x24>
            protocol_exec_rt_suspend(state);
 8012d7e:	6878      	ldr	r0, [r7, #4]
 8012d80:	f000 fc6c 	bl	801365c <protocol_exec_rt_suspend>

#if NVSDATA_BUFFER_ENABLE
        if((state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP))) && settings_dirty.is_dirty && !gc_state.file_run)
 8012d84:	687b      	ldr	r3, [r7, #4]
 8012d86:	2b00      	cmp	r3, #0
 8012d88:	d005      	beq.n	8012d96 <protocol_execute_realtime+0x36>
 8012d8a:	687a      	ldr	r2, [r7, #4]
 8012d8c:	f240 1301 	movw	r3, #257	; 0x101
 8012d90:	4013      	ands	r3, r2
 8012d92:	2b00      	cmp	r3, #0
 8012d94:	d00d      	beq.n	8012db2 <protocol_execute_realtime+0x52>
 8012d96:	4b14      	ldr	r3, [pc, #80]	; (8012de8 <protocol_execute_realtime+0x88>)
 8012d98:	781b      	ldrb	r3, [r3, #0]
 8012d9a:	2b00      	cmp	r3, #0
 8012d9c:	d009      	beq.n	8012db2 <protocol_execute_realtime+0x52>
 8012d9e:	4b13      	ldr	r3, [pc, #76]	; (8012dec <protocol_execute_realtime+0x8c>)
 8012da0:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8012da4:	f083 0301 	eor.w	r3, r3, #1
 8012da8:	b2db      	uxtb	r3, r3
 8012daa:	2b00      	cmp	r3, #0
 8012dac:	d001      	beq.n	8012db2 <protocol_execute_realtime+0x52>
            nvs_buffer_sync_physical();
 8012dae:	f7fe f91d 	bl	8010fec <nvs_buffer_sync_physical>
#endif
    }

    return !ABORTED;
 8012db2:	4b0c      	ldr	r3, [pc, #48]	; (8012de4 <protocol_execute_realtime+0x84>)
 8012db4:	781b      	ldrb	r3, [r3, #0]
 8012db6:	f083 0301 	eor.w	r3, r3, #1
 8012dba:	b2db      	uxtb	r3, r3
 8012dbc:	2b00      	cmp	r3, #0
 8012dbe:	d008      	beq.n	8012dd2 <protocol_execute_realtime+0x72>
 8012dc0:	4b08      	ldr	r3, [pc, #32]	; (8012de4 <protocol_execute_realtime+0x84>)
 8012dc2:	785b      	ldrb	r3, [r3, #1]
 8012dc4:	f083 0301 	eor.w	r3, r3, #1
 8012dc8:	b2db      	uxtb	r3, r3
 8012dca:	2b00      	cmp	r3, #0
 8012dcc:	d001      	beq.n	8012dd2 <protocol_execute_realtime+0x72>
 8012dce:	2301      	movs	r3, #1
 8012dd0:	e000      	b.n	8012dd4 <protocol_execute_realtime+0x74>
 8012dd2:	2300      	movs	r3, #0
 8012dd4:	f003 0301 	and.w	r3, r3, #1
 8012dd8:	b2db      	uxtb	r3, r3
}
 8012dda:	4618      	mov	r0, r3
 8012ddc:	3708      	adds	r7, #8
 8012dde:	46bd      	mov	sp, r7
 8012de0:	bd80      	pop	{r7, pc}
 8012de2:	bf00      	nop
 8012de4:	20000d3c 	.word	0x20000d3c
 8012de8:	2000111c 	.word	0x2000111c
 8012dec:	20000bb0 	.word	0x20000bb0

08012df0 <protocol_poll_cmd>:

static void protocol_poll_cmd (void)
{
 8012df0:	b580      	push	{r7, lr}
 8012df2:	b082      	sub	sp, #8
 8012df4:	af00      	add	r7, sp, #0
    int16_t c;

    if((c = hal.stream.read()) != SERIAL_NO_DATA) {
 8012df6:	4b41      	ldr	r3, [pc, #260]	; (8012efc <protocol_poll_cmd+0x10c>)
 8012df8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8012dfc:	4798      	blx	r3
 8012dfe:	4603      	mov	r3, r0
 8012e00:	80fb      	strh	r3, [r7, #6]
 8012e02:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012e06:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012e0a:	d072      	beq.n	8012ef2 <protocol_poll_cmd+0x102>

        if ((c == '\n') || (c == '\r')) { // End of line reached
 8012e0c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012e10:	2b0a      	cmp	r3, #10
 8012e12:	d003      	beq.n	8012e1c <protocol_poll_cmd+0x2c>
 8012e14:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012e18:	2b0d      	cmp	r3, #13
 8012e1a:	d125      	bne.n	8012e68 <protocol_poll_cmd+0x78>
            line[char_counter] = '\0';
 8012e1c:	4b38      	ldr	r3, [pc, #224]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e1e:	681b      	ldr	r3, [r3, #0]
 8012e20:	4a38      	ldr	r2, [pc, #224]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e22:	2100      	movs	r1, #0
 8012e24:	54d1      	strb	r1, [r2, r3]
            gc_state.last_error = *line == '\0' ? Status_OK : (*line == '$' ? system_execute_line(line) : Status_SystemGClock);
 8012e26:	4b37      	ldr	r3, [pc, #220]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e28:	781b      	ldrb	r3, [r3, #0]
 8012e2a:	2b00      	cmp	r3, #0
 8012e2c:	d00a      	beq.n	8012e44 <protocol_poll_cmd+0x54>
 8012e2e:	4b35      	ldr	r3, [pc, #212]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e30:	781b      	ldrb	r3, [r3, #0]
 8012e32:	2b24      	cmp	r3, #36	; 0x24
 8012e34:	d104      	bne.n	8012e40 <protocol_poll_cmd+0x50>
 8012e36:	4833      	ldr	r0, [pc, #204]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e38:	f00e fe56 	bl	8021ae8 <system_execute_line>
 8012e3c:	4603      	mov	r3, r0
 8012e3e:	e002      	b.n	8012e46 <protocol_poll_cmd+0x56>
 8012e40:	2309      	movs	r3, #9
 8012e42:	e000      	b.n	8012e46 <protocol_poll_cmd+0x56>
 8012e44:	2300      	movs	r3, #0
 8012e46:	4a30      	ldr	r2, [pc, #192]	; (8012f08 <protocol_poll_cmd+0x118>)
 8012e48:	f882 3075 	strb.w	r3, [r2, #117]	; 0x75
            char_counter = 0;
 8012e4c:	4b2c      	ldr	r3, [pc, #176]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e4e:	2200      	movs	r2, #0
 8012e50:	601a      	str	r2, [r3, #0]
            *line = '\0';
 8012e52:	4b2c      	ldr	r3, [pc, #176]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e54:	2200      	movs	r2, #0
 8012e56:	701a      	strb	r2, [r3, #0]
            grbl.report.status_message(gc_state.last_error);
 8012e58:	4b2c      	ldr	r3, [pc, #176]	; (8012f0c <protocol_poll_cmd+0x11c>)
 8012e5a:	689b      	ldr	r3, [r3, #8]
 8012e5c:	4a2a      	ldr	r2, [pc, #168]	; (8012f08 <protocol_poll_cmd+0x118>)
 8012e5e:	f892 2075 	ldrb.w	r2, [r2, #117]	; 0x75
 8012e62:	4610      	mov	r0, r2
 8012e64:	4798      	blx	r3
 8012e66:	e034      	b.n	8012ed2 <protocol_poll_cmd+0xe2>
        } else if(c == ASCII_DEL || c == ASCII_BS) {
 8012e68:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012e6c:	2b7f      	cmp	r3, #127	; 0x7f
 8012e6e:	d003      	beq.n	8012e78 <protocol_poll_cmd+0x88>
 8012e70:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012e74:	2b08      	cmp	r3, #8
 8012e76:	d10e      	bne.n	8012e96 <protocol_poll_cmd+0xa6>
            if(char_counter)
 8012e78:	4b21      	ldr	r3, [pc, #132]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e7a:	681b      	ldr	r3, [r3, #0]
 8012e7c:	2b00      	cmp	r3, #0
 8012e7e:	d028      	beq.n	8012ed2 <protocol_poll_cmd+0xe2>
                line[--char_counter] = '\0';
 8012e80:	4b1f      	ldr	r3, [pc, #124]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e82:	681b      	ldr	r3, [r3, #0]
 8012e84:	3b01      	subs	r3, #1
 8012e86:	4a1e      	ldr	r2, [pc, #120]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e88:	6013      	str	r3, [r2, #0]
 8012e8a:	4b1d      	ldr	r3, [pc, #116]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e8c:	681b      	ldr	r3, [r3, #0]
 8012e8e:	4a1d      	ldr	r2, [pc, #116]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012e90:	2100      	movs	r1, #0
 8012e92:	54d1      	strb	r1, [r2, r3]
            if(char_counter)
 8012e94:	e01d      	b.n	8012ed2 <protocol_poll_cmd+0xe2>
        } else if(char_counter == 0 ? c != ' ' : char_counter < (LINE_BUFFER_SIZE - 1))
 8012e96:	4b1a      	ldr	r3, [pc, #104]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012e98:	681b      	ldr	r3, [r3, #0]
 8012e9a:	2b00      	cmp	r3, #0
 8012e9c:	d107      	bne.n	8012eae <protocol_poll_cmd+0xbe>
 8012e9e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8012ea2:	2b20      	cmp	r3, #32
 8012ea4:	bf14      	ite	ne
 8012ea6:	2301      	movne	r3, #1
 8012ea8:	2300      	moveq	r3, #0
 8012eaa:	b2db      	uxtb	r3, r3
 8012eac:	e006      	b.n	8012ebc <protocol_poll_cmd+0xcc>
 8012eae:	4b14      	ldr	r3, [pc, #80]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012eb0:	681b      	ldr	r3, [r3, #0]
 8012eb2:	2bff      	cmp	r3, #255	; 0xff
 8012eb4:	bf94      	ite	ls
 8012eb6:	2301      	movls	r3, #1
 8012eb8:	2300      	movhi	r3, #0
 8012eba:	b2db      	uxtb	r3, r3
 8012ebc:	2b00      	cmp	r3, #0
 8012ebe:	d008      	beq.n	8012ed2 <protocol_poll_cmd+0xe2>
            line[char_counter++] = c;
 8012ec0:	4b0f      	ldr	r3, [pc, #60]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012ec2:	681b      	ldr	r3, [r3, #0]
 8012ec4:	1c5a      	adds	r2, r3, #1
 8012ec6:	490e      	ldr	r1, [pc, #56]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012ec8:	600a      	str	r2, [r1, #0]
 8012eca:	88fa      	ldrh	r2, [r7, #6]
 8012ecc:	b2d1      	uxtb	r1, r2
 8012ece:	4a0d      	ldr	r2, [pc, #52]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012ed0:	54d1      	strb	r1, [r2, r3]

        keep_rt_commands = char_counter > 0 && *line == '$';
 8012ed2:	4b0b      	ldr	r3, [pc, #44]	; (8012f00 <protocol_poll_cmd+0x110>)
 8012ed4:	681b      	ldr	r3, [r3, #0]
 8012ed6:	2b00      	cmp	r3, #0
 8012ed8:	d005      	beq.n	8012ee6 <protocol_poll_cmd+0xf6>
 8012eda:	4b0a      	ldr	r3, [pc, #40]	; (8012f04 <protocol_poll_cmd+0x114>)
 8012edc:	781b      	ldrb	r3, [r3, #0]
 8012ede:	2b24      	cmp	r3, #36	; 0x24
 8012ee0:	d101      	bne.n	8012ee6 <protocol_poll_cmd+0xf6>
 8012ee2:	2301      	movs	r3, #1
 8012ee4:	e000      	b.n	8012ee8 <protocol_poll_cmd+0xf8>
 8012ee6:	2300      	movs	r3, #0
 8012ee8:	f003 0301 	and.w	r3, r3, #1
 8012eec:	b2da      	uxtb	r2, r3
 8012eee:	4b08      	ldr	r3, [pc, #32]	; (8012f10 <protocol_poll_cmd+0x120>)
 8012ef0:	701a      	strb	r2, [r3, #0]
    }
}
 8012ef2:	bf00      	nop
 8012ef4:	3708      	adds	r7, #8
 8012ef6:	46bd      	mov	sp, r7
 8012ef8:	bd80      	pop	{r7, pc}
 8012efa:	bf00      	nop
 8012efc:	20000ed0 	.word	0x20000ed0
 8012f00:	200011ac 	.word	0x200011ac
 8012f04:	200011b0 	.word	0x200011b0
 8012f08:	20000bb0 	.word	0x20000bb0
 8012f0c:	20000dd4 	.word	0x20000dd4
 8012f10:	200013b5 	.word	0x200013b5

08012f14 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
bool protocol_exec_rt_system (void)
{
 8012f14:	b590      	push	{r4, r7, lr}
 8012f16:	b089      	sub	sp, #36	; 0x24
 8012f18:	af00      	add	r7, sp, #0
    rt_exec_t rt_exec;
    bool killed = false;
 8012f1a:	2300      	movs	r3, #0
 8012f1c:	76fb      	strb	r3, [r7, #27]

    if (sys.rt_exec_alarm && (rt_exec = system_clear_exec_alarm())) { // Enter only if any bit flag is true
 8012f1e:	4b8b      	ldr	r3, [pc, #556]	; (801314c <protocol_exec_rt_system+0x238>)
 8012f20:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8012f22:	2b00      	cmp	r3, #0
 8012f24:	f000 8094 	beq.w	8013050 <protocol_exec_rt_system+0x13c>
 8012f28:	4b89      	ldr	r3, [pc, #548]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8012f2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012f2c:	2100      	movs	r1, #0
 8012f2e:	4889      	ldr	r0, [pc, #548]	; (8013154 <protocol_exec_rt_system+0x240>)
 8012f30:	4798      	blx	r3
 8012f32:	61f8      	str	r0, [r7, #28]
 8012f34:	69fb      	ldr	r3, [r7, #28]
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	f000 808a 	beq.w	8013050 <protocol_exec_rt_system+0x13c>

        if((sys.reset_pending = !!(sys.rt_exec_state & EXEC_RESET))) {
 8012f3c:	4b83      	ldr	r3, [pc, #524]	; (801314c <protocol_exec_rt_system+0x238>)
 8012f3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8012f40:	f003 0320 	and.w	r3, r3, #32
 8012f44:	2b00      	cmp	r3, #0
 8012f46:	bf14      	ite	ne
 8012f48:	2301      	movne	r3, #1
 8012f4a:	2300      	moveq	r3, #0
 8012f4c:	b2da      	uxtb	r2, r3
 8012f4e:	4b7f      	ldr	r3, [pc, #508]	; (801314c <protocol_exec_rt_system+0x238>)
 8012f50:	711a      	strb	r2, [r3, #4]
 8012f52:	4b7e      	ldr	r3, [pc, #504]	; (801314c <protocol_exec_rt_system+0x238>)
 8012f54:	791b      	ldrb	r3, [r3, #4]
 8012f56:	2b00      	cmp	r3, #0
 8012f58:	d008      	beq.n	8012f6c <protocol_exec_rt_system+0x58>
            // Kill spindle and coolant.
            killed = true;
 8012f5a:	2301      	movs	r3, #1
 8012f5c:	76fb      	strb	r3, [r7, #27]
            spindle_all_off();
 8012f5e:	f00a f8b7 	bl	801d0d0 <spindle_all_off>
            hal.coolant.set_state((coolant_state_t){0});
 8012f62:	4b7b      	ldr	r3, [pc, #492]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8012f64:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8012f66:	2200      	movs	r2, #0
 8012f68:	4610      	mov	r0, r2
 8012f6a:	4798      	blx	r3
        }

        // System alarm. Everything has shutdown by something that has gone severely wrong. Report
        // the source of the error to the user. If critical, Grbl disables by entering an infinite
        // loop until system reset/abort.
        system_raise_alarm((alarm_code_t)rt_exec);
 8012f6c:	69fb      	ldr	r3, [r7, #28]
 8012f6e:	b2db      	uxtb	r3, r3
 8012f70:	4618      	mov	r0, r3
 8012f72:	f00e ffa7 	bl	8021ec4 <system_raise_alarm>

        if(killed) // Tell driver/plugins about reset.
 8012f76:	7efb      	ldrb	r3, [r7, #27]
 8012f78:	2b00      	cmp	r3, #0
 8012f7a:	d003      	beq.n	8012f84 <protocol_exec_rt_system+0x70>
            hal.driver_reset();
 8012f7c:	4b74      	ldr	r3, [pc, #464]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8012f7e:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8012f82:	4798      	blx	r3

        // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
        if((sys.blocking_event = (alarm_code_t)rt_exec == Alarm_HardLimit ||
 8012f84:	69fb      	ldr	r3, [r7, #28]
 8012f86:	b2db      	uxtb	r3, r3
                                  (alarm_code_t)rt_exec == Alarm_SoftLimit ||
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 8012f88:	2b01      	cmp	r3, #1
 8012f8a:	d00b      	beq.n	8012fa4 <protocol_exec_rt_system+0x90>
                                  (alarm_code_t)rt_exec == Alarm_SoftLimit ||
 8012f8c:	69fb      	ldr	r3, [r7, #28]
 8012f8e:	b2db      	uxtb	r3, r3
        if((sys.blocking_event = (alarm_code_t)rt_exec == Alarm_HardLimit ||
 8012f90:	2b02      	cmp	r3, #2
 8012f92:	d007      	beq.n	8012fa4 <protocol_exec_rt_system+0x90>
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 8012f94:	69fb      	ldr	r3, [r7, #28]
 8012f96:	b2db      	uxtb	r3, r3
                                  (alarm_code_t)rt_exec == Alarm_SoftLimit ||
 8012f98:	2b0a      	cmp	r3, #10
 8012f9a:	d003      	beq.n	8012fa4 <protocol_exec_rt_system+0x90>
                                    (alarm_code_t)rt_exec == Alarm_MotorFault)) {
 8012f9c:	69fb      	ldr	r3, [r7, #28]
 8012f9e:	b2db      	uxtb	r3, r3
                                   (alarm_code_t)rt_exec == Alarm_EStop ||
 8012fa0:	2b11      	cmp	r3, #17
 8012fa2:	d101      	bne.n	8012fa8 <protocol_exec_rt_system+0x94>
 8012fa4:	2301      	movs	r3, #1
 8012fa6:	e000      	b.n	8012faa <protocol_exec_rt_system+0x96>
 8012fa8:	2300      	movs	r3, #0
 8012faa:	f003 0301 	and.w	r3, r3, #1
 8012fae:	b2da      	uxtb	r2, r3
        if((sys.blocking_event = (alarm_code_t)rt_exec == Alarm_HardLimit ||
 8012fb0:	4b66      	ldr	r3, [pc, #408]	; (801314c <protocol_exec_rt_system+0x238>)
 8012fb2:	715a      	strb	r2, [r3, #5]
 8012fb4:	4b65      	ldr	r3, [pc, #404]	; (801314c <protocol_exec_rt_system+0x238>)
 8012fb6:	795b      	ldrb	r3, [r3, #5]
 8012fb8:	2b00      	cmp	r3, #0
 8012fba:	d049      	beq.n	8013050 <protocol_exec_rt_system+0x13c>

            system_set_exec_alarm(rt_exec);
 8012fbc:	4b64      	ldr	r3, [pc, #400]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8012fbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012fc0:	69f9      	ldr	r1, [r7, #28]
 8012fc2:	4864      	ldr	r0, [pc, #400]	; (8013154 <protocol_exec_rt_system+0x240>)
 8012fc4:	4798      	blx	r3

            switch((alarm_code_t)rt_exec) {
 8012fc6:	69fb      	ldr	r3, [r7, #28]
 8012fc8:	b2db      	uxtb	r3, r3
 8012fca:	2b0a      	cmp	r3, #10
 8012fcc:	d002      	beq.n	8012fd4 <protocol_exec_rt_system+0xc0>
 8012fce:	2b11      	cmp	r3, #17
 8012fd0:	d005      	beq.n	8012fde <protocol_exec_rt_system+0xca>
 8012fd2:	e009      	b.n	8012fe8 <protocol_exec_rt_system+0xd4>

                case Alarm_EStop:
                    grbl.report.feedback_message(Message_EStop);
 8012fd4:	4b60      	ldr	r3, [pc, #384]	; (8013158 <protocol_exec_rt_system+0x244>)
 8012fd6:	68db      	ldr	r3, [r3, #12]
 8012fd8:	200c      	movs	r0, #12
 8012fda:	4798      	blx	r3
                    break;
 8012fdc:	e009      	b.n	8012ff2 <protocol_exec_rt_system+0xde>

                case Alarm_MotorFault:
                    grbl.report.feedback_message(Message_MotorFault);
 8012fde:	4b5e      	ldr	r3, [pc, #376]	; (8013158 <protocol_exec_rt_system+0x244>)
 8012fe0:	68db      	ldr	r3, [r3, #12]
 8012fe2:	2010      	movs	r0, #16
 8012fe4:	4798      	blx	r3
                    break;
 8012fe6:	e004      	b.n	8012ff2 <protocol_exec_rt_system+0xde>

                default:
                    grbl.report.feedback_message(Message_CriticalEvent);
 8012fe8:	4b5b      	ldr	r3, [pc, #364]	; (8013158 <protocol_exec_rt_system+0x244>)
 8012fea:	68db      	ldr	r3, [r3, #12]
 8012fec:	2001      	movs	r0, #1
 8012fee:	4798      	blx	r3
                    break;
 8012ff0:	bf00      	nop
            }

            system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 8012ff2:	4b57      	ldr	r3, [pc, #348]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8012ff4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012ff6:	2120      	movs	r1, #32
 8012ff8:	4858      	ldr	r0, [pc, #352]	; (801315c <protocol_exec_rt_system+0x248>)
 8012ffa:	4798      	blx	r3

            *line = '\0';
 8012ffc:	4b58      	ldr	r3, [pc, #352]	; (8013160 <protocol_exec_rt_system+0x24c>)
 8012ffe:	2200      	movs	r2, #0
 8013000:	701a      	strb	r2, [r3, #0]
            char_counter = 0;
 8013002:	4b58      	ldr	r3, [pc, #352]	; (8013164 <protocol_exec_rt_system+0x250>)
 8013004:	2200      	movs	r2, #0
 8013006:	601a      	str	r2, [r3, #0]
            hal.stream.reset_read_buffer();
 8013008:	4b51      	ldr	r3, [pc, #324]	; (8013150 <protocol_exec_rt_system+0x23c>)
 801300a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801300e:	4798      	blx	r3

            while (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 8013010:	e013      	b.n	801303a <protocol_exec_rt_system+0x126>
                // cycles. Hard limits typically occur while unattended or not paying attention. Gives
                // the user and a GUI time to do what is needed before resetting, like killing the
                // incoming stream. The same could be said about soft limits. While the position is not
                // lost, continued streaming could cause a serious crash if by chance it gets executed.

                if(bit_istrue(sys.rt_exec_state, EXEC_STATUS_REPORT)) {
 8013012:	4b4e      	ldr	r3, [pc, #312]	; (801314c <protocol_exec_rt_system+0x238>)
 8013014:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8013016:	f003 0301 	and.w	r3, r3, #1
 801301a:	2b00      	cmp	r3, #0
 801301c:	d006      	beq.n	801302c <protocol_exec_rt_system+0x118>
                    system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 801301e:	4b4c      	ldr	r3, [pc, #304]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8013020:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8013022:	2101      	movs	r1, #1
 8013024:	484d      	ldr	r0, [pc, #308]	; (801315c <protocol_exec_rt_system+0x248>)
 8013026:	4798      	blx	r3
                    report_realtime_status();
 8013028:	f002 fff6 	bl	8016018 <report_realtime_status>
                }

                protocol_poll_cmd();
 801302c:	f7ff fee0 	bl	8012df0 <protocol_poll_cmd>
                grbl.on_execute_realtime(STATE_ESTOP);
 8013030:	4b49      	ldr	r3, [pc, #292]	; (8013158 <protocol_exec_rt_system+0x244>)
 8013032:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8013034:	f44f 7080 	mov.w	r0, #256	; 0x100
 8013038:	4798      	blx	r3
            while (bit_isfalse(sys.rt_exec_state, EXEC_RESET)) {
 801303a:	4b44      	ldr	r3, [pc, #272]	; (801314c <protocol_exec_rt_system+0x238>)
 801303c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801303e:	f003 0320 	and.w	r3, r3, #32
 8013042:	2b00      	cmp	r3, #0
 8013044:	d0e5      	beq.n	8013012 <protocol_exec_rt_system+0xfe>
            }

            system_clear_exec_alarm(); // Clear alarm
 8013046:	4b42      	ldr	r3, [pc, #264]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8013048:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801304a:	2100      	movs	r1, #0
 801304c:	4841      	ldr	r0, [pc, #260]	; (8013154 <protocol_exec_rt_system+0x240>)
 801304e:	4798      	blx	r3
        }
    }

    if (sys.rt_exec_state && (rt_exec = system_clear_exec_states())) { // Get and clear volatile sys.rt_exec_state atomically.
 8013050:	4b3e      	ldr	r3, [pc, #248]	; (801314c <protocol_exec_rt_system+0x238>)
 8013052:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8013054:	2b00      	cmp	r3, #0
 8013056:	f000 814e 	beq.w	80132f6 <protocol_exec_rt_system+0x3e2>
 801305a:	4b3d      	ldr	r3, [pc, #244]	; (8013150 <protocol_exec_rt_system+0x23c>)
 801305c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801305e:	2100      	movs	r1, #0
 8013060:	483e      	ldr	r0, [pc, #248]	; (801315c <protocol_exec_rt_system+0x248>)
 8013062:	4798      	blx	r3
 8013064:	61f8      	str	r0, [r7, #28]
 8013066:	69fb      	ldr	r3, [r7, #28]
 8013068:	2b00      	cmp	r3, #0
 801306a:	f000 8144 	beq.w	80132f6 <protocol_exec_rt_system+0x3e2>

        // Execute system abort.
        if((sys.reset_pending = !!(rt_exec & EXEC_RESET))) {
 801306e:	69fb      	ldr	r3, [r7, #28]
 8013070:	f003 0320 	and.w	r3, r3, #32
 8013074:	2b00      	cmp	r3, #0
 8013076:	bf14      	ite	ne
 8013078:	2301      	movne	r3, #1
 801307a:	2300      	moveq	r3, #0
 801307c:	b2da      	uxtb	r2, r3
 801307e:	4b33      	ldr	r3, [pc, #204]	; (801314c <protocol_exec_rt_system+0x238>)
 8013080:	711a      	strb	r2, [r3, #4]
 8013082:	4b32      	ldr	r3, [pc, #200]	; (801314c <protocol_exec_rt_system+0x238>)
 8013084:	791b      	ldrb	r3, [r3, #4]
 8013086:	2b00      	cmp	r3, #0
 8013088:	d06e      	beq.n	8013168 <protocol_exec_rt_system+0x254>

            if(!killed) {
 801308a:	7efb      	ldrb	r3, [r7, #27]
 801308c:	f083 0301 	eor.w	r3, r3, #1
 8013090:	b2db      	uxtb	r3, r3
 8013092:	2b00      	cmp	r3, #0
 8013094:	d006      	beq.n	80130a4 <protocol_exec_rt_system+0x190>
                // Kill spindle and coolant.
                spindle_all_off();
 8013096:	f00a f81b 	bl	801d0d0 <spindle_all_off>
                hal.coolant.set_state((coolant_state_t){0});
 801309a:	4b2d      	ldr	r3, [pc, #180]	; (8013150 <protocol_exec_rt_system+0x23c>)
 801309c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801309e:	2200      	movs	r2, #0
 80130a0:	4610      	mov	r0, r2
 80130a2:	4798      	blx	r3
            }

            // Only place sys.abort is set true, when E-stop is not asserted.
            if(!(sys.abort = !hal.control.get_state().e_stop)) {
 80130a4:	4b2a      	ldr	r3, [pc, #168]	; (8013150 <protocol_exec_rt_system+0x23c>)
 80130a6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80130a8:	4798      	blx	r3
 80130aa:	4603      	mov	r3, r0
 80130ac:	b2db      	uxtb	r3, r3
 80130ae:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80130b2:	b2db      	uxtb	r3, r3
 80130b4:	2b00      	cmp	r3, #0
 80130b6:	bf0c      	ite	eq
 80130b8:	2301      	moveq	r3, #1
 80130ba:	2300      	movne	r3, #0
 80130bc:	b2da      	uxtb	r2, r3
 80130be:	4b23      	ldr	r3, [pc, #140]	; (801314c <protocol_exec_rt_system+0x238>)
 80130c0:	701a      	strb	r2, [r3, #0]
 80130c2:	4b22      	ldr	r3, [pc, #136]	; (801314c <protocol_exec_rt_system+0x238>)
 80130c4:	781b      	ldrb	r3, [r3, #0]
 80130c6:	f083 0301 	eor.w	r3, r3, #1
 80130ca:	b2db      	uxtb	r3, r3
 80130cc:	2b00      	cmp	r3, #0
 80130ce:	d00b      	beq.n	80130e8 <protocol_exec_rt_system+0x1d4>
                hal.stream.reset_read_buffer();
 80130d0:	4b1f      	ldr	r3, [pc, #124]	; (8013150 <protocol_exec_rt_system+0x23c>)
 80130d2:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 80130d6:	4798      	blx	r3
                system_raise_alarm(Alarm_EStop);
 80130d8:	200a      	movs	r0, #10
 80130da:	f00e fef3 	bl	8021ec4 <system_raise_alarm>
                grbl.report.feedback_message(Message_EStop);
 80130de:	4b1e      	ldr	r3, [pc, #120]	; (8013158 <protocol_exec_rt_system+0x244>)
 80130e0:	68db      	ldr	r3, [r3, #12]
 80130e2:	200c      	movs	r0, #12
 80130e4:	4798      	blx	r3
 80130e6:	e019      	b.n	801311c <protocol_exec_rt_system+0x208>
            } else if(hal.control.get_state().motor_fault) {
 80130e8:	4b19      	ldr	r3, [pc, #100]	; (8013150 <protocol_exec_rt_system+0x23c>)
 80130ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80130ec:	4798      	blx	r3
 80130ee:	4603      	mov	r3, r0
 80130f0:	f3c3 2307 	ubfx	r3, r3, #8, #8
 80130f4:	b2db      	uxtb	r3, r3
 80130f6:	f003 0301 	and.w	r3, r3, #1
 80130fa:	b2db      	uxtb	r3, r3
 80130fc:	2b00      	cmp	r3, #0
 80130fe:	d00d      	beq.n	801311c <protocol_exec_rt_system+0x208>
                sys.abort = false;
 8013100:	4b12      	ldr	r3, [pc, #72]	; (801314c <protocol_exec_rt_system+0x238>)
 8013102:	2200      	movs	r2, #0
 8013104:	701a      	strb	r2, [r3, #0]
                hal.stream.reset_read_buffer();
 8013106:	4b12      	ldr	r3, [pc, #72]	; (8013150 <protocol_exec_rt_system+0x23c>)
 8013108:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801310c:	4798      	blx	r3
                system_raise_alarm(Alarm_MotorFault);
 801310e:	2011      	movs	r0, #17
 8013110:	f00e fed8 	bl	8021ec4 <system_raise_alarm>
                grbl.report.feedback_message(Message_MotorFault);
 8013114:	4b10      	ldr	r3, [pc, #64]	; (8013158 <protocol_exec_rt_system+0x244>)
 8013116:	68db      	ldr	r3, [r3, #12]
 8013118:	2010      	movs	r0, #16
 801311a:	4798      	blx	r3
            }

            if(!killed) // Tell driver/plugins about reset.
 801311c:	7efb      	ldrb	r3, [r7, #27]
 801311e:	f083 0301 	eor.w	r3, r3, #1
 8013122:	b2db      	uxtb	r3, r3
 8013124:	2b00      	cmp	r3, #0
 8013126:	d003      	beq.n	8013130 <protocol_exec_rt_system+0x21c>
                hal.driver_reset();
 8013128:	4b09      	ldr	r3, [pc, #36]	; (8013150 <protocol_exec_rt_system+0x23c>)
 801312a:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 801312e:	4798      	blx	r3

            return !sys.abort; // Nothing else to do but exit.
 8013130:	4b06      	ldr	r3, [pc, #24]	; (801314c <protocol_exec_rt_system+0x238>)
 8013132:	781b      	ldrb	r3, [r3, #0]
 8013134:	2b00      	cmp	r3, #0
 8013136:	bf14      	ite	ne
 8013138:	2301      	movne	r3, #1
 801313a:	2300      	moveq	r3, #0
 801313c:	b2db      	uxtb	r3, r3
 801313e:	f083 0301 	eor.w	r3, r3, #1
 8013142:	b2db      	uxtb	r3, r3
 8013144:	f003 0301 	and.w	r3, r3, #1
 8013148:	b2db      	uxtb	r3, r3
 801314a:	e27a      	b.n	8013642 <protocol_exec_rt_system+0x72e>
 801314c:	20000d3c 	.word	0x20000d3c
 8013150:	20000ed0 	.word	0x20000ed0
 8013154:	20000d88 	.word	0x20000d88
 8013158:	20000dd4 	.word	0x20000dd4
 801315c:	20000d84 	.word	0x20000d84
 8013160:	200011b0 	.word	0x200011b0
 8013164:	200011ac 	.word	0x200011ac
        }

        if(rt_exec & EXEC_STOP) { // Experimental for now, must be verified. Do NOT move to interrupt context!
 8013168:	69fb      	ldr	r3, [r7, #28]
 801316a:	f003 0310 	and.w	r3, r3, #16
 801316e:	2b00      	cmp	r3, #0
 8013170:	d074      	beq.n	801325c <protocol_exec_rt_system+0x348>

            sys.cancel = true;
 8013172:	4bad      	ldr	r3, [pc, #692]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013174:	2201      	movs	r2, #1
 8013176:	705a      	strb	r2, [r3, #1]
            sys.step_control.flags = 0;
 8013178:	4bab      	ldr	r3, [pc, #684]	; (8013428 <protocol_exec_rt_system+0x514>)
 801317a:	2200      	movs	r2, #0
 801317c:	761a      	strb	r2, [r3, #24]
            sys.flags.feed_hold_pending = Off;
 801317e:	4aaa      	ldr	r2, [pc, #680]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013180:	7d93      	ldrb	r3, [r2, #22]
 8013182:	f36f 1345 	bfc	r3, #5, #1
 8013186:	7593      	strb	r3, [r2, #22]
            sys.override_delay.flags = 0;
 8013188:	4ba7      	ldr	r3, [pc, #668]	; (8013428 <protocol_exec_rt_system+0x514>)
 801318a:	2200      	movs	r2, #0
 801318c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
            if(sys.override.control.sync)
 8013190:	4ba5      	ldr	r3, [pc, #660]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013192:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8013196:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801319a:	b2db      	uxtb	r3, r3
 801319c:	2b00      	cmp	r3, #0
 801319e:	d004      	beq.n	80131aa <protocol_exec_rt_system+0x296>
                sys.override.control = gc_state.modal.override_ctrl;
 80131a0:	4aa1      	ldr	r2, [pc, #644]	; (8013428 <protocol_exec_rt_system+0x514>)
 80131a2:	4ba2      	ldr	r3, [pc, #648]	; (801342c <protocol_exec_rt_system+0x518>)
 80131a4:	7f1b      	ldrb	r3, [r3, #28]
 80131a6:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29

            gc_state.tool_change = false;
 80131aa:	4ba0      	ldr	r3, [pc, #640]	; (801342c <protocol_exec_rt_system+0x518>)
 80131ac:	2200      	movs	r2, #0
 80131ae:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
            gc_state.modal.spindle.rpm_mode = SpindleSpeedMode_RPM;
 80131b2:	4b9e      	ldr	r3, [pc, #632]	; (801342c <protocol_exec_rt_system+0x518>)
 80131b4:	2200      	movs	r2, #0
 80131b6:	76da      	strb	r2, [r3, #27]

            // Tell driver/plugins about reset.
            hal.driver_reset();
 80131b8:	4b9d      	ldr	r3, [pc, #628]	; (8013430 <protocol_exec_rt_system+0x51c>)
 80131ba:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80131be:	4798      	blx	r3

            if(!sys.flags.keep_input && hal.stream.suspend_read && hal.stream.suspend_read(false))
 80131c0:	4b99      	ldr	r3, [pc, #612]	; (8013428 <protocol_exec_rt_system+0x514>)
 80131c2:	7ddb      	ldrb	r3, [r3, #23]
 80131c4:	f003 0301 	and.w	r3, r3, #1
 80131c8:	b2db      	uxtb	r3, r3
 80131ca:	2b00      	cmp	r3, #0
 80131cc:	d110      	bne.n	80131f0 <protocol_exec_rt_system+0x2dc>
 80131ce:	4b98      	ldr	r3, [pc, #608]	; (8013430 <protocol_exec_rt_system+0x51c>)
 80131d0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 80131d4:	2b00      	cmp	r3, #0
 80131d6:	d00b      	beq.n	80131f0 <protocol_exec_rt_system+0x2dc>
 80131d8:	4b95      	ldr	r3, [pc, #596]	; (8013430 <protocol_exec_rt_system+0x51c>)
 80131da:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 80131de:	2000      	movs	r0, #0
 80131e0:	4798      	blx	r3
 80131e2:	4603      	mov	r3, r0
 80131e4:	2b00      	cmp	r3, #0
 80131e6:	d003      	beq.n	80131f0 <protocol_exec_rt_system+0x2dc>
                hal.stream.cancel_read_buffer(); // flush pending blocks (after M6)
 80131e8:	4b91      	ldr	r3, [pc, #580]	; (8013430 <protocol_exec_rt_system+0x51c>)
 80131ea:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80131ee:	4798      	blx	r3

            sys.flags.keep_input = Off;
 80131f0:	4a8d      	ldr	r2, [pc, #564]	; (8013428 <protocol_exec_rt_system+0x514>)
 80131f2:	7dd3      	ldrb	r3, [r2, #23]
 80131f4:	f36f 0300 	bfc	r3, #0, #1
 80131f8:	75d3      	strb	r3, [r2, #23]

            gc_init();
 80131fa:	f7f2 fd03 	bl	8005c04 <gc_init>
            plan_reset();
 80131fe:	f7fe fa8f 	bl	8011720 <plan_reset>
/*            if(sys.alarm_pending == Alarm_ProbeProtect) {
                st_go_idle();
                system_set_exec_alarm(sys.alarm_pending);
                sys.alarm_pending = Alarm_None;
            } else*/
            st_reset();
 8013202:	f00b fed1 	bl	801efa8 <st_reset>
            sync_position();
 8013206:	f7fe ffed 	bl	80121e4 <plan_sync_position>
 801320a:	498a      	ldr	r1, [pc, #552]	; (8013434 <protocol_exec_rt_system+0x520>)
 801320c:	488a      	ldr	r0, [pc, #552]	; (8013438 <protocol_exec_rt_system+0x524>)
 801320e:	f00e fdff 	bl	8021e10 <system_convert_array_steps_to_mpos>

            // Kill spindle and coolant. TODO: Check Mach3 behaviour?
            gc_spindle_off();
 8013212:	f7f2 fdc3 	bl	8005d9c <gc_spindle_off>
            gc_coolant_off();
 8013216:	f7f2 fdd3 	bl	8005dc0 <gc_coolant_off>

            flush_override_buffers();
 801321a:	f7fe f907 	bl	801142c <flush_override_buffers>
            if(!((state_get() == STATE_ALARM) && (sys.alarm == Alarm_LimitsEngaged || sys.alarm == Alarm_HomingRequired)))
 801321e:	f00a fb4f 	bl	801d8c0 <state_get>
 8013222:	4603      	mov	r3, r0
 8013224:	2b01      	cmp	r3, #1
 8013226:	d109      	bne.n	801323c <protocol_exec_rt_system+0x328>
 8013228:	4b7f      	ldr	r3, [pc, #508]	; (8013428 <protocol_exec_rt_system+0x514>)
 801322a:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 801322e:	2b0c      	cmp	r3, #12
 8013230:	d014      	beq.n	801325c <protocol_exec_rt_system+0x348>
 8013232:	4b7d      	ldr	r3, [pc, #500]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013234:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8013238:	2b0b      	cmp	r3, #11
 801323a:	d00f      	beq.n	801325c <protocol_exec_rt_system+0x348>
                state_set(hal.control.get_state().safety_door_ajar ? STATE_SAFETY_DOOR : STATE_IDLE);
 801323c:	4b7c      	ldr	r3, [pc, #496]	; (8013430 <protocol_exec_rt_system+0x51c>)
 801323e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013240:	4798      	blx	r3
 8013242:	4603      	mov	r3, r0
 8013244:	b2db      	uxtb	r3, r3
 8013246:	f003 0308 	and.w	r3, r3, #8
 801324a:	b2db      	uxtb	r3, r3
 801324c:	2b00      	cmp	r3, #0
 801324e:	d001      	beq.n	8013254 <protocol_exec_rt_system+0x340>
 8013250:	2340      	movs	r3, #64	; 0x40
 8013252:	e000      	b.n	8013256 <protocol_exec_rt_system+0x342>
 8013254:	2300      	movs	r3, #0
 8013256:	4618      	mov	r0, r3
 8013258:	f00a fb3c 	bl	801d8d4 <state_set>
        }

        // Execute and print status to output stream
        if (rt_exec & EXEC_STATUS_REPORT)
 801325c:	69fb      	ldr	r3, [r7, #28]
 801325e:	f003 0301 	and.w	r3, r3, #1
 8013262:	2b00      	cmp	r3, #0
 8013264:	d001      	beq.n	801326a <protocol_exec_rt_system+0x356>
            report_realtime_status();
 8013266:	f002 fed7 	bl	8016018 <report_realtime_status>

        if(rt_exec & EXEC_GCODE_REPORT)
 801326a:	69fb      	ldr	r3, [r7, #28]
 801326c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8013270:	2b00      	cmp	r3, #0
 8013272:	d001      	beq.n	8013278 <protocol_exec_rt_system+0x364>
            report_gcode_modes();
 8013274:	f001 ff2e 	bl	80150d4 <report_gcode_modes>

        if(rt_exec & EXEC_TLO_REPORT)
 8013278:	69fb      	ldr	r3, [r7, #28]
 801327a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801327e:	2b00      	cmp	r3, #0
 8013280:	d001      	beq.n	8013286 <protocol_exec_rt_system+0x372>
            report_tool_offsets();
 8013282:	f001 fcf3 	bl	8014c6c <report_tool_offsets>

        // Execute and print PID log to output stream
        if (rt_exec & EXEC_PID_REPORT)
 8013286:	69fb      	ldr	r3, [r7, #28]
 8013288:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801328c:	2b00      	cmp	r3, #0
 801328e:	d001      	beq.n	8013294 <protocol_exec_rt_system+0x380>
            report_pid_log();
 8013290:	f005 fc74 	bl	8018b7c <report_pid_log>

        if(rt_exec & EXEC_RT_COMMAND)
 8013294:	69fb      	ldr	r3, [r7, #28]
 8013296:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801329a:	2b00      	cmp	r3, #0
 801329c:	d001      	beq.n	80132a2 <protocol_exec_rt_system+0x38e>
            protocol_execute_rt_commands();
 801329e:	f000 fdd5 	bl	8013e4c <protocol_execute_rt_commands>

        rt_exec &= ~(EXEC_STOP|EXEC_STATUS_REPORT|EXEC_GCODE_REPORT|EXEC_PID_REPORT|EXEC_TLO_REPORT|EXEC_RT_COMMAND); // clear requests already processed
 80132a2:	69fb      	ldr	r3, [r7, #28]
 80132a4:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80132a8:	f023 0311 	bic.w	r3, r3, #17
 80132ac:	61fb      	str	r3, [r7, #28]

        if(sys.flags.feed_hold_pending) {
 80132ae:	4b5e      	ldr	r3, [pc, #376]	; (8013428 <protocol_exec_rt_system+0x514>)
 80132b0:	7d9b      	ldrb	r3, [r3, #22]
 80132b2:	f003 0320 	and.w	r3, r3, #32
 80132b6:	b2db      	uxtb	r3, r3
 80132b8:	2b00      	cmp	r3, #0
 80132ba:	d016      	beq.n	80132ea <protocol_exec_rt_system+0x3d6>
            if(rt_exec & EXEC_CYCLE_START)
 80132bc:	69fb      	ldr	r3, [r7, #28]
 80132be:	f003 0302 	and.w	r3, r3, #2
 80132c2:	2b00      	cmp	r3, #0
 80132c4:	d005      	beq.n	80132d2 <protocol_exec_rt_system+0x3be>
                sys.flags.feed_hold_pending = Off;
 80132c6:	4a58      	ldr	r2, [pc, #352]	; (8013428 <protocol_exec_rt_system+0x514>)
 80132c8:	7d93      	ldrb	r3, [r2, #22]
 80132ca:	f36f 1345 	bfc	r3, #5, #1
 80132ce:	7593      	strb	r3, [r2, #22]
 80132d0:	e00b      	b.n	80132ea <protocol_exec_rt_system+0x3d6>
            else if(!sys.override.control.feed_hold_disable)
 80132d2:	4b55      	ldr	r3, [pc, #340]	; (8013428 <protocol_exec_rt_system+0x514>)
 80132d4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80132d8:	f003 0302 	and.w	r3, r3, #2
 80132dc:	b2db      	uxtb	r3, r3
 80132de:	2b00      	cmp	r3, #0
 80132e0:	d103      	bne.n	80132ea <protocol_exec_rt_system+0x3d6>
                rt_exec |= EXEC_FEED_HOLD;
 80132e2:	69fb      	ldr	r3, [r7, #28]
 80132e4:	f043 0308 	orr.w	r3, r3, #8
 80132e8:	61fb      	str	r3, [r7, #28]
        }

        // Let state machine handle any remaining requests
        if(rt_exec)
 80132ea:	69fb      	ldr	r3, [r7, #28]
 80132ec:	2b00      	cmp	r3, #0
 80132ee:	d002      	beq.n	80132f6 <protocol_exec_rt_system+0x3e2>
            state_update(rt_exec);
 80132f0:	69f8      	ldr	r0, [r7, #28]
 80132f2:	f00a fac9 	bl	801d888 <state_update>
    }

    grbl.on_execute_realtime(state_get());
 80132f6:	4b51      	ldr	r3, [pc, #324]	; (801343c <protocol_exec_rt_system+0x528>)
 80132f8:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 80132fa:	f00a fae1 	bl	801d8c0 <state_get>
 80132fe:	4603      	mov	r3, r0
 8013300:	4618      	mov	r0, r3
 8013302:	47a0      	blx	r4

    // Execute overrides.

    if(!sys.override_delay.feedrate && (rt_exec = get_feed_override())) {
 8013304:	4b48      	ldr	r3, [pc, #288]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013306:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801330a:	f003 0301 	and.w	r3, r3, #1
 801330e:	b2db      	uxtb	r3, r3
 8013310:	2b00      	cmp	r3, #0
 8013312:	d154      	bne.n	80133be <protocol_exec_rt_system+0x4aa>
 8013314:	f7fd ffe4 	bl	80112e0 <get_feed_override>
 8013318:	4603      	mov	r3, r0
 801331a:	61fb      	str	r3, [r7, #28]
 801331c:	69fb      	ldr	r3, [r7, #28]
 801331e:	2b00      	cmp	r3, #0
 8013320:	d04d      	beq.n	80133be <protocol_exec_rt_system+0x4aa>

        override_t new_f_override = sys.override.feed_rate;
 8013322:	4b41      	ldr	r3, [pc, #260]	; (8013428 <protocol_exec_rt_system+0x514>)
 8013324:	69db      	ldr	r3, [r3, #28]
 8013326:	617b      	str	r3, [r7, #20]
        override_t new_r_override = sys.override.rapid_rate;
 8013328:	4b3f      	ldr	r3, [pc, #252]	; (8013428 <protocol_exec_rt_system+0x514>)
 801332a:	6a1b      	ldr	r3, [r3, #32]
 801332c:	613b      	str	r3, [r7, #16]

        do {

            switch(rt_exec) {
 801332e:	69fb      	ldr	r3, [r7, #28]
 8013330:	3b90      	subs	r3, #144	; 0x90
 8013332:	2b07      	cmp	r3, #7
 8013334:	d82e      	bhi.n	8013394 <protocol_exec_rt_system+0x480>
 8013336:	a201      	add	r2, pc, #4	; (adr r2, 801333c <protocol_exec_rt_system+0x428>)
 8013338:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801333c:	0801335d 	.word	0x0801335d
 8013340:	08013363 	.word	0x08013363
 8013344:	0801336b 	.word	0x0801336b
 8013348:	08013373 	.word	0x08013373
 801334c:	0801337b 	.word	0x0801337b
 8013350:	08013383 	.word	0x08013383
 8013354:	08013389 	.word	0x08013389
 8013358:	0801338f 	.word	0x0801338f

                case CMD_OVERRIDE_FEED_RESET:
                    new_f_override = DEFAULT_FEED_OVERRIDE;
 801335c:	2364      	movs	r3, #100	; 0x64
 801335e:	617b      	str	r3, [r7, #20]
                    break;
 8013360:	e018      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_FEED_COARSE_PLUS:
                    new_f_override += FEED_OVERRIDE_COARSE_INCREMENT;
 8013362:	697b      	ldr	r3, [r7, #20]
 8013364:	330a      	adds	r3, #10
 8013366:	617b      	str	r3, [r7, #20]
                    break;
 8013368:	e014      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_FEED_COARSE_MINUS:
                    new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT;
 801336a:	697b      	ldr	r3, [r7, #20]
 801336c:	3b0a      	subs	r3, #10
 801336e:	617b      	str	r3, [r7, #20]
                    break;
 8013370:	e010      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_FEED_FINE_PLUS:
                    new_f_override += FEED_OVERRIDE_FINE_INCREMENT;
 8013372:	697b      	ldr	r3, [r7, #20]
 8013374:	3301      	adds	r3, #1
 8013376:	617b      	str	r3, [r7, #20]
                    break;
 8013378:	e00c      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_FEED_FINE_MINUS:
                    new_f_override -= FEED_OVERRIDE_FINE_INCREMENT;
 801337a:	697b      	ldr	r3, [r7, #20]
 801337c:	3b01      	subs	r3, #1
 801337e:	617b      	str	r3, [r7, #20]
                    break;
 8013380:	e008      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_RAPID_RESET:
                    new_r_override = DEFAULT_RAPID_OVERRIDE;
 8013382:	2364      	movs	r3, #100	; 0x64
 8013384:	613b      	str	r3, [r7, #16]
                    break;
 8013386:	e005      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_RAPID_MEDIUM:
                    new_r_override = RAPID_OVERRIDE_MEDIUM;
 8013388:	2332      	movs	r3, #50	; 0x32
 801338a:	613b      	str	r3, [r7, #16]
                    break;
 801338c:	e002      	b.n	8013394 <protocol_exec_rt_system+0x480>

                case CMD_OVERRIDE_RAPID_LOW:
                    new_r_override = RAPID_OVERRIDE_LOW;
 801338e:	2319      	movs	r3, #25
 8013390:	613b      	str	r3, [r7, #16]
                    break;
 8013392:	bf00      	nop
            }

            new_f_override = constrain(new_f_override, MIN_FEED_RATE_OVERRIDE, MAX_FEED_RATE_OVERRIDE);
 8013394:	697b      	ldr	r3, [r7, #20]
 8013396:	2b09      	cmp	r3, #9
 8013398:	d904      	bls.n	80133a4 <protocol_exec_rt_system+0x490>
 801339a:	697b      	ldr	r3, [r7, #20]
 801339c:	2bc8      	cmp	r3, #200	; 0xc8
 801339e:	bf28      	it	cs
 80133a0:	23c8      	movcs	r3, #200	; 0xc8
 80133a2:	e000      	b.n	80133a6 <protocol_exec_rt_system+0x492>
 80133a4:	230a      	movs	r3, #10
 80133a6:	617b      	str	r3, [r7, #20]

        } while((rt_exec = get_feed_override()));
 80133a8:	f7fd ff9a 	bl	80112e0 <get_feed_override>
 80133ac:	4603      	mov	r3, r0
 80133ae:	61fb      	str	r3, [r7, #28]
 80133b0:	69fb      	ldr	r3, [r7, #28]
 80133b2:	2b00      	cmp	r3, #0
 80133b4:	d1bb      	bne.n	801332e <protocol_exec_rt_system+0x41a>

        plan_feed_override(new_f_override, new_r_override);
 80133b6:	6939      	ldr	r1, [r7, #16]
 80133b8:	6978      	ldr	r0, [r7, #20]
 80133ba:	f7fe ff9b 	bl	80122f4 <plan_feed_override>
    }

    if(!sys.override_delay.spindle && (rt_exec = get_spindle_override())) {
 80133be:	4b1a      	ldr	r3, [pc, #104]	; (8013428 <protocol_exec_rt_system+0x514>)
 80133c0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80133c4:	f003 0304 	and.w	r3, r3, #4
 80133c8:	b2db      	uxtb	r3, r3
 80133ca:	2b00      	cmp	r3, #0
 80133cc:	f040 809e 	bne.w	801350c <protocol_exec_rt_system+0x5f8>
 80133d0:	f7fd ffc8 	bl	8011364 <get_spindle_override>
 80133d4:	4603      	mov	r3, r0
 80133d6:	61fb      	str	r3, [r7, #28]
 80133d8:	69fb      	ldr	r3, [r7, #28]
 80133da:	2b00      	cmp	r3, #0
 80133dc:	f000 8096 	beq.w	801350c <protocol_exec_rt_system+0x5f8>

        bool spindle_stop = false;
 80133e0:	2300      	movs	r3, #0
 80133e2:	73fb      	strb	r3, [r7, #15]
        spindle_ptrs_t *spindle = gc_spindle_get();
 80133e4:	f7f2 fd00 	bl	8005de8 <gc_spindle_get>
 80133e8:	6078      	str	r0, [r7, #4]
        override_t last_s_override = spindle->param->override_pct;
 80133ea:	687b      	ldr	r3, [r7, #4]
 80133ec:	685b      	ldr	r3, [r3, #4]
 80133ee:	68db      	ldr	r3, [r3, #12]
 80133f0:	60bb      	str	r3, [r7, #8]

        do {

            switch(rt_exec) {
 80133f2:	69fb      	ldr	r3, [r7, #28]
 80133f4:	3b99      	subs	r3, #153	; 0x99
 80133f6:	2b05      	cmp	r3, #5
 80133f8:	d83d      	bhi.n	8013476 <protocol_exec_rt_system+0x562>
 80133fa:	a201      	add	r2, pc, #4	; (adr r2, 8013400 <protocol_exec_rt_system+0x4ec>)
 80133fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013400:	08013419 	.word	0x08013419
 8013404:	0801341f 	.word	0x0801341f
 8013408:	08013441 	.word	0x08013441
 801340c:	08013449 	.word	0x08013449
 8013410:	08013451 	.word	0x08013451
 8013414:	08013459 	.word	0x08013459

                case CMD_OVERRIDE_SPINDLE_RESET:
                    last_s_override = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8013418:	2364      	movs	r3, #100	; 0x64
 801341a:	60bb      	str	r3, [r7, #8]
                    break;
 801341c:	e036      	b.n	801348c <protocol_exec_rt_system+0x578>

                case CMD_OVERRIDE_SPINDLE_COARSE_PLUS:
                    last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT;
 801341e:	68bb      	ldr	r3, [r7, #8]
 8013420:	330a      	adds	r3, #10
 8013422:	60bb      	str	r3, [r7, #8]
                    break;
 8013424:	e032      	b.n	801348c <protocol_exec_rt_system+0x578>
 8013426:	bf00      	nop
 8013428:	20000d3c 	.word	0x20000d3c
 801342c:	20000bb0 	.word	0x20000bb0
 8013430:	20000ed0 	.word	0x20000ed0
 8013434:	20000dc4 	.word	0x20000dc4
 8013438:	20000c0c 	.word	0x20000c0c
 801343c:	20000dd4 	.word	0x20000dd4

                case CMD_OVERRIDE_SPINDLE_COARSE_MINUS:
                    last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT;
 8013440:	68bb      	ldr	r3, [r7, #8]
 8013442:	3b0a      	subs	r3, #10
 8013444:	60bb      	str	r3, [r7, #8]
                    break;
 8013446:	e021      	b.n	801348c <protocol_exec_rt_system+0x578>

                case CMD_OVERRIDE_SPINDLE_FINE_PLUS:
                    last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 8013448:	68bb      	ldr	r3, [r7, #8]
 801344a:	3301      	adds	r3, #1
 801344c:	60bb      	str	r3, [r7, #8]
                    break;
 801344e:	e01d      	b.n	801348c <protocol_exec_rt_system+0x578>

                case CMD_OVERRIDE_SPINDLE_FINE_MINUS:
                    last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT;
 8013450:	68bb      	ldr	r3, [r7, #8]
 8013452:	3b01      	subs	r3, #1
 8013454:	60bb      	str	r3, [r7, #8]
                    break;
 8013456:	e019      	b.n	801348c <protocol_exec_rt_system+0x578>

                case CMD_OVERRIDE_SPINDLE_STOP:
                    spindle_stop = !spindle_stop;
 8013458:	7bfb      	ldrb	r3, [r7, #15]
 801345a:	2b00      	cmp	r3, #0
 801345c:	bf14      	ite	ne
 801345e:	2301      	movne	r3, #1
 8013460:	2300      	moveq	r3, #0
 8013462:	b2db      	uxtb	r3, r3
 8013464:	f083 0301 	eor.w	r3, r3, #1
 8013468:	b2db      	uxtb	r3, r3
 801346a:	73fb      	strb	r3, [r7, #15]
 801346c:	7bfb      	ldrb	r3, [r7, #15]
 801346e:	f003 0301 	and.w	r3, r3, #1
 8013472:	73fb      	strb	r3, [r7, #15]
                    break;
 8013474:	e00a      	b.n	801348c <protocol_exec_rt_system+0x578>

                default:
                    if(grbl.on_unknown_accessory_override)
 8013476:	4b75      	ldr	r3, [pc, #468]	; (801364c <protocol_exec_rt_system+0x738>)
 8013478:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801347a:	2b00      	cmp	r3, #0
 801347c:	d005      	beq.n	801348a <protocol_exec_rt_system+0x576>
                        grbl.on_unknown_accessory_override(rt_exec);
 801347e:	4b73      	ldr	r3, [pc, #460]	; (801364c <protocol_exec_rt_system+0x738>)
 8013480:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8013482:	69fa      	ldr	r2, [r7, #28]
 8013484:	b2d2      	uxtb	r2, r2
 8013486:	4610      	mov	r0, r2
 8013488:	4798      	blx	r3
                    break;
 801348a:	bf00      	nop
            }

            last_s_override = constrain(last_s_override, MIN_SPINDLE_RPM_OVERRIDE, MAX_SPINDLE_RPM_OVERRIDE);
 801348c:	68bb      	ldr	r3, [r7, #8]
 801348e:	2b09      	cmp	r3, #9
 8013490:	d904      	bls.n	801349c <protocol_exec_rt_system+0x588>
 8013492:	68bb      	ldr	r3, [r7, #8]
 8013494:	2bc8      	cmp	r3, #200	; 0xc8
 8013496:	bf28      	it	cs
 8013498:	23c8      	movcs	r3, #200	; 0xc8
 801349a:	e000      	b.n	801349e <protocol_exec_rt_system+0x58a>
 801349c:	230a      	movs	r3, #10
 801349e:	60bb      	str	r3, [r7, #8]

        } while((rt_exec = get_spindle_override()));
 80134a0:	f7fd ff60 	bl	8011364 <get_spindle_override>
 80134a4:	4603      	mov	r3, r0
 80134a6:	61fb      	str	r3, [r7, #28]
 80134a8:	69fb      	ldr	r3, [r7, #28]
 80134aa:	2b00      	cmp	r3, #0
 80134ac:	d1a1      	bne.n	80133f2 <protocol_exec_rt_system+0x4de>

        spindle_set_override(spindle, last_s_override);
 80134ae:	68b9      	ldr	r1, [r7, #8]
 80134b0:	6878      	ldr	r0, [r7, #4]
 80134b2:	f009 fbc1 	bl	801cc38 <spindle_set_override>

        if (spindle_stop && state_get() == STATE_HOLD && gc_state.modal.spindle.state.on) {
 80134b6:	7bfb      	ldrb	r3, [r7, #15]
 80134b8:	2b00      	cmp	r3, #0
 80134ba:	d027      	beq.n	801350c <protocol_exec_rt_system+0x5f8>
 80134bc:	f00a fa00 	bl	801d8c0 <state_get>
 80134c0:	4603      	mov	r3, r0
 80134c2:	2b10      	cmp	r3, #16
 80134c4:	d122      	bne.n	801350c <protocol_exec_rt_system+0x5f8>
 80134c6:	4b62      	ldr	r3, [pc, #392]	; (8013650 <protocol_exec_rt_system+0x73c>)
 80134c8:	7e9b      	ldrb	r3, [r3, #26]
 80134ca:	f003 0301 	and.w	r3, r3, #1
 80134ce:	b2db      	uxtb	r3, r3
 80134d0:	2b00      	cmp	r3, #0
 80134d2:	d01b      	beq.n	801350c <protocol_exec_rt_system+0x5f8>
            // Spindle stop override allowed only while in HOLD state.
            // NOTE: Report flag is set in spindle_set_state() when spindle stop is executed.
            if (!sys.override.spindle_stop.value)
 80134d4:	4b5f      	ldr	r3, [pc, #380]	; (8013654 <protocol_exec_rt_system+0x740>)
 80134d6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80134da:	2b00      	cmp	r3, #0
 80134dc:	d107      	bne.n	80134ee <protocol_exec_rt_system+0x5da>
                sys.override.spindle_stop.initiate = On;
 80134de:	4a5d      	ldr	r2, [pc, #372]	; (8013654 <protocol_exec_rt_system+0x740>)
 80134e0:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80134e4:	f043 0302 	orr.w	r3, r3, #2
 80134e8:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 80134ec:	e00e      	b.n	801350c <protocol_exec_rt_system+0x5f8>
            else if (sys.override.spindle_stop.enabled)
 80134ee:	4b59      	ldr	r3, [pc, #356]	; (8013654 <protocol_exec_rt_system+0x740>)
 80134f0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80134f4:	f003 0301 	and.w	r3, r3, #1
 80134f8:	b2db      	uxtb	r3, r3
 80134fa:	2b00      	cmp	r3, #0
 80134fc:	d006      	beq.n	801350c <protocol_exec_rt_system+0x5f8>
                sys.override.spindle_stop.restore = On;
 80134fe:	4a55      	ldr	r2, [pc, #340]	; (8013654 <protocol_exec_rt_system+0x740>)
 8013500:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8013504:	f043 0304 	orr.w	r3, r3, #4
 8013508:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
        }
    }

    if(!sys.override_delay.coolant && (rt_exec = get_coolant_override())) {
 801350c:	4b51      	ldr	r3, [pc, #324]	; (8013654 <protocol_exec_rt_system+0x740>)
 801350e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8013512:	f003 0302 	and.w	r3, r3, #2
 8013516:	b2db      	uxtb	r3, r3
 8013518:	2b00      	cmp	r3, #0
 801351a:	d175      	bne.n	8013608 <protocol_exec_rt_system+0x6f4>
 801351c:	f7fd ff64 	bl	80113e8 <get_coolant_override>
 8013520:	4603      	mov	r3, r0
 8013522:	61fb      	str	r3, [r7, #28]
 8013524:	69fb      	ldr	r3, [r7, #28]
 8013526:	2b00      	cmp	r3, #0
 8013528:	d06e      	beq.n	8013608 <protocol_exec_rt_system+0x6f4>

        coolant_state_t coolant_state = gc_state.modal.coolant;
 801352a:	4b49      	ldr	r3, [pc, #292]	; (8013650 <protocol_exec_rt_system+0x73c>)
 801352c:	7e5b      	ldrb	r3, [r3, #25]
 801352e:	703b      	strb	r3, [r7, #0]

        do {

            switch(rt_exec) {
 8013530:	69fb      	ldr	r3, [r7, #28]
 8013532:	2ba0      	cmp	r3, #160	; 0xa0
 8013534:	d024      	beq.n	8013580 <protocol_exec_rt_system+0x66c>
 8013536:	69fb      	ldr	r3, [r7, #28]
 8013538:	2ba1      	cmp	r3, #161	; 0xa1
 801353a:	d13b      	bne.n	80135b4 <protocol_exec_rt_system+0x6a0>

                case CMD_OVERRIDE_COOLANT_MIST_TOGGLE:
                    if (hal.driver_cap.mist_control && ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD)))) {
 801353c:	4b46      	ldr	r3, [pc, #280]	; (8013658 <protocol_exec_rt_system+0x744>)
 801353e:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8013542:	f003 0301 	and.w	r3, r3, #1
 8013546:	b2db      	uxtb	r3, r3
 8013548:	2b00      	cmp	r3, #0
 801354a:	d03e      	beq.n	80135ca <protocol_exec_rt_system+0x6b6>
 801354c:	f00a f9b8 	bl	801d8c0 <state_get>
 8013550:	4603      	mov	r3, r0
 8013552:	2b00      	cmp	r3, #0
 8013554:	d006      	beq.n	8013564 <protocol_exec_rt_system+0x650>
 8013556:	f00a f9b3 	bl	801d8c0 <state_get>
 801355a:	4603      	mov	r3, r0
 801355c:	f003 0318 	and.w	r3, r3, #24
 8013560:	2b00      	cmp	r3, #0
 8013562:	d032      	beq.n	80135ca <protocol_exec_rt_system+0x6b6>
                        coolant_state.mist = !coolant_state.mist;
 8013564:	783b      	ldrb	r3, [r7, #0]
 8013566:	f003 0302 	and.w	r3, r3, #2
 801356a:	b2db      	uxtb	r3, r3
 801356c:	2b00      	cmp	r3, #0
 801356e:	bf0c      	ite	eq
 8013570:	2301      	moveq	r3, #1
 8013572:	2300      	movne	r3, #0
 8013574:	b2da      	uxtb	r2, r3
 8013576:	783b      	ldrb	r3, [r7, #0]
 8013578:	f362 0341 	bfi	r3, r2, #1, #1
 801357c:	703b      	strb	r3, [r7, #0]
                    }
                    break;
 801357e:	e024      	b.n	80135ca <protocol_exec_rt_system+0x6b6>

                case CMD_OVERRIDE_COOLANT_FLOOD_TOGGLE:
                    if ((state_get() == STATE_IDLE) || (state_get() & (STATE_CYCLE | STATE_HOLD))) {
 8013580:	f00a f99e 	bl	801d8c0 <state_get>
 8013584:	4603      	mov	r3, r0
 8013586:	2b00      	cmp	r3, #0
 8013588:	d006      	beq.n	8013598 <protocol_exec_rt_system+0x684>
 801358a:	f00a f999 	bl	801d8c0 <state_get>
 801358e:	4603      	mov	r3, r0
 8013590:	f003 0318 	and.w	r3, r3, #24
 8013594:	2b00      	cmp	r3, #0
 8013596:	d01a      	beq.n	80135ce <protocol_exec_rt_system+0x6ba>
                        coolant_state.flood = !coolant_state.flood;
 8013598:	783b      	ldrb	r3, [r7, #0]
 801359a:	f003 0301 	and.w	r3, r3, #1
 801359e:	b2db      	uxtb	r3, r3
 80135a0:	2b00      	cmp	r3, #0
 80135a2:	bf0c      	ite	eq
 80135a4:	2301      	moveq	r3, #1
 80135a6:	2300      	movne	r3, #0
 80135a8:	b2da      	uxtb	r2, r3
 80135aa:	783b      	ldrb	r3, [r7, #0]
 80135ac:	f362 0300 	bfi	r3, r2, #0, #1
 80135b0:	703b      	strb	r3, [r7, #0]
                    }
                    break;
 80135b2:	e00c      	b.n	80135ce <protocol_exec_rt_system+0x6ba>

                default:
                    if(grbl.on_unknown_accessory_override)
 80135b4:	4b25      	ldr	r3, [pc, #148]	; (801364c <protocol_exec_rt_system+0x738>)
 80135b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80135b8:	2b00      	cmp	r3, #0
 80135ba:	d00a      	beq.n	80135d2 <protocol_exec_rt_system+0x6be>
                        grbl.on_unknown_accessory_override(rt_exec);
 80135bc:	4b23      	ldr	r3, [pc, #140]	; (801364c <protocol_exec_rt_system+0x738>)
 80135be:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80135c0:	69fa      	ldr	r2, [r7, #28]
 80135c2:	b2d2      	uxtb	r2, r2
 80135c4:	4610      	mov	r0, r2
 80135c6:	4798      	blx	r3
                    break;
 80135c8:	e003      	b.n	80135d2 <protocol_exec_rt_system+0x6be>
                    break;
 80135ca:	bf00      	nop
 80135cc:	e002      	b.n	80135d4 <protocol_exec_rt_system+0x6c0>
                    break;
 80135ce:	bf00      	nop
 80135d0:	e000      	b.n	80135d4 <protocol_exec_rt_system+0x6c0>
                    break;
 80135d2:	bf00      	nop
            }

        } while((rt_exec = get_coolant_override()));
 80135d4:	f7fd ff08 	bl	80113e8 <get_coolant_override>
 80135d8:	4603      	mov	r3, r0
 80135da:	61fb      	str	r3, [r7, #28]
 80135dc:	69fb      	ldr	r3, [r7, #28]
 80135de:	2b00      	cmp	r3, #0
 80135e0:	d1a6      	bne.n	8013530 <protocol_exec_rt_system+0x61c>

      // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
      // run state can be determined by checking the parser state.
        if(coolant_state.value != gc_state.modal.coolant.value) {
 80135e2:	783a      	ldrb	r2, [r7, #0]
 80135e4:	4b1a      	ldr	r3, [pc, #104]	; (8013650 <protocol_exec_rt_system+0x73c>)
 80135e6:	7e5b      	ldrb	r3, [r3, #25]
 80135e8:	429a      	cmp	r2, r3
 80135ea:	d00d      	beq.n	8013608 <protocol_exec_rt_system+0x6f4>
            coolant_set_state(coolant_state); // Report flag set in coolant_set_state().
 80135ec:	7838      	ldrb	r0, [r7, #0]
 80135ee:	f7f2 f835 	bl	800565c <coolant_set_state>
            gc_state.modal.coolant = coolant_state;
 80135f2:	4a17      	ldr	r2, [pc, #92]	; (8013650 <protocol_exec_rt_system+0x73c>)
 80135f4:	783b      	ldrb	r3, [r7, #0]
 80135f6:	7653      	strb	r3, [r2, #25]
            if(grbl.on_override_changed)
 80135f8:	4b14      	ldr	r3, [pc, #80]	; (801364c <protocol_exec_rt_system+0x738>)
 80135fa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80135fc:	2b00      	cmp	r3, #0
 80135fe:	d003      	beq.n	8013608 <protocol_exec_rt_system+0x6f4>
                grbl.on_override_changed(OverrideChanged_CoolantState);
 8013600:	4b12      	ldr	r3, [pc, #72]	; (801364c <protocol_exec_rt_system+0x738>)
 8013602:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8013604:	2000      	movs	r0, #0
 8013606:	4798      	blx	r3
    }

    // End execute overrides.

    // Reload step segment buffer
    if (state_get() & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG))
 8013608:	f00a f95a 	bl	801d8c0 <state_get>
 801360c:	4603      	mov	r3, r0
 801360e:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 8013612:	2b00      	cmp	r3, #0
 8013614:	d001      	beq.n	801361a <protocol_exec_rt_system+0x706>
        st_prep_buffer();
 8013616:	f00b fe63 	bl	801f2e0 <st_prep_buffer>

    return !ABORTED;
 801361a:	4b0e      	ldr	r3, [pc, #56]	; (8013654 <protocol_exec_rt_system+0x740>)
 801361c:	781b      	ldrb	r3, [r3, #0]
 801361e:	f083 0301 	eor.w	r3, r3, #1
 8013622:	b2db      	uxtb	r3, r3
 8013624:	2b00      	cmp	r3, #0
 8013626:	d008      	beq.n	801363a <protocol_exec_rt_system+0x726>
 8013628:	4b0a      	ldr	r3, [pc, #40]	; (8013654 <protocol_exec_rt_system+0x740>)
 801362a:	785b      	ldrb	r3, [r3, #1]
 801362c:	f083 0301 	eor.w	r3, r3, #1
 8013630:	b2db      	uxtb	r3, r3
 8013632:	2b00      	cmp	r3, #0
 8013634:	d001      	beq.n	801363a <protocol_exec_rt_system+0x726>
 8013636:	2301      	movs	r3, #1
 8013638:	e000      	b.n	801363c <protocol_exec_rt_system+0x728>
 801363a:	2300      	movs	r3, #0
 801363c:	f003 0301 	and.w	r3, r3, #1
 8013640:	b2db      	uxtb	r3, r3
}
 8013642:	4618      	mov	r0, r3
 8013644:	3724      	adds	r7, #36	; 0x24
 8013646:	46bd      	mov	sp, r7
 8013648:	bd90      	pop	{r4, r7, pc}
 801364a:	bf00      	nop
 801364c:	20000dd4 	.word	0x20000dd4
 8013650:	20000bb0 	.word	0x20000bb0
 8013654:	20000d3c 	.word	0x20000d3c
 8013658:	20000ed0 	.word	0x20000ed0

0801365c <protocol_exec_rt_suspend>:
// The system will enter this loop, create local variables for suspend tasks, and return to
// whatever function that invoked the suspend, such that Grbl resumes normal operation.
// This function is written in a way to promote custom parking motions. Simply use this as a
// template.
static void protocol_exec_rt_suspend (sys_state_t state)
{
 801365c:	b580      	push	{r7, lr}
 801365e:	b082      	sub	sp, #8
 8013660:	af00      	add	r7, sp, #0
 8013662:	6078      	str	r0, [r7, #4]
    if((sys.blocking_event = state == STATE_SLEEP)) {
 8013664:	687b      	ldr	r3, [r7, #4]
 8013666:	2b80      	cmp	r3, #128	; 0x80
 8013668:	bf0c      	ite	eq
 801366a:	2301      	moveq	r3, #1
 801366c:	2300      	movne	r3, #0
 801366e:	b2da      	uxtb	r2, r3
 8013670:	4b23      	ldr	r3, [pc, #140]	; (8013700 <protocol_exec_rt_suspend+0xa4>)
 8013672:	715a      	strb	r2, [r3, #5]
 8013674:	4b22      	ldr	r3, [pc, #136]	; (8013700 <protocol_exec_rt_suspend+0xa4>)
 8013676:	795b      	ldrb	r3, [r3, #5]
 8013678:	2b00      	cmp	r3, #0
 801367a:	d037      	beq.n	80136ec <protocol_exec_rt_suspend+0x90>
        *line = '\0';
 801367c:	4b21      	ldr	r3, [pc, #132]	; (8013704 <protocol_exec_rt_suspend+0xa8>)
 801367e:	2200      	movs	r2, #0
 8013680:	701a      	strb	r2, [r3, #0]
        char_counter = 0;
 8013682:	4b21      	ldr	r3, [pc, #132]	; (8013708 <protocol_exec_rt_suspend+0xac>)
 8013684:	2200      	movs	r2, #0
 8013686:	601a      	str	r2, [r3, #0]
        hal.stream.reset_read_buffer();
 8013688:	4b20      	ldr	r3, [pc, #128]	; (801370c <protocol_exec_rt_suspend+0xb0>)
 801368a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801368e:	4798      	blx	r3
    }

    while(sys.suspend) {
 8013690:	e02c      	b.n	80136ec <protocol_exec_rt_suspend+0x90>

        if(sys.abort)
 8013692:	4b1b      	ldr	r3, [pc, #108]	; (8013700 <protocol_exec_rt_suspend+0xa4>)
 8013694:	781b      	ldrb	r3, [r3, #0]
 8013696:	2b00      	cmp	r3, #0
 8013698:	d12d      	bne.n	80136f6 <protocol_exec_rt_suspend+0x9a>
            return;

        if(sys.blocking_event)
 801369a:	4b19      	ldr	r3, [pc, #100]	; (8013700 <protocol_exec_rt_suspend+0xa4>)
 801369c:	795b      	ldrb	r3, [r3, #5]
 801369e:	2b00      	cmp	r3, #0
 80136a0:	d001      	beq.n	80136a6 <protocol_exec_rt_suspend+0x4a>
            protocol_poll_cmd();
 80136a2:	f7ff fba5 	bl	8012df0 <protocol_poll_cmd>

        // Handle spindle overrides during suspend
        state_suspend_manager();
 80136a6:	f00a fae5 	bl	801dc74 <state_suspend_manager>

        // If door closed keep issuing door closed requests until resumed
        if(state_get() == STATE_SAFETY_DOOR && !hal.control.get_state().safety_door_ajar)
 80136aa:	f00a f909 	bl	801d8c0 <state_get>
 80136ae:	4603      	mov	r3, r0
 80136b0:	2b40      	cmp	r3, #64	; 0x40
 80136b2:	d10f      	bne.n	80136d4 <protocol_exec_rt_suspend+0x78>
 80136b4:	4b15      	ldr	r3, [pc, #84]	; (801370c <protocol_exec_rt_suspend+0xb0>)
 80136b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80136b8:	4798      	blx	r3
 80136ba:	4603      	mov	r3, r0
 80136bc:	b2db      	uxtb	r3, r3
 80136be:	f003 0308 	and.w	r3, r3, #8
 80136c2:	b2db      	uxtb	r3, r3
 80136c4:	2b00      	cmp	r3, #0
 80136c6:	d105      	bne.n	80136d4 <protocol_exec_rt_suspend+0x78>
            system_set_exec_state_flag(EXEC_DOOR_CLOSED);
 80136c8:	4b10      	ldr	r3, [pc, #64]	; (801370c <protocol_exec_rt_suspend+0xb0>)
 80136ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80136cc:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80136d0:	480f      	ldr	r0, [pc, #60]	; (8013710 <protocol_exec_rt_suspend+0xb4>)
 80136d2:	4798      	blx	r3

        // Check for sleep conditions and execute auto-park, if timeout duration elapses.
        // Sleep is valid for both hold and door states, if the spindle or coolant are on or
        // set to be re-enabled.
        if(settings.flags.sleep_enable)
 80136d4:	4b0f      	ldr	r3, [pc, #60]	; (8013714 <protocol_exec_rt_suspend+0xb8>)
 80136d6:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80136da:	f003 0308 	and.w	r3, r3, #8
 80136de:	b2db      	uxtb	r3, r3
 80136e0:	2b00      	cmp	r3, #0
 80136e2:	d001      	beq.n	80136e8 <protocol_exec_rt_suspend+0x8c>
            sleep_check();
 80136e4:	f008 fd0c 	bl	801c100 <sleep_check>

        protocol_exec_rt_system();
 80136e8:	f7ff fc14 	bl	8012f14 <protocol_exec_rt_system>
    while(sys.suspend) {
 80136ec:	4b04      	ldr	r3, [pc, #16]	; (8013700 <protocol_exec_rt_suspend+0xa4>)
 80136ee:	789b      	ldrb	r3, [r3, #2]
 80136f0:	2b00      	cmp	r3, #0
 80136f2:	d1ce      	bne.n	8013692 <protocol_exec_rt_suspend+0x36>
 80136f4:	e000      	b.n	80136f8 <protocol_exec_rt_suspend+0x9c>
            return;
 80136f6:	bf00      	nop
    }
}
 80136f8:	3708      	adds	r7, #8
 80136fa:	46bd      	mov	sp, r7
 80136fc:	bd80      	pop	{r7, pc}
 80136fe:	bf00      	nop
 8013700:	20000d3c 	.word	0x20000d3c
 8013704:	200011b0 	.word	0x200011b0
 8013708:	200011ac 	.word	0x200011ac
 801370c:	20000ed0 	.word	0x20000ed0
 8013710:	20000d84 	.word	0x20000d84
 8013714:	2000147c 	.word	0x2000147c

08013718 <protocol_enqueue_realtime_command>:
// Pick off (drop) real-time command characters from input stream.
// These characters are not passed into the main buffer,
// but rather sets system state flag bits for later execution by protocol_exec_rt_system().
// Called from input stream interrupt handler.
ISR_CODE bool ISR_FUNC(protocol_enqueue_realtime_command)(char c)
{
 8013718:	b590      	push	{r4, r7, lr}
 801371a:	b085      	sub	sp, #20
 801371c:	af00      	add	r7, sp, #0
 801371e:	4603      	mov	r3, r0
 8013720:	71fb      	strb	r3, [r7, #7]
    static bool esc = false;

    bool drop = false;
 8013722:	2300      	movs	r3, #0
 8013724:	73fb      	strb	r3, [r7, #15]

    // 1. Process characters in the ranges 0x - 1x and 8x-Ax
    // Characters with functions assigned are always acted upon even when the input stream
    // is redirected to a non-interactive stream such as from a SD card.

    switch ((unsigned char)c) {
 8013726:	79fb      	ldrb	r3, [r7, #7]
 8013728:	3b03      	subs	r3, #3
 801372a:	2ba1      	cmp	r3, #161	; 0xa1
 801372c:	f200 829c 	bhi.w	8013c68 <protocol_enqueue_realtime_command+0x550>
 8013730:	a201      	add	r2, pc, #4	; (adr r2, 8013738 <protocol_enqueue_realtime_command+0x20>)
 8013732:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013736:	bf00      	nop
 8013738:	08013a23 	.word	0x08013a23
 801373c:	08013c69 	.word	0x08013c69
 8013740:	08013a7f 	.word	0x08013a7f
 8013744:	08013c69 	.word	0x08013c69
 8013748:	08013c69 	.word	0x08013c69
 801374c:	08013c69 	.word	0x08013c69
 8013750:	08013c69 	.word	0x08013c69
 8013754:	08013cad 	.word	0x08013cad
 8013758:	08013c69 	.word	0x08013c69
 801375c:	08013c69 	.word	0x08013c69
 8013760:	08013cad 	.word	0x08013cad
 8013764:	08013c69 	.word	0x08013c69
 8013768:	08013c69 	.word	0x08013c69
 801376c:	08013c69 	.word	0x08013c69
 8013770:	08013c69 	.word	0x08013c69
 8013774:	08013c69 	.word	0x08013c69
 8013778:	08013c69 	.word	0x08013c69
 801377c:	08013c25 	.word	0x08013c25
 8013780:	08013c69 	.word	0x08013c69
 8013784:	08013c69 	.word	0x08013c69
 8013788:	08013c69 	.word	0x08013c69
 801378c:	08013a05 	.word	0x08013a05
 8013790:	080139e7 	.word	0x080139e7
 8013794:	08013c69 	.word	0x08013c69
 8013798:	08013c69 	.word	0x08013c69
 801379c:	08013c69 	.word	0x08013c69
 80137a0:	08013c69 	.word	0x08013c69
 80137a4:	08013c69 	.word	0x08013c69
 80137a8:	08013c69 	.word	0x08013c69
 80137ac:	08013c69 	.word	0x08013c69
 80137b0:	08013c69 	.word	0x08013c69
 80137b4:	08013c69 	.word	0x08013c69
 80137b8:	08013c69 	.word	0x08013c69
 80137bc:	080139c1 	.word	0x080139c1
 80137c0:	08013c69 	.word	0x08013c69
 80137c4:	08013c69 	.word	0x08013c69
 80137c8:	08013c69 	.word	0x08013c69
 80137cc:	08013c69 	.word	0x08013c69
 80137d0:	08013c69 	.word	0x08013c69
 80137d4:	08013c69 	.word	0x08013c69
 80137d8:	08013c69 	.word	0x08013c69
 80137dc:	08013c69 	.word	0x08013c69
 80137e0:	08013c69 	.word	0x08013c69
 80137e4:	08013c69 	.word	0x08013c69
 80137e8:	08013c69 	.word	0x08013c69
 80137ec:	08013c69 	.word	0x08013c69
 80137f0:	08013c69 	.word	0x08013c69
 80137f4:	08013c69 	.word	0x08013c69
 80137f8:	08013c69 	.word	0x08013c69
 80137fc:	08013c69 	.word	0x08013c69
 8013800:	08013c69 	.word	0x08013c69
 8013804:	08013c69 	.word	0x08013c69
 8013808:	08013c69 	.word	0x08013c69
 801380c:	08013c69 	.word	0x08013c69
 8013810:	08013c69 	.word	0x08013c69
 8013814:	08013c69 	.word	0x08013c69
 8013818:	08013c69 	.word	0x08013c69
 801381c:	08013c69 	.word	0x08013c69
 8013820:	08013c69 	.word	0x08013c69
 8013824:	08013c69 	.word	0x08013c69
 8013828:	08013c69 	.word	0x08013c69
 801382c:	08013c69 	.word	0x08013c69
 8013830:	08013c69 	.word	0x08013c69
 8013834:	08013c69 	.word	0x08013c69
 8013838:	08013c69 	.word	0x08013c69
 801383c:	08013c69 	.word	0x08013c69
 8013840:	08013c69 	.word	0x08013c69
 8013844:	08013c69 	.word	0x08013c69
 8013848:	08013c69 	.word	0x08013c69
 801384c:	08013c69 	.word	0x08013c69
 8013850:	08013c69 	.word	0x08013c69
 8013854:	08013c69 	.word	0x08013c69
 8013858:	08013c69 	.word	0x08013c69
 801385c:	08013c69 	.word	0x08013c69
 8013860:	08013c69 	.word	0x08013c69
 8013864:	08013c69 	.word	0x08013c69
 8013868:	08013c69 	.word	0x08013c69
 801386c:	08013c69 	.word	0x08013c69
 8013870:	08013c69 	.word	0x08013c69
 8013874:	08013c69 	.word	0x08013c69
 8013878:	08013c69 	.word	0x08013c69
 801387c:	08013c69 	.word	0x08013c69
 8013880:	08013c69 	.word	0x08013c69
 8013884:	08013c69 	.word	0x08013c69
 8013888:	08013c69 	.word	0x08013c69
 801388c:	08013c69 	.word	0x08013c69
 8013890:	08013c69 	.word	0x08013c69
 8013894:	08013c69 	.word	0x08013c69
 8013898:	08013c69 	.word	0x08013c69
 801389c:	08013c69 	.word	0x08013c69
 80138a0:	08013c69 	.word	0x08013c69
 80138a4:	08013c69 	.word	0x08013c69
 80138a8:	08013c69 	.word	0x08013c69
 80138ac:	08013c69 	.word	0x08013c69
 80138b0:	08013c69 	.word	0x08013c69
 80138b4:	08013c69 	.word	0x08013c69
 80138b8:	08013c69 	.word	0x08013c69
 80138bc:	08013c69 	.word	0x08013c69
 80138c0:	08013c69 	.word	0x08013c69
 80138c4:	08013c69 	.word	0x08013c69
 80138c8:	08013c69 	.word	0x08013c69
 80138cc:	08013c69 	.word	0x08013c69
 80138d0:	08013c69 	.word	0x08013c69
 80138d4:	08013c69 	.word	0x08013c69
 80138d8:	08013c69 	.word	0x08013c69
 80138dc:	08013c69 	.word	0x08013c69
 80138e0:	08013c69 	.word	0x08013c69
 80138e4:	08013c69 	.word	0x08013c69
 80138e8:	08013c69 	.word	0x08013c69
 80138ec:	08013c69 	.word	0x08013c69
 80138f0:	08013c69 	.word	0x08013c69
 80138f4:	08013c69 	.word	0x08013c69
 80138f8:	08013c69 	.word	0x08013c69
 80138fc:	08013c69 	.word	0x08013c69
 8013900:	08013c69 	.word	0x08013c69
 8013904:	08013c69 	.word	0x08013c69
 8013908:	08013c69 	.word	0x08013c69
 801390c:	08013c69 	.word	0x08013c69
 8013910:	08013c69 	.word	0x08013c69
 8013914:	08013c69 	.word	0x08013c69
 8013918:	08013c69 	.word	0x08013c69
 801391c:	08013c69 	.word	0x08013c69
 8013920:	08013c69 	.word	0x08013c69
 8013924:	08013c69 	.word	0x08013c69
 8013928:	08013c69 	.word	0x08013c69
 801392c:	08013a7f 	.word	0x08013a7f
 8013930:	08013a9d 	.word	0x08013a9d
 8013934:	08013ab5 	.word	0x08013ab5
 8013938:	08013b29 	.word	0x08013b29
 801393c:	08013ac5 	.word	0x08013ac5
 8013940:	08013ae1 	.word	0x08013ae1
 8013944:	08013c69 	.word	0x08013c69
 8013948:	08013a37 	.word	0x08013a37
 801394c:	08013b51 	.word	0x08013b51
 8013950:	08013b83 	.word	0x08013b83
 8013954:	08013c17 	.word	0x08013c17
 8013958:	08013bc1 	.word	0x08013bc1
 801395c:	08013bd3 	.word	0x08013bd3
 8013960:	08013c69 	.word	0x08013c69
 8013964:	08013c69 	.word	0x08013c69
 8013968:	08013c69 	.word	0x08013c69
 801396c:	08013bfb 	.word	0x08013bfb
 8013970:	08013bfb 	.word	0x08013bfb
 8013974:	08013bfb 	.word	0x08013bfb
 8013978:	08013bfb 	.word	0x08013bfb
 801397c:	08013bfb 	.word	0x08013bfb
 8013980:	08013bfb 	.word	0x08013bfb
 8013984:	08013bfb 	.word	0x08013bfb
 8013988:	08013bfb 	.word	0x08013bfb
 801398c:	08013c69 	.word	0x08013c69
 8013990:	08013c09 	.word	0x08013c09
 8013994:	08013c09 	.word	0x08013c09
 8013998:	08013c09 	.word	0x08013c09
 801399c:	08013c09 	.word	0x08013c09
 80139a0:	08013c09 	.word	0x08013c09
 80139a4:	08013c09 	.word	0x08013c09
 80139a8:	08013c69 	.word	0x08013c69
 80139ac:	08013c17 	.word	0x08013c17
 80139b0:	08013c17 	.word	0x08013c17
 80139b4:	08013baf 	.word	0x08013baf
 80139b8:	08013c69 	.word	0x08013c69
 80139bc:	08013b3b 	.word	0x08013b3b
        case '\n':
        case '\r':
            break;

        case '$':
            if(char_counter == 0)
 80139c0:	4b9f      	ldr	r3, [pc, #636]	; (8013c40 <protocol_enqueue_realtime_command+0x528>)
 80139c2:	681b      	ldr	r3, [r3, #0]
 80139c4:	2b00      	cmp	r3, #0
 80139c6:	f040 8173 	bne.w	8013cb0 <protocol_enqueue_realtime_command+0x598>
                keep_rt_commands = !settings.flags.legacy_rt_commands;
 80139ca:	4b9e      	ldr	r3, [pc, #632]	; (8013c44 <protocol_enqueue_realtime_command+0x52c>)
 80139cc:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80139d0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80139d4:	b2db      	uxtb	r3, r3
 80139d6:	2b00      	cmp	r3, #0
 80139d8:	bf0c      	ite	eq
 80139da:	2301      	moveq	r3, #1
 80139dc:	2300      	movne	r3, #0
 80139de:	b2da      	uxtb	r2, r3
 80139e0:	4b99      	ldr	r3, [pc, #612]	; (8013c48 <protocol_enqueue_realtime_command+0x530>)
 80139e2:	701a      	strb	r2, [r3, #0]
            break;
 80139e4:	e164      	b.n	8013cb0 <protocol_enqueue_realtime_command+0x598>

        case CMD_STOP:
            system_set_exec_state_flag(EXEC_STOP);
 80139e6:	4b99      	ldr	r3, [pc, #612]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 80139e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80139ea:	2110      	movs	r1, #16
 80139ec:	4898      	ldr	r0, [pc, #608]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 80139ee:	4798      	blx	r3
            char_counter = 0;
 80139f0:	4b93      	ldr	r3, [pc, #588]	; (8013c40 <protocol_enqueue_realtime_command+0x528>)
 80139f2:	2200      	movs	r2, #0
 80139f4:	601a      	str	r2, [r3, #0]
            hal.stream.cancel_read_buffer();
 80139f6:	4b95      	ldr	r3, [pc, #596]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 80139f8:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 80139fc:	4798      	blx	r3
            drop = true;
 80139fe:	2301      	movs	r3, #1
 8013a00:	73fb      	strb	r3, [r7, #15]
            break;
 8013a02:	e168      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_RESET: // Call motion control reset routine.
            if(!hal.control.get_state().e_stop)
 8013a04:	4b91      	ldr	r3, [pc, #580]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013a06:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8013a08:	4798      	blx	r3
 8013a0a:	4603      	mov	r3, r0
 8013a0c:	b2db      	uxtb	r3, r3
 8013a0e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013a12:	b2db      	uxtb	r3, r3
 8013a14:	2b00      	cmp	r3, #0
 8013a16:	d101      	bne.n	8013a1c <protocol_enqueue_realtime_command+0x304>
                mc_reset();
 8013a18:	f7fb fe66 	bl	800f6e8 <mc_reset>
            drop = true;
 8013a1c:	2301      	movs	r3, #1
 8013a1e:	73fb      	strb	r3, [r7, #15]
            break;
 8013a20:	e159      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

#if COMPATIBILITY_LEVEL == 0
        case CMD_EXIT: // Call motion control reset routine.
            mc_reset();
 8013a22:	f7fb fe61 	bl	800f6e8 <mc_reset>
            sys.flags.exit = On;
 8013a26:	4a8b      	ldr	r2, [pc, #556]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013a28:	7d93      	ldrb	r3, [r2, #22]
 8013a2a:	f043 0308 	orr.w	r3, r3, #8
 8013a2e:	7593      	strb	r3, [r2, #22]
            drop = true;
 8013a30:	2301      	movs	r3, #1
 8013a32:	73fb      	strb	r3, [r7, #15]
            break;
 8013a34:	e14f      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_STATUS_REPORT_ALL: // Add all statuses to report
            {
                report_tracking_flags_t report;

                report.value = (uint32_t)Report_All;
 8013a36:	4b88      	ldr	r3, [pc, #544]	; (8013c58 <protocol_enqueue_realtime_command+0x540>)
 8013a38:	60bb      	str	r3, [r7, #8]
                report.tool_offset = sys.report.tool_offset;
 8013a3a:	4b86      	ldr	r3, [pc, #536]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013a3c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8013a40:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8013a44:	b2da      	uxtb	r2, r3
 8013a46:	7a7b      	ldrb	r3, [r7, #9]
 8013a48:	f362 0382 	bfi	r3, r2, #2, #1
 8013a4c:	727b      	strb	r3, [r7, #9]
                report.m66result = sys.var5399 > -2;
 8013a4e:	4b81      	ldr	r3, [pc, #516]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013a50:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8013a52:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013a56:	bfac      	ite	ge
 8013a58:	2301      	movge	r3, #1
 8013a5a:	2300      	movlt	r3, #0
 8013a5c:	b2da      	uxtb	r2, r3
 8013a5e:	7a7b      	ldrb	r3, [r7, #9]
 8013a60:	f362 03c3 	bfi	r3, r2, #3, #1
 8013a64:	727b      	strb	r3, [r7, #9]

                system_add_rt_report((report_tracking_t)report.value);
 8013a66:	68bb      	ldr	r3, [r7, #8]
 8013a68:	4618      	mov	r0, r3
 8013a6a:	f00e fa97 	bl	8021f9c <system_add_rt_report>
            }
            system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8013a6e:	4b77      	ldr	r3, [pc, #476]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013a70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013a72:	2101      	movs	r1, #1
 8013a74:	4876      	ldr	r0, [pc, #472]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013a76:	4798      	blx	r3
            drop = true;
 8013a78:	2301      	movs	r3, #1
 8013a7a:	73fb      	strb	r3, [r7, #15]
            break;
 8013a7c:	e12b      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_STATUS_REPORT:
        case 0x05:
            if(!sys.flags.auto_reporting)
 8013a7e:	4b75      	ldr	r3, [pc, #468]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013a80:	7ddb      	ldrb	r3, [r3, #23]
 8013a82:	f003 0302 	and.w	r3, r3, #2
 8013a86:	b2db      	uxtb	r3, r3
 8013a88:	2b00      	cmp	r3, #0
 8013a8a:	d104      	bne.n	8013a96 <protocol_enqueue_realtime_command+0x37e>
                system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8013a8c:	4b6f      	ldr	r3, [pc, #444]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013a8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013a90:	2101      	movs	r1, #1
 8013a92:	486f      	ldr	r0, [pc, #444]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013a94:	4798      	blx	r3
            drop = true;
 8013a96:	2301      	movs	r3, #1
 8013a98:	73fb      	strb	r3, [r7, #15]
            break;
 8013a9a:	e11c      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_CYCLE_START:
            system_set_exec_state_flag(EXEC_CYCLE_START);
 8013a9c:	4b6b      	ldr	r3, [pc, #428]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013a9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013aa0:	2102      	movs	r1, #2
 8013aa2:	486b      	ldr	r0, [pc, #428]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013aa4:	4798      	blx	r3
            // Cancel any pending tool change
            gc_state.tool_change = false;
 8013aa6:	4b6d      	ldr	r3, [pc, #436]	; (8013c5c <protocol_enqueue_realtime_command+0x544>)
 8013aa8:	2200      	movs	r2, #0
 8013aaa:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
            drop = true;
 8013aae:	2301      	movs	r3, #1
 8013ab0:	73fb      	strb	r3, [r7, #15]
            break;
 8013ab2:	e110      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_FEED_HOLD:
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 8013ab4:	4b65      	ldr	r3, [pc, #404]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013ab6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013ab8:	2108      	movs	r1, #8
 8013aba:	4865      	ldr	r0, [pc, #404]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013abc:	4798      	blx	r3
            drop = true;
 8013abe:	2301      	movs	r3, #1
 8013ac0:	73fb      	strb	r3, [r7, #15]
            break;
 8013ac2:	e108      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_SAFETY_DOOR:
            if(state_get() != STATE_SAFETY_DOOR) {
 8013ac4:	f009 fefc 	bl	801d8c0 <state_get>
 8013ac8:	4603      	mov	r3, r0
 8013aca:	2b40      	cmp	r3, #64	; 0x40
 8013acc:	f000 80f2 	beq.w	8013cb4 <protocol_enqueue_realtime_command+0x59c>
                system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8013ad0:	4b5e      	ldr	r3, [pc, #376]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013ad2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013ad4:	2140      	movs	r1, #64	; 0x40
 8013ad6:	485e      	ldr	r0, [pc, #376]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013ad8:	4798      	blx	r3
                drop = true;
 8013ada:	2301      	movs	r3, #1
 8013adc:	73fb      	strb	r3, [r7, #15]
            }
            break;
 8013ade:	e0e9      	b.n	8013cb4 <protocol_enqueue_realtime_command+0x59c>

        case CMD_JOG_CANCEL:
            char_counter = 0;
 8013ae0:	4b57      	ldr	r3, [pc, #348]	; (8013c40 <protocol_enqueue_realtime_command+0x528>)
 8013ae2:	2200      	movs	r2, #0
 8013ae4:	601a      	str	r2, [r3, #0]
            drop = true;
 8013ae6:	2301      	movs	r3, #1
 8013ae8:	73fb      	strb	r3, [r7, #15]
            hal.stream.cancel_read_buffer();
 8013aea:	4b58      	ldr	r3, [pc, #352]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013aec:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8013af0:	4798      	blx	r3
#ifdef KINEMATICS_API // needed when kinematics algorithm segments long jog distances (as it blocks reading from input stream)
            if (state_get() & STATE_JOG) // Block all other states from invoking motion cancel.
 8013af2:	f009 fee5 	bl	801d8c0 <state_get>
 8013af6:	4603      	mov	r3, r0
 8013af8:	f003 0320 	and.w	r3, r3, #32
 8013afc:	2b00      	cmp	r3, #0
 8013afe:	d004      	beq.n	8013b0a <protocol_enqueue_realtime_command+0x3f2>
                system_set_exec_state_flag(EXEC_MOTION_CANCEL);
 8013b00:	4b52      	ldr	r3, [pc, #328]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013b04:	2180      	movs	r1, #128	; 0x80
 8013b06:	4852      	ldr	r0, [pc, #328]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013b08:	4798      	blx	r3
#endif
            if(grbl.on_jog_cancel)
 8013b0a:	4b55      	ldr	r3, [pc, #340]	; (8013c60 <protocol_enqueue_realtime_command+0x548>)
 8013b0c:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8013b10:	2b00      	cmp	r3, #0
 8013b12:	f000 80d1 	beq.w	8013cb8 <protocol_enqueue_realtime_command+0x5a0>
                grbl.on_jog_cancel(state_get());
 8013b16:	4b52      	ldr	r3, [pc, #328]	; (8013c60 <protocol_enqueue_realtime_command+0x548>)
 8013b18:	f8d3 40bc 	ldr.w	r4, [r3, #188]	; 0xbc
 8013b1c:	f009 fed0 	bl	801d8c0 <state_get>
 8013b20:	4603      	mov	r3, r0
 8013b22:	4618      	mov	r0, r3
 8013b24:	47a0      	blx	r4
            break;
 8013b26:	e0c7      	b.n	8013cb8 <protocol_enqueue_realtime_command+0x5a0>

        case CMD_GCODE_REPORT:
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 8013b28:	4b48      	ldr	r3, [pc, #288]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013b2c:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8013b30:	4847      	ldr	r0, [pc, #284]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013b32:	4798      	blx	r3
            drop = true;
 8013b34:	2301      	movs	r3, #1
 8013b36:	73fb      	strb	r3, [r7, #15]
            break;
 8013b38:	e0cd      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_PROBE_CONNECTED_TOGGLE:
            if(hal.probe.connected_toggle)
 8013b3a:	4b44      	ldr	r3, [pc, #272]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b3c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8013b40:	2b00      	cmp	r3, #0
 8013b42:	f000 80bb 	beq.w	8013cbc <protocol_enqueue_realtime_command+0x5a4>
                hal.probe.connected_toggle();
 8013b46:	4b41      	ldr	r3, [pc, #260]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b48:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8013b4c:	4798      	blx	r3
            break;
 8013b4e:	e0b5      	b.n	8013cbc <protocol_enqueue_realtime_command+0x5a4>

        case CMD_OPTIONAL_STOP_TOGGLE:
            if(!hal.signals_cap.stop_disable) // Not available as realtime command if HAL supports physical switch
 8013b50:	4b3e      	ldr	r3, [pc, #248]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b52:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8013b56:	f003 0320 	and.w	r3, r3, #32
 8013b5a:	b2db      	uxtb	r3, r3
 8013b5c:	2b00      	cmp	r3, #0
 8013b5e:	f040 80af 	bne.w	8013cc0 <protocol_enqueue_realtime_command+0x5a8>
                sys.flags.optional_stop_disable = !sys.flags.optional_stop_disable;
 8013b62:	4b3c      	ldr	r3, [pc, #240]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013b64:	7d9b      	ldrb	r3, [r3, #22]
 8013b66:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013b6a:	b2db      	uxtb	r3, r3
 8013b6c:	2b00      	cmp	r3, #0
 8013b6e:	bf0c      	ite	eq
 8013b70:	2301      	moveq	r3, #1
 8013b72:	2300      	movne	r3, #0
 8013b74:	b2d9      	uxtb	r1, r3
 8013b76:	4a37      	ldr	r2, [pc, #220]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013b78:	7d93      	ldrb	r3, [r2, #22]
 8013b7a:	f361 1386 	bfi	r3, r1, #6, #1
 8013b7e:	7593      	strb	r3, [r2, #22]
            break;
 8013b80:	e09e      	b.n	8013cc0 <protocol_enqueue_realtime_command+0x5a8>

        case CMD_SINGLE_BLOCK_TOGGLE:
            if(!hal.signals_cap.single_block) // Not available as realtime command if HAL supports physical switch
 8013b82:	4b32      	ldr	r3, [pc, #200]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013b84:	f893 31ad 	ldrb.w	r3, [r3, #429]	; 0x1ad
 8013b88:	f003 0308 	and.w	r3, r3, #8
 8013b8c:	b2db      	uxtb	r3, r3
 8013b8e:	2b00      	cmp	r3, #0
 8013b90:	f040 8098 	bne.w	8013cc4 <protocol_enqueue_realtime_command+0x5ac>
                sys.flags.single_block = !sys.flags.single_block;
 8013b94:	4b2f      	ldr	r3, [pc, #188]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013b96:	7d9b      	ldrb	r3, [r3, #22]
 8013b98:	b25b      	sxtb	r3, r3
 8013b9a:	43db      	mvns	r3, r3
 8013b9c:	b2db      	uxtb	r3, r3
 8013b9e:	09db      	lsrs	r3, r3, #7
 8013ba0:	b2d9      	uxtb	r1, r3
 8013ba2:	4a2c      	ldr	r2, [pc, #176]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013ba4:	7d93      	ldrb	r3, [r2, #22]
 8013ba6:	f361 13c7 	bfi	r3, r1, #7, #1
 8013baa:	7593      	strb	r3, [r2, #22]
            break;
 8013bac:	e08a      	b.n	8013cc4 <protocol_enqueue_realtime_command+0x5ac>

        case CMD_PID_REPORT:
            system_set_exec_state_flag(EXEC_PID_REPORT);
 8013bae:	4b27      	ldr	r3, [pc, #156]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013bb0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013bb2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8013bb6:	4826      	ldr	r0, [pc, #152]	; (8013c50 <protocol_enqueue_realtime_command+0x538>)
 8013bb8:	4798      	blx	r3
            drop = true;
 8013bba:	2301      	movs	r3, #1
 8013bbc:	73fb      	strb	r3, [r7, #15]
            break;
 8013bbe:	e08a      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_MPG_MODE_TOGGLE:           // Switch off MPG mode
            if(hal.stream.type == StreamType_MPG)
 8013bc0:	4b22      	ldr	r3, [pc, #136]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013bc2:	f893 30a8 	ldrb.w	r3, [r3, #168]	; 0xa8
 8013bc6:	2b01      	cmp	r3, #1
 8013bc8:	d17e      	bne.n	8013cc8 <protocol_enqueue_realtime_command+0x5b0>
                stream_mpg_enable(false);
 8013bca:	2000      	movs	r0, #0
 8013bcc:	f00c fe36 	bl	802083c <stream_mpg_enable>
            break;
 8013bd0:	e07a      	b.n	8013cc8 <protocol_enqueue_realtime_command+0x5b0>

        case CMD_AUTO_REPORTING_TOGGLE:
            if(settings.report_interval)
 8013bd2:	4b1c      	ldr	r3, [pc, #112]	; (8013c44 <protocol_enqueue_realtime_command+0x52c>)
 8013bd4:	8a9b      	ldrh	r3, [r3, #20]
 8013bd6:	2b00      	cmp	r3, #0
 8013bd8:	d078      	beq.n	8013ccc <protocol_enqueue_realtime_command+0x5b4>
                sys.flags.auto_reporting = !sys.flags.auto_reporting;
 8013bda:	4b1e      	ldr	r3, [pc, #120]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013bdc:	7ddb      	ldrb	r3, [r3, #23]
 8013bde:	f003 0302 	and.w	r3, r3, #2
 8013be2:	b2db      	uxtb	r3, r3
 8013be4:	2b00      	cmp	r3, #0
 8013be6:	bf0c      	ite	eq
 8013be8:	2301      	moveq	r3, #1
 8013bea:	2300      	movne	r3, #0
 8013bec:	b2d9      	uxtb	r1, r3
 8013bee:	4a19      	ldr	r2, [pc, #100]	; (8013c54 <protocol_enqueue_realtime_command+0x53c>)
 8013bf0:	7dd3      	ldrb	r3, [r2, #23]
 8013bf2:	f361 0341 	bfi	r3, r1, #1, #1
 8013bf6:	75d3      	strb	r3, [r2, #23]
            break;
 8013bf8:	e068      	b.n	8013ccc <protocol_enqueue_realtime_command+0x5b4>
        case CMD_OVERRIDE_FEED_FINE_PLUS:
        case CMD_OVERRIDE_FEED_FINE_MINUS:
        case CMD_OVERRIDE_RAPID_RESET:
        case CMD_OVERRIDE_RAPID_MEDIUM:
        case CMD_OVERRIDE_RAPID_LOW:
            drop = true;
 8013bfa:	2301      	movs	r3, #1
 8013bfc:	73fb      	strb	r3, [r7, #15]
            enqueue_feed_override(c);
 8013bfe:	79fb      	ldrb	r3, [r7, #7]
 8013c00:	4618      	mov	r0, r3
 8013c02:	f7fd fb4d 	bl	80112a0 <enqueue_feed_override>
            break;
 8013c06:	e066      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
        case CMD_OVERRIDE_SPINDLE_COARSE_PLUS:
        case CMD_OVERRIDE_SPINDLE_COARSE_MINUS:
        case CMD_OVERRIDE_SPINDLE_FINE_PLUS:
        case CMD_OVERRIDE_SPINDLE_FINE_MINUS:
        case CMD_OVERRIDE_SPINDLE_STOP:
            drop = true;
 8013c08:	2301      	movs	r3, #1
 8013c0a:	73fb      	strb	r3, [r7, #15]
            enqueue_spindle_override((uint8_t)c);
 8013c0c:	79fb      	ldrb	r3, [r7, #7]
 8013c0e:	4618      	mov	r0, r3
 8013c10:	f7fd fb88 	bl	8011324 <enqueue_spindle_override>
            break;
 8013c14:	e05f      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_OVERRIDE_COOLANT_FLOOD_TOGGLE:
        case CMD_OVERRIDE_COOLANT_MIST_TOGGLE:
        case CMD_OVERRIDE_FAN0_TOGGLE:
            drop = true;
 8013c16:	2301      	movs	r3, #1
 8013c18:	73fb      	strb	r3, [r7, #15]
            enqueue_coolant_override((uint8_t)c);
 8013c1a:	79fb      	ldrb	r3, [r7, #7]
 8013c1c:	4618      	mov	r0, r3
 8013c1e:	f7fd fbc3 	bl	80113a8 <enqueue_coolant_override>
            break;
 8013c22:	e058      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>

        case CMD_REBOOT:
            if(esc && hal.reboot)
 8013c24:	4b0f      	ldr	r3, [pc, #60]	; (8013c64 <protocol_enqueue_realtime_command+0x54c>)
 8013c26:	781b      	ldrb	r3, [r3, #0]
 8013c28:	2b00      	cmp	r3, #0
 8013c2a:	d051      	beq.n	8013cd0 <protocol_enqueue_realtime_command+0x5b8>
 8013c2c:	4b07      	ldr	r3, [pc, #28]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013c2e:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8013c32:	2b00      	cmp	r3, #0
 8013c34:	d04c      	beq.n	8013cd0 <protocol_enqueue_realtime_command+0x5b8>
                hal.reboot(); // Force MCU reboot. This call should never return.
 8013c36:	4b05      	ldr	r3, [pc, #20]	; (8013c4c <protocol_enqueue_realtime_command+0x534>)
 8013c38:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8013c3c:	4798      	blx	r3
            break;
 8013c3e:	e047      	b.n	8013cd0 <protocol_enqueue_realtime_command+0x5b8>
 8013c40:	200011ac 	.word	0x200011ac
 8013c44:	2000147c 	.word	0x2000147c
 8013c48:	200013b5 	.word	0x200013b5
 8013c4c:	20000ed0 	.word	0x20000ed0
 8013c50:	20000d84 	.word	0x20000d84
 8013c54:	20000d3c 	.word	0x20000d3c
 8013c58:	8001ffff 	.word	0x8001ffff
 8013c5c:	20000bb0 	.word	0x20000bb0
 8013c60:	20000dd4 	.word	0x20000dd4
 8013c64:	20001400 	.word	0x20001400

        default:
            if((c < ' ' && c != ASCII_BS) || (c > ASCII_DEL && c <= 0xBF))
 8013c68:	79fb      	ldrb	r3, [r7, #7]
 8013c6a:	2b1f      	cmp	r3, #31
 8013c6c:	d802      	bhi.n	8013c74 <protocol_enqueue_realtime_command+0x55c>
 8013c6e:	79fb      	ldrb	r3, [r7, #7]
 8013c70:	2b08      	cmp	r3, #8
 8013c72:	d106      	bne.n	8013c82 <protocol_enqueue_realtime_command+0x56a>
 8013c74:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8013c78:	2b00      	cmp	r3, #0
 8013c7a:	da2b      	bge.n	8013cd4 <protocol_enqueue_realtime_command+0x5bc>
 8013c7c:	79fb      	ldrb	r3, [r7, #7]
 8013c7e:	2bbf      	cmp	r3, #191	; 0xbf
 8013c80:	d828      	bhi.n	8013cd4 <protocol_enqueue_realtime_command+0x5bc>
                drop = grbl.on_unknown_realtime_cmd == NULL || grbl.on_unknown_realtime_cmd(c);
 8013c82:	4b53      	ldr	r3, [pc, #332]	; (8013dd0 <protocol_enqueue_realtime_command+0x6b8>)
 8013c84:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013c86:	2b00      	cmp	r3, #0
 8013c88:	d007      	beq.n	8013c9a <protocol_enqueue_realtime_command+0x582>
 8013c8a:	4b51      	ldr	r3, [pc, #324]	; (8013dd0 <protocol_enqueue_realtime_command+0x6b8>)
 8013c8c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8013c8e:	79fa      	ldrb	r2, [r7, #7]
 8013c90:	4610      	mov	r0, r2
 8013c92:	4798      	blx	r3
 8013c94:	4603      	mov	r3, r0
 8013c96:	2b00      	cmp	r3, #0
 8013c98:	d001      	beq.n	8013c9e <protocol_enqueue_realtime_command+0x586>
 8013c9a:	2301      	movs	r3, #1
 8013c9c:	e000      	b.n	8013ca0 <protocol_enqueue_realtime_command+0x588>
 8013c9e:	2300      	movs	r3, #0
 8013ca0:	73fb      	strb	r3, [r7, #15]
 8013ca2:	7bfb      	ldrb	r3, [r7, #15]
 8013ca4:	f003 0301 	and.w	r3, r3, #1
 8013ca8:	73fb      	strb	r3, [r7, #15]
            break;
 8013caa:	e013      	b.n	8013cd4 <protocol_enqueue_realtime_command+0x5bc>
            break;
 8013cac:	bf00      	nop
 8013cae:	e012      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cb0:	bf00      	nop
 8013cb2:	e010      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cb4:	bf00      	nop
 8013cb6:	e00e      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cb8:	bf00      	nop
 8013cba:	e00c      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cbc:	bf00      	nop
 8013cbe:	e00a      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cc0:	bf00      	nop
 8013cc2:	e008      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cc4:	bf00      	nop
 8013cc6:	e006      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cc8:	bf00      	nop
 8013cca:	e004      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013ccc:	bf00      	nop
 8013cce:	e002      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cd0:	bf00      	nop
 8013cd2:	e000      	b.n	8013cd6 <protocol_enqueue_realtime_command+0x5be>
            break;
 8013cd4:	bf00      	nop

    // 2. Process printable ASCII characters and top-bit set characters
    //    If legacy realtime commands are disabled they are returned to the input stream
    //    when appearing in settings ($ commands) or comments

    if(!drop) switch ((unsigned char)c) {
 8013cd6:	7bfb      	ldrb	r3, [r7, #15]
 8013cd8:	f083 0301 	eor.w	r3, r3, #1
 8013cdc:	b2db      	uxtb	r3, r3
 8013cde:	2b00      	cmp	r3, #0
 8013ce0:	d069      	beq.n	8013db6 <protocol_enqueue_realtime_command+0x69e>
 8013ce2:	79fb      	ldrb	r3, [r7, #7]
 8013ce4:	2b7e      	cmp	r3, #126	; 0x7e
 8013ce6:	d01c      	beq.n	8013d22 <protocol_enqueue_realtime_command+0x60a>
 8013ce8:	2b7e      	cmp	r3, #126	; 0x7e
 8013cea:	dc4c      	bgt.n	8013d86 <protocol_enqueue_realtime_command+0x66e>
 8013cec:	2b21      	cmp	r3, #33	; 0x21
 8013cee:	d033      	beq.n	8013d58 <protocol_enqueue_realtime_command+0x640>
 8013cf0:	2b3f      	cmp	r3, #63	; 0x3f
 8013cf2:	d148      	bne.n	8013d86 <protocol_enqueue_realtime_command+0x66e>

        case CMD_STATUS_REPORT_LEGACY:
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8013cf4:	4b37      	ldr	r3, [pc, #220]	; (8013dd4 <protocol_enqueue_realtime_command+0x6bc>)
 8013cf6:	781b      	ldrb	r3, [r3, #0]
 8013cf8:	f083 0301 	eor.w	r3, r3, #1
 8013cfc:	b2db      	uxtb	r3, r3
 8013cfe:	2b00      	cmp	r3, #0
 8013d00:	d107      	bne.n	8013d12 <protocol_enqueue_realtime_command+0x5fa>
 8013d02:	4b35      	ldr	r3, [pc, #212]	; (8013dd8 <protocol_enqueue_realtime_command+0x6c0>)
 8013d04:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8013d08:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013d0c:	b2db      	uxtb	r3, r3
 8013d0e:	2b00      	cmp	r3, #0
 8013d10:	d04c      	beq.n	8013dac <protocol_enqueue_realtime_command+0x694>
                system_set_exec_state_flag(EXEC_STATUS_REPORT);
 8013d12:	4b32      	ldr	r3, [pc, #200]	; (8013ddc <protocol_enqueue_realtime_command+0x6c4>)
 8013d14:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013d16:	2101      	movs	r1, #1
 8013d18:	4831      	ldr	r0, [pc, #196]	; (8013de0 <protocol_enqueue_realtime_command+0x6c8>)
 8013d1a:	4798      	blx	r3
                drop = true;
 8013d1c:	2301      	movs	r3, #1
 8013d1e:	73fb      	strb	r3, [r7, #15]
            }
            break;
 8013d20:	e044      	b.n	8013dac <protocol_enqueue_realtime_command+0x694>

        case CMD_CYCLE_START_LEGACY:
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8013d22:	4b2c      	ldr	r3, [pc, #176]	; (8013dd4 <protocol_enqueue_realtime_command+0x6bc>)
 8013d24:	781b      	ldrb	r3, [r3, #0]
 8013d26:	f083 0301 	eor.w	r3, r3, #1
 8013d2a:	b2db      	uxtb	r3, r3
 8013d2c:	2b00      	cmp	r3, #0
 8013d2e:	d107      	bne.n	8013d40 <protocol_enqueue_realtime_command+0x628>
 8013d30:	4b29      	ldr	r3, [pc, #164]	; (8013dd8 <protocol_enqueue_realtime_command+0x6c0>)
 8013d32:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8013d36:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013d3a:	b2db      	uxtb	r3, r3
 8013d3c:	2b00      	cmp	r3, #0
 8013d3e:	d037      	beq.n	8013db0 <protocol_enqueue_realtime_command+0x698>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 8013d40:	4b26      	ldr	r3, [pc, #152]	; (8013ddc <protocol_enqueue_realtime_command+0x6c4>)
 8013d42:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013d44:	2102      	movs	r1, #2
 8013d46:	4826      	ldr	r0, [pc, #152]	; (8013de0 <protocol_enqueue_realtime_command+0x6c8>)
 8013d48:	4798      	blx	r3
                // Cancel any pending tool change
                gc_state.tool_change = false;
 8013d4a:	4b26      	ldr	r3, [pc, #152]	; (8013de4 <protocol_enqueue_realtime_command+0x6cc>)
 8013d4c:	2200      	movs	r2, #0
 8013d4e:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
                drop = true;
 8013d52:	2301      	movs	r3, #1
 8013d54:	73fb      	strb	r3, [r7, #15]
            }
            break;
 8013d56:	e02b      	b.n	8013db0 <protocol_enqueue_realtime_command+0x698>

        case CMD_FEED_HOLD_LEGACY:
            if(!keep_rt_commands || settings.flags.legacy_rt_commands) {
 8013d58:	4b1e      	ldr	r3, [pc, #120]	; (8013dd4 <protocol_enqueue_realtime_command+0x6bc>)
 8013d5a:	781b      	ldrb	r3, [r3, #0]
 8013d5c:	f083 0301 	eor.w	r3, r3, #1
 8013d60:	b2db      	uxtb	r3, r3
 8013d62:	2b00      	cmp	r3, #0
 8013d64:	d107      	bne.n	8013d76 <protocol_enqueue_realtime_command+0x65e>
 8013d66:	4b1c      	ldr	r3, [pc, #112]	; (8013dd8 <protocol_enqueue_realtime_command+0x6c0>)
 8013d68:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8013d6c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013d70:	b2db      	uxtb	r3, r3
 8013d72:	2b00      	cmp	r3, #0
 8013d74:	d01e      	beq.n	8013db4 <protocol_enqueue_realtime_command+0x69c>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 8013d76:	4b19      	ldr	r3, [pc, #100]	; (8013ddc <protocol_enqueue_realtime_command+0x6c4>)
 8013d78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013d7a:	2108      	movs	r1, #8
 8013d7c:	4818      	ldr	r0, [pc, #96]	; (8013de0 <protocol_enqueue_realtime_command+0x6c8>)
 8013d7e:	4798      	blx	r3
                drop = true;
 8013d80:	2301      	movs	r3, #1
 8013d82:	73fb      	strb	r3, [r7, #15]
            }
            break;
 8013d84:	e016      	b.n	8013db4 <protocol_enqueue_realtime_command+0x69c>

        default: // Drop top bit set characters
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
 8013d86:	4b13      	ldr	r3, [pc, #76]	; (8013dd4 <protocol_enqueue_realtime_command+0x6bc>)
 8013d88:	781b      	ldrb	r3, [r3, #0]
 8013d8a:	f083 0301 	eor.w	r3, r3, #1
 8013d8e:	b2db      	uxtb	r3, r3
 8013d90:	2b00      	cmp	r3, #0
 8013d92:	d004      	beq.n	8013d9e <protocol_enqueue_realtime_command+0x686>
 8013d94:	79fb      	ldrb	r3, [r7, #7]
 8013d96:	2b7e      	cmp	r3, #126	; 0x7e
 8013d98:	d901      	bls.n	8013d9e <protocol_enqueue_realtime_command+0x686>
 8013d9a:	2301      	movs	r3, #1
 8013d9c:	e000      	b.n	8013da0 <protocol_enqueue_realtime_command+0x688>
 8013d9e:	2300      	movs	r3, #0
 8013da0:	73fb      	strb	r3, [r7, #15]
 8013da2:	7bfb      	ldrb	r3, [r7, #15]
 8013da4:	f003 0301 	and.w	r3, r3, #1
 8013da8:	73fb      	strb	r3, [r7, #15]
            break;
 8013daa:	e004      	b.n	8013db6 <protocol_enqueue_realtime_command+0x69e>
            break;
 8013dac:	bf00      	nop
 8013dae:	e002      	b.n	8013db6 <protocol_enqueue_realtime_command+0x69e>
            break;
 8013db0:	bf00      	nop
 8013db2:	e000      	b.n	8013db6 <protocol_enqueue_realtime_command+0x69e>
            break;
 8013db4:	bf00      	nop
    }

    esc = c == ASCII_ESC;
 8013db6:	79fb      	ldrb	r3, [r7, #7]
 8013db8:	2b1b      	cmp	r3, #27
 8013dba:	bf0c      	ite	eq
 8013dbc:	2301      	moveq	r3, #1
 8013dbe:	2300      	movne	r3, #0
 8013dc0:	b2da      	uxtb	r2, r3
 8013dc2:	4b09      	ldr	r3, [pc, #36]	; (8013de8 <protocol_enqueue_realtime_command+0x6d0>)
 8013dc4:	701a      	strb	r2, [r3, #0]

    return drop;
 8013dc6:	7bfb      	ldrb	r3, [r7, #15]
}
 8013dc8:	4618      	mov	r0, r3
 8013dca:	3714      	adds	r7, #20
 8013dcc:	46bd      	mov	sp, r7
 8013dce:	bd90      	pop	{r4, r7, pc}
 8013dd0:	20000dd4 	.word	0x20000dd4
 8013dd4:	200013b5 	.word	0x200013b5
 8013dd8:	2000147c 	.word	0x2000147c
 8013ddc:	20000ed0 	.word	0x20000ed0
 8013de0:	20000d84 	.word	0x20000d84
 8013de4:	20000bb0 	.word	0x20000bb0
 8013de8:	20001400 	.word	0x20001400

08013dec <protocol_enqueue_rt_command>:

// Enqueue a function to be called once by the
// foreground process, typically enqueued from an interrupt handler.
ISR_CODE bool ISR_FUNC(protocol_enqueue_rt_command)(on_execute_realtime_ptr fn)
{
 8013dec:	b580      	push	{r7, lr}
 8013dee:	b084      	sub	sp, #16
 8013df0:	af00      	add	r7, sp, #0
 8013df2:	6078      	str	r0, [r7, #4]
    bool ok;
    uint_fast8_t bptr = (realtime_queue.head + 1) & (RT_QUEUE_SIZE - 1);    // Get next head pointer
 8013df4:	4b12      	ldr	r3, [pc, #72]	; (8013e40 <protocol_enqueue_rt_command+0x54>)
 8013df6:	681b      	ldr	r3, [r3, #0]
 8013df8:	3301      	adds	r3, #1
 8013dfa:	f003 030f 	and.w	r3, r3, #15
 8013dfe:	60fb      	str	r3, [r7, #12]

    if((ok = bptr != realtime_queue.tail)) {          // If not buffer full
 8013e00:	4b0f      	ldr	r3, [pc, #60]	; (8013e40 <protocol_enqueue_rt_command+0x54>)
 8013e02:	685b      	ldr	r3, [r3, #4]
 8013e04:	68fa      	ldr	r2, [r7, #12]
 8013e06:	429a      	cmp	r2, r3
 8013e08:	bf14      	ite	ne
 8013e0a:	2301      	movne	r3, #1
 8013e0c:	2300      	moveq	r3, #0
 8013e0e:	72fb      	strb	r3, [r7, #11]
 8013e10:	7afb      	ldrb	r3, [r7, #11]
 8013e12:	2b00      	cmp	r3, #0
 8013e14:	d00f      	beq.n	8013e36 <protocol_enqueue_rt_command+0x4a>
        realtime_queue.fn[realtime_queue.head] = fn;  // add function pointer to buffer,
 8013e16:	4b0a      	ldr	r3, [pc, #40]	; (8013e40 <protocol_enqueue_rt_command+0x54>)
 8013e18:	681b      	ldr	r3, [r3, #0]
 8013e1a:	4909      	ldr	r1, [pc, #36]	; (8013e40 <protocol_enqueue_rt_command+0x54>)
 8013e1c:	3302      	adds	r3, #2
 8013e1e:	687a      	ldr	r2, [r7, #4]
 8013e20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        realtime_queue.head = bptr;                   // update pointer and
 8013e24:	4a06      	ldr	r2, [pc, #24]	; (8013e40 <protocol_enqueue_rt_command+0x54>)
 8013e26:	68fb      	ldr	r3, [r7, #12]
 8013e28:	6013      	str	r3, [r2, #0]
        system_set_exec_state_flag(EXEC_RT_COMMAND);  // flag it for execute
 8013e2a:	4b06      	ldr	r3, [pc, #24]	; (8013e44 <protocol_enqueue_rt_command+0x58>)
 8013e2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8013e2e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8013e32:	4805      	ldr	r0, [pc, #20]	; (8013e48 <protocol_enqueue_rt_command+0x5c>)
 8013e34:	4798      	blx	r3
    }

    return ok;
 8013e36:	7afb      	ldrb	r3, [r7, #11]
}
 8013e38:	4618      	mov	r0, r3
 8013e3a:	3710      	adds	r7, #16
 8013e3c:	46bd      	mov	sp, r7
 8013e3e:	bd80      	pop	{r7, pc}
 8013e40:	200013b8 	.word	0x200013b8
 8013e44:	20000ed0 	.word	0x20000ed0
 8013e48:	20000d84 	.word	0x20000d84

08013e4c <protocol_execute_rt_commands>:

// Execute enqueued functions.
static void protocol_execute_rt_commands (void)
{
 8013e4c:	b580      	push	{r7, lr}
 8013e4e:	b082      	sub	sp, #8
 8013e50:	af00      	add	r7, sp, #0
    while(realtime_queue.tail != realtime_queue.head) {
 8013e52:	e01d      	b.n	8013e90 <protocol_execute_rt_commands+0x44>
        uint_fast8_t bptr = realtime_queue.tail;
 8013e54:	4b18      	ldr	r3, [pc, #96]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e56:	685b      	ldr	r3, [r3, #4]
 8013e58:	607b      	str	r3, [r7, #4]
        on_execute_realtime_ptr call;
        if((call = realtime_queue.fn[bptr])) {
 8013e5a:	4a17      	ldr	r2, [pc, #92]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e5c:	687b      	ldr	r3, [r7, #4]
 8013e5e:	3302      	adds	r3, #2
 8013e60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013e64:	603b      	str	r3, [r7, #0]
 8013e66:	683b      	ldr	r3, [r7, #0]
 8013e68:	2b00      	cmp	r3, #0
 8013e6a:	d00b      	beq.n	8013e84 <protocol_execute_rt_commands+0x38>
            realtime_queue.fn[bptr] = NULL;
 8013e6c:	4a12      	ldr	r2, [pc, #72]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e6e:	687b      	ldr	r3, [r7, #4]
 8013e70:	3302      	adds	r3, #2
 8013e72:	2100      	movs	r1, #0
 8013e74:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            call(state_get());
 8013e78:	f009 fd22 	bl	801d8c0 <state_get>
 8013e7c:	4602      	mov	r2, r0
 8013e7e:	683b      	ldr	r3, [r7, #0]
 8013e80:	4610      	mov	r0, r2
 8013e82:	4798      	blx	r3
        }
        realtime_queue.tail = (bptr + 1) & (RT_QUEUE_SIZE - 1);
 8013e84:	687b      	ldr	r3, [r7, #4]
 8013e86:	3301      	adds	r3, #1
 8013e88:	f003 030f 	and.w	r3, r3, #15
 8013e8c:	4a0a      	ldr	r2, [pc, #40]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e8e:	6053      	str	r3, [r2, #4]
    while(realtime_queue.tail != realtime_queue.head) {
 8013e90:	4b09      	ldr	r3, [pc, #36]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e92:	685a      	ldr	r2, [r3, #4]
 8013e94:	4b08      	ldr	r3, [pc, #32]	; (8013eb8 <protocol_execute_rt_commands+0x6c>)
 8013e96:	681b      	ldr	r3, [r3, #0]
 8013e98:	429a      	cmp	r2, r3
 8013e9a:	d1db      	bne.n	8013e54 <protocol_execute_rt_commands+0x8>
    }

    if(!sys.driver_started)
 8013e9c:	4b07      	ldr	r3, [pc, #28]	; (8013ebc <protocol_execute_rt_commands+0x70>)
 8013e9e:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8013ea2:	f083 0301 	eor.w	r3, r3, #1
 8013ea6:	b2db      	uxtb	r3, r3
 8013ea8:	2b00      	cmp	r3, #0
 8013eaa:	d000      	beq.n	8013eae <protocol_execute_rt_commands+0x62>
        while(true);
 8013eac:	e7fe      	b.n	8013eac <protocol_execute_rt_commands+0x60>
}
 8013eae:	bf00      	nop
 8013eb0:	3708      	adds	r7, #8
 8013eb2:	46bd      	mov	sp, r7
 8013eb4:	bd80      	pop	{r7, pc}
 8013eb6:	bf00      	nop
 8013eb8:	200013b8 	.word	0x200013b8
 8013ebc:	20000d3c 	.word	0x20000d3c

08013ec0 <protocol_execute_noop>:

void protocol_execute_noop (sys_state_t state)
{
 8013ec0:	b480      	push	{r7}
 8013ec2:	b083      	sub	sp, #12
 8013ec4:	af00      	add	r7, sp, #0
 8013ec6:	6078      	str	r0, [r7, #4]
    (void)state;
}
 8013ec8:	bf00      	nop
 8013eca:	370c      	adds	r7, #12
 8013ecc:	46bd      	mov	sp, r7
 8013ece:	bc80      	pop	{r7}
 8013ed0:	4770      	bx	lr

08013ed2 <matchhere>:
    return 0;
}

/* matchhere: search for regexp at beginning of text */
int matchhere(char *regexp, char *text)
{
 8013ed2:	b580      	push	{r7, lr}
 8013ed4:	b082      	sub	sp, #8
 8013ed6:	af00      	add	r7, sp, #0
 8013ed8:	6078      	str	r0, [r7, #4]
 8013eda:	6039      	str	r1, [r7, #0]
    if (regexp[0] == '\0')
 8013edc:	687b      	ldr	r3, [r7, #4]
 8013ede:	781b      	ldrb	r3, [r3, #0]
 8013ee0:	2b00      	cmp	r3, #0
 8013ee2:	d101      	bne.n	8013ee8 <matchhere+0x16>
        return 1;
 8013ee4:	2301      	movs	r3, #1
 8013ee6:	e039      	b.n	8013f5c <matchhere+0x8a>
    if (regexp[1] == '*')
 8013ee8:	687b      	ldr	r3, [r7, #4]
 8013eea:	3301      	adds	r3, #1
 8013eec:	781b      	ldrb	r3, [r3, #0]
 8013eee:	2b2a      	cmp	r3, #42	; 0x2a
 8013ef0:	d10a      	bne.n	8013f08 <matchhere+0x36>
        return matchstar(regexp[0], regexp+2, text);
 8013ef2:	687b      	ldr	r3, [r7, #4]
 8013ef4:	781b      	ldrb	r3, [r3, #0]
 8013ef6:	4618      	mov	r0, r3
 8013ef8:	687b      	ldr	r3, [r7, #4]
 8013efa:	3302      	adds	r3, #2
 8013efc:	683a      	ldr	r2, [r7, #0]
 8013efe:	4619      	mov	r1, r3
 8013f00:	f000 f830 	bl	8013f64 <matchstar>
 8013f04:	4603      	mov	r3, r0
 8013f06:	e029      	b.n	8013f5c <matchhere+0x8a>
    if (regexp[0] == '$' && regexp[1] == '\0')
 8013f08:	687b      	ldr	r3, [r7, #4]
 8013f0a:	781b      	ldrb	r3, [r3, #0]
 8013f0c:	2b24      	cmp	r3, #36	; 0x24
 8013f0e:	d10c      	bne.n	8013f2a <matchhere+0x58>
 8013f10:	687b      	ldr	r3, [r7, #4]
 8013f12:	3301      	adds	r3, #1
 8013f14:	781b      	ldrb	r3, [r3, #0]
 8013f16:	2b00      	cmp	r3, #0
 8013f18:	d107      	bne.n	8013f2a <matchhere+0x58>
        return *text == '\0';
 8013f1a:	683b      	ldr	r3, [r7, #0]
 8013f1c:	781b      	ldrb	r3, [r3, #0]
 8013f1e:	2b00      	cmp	r3, #0
 8013f20:	bf0c      	ite	eq
 8013f22:	2301      	moveq	r3, #1
 8013f24:	2300      	movne	r3, #0
 8013f26:	b2db      	uxtb	r3, r3
 8013f28:	e018      	b.n	8013f5c <matchhere+0x8a>
    if (*text!='\0' && (regexp[0]=='.' || regexp[0]==*text))
 8013f2a:	683b      	ldr	r3, [r7, #0]
 8013f2c:	781b      	ldrb	r3, [r3, #0]
 8013f2e:	2b00      	cmp	r3, #0
 8013f30:	d013      	beq.n	8013f5a <matchhere+0x88>
 8013f32:	687b      	ldr	r3, [r7, #4]
 8013f34:	781b      	ldrb	r3, [r3, #0]
 8013f36:	2b2e      	cmp	r3, #46	; 0x2e
 8013f38:	d005      	beq.n	8013f46 <matchhere+0x74>
 8013f3a:	687b      	ldr	r3, [r7, #4]
 8013f3c:	781a      	ldrb	r2, [r3, #0]
 8013f3e:	683b      	ldr	r3, [r7, #0]
 8013f40:	781b      	ldrb	r3, [r3, #0]
 8013f42:	429a      	cmp	r2, r3
 8013f44:	d109      	bne.n	8013f5a <matchhere+0x88>
        return matchhere(regexp+1, text+1);
 8013f46:	687b      	ldr	r3, [r7, #4]
 8013f48:	1c5a      	adds	r2, r3, #1
 8013f4a:	683b      	ldr	r3, [r7, #0]
 8013f4c:	3301      	adds	r3, #1
 8013f4e:	4619      	mov	r1, r3
 8013f50:	4610      	mov	r0, r2
 8013f52:	f7ff ffbe 	bl	8013ed2 <matchhere>
 8013f56:	4603      	mov	r3, r0
 8013f58:	e000      	b.n	8013f5c <matchhere+0x8a>
    return 0;
 8013f5a:	2300      	movs	r3, #0
}
 8013f5c:	4618      	mov	r0, r3
 8013f5e:	3708      	adds	r7, #8
 8013f60:	46bd      	mov	sp, r7
 8013f62:	bd80      	pop	{r7, pc}

08013f64 <matchstar>:

/* matchstar: search for c*regexp at beginning of text */
int matchstar(int c, char *regexp, char *text)
{
 8013f64:	b580      	push	{r7, lr}
 8013f66:	b084      	sub	sp, #16
 8013f68:	af00      	add	r7, sp, #0
 8013f6a:	60f8      	str	r0, [r7, #12]
 8013f6c:	60b9      	str	r1, [r7, #8]
 8013f6e:	607a      	str	r2, [r7, #4]
    do {    /* a * matches zero or more instances */
        if (matchhere(regexp, text))
 8013f70:	6879      	ldr	r1, [r7, #4]
 8013f72:	68b8      	ldr	r0, [r7, #8]
 8013f74:	f7ff ffad 	bl	8013ed2 <matchhere>
 8013f78:	4603      	mov	r3, r0
 8013f7a:	2b00      	cmp	r3, #0
 8013f7c:	d001      	beq.n	8013f82 <matchstar+0x1e>
            return 1;
 8013f7e:	2301      	movs	r3, #1
 8013f80:	e00f      	b.n	8013fa2 <matchstar+0x3e>
    } while (*text != '\0' && (*text++ == c || c == '.'));
 8013f82:	687b      	ldr	r3, [r7, #4]
 8013f84:	781b      	ldrb	r3, [r3, #0]
 8013f86:	2b00      	cmp	r3, #0
 8013f88:	d00a      	beq.n	8013fa0 <matchstar+0x3c>
 8013f8a:	687b      	ldr	r3, [r7, #4]
 8013f8c:	1c5a      	adds	r2, r3, #1
 8013f8e:	607a      	str	r2, [r7, #4]
 8013f90:	781b      	ldrb	r3, [r3, #0]
 8013f92:	461a      	mov	r2, r3
 8013f94:	68fb      	ldr	r3, [r7, #12]
 8013f96:	4293      	cmp	r3, r2
 8013f98:	d0ea      	beq.n	8013f70 <matchstar+0xc>
 8013f9a:	68fb      	ldr	r3, [r7, #12]
 8013f9c:	2b2e      	cmp	r3, #46	; 0x2e
 8013f9e:	d0e7      	beq.n	8013f70 <matchstar+0xc>
    return 0;
 8013fa0:	2300      	movs	r3, #0
}
 8013fa2:	4618      	mov	r0, r3
 8013fa4:	3710      	adds	r7, #16
 8013fa6:	46bd      	mov	sp, r7
 8013fa8:	bd80      	pop	{r7, pc}
	...

08013fac <appendbuf>:
static const char vbar[2] = { '|', '\0' };

// Append a number of strings to the static buffer
// NOTE: do NOT use for several int/float conversions as these share the same underlying buffer!
static char *appendbuf (int argc, ...)
{
 8013fac:	b40f      	push	{r0, r1, r2, r3}
 8013fae:	b480      	push	{r7}
 8013fb0:	b085      	sub	sp, #20
 8013fb2:	af00      	add	r7, sp, #0
    char c, *s = buf, *arg;
 8013fb4:	4b13      	ldr	r3, [pc, #76]	; (8014004 <appendbuf+0x58>)
 8013fb6:	60fb      	str	r3, [r7, #12]

    va_list list;
    va_start(list, argc);
 8013fb8:	f107 031c 	add.w	r3, r7, #28
 8013fbc:	603b      	str	r3, [r7, #0]

    while(argc--) {
 8013fbe:	e014      	b.n	8013fea <appendbuf+0x3e>
        arg = va_arg(list, char *);
 8013fc0:	683b      	ldr	r3, [r7, #0]
 8013fc2:	1d1a      	adds	r2, r3, #4
 8013fc4:	603a      	str	r2, [r7, #0]
 8013fc6:	681b      	ldr	r3, [r3, #0]
 8013fc8:	60bb      	str	r3, [r7, #8]
        do {
            c = *s++ = *arg++;
 8013fca:	68ba      	ldr	r2, [r7, #8]
 8013fcc:	1c53      	adds	r3, r2, #1
 8013fce:	60bb      	str	r3, [r7, #8]
 8013fd0:	68fb      	ldr	r3, [r7, #12]
 8013fd2:	1c59      	adds	r1, r3, #1
 8013fd4:	60f9      	str	r1, [r7, #12]
 8013fd6:	7812      	ldrb	r2, [r2, #0]
 8013fd8:	701a      	strb	r2, [r3, #0]
 8013fda:	781b      	ldrb	r3, [r3, #0]
 8013fdc:	71fb      	strb	r3, [r7, #7]
        } while(c);
 8013fde:	79fb      	ldrb	r3, [r7, #7]
 8013fe0:	2b00      	cmp	r3, #0
 8013fe2:	d1f2      	bne.n	8013fca <appendbuf+0x1e>
        s--;
 8013fe4:	68fb      	ldr	r3, [r7, #12]
 8013fe6:	3b01      	subs	r3, #1
 8013fe8:	60fb      	str	r3, [r7, #12]
    while(argc--) {
 8013fea:	69bb      	ldr	r3, [r7, #24]
 8013fec:	1e5a      	subs	r2, r3, #1
 8013fee:	61ba      	str	r2, [r7, #24]
 8013ff0:	2b00      	cmp	r3, #0
 8013ff2:	d1e5      	bne.n	8013fc0 <appendbuf+0x14>
    }

    va_end(list);

    return buf;
 8013ff4:	4b03      	ldr	r3, [pc, #12]	; (8014004 <appendbuf+0x58>)
}
 8013ff6:	4618      	mov	r0, r3
 8013ff8:	3714      	adds	r7, #20
 8013ffa:	46bd      	mov	sp, r7
 8013ffc:	bc80      	pop	{r7}
 8013ffe:	b004      	add	sp, #16
 8014000:	4770      	bx	lr
 8014002:	bf00      	nop
 8014004:	20001404 	.word	0x20001404

08014008 <map_coord_system>:

static char *map_coord_system (coord_system_id_t id)
{
 8014008:	b580      	push	{r7, lr}
 801400a:	b084      	sub	sp, #16
 801400c:	af00      	add	r7, sp, #0
 801400e:	4603      	mov	r3, r0
 8014010:	71fb      	strb	r3, [r7, #7]
    uint8_t g5x = id + 54;
 8014012:	79fb      	ldrb	r3, [r7, #7]
 8014014:	3336      	adds	r3, #54	; 0x36
 8014016:	73fb      	strb	r3, [r7, #15]

    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 8014018:	7bfb      	ldrb	r3, [r7, #15]
 801401a:	2b3b      	cmp	r3, #59	; 0x3b
 801401c:	bf28      	it	cs
 801401e:	233b      	movcs	r3, #59	; 0x3b
 8014020:	b2db      	uxtb	r3, r3
 8014022:	4618      	mov	r0, r3
 8014024:	f7fc f932 	bl	801028c <uitoa>
 8014028:	4603      	mov	r3, r0
 801402a:	4619      	mov	r1, r3
 801402c:	4810      	ldr	r0, [pc, #64]	; (8014070 <map_coord_system+0x68>)
 801402e:	f00f ff46 	bl	8023ebe <strcpy>
    if(g5x > 59) {
 8014032:	7bfb      	ldrb	r3, [r7, #15]
 8014034:	2b3b      	cmp	r3, #59	; 0x3b
 8014036:	d915      	bls.n	8014064 <map_coord_system+0x5c>
        strcat(buf, ".");
 8014038:	480d      	ldr	r0, [pc, #52]	; (8014070 <map_coord_system+0x68>)
 801403a:	f7ec f8ff 	bl	800023c <strlen>
 801403e:	4603      	mov	r3, r0
 8014040:	461a      	mov	r2, r3
 8014042:	4b0b      	ldr	r3, [pc, #44]	; (8014070 <map_coord_system+0x68>)
 8014044:	4413      	add	r3, r2
 8014046:	490b      	ldr	r1, [pc, #44]	; (8014074 <map_coord_system+0x6c>)
 8014048:	461a      	mov	r2, r3
 801404a:	460b      	mov	r3, r1
 801404c:	881b      	ldrh	r3, [r3, #0]
 801404e:	8013      	strh	r3, [r2, #0]
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 8014050:	7bfb      	ldrb	r3, [r7, #15]
 8014052:	3b3b      	subs	r3, #59	; 0x3b
 8014054:	4618      	mov	r0, r3
 8014056:	f7fc f919 	bl	801028c <uitoa>
 801405a:	4603      	mov	r3, r0
 801405c:	4619      	mov	r1, r3
 801405e:	4804      	ldr	r0, [pc, #16]	; (8014070 <map_coord_system+0x68>)
 8014060:	f00f fde1 	bl	8023c26 <strcat>
    }

    return buf;
 8014064:	4b02      	ldr	r3, [pc, #8]	; (8014070 <map_coord_system+0x68>)
}
 8014066:	4618      	mov	r0, r3
 8014068:	3710      	adds	r7, #16
 801406a:	46bd      	mov	sp, r7
 801406c:	bd80      	pop	{r7, pc}
 801406e:	bf00      	nop
 8014070:	20001404 	.word	0x20001404
 8014074:	0802b180 	.word	0x0802b180

08014078 <get_axis_values_mm>:

// Convert axis position values to null terminated string (mm).
static char *get_axis_values_mm (float *axis_values)
{
 8014078:	b580      	push	{r7, lr}
 801407a:	b084      	sub	sp, #16
 801407c:	af00      	add	r7, sp, #0
 801407e:	6078      	str	r0, [r7, #4]
    uint_fast32_t idx;

    buf[0] = '\0';
 8014080:	4b24      	ldr	r3, [pc, #144]	; (8014114 <get_axis_values_mm+0x9c>)
 8014082:	2200      	movs	r2, #0
 8014084:	701a      	strb	r2, [r3, #0]

    for (idx = 0; idx < N_AXIS; idx++) {
 8014086:	2300      	movs	r3, #0
 8014088:	60fb      	str	r3, [r7, #12]
 801408a:	e03a      	b.n	8014102 <get_axis_values_mm+0x8a>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 801408c:	68fb      	ldr	r3, [r7, #12]
 801408e:	2b00      	cmp	r3, #0
 8014090:	d117      	bne.n	80140c2 <get_axis_values_mm+0x4a>
 8014092:	4b21      	ldr	r3, [pc, #132]	; (8014118 <get_axis_values_mm+0xa0>)
 8014094:	795b      	ldrb	r3, [r3, #5]
 8014096:	2b00      	cmp	r3, #0
 8014098:	d013      	beq.n	80140c2 <get_axis_values_mm+0x4a>
            strcat(buf, ftoa(axis_values[idx] * 2.0f, N_DECIMAL_COORDVALUE_MM));
 801409a:	68fb      	ldr	r3, [r7, #12]
 801409c:	009b      	lsls	r3, r3, #2
 801409e:	687a      	ldr	r2, [r7, #4]
 80140a0:	4413      	add	r3, r2
 80140a2:	681b      	ldr	r3, [r3, #0]
 80140a4:	4619      	mov	r1, r3
 80140a6:	4618      	mov	r0, r3
 80140a8:	f7ec fd7c 	bl	8000ba4 <__addsf3>
 80140ac:	4603      	mov	r3, r0
 80140ae:	2103      	movs	r1, #3
 80140b0:	4618      	mov	r0, r3
 80140b2:	f7fc f927 	bl	8010304 <ftoa>
 80140b6:	4603      	mov	r3, r0
 80140b8:	4619      	mov	r1, r3
 80140ba:	4816      	ldr	r0, [pc, #88]	; (8014114 <get_axis_values_mm+0x9c>)
 80140bc:	f00f fdb3 	bl	8023c26 <strcat>
 80140c0:	e00d      	b.n	80140de <get_axis_values_mm+0x66>
        else
            strcat(buf, ftoa(axis_values[idx], N_DECIMAL_COORDVALUE_MM));
 80140c2:	68fb      	ldr	r3, [r7, #12]
 80140c4:	009b      	lsls	r3, r3, #2
 80140c6:	687a      	ldr	r2, [r7, #4]
 80140c8:	4413      	add	r3, r2
 80140ca:	681b      	ldr	r3, [r3, #0]
 80140cc:	2103      	movs	r1, #3
 80140ce:	4618      	mov	r0, r3
 80140d0:	f7fc f918 	bl	8010304 <ftoa>
 80140d4:	4603      	mov	r3, r0
 80140d6:	4619      	mov	r1, r3
 80140d8:	480e      	ldr	r0, [pc, #56]	; (8014114 <get_axis_values_mm+0x9c>)
 80140da:	f00f fda4 	bl	8023c26 <strcat>
        if (idx < (N_AXIS - 1))
 80140de:	68fb      	ldr	r3, [r7, #12]
 80140e0:	2b01      	cmp	r3, #1
 80140e2:	d80b      	bhi.n	80140fc <get_axis_values_mm+0x84>
            strcat(buf, ",");
 80140e4:	480b      	ldr	r0, [pc, #44]	; (8014114 <get_axis_values_mm+0x9c>)
 80140e6:	f7ec f8a9 	bl	800023c <strlen>
 80140ea:	4603      	mov	r3, r0
 80140ec:	461a      	mov	r2, r3
 80140ee:	4b09      	ldr	r3, [pc, #36]	; (8014114 <get_axis_values_mm+0x9c>)
 80140f0:	4413      	add	r3, r2
 80140f2:	490a      	ldr	r1, [pc, #40]	; (801411c <get_axis_values_mm+0xa4>)
 80140f4:	461a      	mov	r2, r3
 80140f6:	460b      	mov	r3, r1
 80140f8:	881b      	ldrh	r3, [r3, #0]
 80140fa:	8013      	strh	r3, [r2, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 80140fc:	68fb      	ldr	r3, [r7, #12]
 80140fe:	3301      	adds	r3, #1
 8014100:	60fb      	str	r3, [r7, #12]
 8014102:	68fb      	ldr	r3, [r7, #12]
 8014104:	2b02      	cmp	r3, #2
 8014106:	d9c1      	bls.n	801408c <get_axis_values_mm+0x14>
    }

    return buf;
 8014108:	4b02      	ldr	r3, [pc, #8]	; (8014114 <get_axis_values_mm+0x9c>)
}
 801410a:	4618      	mov	r0, r3
 801410c:	3710      	adds	r7, #16
 801410e:	46bd      	mov	sp, r7
 8014110:	bd80      	pop	{r7, pc}
 8014112:	bf00      	nop
 8014114:	20001404 	.word	0x20001404
 8014118:	20000bb0 	.word	0x20000bb0
 801411c:	0802b184 	.word	0x0802b184

08014120 <get_axis_values_inches>:

// Convert axis position values to null terminated string (inch).
static char *get_axis_values_inches (float *axis_values)
{
 8014120:	b580      	push	{r7, lr}
 8014122:	b084      	sub	sp, #16
 8014124:	af00      	add	r7, sp, #0
 8014126:	6078      	str	r0, [r7, #4]
    uint_fast32_t idx;

    buf[0] = '\0';
 8014128:	4b29      	ldr	r3, [pc, #164]	; (80141d0 <get_axis_values_inches+0xb0>)
 801412a:	2200      	movs	r2, #0
 801412c:	701a      	strb	r2, [r3, #0]

    for (idx = 0; idx < N_AXIS; idx++) {
 801412e:	2300      	movs	r3, #0
 8014130:	60fb      	str	r3, [r7, #12]
 8014132:	e044      	b.n	80141be <get_axis_values_inches+0x9e>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 8014134:	68fb      	ldr	r3, [r7, #12]
 8014136:	2b00      	cmp	r3, #0
 8014138:	d11c      	bne.n	8014174 <get_axis_values_inches+0x54>
 801413a:	4b26      	ldr	r3, [pc, #152]	; (80141d4 <get_axis_values_inches+0xb4>)
 801413c:	795b      	ldrb	r3, [r3, #5]
 801413e:	2b00      	cmp	r3, #0
 8014140:	d018      	beq.n	8014174 <get_axis_values_inches+0x54>
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM * 2.0f, N_DECIMAL_COORDVALUE_INCH));
 8014142:	68fb      	ldr	r3, [r7, #12]
 8014144:	009b      	lsls	r3, r3, #2
 8014146:	687a      	ldr	r2, [r7, #4]
 8014148:	4413      	add	r3, r2
 801414a:	681b      	ldr	r3, [r3, #0]
 801414c:	4922      	ldr	r1, [pc, #136]	; (80141d8 <get_axis_values_inches+0xb8>)
 801414e:	4618      	mov	r0, r3
 8014150:	f7ec fe30 	bl	8000db4 <__aeabi_fmul>
 8014154:	4603      	mov	r3, r0
 8014156:	4619      	mov	r1, r3
 8014158:	4618      	mov	r0, r3
 801415a:	f7ec fd23 	bl	8000ba4 <__addsf3>
 801415e:	4603      	mov	r3, r0
 8014160:	2104      	movs	r1, #4
 8014162:	4618      	mov	r0, r3
 8014164:	f7fc f8ce 	bl	8010304 <ftoa>
 8014168:	4603      	mov	r3, r0
 801416a:	4619      	mov	r1, r3
 801416c:	4818      	ldr	r0, [pc, #96]	; (80141d0 <get_axis_values_inches+0xb0>)
 801416e:	f00f fd5a 	bl	8023c26 <strcat>
 8014172:	e012      	b.n	801419a <get_axis_values_inches+0x7a>
#if N_AXIS > 3
        else if(idx > Z_AXIS && bit_istrue(settings.steppers.is_rotational.mask, bit(idx)))
            strcat(buf, ftoa(axis_values[idx], N_DECIMAL_COORDVALUE_MM));
#endif
        else
             strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 8014174:	68fb      	ldr	r3, [r7, #12]
 8014176:	009b      	lsls	r3, r3, #2
 8014178:	687a      	ldr	r2, [r7, #4]
 801417a:	4413      	add	r3, r2
 801417c:	681b      	ldr	r3, [r3, #0]
 801417e:	4916      	ldr	r1, [pc, #88]	; (80141d8 <get_axis_values_inches+0xb8>)
 8014180:	4618      	mov	r0, r3
 8014182:	f7ec fe17 	bl	8000db4 <__aeabi_fmul>
 8014186:	4603      	mov	r3, r0
 8014188:	2104      	movs	r1, #4
 801418a:	4618      	mov	r0, r3
 801418c:	f7fc f8ba 	bl	8010304 <ftoa>
 8014190:	4603      	mov	r3, r0
 8014192:	4619      	mov	r1, r3
 8014194:	480e      	ldr	r0, [pc, #56]	; (80141d0 <get_axis_values_inches+0xb0>)
 8014196:	f00f fd46 	bl	8023c26 <strcat>
        if (idx < (N_AXIS - 1))
 801419a:	68fb      	ldr	r3, [r7, #12]
 801419c:	2b01      	cmp	r3, #1
 801419e:	d80b      	bhi.n	80141b8 <get_axis_values_inches+0x98>
            strcat(buf, ",");
 80141a0:	480b      	ldr	r0, [pc, #44]	; (80141d0 <get_axis_values_inches+0xb0>)
 80141a2:	f7ec f84b 	bl	800023c <strlen>
 80141a6:	4603      	mov	r3, r0
 80141a8:	461a      	mov	r2, r3
 80141aa:	4b09      	ldr	r3, [pc, #36]	; (80141d0 <get_axis_values_inches+0xb0>)
 80141ac:	4413      	add	r3, r2
 80141ae:	490b      	ldr	r1, [pc, #44]	; (80141dc <get_axis_values_inches+0xbc>)
 80141b0:	461a      	mov	r2, r3
 80141b2:	460b      	mov	r3, r1
 80141b4:	881b      	ldrh	r3, [r3, #0]
 80141b6:	8013      	strh	r3, [r2, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 80141b8:	68fb      	ldr	r3, [r7, #12]
 80141ba:	3301      	adds	r3, #1
 80141bc:	60fb      	str	r3, [r7, #12]
 80141be:	68fb      	ldr	r3, [r7, #12]
 80141c0:	2b02      	cmp	r3, #2
 80141c2:	d9b7      	bls.n	8014134 <get_axis_values_inches+0x14>
    }

    return buf;
 80141c4:	4b02      	ldr	r3, [pc, #8]	; (80141d0 <get_axis_values_inches+0xb0>)
}
 80141c6:	4618      	mov	r0, r3
 80141c8:	3710      	adds	r7, #16
 80141ca:	46bd      	mov	sp, r7
 80141cc:	bd80      	pop	{r7, pc}
 80141ce:	bf00      	nop
 80141d0:	20001404 	.word	0x20001404
 80141d4:	20000bb0 	.word	0x20000bb0
 80141d8:	3d21428b 	.word	0x3d21428b
 80141dc:	0802b184 	.word	0x0802b184

080141e0 <get_axis_value_mm>:

// Convert rate value to null terminated string (mm).
static char *get_axis_value_mm (float value)
{
 80141e0:	b580      	push	{r7, lr}
 80141e2:	b082      	sub	sp, #8
 80141e4:	af00      	add	r7, sp, #0
 80141e6:	6078      	str	r0, [r7, #4]
    return strcpy(buf, ftoa(value, N_DECIMAL_COORDVALUE_MM));
 80141e8:	2103      	movs	r1, #3
 80141ea:	6878      	ldr	r0, [r7, #4]
 80141ec:	f7fc f88a 	bl	8010304 <ftoa>
 80141f0:	4603      	mov	r3, r0
 80141f2:	4619      	mov	r1, r3
 80141f4:	4803      	ldr	r0, [pc, #12]	; (8014204 <get_axis_value_mm+0x24>)
 80141f6:	f00f fe62 	bl	8023ebe <strcpy>
 80141fa:	4603      	mov	r3, r0
}
 80141fc:	4618      	mov	r0, r3
 80141fe:	3708      	adds	r7, #8
 8014200:	46bd      	mov	sp, r7
 8014202:	bd80      	pop	{r7, pc}
 8014204:	20001404 	.word	0x20001404

08014208 <get_axis_value_inches>:

// Convert rate value to null terminated string (mm).
static char *get_axis_value_inches (float value)
{
 8014208:	b580      	push	{r7, lr}
 801420a:	b082      	sub	sp, #8
 801420c:	af00      	add	r7, sp, #0
 801420e:	6078      	str	r0, [r7, #4]
    return strcpy(buf, ftoa(value * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 8014210:	4909      	ldr	r1, [pc, #36]	; (8014238 <get_axis_value_inches+0x30>)
 8014212:	6878      	ldr	r0, [r7, #4]
 8014214:	f7ec fdce 	bl	8000db4 <__aeabi_fmul>
 8014218:	4603      	mov	r3, r0
 801421a:	2104      	movs	r1, #4
 801421c:	4618      	mov	r0, r3
 801421e:	f7fc f871 	bl	8010304 <ftoa>
 8014222:	4603      	mov	r3, r0
 8014224:	4619      	mov	r1, r3
 8014226:	4805      	ldr	r0, [pc, #20]	; (801423c <get_axis_value_inches+0x34>)
 8014228:	f00f fe49 	bl	8023ebe <strcpy>
 801422c:	4603      	mov	r3, r0
}
 801422e:	4618      	mov	r0, r3
 8014230:	3708      	adds	r7, #8
 8014232:	46bd      	mov	sp, r7
 8014234:	bd80      	pop	{r7, pc}
 8014236:	bf00      	nop
 8014238:	3d21428b 	.word	0x3d21428b
 801423c:	20001404 	.word	0x20001404

08014240 <get_rate_value_mm>:

// Convert rate value to null terminated string (mm).
static char *get_rate_value_mm (float value)
{
 8014240:	b580      	push	{r7, lr}
 8014242:	b082      	sub	sp, #8
 8014244:	af00      	add	r7, sp, #0
 8014246:	6078      	str	r0, [r7, #4]
    return uitoa((uint32_t)value);
 8014248:	6878      	ldr	r0, [r7, #4]
 801424a:	f7ec ffb5 	bl	80011b8 <__aeabi_f2uiz>
 801424e:	4603      	mov	r3, r0
 8014250:	4618      	mov	r0, r3
 8014252:	f7fc f81b 	bl	801028c <uitoa>
 8014256:	4603      	mov	r3, r0
}
 8014258:	4618      	mov	r0, r3
 801425a:	3708      	adds	r7, #8
 801425c:	46bd      	mov	sp, r7
 801425e:	bd80      	pop	{r7, pc}

08014260 <get_rate_value_inch>:

// Convert rate value to null terminated string (mm).
static char *get_rate_value_inch (float value)
{
 8014260:	b580      	push	{r7, lr}
 8014262:	b082      	sub	sp, #8
 8014264:	af00      	add	r7, sp, #0
 8014266:	6078      	str	r0, [r7, #4]
    return uitoa((uint32_t)(value * INCH_PER_MM));
 8014268:	4908      	ldr	r1, [pc, #32]	; (801428c <get_rate_value_inch+0x2c>)
 801426a:	6878      	ldr	r0, [r7, #4]
 801426c:	f7ec fda2 	bl	8000db4 <__aeabi_fmul>
 8014270:	4603      	mov	r3, r0
 8014272:	4618      	mov	r0, r3
 8014274:	f7ec ffa0 	bl	80011b8 <__aeabi_f2uiz>
 8014278:	4603      	mov	r3, r0
 801427a:	4618      	mov	r0, r3
 801427c:	f7fc f806 	bl	801028c <uitoa>
 8014280:	4603      	mov	r3, r0
}
 8014282:	4618      	mov	r0, r3
 8014284:	3708      	adds	r7, #8
 8014286:	46bd      	mov	sp, r7
 8014288:	bd80      	pop	{r7, pc}
 801428a:	bf00      	nop
 801428c:	3d21428b 	.word	0x3d21428b

08014290 <axis_signals_tostring>:

// Convert axes signals bits to string representation.
// NOTE: returns pointer to null terminator!
inline static char *axis_signals_tostring (char *buf, axes_signals_t signals)
{
 8014290:	b480      	push	{r7}
 8014292:	b085      	sub	sp, #20
 8014294:	af00      	add	r7, sp, #0
 8014296:	6078      	str	r0, [r7, #4]
 8014298:	7039      	strb	r1, [r7, #0]
    uint_fast16_t idx = 0;
 801429a:	2300      	movs	r3, #0
 801429c:	60fb      	str	r3, [r7, #12]

    signals.mask &= AXES_BITMASK;
 801429e:	783b      	ldrb	r3, [r7, #0]
 80142a0:	f003 0307 	and.w	r3, r3, #7
 80142a4:	b2db      	uxtb	r3, r3
 80142a6:	703b      	strb	r3, [r7, #0]

    while(signals.mask) {
 80142a8:	e014      	b.n	80142d4 <axis_signals_tostring+0x44>
        if(signals.mask & 0x01)
 80142aa:	783b      	ldrb	r3, [r7, #0]
 80142ac:	f003 0301 	and.w	r3, r3, #1
 80142b0:	2b00      	cmp	r3, #0
 80142b2:	d008      	beq.n	80142c6 <axis_signals_tostring+0x36>
            *buf++ = *axis_letter[idx];
 80142b4:	4a0d      	ldr	r2, [pc, #52]	; (80142ec <axis_signals_tostring+0x5c>)
 80142b6:	68fb      	ldr	r3, [r7, #12]
 80142b8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80142bc:	687b      	ldr	r3, [r7, #4]
 80142be:	1c59      	adds	r1, r3, #1
 80142c0:	6079      	str	r1, [r7, #4]
 80142c2:	7812      	ldrb	r2, [r2, #0]
 80142c4:	701a      	strb	r2, [r3, #0]
        idx++;
 80142c6:	68fb      	ldr	r3, [r7, #12]
 80142c8:	3301      	adds	r3, #1
 80142ca:	60fb      	str	r3, [r7, #12]
        signals.mask >>= 1;
 80142cc:	783b      	ldrb	r3, [r7, #0]
 80142ce:	085b      	lsrs	r3, r3, #1
 80142d0:	b2db      	uxtb	r3, r3
 80142d2:	703b      	strb	r3, [r7, #0]
    while(signals.mask) {
 80142d4:	783b      	ldrb	r3, [r7, #0]
 80142d6:	2b00      	cmp	r3, #0
 80142d8:	d1e7      	bne.n	80142aa <axis_signals_tostring+0x1a>
    };

    *buf = '\0';
 80142da:	687b      	ldr	r3, [r7, #4]
 80142dc:	2200      	movs	r2, #0
 80142de:	701a      	strb	r2, [r3, #0]

    return buf;
 80142e0:	687b      	ldr	r3, [r7, #4]
}
 80142e2:	4618      	mov	r0, r3
 80142e4:	3714      	adds	r7, #20
 80142e6:	46bd      	mov	sp, r7
 80142e8:	bc80      	pop	{r7}
 80142ea:	4770      	bx	lr
 80142ec:	0803102c 	.word	0x0803102c

080142f0 <control_signals_tostring>:

// Convert control signals bits to string representation.
// NOTE: returns pointer to null terminator!
inline static char *control_signals_tostring (char *buf, control_signals_t signals)
{
 80142f0:	b480      	push	{r7}
 80142f2:	b085      	sub	sp, #20
 80142f4:	af00      	add	r7, sp, #0
 80142f6:	6078      	str	r0, [r7, #4]
 80142f8:	8039      	strh	r1, [r7, #0]
    static const char signals_map[] = "RHSDLTE FM    P ";

    char *map = (char *)signals_map;
 80142fa:	4b32      	ldr	r3, [pc, #200]	; (80143c4 <control_signals_tostring+0xd4>)
 80142fc:	60fb      	str	r3, [r7, #12]

    if(!hal.signals_cap.stop_disable)
 80142fe:	4b32      	ldr	r3, [pc, #200]	; (80143c8 <control_signals_tostring+0xd8>)
 8014300:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8014304:	f003 0320 	and.w	r3, r3, #32
 8014308:	b2db      	uxtb	r3, r3
 801430a:	2b00      	cmp	r3, #0
 801430c:	d108      	bne.n	8014320 <control_signals_tostring+0x30>
        signals.stop_disable = sys.flags.optional_stop_disable;
 801430e:	4b2f      	ldr	r3, [pc, #188]	; (80143cc <control_signals_tostring+0xdc>)
 8014310:	7d9b      	ldrb	r3, [r3, #22]
 8014312:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8014316:	b2da      	uxtb	r2, r3
 8014318:	783b      	ldrb	r3, [r7, #0]
 801431a:	f362 1345 	bfi	r3, r2, #5, #1
 801431e:	703b      	strb	r3, [r7, #0]

    if(!signals.deasserted)
 8014320:	787b      	ldrb	r3, [r7, #1]
 8014322:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014326:	b2db      	uxtb	r3, r3
 8014328:	2b00      	cmp	r3, #0
 801432a:	d142      	bne.n	80143b2 <control_signals_tostring+0xc2>
      while(signals.mask) {
 801432c:	e03e      	b.n	80143ac <control_signals_tostring+0xbc>

        if(signals.mask & 0x01) {
 801432e:	883b      	ldrh	r3, [r7, #0]
 8014330:	f003 0301 	and.w	r3, r3, #1
 8014334:	2b00      	cmp	r3, #0
 8014336:	d032      	beq.n	801439e <control_signals_tostring+0xae>

            switch(*map) {
 8014338:	68fb      	ldr	r3, [r7, #12]
 801433a:	781b      	ldrb	r3, [r3, #0]
 801433c:	2b4c      	cmp	r3, #76	; 0x4c
 801433e:	d014      	beq.n	801436a <control_signals_tostring+0x7a>
 8014340:	2b4c      	cmp	r3, #76	; 0x4c
 8014342:	dc20      	bgt.n	8014386 <control_signals_tostring+0x96>
 8014344:	2b20      	cmp	r3, #32
 8014346:	d025      	beq.n	8014394 <control_signals_tostring+0xa4>
 8014348:	2b44      	cmp	r3, #68	; 0x44
 801434a:	d11c      	bne.n	8014386 <control_signals_tostring+0x96>

                case ' ':
                    break;

                case 'D':
                    if(hal.signals_cap.safety_door_ajar)
 801434c:	4b1e      	ldr	r3, [pc, #120]	; (80143c8 <control_signals_tostring+0xd8>)
 801434e:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8014352:	f003 0308 	and.w	r3, r3, #8
 8014356:	b2db      	uxtb	r3, r3
 8014358:	2b00      	cmp	r3, #0
 801435a:	d01d      	beq.n	8014398 <control_signals_tostring+0xa8>
                        *buf++ = *map;
 801435c:	687b      	ldr	r3, [r7, #4]
 801435e:	1c5a      	adds	r2, r3, #1
 8014360:	607a      	str	r2, [r7, #4]
 8014362:	68fa      	ldr	r2, [r7, #12]
 8014364:	7812      	ldrb	r2, [r2, #0]
 8014366:	701a      	strb	r2, [r3, #0]
                    break;
 8014368:	e016      	b.n	8014398 <control_signals_tostring+0xa8>

                case 'L':
                    if(sys.flags.block_delete_enabled)
 801436a:	4b18      	ldr	r3, [pc, #96]	; (80143cc <control_signals_tostring+0xdc>)
 801436c:	7d9b      	ldrb	r3, [r3, #22]
 801436e:	f003 0310 	and.w	r3, r3, #16
 8014372:	b2db      	uxtb	r3, r3
 8014374:	2b00      	cmp	r3, #0
 8014376:	d011      	beq.n	801439c <control_signals_tostring+0xac>
                        *buf++ = *map;
 8014378:	687b      	ldr	r3, [r7, #4]
 801437a:	1c5a      	adds	r2, r3, #1
 801437c:	607a      	str	r2, [r7, #4]
 801437e:	68fa      	ldr	r2, [r7, #12]
 8014380:	7812      	ldrb	r2, [r2, #0]
 8014382:	701a      	strb	r2, [r3, #0]
                    break;
 8014384:	e00a      	b.n	801439c <control_signals_tostring+0xac>

                default:
                    *buf++ = *map;
 8014386:	687b      	ldr	r3, [r7, #4]
 8014388:	1c5a      	adds	r2, r3, #1
 801438a:	607a      	str	r2, [r7, #4]
 801438c:	68fa      	ldr	r2, [r7, #12]
 801438e:	7812      	ldrb	r2, [r2, #0]
 8014390:	701a      	strb	r2, [r3, #0]
                    break;
 8014392:	e004      	b.n	801439e <control_signals_tostring+0xae>
                    break;
 8014394:	bf00      	nop
 8014396:	e002      	b.n	801439e <control_signals_tostring+0xae>
                    break;
 8014398:	bf00      	nop
 801439a:	e000      	b.n	801439e <control_signals_tostring+0xae>
                    break;
 801439c:	bf00      	nop
            }
        }

        map++;
 801439e:	68fb      	ldr	r3, [r7, #12]
 80143a0:	3301      	adds	r3, #1
 80143a2:	60fb      	str	r3, [r7, #12]
        signals.mask >>= 1;
 80143a4:	883b      	ldrh	r3, [r7, #0]
 80143a6:	085b      	lsrs	r3, r3, #1
 80143a8:	b29b      	uxth	r3, r3
 80143aa:	803b      	strh	r3, [r7, #0]
      while(signals.mask) {
 80143ac:	883b      	ldrh	r3, [r7, #0]
 80143ae:	2b00      	cmp	r3, #0
 80143b0:	d1bd      	bne.n	801432e <control_signals_tostring+0x3e>
    }

    *buf = '\0';
 80143b2:	687b      	ldr	r3, [r7, #4]
 80143b4:	2200      	movs	r2, #0
 80143b6:	701a      	strb	r2, [r3, #0]

    return buf;
 80143b8:	687b      	ldr	r3, [r7, #4]
}
 80143ba:	4618      	mov	r0, r3
 80143bc:	3714      	adds	r7, #20
 80143be:	46bd      	mov	sp, r7
 80143c0:	bc80      	pop	{r7}
 80143c2:	4770      	bx	lr
 80143c4:	08031454 	.word	0x08031454
 80143c8:	20000ed0 	.word	0x20000ed0
 80143cc:	20000d3c 	.word	0x20000d3c

080143d0 <report_init>:

void report_init (void)
{
 80143d0:	b480      	push	{r7}
 80143d2:	af00      	add	r7, sp, #0
    get_axis_value = settings.flags.report_inches ? get_axis_value_inches : get_axis_value_mm;
 80143d4:	4b15      	ldr	r3, [pc, #84]	; (801442c <report_init+0x5c>)
 80143d6:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80143da:	f003 0301 	and.w	r3, r3, #1
 80143de:	b2db      	uxtb	r3, r3
 80143e0:	2b00      	cmp	r3, #0
 80143e2:	d001      	beq.n	80143e8 <report_init+0x18>
 80143e4:	4b12      	ldr	r3, [pc, #72]	; (8014430 <report_init+0x60>)
 80143e6:	e000      	b.n	80143ea <report_init+0x1a>
 80143e8:	4b12      	ldr	r3, [pc, #72]	; (8014434 <report_init+0x64>)
 80143ea:	4a13      	ldr	r2, [pc, #76]	; (8014438 <report_init+0x68>)
 80143ec:	6013      	str	r3, [r2, #0]
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 80143ee:	4b0f      	ldr	r3, [pc, #60]	; (801442c <report_init+0x5c>)
 80143f0:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80143f4:	f003 0301 	and.w	r3, r3, #1
 80143f8:	b2db      	uxtb	r3, r3
 80143fa:	2b00      	cmp	r3, #0
 80143fc:	d001      	beq.n	8014402 <report_init+0x32>
 80143fe:	4b0f      	ldr	r3, [pc, #60]	; (801443c <report_init+0x6c>)
 8014400:	e000      	b.n	8014404 <report_init+0x34>
 8014402:	4b0f      	ldr	r3, [pc, #60]	; (8014440 <report_init+0x70>)
 8014404:	4a0f      	ldr	r2, [pc, #60]	; (8014444 <report_init+0x74>)
 8014406:	6013      	str	r3, [r2, #0]
    get_rate_value = settings.flags.report_inches ? get_rate_value_inch : get_rate_value_mm;
 8014408:	4b08      	ldr	r3, [pc, #32]	; (801442c <report_init+0x5c>)
 801440a:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801440e:	f003 0301 	and.w	r3, r3, #1
 8014412:	b2db      	uxtb	r3, r3
 8014414:	2b00      	cmp	r3, #0
 8014416:	d001      	beq.n	801441c <report_init+0x4c>
 8014418:	4b0b      	ldr	r3, [pc, #44]	; (8014448 <report_init+0x78>)
 801441a:	e000      	b.n	801441e <report_init+0x4e>
 801441c:	4b0b      	ldr	r3, [pc, #44]	; (801444c <report_init+0x7c>)
 801441e:	4a0c      	ldr	r2, [pc, #48]	; (8014450 <report_init+0x80>)
 8014420:	6013      	str	r3, [r2, #0]
}
 8014422:	bf00      	nop
 8014424:	46bd      	mov	sp, r7
 8014426:	bc80      	pop	{r7}
 8014428:	4770      	bx	lr
 801442a:	bf00      	nop
 801442c:	2000147c 	.word	0x2000147c
 8014430:	08014209 	.word	0x08014209
 8014434:	080141e1 	.word	0x080141e1
 8014438:	20001438 	.word	0x20001438
 801443c:	08014121 	.word	0x08014121
 8014440:	08014079 	.word	0x08014079
 8014444:	20001434 	.word	0x20001434
 8014448:	08014261 	.word	0x08014261
 801444c:	08014241 	.word	0x08014241
 8014450:	2000143c 	.word	0x2000143c

08014454 <report_status_message>:
// 'error:'  to indicate some error event with the line or some critical system error during
// operation. Errors events can originate from the g-code parser, settings module, or asynchronously
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
static status_code_t report_status_message (status_code_t status_code)
{
 8014454:	b590      	push	{r4, r7, lr}
 8014456:	b083      	sub	sp, #12
 8014458:	af00      	add	r7, sp, #0
 801445a:	4603      	mov	r3, r0
 801445c:	71fb      	strb	r3, [r7, #7]
    switch(status_code) {
 801445e:	79fb      	ldrb	r3, [r7, #7]
 8014460:	2b00      	cmp	r3, #0
 8014462:	d105      	bne.n	8014470 <report_status_message+0x1c>

        case Status_OK: // STATUS_OK
            hal.stream.write("ok" ASCII_EOL);
 8014464:	4b0d      	ldr	r3, [pc, #52]	; (801449c <report_status_message+0x48>)
 8014466:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801446a:	480d      	ldr	r0, [pc, #52]	; (80144a0 <report_status_message+0x4c>)
 801446c:	4798      	blx	r3
            break;
 801446e:	e010      	b.n	8014492 <report_status_message+0x3e>

        default:
            hal.stream.write(appendbuf(3, "error:", uitoa((uint32_t)status_code), ASCII_EOL));
 8014470:	4b0a      	ldr	r3, [pc, #40]	; (801449c <report_status_message+0x48>)
 8014472:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014476:	79fb      	ldrb	r3, [r7, #7]
 8014478:	4618      	mov	r0, r3
 801447a:	f7fb ff07 	bl	801028c <uitoa>
 801447e:	4602      	mov	r2, r0
 8014480:	4b08      	ldr	r3, [pc, #32]	; (80144a4 <report_status_message+0x50>)
 8014482:	4909      	ldr	r1, [pc, #36]	; (80144a8 <report_status_message+0x54>)
 8014484:	2003      	movs	r0, #3
 8014486:	f7ff fd91 	bl	8013fac <appendbuf>
 801448a:	4603      	mov	r3, r0
 801448c:	4618      	mov	r0, r3
 801448e:	47a0      	blx	r4
            break;
 8014490:	bf00      	nop
    }

    return status_code;
 8014492:	79fb      	ldrb	r3, [r7, #7]
}
 8014494:	4618      	mov	r0, r3
 8014496:	370c      	adds	r7, #12
 8014498:	46bd      	mov	sp, r7
 801449a:	bd90      	pop	{r4, r7, pc}
 801449c:	20000ed0 	.word	0x20000ed0
 80144a0:	0802b188 	.word	0x0802b188
 80144a4:	0802b190 	.word	0x0802b190
 80144a8:	0802b194 	.word	0x0802b194

080144ac <report_alarm_message>:

// Prints alarm messages.
static alarm_code_t report_alarm_message (alarm_code_t alarm_code)
{
 80144ac:	b590      	push	{r4, r7, lr}
 80144ae:	b083      	sub	sp, #12
 80144b0:	af00      	add	r7, sp, #0
 80144b2:	4603      	mov	r3, r0
 80144b4:	71fb      	strb	r3, [r7, #7]
    hal.stream.write_all(appendbuf(3, "ALARM:", uitoa((uint32_t)alarm_code), ASCII_EOL));
 80144b6:	4b0d      	ldr	r3, [pc, #52]	; (80144ec <report_alarm_message+0x40>)
 80144b8:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80144bc:	79fb      	ldrb	r3, [r7, #7]
 80144be:	4618      	mov	r0, r3
 80144c0:	f7fb fee4 	bl	801028c <uitoa>
 80144c4:	4602      	mov	r2, r0
 80144c6:	4b0a      	ldr	r3, [pc, #40]	; (80144f0 <report_alarm_message+0x44>)
 80144c8:	490a      	ldr	r1, [pc, #40]	; (80144f4 <report_alarm_message+0x48>)
 80144ca:	2003      	movs	r0, #3
 80144cc:	f7ff fd6e 	bl	8013fac <appendbuf>
 80144d0:	4603      	mov	r3, r0
 80144d2:	4618      	mov	r0, r3
 80144d4:	47a0      	blx	r4
    hal.delay_ms(100, NULL); // Force delay to ensure message clears output stream buffer.
 80144d6:	4b05      	ldr	r3, [pc, #20]	; (80144ec <report_alarm_message+0x40>)
 80144d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80144da:	2100      	movs	r1, #0
 80144dc:	2064      	movs	r0, #100	; 0x64
 80144de:	4798      	blx	r3

    return alarm_code;
 80144e0:	79fb      	ldrb	r3, [r7, #7]
}
 80144e2:	4618      	mov	r0, r3
 80144e4:	370c      	adds	r7, #12
 80144e6:	46bd      	mov	sp, r7
 80144e8:	bd90      	pop	{r4, r7, pc}
 80144ea:	bf00      	nop
 80144ec:	20000ed0 	.word	0x20000ed0
 80144f0:	0802b190 	.word	0x0802b190
 80144f4:	0802b19c 	.word	0x0802b19c

080144f8 <report_message>:

// Prints feedback message, typically from gcode.
void report_message (const char *msg, message_type_t type)
{
 80144f8:	b580      	push	{r7, lr}
 80144fa:	b082      	sub	sp, #8
 80144fc:	af00      	add	r7, sp, #0
 80144fe:	6078      	str	r0, [r7, #4]
 8014500:	460b      	mov	r3, r1
 8014502:	70fb      	strb	r3, [r7, #3]
    hal.stream.write("[MSG:");
 8014504:	4b12      	ldr	r3, [pc, #72]	; (8014550 <report_message+0x58>)
 8014506:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801450a:	4812      	ldr	r0, [pc, #72]	; (8014554 <report_message+0x5c>)
 801450c:	4798      	blx	r3

    switch(type) {
 801450e:	78fb      	ldrb	r3, [r7, #3]
 8014510:	2b01      	cmp	r3, #1
 8014512:	d002      	beq.n	801451a <report_message+0x22>
 8014514:	2b02      	cmp	r3, #2
 8014516:	d006      	beq.n	8014526 <report_message+0x2e>
        case Message_Warning:
            hal.stream.write("Warning: ");
            break;

        default:
            break;
 8014518:	e00b      	b.n	8014532 <report_message+0x3a>
            hal.stream.write("Info: ");
 801451a:	4b0d      	ldr	r3, [pc, #52]	; (8014550 <report_message+0x58>)
 801451c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014520:	480d      	ldr	r0, [pc, #52]	; (8014558 <report_message+0x60>)
 8014522:	4798      	blx	r3
            break;
 8014524:	e005      	b.n	8014532 <report_message+0x3a>
            hal.stream.write("Warning: ");
 8014526:	4b0a      	ldr	r3, [pc, #40]	; (8014550 <report_message+0x58>)
 8014528:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801452c:	480b      	ldr	r0, [pc, #44]	; (801455c <report_message+0x64>)
 801452e:	4798      	blx	r3
            break;
 8014530:	bf00      	nop
    }

    hal.stream.write(msg);
 8014532:	4b07      	ldr	r3, [pc, #28]	; (8014550 <report_message+0x58>)
 8014534:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014538:	6878      	ldr	r0, [r7, #4]
 801453a:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 801453c:	4b04      	ldr	r3, [pc, #16]	; (8014550 <report_message+0x58>)
 801453e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014542:	4807      	ldr	r0, [pc, #28]	; (8014560 <report_message+0x68>)
 8014544:	4798      	blx	r3
}
 8014546:	bf00      	nop
 8014548:	3708      	adds	r7, #8
 801454a:	46bd      	mov	sp, r7
 801454c:	bd80      	pop	{r7, pc}
 801454e:	bf00      	nop
 8014550:	20000ed0 	.word	0x20000ed0
 8014554:	0802b1a4 	.word	0x0802b1a4
 8014558:	0802b1ac 	.word	0x0802b1ac
 801455c:	0802b1b4 	.word	0x0802b1b4
 8014560:	0802b1c0 	.word	0x0802b1c0

08014564 <report_feedback_message>:
// user feedback for things that are not of the status/alarm message protocol. These are
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
static message_code_t report_feedback_message (message_code_t id)
{
 8014564:	b580      	push	{r7, lr}
 8014566:	b084      	sub	sp, #16
 8014568:	af00      	add	r7, sp, #0
 801456a:	4603      	mov	r3, r0
 801456c:	71fb      	strb	r3, [r7, #7]
    const message_t *msg = message_get(id);
 801456e:	79fb      	ldrb	r3, [r7, #7]
 8014570:	4618      	mov	r0, r3
 8014572:	f7f9 fa1b 	bl	800d9ac <message_get>
 8014576:	60f8      	str	r0, [r7, #12]

    report_message(msg ? msg->text : "", msg ? msg->type : Message_Plain);
 8014578:	68fb      	ldr	r3, [r7, #12]
 801457a:	2b00      	cmp	r3, #0
 801457c:	d002      	beq.n	8014584 <report_feedback_message+0x20>
 801457e:	68fb      	ldr	r3, [r7, #12]
 8014580:	685b      	ldr	r3, [r3, #4]
 8014582:	e000      	b.n	8014586 <report_feedback_message+0x22>
 8014584:	4b0e      	ldr	r3, [pc, #56]	; (80145c0 <report_feedback_message+0x5c>)
 8014586:	68fa      	ldr	r2, [r7, #12]
 8014588:	2a00      	cmp	r2, #0
 801458a:	d002      	beq.n	8014592 <report_feedback_message+0x2e>
 801458c:	68fa      	ldr	r2, [r7, #12]
 801458e:	7852      	ldrb	r2, [r2, #1]
 8014590:	e000      	b.n	8014594 <report_feedback_message+0x30>
 8014592:	2200      	movs	r2, #0
 8014594:	4611      	mov	r1, r2
 8014596:	4618      	mov	r0, r3
 8014598:	f7ff ffae 	bl	80144f8 <report_message>

    if(id == Message_None && grbl.on_gcode_message)
 801459c:	79fb      	ldrb	r3, [r7, #7]
 801459e:	2b00      	cmp	r3, #0
 80145a0:	d109      	bne.n	80145b6 <report_feedback_message+0x52>
 80145a2:	4b08      	ldr	r3, [pc, #32]	; (80145c4 <report_feedback_message+0x60>)
 80145a4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80145a8:	2b00      	cmp	r3, #0
 80145aa:	d004      	beq.n	80145b6 <report_feedback_message+0x52>
        grbl.on_gcode_message("");
 80145ac:	4b05      	ldr	r3, [pc, #20]	; (80145c4 <report_feedback_message+0x60>)
 80145ae:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80145b2:	4803      	ldr	r0, [pc, #12]	; (80145c0 <report_feedback_message+0x5c>)
 80145b4:	4798      	blx	r3

    return id;
 80145b6:	79fb      	ldrb	r3, [r7, #7]
}
 80145b8:	4618      	mov	r0, r3
 80145ba:	3710      	adds	r7, #16
 80145bc:	46bd      	mov	sp, r7
 80145be:	bd80      	pop	{r7, pc}
 80145c0:	0802b1c4 	.word	0x0802b1c4
 80145c4:	20000dd4 	.word	0x20000dd4

080145c8 <report_init_message>:

// Welcome message
static void report_init_message (void)
{
 80145c8:	b580      	push	{r7, lr}
 80145ca:	af00      	add	r7, sp, #0
    override_counter = wco_counter = 0;
 80145cc:	4b06      	ldr	r3, [pc, #24]	; (80145e8 <report_init_message+0x20>)
 80145ce:	2200      	movs	r2, #0
 80145d0:	701a      	strb	r2, [r3, #0]
 80145d2:	4b05      	ldr	r3, [pc, #20]	; (80145e8 <report_init_message+0x20>)
 80145d4:	781a      	ldrb	r2, [r3, #0]
 80145d6:	4b05      	ldr	r3, [pc, #20]	; (80145ec <report_init_message+0x24>)
 80145d8:	701a      	strb	r2, [r3, #0]
#if COMPATIBILITY_LEVEL == 0
    hal.stream.write_all(ASCII_EOL "GrblHAL " GRBL_VERSION " ['$' or '$HELP' for help]" ASCII_EOL);
 80145da:	4b05      	ldr	r3, [pc, #20]	; (80145f0 <report_init_message+0x28>)
 80145dc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80145e0:	4804      	ldr	r0, [pc, #16]	; (80145f4 <report_init_message+0x2c>)
 80145e2:	4798      	blx	r3
#else
    hal.stream.write_all(ASCII_EOL "Grbl " GRBL_VERSION " ['$' for help]" ASCII_EOL);
#endif
}
 80145e4:	bf00      	nop
 80145e6:	bd80      	pop	{r7, pc}
 80145e8:	20001441 	.word	0x20001441
 80145ec:	20001440 	.word	0x20001440
 80145f0:	20000ed0 	.word	0x20000ed0
 80145f4:	0802b1c8 	.word	0x0802b1c8

080145f8 <report_help_message>:

// grblHAL help message
static void report_help_message (void)
{
 80145f8:	b580      	push	{r7, lr}
 80145fa:	af00      	add	r7, sp, #0
    hal.stream.write("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H $B ~ ! ? ctrl-x]" ASCII_EOL);
 80145fc:	4b03      	ldr	r3, [pc, #12]	; (801460c <report_help_message+0x14>)
 80145fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014602:	4803      	ldr	r0, [pc, #12]	; (8014610 <report_help_message+0x18>)
 8014604:	4798      	blx	r3
}
 8014606:	bf00      	nop
 8014608:	bd80      	pop	{r7, pc}
 801460a:	bf00      	nop
 801460c:	20000ed0 	.word	0x20000ed0
 8014610:	0802b1f4 	.word	0x0802b1f4

08014614 <report_group_settings>:

static bool report_group_settings (const setting_group_detail_t *groups, const uint_fast8_t n_groups, char *args)
{
 8014614:	b580      	push	{r7, lr}
 8014616:	b08e      	sub	sp, #56	; 0x38
 8014618:	af00      	add	r7, sp, #0
 801461a:	60f8      	str	r0, [r7, #12]
 801461c:	60b9      	str	r1, [r7, #8]
 801461e:	607a      	str	r2, [r7, #4]
    bool found = false;
 8014620:	2300      	movs	r3, #0
 8014622:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint_fast8_t idx;
    char c, *s, group[26];

    for(idx = 0; idx < n_groups; idx++) {
 8014626:	2300      	movs	r3, #0
 8014628:	633b      	str	r3, [r7, #48]	; 0x30
 801462a:	e06a      	b.n	8014702 <report_group_settings+0xee>

        s = group;
 801462c:	f107 0310 	add.w	r3, r7, #16
 8014630:	62fb      	str	r3, [r7, #44]	; 0x2c
        strncpy(group, groups[idx].name, sizeof(group) - 1);
 8014632:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014634:	4613      	mov	r3, r2
 8014636:	005b      	lsls	r3, r3, #1
 8014638:	4413      	add	r3, r2
 801463a:	009b      	lsls	r3, r3, #2
 801463c:	461a      	mov	r2, r3
 801463e:	68fb      	ldr	r3, [r7, #12]
 8014640:	4413      	add	r3, r2
 8014642:	6859      	ldr	r1, [r3, #4]
 8014644:	f107 0310 	add.w	r3, r7, #16
 8014648:	2219      	movs	r2, #25
 801464a:	4618      	mov	r0, r3
 801464c:	f00f fb19 	bl	8023c82 <strncpy>

        // Uppercase group name
        while((c = *s))
 8014650:	e013      	b.n	801467a <report_group_settings+0x66>
            *s++ = CAPS(c);
 8014652:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8014656:	2b60      	cmp	r3, #96	; 0x60
 8014658:	d909      	bls.n	801466e <report_group_settings+0x5a>
 801465a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801465e:	2b7a      	cmp	r3, #122	; 0x7a
 8014660:	d805      	bhi.n	801466e <report_group_settings+0x5a>
 8014662:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8014666:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 801466a:	b2da      	uxtb	r2, r3
 801466c:	e001      	b.n	8014672 <report_group_settings+0x5e>
 801466e:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8014672:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014674:	1c59      	adds	r1, r3, #1
 8014676:	62f9      	str	r1, [r7, #44]	; 0x2c
 8014678:	701a      	strb	r2, [r3, #0]
        while((c = *s))
 801467a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801467c:	781b      	ldrb	r3, [r3, #0]
 801467e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8014682:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8014686:	2b00      	cmp	r3, #0
 8014688:	d1e3      	bne.n	8014652 <report_group_settings+0x3e>

        if((found = matchhere(args, group))) {
 801468a:	f107 0310 	add.w	r3, r7, #16
 801468e:	4619      	mov	r1, r3
 8014690:	6878      	ldr	r0, [r7, #4]
 8014692:	f7ff fc1e 	bl	8013ed2 <matchhere>
 8014696:	4603      	mov	r3, r0
 8014698:	2b00      	cmp	r3, #0
 801469a:	bf14      	ite	ne
 801469c:	2301      	movne	r3, #1
 801469e:	2300      	moveq	r3, #0
 80146a0:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 80146a4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80146a8:	2b00      	cmp	r3, #0
 80146aa:	d027      	beq.n	80146fc <report_group_settings+0xe8>
            hal.stream.write(ASCII_EOL "---- ");
 80146ac:	4b1a      	ldr	r3, [pc, #104]	; (8014718 <report_group_settings+0x104>)
 80146ae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80146b2:	481a      	ldr	r0, [pc, #104]	; (801471c <report_group_settings+0x108>)
 80146b4:	4798      	blx	r3
            hal.stream.write(groups[idx].name);
 80146b6:	4b18      	ldr	r3, [pc, #96]	; (8014718 <report_group_settings+0x104>)
 80146b8:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
 80146bc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80146be:	4613      	mov	r3, r2
 80146c0:	005b      	lsls	r3, r3, #1
 80146c2:	4413      	add	r3, r2
 80146c4:	009b      	lsls	r3, r3, #2
 80146c6:	461a      	mov	r2, r3
 80146c8:	68fb      	ldr	r3, [r7, #12]
 80146ca:	4413      	add	r3, r2
 80146cc:	685b      	ldr	r3, [r3, #4]
 80146ce:	4618      	mov	r0, r3
 80146d0:	4788      	blx	r1
            hal.stream.write(":" ASCII_EOL);
 80146d2:	4b11      	ldr	r3, [pc, #68]	; (8014718 <report_group_settings+0x104>)
 80146d4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80146d8:	4811      	ldr	r0, [pc, #68]	; (8014720 <report_group_settings+0x10c>)
 80146da:	4798      	blx	r3
            report_settings_details(SettingsFormat_HumanReadable, Setting_SettingsAll, groups[idx].id);
 80146dc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80146de:	4613      	mov	r3, r2
 80146e0:	005b      	lsls	r3, r3, #1
 80146e2:	4413      	add	r3, r2
 80146e4:	009b      	lsls	r3, r3, #2
 80146e6:	461a      	mov	r2, r3
 80146e8:	68fb      	ldr	r3, [r7, #12]
 80146ea:	4413      	add	r3, r2
 80146ec:	785b      	ldrb	r3, [r3, #1]
 80146ee:	461a      	mov	r2, r3
 80146f0:	f240 21e5 	movw	r1, #741	; 0x2e5
 80146f4:	2001      	movs	r0, #1
 80146f6:	f003 fa65 	bl	8017bc4 <report_settings_details>
            break;
 80146fa:	e006      	b.n	801470a <report_group_settings+0xf6>
    for(idx = 0; idx < n_groups; idx++) {
 80146fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80146fe:	3301      	adds	r3, #1
 8014700:	633b      	str	r3, [r7, #48]	; 0x30
 8014702:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014704:	68bb      	ldr	r3, [r7, #8]
 8014706:	429a      	cmp	r2, r3
 8014708:	d390      	bcc.n	801462c <report_group_settings+0x18>
        }
    }

    return found;
 801470a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 801470e:	4618      	mov	r0, r3
 8014710:	3738      	adds	r7, #56	; 0x38
 8014712:	46bd      	mov	sp, r7
 8014714:	bd80      	pop	{r7, pc}
 8014716:	bf00      	nop
 8014718:	20000ed0 	.word	0x20000ed0
 801471c:	0802b244 	.word	0x0802b244
 8014720:	0802b24c 	.word	0x0802b24c

08014724 <report_help>:

status_code_t report_help (char *args)
{
 8014724:	b580      	push	{r7, lr}
 8014726:	b086      	sub	sp, #24
 8014728:	af00      	add	r7, sp, #0
 801472a:	6078      	str	r0, [r7, #4]
    // Strip leading spaces
    while(*args == ' ')
 801472c:	e002      	b.n	8014734 <report_help+0x10>
        args++;
 801472e:	687b      	ldr	r3, [r7, #4]
 8014730:	3301      	adds	r3, #1
 8014732:	607b      	str	r3, [r7, #4]
    while(*args == ' ')
 8014734:	687b      	ldr	r3, [r7, #4]
 8014736:	781b      	ldrb	r3, [r3, #0]
 8014738:	2b20      	cmp	r3, #32
 801473a:	d0f8      	beq.n	801472e <report_help+0xa>

    if(*args == '\0') {
 801473c:	687b      	ldr	r3, [r7, #4]
 801473e:	781b      	ldrb	r3, [r3, #0]
 8014740:	2b00      	cmp	r3, #0
 8014742:	d113      	bne.n	801476c <report_help+0x48>

        hal.stream.write("Help topics:" ASCII_EOL);
 8014744:	4b46      	ldr	r3, [pc, #280]	; (8014860 <report_help+0x13c>)
 8014746:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801474a:	4846      	ldr	r0, [pc, #280]	; (8014864 <report_help+0x140>)
 801474c:	4798      	blx	r3
        hal.stream.write(" Commands" ASCII_EOL);
 801474e:	4b44      	ldr	r3, [pc, #272]	; (8014860 <report_help+0x13c>)
 8014750:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014754:	4844      	ldr	r0, [pc, #272]	; (8014868 <report_help+0x144>)
 8014756:	4798      	blx	r3
        hal.stream.write(" Settings" ASCII_EOL);
 8014758:	4b41      	ldr	r3, [pc, #260]	; (8014860 <report_help+0x13c>)
 801475a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801475e:	4843      	ldr	r0, [pc, #268]	; (801486c <report_help+0x148>)
 8014760:	4798      	blx	r3
        report_setting_group_details(false, " ");
 8014762:	4943      	ldr	r1, [pc, #268]	; (8014870 <report_help+0x14c>)
 8014764:	2000      	movs	r0, #0
 8014766:	f003 fd8f 	bl	8018288 <report_setting_group_details>
 801476a:	e074      	b.n	8014856 <report_help+0x132>

    } else {

        char c, *s = args;
 801476c:	687b      	ldr	r3, [r7, #4]
 801476e:	617b      	str	r3, [r7, #20]

        // Upper case argument
        while((c = *s))
 8014770:	e00f      	b.n	8014792 <report_help+0x6e>
            *s++ = CAPS(c);
 8014772:	7afb      	ldrb	r3, [r7, #11]
 8014774:	2b60      	cmp	r3, #96	; 0x60
 8014776:	d907      	bls.n	8014788 <report_help+0x64>
 8014778:	7afb      	ldrb	r3, [r7, #11]
 801477a:	2b7a      	cmp	r3, #122	; 0x7a
 801477c:	d804      	bhi.n	8014788 <report_help+0x64>
 801477e:	7afb      	ldrb	r3, [r7, #11]
 8014780:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 8014784:	b2da      	uxtb	r2, r3
 8014786:	e000      	b.n	801478a <report_help+0x66>
 8014788:	7afa      	ldrb	r2, [r7, #11]
 801478a:	697b      	ldr	r3, [r7, #20]
 801478c:	1c59      	adds	r1, r3, #1
 801478e:	6179      	str	r1, [r7, #20]
 8014790:	701a      	strb	r2, [r3, #0]
        while((c = *s))
 8014792:	697b      	ldr	r3, [r7, #20]
 8014794:	781b      	ldrb	r3, [r3, #0]
 8014796:	72fb      	strb	r3, [r7, #11]
 8014798:	7afb      	ldrb	r3, [r7, #11]
 801479a:	2b00      	cmp	r3, #0
 801479c:	d1e9      	bne.n	8014772 <report_help+0x4e>

        if(matchhere(args, "COMMANDS")) {
 801479e:	4935      	ldr	r1, [pc, #212]	; (8014874 <report_help+0x150>)
 80147a0:	6878      	ldr	r0, [r7, #4]
 80147a2:	f7ff fb96 	bl	8013ed2 <matchhere>
 80147a6:	4603      	mov	r3, r0
 80147a8:	2b00      	cmp	r3, #0
 80147aa:	d007      	beq.n	80147bc <report_help+0x98>
            if(grbl.on_report_command_help)
 80147ac:	4b32      	ldr	r3, [pc, #200]	; (8014878 <report_help+0x154>)
 80147ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80147b0:	2b00      	cmp	r3, #0
 80147b2:	d050      	beq.n	8014856 <report_help+0x132>
                grbl.on_report_command_help();
 80147b4:	4b30      	ldr	r3, [pc, #192]	; (8014878 <report_help+0x154>)
 80147b6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80147b8:	4798      	blx	r3
 80147ba:	e04c      	b.n	8014856 <report_help+0x132>

        } else if(matchhere(args, "SETTINGS"))
 80147bc:	492f      	ldr	r1, [pc, #188]	; (801487c <report_help+0x158>)
 80147be:	6878      	ldr	r0, [r7, #4]
 80147c0:	f7ff fb87 	bl	8013ed2 <matchhere>
 80147c4:	4603      	mov	r3, r0
 80147c6:	2b00      	cmp	r3, #0
 80147c8:	d006      	beq.n	80147d8 <report_help+0xb4>
            report_settings_details(SettingsFormat_HumanReadable, Setting_SettingsAll, Group_All);
 80147ca:	2200      	movs	r2, #0
 80147cc:	f240 21e5 	movw	r1, #741	; 0x2e5
 80147d0:	2001      	movs	r0, #1
 80147d2:	f003 f9f7 	bl	8017bc4 <report_settings_details>
 80147d6:	e03e      	b.n	8014856 <report_help+0x132>

        else {

            bool found = false;
 80147d8:	2300      	movs	r3, #0
 80147da:	74fb      	strb	r3, [r7, #19]
            setting_details_t *settings_info = settings_get_details();
 80147dc:	f004 fa9e 	bl	8018d1c <settings_get_details>
 80147e0:	60f8      	str	r0, [r7, #12]

            found = report_group_settings(settings_info->groups, settings_info->n_groups, args);
 80147e2:	68fb      	ldr	r3, [r7, #12]
 80147e4:	6858      	ldr	r0, [r3, #4]
 80147e6:	68fb      	ldr	r3, [r7, #12]
 80147e8:	781b      	ldrb	r3, [r3, #0]
 80147ea:	687a      	ldr	r2, [r7, #4]
 80147ec:	4619      	mov	r1, r3
 80147ee:	f7ff ff11 	bl	8014614 <report_group_settings>
 80147f2:	4603      	mov	r3, r0
 80147f4:	74fb      	strb	r3, [r7, #19]

            if(!found && (settings_info = settings_info->next)) do {
 80147f6:	7cfb      	ldrb	r3, [r7, #19]
 80147f8:	f083 0301 	eor.w	r3, r3, #1
 80147fc:	b2db      	uxtb	r3, r3
 80147fe:	2b00      	cmp	r3, #0
 8014800:	d01e      	beq.n	8014840 <report_help+0x11c>
 8014802:	68fb      	ldr	r3, [r7, #12]
 8014804:	699b      	ldr	r3, [r3, #24]
 8014806:	60fb      	str	r3, [r7, #12]
 8014808:	68fb      	ldr	r3, [r7, #12]
 801480a:	2b00      	cmp	r3, #0
 801480c:	d018      	beq.n	8014840 <report_help+0x11c>
                if(settings_info->groups && (found = report_group_settings(settings_info->groups, settings_info->n_groups, args)))
 801480e:	68fb      	ldr	r3, [r7, #12]
 8014810:	685b      	ldr	r3, [r3, #4]
 8014812:	2b00      	cmp	r3, #0
 8014814:	d00c      	beq.n	8014830 <report_help+0x10c>
 8014816:	68fb      	ldr	r3, [r7, #12]
 8014818:	6858      	ldr	r0, [r3, #4]
 801481a:	68fb      	ldr	r3, [r7, #12]
 801481c:	781b      	ldrb	r3, [r3, #0]
 801481e:	687a      	ldr	r2, [r7, #4]
 8014820:	4619      	mov	r1, r3
 8014822:	f7ff fef7 	bl	8014614 <report_group_settings>
 8014826:	4603      	mov	r3, r0
 8014828:	74fb      	strb	r3, [r7, #19]
 801482a:	7cfb      	ldrb	r3, [r7, #19]
 801482c:	2b00      	cmp	r3, #0
 801482e:	d106      	bne.n	801483e <report_help+0x11a>
                    break;
            } while((settings_info = settings_info->next));
 8014830:	68fb      	ldr	r3, [r7, #12]
 8014832:	699b      	ldr	r3, [r3, #24]
 8014834:	60fb      	str	r3, [r7, #12]
 8014836:	68fb      	ldr	r3, [r7, #12]
 8014838:	2b00      	cmp	r3, #0
 801483a:	d1e8      	bne.n	801480e <report_help+0xea>
 801483c:	e000      	b.n	8014840 <report_help+0x11c>
                    break;
 801483e:	bf00      	nop

            if(!found)
 8014840:	7cfb      	ldrb	r3, [r7, #19]
 8014842:	f083 0301 	eor.w	r3, r3, #1
 8014846:	b2db      	uxtb	r3, r3
 8014848:	2b00      	cmp	r3, #0
 801484a:	d004      	beq.n	8014856 <report_help+0x132>
                hal.stream.write( ASCII_EOL "N/A" ASCII_EOL);
 801484c:	4b04      	ldr	r3, [pc, #16]	; (8014860 <report_help+0x13c>)
 801484e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014852:	480b      	ldr	r0, [pc, #44]	; (8014880 <report_help+0x15c>)
 8014854:	4798      	blx	r3
        }
    }

    return Status_OK;
 8014856:	2300      	movs	r3, #0
}
 8014858:	4618      	mov	r0, r3
 801485a:	3718      	adds	r7, #24
 801485c:	46bd      	mov	sp, r7
 801485e:	bd80      	pop	{r7, pc}
 8014860:	20000ed0 	.word	0x20000ed0
 8014864:	0802b250 	.word	0x0802b250
 8014868:	0802b260 	.word	0x0802b260
 801486c:	0802b26c 	.word	0x0802b26c
 8014870:	0802b278 	.word	0x0802b278
 8014874:	0802b27c 	.word	0x0802b27c
 8014878:	20000dd4 	.word	0x20000dd4
 801487c:	0802b288 	.word	0x0802b288
 8014880:	0802b294 	.word	0x0802b294

08014884 <cmp_settings>:


// Grbl settings print out.

static int cmp_settings (const void *a, const void *b)
{
 8014884:	b480      	push	{r7}
 8014886:	b083      	sub	sp, #12
 8014888:	af00      	add	r7, sp, #0
 801488a:	6078      	str	r0, [r7, #4]
 801488c:	6039      	str	r1, [r7, #0]
  return (*(setting_detail_t **)(a))->id - (*(setting_detail_t **)(b))->id;
 801488e:	687b      	ldr	r3, [r7, #4]
 8014890:	681b      	ldr	r3, [r3, #0]
 8014892:	881b      	ldrh	r3, [r3, #0]
 8014894:	461a      	mov	r2, r3
 8014896:	683b      	ldr	r3, [r7, #0]
 8014898:	681b      	ldr	r3, [r3, #0]
 801489a:	881b      	ldrh	r3, [r3, #0]
 801489c:	1ad3      	subs	r3, r2, r3
}
 801489e:	4618      	mov	r0, r3
 80148a0:	370c      	adds	r7, #12
 80148a2:	46bd      	mov	sp, r7
 80148a4:	bc80      	pop	{r7}
 80148a6:	4770      	bx	lr

080148a8 <report_setting>:

static bool report_setting (const setting_detail_t *setting, uint_fast16_t offset, void *data)
{
 80148a8:	b580      	push	{r7, lr}
 80148aa:	b086      	sub	sp, #24
 80148ac:	af00      	add	r7, sp, #0
 80148ae:	60f8      	str	r0, [r7, #12]
 80148b0:	60b9      	str	r1, [r7, #8]
 80148b2:	607a      	str	r2, [r7, #4]
    appendbuf(3, "$", uitoa(setting->id + offset), "=");
 80148b4:	68fb      	ldr	r3, [r7, #12]
 80148b6:	881b      	ldrh	r3, [r3, #0]
 80148b8:	461a      	mov	r2, r3
 80148ba:	68bb      	ldr	r3, [r7, #8]
 80148bc:	4413      	add	r3, r2
 80148be:	4618      	mov	r0, r3
 80148c0:	f7fb fce4 	bl	801028c <uitoa>
 80148c4:	4602      	mov	r2, r0
 80148c6:	4b10      	ldr	r3, [pc, #64]	; (8014908 <report_setting+0x60>)
 80148c8:	4910      	ldr	r1, [pc, #64]	; (801490c <report_setting+0x64>)
 80148ca:	2003      	movs	r0, #3
 80148cc:	f7ff fb6e 	bl	8013fac <appendbuf>

    char *value = setting_get_value(setting, offset);
 80148d0:	68b9      	ldr	r1, [r7, #8]
 80148d2:	68f8      	ldr	r0, [r7, #12]
 80148d4:	f005 fd06 	bl	801a2e4 <setting_get_value>
 80148d8:	6178      	str	r0, [r7, #20]

    if(value) {
 80148da:	697b      	ldr	r3, [r7, #20]
 80148dc:	2b00      	cmp	r3, #0
 80148de:	d00e      	beq.n	80148fe <report_setting+0x56>
        hal.stream.write(buf);
 80148e0:	4b0b      	ldr	r3, [pc, #44]	; (8014910 <report_setting+0x68>)
 80148e2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80148e6:	480b      	ldr	r0, [pc, #44]	; (8014914 <report_setting+0x6c>)
 80148e8:	4798      	blx	r3
        hal.stream.write(value);
 80148ea:	4b09      	ldr	r3, [pc, #36]	; (8014910 <report_setting+0x68>)
 80148ec:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80148f0:	6978      	ldr	r0, [r7, #20]
 80148f2:	4798      	blx	r3
        hal.stream.write(ASCII_EOL);
 80148f4:	4b06      	ldr	r3, [pc, #24]	; (8014910 <report_setting+0x68>)
 80148f6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80148fa:	4807      	ldr	r0, [pc, #28]	; (8014918 <report_setting+0x70>)
 80148fc:	4798      	blx	r3
    }

    return true;
 80148fe:	2301      	movs	r3, #1
}
 8014900:	4618      	mov	r0, r3
 8014902:	3718      	adds	r7, #24
 8014904:	46bd      	mov	sp, r7
 8014906:	bd80      	pop	{r7, pc}
 8014908:	0802b29c 	.word	0x0802b29c
 801490c:	0802b2a0 	.word	0x0802b2a0
 8014910:	20000ed0 	.word	0x20000ed0
 8014914:	20001404 	.word	0x20001404
 8014918:	0802b190 	.word	0x0802b190

0801491c <report_grbl_setting>:

status_code_t report_grbl_setting (setting_id_t id, void *data)
{
 801491c:	b580      	push	{r7, lr}
 801491e:	b084      	sub	sp, #16
 8014920:	af00      	add	r7, sp, #0
 8014922:	4603      	mov	r3, r0
 8014924:	6039      	str	r1, [r7, #0]
 8014926:	80fb      	strh	r3, [r7, #6]
    status_code_t status = Status_OK;
 8014928:	2300      	movs	r3, #0
 801492a:	73fb      	strb	r3, [r7, #15]

    const setting_detail_t *setting = setting_get_details(id, NULL);
 801492c:	88fb      	ldrh	r3, [r7, #6]
 801492e:	2100      	movs	r1, #0
 8014930:	4618      	mov	r0, r3
 8014932:	f006 fc71 	bl	801b218 <setting_get_details>
 8014936:	60b8      	str	r0, [r7, #8]

    if(setting)
 8014938:	68bb      	ldr	r3, [r7, #8]
 801493a:	2b00      	cmp	r3, #0
 801493c:	d00a      	beq.n	8014954 <report_grbl_setting+0x38>
        grbl.report.setting(setting, id - setting->id, data);
 801493e:	4b09      	ldr	r3, [pc, #36]	; (8014964 <report_grbl_setting+0x48>)
 8014940:	695b      	ldr	r3, [r3, #20]
 8014942:	88fa      	ldrh	r2, [r7, #6]
 8014944:	68b9      	ldr	r1, [r7, #8]
 8014946:	8809      	ldrh	r1, [r1, #0]
 8014948:	1a52      	subs	r2, r2, r1
 801494a:	4611      	mov	r1, r2
 801494c:	683a      	ldr	r2, [r7, #0]
 801494e:	68b8      	ldr	r0, [r7, #8]
 8014950:	4798      	blx	r3
 8014952:	e001      	b.n	8014958 <report_grbl_setting+0x3c>
    else
        status = Status_SettingDisabled;
 8014954:	2335      	movs	r3, #53	; 0x35
 8014956:	73fb      	strb	r3, [r7, #15]

    return status;
 8014958:	7bfb      	ldrb	r3, [r7, #15]
}
 801495a:	4618      	mov	r0, r3
 801495c:	3710      	adds	r7, #16
 801495e:	46bd      	mov	sp, r7
 8014960:	bd80      	pop	{r7, pc}
 8014962:	bf00      	nop
 8014964:	20000dd4 	.word	0x20000dd4

08014968 <print_setting>:

static bool print_setting (const setting_detail_t *setting, uint_fast16_t offset, void *data)
{
 8014968:	b590      	push	{r4, r7, lr}
 801496a:	b085      	sub	sp, #20
 801496c:	af00      	add	r7, sp, #0
 801496e:	60f8      	str	r0, [r7, #12]
 8014970:	60b9      	str	r1, [r7, #8]
 8014972:	607a      	str	r2, [r7, #4]
    if(setting->value != NULL)
 8014974:	68fb      	ldr	r3, [r7, #12]
 8014976:	6a1b      	ldr	r3, [r3, #32]
 8014978:	2b00      	cmp	r3, #0
 801497a:	d006      	beq.n	801498a <print_setting+0x22>
        grbl.report.setting(setting, offset, data);
 801497c:	4b10      	ldr	r3, [pc, #64]	; (80149c0 <print_setting+0x58>)
 801497e:	695b      	ldr	r3, [r3, #20]
 8014980:	687a      	ldr	r2, [r7, #4]
 8014982:	68b9      	ldr	r1, [r7, #8]
 8014984:	68f8      	ldr	r0, [r7, #12]
 8014986:	4798      	blx	r3
 8014988:	e014      	b.n	80149b4 <print_setting+0x4c>
    else {
        hal.stream.write("$");
 801498a:	4b0e      	ldr	r3, [pc, #56]	; (80149c4 <print_setting+0x5c>)
 801498c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014990:	480d      	ldr	r0, [pc, #52]	; (80149c8 <print_setting+0x60>)
 8014992:	4798      	blx	r3
        hal.stream.write(uitoa(setting->id));
 8014994:	4b0b      	ldr	r3, [pc, #44]	; (80149c4 <print_setting+0x5c>)
 8014996:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 801499a:	68fb      	ldr	r3, [r7, #12]
 801499c:	881b      	ldrh	r3, [r3, #0]
 801499e:	4618      	mov	r0, r3
 80149a0:	f7fb fc74 	bl	801028c <uitoa>
 80149a4:	4603      	mov	r3, r0
 80149a6:	4618      	mov	r0, r3
 80149a8:	47a0      	blx	r4
        hal.stream.write("=N/A" ASCII_EOL);
 80149aa:	4b06      	ldr	r3, [pc, #24]	; (80149c4 <print_setting+0x5c>)
 80149ac:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80149b0:	4806      	ldr	r0, [pc, #24]	; (80149cc <print_setting+0x64>)
 80149b2:	4798      	blx	r3
    }

    return true;
 80149b4:	2301      	movs	r3, #1
}
 80149b6:	4618      	mov	r0, r3
 80149b8:	3714      	adds	r7, #20
 80149ba:	46bd      	mov	sp, r7
 80149bc:	bd90      	pop	{r4, r7, pc}
 80149be:	bf00      	nop
 80149c0:	20000dd4 	.word	0x20000dd4
 80149c4:	20000ed0 	.word	0x20000ed0
 80149c8:	0802b2a0 	.word	0x0802b2a0
 80149cc:	0802b2a4 	.word	0x0802b2a4

080149d0 <report_grbl_settings>:

void report_grbl_settings (bool all, void *data)
{
 80149d0:	b580      	push	{r7, lr}
 80149d2:	b088      	sub	sp, #32
 80149d4:	af00      	add	r7, sp, #0
 80149d6:	4603      	mov	r3, r0
 80149d8:	6039      	str	r1, [r7, #0]
 80149da:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx, n_settings = 0;
 80149dc:	2300      	movs	r3, #0
 80149de:	61bb      	str	r3, [r7, #24]
    const setting_detail_t *setting;
    setting_detail_t **all_settings, **psetting;
    setting_details_t *details = settings_get_details();
 80149e0:	f004 f99c 	bl	8018d1c <settings_get_details>
 80149e4:	6138      	str	r0, [r7, #16]

    do {
        n_settings += details->n_settings;
 80149e6:	693b      	ldr	r3, [r7, #16]
 80149e8:	891b      	ldrh	r3, [r3, #8]
 80149ea:	461a      	mov	r2, r3
 80149ec:	69bb      	ldr	r3, [r7, #24]
 80149ee:	4413      	add	r3, r2
 80149f0:	61bb      	str	r3, [r7, #24]
    } while((details = details->next));
 80149f2:	693b      	ldr	r3, [r7, #16]
 80149f4:	699b      	ldr	r3, [r3, #24]
 80149f6:	613b      	str	r3, [r7, #16]
 80149f8:	693b      	ldr	r3, [r7, #16]
 80149fa:	2b00      	cmp	r3, #0
 80149fc:	d1f3      	bne.n	80149e6 <report_grbl_settings+0x16>

    details = settings_get_details();
 80149fe:	f004 f98d 	bl	8018d1c <settings_get_details>
 8014a02:	6138      	str	r0, [r7, #16]

    if((all_settings = psetting = calloc(n_settings, sizeof(setting_detail_t *)))) {
 8014a04:	2104      	movs	r1, #4
 8014a06:	69b8      	ldr	r0, [r7, #24]
 8014a08:	f00e fd20 	bl	802344c <calloc>
 8014a0c:	4603      	mov	r3, r0
 8014a0e:	617b      	str	r3, [r7, #20]
 8014a10:	697b      	ldr	r3, [r7, #20]
 8014a12:	60fb      	str	r3, [r7, #12]
 8014a14:	68fb      	ldr	r3, [r7, #12]
 8014a16:	2b00      	cmp	r3, #0
 8014a18:	f000 808a 	beq.w	8014b30 <report_grbl_settings+0x160>

        n_settings = 0;
 8014a1c:	2300      	movs	r3, #0
 8014a1e:	61bb      	str	r3, [r7, #24]

        // Report core settings
        for(idx = 0; idx < details->n_settings; idx++) {
 8014a20:	2300      	movs	r3, #0
 8014a22:	61fb      	str	r3, [r7, #28]
 8014a24:	e029      	b.n	8014a7a <report_grbl_settings+0xaa>
            setting = &details->settings[idx];
 8014a26:	693b      	ldr	r3, [r7, #16]
 8014a28:	68d9      	ldr	r1, [r3, #12]
 8014a2a:	69fa      	ldr	r2, [r7, #28]
 8014a2c:	4613      	mov	r3, r2
 8014a2e:	005b      	lsls	r3, r3, #1
 8014a30:	4413      	add	r3, r2
 8014a32:	011b      	lsls	r3, r3, #4
 8014a34:	440b      	add	r3, r1
 8014a36:	60bb      	str	r3, [r7, #8]
            if((all || setting->type == Setting_IsLegacy || setting->type == Setting_IsLegacyFn) &&
 8014a38:	79fb      	ldrb	r3, [r7, #7]
 8014a3a:	2b00      	cmp	r3, #0
 8014a3c:	d107      	bne.n	8014a4e <report_grbl_settings+0x7e>
 8014a3e:	68bb      	ldr	r3, [r7, #8]
 8014a40:	7f1b      	ldrb	r3, [r3, #28]
 8014a42:	2b04      	cmp	r3, #4
 8014a44:	d003      	beq.n	8014a4e <report_grbl_settings+0x7e>
 8014a46:	68bb      	ldr	r3, [r7, #8]
 8014a48:	7f1b      	ldrb	r3, [r3, #28]
 8014a4a:	2b05      	cmp	r3, #5
 8014a4c:	d112      	bne.n	8014a74 <report_grbl_settings+0xa4>
                  (setting->is_available == NULL ||setting->is_available(setting))) {
 8014a4e:	68bb      	ldr	r3, [r7, #8]
 8014a50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
            if((all || setting->type == Setting_IsLegacy || setting->type == Setting_IsLegacyFn) &&
 8014a52:	2b00      	cmp	r3, #0
 8014a54:	d006      	beq.n	8014a64 <report_grbl_settings+0x94>
                  (setting->is_available == NULL ||setting->is_available(setting))) {
 8014a56:	68bb      	ldr	r3, [r7, #8]
 8014a58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a5a:	68b8      	ldr	r0, [r7, #8]
 8014a5c:	4798      	blx	r3
 8014a5e:	4603      	mov	r3, r0
 8014a60:	2b00      	cmp	r3, #0
 8014a62:	d007      	beq.n	8014a74 <report_grbl_settings+0xa4>
                *psetting++ = (setting_detail_t *)setting;
 8014a64:	697b      	ldr	r3, [r7, #20]
 8014a66:	1d1a      	adds	r2, r3, #4
 8014a68:	617a      	str	r2, [r7, #20]
 8014a6a:	68ba      	ldr	r2, [r7, #8]
 8014a6c:	601a      	str	r2, [r3, #0]
                n_settings++;
 8014a6e:	69bb      	ldr	r3, [r7, #24]
 8014a70:	3301      	adds	r3, #1
 8014a72:	61bb      	str	r3, [r7, #24]
        for(idx = 0; idx < details->n_settings; idx++) {
 8014a74:	69fb      	ldr	r3, [r7, #28]
 8014a76:	3301      	adds	r3, #1
 8014a78:	61fb      	str	r3, [r7, #28]
 8014a7a:	693b      	ldr	r3, [r7, #16]
 8014a7c:	891b      	ldrh	r3, [r3, #8]
 8014a7e:	461a      	mov	r2, r3
 8014a80:	69fb      	ldr	r3, [r7, #28]
 8014a82:	4293      	cmp	r3, r2
 8014a84:	d3cf      	bcc.n	8014a26 <report_grbl_settings+0x56>
            }
        }

        // Report driver and plugin settings
        if(all && (details = details->next)) do {
 8014a86:	79fb      	ldrb	r3, [r7, #7]
 8014a88:	2b00      	cmp	r3, #0
 8014a8a:	d033      	beq.n	8014af4 <report_grbl_settings+0x124>
 8014a8c:	693b      	ldr	r3, [r7, #16]
 8014a8e:	699b      	ldr	r3, [r3, #24]
 8014a90:	613b      	str	r3, [r7, #16]
 8014a92:	693b      	ldr	r3, [r7, #16]
 8014a94:	2b00      	cmp	r3, #0
 8014a96:	d02d      	beq.n	8014af4 <report_grbl_settings+0x124>
            for(idx = 0; idx < details->n_settings; idx++) {
 8014a98:	2300      	movs	r3, #0
 8014a9a:	61fb      	str	r3, [r7, #28]
 8014a9c:	e01e      	b.n	8014adc <report_grbl_settings+0x10c>
                setting = &details->settings[idx];
 8014a9e:	693b      	ldr	r3, [r7, #16]
 8014aa0:	68d9      	ldr	r1, [r3, #12]
 8014aa2:	69fa      	ldr	r2, [r7, #28]
 8014aa4:	4613      	mov	r3, r2
 8014aa6:	005b      	lsls	r3, r3, #1
 8014aa8:	4413      	add	r3, r2
 8014aaa:	011b      	lsls	r3, r3, #4
 8014aac:	440b      	add	r3, r1
 8014aae:	60bb      	str	r3, [r7, #8]
                if(setting->is_available == NULL ||setting->is_available(setting)) {
 8014ab0:	68bb      	ldr	r3, [r7, #8]
 8014ab2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014ab4:	2b00      	cmp	r3, #0
 8014ab6:	d006      	beq.n	8014ac6 <report_grbl_settings+0xf6>
 8014ab8:	68bb      	ldr	r3, [r7, #8]
 8014aba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014abc:	68b8      	ldr	r0, [r7, #8]
 8014abe:	4798      	blx	r3
 8014ac0:	4603      	mov	r3, r0
 8014ac2:	2b00      	cmp	r3, #0
 8014ac4:	d007      	beq.n	8014ad6 <report_grbl_settings+0x106>
                    *psetting++ = (setting_detail_t *)setting;
 8014ac6:	697b      	ldr	r3, [r7, #20]
 8014ac8:	1d1a      	adds	r2, r3, #4
 8014aca:	617a      	str	r2, [r7, #20]
 8014acc:	68ba      	ldr	r2, [r7, #8]
 8014ace:	601a      	str	r2, [r3, #0]
                    n_settings++;
 8014ad0:	69bb      	ldr	r3, [r7, #24]
 8014ad2:	3301      	adds	r3, #1
 8014ad4:	61bb      	str	r3, [r7, #24]
            for(idx = 0; idx < details->n_settings; idx++) {
 8014ad6:	69fb      	ldr	r3, [r7, #28]
 8014ad8:	3301      	adds	r3, #1
 8014ada:	61fb      	str	r3, [r7, #28]
 8014adc:	693b      	ldr	r3, [r7, #16]
 8014ade:	891b      	ldrh	r3, [r3, #8]
 8014ae0:	461a      	mov	r2, r3
 8014ae2:	69fb      	ldr	r3, [r7, #28]
 8014ae4:	4293      	cmp	r3, r2
 8014ae6:	d3da      	bcc.n	8014a9e <report_grbl_settings+0xce>
                }
            }
        } while((details = details->next));
 8014ae8:	693b      	ldr	r3, [r7, #16]
 8014aea:	699b      	ldr	r3, [r3, #24]
 8014aec:	613b      	str	r3, [r7, #16]
 8014aee:	693b      	ldr	r3, [r7, #16]
 8014af0:	2b00      	cmp	r3, #0
 8014af2:	d1d1      	bne.n	8014a98 <report_grbl_settings+0xc8>

        qsort(all_settings, n_settings, sizeof(setting_detail_t *), cmp_settings);
 8014af4:	4b1f      	ldr	r3, [pc, #124]	; (8014b74 <report_grbl_settings+0x1a4>)
 8014af6:	2204      	movs	r2, #4
 8014af8:	69b9      	ldr	r1, [r7, #24]
 8014afa:	68f8      	ldr	r0, [r7, #12]
 8014afc:	f00e fe12 	bl	8023724 <qsort>

        for(idx = 0; idx < n_settings; idx++)
 8014b00:	2300      	movs	r3, #0
 8014b02:	61fb      	str	r3, [r7, #28]
 8014b04:	e00c      	b.n	8014b20 <report_grbl_settings+0x150>
            settings_iterator(all_settings[idx], print_setting, data);
 8014b06:	69fb      	ldr	r3, [r7, #28]
 8014b08:	009b      	lsls	r3, r3, #2
 8014b0a:	68fa      	ldr	r2, [r7, #12]
 8014b0c:	4413      	add	r3, r2
 8014b0e:	681b      	ldr	r3, [r3, #0]
 8014b10:	683a      	ldr	r2, [r7, #0]
 8014b12:	4919      	ldr	r1, [pc, #100]	; (8014b78 <report_grbl_settings+0x1a8>)
 8014b14:	4618      	mov	r0, r3
 8014b16:	f006 fb1f 	bl	801b158 <settings_iterator>
        for(idx = 0; idx < n_settings; idx++)
 8014b1a:	69fb      	ldr	r3, [r7, #28]
 8014b1c:	3301      	adds	r3, #1
 8014b1e:	61fb      	str	r3, [r7, #28]
 8014b20:	69fa      	ldr	r2, [r7, #28]
 8014b22:	69bb      	ldr	r3, [r7, #24]
 8014b24:	429a      	cmp	r2, r3
 8014b26:	d3ee      	bcc.n	8014b06 <report_grbl_settings+0x136>

        free(all_settings);
 8014b28:	68f8      	ldr	r0, [r7, #12]
 8014b2a:	f00e fccd 	bl	80234c8 <free>

    } else do {
        for(idx = 0; idx < n_settings; idx++)
            settings_iterator(&details->settings[idx], print_setting, data);
    } while((details = details->next));
}
 8014b2e:	e01c      	b.n	8014b6a <report_grbl_settings+0x19a>
        for(idx = 0; idx < n_settings; idx++)
 8014b30:	2300      	movs	r3, #0
 8014b32:	61fb      	str	r3, [r7, #28]
 8014b34:	e00f      	b.n	8014b56 <report_grbl_settings+0x186>
            settings_iterator(&details->settings[idx], print_setting, data);
 8014b36:	693b      	ldr	r3, [r7, #16]
 8014b38:	68d9      	ldr	r1, [r3, #12]
 8014b3a:	69fa      	ldr	r2, [r7, #28]
 8014b3c:	4613      	mov	r3, r2
 8014b3e:	005b      	lsls	r3, r3, #1
 8014b40:	4413      	add	r3, r2
 8014b42:	011b      	lsls	r3, r3, #4
 8014b44:	440b      	add	r3, r1
 8014b46:	683a      	ldr	r2, [r7, #0]
 8014b48:	490b      	ldr	r1, [pc, #44]	; (8014b78 <report_grbl_settings+0x1a8>)
 8014b4a:	4618      	mov	r0, r3
 8014b4c:	f006 fb04 	bl	801b158 <settings_iterator>
        for(idx = 0; idx < n_settings; idx++)
 8014b50:	69fb      	ldr	r3, [r7, #28]
 8014b52:	3301      	adds	r3, #1
 8014b54:	61fb      	str	r3, [r7, #28]
 8014b56:	69fa      	ldr	r2, [r7, #28]
 8014b58:	69bb      	ldr	r3, [r7, #24]
 8014b5a:	429a      	cmp	r2, r3
 8014b5c:	d3eb      	bcc.n	8014b36 <report_grbl_settings+0x166>
    } while((details = details->next));
 8014b5e:	693b      	ldr	r3, [r7, #16]
 8014b60:	699b      	ldr	r3, [r3, #24]
 8014b62:	613b      	str	r3, [r7, #16]
 8014b64:	693b      	ldr	r3, [r7, #16]
 8014b66:	2b00      	cmp	r3, #0
 8014b68:	d1e2      	bne.n	8014b30 <report_grbl_settings+0x160>
}
 8014b6a:	bf00      	nop
 8014b6c:	3720      	adds	r7, #32
 8014b6e:	46bd      	mov	sp, r7
 8014b70:	bd80      	pop	{r7, pc}
 8014b72:	bf00      	nop
 8014b74:	08014885 	.word	0x08014885
 8014b78:	08014969 	.word	0x08014969

08014b7c <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported).
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters (void)
{
 8014b7c:	b590      	push	{r4, r7, lr}
 8014b7e:	b085      	sub	sp, #20
 8014b80:	af00      	add	r7, sp, #0
    // Report in terms of machine position.
    float print_position[N_AXIS];
    system_convert_array_steps_to_mpos(print_position, sys.probe_position);
 8014b82:	1d3b      	adds	r3, r7, #4
 8014b84:	4915      	ldr	r1, [pc, #84]	; (8014bdc <report_probe_parameters+0x60>)
 8014b86:	4618      	mov	r0, r3
 8014b88:	f00d f942 	bl	8021e10 <system_convert_array_steps_to_mpos>
    hal.stream.write("[PRB:");
 8014b8c:	4b14      	ldr	r3, [pc, #80]	; (8014be0 <report_probe_parameters+0x64>)
 8014b8e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014b92:	4814      	ldr	r0, [pc, #80]	; (8014be4 <report_probe_parameters+0x68>)
 8014b94:	4798      	blx	r3
    hal.stream.write(get_axis_values(print_position));
 8014b96:	4b12      	ldr	r3, [pc, #72]	; (8014be0 <report_probe_parameters+0x64>)
 8014b98:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014b9c:	4b12      	ldr	r3, [pc, #72]	; (8014be8 <report_probe_parameters+0x6c>)
 8014b9e:	681b      	ldr	r3, [r3, #0]
 8014ba0:	1d3a      	adds	r2, r7, #4
 8014ba2:	4610      	mov	r0, r2
 8014ba4:	4798      	blx	r3
 8014ba6:	4603      	mov	r3, r0
 8014ba8:	4618      	mov	r0, r3
 8014baa:	47a0      	blx	r4
    hal.stream.write(sys.flags.probe_succeeded ? ":1" : ":0");
 8014bac:	4b0c      	ldr	r3, [pc, #48]	; (8014be0 <report_probe_parameters+0x64>)
 8014bae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014bb2:	4a0e      	ldr	r2, [pc, #56]	; (8014bec <report_probe_parameters+0x70>)
 8014bb4:	7d92      	ldrb	r2, [r2, #22]
 8014bb6:	f002 0202 	and.w	r2, r2, #2
 8014bba:	b2d2      	uxtb	r2, r2
 8014bbc:	2a00      	cmp	r2, #0
 8014bbe:	d001      	beq.n	8014bc4 <report_probe_parameters+0x48>
 8014bc0:	4a0b      	ldr	r2, [pc, #44]	; (8014bf0 <report_probe_parameters+0x74>)
 8014bc2:	e000      	b.n	8014bc6 <report_probe_parameters+0x4a>
 8014bc4:	4a0b      	ldr	r2, [pc, #44]	; (8014bf4 <report_probe_parameters+0x78>)
 8014bc6:	4610      	mov	r0, r2
 8014bc8:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8014bca:	4b05      	ldr	r3, [pc, #20]	; (8014be0 <report_probe_parameters+0x64>)
 8014bcc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014bd0:	4809      	ldr	r0, [pc, #36]	; (8014bf8 <report_probe_parameters+0x7c>)
 8014bd2:	4798      	blx	r3
}
 8014bd4:	bf00      	nop
 8014bd6:	3714      	adds	r7, #20
 8014bd8:	46bd      	mov	sp, r7
 8014bda:	bd90      	pop	{r4, r7, pc}
 8014bdc:	20000d74 	.word	0x20000d74
 8014be0:	20000ed0 	.word	0x20000ed0
 8014be4:	0802b2ac 	.word	0x0802b2ac
 8014be8:	20001434 	.word	0x20001434
 8014bec:	20000d3c 	.word	0x20000d3c
 8014bf0:	0802b2b4 	.word	0x0802b2b4
 8014bf4:	0802b2b8 	.word	0x0802b2b8
 8014bf8:	0802b1c0 	.word	0x0802b1c0

08014bfc <report_home_position>:

// Prints current home position in terms of machine position.
// Bitmask for homed axes attached.
void report_home_position (void)
{
 8014bfc:	b598      	push	{r3, r4, r7, lr}
 8014bfe:	af00      	add	r7, sp, #0
    hal.stream.write("[HOME:");
 8014c00:	4b13      	ldr	r3, [pc, #76]	; (8014c50 <report_home_position+0x54>)
 8014c02:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014c06:	4813      	ldr	r0, [pc, #76]	; (8014c54 <report_home_position+0x58>)
 8014c08:	4798      	blx	r3
    hal.stream.write(get_axis_values(sys.home_position));
 8014c0a:	4b11      	ldr	r3, [pc, #68]	; (8014c50 <report_home_position+0x54>)
 8014c0c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014c10:	4b11      	ldr	r3, [pc, #68]	; (8014c58 <report_home_position+0x5c>)
 8014c12:	681b      	ldr	r3, [r3, #0]
 8014c14:	4811      	ldr	r0, [pc, #68]	; (8014c5c <report_home_position+0x60>)
 8014c16:	4798      	blx	r3
 8014c18:	4603      	mov	r3, r0
 8014c1a:	4618      	mov	r0, r3
 8014c1c:	47a0      	blx	r4
    hal.stream.write(":");
 8014c1e:	4b0c      	ldr	r3, [pc, #48]	; (8014c50 <report_home_position+0x54>)
 8014c20:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014c24:	480e      	ldr	r0, [pc, #56]	; (8014c60 <report_home_position+0x64>)
 8014c26:	4798      	blx	r3
    hal.stream.write(uitoa(sys.homed.mask));
 8014c28:	4b09      	ldr	r3, [pc, #36]	; (8014c50 <report_home_position+0x54>)
 8014c2a:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014c2e:	4b0d      	ldr	r3, [pc, #52]	; (8014c64 <report_home_position+0x68>)
 8014c30:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8014c34:	4618      	mov	r0, r3
 8014c36:	f7fb fb29 	bl	801028c <uitoa>
 8014c3a:	4603      	mov	r3, r0
 8014c3c:	4618      	mov	r0, r3
 8014c3e:	47a0      	blx	r4
    hal.stream.write("]" ASCII_EOL);
 8014c40:	4b03      	ldr	r3, [pc, #12]	; (8014c50 <report_home_position+0x54>)
 8014c42:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014c46:	4808      	ldr	r0, [pc, #32]	; (8014c68 <report_home_position+0x6c>)
 8014c48:	4798      	blx	r3
}
 8014c4a:	bf00      	nop
 8014c4c:	bd98      	pop	{r3, r4, r7, pc}
 8014c4e:	bf00      	nop
 8014c50:	20000ed0 	.word	0x20000ed0
 8014c54:	0802b2bc 	.word	0x0802b2bc
 8014c58:	20001434 	.word	0x20001434
 8014c5c:	20000d94 	.word	0x20000d94
 8014c60:	0802b2c4 	.word	0x0802b2c4
 8014c64:	20000d3c 	.word	0x20000d3c
 8014c68:	0802b1c0 	.word	0x0802b1c0

08014c6c <report_tool_offsets>:

// Prints current tool offsets.
void report_tool_offsets (void)
{
 8014c6c:	b598      	push	{r3, r4, r7, lr}
 8014c6e:	af00      	add	r7, sp, #0
    hal.stream.write("[TLO:");
 8014c70:	4b0a      	ldr	r3, [pc, #40]	; (8014c9c <report_tool_offsets+0x30>)
 8014c72:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014c76:	480a      	ldr	r0, [pc, #40]	; (8014ca0 <report_tool_offsets+0x34>)
 8014c78:	4798      	blx	r3
#if TOOL_LENGTH_OFFSET_AXIS >= 0
    hal.stream.write(get_axis_value(gc_state.tool_length_offset[TOOL_LENGTH_OFFSET_AXIS]));
#else
    hal.stream.write(get_axis_values(gc_state.tool_length_offset));
 8014c7a:	4b08      	ldr	r3, [pc, #32]	; (8014c9c <report_tool_offsets+0x30>)
 8014c7c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014c80:	4b08      	ldr	r3, [pc, #32]	; (8014ca4 <report_tool_offsets+0x38>)
 8014c82:	681b      	ldr	r3, [r3, #0]
 8014c84:	4808      	ldr	r0, [pc, #32]	; (8014ca8 <report_tool_offsets+0x3c>)
 8014c86:	4798      	blx	r3
 8014c88:	4603      	mov	r3, r0
 8014c8a:	4618      	mov	r0, r3
 8014c8c:	47a0      	blx	r4
#endif
    hal.stream.write("]" ASCII_EOL);
 8014c8e:	4b03      	ldr	r3, [pc, #12]	; (8014c9c <report_tool_offsets+0x30>)
 8014c90:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014c94:	4805      	ldr	r0, [pc, #20]	; (8014cac <report_tool_offsets+0x40>)
 8014c96:	4798      	blx	r3
}
 8014c98:	bf00      	nop
 8014c9a:	bd98      	pop	{r3, r4, r7, pc}
 8014c9c:	20000ed0 	.word	0x20000ed0
 8014ca0:	0802b2c8 	.word	0x0802b2c8
 8014ca4:	20001434 	.word	0x20001434
 8014ca8:	20000c34 	.word	0x20000c34
 8014cac:	0802b1c0 	.word	0x0802b1c0

08014cb0 <report_ngc_parameter>:

// Prints NIST/LinuxCNC NGC parameter value
status_code_t report_ngc_parameter (ngc_param_id_t id)
{
 8014cb0:	b590      	push	{r4, r7, lr}
 8014cb2:	b085      	sub	sp, #20
 8014cb4:	af00      	add	r7, sp, #0
 8014cb6:	4603      	mov	r3, r0
 8014cb8:	80fb      	strh	r3, [r7, #6]
    float value;

    hal.stream.write("[PARAM:");
 8014cba:	4b1c      	ldr	r3, [pc, #112]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014cbc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014cc0:	481b      	ldr	r0, [pc, #108]	; (8014d30 <report_ngc_parameter+0x80>)
 8014cc2:	4798      	blx	r3
    hal.stream.write(uitoa(id));
 8014cc4:	4b19      	ldr	r3, [pc, #100]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014cc6:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014cca:	88fb      	ldrh	r3, [r7, #6]
 8014ccc:	4618      	mov	r0, r3
 8014cce:	f7fb fadd 	bl	801028c <uitoa>
 8014cd2:	4603      	mov	r3, r0
 8014cd4:	4618      	mov	r0, r3
 8014cd6:	47a0      	blx	r4
    if(ngc_param_get(id, &value)) {
 8014cd8:	f107 020c 	add.w	r2, r7, #12
 8014cdc:	88fb      	ldrh	r3, [r7, #6]
 8014cde:	4611      	mov	r1, r2
 8014ce0:	4618      	mov	r0, r3
 8014ce2:	f7fa ffe1 	bl	800fca8 <ngc_param_get>
 8014ce6:	4603      	mov	r3, r0
 8014ce8:	2b00      	cmp	r3, #0
 8014cea:	d010      	beq.n	8014d0e <report_ngc_parameter+0x5e>
        hal.stream.write("=");
 8014cec:	4b0f      	ldr	r3, [pc, #60]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014cee:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014cf2:	4810      	ldr	r0, [pc, #64]	; (8014d34 <report_ngc_parameter+0x84>)
 8014cf4:	4798      	blx	r3
        hal.stream.write(ftoa(value, 3));
 8014cf6:	4b0d      	ldr	r3, [pc, #52]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014cf8:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014cfc:	68fb      	ldr	r3, [r7, #12]
 8014cfe:	2103      	movs	r1, #3
 8014d00:	4618      	mov	r0, r3
 8014d02:	f7fb faff 	bl	8010304 <ftoa>
 8014d06:	4603      	mov	r3, r0
 8014d08:	4618      	mov	r0, r3
 8014d0a:	47a0      	blx	r4
 8014d0c:	e004      	b.n	8014d18 <report_ngc_parameter+0x68>
    } else
        hal.stream.write("=N/A");
 8014d0e:	4b07      	ldr	r3, [pc, #28]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014d10:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d14:	4808      	ldr	r0, [pc, #32]	; (8014d38 <report_ngc_parameter+0x88>)
 8014d16:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8014d18:	4b04      	ldr	r3, [pc, #16]	; (8014d2c <report_ngc_parameter+0x7c>)
 8014d1a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d1e:	4807      	ldr	r0, [pc, #28]	; (8014d3c <report_ngc_parameter+0x8c>)
 8014d20:	4798      	blx	r3

    return Status_OK;
 8014d22:	2300      	movs	r3, #0
}
 8014d24:	4618      	mov	r0, r3
 8014d26:	3714      	adds	r7, #20
 8014d28:	46bd      	mov	sp, r7
 8014d2a:	bd90      	pop	{r4, r7, pc}
 8014d2c:	20000ed0 	.word	0x20000ed0
 8014d30:	0802b2d0 	.word	0x0802b2d0
 8014d34:	0802b29c 	.word	0x0802b29c
 8014d38:	0802b2d8 	.word	0x0802b2d8
 8014d3c:	0802b1c0 	.word	0x0802b1c0

08014d40 <report_named_ngc_parameter>:

// Prints named LinuxCNC NGC parameter value
status_code_t report_named_ngc_parameter (char *arg)
{
 8014d40:	b590      	push	{r4, r7, lr}
 8014d42:	b085      	sub	sp, #20
 8014d44:	af00      	add	r7, sp, #0
 8014d46:	6078      	str	r0, [r7, #4]
    float value;

    hal.stream.write("[PARAM:");
 8014d48:	4b19      	ldr	r3, [pc, #100]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d4a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d4e:	4819      	ldr	r0, [pc, #100]	; (8014db4 <report_named_ngc_parameter+0x74>)
 8014d50:	4798      	blx	r3
    hal.stream.write(arg);
 8014d52:	4b17      	ldr	r3, [pc, #92]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d54:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d58:	6878      	ldr	r0, [r7, #4]
 8014d5a:	4798      	blx	r3
    if(ngc_named_param_get(arg, &value)) {
 8014d5c:	f107 030c 	add.w	r3, r7, #12
 8014d60:	4619      	mov	r1, r3
 8014d62:	6878      	ldr	r0, [r7, #4]
 8014d64:	f7fb fa06 	bl	8010174 <ngc_named_param_get>
 8014d68:	4603      	mov	r3, r0
 8014d6a:	2b00      	cmp	r3, #0
 8014d6c:	d010      	beq.n	8014d90 <report_named_ngc_parameter+0x50>
        hal.stream.write("=");
 8014d6e:	4b10      	ldr	r3, [pc, #64]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d70:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d74:	4810      	ldr	r0, [pc, #64]	; (8014db8 <report_named_ngc_parameter+0x78>)
 8014d76:	4798      	blx	r3
        hal.stream.write(ftoa(value, 3));
 8014d78:	4b0d      	ldr	r3, [pc, #52]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d7a:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014d7e:	68fb      	ldr	r3, [r7, #12]
 8014d80:	2103      	movs	r1, #3
 8014d82:	4618      	mov	r0, r3
 8014d84:	f7fb fabe 	bl	8010304 <ftoa>
 8014d88:	4603      	mov	r3, r0
 8014d8a:	4618      	mov	r0, r3
 8014d8c:	47a0      	blx	r4
 8014d8e:	e004      	b.n	8014d9a <report_named_ngc_parameter+0x5a>
    } else
        hal.stream.write("=N/A");
 8014d90:	4b07      	ldr	r3, [pc, #28]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d92:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014d96:	4809      	ldr	r0, [pc, #36]	; (8014dbc <report_named_ngc_parameter+0x7c>)
 8014d98:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8014d9a:	4b05      	ldr	r3, [pc, #20]	; (8014db0 <report_named_ngc_parameter+0x70>)
 8014d9c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014da0:	4807      	ldr	r0, [pc, #28]	; (8014dc0 <report_named_ngc_parameter+0x80>)
 8014da2:	4798      	blx	r3

    return Status_OK;
 8014da4:	2300      	movs	r3, #0
}
 8014da6:	4618      	mov	r0, r3
 8014da8:	3714      	adds	r7, #20
 8014daa:	46bd      	mov	sp, r7
 8014dac:	bd90      	pop	{r4, r7, pc}
 8014dae:	bf00      	nop
 8014db0:	20000ed0 	.word	0x20000ed0
 8014db4:	0802b2d0 	.word	0x0802b2d0
 8014db8:	0802b29c 	.word	0x0802b29c
 8014dbc:	0802b2d8 	.word	0x0802b2d8
 8014dc0:	0802b1c0 	.word	0x0802b1c0

08014dc4 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing, tool table)
void report_ngc_parameters (void)
{
 8014dc4:	b5b0      	push	{r4, r5, r7, lr}
 8014dc6:	b086      	sub	sp, #24
 8014dc8:	af00      	add	r7, sp, #0
    uint_fast8_t idx;
    float coord_data[N_AXIS];

    if(gc_state.modal.scaling_active) {
 8014dca:	4b92      	ldr	r3, [pc, #584]	; (8015014 <report_ngc_parameters+0x250>)
 8014dcc:	7f9b      	ldrb	r3, [r3, #30]
 8014dce:	2b00      	cmp	r3, #0
 8014dd0:	d016      	beq.n	8014e00 <report_ngc_parameters+0x3c>
        hal.stream.write("[G51:");
 8014dd2:	4b91      	ldr	r3, [pc, #580]	; (8015018 <report_ngc_parameters+0x254>)
 8014dd4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014dd8:	4890      	ldr	r0, [pc, #576]	; (801501c <report_ngc_parameters+0x258>)
 8014dda:	4798      	blx	r3
        hal.stream.write(get_axis_values(gc_get_scaling()));
 8014ddc:	4b8e      	ldr	r3, [pc, #568]	; (8015018 <report_ngc_parameters+0x254>)
 8014dde:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014de2:	4b8f      	ldr	r3, [pc, #572]	; (8015020 <report_ngc_parameters+0x25c>)
 8014de4:	681d      	ldr	r5, [r3, #0]
 8014de6:	f7f0 fdc3 	bl	8005970 <gc_get_scaling>
 8014dea:	4603      	mov	r3, r0
 8014dec:	4618      	mov	r0, r3
 8014dee:	47a8      	blx	r5
 8014df0:	4603      	mov	r3, r0
 8014df2:	4618      	mov	r0, r3
 8014df4:	47a0      	blx	r4
        hal.stream.write("]" ASCII_EOL);
 8014df6:	4b88      	ldr	r3, [pc, #544]	; (8015018 <report_ngc_parameters+0x254>)
 8014df8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014dfc:	4889      	ldr	r0, [pc, #548]	; (8015024 <report_ngc_parameters+0x260>)
 8014dfe:	4798      	blx	r3
    }

    for (idx = 0; idx < N_CoordinateSystems; idx++) {
 8014e00:	2300      	movs	r3, #0
 8014e02:	617b      	str	r3, [r7, #20]
 8014e04:	e059      	b.n	8014eba <report_ngc_parameters+0xf6>

        if (!(settings_read_coord_data((coord_system_id_t)idx, &coord_data))) {
 8014e06:	697b      	ldr	r3, [r7, #20]
 8014e08:	b2db      	uxtb	r3, r3
 8014e0a:	f107 0208 	add.w	r2, r7, #8
 8014e0e:	4611      	mov	r1, r2
 8014e10:	4618      	mov	r0, r3
 8014e12:	f005 ff01 	bl	801ac18 <settings_read_coord_data>
 8014e16:	4603      	mov	r3, r0
 8014e18:	f083 0301 	eor.w	r3, r3, #1
 8014e1c:	b2db      	uxtb	r3, r3
 8014e1e:	2b00      	cmp	r3, #0
 8014e20:	d004      	beq.n	8014e2c <report_ngc_parameters+0x68>
            grbl.report.status_message(Status_SettingReadFail);
 8014e22:	4b81      	ldr	r3, [pc, #516]	; (8015028 <report_ngc_parameters+0x264>)
 8014e24:	689b      	ldr	r3, [r3, #8]
 8014e26:	2007      	movs	r0, #7
 8014e28:	4798      	blx	r3
 8014e2a:	e0ef      	b.n	801500c <report_ngc_parameters+0x248>
            return;
        }

        hal.stream.write("[G");
 8014e2c:	4b7a      	ldr	r3, [pc, #488]	; (8015018 <report_ngc_parameters+0x254>)
 8014e2e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014e32:	487e      	ldr	r0, [pc, #504]	; (801502c <report_ngc_parameters+0x268>)
 8014e34:	4798      	blx	r3

        switch (idx) {
 8014e36:	697b      	ldr	r3, [r7, #20]
 8014e38:	2b0b      	cmp	r3, #11
 8014e3a:	d021      	beq.n	8014e80 <report_ngc_parameters+0xbc>
 8014e3c:	697b      	ldr	r3, [r7, #20]
 8014e3e:	2b0b      	cmp	r3, #11
 8014e40:	d812      	bhi.n	8014e68 <report_ngc_parameters+0xa4>
 8014e42:	697b      	ldr	r3, [r7, #20]
 8014e44:	2b09      	cmp	r3, #9
 8014e46:	d003      	beq.n	8014e50 <report_ngc_parameters+0x8c>
 8014e48:	697b      	ldr	r3, [r7, #20]
 8014e4a:	2b0a      	cmp	r3, #10
 8014e4c:	d006      	beq.n	8014e5c <report_ngc_parameters+0x98>
 8014e4e:	e00b      	b.n	8014e68 <report_ngc_parameters+0xa4>

            case CoordinateSystem_G28:
                hal.stream.write("28");
 8014e50:	4b71      	ldr	r3, [pc, #452]	; (8015018 <report_ngc_parameters+0x254>)
 8014e52:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014e56:	4876      	ldr	r0, [pc, #472]	; (8015030 <report_ngc_parameters+0x26c>)
 8014e58:	4798      	blx	r3
                break;
 8014e5a:	e012      	b.n	8014e82 <report_ngc_parameters+0xbe>

            case CoordinateSystem_G30:
                hal.stream.write("30");
 8014e5c:	4b6e      	ldr	r3, [pc, #440]	; (8015018 <report_ngc_parameters+0x254>)
 8014e5e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014e62:	4874      	ldr	r0, [pc, #464]	; (8015034 <report_ngc_parameters+0x270>)
 8014e64:	4798      	blx	r3
                break;
 8014e66:	e00c      	b.n	8014e82 <report_ngc_parameters+0xbe>

            case CoordinateSystem_G92:
                break;

            default: // G54-G59
                hal.stream.write(map_coord_system((coord_system_id_t)idx));
 8014e68:	4b6b      	ldr	r3, [pc, #428]	; (8015018 <report_ngc_parameters+0x254>)
 8014e6a:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014e6e:	697b      	ldr	r3, [r7, #20]
 8014e70:	b2db      	uxtb	r3, r3
 8014e72:	4618      	mov	r0, r3
 8014e74:	f7ff f8c8 	bl	8014008 <map_coord_system>
 8014e78:	4603      	mov	r3, r0
 8014e7a:	4618      	mov	r0, r3
 8014e7c:	47a0      	blx	r4
                break;
 8014e7e:	e000      	b.n	8014e82 <report_ngc_parameters+0xbe>
                break;
 8014e80:	bf00      	nop
        }

        if(idx != CoordinateSystem_G92) {
 8014e82:	697b      	ldr	r3, [r7, #20]
 8014e84:	2b0b      	cmp	r3, #11
 8014e86:	d015      	beq.n	8014eb4 <report_ngc_parameters+0xf0>
            hal.stream.write(":");
 8014e88:	4b63      	ldr	r3, [pc, #396]	; (8015018 <report_ngc_parameters+0x254>)
 8014e8a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014e8e:	486a      	ldr	r0, [pc, #424]	; (8015038 <report_ngc_parameters+0x274>)
 8014e90:	4798      	blx	r3
            hal.stream.write(get_axis_values(coord_data));
 8014e92:	4b61      	ldr	r3, [pc, #388]	; (8015018 <report_ngc_parameters+0x254>)
 8014e94:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014e98:	4b61      	ldr	r3, [pc, #388]	; (8015020 <report_ngc_parameters+0x25c>)
 8014e9a:	681b      	ldr	r3, [r3, #0]
 8014e9c:	f107 0208 	add.w	r2, r7, #8
 8014ea0:	4610      	mov	r0, r2
 8014ea2:	4798      	blx	r3
 8014ea4:	4603      	mov	r3, r0
 8014ea6:	4618      	mov	r0, r3
 8014ea8:	47a0      	blx	r4
            hal.stream.write("]" ASCII_EOL);
 8014eaa:	4b5b      	ldr	r3, [pc, #364]	; (8015018 <report_ngc_parameters+0x254>)
 8014eac:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014eb0:	485c      	ldr	r0, [pc, #368]	; (8015024 <report_ngc_parameters+0x260>)
 8014eb2:	4798      	blx	r3
    for (idx = 0; idx < N_CoordinateSystems; idx++) {
 8014eb4:	697b      	ldr	r3, [r7, #20]
 8014eb6:	3301      	adds	r3, #1
 8014eb8:	617b      	str	r3, [r7, #20]
 8014eba:	697b      	ldr	r3, [r7, #20]
 8014ebc:	2b0b      	cmp	r3, #11
 8014ebe:	d9a2      	bls.n	8014e06 <report_ngc_parameters+0x42>
        }
    }

    // Print G92, G92.1 which are not persistent in memory
    hal.stream.write("92:");
 8014ec0:	4b55      	ldr	r3, [pc, #340]	; (8015018 <report_ngc_parameters+0x254>)
 8014ec2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014ec6:	485d      	ldr	r0, [pc, #372]	; (801503c <report_ngc_parameters+0x278>)
 8014ec8:	4798      	blx	r3
    hal.stream.write(get_axis_values(gc_state.g92_coord_offset));
 8014eca:	4b53      	ldr	r3, [pc, #332]	; (8015018 <report_ngc_parameters+0x254>)
 8014ecc:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014ed0:	4b53      	ldr	r3, [pc, #332]	; (8015020 <report_ngc_parameters+0x25c>)
 8014ed2:	681b      	ldr	r3, [r3, #0]
 8014ed4:	485a      	ldr	r0, [pc, #360]	; (8015040 <report_ngc_parameters+0x27c>)
 8014ed6:	4798      	blx	r3
 8014ed8:	4603      	mov	r3, r0
 8014eda:	4618      	mov	r0, r3
 8014edc:	47a0      	blx	r4
    hal.stream.write("]" ASCII_EOL);
 8014ede:	4b4e      	ldr	r3, [pc, #312]	; (8015018 <report_ngc_parameters+0x254>)
 8014ee0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014ee4:	484f      	ldr	r0, [pc, #316]	; (8015024 <report_ngc_parameters+0x260>)
 8014ee6:	4798      	blx	r3

    for (idx = 1; idx <= grbl.tool_table.n_tools; idx++) {
 8014ee8:	2301      	movs	r3, #1
 8014eea:	617b      	str	r3, [r7, #20]
 8014eec:	e044      	b.n	8014f78 <report_ngc_parameters+0x1b4>
        hal.stream.write("[T:");
 8014eee:	4b4a      	ldr	r3, [pc, #296]	; (8015018 <report_ngc_parameters+0x254>)
 8014ef0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014ef4:	4853      	ldr	r0, [pc, #332]	; (8015044 <report_ngc_parameters+0x280>)
 8014ef6:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)idx));
 8014ef8:	4b47      	ldr	r3, [pc, #284]	; (8015018 <report_ngc_parameters+0x254>)
 8014efa:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014efe:	6978      	ldr	r0, [r7, #20]
 8014f00:	f7fb f9c4 	bl	801028c <uitoa>
 8014f04:	4603      	mov	r3, r0
 8014f06:	4618      	mov	r0, r3
 8014f08:	47a0      	blx	r4
        hal.stream.write("|");
 8014f0a:	4b43      	ldr	r3, [pc, #268]	; (8015018 <report_ngc_parameters+0x254>)
 8014f0c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014f10:	484d      	ldr	r0, [pc, #308]	; (8015048 <report_ngc_parameters+0x284>)
 8014f12:	4798      	blx	r3
        hal.stream.write(get_axis_values(grbl.tool_table.tool[idx].offset));
 8014f14:	4b40      	ldr	r3, [pc, #256]	; (8015018 <report_ngc_parameters+0x254>)
 8014f16:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014f1a:	4b41      	ldr	r3, [pc, #260]	; (8015020 <report_ngc_parameters+0x25c>)
 8014f1c:	6819      	ldr	r1, [r3, #0]
 8014f1e:	4b42      	ldr	r3, [pc, #264]	; (8015028 <report_ngc_parameters+0x264>)
 8014f20:	69d8      	ldr	r0, [r3, #28]
 8014f22:	697a      	ldr	r2, [r7, #20]
 8014f24:	4613      	mov	r3, r2
 8014f26:	009b      	lsls	r3, r3, #2
 8014f28:	4413      	add	r3, r2
 8014f2a:	009b      	lsls	r3, r3, #2
 8014f2c:	4403      	add	r3, r0
 8014f2e:	4618      	mov	r0, r3
 8014f30:	4788      	blx	r1
 8014f32:	4603      	mov	r3, r0
 8014f34:	4618      	mov	r0, r3
 8014f36:	47a0      	blx	r4
        hal.stream.write("|");
 8014f38:	4b37      	ldr	r3, [pc, #220]	; (8015018 <report_ngc_parameters+0x254>)
 8014f3a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014f3e:	4842      	ldr	r0, [pc, #264]	; (8015048 <report_ngc_parameters+0x284>)
 8014f40:	4798      	blx	r3
        hal.stream.write(get_axis_value(grbl.tool_table.tool[idx].radius));
 8014f42:	4b35      	ldr	r3, [pc, #212]	; (8015018 <report_ngc_parameters+0x254>)
 8014f44:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014f48:	4b40      	ldr	r3, [pc, #256]	; (801504c <report_ngc_parameters+0x288>)
 8014f4a:	6819      	ldr	r1, [r3, #0]
 8014f4c:	4b36      	ldr	r3, [pc, #216]	; (8015028 <report_ngc_parameters+0x264>)
 8014f4e:	69d8      	ldr	r0, [r3, #28]
 8014f50:	697a      	ldr	r2, [r7, #20]
 8014f52:	4613      	mov	r3, r2
 8014f54:	009b      	lsls	r3, r3, #2
 8014f56:	4413      	add	r3, r2
 8014f58:	009b      	lsls	r3, r3, #2
 8014f5a:	4403      	add	r3, r0
 8014f5c:	68db      	ldr	r3, [r3, #12]
 8014f5e:	4618      	mov	r0, r3
 8014f60:	4788      	blx	r1
 8014f62:	4603      	mov	r3, r0
 8014f64:	4618      	mov	r0, r3
 8014f66:	47a0      	blx	r4
        hal.stream.write("]" ASCII_EOL);
 8014f68:	4b2b      	ldr	r3, [pc, #172]	; (8015018 <report_ngc_parameters+0x254>)
 8014f6a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014f6e:	482d      	ldr	r0, [pc, #180]	; (8015024 <report_ngc_parameters+0x260>)
 8014f70:	4798      	blx	r3
    for (idx = 1; idx <= grbl.tool_table.n_tools; idx++) {
 8014f72:	697b      	ldr	r3, [r7, #20]
 8014f74:	3301      	adds	r3, #1
 8014f76:	617b      	str	r3, [r7, #20]
 8014f78:	4b2b      	ldr	r3, [pc, #172]	; (8015028 <report_ngc_parameters+0x264>)
 8014f7a:	699b      	ldr	r3, [r3, #24]
 8014f7c:	697a      	ldr	r2, [r7, #20]
 8014f7e:	429a      	cmp	r2, r3
 8014f80:	d9b5      	bls.n	8014eee <report_ngc_parameters+0x12a>
    }

#if COMPATIBILITY_LEVEL < 10
    if(settings.homing.flags.enabled)
 8014f82:	4b33      	ldr	r3, [pc, #204]	; (8015050 <report_ngc_parameters+0x28c>)
 8014f84:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8014f88:	f003 0301 	and.w	r3, r3, #1
 8014f8c:	b2db      	uxtb	r3, r3
 8014f8e:	2b00      	cmp	r3, #0
 8014f90:	d001      	beq.n	8014f96 <report_ngc_parameters+0x1d2>
        report_home_position();
 8014f92:	f7ff fe33 	bl	8014bfc <report_home_position>
#endif

    report_tool_offsets();      // Print tool length offset value.
 8014f96:	f7ff fe69 	bl	8014c6c <report_tool_offsets>
    report_probe_parameters();  // Print probe parameters. Not persistent in memory.
 8014f9a:	f7ff fdef 	bl	8014b7c <report_probe_parameters>
    if(sys.tlo_reference_set.mask) { // Print tool length reference offset. Not persistent in memory.
 8014f9e:	4b2d      	ldr	r3, [pc, #180]	; (8015054 <report_ngc_parameters+0x290>)
 8014fa0:	79db      	ldrb	r3, [r3, #7]
 8014fa2:	2b00      	cmp	r3, #0
 8014fa4:	d032      	beq.n	801500c <report_ngc_parameters+0x248>
        plane_t plane;
        gc_get_plane_data(&plane, gc_state.modal.plane_select);
 8014fa6:	4b1b      	ldr	r3, [pc, #108]	; (8015014 <report_ngc_parameters+0x250>)
 8014fa8:	799a      	ldrb	r2, [r3, #6]
 8014faa:	1d3b      	adds	r3, r7, #4
 8014fac:	4611      	mov	r1, r2
 8014fae:	4618      	mov	r0, r3
 8014fb0:	f7f0 fdf8 	bl	8005ba4 <gc_get_plane_data>
        hal.stream.write("[TLR:");
 8014fb4:	4b18      	ldr	r3, [pc, #96]	; (8015018 <report_ngc_parameters+0x254>)
 8014fb6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8014fba:	4827      	ldr	r0, [pc, #156]	; (8015058 <report_ngc_parameters+0x294>)
 8014fbc:	4798      	blx	r3
        hal.stream.write(get_axis_value(sys.tlo_reference[plane.axis_linear] / settings.axis[plane.axis_linear].steps_per_mm));
 8014fbe:	4b16      	ldr	r3, [pc, #88]	; (8015018 <report_ngc_parameters+0x254>)
 8014fc0:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8014fc4:	4b21      	ldr	r3, [pc, #132]	; (801504c <report_ngc_parameters+0x288>)
 8014fc6:	681d      	ldr	r5, [r3, #0]
 8014fc8:	79bb      	ldrb	r3, [r7, #6]
 8014fca:	4a22      	ldr	r2, [pc, #136]	; (8015054 <report_ngc_parameters+0x290>)
 8014fcc:	3302      	adds	r3, #2
 8014fce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014fd2:	4618      	mov	r0, r3
 8014fd4:	f7eb fe9a 	bl	8000d0c <__aeabi_i2f>
 8014fd8:	4602      	mov	r2, r0
 8014fda:	79bb      	ldrb	r3, [r7, #6]
 8014fdc:	4618      	mov	r0, r3
 8014fde:	491c      	ldr	r1, [pc, #112]	; (8015050 <report_ngc_parameters+0x28c>)
 8014fe0:	4603      	mov	r3, r0
 8014fe2:	009b      	lsls	r3, r3, #2
 8014fe4:	4403      	add	r3, r0
 8014fe6:	009b      	lsls	r3, r3, #2
 8014fe8:	440b      	add	r3, r1
 8014fea:	3330      	adds	r3, #48	; 0x30
 8014fec:	681b      	ldr	r3, [r3, #0]
 8014fee:	4619      	mov	r1, r3
 8014ff0:	4610      	mov	r0, r2
 8014ff2:	f7eb ff93 	bl	8000f1c <__aeabi_fdiv>
 8014ff6:	4603      	mov	r3, r0
 8014ff8:	4618      	mov	r0, r3
 8014ffa:	47a8      	blx	r5
 8014ffc:	4603      	mov	r3, r0
 8014ffe:	4618      	mov	r0, r3
 8015000:	47a0      	blx	r4
        hal.stream.write("]" ASCII_EOL);
 8015002:	4b05      	ldr	r3, [pc, #20]	; (8015018 <report_ngc_parameters+0x254>)
 8015004:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015008:	4806      	ldr	r0, [pc, #24]	; (8015024 <report_ngc_parameters+0x260>)
 801500a:	4798      	blx	r3
    }
}
 801500c:	3718      	adds	r7, #24
 801500e:	46bd      	mov	sp, r7
 8015010:	bdb0      	pop	{r4, r5, r7, pc}
 8015012:	bf00      	nop
 8015014:	20000bb0 	.word	0x20000bb0
 8015018:	20000ed0 	.word	0x20000ed0
 801501c:	0802b2e0 	.word	0x0802b2e0
 8015020:	20001434 	.word	0x20001434
 8015024:	0802b1c0 	.word	0x0802b1c0
 8015028:	20000dd4 	.word	0x20000dd4
 801502c:	0802b2e8 	.word	0x0802b2e8
 8015030:	0802b2ec 	.word	0x0802b2ec
 8015034:	0802b2f0 	.word	0x0802b2f0
 8015038:	0802b2c4 	.word	0x0802b2c4
 801503c:	0802b2f4 	.word	0x0802b2f4
 8015040:	20000c28 	.word	0x20000c28
 8015044:	0802b2f8 	.word	0x0802b2f8
 8015048:	0802b2fc 	.word	0x0802b2fc
 801504c:	20001438 	.word	0x20001438
 8015050:	2000147c 	.word	0x2000147c
 8015054:	20000d3c 	.word	0x20000d3c
 8015058:	0802b300 	.word	0x0802b300

0801505c <is_g92_active>:

static inline bool is_g92_active (void)
{
 801505c:	b580      	push	{r7, lr}
 801505e:	b082      	sub	sp, #8
 8015060:	af00      	add	r7, sp, #0
    bool active = false;
 8015062:	2300      	movs	r3, #0
 8015064:	70fb      	strb	r3, [r7, #3]
    uint_fast32_t idx = N_AXIS;
 8015066:	2303      	movs	r3, #3
 8015068:	607b      	str	r3, [r7, #4]

    do {
        idx--;
 801506a:	687b      	ldr	r3, [r7, #4]
 801506c:	3b01      	subs	r3, #1
 801506e:	607b      	str	r3, [r7, #4]
        active = !(gc_state.g92_coord_offset[idx] == 0.0f || gc_state.g92_coord_offset[idx] == -0.0f);
 8015070:	4a17      	ldr	r2, [pc, #92]	; (80150d0 <is_g92_active+0x74>)
 8015072:	687b      	ldr	r3, [r7, #4]
 8015074:	331e      	adds	r3, #30
 8015076:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 801507a:	f04f 0100 	mov.w	r1, #0
 801507e:	4618      	mov	r0, r3
 8015080:	f7ec f82c 	bl	80010dc <__aeabi_fcmpeq>
 8015084:	4603      	mov	r3, r0
 8015086:	2b00      	cmp	r3, #0
 8015088:	d10e      	bne.n	80150a8 <is_g92_active+0x4c>
 801508a:	4a11      	ldr	r2, [pc, #68]	; (80150d0 <is_g92_active+0x74>)
 801508c:	687b      	ldr	r3, [r7, #4]
 801508e:	331e      	adds	r3, #30
 8015090:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8015094:	f04f 0100 	mov.w	r1, #0
 8015098:	4618      	mov	r0, r3
 801509a:	f7ec f81f 	bl	80010dc <__aeabi_fcmpeq>
 801509e:	4603      	mov	r3, r0
 80150a0:	2b00      	cmp	r3, #0
 80150a2:	d101      	bne.n	80150a8 <is_g92_active+0x4c>
 80150a4:	2301      	movs	r3, #1
 80150a6:	e000      	b.n	80150aa <is_g92_active+0x4e>
 80150a8:	2300      	movs	r3, #0
 80150aa:	70fb      	strb	r3, [r7, #3]
 80150ac:	78fb      	ldrb	r3, [r7, #3]
 80150ae:	f003 0301 	and.w	r3, r3, #1
 80150b2:	70fb      	strb	r3, [r7, #3]
    } while(idx && !active);
 80150b4:	687b      	ldr	r3, [r7, #4]
 80150b6:	2b00      	cmp	r3, #0
 80150b8:	d005      	beq.n	80150c6 <is_g92_active+0x6a>
 80150ba:	78fb      	ldrb	r3, [r7, #3]
 80150bc:	f083 0301 	eor.w	r3, r3, #1
 80150c0:	b2db      	uxtb	r3, r3
 80150c2:	2b00      	cmp	r3, #0
 80150c4:	d1d1      	bne.n	801506a <is_g92_active+0xe>

    return active;
 80150c6:	78fb      	ldrb	r3, [r7, #3]
}
 80150c8:	4618      	mov	r0, r3
 80150ca:	3708      	adds	r7, #8
 80150cc:	46bd      	mov	sp, r7
 80150ce:	bd80      	pop	{r7, pc}
 80150d0:	20000bb0 	.word	0x20000bb0

080150d4 <report_gcode_modes>:

// Print current gcode parser mode state
void report_gcode_modes (void)
{
 80150d4:	b598      	push	{r3, r4, r7, lr}
 80150d6:	af00      	add	r7, sp, #0
    hal.stream.write("[GC:G");
 80150d8:	4ba7      	ldr	r3, [pc, #668]	; (8015378 <report_gcode_modes+0x2a4>)
 80150da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80150de:	48a7      	ldr	r0, [pc, #668]	; (801537c <report_gcode_modes+0x2a8>)
 80150e0:	4798      	blx	r3
    if (gc_state.modal.motion >= MotionMode_ProbeToward) {
 80150e2:	4ba7      	ldr	r3, [pc, #668]	; (8015380 <report_gcode_modes+0x2ac>)
 80150e4:	881b      	ldrh	r3, [r3, #0]
 80150e6:	2b8b      	cmp	r3, #139	; 0x8b
 80150e8:	d911      	bls.n	801510e <report_gcode_modes+0x3a>
        hal.stream.write("38.");
 80150ea:	4ba3      	ldr	r3, [pc, #652]	; (8015378 <report_gcode_modes+0x2a4>)
 80150ec:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80150f0:	48a4      	ldr	r0, [pc, #656]	; (8015384 <report_gcode_modes+0x2b0>)
 80150f2:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)(gc_state.modal.motion - (MotionMode_ProbeToward - 2))));
 80150f4:	4ba0      	ldr	r3, [pc, #640]	; (8015378 <report_gcode_modes+0x2a4>)
 80150f6:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80150fa:	4ba1      	ldr	r3, [pc, #644]	; (8015380 <report_gcode_modes+0x2ac>)
 80150fc:	881b      	ldrh	r3, [r3, #0]
 80150fe:	3b8a      	subs	r3, #138	; 0x8a
 8015100:	4618      	mov	r0, r3
 8015102:	f7fb f8c3 	bl	801028c <uitoa>
 8015106:	4603      	mov	r3, r0
 8015108:	4618      	mov	r0, r3
 801510a:	47a0      	blx	r4
 801510c:	e00a      	b.n	8015124 <report_gcode_modes+0x50>
    } else
        hal.stream.write(uitoa((uint32_t)gc_state.modal.motion));
 801510e:	4b9a      	ldr	r3, [pc, #616]	; (8015378 <report_gcode_modes+0x2a4>)
 8015110:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015114:	4b9a      	ldr	r3, [pc, #616]	; (8015380 <report_gcode_modes+0x2ac>)
 8015116:	881b      	ldrh	r3, [r3, #0]
 8015118:	4618      	mov	r0, r3
 801511a:	f7fb f8b7 	bl	801028c <uitoa>
 801511e:	4603      	mov	r3, r0
 8015120:	4618      	mov	r0, r3
 8015122:	47a0      	blx	r4

    hal.stream.write(" G");
 8015124:	4b94      	ldr	r3, [pc, #592]	; (8015378 <report_gcode_modes+0x2a4>)
 8015126:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801512a:	4897      	ldr	r0, [pc, #604]	; (8015388 <report_gcode_modes+0x2b4>)
 801512c:	4798      	blx	r3
    hal.stream.write(map_coord_system(gc_state.modal.coord_system.id));
 801512e:	4b92      	ldr	r3, [pc, #584]	; (8015378 <report_gcode_modes+0x2a4>)
 8015130:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015134:	4b92      	ldr	r3, [pc, #584]	; (8015380 <report_gcode_modes+0x2ac>)
 8015136:	7d1b      	ldrb	r3, [r3, #20]
 8015138:	4618      	mov	r0, r3
 801513a:	f7fe ff65 	bl	8014008 <map_coord_system>
 801513e:	4603      	mov	r3, r0
 8015140:	4618      	mov	r0, r3
 8015142:	47a0      	blx	r4

#if COMPATIBILITY_LEVEL < 10

    if(is_g92_active())
 8015144:	f7ff ff8a 	bl	801505c <is_g92_active>
 8015148:	4603      	mov	r3, r0
 801514a:	2b00      	cmp	r3, #0
 801514c:	d004      	beq.n	8015158 <report_gcode_modes+0x84>
        hal.stream.write(" G92");
 801514e:	4b8a      	ldr	r3, [pc, #552]	; (8015378 <report_gcode_modes+0x2a4>)
 8015150:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015154:	488d      	ldr	r0, [pc, #564]	; (801538c <report_gcode_modes+0x2b8>)
 8015156:	4798      	blx	r3

#endif

    if(settings.mode == Mode_Lathe)
 8015158:	4b8d      	ldr	r3, [pc, #564]	; (8015390 <report_gcode_modes+0x2bc>)
 801515a:	7e1b      	ldrb	r3, [r3, #24]
 801515c:	2b02      	cmp	r3, #2
 801515e:	d10b      	bne.n	8015178 <report_gcode_modes+0xa4>
        hal.stream.write(gc_state.modal.diameter_mode ? " G7" : " G8");
 8015160:	4b85      	ldr	r3, [pc, #532]	; (8015378 <report_gcode_modes+0x2a4>)
 8015162:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015166:	4a86      	ldr	r2, [pc, #536]	; (8015380 <report_gcode_modes+0x2ac>)
 8015168:	7952      	ldrb	r2, [r2, #5]
 801516a:	2a00      	cmp	r2, #0
 801516c:	d001      	beq.n	8015172 <report_gcode_modes+0x9e>
 801516e:	4a89      	ldr	r2, [pc, #548]	; (8015394 <report_gcode_modes+0x2c0>)
 8015170:	e000      	b.n	8015174 <report_gcode_modes+0xa0>
 8015172:	4a89      	ldr	r2, [pc, #548]	; (8015398 <report_gcode_modes+0x2c4>)
 8015174:	4610      	mov	r0, r2
 8015176:	4798      	blx	r3

    hal.stream.write(" G");
 8015178:	4b7f      	ldr	r3, [pc, #508]	; (8015378 <report_gcode_modes+0x2a4>)
 801517a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801517e:	4882      	ldr	r0, [pc, #520]	; (8015388 <report_gcode_modes+0x2b4>)
 8015180:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(gc_state.modal.plane_select + 17)));
 8015182:	4b7d      	ldr	r3, [pc, #500]	; (8015378 <report_gcode_modes+0x2a4>)
 8015184:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015188:	4b7d      	ldr	r3, [pc, #500]	; (8015380 <report_gcode_modes+0x2ac>)
 801518a:	799b      	ldrb	r3, [r3, #6]
 801518c:	3311      	adds	r3, #17
 801518e:	4618      	mov	r0, r3
 8015190:	f7fb f87c 	bl	801028c <uitoa>
 8015194:	4603      	mov	r3, r0
 8015196:	4618      	mov	r0, r3
 8015198:	47a0      	blx	r4

    hal.stream.write(gc_state.modal.units_imperial ? " G20" : " G21");
 801519a:	4b77      	ldr	r3, [pc, #476]	; (8015378 <report_gcode_modes+0x2a4>)
 801519c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80151a0:	4a77      	ldr	r2, [pc, #476]	; (8015380 <report_gcode_modes+0x2ac>)
 80151a2:	78d2      	ldrb	r2, [r2, #3]
 80151a4:	2a00      	cmp	r2, #0
 80151a6:	d001      	beq.n	80151ac <report_gcode_modes+0xd8>
 80151a8:	4a7c      	ldr	r2, [pc, #496]	; (801539c <report_gcode_modes+0x2c8>)
 80151aa:	e000      	b.n	80151ae <report_gcode_modes+0xda>
 80151ac:	4a7c      	ldr	r2, [pc, #496]	; (80153a0 <report_gcode_modes+0x2cc>)
 80151ae:	4610      	mov	r0, r2
 80151b0:	4798      	blx	r3

    hal.stream.write(gc_state.modal.distance_incremental ? " G91" : " G90");
 80151b2:	4b71      	ldr	r3, [pc, #452]	; (8015378 <report_gcode_modes+0x2a4>)
 80151b4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80151b8:	4a71      	ldr	r2, [pc, #452]	; (8015380 <report_gcode_modes+0x2ac>)
 80151ba:	7912      	ldrb	r2, [r2, #4]
 80151bc:	2a00      	cmp	r2, #0
 80151be:	d001      	beq.n	80151c4 <report_gcode_modes+0xf0>
 80151c0:	4a78      	ldr	r2, [pc, #480]	; (80153a4 <report_gcode_modes+0x2d0>)
 80151c2:	e000      	b.n	80151c6 <report_gcode_modes+0xf2>
 80151c4:	4a78      	ldr	r2, [pc, #480]	; (80153a8 <report_gcode_modes+0x2d4>)
 80151c6:	4610      	mov	r0, r2
 80151c8:	4798      	blx	r3

    hal.stream.write(" G");
 80151ca:	4b6b      	ldr	r3, [pc, #428]	; (8015378 <report_gcode_modes+0x2a4>)
 80151cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80151d0:	486d      	ldr	r0, [pc, #436]	; (8015388 <report_gcode_modes+0x2b4>)
 80151d2:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(94 - gc_state.modal.feed_mode)));
 80151d4:	4b68      	ldr	r3, [pc, #416]	; (8015378 <report_gcode_modes+0x2a4>)
 80151d6:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80151da:	4b69      	ldr	r3, [pc, #420]	; (8015380 <report_gcode_modes+0x2ac>)
 80151dc:	789b      	ldrb	r3, [r3, #2]
 80151de:	f1c3 035e 	rsb	r3, r3, #94	; 0x5e
 80151e2:	4618      	mov	r0, r3
 80151e4:	f7fb f852 	bl	801028c <uitoa>
 80151e8:	4603      	mov	r3, r0
 80151ea:	4618      	mov	r0, r3
 80151ec:	47a0      	blx	r4

    if(settings.mode == Mode_Lathe && gc_spindle_get()->cap.variable)
 80151ee:	4b68      	ldr	r3, [pc, #416]	; (8015390 <report_gcode_modes+0x2bc>)
 80151f0:	7e1b      	ldrb	r3, [r3, #24]
 80151f2:	2b02      	cmp	r3, #2
 80151f4:	d114      	bne.n	8015220 <report_gcode_modes+0x14c>
 80151f6:	f7f0 fdf7 	bl	8005de8 <gc_spindle_get>
 80151fa:	4603      	mov	r3, r0
 80151fc:	7a9b      	ldrb	r3, [r3, #10]
 80151fe:	f003 0301 	and.w	r3, r3, #1
 8015202:	b2db      	uxtb	r3, r3
 8015204:	2b00      	cmp	r3, #0
 8015206:	d00b      	beq.n	8015220 <report_gcode_modes+0x14c>
        hal.stream.write(gc_state.modal.spindle.rpm_mode == SpindleSpeedMode_RPM ? " G97" : " G96");
 8015208:	4b5b      	ldr	r3, [pc, #364]	; (8015378 <report_gcode_modes+0x2a4>)
 801520a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801520e:	4a5c      	ldr	r2, [pc, #368]	; (8015380 <report_gcode_modes+0x2ac>)
 8015210:	7ed2      	ldrb	r2, [r2, #27]
 8015212:	2a00      	cmp	r2, #0
 8015214:	d101      	bne.n	801521a <report_gcode_modes+0x146>
 8015216:	4a65      	ldr	r2, [pc, #404]	; (80153ac <report_gcode_modes+0x2d8>)
 8015218:	e000      	b.n	801521c <report_gcode_modes+0x148>
 801521a:	4a65      	ldr	r2, [pc, #404]	; (80153b0 <report_gcode_modes+0x2dc>)
 801521c:	4610      	mov	r0, r2
 801521e:	4798      	blx	r3

#if COMPATIBILITY_LEVEL < 10

    if(gc_state.modal.tool_offset_mode == ToolLengthOffset_Cancel)
 8015220:	4b57      	ldr	r3, [pc, #348]	; (8015380 <report_gcode_modes+0x2ac>)
 8015222:	79db      	ldrb	r3, [r3, #7]
 8015224:	2b00      	cmp	r3, #0
 8015226:	d105      	bne.n	8015234 <report_gcode_modes+0x160>
        hal.stream.write(" G49");
 8015228:	4b53      	ldr	r3, [pc, #332]	; (8015378 <report_gcode_modes+0x2a4>)
 801522a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801522e:	4861      	ldr	r0, [pc, #388]	; (80153b4 <report_gcode_modes+0x2e0>)
 8015230:	4798      	blx	r3
 8015232:	e014      	b.n	801525e <report_gcode_modes+0x18a>
    else {
        hal.stream.write(" G43");
 8015234:	4b50      	ldr	r3, [pc, #320]	; (8015378 <report_gcode_modes+0x2a4>)
 8015236:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801523a:	485f      	ldr	r0, [pc, #380]	; (80153b8 <report_gcode_modes+0x2e4>)
 801523c:	4798      	blx	r3
        if(gc_state.modal.tool_offset_mode != ToolLengthOffset_Enable)
 801523e:	4b50      	ldr	r3, [pc, #320]	; (8015380 <report_gcode_modes+0x2ac>)
 8015240:	79db      	ldrb	r3, [r3, #7]
 8015242:	2b01      	cmp	r3, #1
 8015244:	d00b      	beq.n	801525e <report_gcode_modes+0x18a>
            hal.stream.write(gc_state.modal.tool_offset_mode == ToolLengthOffset_EnableDynamic ? ".1" : ".2");
 8015246:	4b4c      	ldr	r3, [pc, #304]	; (8015378 <report_gcode_modes+0x2a4>)
 8015248:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801524c:	4a4c      	ldr	r2, [pc, #304]	; (8015380 <report_gcode_modes+0x2ac>)
 801524e:	79d2      	ldrb	r2, [r2, #7]
 8015250:	2a02      	cmp	r2, #2
 8015252:	d101      	bne.n	8015258 <report_gcode_modes+0x184>
 8015254:	4a59      	ldr	r2, [pc, #356]	; (80153bc <report_gcode_modes+0x2e8>)
 8015256:	e000      	b.n	801525a <report_gcode_modes+0x186>
 8015258:	4a59      	ldr	r2, [pc, #356]	; (80153c0 <report_gcode_modes+0x2ec>)
 801525a:	4610      	mov	r0, r2
 801525c:	4798      	blx	r3
    }

    hal.stream.write(gc_state.modal.retract_mode == CCRetractMode_RPos ? " G99" : " G98");
 801525e:	4b46      	ldr	r3, [pc, #280]	; (8015378 <report_gcode_modes+0x2a4>)
 8015260:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015264:	4a46      	ldr	r2, [pc, #280]	; (8015380 <report_gcode_modes+0x2ac>)
 8015266:	7f52      	ldrb	r2, [r2, #29]
 8015268:	2a01      	cmp	r2, #1
 801526a:	d101      	bne.n	8015270 <report_gcode_modes+0x19c>
 801526c:	4a55      	ldr	r2, [pc, #340]	; (80153c4 <report_gcode_modes+0x2f0>)
 801526e:	e000      	b.n	8015272 <report_gcode_modes+0x19e>
 8015270:	4a55      	ldr	r2, [pc, #340]	; (80153c8 <report_gcode_modes+0x2f4>)
 8015272:	4610      	mov	r0, r2
 8015274:	4798      	blx	r3

    if(gc_state.modal.scaling_active) {
 8015276:	4b42      	ldr	r3, [pc, #264]	; (8015380 <report_gcode_modes+0x2ac>)
 8015278:	7f9b      	ldrb	r3, [r3, #30]
 801527a:	2b00      	cmp	r3, #0
 801527c:	d011      	beq.n	80152a2 <report_gcode_modes+0x1ce>
        hal.stream.write(" G51:");
 801527e:	4b3e      	ldr	r3, [pc, #248]	; (8015378 <report_gcode_modes+0x2a4>)
 8015280:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015284:	4851      	ldr	r0, [pc, #324]	; (80153cc <report_gcode_modes+0x2f8>)
 8015286:	4798      	blx	r3
        axis_signals_tostring(buf, gc_get_g51_state());
 8015288:	f7f0 fb7c 	bl	8005984 <gc_get_g51_state>
 801528c:	4603      	mov	r3, r0
 801528e:	4619      	mov	r1, r3
 8015290:	484f      	ldr	r0, [pc, #316]	; (80153d0 <report_gcode_modes+0x2fc>)
 8015292:	f7fe fffd 	bl	8014290 <axis_signals_tostring>
        hal.stream.write(buf);
 8015296:	4b38      	ldr	r3, [pc, #224]	; (8015378 <report_gcode_modes+0x2a4>)
 8015298:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801529c:	484c      	ldr	r0, [pc, #304]	; (80153d0 <report_gcode_modes+0x2fc>)
 801529e:	4798      	blx	r3
 80152a0:	e004      	b.n	80152ac <report_gcode_modes+0x1d8>
    } else
        hal.stream.write(" G50");
 80152a2:	4b35      	ldr	r3, [pc, #212]	; (8015378 <report_gcode_modes+0x2a4>)
 80152a4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80152a8:	484a      	ldr	r0, [pc, #296]	; (80153d4 <report_gcode_modes+0x300>)
 80152aa:	4798      	blx	r3

#endif

    if (gc_state.modal.program_flow) {
 80152ac:	4b34      	ldr	r3, [pc, #208]	; (8015380 <report_gcode_modes+0x2ac>)
 80152ae:	7e1b      	ldrb	r3, [r3, #24]
 80152b0:	2b00      	cmp	r3, #0
 80152b2:	f000 80a4 	beq.w	80153fe <report_gcode_modes+0x32a>

        switch (gc_state.modal.program_flow) {
 80152b6:	4b32      	ldr	r3, [pc, #200]	; (8015380 <report_gcode_modes+0x2ac>)
 80152b8:	7e1b      	ldrb	r3, [r3, #24]
 80152ba:	2b1e      	cmp	r3, #30
 80152bc:	dc46      	bgt.n	801534c <report_gcode_modes+0x278>
 80152be:	2b00      	cmp	r3, #0
 80152c0:	f340 809c 	ble.w	80153fc <report_gcode_modes+0x328>
 80152c4:	3b01      	subs	r3, #1
 80152c6:	2b1d      	cmp	r3, #29
 80152c8:	f200 8098 	bhi.w	80153fc <report_gcode_modes+0x328>
 80152cc:	a201      	add	r2, pc, #4	; (adr r2, 80152d4 <report_gcode_modes+0x200>)
 80152ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80152d2:	bf00      	nop
 80152d4:	0801535f 	.word	0x0801535f
 80152d8:	0801536b 	.word	0x0801536b
 80152dc:	08015353 	.word	0x08015353
 80152e0:	080153fd 	.word	0x080153fd
 80152e4:	080153fd 	.word	0x080153fd
 80152e8:	080153fd 	.word	0x080153fd
 80152ec:	080153fd 	.word	0x080153fd
 80152f0:	080153fd 	.word	0x080153fd
 80152f4:	080153fd 	.word	0x080153fd
 80152f8:	080153fd 	.word	0x080153fd
 80152fc:	080153fd 	.word	0x080153fd
 8015300:	080153fd 	.word	0x080153fd
 8015304:	080153fd 	.word	0x080153fd
 8015308:	080153fd 	.word	0x080153fd
 801530c:	080153fd 	.word	0x080153fd
 8015310:	080153fd 	.word	0x080153fd
 8015314:	080153fd 	.word	0x080153fd
 8015318:	080153fd 	.word	0x080153fd
 801531c:	080153fd 	.word	0x080153fd
 8015320:	080153fd 	.word	0x080153fd
 8015324:	080153fd 	.word	0x080153fd
 8015328:	080153fd 	.word	0x080153fd
 801532c:	080153fd 	.word	0x080153fd
 8015330:	080153fd 	.word	0x080153fd
 8015334:	080153fd 	.word	0x080153fd
 8015338:	080153fd 	.word	0x080153fd
 801533c:	080153fd 	.word	0x080153fd
 8015340:	080153fd 	.word	0x080153fd
 8015344:	080153fd 	.word	0x080153fd
 8015348:	080153e5 	.word	0x080153e5
 801534c:	2b3c      	cmp	r3, #60	; 0x3c
 801534e:	d04f      	beq.n	80153f0 <report_gcode_modes+0x31c>
            case ProgramFlow_CompletedM60:
                hal.stream.write(" M60");
                break;

            default:
                break;
 8015350:	e054      	b.n	80153fc <report_gcode_modes+0x328>
                hal.stream.write(" M0");
 8015352:	4b09      	ldr	r3, [pc, #36]	; (8015378 <report_gcode_modes+0x2a4>)
 8015354:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015358:	481f      	ldr	r0, [pc, #124]	; (80153d8 <report_gcode_modes+0x304>)
 801535a:	4798      	blx	r3
                break;
 801535c:	e04f      	b.n	80153fe <report_gcode_modes+0x32a>
                hal.stream.write(" M1");
 801535e:	4b06      	ldr	r3, [pc, #24]	; (8015378 <report_gcode_modes+0x2a4>)
 8015360:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015364:	481d      	ldr	r0, [pc, #116]	; (80153dc <report_gcode_modes+0x308>)
 8015366:	4798      	blx	r3
                break;
 8015368:	e049      	b.n	80153fe <report_gcode_modes+0x32a>
                hal.stream.write(" M2");
 801536a:	4b03      	ldr	r3, [pc, #12]	; (8015378 <report_gcode_modes+0x2a4>)
 801536c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015370:	481b      	ldr	r0, [pc, #108]	; (80153e0 <report_gcode_modes+0x30c>)
 8015372:	4798      	blx	r3
                break;
 8015374:	e043      	b.n	80153fe <report_gcode_modes+0x32a>
 8015376:	bf00      	nop
 8015378:	20000ed0 	.word	0x20000ed0
 801537c:	0802b308 	.word	0x0802b308
 8015380:	20000bb0 	.word	0x20000bb0
 8015384:	0802b310 	.word	0x0802b310
 8015388:	0802b314 	.word	0x0802b314
 801538c:	0802b318 	.word	0x0802b318
 8015390:	2000147c 	.word	0x2000147c
 8015394:	0802b320 	.word	0x0802b320
 8015398:	0802b324 	.word	0x0802b324
 801539c:	0802b328 	.word	0x0802b328
 80153a0:	0802b330 	.word	0x0802b330
 80153a4:	0802b338 	.word	0x0802b338
 80153a8:	0802b340 	.word	0x0802b340
 80153ac:	0802b348 	.word	0x0802b348
 80153b0:	0802b350 	.word	0x0802b350
 80153b4:	0802b358 	.word	0x0802b358
 80153b8:	0802b360 	.word	0x0802b360
 80153bc:	0802b368 	.word	0x0802b368
 80153c0:	0802b36c 	.word	0x0802b36c
 80153c4:	0802b370 	.word	0x0802b370
 80153c8:	0802b378 	.word	0x0802b378
 80153cc:	0802b380 	.word	0x0802b380
 80153d0:	20001404 	.word	0x20001404
 80153d4:	0802b388 	.word	0x0802b388
 80153d8:	0802b390 	.word	0x0802b390
 80153dc:	0802b394 	.word	0x0802b394
 80153e0:	0802b398 	.word	0x0802b398
                hal.stream.write(" M30");
 80153e4:	4b69      	ldr	r3, [pc, #420]	; (801558c <report_gcode_modes+0x4b8>)
 80153e6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80153ea:	4869      	ldr	r0, [pc, #420]	; (8015590 <report_gcode_modes+0x4bc>)
 80153ec:	4798      	blx	r3
                break;
 80153ee:	e006      	b.n	80153fe <report_gcode_modes+0x32a>
                hal.stream.write(" M60");
 80153f0:	4b66      	ldr	r3, [pc, #408]	; (801558c <report_gcode_modes+0x4b8>)
 80153f2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80153f6:	4867      	ldr	r0, [pc, #412]	; (8015594 <report_gcode_modes+0x4c0>)
 80153f8:	4798      	blx	r3
                break;
 80153fa:	e000      	b.n	80153fe <report_gcode_modes+0x32a>
                break;
 80153fc:	bf00      	nop
        }
    }

    hal.stream.write(gc_state.modal.spindle.state.on ? (gc_state.modal.spindle.state.ccw ? " M4" : " M3") : " M5");
 80153fe:	4b63      	ldr	r3, [pc, #396]	; (801558c <report_gcode_modes+0x4b8>)
 8015400:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8015404:	4b64      	ldr	r3, [pc, #400]	; (8015598 <report_gcode_modes+0x4c4>)
 8015406:	7e9b      	ldrb	r3, [r3, #26]
 8015408:	f003 0301 	and.w	r3, r3, #1
 801540c:	b2db      	uxtb	r3, r3
 801540e:	2b00      	cmp	r3, #0
 8015410:	d00a      	beq.n	8015428 <report_gcode_modes+0x354>
 8015412:	4b61      	ldr	r3, [pc, #388]	; (8015598 <report_gcode_modes+0x4c4>)
 8015414:	7e9b      	ldrb	r3, [r3, #26]
 8015416:	f003 0302 	and.w	r3, r3, #2
 801541a:	b2db      	uxtb	r3, r3
 801541c:	2b00      	cmp	r3, #0
 801541e:	d001      	beq.n	8015424 <report_gcode_modes+0x350>
 8015420:	4b5e      	ldr	r3, [pc, #376]	; (801559c <report_gcode_modes+0x4c8>)
 8015422:	e002      	b.n	801542a <report_gcode_modes+0x356>
 8015424:	4b5e      	ldr	r3, [pc, #376]	; (80155a0 <report_gcode_modes+0x4cc>)
 8015426:	e000      	b.n	801542a <report_gcode_modes+0x356>
 8015428:	4b5e      	ldr	r3, [pc, #376]	; (80155a4 <report_gcode_modes+0x4d0>)
 801542a:	4618      	mov	r0, r3
 801542c:	4790      	blx	r2

    if(gc_state.tool_change)
 801542e:	4b5a      	ldr	r3, [pc, #360]	; (8015598 <report_gcode_modes+0x4c4>)
 8015430:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 8015434:	2b00      	cmp	r3, #0
 8015436:	d004      	beq.n	8015442 <report_gcode_modes+0x36e>
        hal.stream.write(" M6");
 8015438:	4b54      	ldr	r3, [pc, #336]	; (801558c <report_gcode_modes+0x4b8>)
 801543a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801543e:	485a      	ldr	r0, [pc, #360]	; (80155a8 <report_gcode_modes+0x4d4>)
 8015440:	4798      	blx	r3

    if (gc_state.modal.coolant.value) {
 8015442:	4b55      	ldr	r3, [pc, #340]	; (8015598 <report_gcode_modes+0x4c4>)
 8015444:	7e5b      	ldrb	r3, [r3, #25]
 8015446:	2b00      	cmp	r3, #0
 8015448:	d018      	beq.n	801547c <report_gcode_modes+0x3a8>

        if (gc_state.modal.coolant.mist)
 801544a:	4b53      	ldr	r3, [pc, #332]	; (8015598 <report_gcode_modes+0x4c4>)
 801544c:	7e5b      	ldrb	r3, [r3, #25]
 801544e:	f003 0302 	and.w	r3, r3, #2
 8015452:	b2db      	uxtb	r3, r3
 8015454:	2b00      	cmp	r3, #0
 8015456:	d004      	beq.n	8015462 <report_gcode_modes+0x38e>
             hal.stream.write(" M7");
 8015458:	4b4c      	ldr	r3, [pc, #304]	; (801558c <report_gcode_modes+0x4b8>)
 801545a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801545e:	4853      	ldr	r0, [pc, #332]	; (80155ac <report_gcode_modes+0x4d8>)
 8015460:	4798      	blx	r3

        if (gc_state.modal.coolant.flood)
 8015462:	4b4d      	ldr	r3, [pc, #308]	; (8015598 <report_gcode_modes+0x4c4>)
 8015464:	7e5b      	ldrb	r3, [r3, #25]
 8015466:	f003 0301 	and.w	r3, r3, #1
 801546a:	b2db      	uxtb	r3, r3
 801546c:	2b00      	cmp	r3, #0
 801546e:	d00a      	beq.n	8015486 <report_gcode_modes+0x3b2>
            hal.stream.write(" M8");
 8015470:	4b46      	ldr	r3, [pc, #280]	; (801558c <report_gcode_modes+0x4b8>)
 8015472:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015476:	484e      	ldr	r0, [pc, #312]	; (80155b0 <report_gcode_modes+0x4dc>)
 8015478:	4798      	blx	r3
 801547a:	e004      	b.n	8015486 <report_gcode_modes+0x3b2>

    } else
        hal.stream.write(" M9");
 801547c:	4b43      	ldr	r3, [pc, #268]	; (801558c <report_gcode_modes+0x4b8>)
 801547e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015482:	484c      	ldr	r0, [pc, #304]	; (80155b4 <report_gcode_modes+0x4e0>)
 8015484:	4798      	blx	r3

    if (sys.override.control.feed_rate_disable)
 8015486:	4b4c      	ldr	r3, [pc, #304]	; (80155b8 <report_gcode_modes+0x4e4>)
 8015488:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801548c:	f003 0301 	and.w	r3, r3, #1
 8015490:	b2db      	uxtb	r3, r3
 8015492:	2b00      	cmp	r3, #0
 8015494:	d004      	beq.n	80154a0 <report_gcode_modes+0x3cc>
        hal.stream.write(" M50");
 8015496:	4b3d      	ldr	r3, [pc, #244]	; (801558c <report_gcode_modes+0x4b8>)
 8015498:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801549c:	4847      	ldr	r0, [pc, #284]	; (80155bc <report_gcode_modes+0x4e8>)
 801549e:	4798      	blx	r3

    if (sys.override.control.spindle_rpm_disable)
 80154a0:	4b45      	ldr	r3, [pc, #276]	; (80155b8 <report_gcode_modes+0x4e4>)
 80154a2:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80154a6:	f003 0304 	and.w	r3, r3, #4
 80154aa:	b2db      	uxtb	r3, r3
 80154ac:	2b00      	cmp	r3, #0
 80154ae:	d004      	beq.n	80154ba <report_gcode_modes+0x3e6>
        hal.stream.write(" M51");
 80154b0:	4b36      	ldr	r3, [pc, #216]	; (801558c <report_gcode_modes+0x4b8>)
 80154b2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80154b6:	4842      	ldr	r0, [pc, #264]	; (80155c0 <report_gcode_modes+0x4ec>)
 80154b8:	4798      	blx	r3

    if (sys.override.control.feed_hold_disable)
 80154ba:	4b3f      	ldr	r3, [pc, #252]	; (80155b8 <report_gcode_modes+0x4e4>)
 80154bc:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80154c0:	f003 0302 	and.w	r3, r3, #2
 80154c4:	b2db      	uxtb	r3, r3
 80154c6:	2b00      	cmp	r3, #0
 80154c8:	d004      	beq.n	80154d4 <report_gcode_modes+0x400>
        hal.stream.write(" M53");
 80154ca:	4b30      	ldr	r3, [pc, #192]	; (801558c <report_gcode_modes+0x4b8>)
 80154cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80154d0:	483c      	ldr	r0, [pc, #240]	; (80155c4 <report_gcode_modes+0x4f0>)
 80154d2:	4798      	blx	r3

    if (settings.parking.flags.enable_override_control && sys.override.control.parking_disable)
 80154d4:	4b3c      	ldr	r3, [pc, #240]	; (80155c8 <report_gcode_modes+0x4f4>)
 80154d6:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 80154da:	f003 0304 	and.w	r3, r3, #4
 80154de:	b2db      	uxtb	r3, r3
 80154e0:	2b00      	cmp	r3, #0
 80154e2:	d00c      	beq.n	80154fe <report_gcode_modes+0x42a>
 80154e4:	4b34      	ldr	r3, [pc, #208]	; (80155b8 <report_gcode_modes+0x4e4>)
 80154e6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80154ea:	f003 0308 	and.w	r3, r3, #8
 80154ee:	b2db      	uxtb	r3, r3
 80154f0:	2b00      	cmp	r3, #0
 80154f2:	d004      	beq.n	80154fe <report_gcode_modes+0x42a>
        hal.stream.write(" M56");
 80154f4:	4b25      	ldr	r3, [pc, #148]	; (801558c <report_gcode_modes+0x4b8>)
 80154f6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80154fa:	4834      	ldr	r0, [pc, #208]	; (80155cc <report_gcode_modes+0x4f8>)
 80154fc:	4798      	blx	r3

    hal.stream.write(appendbuf(2, " T", uitoa((uint32_t)gc_state.tool->tool_id)));
 80154fe:	4b23      	ldr	r3, [pc, #140]	; (801558c <report_gcode_modes+0x4b8>)
 8015500:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015504:	4b24      	ldr	r3, [pc, #144]	; (8015598 <report_gcode_modes+0x4c4>)
 8015506:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801550a:	691b      	ldr	r3, [r3, #16]
 801550c:	4618      	mov	r0, r3
 801550e:	f7fa febd 	bl	801028c <uitoa>
 8015512:	4603      	mov	r3, r0
 8015514:	461a      	mov	r2, r3
 8015516:	492e      	ldr	r1, [pc, #184]	; (80155d0 <report_gcode_modes+0x4fc>)
 8015518:	2002      	movs	r0, #2
 801551a:	f7fe fd47 	bl	8013fac <appendbuf>
 801551e:	4603      	mov	r3, r0
 8015520:	4618      	mov	r0, r3
 8015522:	47a0      	blx	r4

    hal.stream.write(appendbuf(2, " F", get_rate_value(gc_state.feed_rate)));
 8015524:	4b19      	ldr	r3, [pc, #100]	; (801558c <report_gcode_modes+0x4b8>)
 8015526:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 801552a:	4b2a      	ldr	r3, [pc, #168]	; (80155d4 <report_gcode_modes+0x500>)
 801552c:	681b      	ldr	r3, [r3, #0]
 801552e:	4a1a      	ldr	r2, [pc, #104]	; (8015598 <report_gcode_modes+0x4c4>)
 8015530:	6d52      	ldr	r2, [r2, #84]	; 0x54
 8015532:	4610      	mov	r0, r2
 8015534:	4798      	blx	r3
 8015536:	4603      	mov	r3, r0
 8015538:	461a      	mov	r2, r3
 801553a:	4927      	ldr	r1, [pc, #156]	; (80155d8 <report_gcode_modes+0x504>)
 801553c:	2002      	movs	r0, #2
 801553e:	f7fe fd35 	bl	8013fac <appendbuf>
 8015542:	4603      	mov	r3, r0
 8015544:	4618      	mov	r0, r3
 8015546:	47a0      	blx	r4

    if(gc_spindle_get()->cap.variable)
 8015548:	f7f0 fc4e 	bl	8005de8 <gc_spindle_get>
 801554c:	4603      	mov	r3, r0
 801554e:	7a9b      	ldrb	r3, [r3, #10]
 8015550:	f003 0301 	and.w	r3, r3, #1
 8015554:	b2db      	uxtb	r3, r3
 8015556:	2b00      	cmp	r3, #0
 8015558:	d011      	beq.n	801557e <report_gcode_modes+0x4aa>
        hal.stream.write(appendbuf(2, " S", ftoa(gc_state.spindle.rpm, N_DECIMAL_RPMVALUE)));
 801555a:	4b0c      	ldr	r3, [pc, #48]	; (801558c <report_gcode_modes+0x4b8>)
 801555c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015560:	4b0d      	ldr	r3, [pc, #52]	; (8015598 <report_gcode_modes+0x4c4>)
 8015562:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015564:	2100      	movs	r1, #0
 8015566:	4618      	mov	r0, r3
 8015568:	f7fa fecc 	bl	8010304 <ftoa>
 801556c:	4603      	mov	r3, r0
 801556e:	461a      	mov	r2, r3
 8015570:	491a      	ldr	r1, [pc, #104]	; (80155dc <report_gcode_modes+0x508>)
 8015572:	2002      	movs	r0, #2
 8015574:	f7fe fd1a 	bl	8013fac <appendbuf>
 8015578:	4603      	mov	r3, r0
 801557a:	4618      	mov	r0, r3
 801557c:	47a0      	blx	r4

    hal.stream.write("]" ASCII_EOL);
 801557e:	4b03      	ldr	r3, [pc, #12]	; (801558c <report_gcode_modes+0x4b8>)
 8015580:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015584:	4816      	ldr	r0, [pc, #88]	; (80155e0 <report_gcode_modes+0x50c>)
 8015586:	4798      	blx	r3
}
 8015588:	bf00      	nop
 801558a:	bd98      	pop	{r3, r4, r7, pc}
 801558c:	20000ed0 	.word	0x20000ed0
 8015590:	0802b39c 	.word	0x0802b39c
 8015594:	0802b3a4 	.word	0x0802b3a4
 8015598:	20000bb0 	.word	0x20000bb0
 801559c:	0802b3ac 	.word	0x0802b3ac
 80155a0:	0802b3b0 	.word	0x0802b3b0
 80155a4:	0802b3b4 	.word	0x0802b3b4
 80155a8:	0802b3b8 	.word	0x0802b3b8
 80155ac:	0802b3bc 	.word	0x0802b3bc
 80155b0:	0802b3c0 	.word	0x0802b3c0
 80155b4:	0802b3c4 	.word	0x0802b3c4
 80155b8:	20000d3c 	.word	0x20000d3c
 80155bc:	0802b3c8 	.word	0x0802b3c8
 80155c0:	0802b3d0 	.word	0x0802b3d0
 80155c4:	0802b3d8 	.word	0x0802b3d8
 80155c8:	2000147c 	.word	0x2000147c
 80155cc:	0802b3e0 	.word	0x0802b3e0
 80155d0:	0802b3e8 	.word	0x0802b3e8
 80155d4:	2000143c 	.word	0x2000143c
 80155d8:	0802b3ec 	.word	0x0802b3ec
 80155dc:	0802b3f0 	.word	0x0802b3f0
 80155e0:	0802b1c0 	.word	0x0802b1c0

080155e4 <report_startup_line>:

// Prints specified startup line
void report_startup_line (uint8_t n, char *line)
{
 80155e4:	b590      	push	{r4, r7, lr}
 80155e6:	b083      	sub	sp, #12
 80155e8:	af00      	add	r7, sp, #0
 80155ea:	4603      	mov	r3, r0
 80155ec:	6039      	str	r1, [r7, #0]
 80155ee:	71fb      	strb	r3, [r7, #7]
    hal.stream.write(appendbuf(3, "$N", uitoa((uint32_t)n), "="));
 80155f0:	4b0e      	ldr	r3, [pc, #56]	; (801562c <report_startup_line+0x48>)
 80155f2:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80155f6:	79fb      	ldrb	r3, [r7, #7]
 80155f8:	4618      	mov	r0, r3
 80155fa:	f7fa fe47 	bl	801028c <uitoa>
 80155fe:	4602      	mov	r2, r0
 8015600:	4b0b      	ldr	r3, [pc, #44]	; (8015630 <report_startup_line+0x4c>)
 8015602:	490c      	ldr	r1, [pc, #48]	; (8015634 <report_startup_line+0x50>)
 8015604:	2003      	movs	r0, #3
 8015606:	f7fe fcd1 	bl	8013fac <appendbuf>
 801560a:	4603      	mov	r3, r0
 801560c:	4618      	mov	r0, r3
 801560e:	47a0      	blx	r4
    hal.stream.write(line);
 8015610:	4b06      	ldr	r3, [pc, #24]	; (801562c <report_startup_line+0x48>)
 8015612:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015616:	6838      	ldr	r0, [r7, #0]
 8015618:	4798      	blx	r3
    hal.stream.write(ASCII_EOL);
 801561a:	4b04      	ldr	r3, [pc, #16]	; (801562c <report_startup_line+0x48>)
 801561c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015620:	4805      	ldr	r0, [pc, #20]	; (8015638 <report_startup_line+0x54>)
 8015622:	4798      	blx	r3
}
 8015624:	bf00      	nop
 8015626:	370c      	adds	r7, #12
 8015628:	46bd      	mov	sp, r7
 801562a:	bd90      	pop	{r4, r7, pc}
 801562c:	20000ed0 	.word	0x20000ed0
 8015630:	0802b29c 	.word	0x0802b29c
 8015634:	0802b3f4 	.word	0x0802b3f4
 8015638:	0802b190 	.word	0x0802b190

0801563c <report_execute_startup_message>:

void report_execute_startup_message (char *line, status_code_t status_code)
{
 801563c:	b580      	push	{r7, lr}
 801563e:	b082      	sub	sp, #8
 8015640:	af00      	add	r7, sp, #0
 8015642:	6078      	str	r0, [r7, #4]
 8015644:	460b      	mov	r3, r1
 8015646:	70fb      	strb	r3, [r7, #3]
    hal.stream.write(">");
 8015648:	4b0b      	ldr	r3, [pc, #44]	; (8015678 <report_execute_startup_message+0x3c>)
 801564a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801564e:	480b      	ldr	r0, [pc, #44]	; (801567c <report_execute_startup_message+0x40>)
 8015650:	4798      	blx	r3
    hal.stream.write(line);
 8015652:	4b09      	ldr	r3, [pc, #36]	; (8015678 <report_execute_startup_message+0x3c>)
 8015654:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015658:	6878      	ldr	r0, [r7, #4]
 801565a:	4798      	blx	r3
    hal.stream.write(":");
 801565c:	4b06      	ldr	r3, [pc, #24]	; (8015678 <report_execute_startup_message+0x3c>)
 801565e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015662:	4807      	ldr	r0, [pc, #28]	; (8015680 <report_execute_startup_message+0x44>)
 8015664:	4798      	blx	r3
    grbl.report.status_message(status_code);
 8015666:	4b07      	ldr	r3, [pc, #28]	; (8015684 <report_execute_startup_message+0x48>)
 8015668:	689b      	ldr	r3, [r3, #8]
 801566a:	78fa      	ldrb	r2, [r7, #3]
 801566c:	4610      	mov	r0, r2
 801566e:	4798      	blx	r3
}
 8015670:	bf00      	nop
 8015672:	3708      	adds	r7, #8
 8015674:	46bd      	mov	sp, r7
 8015676:	bd80      	pop	{r7, pc}
 8015678:	20000ed0 	.word	0x20000ed0
 801567c:	0802b3f8 	.word	0x0802b3f8
 8015680:	0802b2c4 	.word	0x0802b2c4
 8015684:	20000dd4 	.word	0x20000dd4

08015688 <report_build_info>:

// Prints build info line
void report_build_info (char *line, bool extended)
{
 8015688:	b5b0      	push	{r4, r5, r7, lr}
 801568a:	b09e      	sub	sp, #120	; 0x78
 801568c:	af00      	add	r7, sp, #0
 801568e:	6078      	str	r0, [r7, #4]
 8015690:	460b      	mov	r3, r1
 8015692:	70fb      	strb	r3, [r7, #3]
    char buf[100];

    hal.stream.write("[VER:" GRBL_VERSION ".");
 8015694:	4baf      	ldr	r3, [pc, #700]	; (8015954 <report_build_info+0x2cc>)
 8015696:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801569a:	48af      	ldr	r0, [pc, #700]	; (8015958 <report_build_info+0x2d0>)
 801569c:	4798      	blx	r3
    hal.stream.write(uitoa(GRBL_BUILD));
 801569e:	4bad      	ldr	r3, [pc, #692]	; (8015954 <report_build_info+0x2cc>)
 80156a0:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80156a4:	48ad      	ldr	r0, [pc, #692]	; (801595c <report_build_info+0x2d4>)
 80156a6:	f7fa fdf1 	bl	801028c <uitoa>
 80156aa:	4603      	mov	r3, r0
 80156ac:	4618      	mov	r0, r3
 80156ae:	47a0      	blx	r4
    hal.stream.write(":");
 80156b0:	4ba8      	ldr	r3, [pc, #672]	; (8015954 <report_build_info+0x2cc>)
 80156b2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80156b6:	48aa      	ldr	r0, [pc, #680]	; (8015960 <report_build_info+0x2d8>)
 80156b8:	4798      	blx	r3
    hal.stream.write(line);
 80156ba:	4ba6      	ldr	r3, [pc, #664]	; (8015954 <report_build_info+0x2cc>)
 80156bc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80156c0:	6878      	ldr	r0, [r7, #4]
 80156c2:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 80156c4:	4ba3      	ldr	r3, [pc, #652]	; (8015954 <report_build_info+0x2cc>)
 80156c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80156ca:	48a6      	ldr	r0, [pc, #664]	; (8015964 <report_build_info+0x2dc>)
 80156cc:	4798      	blx	r3

#if COMPATIBILITY_LEVEL == 0
    extended = true;
 80156ce:	2301      	movs	r3, #1
 80156d0:	70fb      	strb	r3, [r7, #3]
#endif

    // Generate compile-time build option list

    char *append = &buf[5];
 80156d2:	f107 0308 	add.w	r3, r7, #8
 80156d6:	3305      	adds	r3, #5
 80156d8:	677b      	str	r3, [r7, #116]	; 0x74

    strcpy(buf, "[OPT:");
 80156da:	f107 0308 	add.w	r3, r7, #8
 80156de:	4aa2      	ldr	r2, [pc, #648]	; (8015968 <report_build_info+0x2e0>)
 80156e0:	e892 0003 	ldmia.w	r2, {r0, r1}
 80156e4:	6018      	str	r0, [r3, #0]
 80156e6:	3304      	adds	r3, #4
 80156e8:	8019      	strh	r1, [r3, #0]

    if(spindle_get_caps(false).variable)
 80156ea:	2000      	movs	r0, #0
 80156ec:	f007 f856 	bl	801c79c <spindle_get_caps>
 80156f0:	4603      	mov	r3, r0
 80156f2:	b2db      	uxtb	r3, r3
 80156f4:	f003 0301 	and.w	r3, r3, #1
 80156f8:	b2db      	uxtb	r3, r3
 80156fa:	2b00      	cmp	r3, #0
 80156fc:	d004      	beq.n	8015708 <report_build_info+0x80>
        *append++ = 'V';
 80156fe:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015700:	1c5a      	adds	r2, r3, #1
 8015702:	677a      	str	r2, [r7, #116]	; 0x74
 8015704:	2256      	movs	r2, #86	; 0x56
 8015706:	701a      	strb	r2, [r3, #0]

    *append++ = 'N';
 8015708:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801570a:	1c5a      	adds	r2, r3, #1
 801570c:	677a      	str	r2, [r7, #116]	; 0x74
 801570e:	224e      	movs	r2, #78	; 0x4e
 8015710:	701a      	strb	r2, [r3, #0]

    if(hal.driver_cap.mist_control)
 8015712:	4b90      	ldr	r3, [pc, #576]	; (8015954 <report_build_info+0x2cc>)
 8015714:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 8015718:	f003 0301 	and.w	r3, r3, #1
 801571c:	b2db      	uxtb	r3, r3
 801571e:	2b00      	cmp	r3, #0
 8015720:	d004      	beq.n	801572c <report_build_info+0xa4>
        *append++ = 'M';
 8015722:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015724:	1c5a      	adds	r2, r3, #1
 8015726:	677a      	str	r2, [r7, #116]	; 0x74
 8015728:	224d      	movs	r2, #77	; 0x4d
 801572a:	701a      	strb	r2, [r3, #0]

#if COREXY
    *append++ = 'C';
 801572c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801572e:	1c5a      	adds	r2, r3, #1
 8015730:	677a      	str	r2, [r7, #116]	; 0x74
 8015732:	2243      	movs	r2, #67	; 0x43
 8015734:	701a      	strb	r2, [r3, #0]
#endif

    if(settings.parking.flags.enabled)
 8015736:	4b8d      	ldr	r3, [pc, #564]	; (801596c <report_build_info+0x2e4>)
 8015738:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801573c:	f003 0301 	and.w	r3, r3, #1
 8015740:	b2db      	uxtb	r3, r3
 8015742:	2b00      	cmp	r3, #0
 8015744:	d004      	beq.n	8015750 <report_build_info+0xc8>
        *append++ = 'P';
 8015746:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015748:	1c5a      	adds	r2, r3, #1
 801574a:	677a      	str	r2, [r7, #116]	; 0x74
 801574c:	2250      	movs	r2, #80	; 0x50
 801574e:	701a      	strb	r2, [r3, #0]

    if(settings.homing.flags.force_set_origin)
 8015750:	4b86      	ldr	r3, [pc, #536]	; (801596c <report_build_info+0x2e4>)
 8015752:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8015756:	f003 0308 	and.w	r3, r3, #8
 801575a:	b2db      	uxtb	r3, r3
 801575c:	2b00      	cmp	r3, #0
 801575e:	d004      	beq.n	801576a <report_build_info+0xe2>
        *append++ = 'Z';
 8015760:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015762:	1c5a      	adds	r2, r3, #1
 8015764:	677a      	str	r2, [r7, #116]	; 0x74
 8015766:	225a      	movs	r2, #90	; 0x5a
 8015768:	701a      	strb	r2, [r3, #0]

    if(settings.homing.flags.single_axis_commands)
 801576a:	4b80      	ldr	r3, [pc, #512]	; (801596c <report_build_info+0x2e4>)
 801576c:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8015770:	f003 0302 	and.w	r3, r3, #2
 8015774:	b2db      	uxtb	r3, r3
 8015776:	2b00      	cmp	r3, #0
 8015778:	d004      	beq.n	8015784 <report_build_info+0xfc>
        *append++ = 'H';
 801577a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801577c:	1c5a      	adds	r2, r3, #1
 801577e:	677a      	str	r2, [r7, #116]	; 0x74
 8015780:	2248      	movs	r2, #72	; 0x48
 8015782:	701a      	strb	r2, [r3, #0]

    if(settings.limits.flags.two_switches)
 8015784:	4b79      	ldr	r3, [pc, #484]	; (801596c <report_build_info+0x2e4>)
 8015786:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801578a:	f003 0310 	and.w	r3, r3, #16
 801578e:	b2db      	uxtb	r3, r3
 8015790:	2b00      	cmp	r3, #0
 8015792:	d004      	beq.n	801579e <report_build_info+0x116>
        *append++ = 'T';
 8015794:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015796:	1c5a      	adds	r2, r3, #1
 8015798:	677a      	str	r2, [r7, #116]	; 0x74
 801579a:	2254      	movs	r2, #84	; 0x54
 801579c:	701a      	strb	r2, [r3, #0]

    if(settings.probe.allow_feed_override)
 801579e:	4b73      	ldr	r3, [pc, #460]	; (801596c <report_build_info+0x2e4>)
 80157a0:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80157a4:	f003 0310 	and.w	r3, r3, #16
 80157a8:	b2db      	uxtb	r3, r3
 80157aa:	2b00      	cmp	r3, #0
 80157ac:	d004      	beq.n	80157b8 <report_build_info+0x130>
        *append++ = 'A';
 80157ae:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80157b0:	1c5a      	adds	r2, r3, #1
 80157b2:	677a      	str	r2, [r7, #116]	; 0x74
 80157b4:	2241      	movs	r2, #65	; 0x41
 80157b6:	701a      	strb	r2, [r3, #0]

    if(settings.spindle.flags.enable_rpm_controlled)
 80157b8:	4b6c      	ldr	r3, [pc, #432]	; (801596c <report_build_info+0x2e4>)
 80157ba:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 80157be:	f003 0301 	and.w	r3, r3, #1
 80157c2:	b2db      	uxtb	r3, r3
 80157c4:	2b00      	cmp	r3, #0
 80157c6:	d004      	beq.n	80157d2 <report_build_info+0x14a>
        *append++ = '0';
 80157c8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80157ca:	1c5a      	adds	r2, r3, #1
 80157cc:	677a      	str	r2, [r7, #116]	; 0x74
 80157ce:	2230      	movs	r2, #48	; 0x30
 80157d0:	701a      	strb	r2, [r3, #0]

    if(hal.driver_cap.software_debounce)
 80157d2:	4b60      	ldr	r3, [pc, #384]	; (8015954 <report_build_info+0x2cc>)
 80157d4:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 80157d8:	f003 0302 	and.w	r3, r3, #2
 80157dc:	b2db      	uxtb	r3, r3
 80157de:	2b00      	cmp	r3, #0
 80157e0:	d004      	beq.n	80157ec <report_build_info+0x164>
        *append++ = 'S';
 80157e2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80157e4:	1c5a      	adds	r2, r3, #1
 80157e6:	677a      	str	r2, [r7, #116]	; 0x74
 80157e8:	2253      	movs	r2, #83	; 0x53
 80157ea:	701a      	strb	r2, [r3, #0]

    if(settings.parking.flags.enable_override_control)
 80157ec:	4b5f      	ldr	r3, [pc, #380]	; (801596c <report_build_info+0x2e4>)
 80157ee:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 80157f2:	f003 0304 	and.w	r3, r3, #4
 80157f6:	b2db      	uxtb	r3, r3
 80157f8:	2b00      	cmp	r3, #0
 80157fa:	d004      	beq.n	8015806 <report_build_info+0x17e>
        *append++ = 'R';
 80157fc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80157fe:	1c5a      	adds	r2, r3, #1
 8015800:	677a      	str	r2, [r7, #116]	; 0x74
 8015802:	2252      	movs	r2, #82	; 0x52
 8015804:	701a      	strb	r2, [r3, #0]

    if(!settings.homing.flags.init_lock)
 8015806:	4b59      	ldr	r3, [pc, #356]	; (801596c <report_build_info+0x2e4>)
 8015808:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801580c:	f003 0304 	and.w	r3, r3, #4
 8015810:	b2db      	uxtb	r3, r3
 8015812:	2b00      	cmp	r3, #0
 8015814:	d104      	bne.n	8015820 <report_build_info+0x198>
        *append++ = 'L';
 8015816:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015818:	1c5a      	adds	r2, r3, #1
 801581a:	677a      	str	r2, [r7, #116]	; 0x74
 801581c:	224c      	movs	r2, #76	; 0x4c
 801581e:	701a      	strb	r2, [r3, #0]

    if(hal.signals_cap.safety_door_ajar)
 8015820:	4b4c      	ldr	r3, [pc, #304]	; (8015954 <report_build_info+0x2cc>)
 8015822:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8015826:	f003 0308 	and.w	r3, r3, #8
 801582a:	b2db      	uxtb	r3, r3
 801582c:	2b00      	cmp	r3, #0
 801582e:	d004      	beq.n	801583a <report_build_info+0x1b2>
        *append++ = '+';
 8015830:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015832:	1c5a      	adds	r2, r3, #1
 8015834:	677a      	str	r2, [r7, #116]	; 0x74
 8015836:	222b      	movs	r2, #43	; 0x2b
 8015838:	701a      	strb	r2, [r3, #0]

  #if DISABLE_BUILD_INFO_WRITE_COMMAND // NOTE: Shown when disabled.
    *append++ = 'I';
  #endif

    if(!settings.status_report.sync_on_wco_change) // NOTE: Shown when disabled.
 801583a:	4b4c      	ldr	r3, [pc, #304]	; (801596c <report_build_info+0x2e4>)
 801583c:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8015840:	f003 0301 	and.w	r3, r3, #1
 8015844:	b2db      	uxtb	r3, r3
 8015846:	2b00      	cmp	r3, #0
 8015848:	d104      	bne.n	8015854 <report_build_info+0x1cc>
        *append++ = 'W';
 801584a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801584c:	1c5a      	adds	r2, r3, #1
 801584e:	677a      	str	r2, [r7, #116]	; 0x74
 8015850:	2257      	movs	r2, #87	; 0x57
 8015852:	701a      	strb	r2, [r3, #0]

    if(hal.stepper.get_ganged)
 8015854:	4b3f      	ldr	r3, [pc, #252]	; (8015954 <report_build_info+0x2cc>)
 8015856:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801585a:	2b00      	cmp	r3, #0
 801585c:	d004      	beq.n	8015868 <report_build_info+0x1e0>
        *append++ = '2';
 801585e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015860:	1c5a      	adds	r2, r3, #1
 8015862:	677a      	str	r2, [r7, #116]	; 0x74
 8015864:	2232      	movs	r2, #50	; 0x32
 8015866:	701a      	strb	r2, [r3, #0]

    *append++ = ',';
 8015868:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801586a:	1c5a      	adds	r2, r3, #1
 801586c:	677a      	str	r2, [r7, #116]	; 0x74
 801586e:	222c      	movs	r2, #44	; 0x2c
 8015870:	701a      	strb	r2, [r3, #0]
    *append = '\0';
 8015872:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015874:	2200      	movs	r2, #0
 8015876:	701a      	strb	r2, [r3, #0]
    hal.stream.write(buf);
 8015878:	4b36      	ldr	r3, [pc, #216]	; (8015954 <report_build_info+0x2cc>)
 801587a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801587e:	f107 0208 	add.w	r2, r7, #8
 8015882:	4610      	mov	r0, r2
 8015884:	4798      	blx	r3

    // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
    hal.stream.write(uitoa((uint32_t)plan_get_buffer_size()));
 8015886:	4b33      	ldr	r3, [pc, #204]	; (8015954 <report_build_info+0x2cc>)
 8015888:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 801588c:	f7fb ff3e 	bl	801170c <plan_get_buffer_size>
 8015890:	4603      	mov	r3, r0
 8015892:	4618      	mov	r0, r3
 8015894:	f7fa fcfa 	bl	801028c <uitoa>
 8015898:	4603      	mov	r3, r0
 801589a:	4618      	mov	r0, r3
 801589c:	47a0      	blx	r4
    hal.stream.write(",");
 801589e:	4b2d      	ldr	r3, [pc, #180]	; (8015954 <report_build_info+0x2cc>)
 80158a0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80158a4:	4832      	ldr	r0, [pc, #200]	; (8015970 <report_build_info+0x2e8>)
 80158a6:	4798      	blx	r3
    hal.stream.write(uitoa(hal.rx_buffer_size));
 80158a8:	4b2a      	ldr	r3, [pc, #168]	; (8015954 <report_build_info+0x2cc>)
 80158aa:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80158ae:	4b29      	ldr	r3, [pc, #164]	; (8015954 <report_build_info+0x2cc>)
 80158b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80158b2:	4618      	mov	r0, r3
 80158b4:	f7fa fcea 	bl	801028c <uitoa>
 80158b8:	4603      	mov	r3, r0
 80158ba:	4618      	mov	r0, r3
 80158bc:	47a0      	blx	r4
    if(extended) {
 80158be:	78fb      	ldrb	r3, [r7, #3]
 80158c0:	2b00      	cmp	r3, #0
 80158c2:	d01d      	beq.n	8015900 <report_build_info+0x278>
        hal.stream.write(",");
 80158c4:	4b23      	ldr	r3, [pc, #140]	; (8015954 <report_build_info+0x2cc>)
 80158c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80158ca:	4829      	ldr	r0, [pc, #164]	; (8015970 <report_build_info+0x2e8>)
 80158cc:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)N_AXIS));
 80158ce:	4b21      	ldr	r3, [pc, #132]	; (8015954 <report_build_info+0x2cc>)
 80158d0:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80158d4:	2003      	movs	r0, #3
 80158d6:	f7fa fcd9 	bl	801028c <uitoa>
 80158da:	4603      	mov	r3, r0
 80158dc:	4618      	mov	r0, r3
 80158de:	47a0      	blx	r4
        hal.stream.write(",");
 80158e0:	4b1c      	ldr	r3, [pc, #112]	; (8015954 <report_build_info+0x2cc>)
 80158e2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80158e6:	4822      	ldr	r0, [pc, #136]	; (8015970 <report_build_info+0x2e8>)
 80158e8:	4798      	blx	r3
        hal.stream.write(uitoa(grbl.tool_table.n_tools));
 80158ea:	4b1a      	ldr	r3, [pc, #104]	; (8015954 <report_build_info+0x2cc>)
 80158ec:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80158f0:	4b20      	ldr	r3, [pc, #128]	; (8015974 <report_build_info+0x2ec>)
 80158f2:	699b      	ldr	r3, [r3, #24]
 80158f4:	4618      	mov	r0, r3
 80158f6:	f7fa fcc9 	bl	801028c <uitoa>
 80158fa:	4603      	mov	r3, r0
 80158fc:	4618      	mov	r0, r3
 80158fe:	47a0      	blx	r4
    }
    hal.stream.write("]" ASCII_EOL);
 8015900:	4b14      	ldr	r3, [pc, #80]	; (8015954 <report_build_info+0x2cc>)
 8015902:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015906:	4817      	ldr	r0, [pc, #92]	; (8015964 <report_build_info+0x2dc>)
 8015908:	4798      	blx	r3

    if(extended) {
 801590a:	78fb      	ldrb	r3, [r7, #3]
 801590c:	2b00      	cmp	r3, #0
 801590e:	f000 835f 	beq.w	8015fd0 <report_build_info+0x948>

        uint_fast8_t idx;
        nvs_io_t *nvs = nvs_buffer_get_physical();
 8015912:	f7fb fcb1 	bl	8011278 <nvs_buffer_get_physical>
 8015916:	66f8      	str	r0, [r7, #108]	; 0x6c

        strcat(strcpy(buf, "[AXS:"), uitoa(N_AXIS));
 8015918:	f107 0208 	add.w	r2, r7, #8
 801591c:	4916      	ldr	r1, [pc, #88]	; (8015978 <report_build_info+0x2f0>)
 801591e:	4613      	mov	r3, r2
 8015920:	c903      	ldmia	r1, {r0, r1}
 8015922:	6018      	str	r0, [r3, #0]
 8015924:	3304      	adds	r3, #4
 8015926:	8019      	strh	r1, [r3, #0]
 8015928:	4614      	mov	r4, r2
 801592a:	2003      	movs	r0, #3
 801592c:	f7fa fcae 	bl	801028c <uitoa>
 8015930:	4603      	mov	r3, r0
 8015932:	4619      	mov	r1, r3
 8015934:	4620      	mov	r0, r4
 8015936:	f00e f976 	bl	8023c26 <strcat>

        append = &buf[6];
 801593a:	f107 0308 	add.w	r3, r7, #8
 801593e:	3306      	adds	r3, #6
 8015940:	677b      	str	r3, [r7, #116]	; 0x74
        *append++ = ':';
 8015942:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015944:	1c5a      	adds	r2, r3, #1
 8015946:	677a      	str	r2, [r7, #116]	; 0x74
 8015948:	223a      	movs	r2, #58	; 0x3a
 801594a:	701a      	strb	r2, [r3, #0]

        for(idx = 0; idx < N_AXIS; idx++)
 801594c:	2300      	movs	r3, #0
 801594e:	673b      	str	r3, [r7, #112]	; 0x70
 8015950:	e020      	b.n	8015994 <report_build_info+0x30c>
 8015952:	bf00      	nop
 8015954:	20000ed0 	.word	0x20000ed0
 8015958:	0802b3fc 	.word	0x0802b3fc
 801595c:	0134b436 	.word	0x0134b436
 8015960:	0802b2c4 	.word	0x0802b2c4
 8015964:	0802b1c0 	.word	0x0802b1c0
 8015968:	0802b408 	.word	0x0802b408
 801596c:	2000147c 	.word	0x2000147c
 8015970:	0802b184 	.word	0x0802b184
 8015974:	20000dd4 	.word	0x20000dd4
 8015978:	0802b410 	.word	0x0802b410
            *append++ = *axis_letter[idx];
 801597c:	4a94      	ldr	r2, [pc, #592]	; (8015bd0 <report_build_info+0x548>)
 801597e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015980:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8015984:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015986:	1c59      	adds	r1, r3, #1
 8015988:	6779      	str	r1, [r7, #116]	; 0x74
 801598a:	7812      	ldrb	r2, [r2, #0]
 801598c:	701a      	strb	r2, [r3, #0]
        for(idx = 0; idx < N_AXIS; idx++)
 801598e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015990:	3301      	adds	r3, #1
 8015992:	673b      	str	r3, [r7, #112]	; 0x70
 8015994:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8015996:	2b02      	cmp	r3, #2
 8015998:	d9f0      	bls.n	801597c <report_build_info+0x2f4>

        *append = '\0';
 801599a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801599c:	2200      	movs	r2, #0
 801599e:	701a      	strb	r2, [r3, #0]

        hal.stream.write(strcat(buf, "]" ASCII_EOL));
 80159a0:	4b8c      	ldr	r3, [pc, #560]	; (8015bd4 <report_build_info+0x54c>)
 80159a2:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80159a6:	f107 0308 	add.w	r3, r7, #8
 80159aa:	4618      	mov	r0, r3
 80159ac:	f7ea fc46 	bl	800023c <strlen>
 80159b0:	4603      	mov	r3, r0
 80159b2:	461a      	mov	r2, r3
 80159b4:	f107 0308 	add.w	r3, r7, #8
 80159b8:	4413      	add	r3, r2
 80159ba:	4a87      	ldr	r2, [pc, #540]	; (8015bd8 <report_build_info+0x550>)
 80159bc:	6810      	ldr	r0, [r2, #0]
 80159be:	6018      	str	r0, [r3, #0]
 80159c0:	f107 0308 	add.w	r3, r7, #8
 80159c4:	4618      	mov	r0, r3
 80159c6:	47a0      	blx	r4

        strcpy(buf, "[NEWOPT:ENUMS,RT");
 80159c8:	f107 0308 	add.w	r3, r7, #8
 80159cc:	4a83      	ldr	r2, [pc, #524]	; (8015bdc <report_build_info+0x554>)
 80159ce:	461c      	mov	r4, r3
 80159d0:	4615      	mov	r5, r2
 80159d2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80159d4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80159d6:	682b      	ldr	r3, [r5, #0]
 80159d8:	7023      	strb	r3, [r4, #0]
        strcat(buf, settings.flags.legacy_rt_commands ? "+," : "-,");
 80159da:	4b81      	ldr	r3, [pc, #516]	; (8015be0 <report_build_info+0x558>)
 80159dc:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 80159e0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80159e4:	b2db      	uxtb	r3, r3
 80159e6:	2b00      	cmp	r3, #0
 80159e8:	d001      	beq.n	80159ee <report_build_info+0x366>
 80159ea:	4a7e      	ldr	r2, [pc, #504]	; (8015be4 <report_build_info+0x55c>)
 80159ec:	e000      	b.n	80159f0 <report_build_info+0x368>
 80159ee:	4a7e      	ldr	r2, [pc, #504]	; (8015be8 <report_build_info+0x560>)
 80159f0:	f107 0308 	add.w	r3, r7, #8
 80159f4:	4611      	mov	r1, r2
 80159f6:	4618      	mov	r0, r3
 80159f8:	f00e f915 	bl	8023c26 <strcat>

        if(settings.homing.flags.enabled)
 80159fc:	4b78      	ldr	r3, [pc, #480]	; (8015be0 <report_build_info+0x558>)
 80159fe:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8015a02:	f003 0301 	and.w	r3, r3, #1
 8015a06:	b2db      	uxtb	r3, r3
 8015a08:	2b00      	cmp	r3, #0
 8015a0a:	d00e      	beq.n	8015a2a <report_build_info+0x3a2>
            strcat(buf, "HOME,");
 8015a0c:	f107 0308 	add.w	r3, r7, #8
 8015a10:	4618      	mov	r0, r3
 8015a12:	f7ea fc13 	bl	800023c <strlen>
 8015a16:	4603      	mov	r3, r0
 8015a18:	461a      	mov	r2, r3
 8015a1a:	f107 0308 	add.w	r3, r7, #8
 8015a1e:	4413      	add	r3, r2
 8015a20:	4a72      	ldr	r2, [pc, #456]	; (8015bec <report_build_info+0x564>)
 8015a22:	6810      	ldr	r0, [r2, #0]
 8015a24:	6018      	str	r0, [r3, #0]
 8015a26:	8892      	ldrh	r2, [r2, #4]
 8015a28:	809a      	strh	r2, [r3, #4]

        if(!hal.probe.get_state)
 8015a2a:	4b6a      	ldr	r3, [pc, #424]	; (8015bd4 <report_build_info+0x54c>)
 8015a2c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8015a30:	2b00      	cmp	r3, #0
 8015a32:	d112      	bne.n	8015a5a <report_build_info+0x3d2>
            strcat(buf, "NOPROBE,");
 8015a34:	f107 0308 	add.w	r3, r7, #8
 8015a38:	4618      	mov	r0, r3
 8015a3a:	f7ea fbff 	bl	800023c <strlen>
 8015a3e:	4603      	mov	r3, r0
 8015a40:	461a      	mov	r2, r3
 8015a42:	f107 0308 	add.w	r3, r7, #8
 8015a46:	4413      	add	r3, r2
 8015a48:	4969      	ldr	r1, [pc, #420]	; (8015bf0 <report_build_info+0x568>)
 8015a4a:	461a      	mov	r2, r3
 8015a4c:	460b      	mov	r3, r1
 8015a4e:	cb03      	ldmia	r3!, {r0, r1}
 8015a50:	6010      	str	r0, [r2, #0]
 8015a52:	6051      	str	r1, [r2, #4]
 8015a54:	781b      	ldrb	r3, [r3, #0]
 8015a56:	7213      	strb	r3, [r2, #8]
 8015a58:	e014      	b.n	8015a84 <report_build_info+0x3fc>
        else if(hal.signals_cap.probe_disconnected)
 8015a5a:	4b5e      	ldr	r3, [pc, #376]	; (8015bd4 <report_build_info+0x54c>)
 8015a5c:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8015a60:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015a64:	b2db      	uxtb	r3, r3
 8015a66:	2b00      	cmp	r3, #0
 8015a68:	d00c      	beq.n	8015a84 <report_build_info+0x3fc>
            strcat(buf, "PC,");
 8015a6a:	f107 0308 	add.w	r3, r7, #8
 8015a6e:	4618      	mov	r0, r3
 8015a70:	f7ea fbe4 	bl	800023c <strlen>
 8015a74:	4603      	mov	r3, r0
 8015a76:	461a      	mov	r2, r3
 8015a78:	f107 0308 	add.w	r3, r7, #8
 8015a7c:	4413      	add	r3, r2
 8015a7e:	4a5d      	ldr	r2, [pc, #372]	; (8015bf4 <report_build_info+0x56c>)
 8015a80:	6810      	ldr	r0, [r2, #0]
 8015a82:	6018      	str	r0, [r3, #0]

        if(hal.signals_cap.stop_disable)
 8015a84:	4b53      	ldr	r3, [pc, #332]	; (8015bd4 <report_build_info+0x54c>)
 8015a86:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8015a8a:	f003 0320 	and.w	r3, r3, #32
 8015a8e:	b2db      	uxtb	r3, r3
 8015a90:	2b00      	cmp	r3, #0
 8015a92:	d00c      	beq.n	8015aae <report_build_info+0x426>
            strcat(buf, "OS,");
 8015a94:	f107 0308 	add.w	r3, r7, #8
 8015a98:	4618      	mov	r0, r3
 8015a9a:	f7ea fbcf 	bl	800023c <strlen>
 8015a9e:	4603      	mov	r3, r0
 8015aa0:	461a      	mov	r2, r3
 8015aa2:	f107 0308 	add.w	r3, r7, #8
 8015aa6:	4413      	add	r3, r2
 8015aa8:	4a53      	ldr	r2, [pc, #332]	; (8015bf8 <report_build_info+0x570>)
 8015aaa:	6810      	ldr	r0, [r2, #0]
 8015aac:	6018      	str	r0, [r3, #0]

        if(hal.signals_cap.block_delete)
 8015aae:	4b49      	ldr	r3, [pc, #292]	; (8015bd4 <report_build_info+0x54c>)
 8015ab0:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8015ab4:	f003 0310 	and.w	r3, r3, #16
 8015ab8:	b2db      	uxtb	r3, r3
 8015aba:	2b00      	cmp	r3, #0
 8015abc:	d00c      	beq.n	8015ad8 <report_build_info+0x450>
            strcat(buf, "BD,");
 8015abe:	f107 0308 	add.w	r3, r7, #8
 8015ac2:	4618      	mov	r0, r3
 8015ac4:	f7ea fbba 	bl	800023c <strlen>
 8015ac8:	4603      	mov	r3, r0
 8015aca:	461a      	mov	r2, r3
 8015acc:	f107 0308 	add.w	r3, r7, #8
 8015ad0:	4413      	add	r3, r2
 8015ad2:	4a4a      	ldr	r2, [pc, #296]	; (8015bfc <report_build_info+0x574>)
 8015ad4:	6810      	ldr	r0, [r2, #0]
 8015ad6:	6018      	str	r0, [r3, #0]

        if(hal.signals_cap.e_stop)
 8015ad8:	4b3e      	ldr	r3, [pc, #248]	; (8015bd4 <report_build_info+0x54c>)
 8015ada:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8015ade:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015ae2:	b2db      	uxtb	r3, r3
 8015ae4:	2b00      	cmp	r3, #0
 8015ae6:	d00c      	beq.n	8015b02 <report_build_info+0x47a>
            strcat(buf, "ES,");
 8015ae8:	f107 0308 	add.w	r3, r7, #8
 8015aec:	4618      	mov	r0, r3
 8015aee:	f7ea fba5 	bl	800023c <strlen>
 8015af2:	4603      	mov	r3, r0
 8015af4:	461a      	mov	r2, r3
 8015af6:	f107 0308 	add.w	r3, r7, #8
 8015afa:	4413      	add	r3, r2
 8015afc:	4a40      	ldr	r2, [pc, #256]	; (8015c00 <report_build_info+0x578>)
 8015afe:	6810      	ldr	r0, [r2, #0]
 8015b00:	6018      	str	r0, [r3, #0]

        if(hal.driver_cap.mpg_mode)
 8015b02:	4b34      	ldr	r3, [pc, #208]	; (8015bd4 <report_build_info+0x54c>)
 8015b04:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8015b08:	f003 0301 	and.w	r3, r3, #1
 8015b0c:	b2db      	uxtb	r3, r3
 8015b0e:	2b00      	cmp	r3, #0
 8015b10:	d00e      	beq.n	8015b30 <report_build_info+0x4a8>
            strcat(buf, "MPG,");
 8015b12:	f107 0308 	add.w	r3, r7, #8
 8015b16:	4618      	mov	r0, r3
 8015b18:	f7ea fb90 	bl	800023c <strlen>
 8015b1c:	4603      	mov	r3, r0
 8015b1e:	461a      	mov	r2, r3
 8015b20:	f107 0308 	add.w	r3, r7, #8
 8015b24:	4413      	add	r3, r2
 8015b26:	4a37      	ldr	r2, [pc, #220]	; (8015c04 <report_build_info+0x57c>)
 8015b28:	6810      	ldr	r0, [r2, #0]
 8015b2a:	6018      	str	r0, [r3, #0]
 8015b2c:	7912      	ldrb	r2, [r2, #4]
 8015b2e:	711a      	strb	r2, [r3, #4]

#if LATHE_UVW_OPTION
        strcat(buf, "LATHE,LATHEUVW,");
#else
        if(settings.mode == Mode_Lathe)
 8015b30:	4b2b      	ldr	r3, [pc, #172]	; (8015be0 <report_build_info+0x558>)
 8015b32:	7e1b      	ldrb	r3, [r3, #24]
 8015b34:	2b02      	cmp	r3, #2
 8015b36:	d110      	bne.n	8015b5a <report_build_info+0x4d2>
            strcat(buf, "LATHE,");
 8015b38:	f107 0308 	add.w	r3, r7, #8
 8015b3c:	4618      	mov	r0, r3
 8015b3e:	f7ea fb7d 	bl	800023c <strlen>
 8015b42:	4603      	mov	r3, r0
 8015b44:	461a      	mov	r2, r3
 8015b46:	f107 0308 	add.w	r3, r7, #8
 8015b4a:	4413      	add	r3, r2
 8015b4c:	4a2e      	ldr	r2, [pc, #184]	; (8015c08 <report_build_info+0x580>)
 8015b4e:	6810      	ldr	r0, [r2, #0]
 8015b50:	6018      	str	r0, [r3, #0]
 8015b52:	8891      	ldrh	r1, [r2, #4]
 8015b54:	7992      	ldrb	r2, [r2, #6]
 8015b56:	8099      	strh	r1, [r3, #4]
 8015b58:	719a      	strb	r2, [r3, #6]
#endif

        if(hal.driver_cap.laser_ppi_mode)
 8015b5a:	4b1e      	ldr	r3, [pc, #120]	; (8015bd4 <report_build_info+0x54c>)
 8015b5c:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8015b60:	f003 0302 	and.w	r3, r3, #2
 8015b64:	b2db      	uxtb	r3, r3
 8015b66:	2b00      	cmp	r3, #0
 8015b68:	d00e      	beq.n	8015b88 <report_build_info+0x500>
            strcat(buf, "PPI,");
 8015b6a:	f107 0308 	add.w	r3, r7, #8
 8015b6e:	4618      	mov	r0, r3
 8015b70:	f7ea fb64 	bl	800023c <strlen>
 8015b74:	4603      	mov	r3, r0
 8015b76:	461a      	mov	r2, r3
 8015b78:	f107 0308 	add.w	r3, r7, #8
 8015b7c:	4413      	add	r3, r2
 8015b7e:	4a23      	ldr	r2, [pc, #140]	; (8015c0c <report_build_info+0x584>)
 8015b80:	6810      	ldr	r0, [r2, #0]
 8015b82:	6018      	str	r0, [r3, #0]
 8015b84:	7912      	ldrb	r2, [r2, #4]
 8015b86:	711a      	strb	r2, [r3, #4]

        if(hal.reboot)
 8015b88:	4b12      	ldr	r3, [pc, #72]	; (8015bd4 <report_build_info+0x54c>)
 8015b8a:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 8015b8e:	2b00      	cmp	r3, #0
 8015b90:	d00f      	beq.n	8015bb2 <report_build_info+0x52a>
            strcat(buf, "REBOOT,");
 8015b92:	f107 0308 	add.w	r3, r7, #8
 8015b96:	4618      	mov	r0, r3
 8015b98:	f7ea fb50 	bl	800023c <strlen>
 8015b9c:	4603      	mov	r3, r0
 8015b9e:	461a      	mov	r2, r3
 8015ba0:	f107 0308 	add.w	r3, r7, #8
 8015ba4:	4413      	add	r3, r2
 8015ba6:	491a      	ldr	r1, [pc, #104]	; (8015c10 <report_build_info+0x588>)
 8015ba8:	461a      	mov	r2, r3
 8015baa:	460b      	mov	r3, r1
 8015bac:	cb03      	ldmia	r3!, {r0, r1}
 8015bae:	6010      	str	r0, [r2, #0]
 8015bb0:	6051      	str	r1, [r2, #4]

    #if NGC_EXPRESSIONS_ENABLE
        strcat(buf, "EXPR,");
    #endif

        if(hal.tool.change)
 8015bb2:	4b08      	ldr	r3, [pc, #32]	; (8015bd4 <report_build_info+0x54c>)
 8015bb4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8015bb8:	2b00      	cmp	r3, #0
 8015bba:	d034      	beq.n	8015c26 <report_build_info+0x59e>
            strcat(buf, hal.driver_cap.atc ? "ATC," : "TC,"); // Tool change supported (M6)
 8015bbc:	4b05      	ldr	r3, [pc, #20]	; (8015bd4 <report_build_info+0x54c>)
 8015bbe:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8015bc2:	f003 0304 	and.w	r3, r3, #4
 8015bc6:	b2db      	uxtb	r3, r3
 8015bc8:	2b00      	cmp	r3, #0
 8015bca:	d025      	beq.n	8015c18 <report_build_info+0x590>
 8015bcc:	4a11      	ldr	r2, [pc, #68]	; (8015c14 <report_build_info+0x58c>)
 8015bce:	e024      	b.n	8015c1a <report_build_info+0x592>
 8015bd0:	0803102c 	.word	0x0803102c
 8015bd4:	20000ed0 	.word	0x20000ed0
 8015bd8:	0802b1c0 	.word	0x0802b1c0
 8015bdc:	0802b418 	.word	0x0802b418
 8015be0:	2000147c 	.word	0x2000147c
 8015be4:	0802b42c 	.word	0x0802b42c
 8015be8:	0802b430 	.word	0x0802b430
 8015bec:	0802b434 	.word	0x0802b434
 8015bf0:	0802b43c 	.word	0x0802b43c
 8015bf4:	0802b448 	.word	0x0802b448
 8015bf8:	0802b44c 	.word	0x0802b44c
 8015bfc:	0802b450 	.word	0x0802b450
 8015c00:	0802b454 	.word	0x0802b454
 8015c04:	0802b458 	.word	0x0802b458
 8015c08:	0802b460 	.word	0x0802b460
 8015c0c:	0802b468 	.word	0x0802b468
 8015c10:	0802b470 	.word	0x0802b470
 8015c14:	0802b478 	.word	0x0802b478
 8015c18:	4a4b      	ldr	r2, [pc, #300]	; (8015d48 <report_build_info+0x6c0>)
 8015c1a:	f107 0308 	add.w	r3, r7, #8
 8015c1e:	4611      	mov	r1, r2
 8015c20:	4618      	mov	r0, r3
 8015c22:	f00e f800 	bl	8023c26 <strcat>

        if(hal.driver_cap.spindle_sync)
 8015c26:	4b49      	ldr	r3, [pc, #292]	; (8015d4c <report_build_info+0x6c4>)
 8015c28:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 8015c2c:	f003 0302 	and.w	r3, r3, #2
 8015c30:	b2db      	uxtb	r3, r3
 8015c32:	2b00      	cmp	r3, #0
 8015c34:	d00c      	beq.n	8015c50 <report_build_info+0x5c8>
            strcat(buf, "SS,");
 8015c36:	f107 0308 	add.w	r3, r7, #8
 8015c3a:	4618      	mov	r0, r3
 8015c3c:	f7ea fafe 	bl	800023c <strlen>
 8015c40:	4603      	mov	r3, r0
 8015c42:	461a      	mov	r2, r3
 8015c44:	f107 0308 	add.w	r3, r7, #8
 8015c48:	4413      	add	r3, r2
 8015c4a:	4a41      	ldr	r2, [pc, #260]	; (8015d50 <report_build_info+0x6c8>)
 8015c4c:	6810      	ldr	r0, [r2, #0]
 8015c4e:	6018      	str	r0, [r3, #0]

    #ifndef NO_SETTINGS_DESCRIPTIONS
        strcat(buf, "SED,");
 8015c50:	f107 0308 	add.w	r3, r7, #8
 8015c54:	4618      	mov	r0, r3
 8015c56:	f7ea faf1 	bl	800023c <strlen>
 8015c5a:	4603      	mov	r3, r0
 8015c5c:	461a      	mov	r2, r3
 8015c5e:	f107 0308 	add.w	r3, r7, #8
 8015c62:	4413      	add	r3, r2
 8015c64:	4a3b      	ldr	r2, [pc, #236]	; (8015d54 <report_build_info+0x6cc>)
 8015c66:	6810      	ldr	r0, [r2, #0]
 8015c68:	6018      	str	r0, [r3, #0]
 8015c6a:	7912      	ldrb	r2, [r2, #4]
 8015c6c:	711a      	strb	r2, [r3, #4]
    #endif

        if(hal.rtc.get_datetime)
 8015c6e:	4b37      	ldr	r3, [pc, #220]	; (8015d4c <report_build_info+0x6c4>)
 8015c70:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8015c74:	2b00      	cmp	r3, #0
 8015c76:	d00e      	beq.n	8015c96 <report_build_info+0x60e>
            strcat(buf, "RTC,");
 8015c78:	f107 0308 	add.w	r3, r7, #8
 8015c7c:	4618      	mov	r0, r3
 8015c7e:	f7ea fadd 	bl	800023c <strlen>
 8015c82:	4603      	mov	r3, r0
 8015c84:	461a      	mov	r2, r3
 8015c86:	f107 0308 	add.w	r3, r7, #8
 8015c8a:	4413      	add	r3, r2
 8015c8c:	4a32      	ldr	r2, [pc, #200]	; (8015d58 <report_build_info+0x6d0>)
 8015c8e:	6810      	ldr	r0, [r2, #0]
 8015c90:	6018      	str	r0, [r3, #0]
 8015c92:	7912      	ldrb	r2, [r2, #4]
 8015c94:	711a      	strb	r2, [r3, #4]

    #ifdef PID_LOG
        strcat(buf, "PID,");
    #endif

        append = &buf[strlen(buf) - 1];
 8015c96:	f107 0308 	add.w	r3, r7, #8
 8015c9a:	4618      	mov	r0, r3
 8015c9c:	f7ea face 	bl	800023c <strlen>
 8015ca0:	4603      	mov	r3, r0
 8015ca2:	3b01      	subs	r3, #1
 8015ca4:	f107 0208 	add.w	r2, r7, #8
 8015ca8:	4413      	add	r3, r2
 8015caa:	677b      	str	r3, [r7, #116]	; 0x74
        if(*append == ',')
 8015cac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015cae:	781b      	ldrb	r3, [r3, #0]
 8015cb0:	2b2c      	cmp	r3, #44	; 0x2c
 8015cb2:	d102      	bne.n	8015cba <report_build_info+0x632>
            *append = '\0';
 8015cb4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8015cb6:	2200      	movs	r2, #0
 8015cb8:	701a      	strb	r2, [r3, #0]

        hal.stream.write(buf);
 8015cba:	4b24      	ldr	r3, [pc, #144]	; (8015d4c <report_build_info+0x6c4>)
 8015cbc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015cc0:	f107 0208 	add.w	r2, r7, #8
 8015cc4:	4610      	mov	r0, r2
 8015cc6:	4798      	blx	r3
        grbl.on_report_options(true);
 8015cc8:	4b24      	ldr	r3, [pc, #144]	; (8015d5c <report_build_info+0x6d4>)
 8015cca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015ccc:	2001      	movs	r0, #1
 8015cce:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 8015cd0:	4b1e      	ldr	r3, [pc, #120]	; (8015d4c <report_build_info+0x6c4>)
 8015cd2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015cd6:	4822      	ldr	r0, [pc, #136]	; (8015d60 <report_build_info+0x6d8>)
 8015cd8:	4798      	blx	r3

        hal.stream.write("[FIRMWARE:grblHAL]" ASCII_EOL);
 8015cda:	4b1c      	ldr	r3, [pc, #112]	; (8015d4c <report_build_info+0x6c4>)
 8015cdc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015ce0:	4820      	ldr	r0, [pc, #128]	; (8015d64 <report_build_info+0x6dc>)
 8015ce2:	4798      	blx	r3

        if(!(nvs->type == NVS_None || nvs->type == NVS_Emulated)) {
 8015ce4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015ce6:	781b      	ldrb	r3, [r3, #0]
 8015ce8:	2b00      	cmp	r3, #0
 8015cea:	f000 8089 	beq.w	8015e00 <report_build_info+0x778>
 8015cee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015cf0:	781b      	ldrb	r3, [r3, #0]
 8015cf2:	2b04      	cmp	r3, #4
 8015cf4:	f000 8084 	beq.w	8015e00 <report_build_info+0x778>
            hal.stream.write("[NVS STORAGE:");
 8015cf8:	4b14      	ldr	r3, [pc, #80]	; (8015d4c <report_build_info+0x6c4>)
 8015cfa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015cfe:	481a      	ldr	r0, [pc, #104]	; (8015d68 <report_build_info+0x6e0>)
 8015d00:	4798      	blx	r3
            *buf = '\0';
 8015d02:	2300      	movs	r3, #0
 8015d04:	723b      	strb	r3, [r7, #8]
            if(hal.nvs.type == NVS_Emulated)
 8015d06:	4b11      	ldr	r3, [pc, #68]	; (8015d4c <report_build_info+0x6c4>)
 8015d08:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 8015d0c:	2b04      	cmp	r3, #4
 8015d0e:	d10e      	bne.n	8015d2e <report_build_info+0x6a6>
                strcat(buf, "*");
 8015d10:	f107 0308 	add.w	r3, r7, #8
 8015d14:	4618      	mov	r0, r3
 8015d16:	f7ea fa91 	bl	800023c <strlen>
 8015d1a:	4603      	mov	r3, r0
 8015d1c:	461a      	mov	r2, r3
 8015d1e:	f107 0308 	add.w	r3, r7, #8
 8015d22:	4413      	add	r3, r2
 8015d24:	4911      	ldr	r1, [pc, #68]	; (8015d6c <report_build_info+0x6e4>)
 8015d26:	461a      	mov	r2, r3
 8015d28:	460b      	mov	r3, r1
 8015d2a:	881b      	ldrh	r3, [r3, #0]
 8015d2c:	8013      	strh	r3, [r2, #0]
            strcat(buf, nvs->type == NVS_Flash ? "FLASH" : (nvs->type == NVS_FRAM ? "FRAM" : "EEPROM"));
 8015d2e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015d30:	781b      	ldrb	r3, [r3, #0]
 8015d32:	2b03      	cmp	r3, #3
 8015d34:	d020      	beq.n	8015d78 <report_build_info+0x6f0>
 8015d36:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8015d38:	781b      	ldrb	r3, [r3, #0]
 8015d3a:	2b02      	cmp	r3, #2
 8015d3c:	d101      	bne.n	8015d42 <report_build_info+0x6ba>
 8015d3e:	4b0c      	ldr	r3, [pc, #48]	; (8015d70 <report_build_info+0x6e8>)
 8015d40:	e01b      	b.n	8015d7a <report_build_info+0x6f2>
 8015d42:	4b0c      	ldr	r3, [pc, #48]	; (8015d74 <report_build_info+0x6ec>)
 8015d44:	e019      	b.n	8015d7a <report_build_info+0x6f2>
 8015d46:	bf00      	nop
 8015d48:	0802b480 	.word	0x0802b480
 8015d4c:	20000ed0 	.word	0x20000ed0
 8015d50:	0802b484 	.word	0x0802b484
 8015d54:	0802b488 	.word	0x0802b488
 8015d58:	0802b490 	.word	0x0802b490
 8015d5c:	20000dd4 	.word	0x20000dd4
 8015d60:	0802b1c0 	.word	0x0802b1c0
 8015d64:	0802b498 	.word	0x0802b498
 8015d68:	0802b4b0 	.word	0x0802b4b0
 8015d6c:	0802b4c0 	.word	0x0802b4c0
 8015d70:	0802b4c4 	.word	0x0802b4c4
 8015d74:	0802b4cc 	.word	0x0802b4cc
 8015d78:	4b97      	ldr	r3, [pc, #604]	; (8015fd8 <report_build_info+0x950>)
 8015d7a:	f107 0208 	add.w	r2, r7, #8
 8015d7e:	4619      	mov	r1, r3
 8015d80:	4610      	mov	r0, r2
 8015d82:	f00d ff50 	bl	8023c26 <strcat>
            if(hal.nvs.size_max) {
 8015d86:	4b95      	ldr	r3, [pc, #596]	; (8015fdc <report_build_info+0x954>)
 8015d88:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8015d8c:	2b00      	cmp	r3, #0
 8015d8e:	d02b      	beq.n	8015de8 <report_build_info+0x760>
                strcat(buf, " ");
 8015d90:	f107 0308 	add.w	r3, r7, #8
 8015d94:	4618      	mov	r0, r3
 8015d96:	f7ea fa51 	bl	800023c <strlen>
 8015d9a:	4603      	mov	r3, r0
 8015d9c:	461a      	mov	r2, r3
 8015d9e:	f107 0308 	add.w	r3, r7, #8
 8015da2:	4413      	add	r3, r2
 8015da4:	498e      	ldr	r1, [pc, #568]	; (8015fe0 <report_build_info+0x958>)
 8015da6:	461a      	mov	r2, r3
 8015da8:	460b      	mov	r3, r1
 8015daa:	881b      	ldrh	r3, [r3, #0]
 8015dac:	8013      	strh	r3, [r2, #0]
                strcat(buf, uitoa(hal.nvs.size_max / 1024));
 8015dae:	4b8b      	ldr	r3, [pc, #556]	; (8015fdc <report_build_info+0x954>)
 8015db0:	f8d3 314c 	ldr.w	r3, [r3, #332]	; 0x14c
 8015db4:	0a9b      	lsrs	r3, r3, #10
 8015db6:	4618      	mov	r0, r3
 8015db8:	f7fa fa68 	bl	801028c <uitoa>
 8015dbc:	4602      	mov	r2, r0
 8015dbe:	f107 0308 	add.w	r3, r7, #8
 8015dc2:	4611      	mov	r1, r2
 8015dc4:	4618      	mov	r0, r3
 8015dc6:	f00d ff2e 	bl	8023c26 <strcat>
                strcat(buf, "K");
 8015dca:	f107 0308 	add.w	r3, r7, #8
 8015dce:	4618      	mov	r0, r3
 8015dd0:	f7ea fa34 	bl	800023c <strlen>
 8015dd4:	4603      	mov	r3, r0
 8015dd6:	461a      	mov	r2, r3
 8015dd8:	f107 0308 	add.w	r3, r7, #8
 8015ddc:	4413      	add	r3, r2
 8015dde:	4981      	ldr	r1, [pc, #516]	; (8015fe4 <report_build_info+0x95c>)
 8015de0:	461a      	mov	r2, r3
 8015de2:	460b      	mov	r3, r1
 8015de4:	881b      	ldrh	r3, [r3, #0]
 8015de6:	8013      	strh	r3, [r2, #0]
            }
            hal.stream.write(buf);
 8015de8:	4b7c      	ldr	r3, [pc, #496]	; (8015fdc <report_build_info+0x954>)
 8015dea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015dee:	f107 0208 	add.w	r2, r7, #8
 8015df2:	4610      	mov	r0, r2
 8015df4:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8015df6:	4b79      	ldr	r3, [pc, #484]	; (8015fdc <report_build_info+0x954>)
 8015df8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015dfc:	487a      	ldr	r0, [pc, #488]	; (8015fe8 <report_build_info+0x960>)
 8015dfe:	4798      	blx	r3
        }

        if(hal.get_free_mem) {
 8015e00:	4b76      	ldr	r3, [pc, #472]	; (8015fdc <report_build_info+0x954>)
 8015e02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e04:	2b00      	cmp	r3, #0
 8015e06:	d017      	beq.n	8015e38 <report_build_info+0x7b0>
            hal.stream.write("[FREE MEMORY:");
 8015e08:	4b74      	ldr	r3, [pc, #464]	; (8015fdc <report_build_info+0x954>)
 8015e0a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e0e:	4877      	ldr	r0, [pc, #476]	; (8015fec <report_build_info+0x964>)
 8015e10:	4798      	blx	r3
            hal.stream.write(uitoa(hal.get_free_mem() / 1024));
 8015e12:	4b72      	ldr	r3, [pc, #456]	; (8015fdc <report_build_info+0x954>)
 8015e14:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015e18:	4b70      	ldr	r3, [pc, #448]	; (8015fdc <report_build_info+0x954>)
 8015e1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015e1c:	4798      	blx	r3
 8015e1e:	4603      	mov	r3, r0
 8015e20:	0a9b      	lsrs	r3, r3, #10
 8015e22:	4618      	mov	r0, r3
 8015e24:	f7fa fa32 	bl	801028c <uitoa>
 8015e28:	4603      	mov	r3, r0
 8015e2a:	4618      	mov	r0, r3
 8015e2c:	47a0      	blx	r4
            hal.stream.write("K]" ASCII_EOL);
 8015e2e:	4b6b      	ldr	r3, [pc, #428]	; (8015fdc <report_build_info+0x954>)
 8015e30:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e34:	486e      	ldr	r0, [pc, #440]	; (8015ff0 <report_build_info+0x968>)
 8015e36:	4798      	blx	r3
        }

        if(hal.info) {
 8015e38:	4b68      	ldr	r3, [pc, #416]	; (8015fdc <report_build_info+0x954>)
 8015e3a:	685b      	ldr	r3, [r3, #4]
 8015e3c:	2b00      	cmp	r3, #0
 8015e3e:	d010      	beq.n	8015e62 <report_build_info+0x7da>
            hal.stream.write("[DRIVER:");
 8015e40:	4b66      	ldr	r3, [pc, #408]	; (8015fdc <report_build_info+0x954>)
 8015e42:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e46:	486b      	ldr	r0, [pc, #428]	; (8015ff4 <report_build_info+0x96c>)
 8015e48:	4798      	blx	r3
            hal.stream.write(hal.info);
 8015e4a:	4b64      	ldr	r3, [pc, #400]	; (8015fdc <report_build_info+0x954>)
 8015e4c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e50:	4a62      	ldr	r2, [pc, #392]	; (8015fdc <report_build_info+0x954>)
 8015e52:	6852      	ldr	r2, [r2, #4]
 8015e54:	4610      	mov	r0, r2
 8015e56:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8015e58:	4b60      	ldr	r3, [pc, #384]	; (8015fdc <report_build_info+0x954>)
 8015e5a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e5e:	4862      	ldr	r0, [pc, #392]	; (8015fe8 <report_build_info+0x960>)
 8015e60:	4798      	blx	r3
        }

        if(hal.driver_version) {
 8015e62:	4b5e      	ldr	r3, [pc, #376]	; (8015fdc <report_build_info+0x954>)
 8015e64:	689b      	ldr	r3, [r3, #8]
 8015e66:	2b00      	cmp	r3, #0
 8015e68:	d010      	beq.n	8015e8c <report_build_info+0x804>
            hal.stream.write("[DRIVER VERSION:");
 8015e6a:	4b5c      	ldr	r3, [pc, #368]	; (8015fdc <report_build_info+0x954>)
 8015e6c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e70:	4861      	ldr	r0, [pc, #388]	; (8015ff8 <report_build_info+0x970>)
 8015e72:	4798      	blx	r3
            hal.stream.write(hal.driver_version);
 8015e74:	4b59      	ldr	r3, [pc, #356]	; (8015fdc <report_build_info+0x954>)
 8015e76:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e7a:	4a58      	ldr	r2, [pc, #352]	; (8015fdc <report_build_info+0x954>)
 8015e7c:	6892      	ldr	r2, [r2, #8]
 8015e7e:	4610      	mov	r0, r2
 8015e80:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8015e82:	4b56      	ldr	r3, [pc, #344]	; (8015fdc <report_build_info+0x954>)
 8015e84:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e88:	4857      	ldr	r0, [pc, #348]	; (8015fe8 <report_build_info+0x960>)
 8015e8a:	4798      	blx	r3
        }

        if(hal.driver_options) {
 8015e8c:	4b53      	ldr	r3, [pc, #332]	; (8015fdc <report_build_info+0x954>)
 8015e8e:	68db      	ldr	r3, [r3, #12]
 8015e90:	2b00      	cmp	r3, #0
 8015e92:	d010      	beq.n	8015eb6 <report_build_info+0x82e>
            hal.stream.write("[DRIVER OPTIONS:");
 8015e94:	4b51      	ldr	r3, [pc, #324]	; (8015fdc <report_build_info+0x954>)
 8015e96:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015e9a:	4858      	ldr	r0, [pc, #352]	; (8015ffc <report_build_info+0x974>)
 8015e9c:	4798      	blx	r3
            hal.stream.write(hal.driver_options);
 8015e9e:	4b4f      	ldr	r3, [pc, #316]	; (8015fdc <report_build_info+0x954>)
 8015ea0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015ea4:	4a4d      	ldr	r2, [pc, #308]	; (8015fdc <report_build_info+0x954>)
 8015ea6:	68d2      	ldr	r2, [r2, #12]
 8015ea8:	4610      	mov	r0, r2
 8015eaa:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8015eac:	4b4b      	ldr	r3, [pc, #300]	; (8015fdc <report_build_info+0x954>)
 8015eae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015eb2:	484d      	ldr	r0, [pc, #308]	; (8015fe8 <report_build_info+0x960>)
 8015eb4:	4798      	blx	r3
        }

        if(hal.board) {
 8015eb6:	4b49      	ldr	r3, [pc, #292]	; (8015fdc <report_build_info+0x954>)
 8015eb8:	695b      	ldr	r3, [r3, #20]
 8015eba:	2b00      	cmp	r3, #0
 8015ebc:	d010      	beq.n	8015ee0 <report_build_info+0x858>
            hal.stream.write("[BOARD:");
 8015ebe:	4b47      	ldr	r3, [pc, #284]	; (8015fdc <report_build_info+0x954>)
 8015ec0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015ec4:	484e      	ldr	r0, [pc, #312]	; (8016000 <report_build_info+0x978>)
 8015ec6:	4798      	blx	r3
            hal.stream.write(hal.board);
 8015ec8:	4b44      	ldr	r3, [pc, #272]	; (8015fdc <report_build_info+0x954>)
 8015eca:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015ece:	4a43      	ldr	r2, [pc, #268]	; (8015fdc <report_build_info+0x954>)
 8015ed0:	6952      	ldr	r2, [r2, #20]
 8015ed2:	4610      	mov	r0, r2
 8015ed4:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 8015ed6:	4b41      	ldr	r3, [pc, #260]	; (8015fdc <report_build_info+0x954>)
 8015ed8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015edc:	4842      	ldr	r0, [pc, #264]	; (8015fe8 <report_build_info+0x960>)
 8015ede:	4798      	blx	r3
        }

        if(hal.max_step_rate) {
 8015ee0:	4b3e      	ldr	r3, [pc, #248]	; (8015fdc <report_build_info+0x954>)
 8015ee2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015ee4:	2b00      	cmp	r3, #0
 8015ee6:	d014      	beq.n	8015f12 <report_build_info+0x88a>
            hal.stream.write("[MAX STEP RATE:");
 8015ee8:	4b3c      	ldr	r3, [pc, #240]	; (8015fdc <report_build_info+0x954>)
 8015eea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015eee:	4845      	ldr	r0, [pc, #276]	; (8016004 <report_build_info+0x97c>)
 8015ef0:	4798      	blx	r3
            hal.stream.write(uitoa(hal.max_step_rate));
 8015ef2:	4b3a      	ldr	r3, [pc, #232]	; (8015fdc <report_build_info+0x954>)
 8015ef4:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015ef8:	4b38      	ldr	r3, [pc, #224]	; (8015fdc <report_build_info+0x954>)
 8015efa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8015efc:	4618      	mov	r0, r3
 8015efe:	f7fa f9c5 	bl	801028c <uitoa>
 8015f02:	4603      	mov	r3, r0
 8015f04:	4618      	mov	r0, r3
 8015f06:	47a0      	blx	r4
            hal.stream.write(" Hz]" ASCII_EOL);
 8015f08:	4b34      	ldr	r3, [pc, #208]	; (8015fdc <report_build_info+0x954>)
 8015f0a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015f0e:	483e      	ldr	r0, [pc, #248]	; (8016008 <report_build_info+0x980>)
 8015f10:	4798      	blx	r3
        hal.stream.write("[COMPATIBILITY LEVEL:");
        hal.stream.write(uitoa(COMPATIBILITY_LEVEL));
        hal.stream.write("]" ASCII_EOL);
#endif

        if(hal.port.num_digital_in + hal.port.num_digital_out + hal.port.num_analog_in + hal.port.num_analog_out > 0) {
 8015f12:	4b32      	ldr	r3, [pc, #200]	; (8015fdc <report_build_info+0x954>)
 8015f14:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8015f18:	461a      	mov	r2, r3
 8015f1a:	4b30      	ldr	r3, [pc, #192]	; (8015fdc <report_build_info+0x954>)
 8015f1c:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8015f20:	4413      	add	r3, r2
 8015f22:	4a2e      	ldr	r2, [pc, #184]	; (8015fdc <report_build_info+0x954>)
 8015f24:	f892 2116 	ldrb.w	r2, [r2, #278]	; 0x116
 8015f28:	4413      	add	r3, r2
 8015f2a:	4a2c      	ldr	r2, [pc, #176]	; (8015fdc <report_build_info+0x954>)
 8015f2c:	f892 2117 	ldrb.w	r2, [r2, #279]	; 0x117
 8015f30:	4413      	add	r3, r2
 8015f32:	2b00      	cmp	r3, #0
 8015f34:	dd48      	ble.n	8015fc8 <report_build_info+0x940>
            hal.stream.write("[AUX IO:");
 8015f36:	4b29      	ldr	r3, [pc, #164]	; (8015fdc <report_build_info+0x954>)
 8015f38:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015f3c:	4833      	ldr	r0, [pc, #204]	; (801600c <report_build_info+0x984>)
 8015f3e:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_digital_in));
 8015f40:	4b26      	ldr	r3, [pc, #152]	; (8015fdc <report_build_info+0x954>)
 8015f42:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015f46:	4b25      	ldr	r3, [pc, #148]	; (8015fdc <report_build_info+0x954>)
 8015f48:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8015f4c:	4618      	mov	r0, r3
 8015f4e:	f7fa f99d 	bl	801028c <uitoa>
 8015f52:	4603      	mov	r3, r0
 8015f54:	4618      	mov	r0, r3
 8015f56:	47a0      	blx	r4
            hal.stream.write(",");
 8015f58:	4b20      	ldr	r3, [pc, #128]	; (8015fdc <report_build_info+0x954>)
 8015f5a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015f5e:	482c      	ldr	r0, [pc, #176]	; (8016010 <report_build_info+0x988>)
 8015f60:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_digital_out));
 8015f62:	4b1e      	ldr	r3, [pc, #120]	; (8015fdc <report_build_info+0x954>)
 8015f64:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015f68:	4b1c      	ldr	r3, [pc, #112]	; (8015fdc <report_build_info+0x954>)
 8015f6a:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8015f6e:	4618      	mov	r0, r3
 8015f70:	f7fa f98c 	bl	801028c <uitoa>
 8015f74:	4603      	mov	r3, r0
 8015f76:	4618      	mov	r0, r3
 8015f78:	47a0      	blx	r4
            hal.stream.write(",");
 8015f7a:	4b18      	ldr	r3, [pc, #96]	; (8015fdc <report_build_info+0x954>)
 8015f7c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015f80:	4823      	ldr	r0, [pc, #140]	; (8016010 <report_build_info+0x988>)
 8015f82:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_analog_in));
 8015f84:	4b15      	ldr	r3, [pc, #84]	; (8015fdc <report_build_info+0x954>)
 8015f86:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015f8a:	4b14      	ldr	r3, [pc, #80]	; (8015fdc <report_build_info+0x954>)
 8015f8c:	f893 3116 	ldrb.w	r3, [r3, #278]	; 0x116
 8015f90:	4618      	mov	r0, r3
 8015f92:	f7fa f97b 	bl	801028c <uitoa>
 8015f96:	4603      	mov	r3, r0
 8015f98:	4618      	mov	r0, r3
 8015f9a:	47a0      	blx	r4
            hal.stream.write(",");
 8015f9c:	4b0f      	ldr	r3, [pc, #60]	; (8015fdc <report_build_info+0x954>)
 8015f9e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015fa2:	481b      	ldr	r0, [pc, #108]	; (8016010 <report_build_info+0x988>)
 8015fa4:	4798      	blx	r3
            hal.stream.write(uitoa(hal.port.num_analog_out));
 8015fa6:	4b0d      	ldr	r3, [pc, #52]	; (8015fdc <report_build_info+0x954>)
 8015fa8:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8015fac:	4b0b      	ldr	r3, [pc, #44]	; (8015fdc <report_build_info+0x954>)
 8015fae:	f893 3117 	ldrb.w	r3, [r3, #279]	; 0x117
 8015fb2:	4618      	mov	r0, r3
 8015fb4:	f7fa f96a 	bl	801028c <uitoa>
 8015fb8:	4603      	mov	r3, r0
 8015fba:	4618      	mov	r0, r3
 8015fbc:	47a0      	blx	r4
            hal.stream.write("]" ASCII_EOL);
 8015fbe:	4b07      	ldr	r3, [pc, #28]	; (8015fdc <report_build_info+0x954>)
 8015fc0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8015fc4:	4808      	ldr	r0, [pc, #32]	; (8015fe8 <report_build_info+0x960>)
 8015fc6:	4798      	blx	r3
        }

        grbl.on_report_options(false);
 8015fc8:	4b12      	ldr	r3, [pc, #72]	; (8016014 <report_build_info+0x98c>)
 8015fca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8015fcc:	2000      	movs	r0, #0
 8015fce:	4798      	blx	r3
    }
}
 8015fd0:	bf00      	nop
 8015fd2:	3778      	adds	r7, #120	; 0x78
 8015fd4:	46bd      	mov	sp, r7
 8015fd6:	bdb0      	pop	{r4, r5, r7, pc}
 8015fd8:	0802b4d4 	.word	0x0802b4d4
 8015fdc:	20000ed0 	.word	0x20000ed0
 8015fe0:	0802b278 	.word	0x0802b278
 8015fe4:	0802b4dc 	.word	0x0802b4dc
 8015fe8:	0802b1c0 	.word	0x0802b1c0
 8015fec:	0802b4e0 	.word	0x0802b4e0
 8015ff0:	0802b4f0 	.word	0x0802b4f0
 8015ff4:	0802b4f8 	.word	0x0802b4f8
 8015ff8:	0802b504 	.word	0x0802b504
 8015ffc:	0802b518 	.word	0x0802b518
 8016000:	0802b52c 	.word	0x0802b52c
 8016004:	0802b534 	.word	0x0802b534
 8016008:	0802b544 	.word	0x0802b544
 801600c:	0802b54c 	.word	0x0802b54c
 8016010:	0802b184 	.word	0x0802b184
 8016014:	20000dd4 	.word	0x20000dd4

08016018 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status (void)
{
 8016018:	b5b0      	push	{r4, r5, r7, lr}
 801601a:	b096      	sub	sp, #88	; 0x58
 801601c:	af00      	add	r7, sp, #0
    static bool probing = false;

    float print_position[N_AXIS];
    report_tracking_flags_t report = system_get_rt_report_flags();
 801601e:	f00b ffb3 	bl	8021f88 <system_get_rt_report_flags>
 8016022:	4603      	mov	r3, r0
 8016024:	62bb      	str	r3, [r7, #40]	; 0x28
    probe_state_t probe_state = {
 8016026:	2300      	movs	r3, #0
 8016028:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
 801602c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8016030:	f043 0302 	orr.w	r3, r3, #2
 8016034:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        .connected = On,
        .triggered = Off
    };

    system_convert_array_steps_to_mpos(print_position, sys.position);
 8016038:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801603c:	49a8      	ldr	r1, [pc, #672]	; (80162e0 <report_realtime_status+0x2c8>)
 801603e:	4618      	mov	r0, r3
 8016040:	f00b fee6 	bl	8021e10 <system_convert_array_steps_to_mpos>

    if(hal.probe.get_state)
 8016044:	4ba7      	ldr	r3, [pc, #668]	; (80162e4 <report_realtime_status+0x2cc>)
 8016046:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801604a:	2b00      	cmp	r3, #0
 801604c:	d006      	beq.n	801605c <report_realtime_status+0x44>
        probe_state = hal.probe.get_state();
 801604e:	4ba5      	ldr	r3, [pc, #660]	; (80162e4 <report_realtime_status+0x2cc>)
 8016050:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 8016054:	4798      	blx	r3
 8016056:	4603      	mov	r3, r0
 8016058:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24

    // Report current machine state and sub-states
    hal.stream.write_all("<");
 801605c:	4ba1      	ldr	r3, [pc, #644]	; (80162e4 <report_realtime_status+0x2cc>)
 801605e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016062:	48a1      	ldr	r0, [pc, #644]	; (80162e8 <report_realtime_status+0x2d0>)
 8016064:	4798      	blx	r3

    sys_state_t state = state_get();
 8016066:	f007 fc2b 	bl	801d8c0 <state_get>
 801606a:	6478      	str	r0, [r7, #68]	; 0x44

    switch (gc_state.tool_change && state == STATE_CYCLE ? STATE_TOOL_CHANGE : state) {
 801606c:	4b9f      	ldr	r3, [pc, #636]	; (80162ec <report_realtime_status+0x2d4>)
 801606e:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 8016072:	2b00      	cmp	r3, #0
 8016074:	d002      	beq.n	801607c <report_realtime_status+0x64>
 8016076:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016078:	2b08      	cmp	r3, #8
 801607a:	d001      	beq.n	8016080 <report_realtime_status+0x68>
 801607c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801607e:	e001      	b.n	8016084 <report_realtime_status+0x6c>
 8016080:	f44f 7300 	mov.w	r3, #512	; 0x200
 8016084:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8016088:	f000 8110 	beq.w	80162ac <report_realtime_status+0x294>
 801608c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8016090:	f200 8113 	bhi.w	80162ba <report_realtime_status+0x2a2>
 8016094:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8016098:	f000 80bc 	beq.w	8016214 <report_realtime_status+0x1fc>
 801609c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80160a0:	f200 810b 	bhi.w	80162ba <report_realtime_status+0x2a2>
 80160a4:	2b80      	cmp	r3, #128	; 0x80
 80160a6:	f000 80fb 	beq.w	80162a0 <report_realtime_status+0x288>
 80160aa:	2b80      	cmp	r3, #128	; 0x80
 80160ac:	f200 8105 	bhi.w	80162ba <report_realtime_status+0x2a2>
 80160b0:	2b20      	cmp	r3, #32
 80160b2:	d847      	bhi.n	8016144 <report_realtime_status+0x12c>
 80160b4:	2b20      	cmp	r3, #32
 80160b6:	f200 8100 	bhi.w	80162ba <report_realtime_status+0x2a2>
 80160ba:	a201      	add	r2, pc, #4	; (adr r2, 80160c0 <report_realtime_status+0xa8>)
 80160bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80160c0:	0801614d 	.word	0x0801614d
 80160c4:	08016215 	.word	0x08016215
 80160c8:	0801626f 	.word	0x0801626f
 80160cc:	080162bb 	.word	0x080162bb
 80160d0:	08016209 	.word	0x08016209
 80160d4:	080162bb 	.word	0x080162bb
 80160d8:	080162bb 	.word	0x080162bb
 80160dc:	080162bb 	.word	0x080162bb
 80160e0:	08016159 	.word	0x08016159
 80160e4:	080162bb 	.word	0x080162bb
 80160e8:	080162bb 	.word	0x080162bb
 80160ec:	080162bb 	.word	0x080162bb
 80160f0:	080162bb 	.word	0x080162bb
 80160f4:	080162bb 	.word	0x080162bb
 80160f8:	080162bb 	.word	0x080162bb
 80160fc:	080162bb 	.word	0x080162bb
 8016100:	080161d5 	.word	0x080161d5
 8016104:	080162bb 	.word	0x080162bb
 8016108:	080162bb 	.word	0x080162bb
 801610c:	080162bb 	.word	0x080162bb
 8016110:	080162bb 	.word	0x080162bb
 8016114:	080162bb 	.word	0x080162bb
 8016118:	080162bb 	.word	0x080162bb
 801611c:	080162bb 	.word	0x080162bb
 8016120:	080162bb 	.word	0x080162bb
 8016124:	080162bb 	.word	0x080162bb
 8016128:	080162bb 	.word	0x080162bb
 801612c:	080162bb 	.word	0x080162bb
 8016130:	080162bb 	.word	0x080162bb
 8016134:	080162bb 	.word	0x080162bb
 8016138:	080162bb 	.word	0x080162bb
 801613c:	080162bb 	.word	0x080162bb
 8016140:	080161fd 	.word	0x080161fd
 8016144:	2b40      	cmp	r3, #64	; 0x40
 8016146:	f000 8098 	beq.w	801627a <report_realtime_status+0x262>
 801614a:	e0b6      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_IDLE:
            hal.stream.write_all("Idle");
 801614c:	4b65      	ldr	r3, [pc, #404]	; (80162e4 <report_realtime_status+0x2cc>)
 801614e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016152:	4867      	ldr	r0, [pc, #412]	; (80162f0 <report_realtime_status+0x2d8>)
 8016154:	4798      	blx	r3
            break;
 8016156:	e0b0      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_CYCLE:
            hal.stream.write_all("Run");
 8016158:	4b62      	ldr	r3, [pc, #392]	; (80162e4 <report_realtime_status+0x2cc>)
 801615a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801615e:	4865      	ldr	r0, [pc, #404]	; (80162f4 <report_realtime_status+0x2dc>)
 8016160:	4798      	blx	r3
            if(sys.probing_state == Probing_Active && settings.status_report.run_substate)
 8016162:	4b65      	ldr	r3, [pc, #404]	; (80162f8 <report_realtime_status+0x2e0>)
 8016164:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8016168:	b2db      	uxtb	r3, r3
 801616a:	2b01      	cmp	r3, #1
 801616c:	d10b      	bne.n	8016186 <report_realtime_status+0x16e>
 801616e:	4b63      	ldr	r3, [pc, #396]	; (80162fc <report_realtime_status+0x2e4>)
 8016170:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8016174:	f003 0308 	and.w	r3, r3, #8
 8016178:	b2db      	uxtb	r3, r3
 801617a:	2b00      	cmp	r3, #0
 801617c:	d003      	beq.n	8016186 <report_realtime_status+0x16e>
                probing = true;
 801617e:	4b60      	ldr	r3, [pc, #384]	; (8016300 <report_realtime_status+0x2e8>)
 8016180:	2201      	movs	r2, #1
 8016182:	701a      	strb	r2, [r3, #0]
 8016184:	e00f      	b.n	80161a6 <report_realtime_status+0x18e>
            else if (probing)
 8016186:	4b5e      	ldr	r3, [pc, #376]	; (8016300 <report_realtime_status+0x2e8>)
 8016188:	781b      	ldrb	r3, [r3, #0]
 801618a:	2b00      	cmp	r3, #0
 801618c:	d00b      	beq.n	80161a6 <report_realtime_status+0x18e>
                probing = probe_state.triggered;
 801618e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8016192:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8016196:	b2db      	uxtb	r3, r3
 8016198:	2b00      	cmp	r3, #0
 801619a:	bf14      	ite	ne
 801619c:	2301      	movne	r3, #1
 801619e:	2300      	moveq	r3, #0
 80161a0:	b2da      	uxtb	r2, r3
 80161a2:	4b57      	ldr	r3, [pc, #348]	; (8016300 <report_realtime_status+0x2e8>)
 80161a4:	701a      	strb	r2, [r3, #0]
            if(sys.flags.feed_hold_pending)
 80161a6:	4b54      	ldr	r3, [pc, #336]	; (80162f8 <report_realtime_status+0x2e0>)
 80161a8:	7d9b      	ldrb	r3, [r3, #22]
 80161aa:	f003 0320 	and.w	r3, r3, #32
 80161ae:	b2db      	uxtb	r3, r3
 80161b0:	2b00      	cmp	r3, #0
 80161b2:	d005      	beq.n	80161c0 <report_realtime_status+0x1a8>
                hal.stream.write_all(":1");
 80161b4:	4b4b      	ldr	r3, [pc, #300]	; (80162e4 <report_realtime_status+0x2cc>)
 80161b6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80161ba:	4852      	ldr	r0, [pc, #328]	; (8016304 <report_realtime_status+0x2ec>)
 80161bc:	4798      	blx	r3
            else if(probing)
                hal.stream.write_all(":2");
            break;
 80161be:	e07b      	b.n	80162b8 <report_realtime_status+0x2a0>
            else if(probing)
 80161c0:	4b4f      	ldr	r3, [pc, #316]	; (8016300 <report_realtime_status+0x2e8>)
 80161c2:	781b      	ldrb	r3, [r3, #0]
 80161c4:	2b00      	cmp	r3, #0
 80161c6:	d077      	beq.n	80162b8 <report_realtime_status+0x2a0>
                hal.stream.write_all(":2");
 80161c8:	4b46      	ldr	r3, [pc, #280]	; (80162e4 <report_realtime_status+0x2cc>)
 80161ca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80161ce:	484e      	ldr	r0, [pc, #312]	; (8016308 <report_realtime_status+0x2f0>)
 80161d0:	4798      	blx	r3
            break;
 80161d2:	e071      	b.n	80162b8 <report_realtime_status+0x2a0>

        case STATE_HOLD:
            hal.stream.write_all(appendbuf(2, "Hold:", uitoa((uint32_t)(sys.holding_state - 1))));
 80161d4:	4b43      	ldr	r3, [pc, #268]	; (80162e4 <report_realtime_status+0x2cc>)
 80161d6:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80161da:	4b47      	ldr	r3, [pc, #284]	; (80162f8 <report_realtime_status+0x2e0>)
 80161dc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80161e0:	3b01      	subs	r3, #1
 80161e2:	4618      	mov	r0, r3
 80161e4:	f7fa f852 	bl	801028c <uitoa>
 80161e8:	4603      	mov	r3, r0
 80161ea:	461a      	mov	r2, r3
 80161ec:	4947      	ldr	r1, [pc, #284]	; (801630c <report_realtime_status+0x2f4>)
 80161ee:	2002      	movs	r0, #2
 80161f0:	f7fd fedc 	bl	8013fac <appendbuf>
 80161f4:	4603      	mov	r3, r0
 80161f6:	4618      	mov	r0, r3
 80161f8:	47a0      	blx	r4
            break;
 80161fa:	e05e      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_JOG:
            hal.stream.write_all("Jog");
 80161fc:	4b39      	ldr	r3, [pc, #228]	; (80162e4 <report_realtime_status+0x2cc>)
 80161fe:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016202:	4843      	ldr	r0, [pc, #268]	; (8016310 <report_realtime_status+0x2f8>)
 8016204:	4798      	blx	r3
            break;
 8016206:	e058      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_HOMING:
            hal.stream.write_all("Home");
 8016208:	4b36      	ldr	r3, [pc, #216]	; (80162e4 <report_realtime_status+0x2cc>)
 801620a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801620e:	4841      	ldr	r0, [pc, #260]	; (8016314 <report_realtime_status+0x2fc>)
 8016210:	4798      	blx	r3
            break;
 8016212:	e052      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_ESTOP:
        case STATE_ALARM:
            if((report.all || settings.status_report.alarm_substate) && sys.alarm)
 8016214:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8016218:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801621c:	b2db      	uxtb	r3, r3
 801621e:	2b00      	cmp	r3, #0
 8016220:	d107      	bne.n	8016232 <report_realtime_status+0x21a>
 8016222:	4b36      	ldr	r3, [pc, #216]	; (80162fc <report_realtime_status+0x2e4>)
 8016224:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8016228:	f003 0304 	and.w	r3, r3, #4
 801622c:	b2db      	uxtb	r3, r3
 801622e:	2b00      	cmp	r3, #0
 8016230:	d017      	beq.n	8016262 <report_realtime_status+0x24a>
 8016232:	4b31      	ldr	r3, [pc, #196]	; (80162f8 <report_realtime_status+0x2e0>)
 8016234:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8016238:	2b00      	cmp	r3, #0
 801623a:	d012      	beq.n	8016262 <report_realtime_status+0x24a>
                hal.stream.write_all(appendbuf(2, "Alarm:", uitoa((uint32_t)sys.alarm)));
 801623c:	4b29      	ldr	r3, [pc, #164]	; (80162e4 <report_realtime_status+0x2cc>)
 801623e:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016242:	4b2d      	ldr	r3, [pc, #180]	; (80162f8 <report_realtime_status+0x2e0>)
 8016244:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8016248:	4618      	mov	r0, r3
 801624a:	f7fa f81f 	bl	801028c <uitoa>
 801624e:	4603      	mov	r3, r0
 8016250:	461a      	mov	r2, r3
 8016252:	4931      	ldr	r1, [pc, #196]	; (8016318 <report_realtime_status+0x300>)
 8016254:	2002      	movs	r0, #2
 8016256:	f7fd fea9 	bl	8013fac <appendbuf>
 801625a:	4603      	mov	r3, r0
 801625c:	4618      	mov	r0, r3
 801625e:	47a0      	blx	r4
            else
                hal.stream.write_all("Alarm");
            break;
 8016260:	e02b      	b.n	80162ba <report_realtime_status+0x2a2>
                hal.stream.write_all("Alarm");
 8016262:	4b20      	ldr	r3, [pc, #128]	; (80162e4 <report_realtime_status+0x2cc>)
 8016264:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016268:	482c      	ldr	r0, [pc, #176]	; (801631c <report_realtime_status+0x304>)
 801626a:	4798      	blx	r3
            break;
 801626c:	e025      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_CHECK_MODE:
            hal.stream.write_all("Check");
 801626e:	4b1d      	ldr	r3, [pc, #116]	; (80162e4 <report_realtime_status+0x2cc>)
 8016270:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016274:	482a      	ldr	r0, [pc, #168]	; (8016320 <report_realtime_status+0x308>)
 8016276:	4798      	blx	r3
            break;
 8016278:	e01f      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_SAFETY_DOOR:
            hal.stream.write_all(appendbuf(2, "Door:", uitoa((uint32_t)sys.parking_state)));
 801627a:	4b1a      	ldr	r3, [pc, #104]	; (80162e4 <report_realtime_status+0x2cc>)
 801627c:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016280:	4b1d      	ldr	r3, [pc, #116]	; (80162f8 <report_realtime_status+0x2e0>)
 8016282:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8016286:	4618      	mov	r0, r3
 8016288:	f7fa f800 	bl	801028c <uitoa>
 801628c:	4603      	mov	r3, r0
 801628e:	461a      	mov	r2, r3
 8016290:	4924      	ldr	r1, [pc, #144]	; (8016324 <report_realtime_status+0x30c>)
 8016292:	2002      	movs	r0, #2
 8016294:	f7fd fe8a 	bl	8013fac <appendbuf>
 8016298:	4603      	mov	r3, r0
 801629a:	4618      	mov	r0, r3
 801629c:	47a0      	blx	r4
            break;
 801629e:	e00c      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_SLEEP:
            hal.stream.write_all("Sleep");
 80162a0:	4b10      	ldr	r3, [pc, #64]	; (80162e4 <report_realtime_status+0x2cc>)
 80162a2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80162a6:	4820      	ldr	r0, [pc, #128]	; (8016328 <report_realtime_status+0x310>)
 80162a8:	4798      	blx	r3
            break;
 80162aa:	e006      	b.n	80162ba <report_realtime_status+0x2a2>

        case STATE_TOOL_CHANGE:
            hal.stream.write_all("Tool");
 80162ac:	4b0d      	ldr	r3, [pc, #52]	; (80162e4 <report_realtime_status+0x2cc>)
 80162ae:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80162b2:	481e      	ldr	r0, [pc, #120]	; (801632c <report_realtime_status+0x314>)
 80162b4:	4798      	blx	r3
            break;
 80162b6:	e000      	b.n	80162ba <report_realtime_status+0x2a2>
            break;
 80162b8:	bf00      	nop
    }

    uint_fast8_t idx;
    float wco[N_AXIS];
    if (!settings.status_report.machine_position || report.wco) {
 80162ba:	4b10      	ldr	r3, [pc, #64]	; (80162fc <report_realtime_status+0x2e4>)
 80162bc:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 80162c0:	f003 0301 	and.w	r3, r3, #1
 80162c4:	b2db      	uxtb	r3, r3
 80162c6:	2b00      	cmp	r3, #0
 80162c8:	d006      	beq.n	80162d8 <report_realtime_status+0x2c0>
 80162ca:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80162ce:	f003 0301 	and.w	r3, r3, #1
 80162d2:	b2db      	uxtb	r3, r3
 80162d4:	2b00      	cmp	r3, #0
 80162d6:	d05b      	beq.n	8016390 <report_realtime_status+0x378>
        for (idx = 0; idx < N_AXIS; idx++) {
 80162d8:	2300      	movs	r3, #0
 80162da:	657b      	str	r3, [r7, #84]	; 0x54
 80162dc:	e055      	b.n	801638a <report_realtime_status+0x372>
 80162de:	bf00      	nop
 80162e0:	20000dc4 	.word	0x20000dc4
 80162e4:	20000ed0 	.word	0x20000ed0
 80162e8:	0802b560 	.word	0x0802b560
 80162ec:	20000bb0 	.word	0x20000bb0
 80162f0:	0802b564 	.word	0x0802b564
 80162f4:	0802b56c 	.word	0x0802b56c
 80162f8:	20000d3c 	.word	0x20000d3c
 80162fc:	2000147c 	.word	0x2000147c
 8016300:	20001442 	.word	0x20001442
 8016304:	0802b2b4 	.word	0x0802b2b4
 8016308:	0802b570 	.word	0x0802b570
 801630c:	0802b574 	.word	0x0802b574
 8016310:	0802b57c 	.word	0x0802b57c
 8016314:	0802b580 	.word	0x0802b580
 8016318:	0802b588 	.word	0x0802b588
 801631c:	0802b590 	.word	0x0802b590
 8016320:	0802b598 	.word	0x0802b598
 8016324:	0802b5a0 	.word	0x0802b5a0
 8016328:	0802b5a8 	.word	0x0802b5a8
 801632c:	0802b5b0 	.word	0x0802b5b0
            // Apply work coordinate offsets and tool length offset to current position.
            wco[idx] = gc_get_offset(idx);
 8016330:	6d78      	ldr	r0, [r7, #84]	; 0x54
 8016332:	f7ef fb53 	bl	80059dc <gc_get_offset>
 8016336:	4602      	mov	r2, r0
 8016338:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801633a:	009b      	lsls	r3, r3, #2
 801633c:	3358      	adds	r3, #88	; 0x58
 801633e:	443b      	add	r3, r7
 8016340:	f843 2c40 	str.w	r2, [r3, #-64]
            if (!settings.status_report.machine_position)
 8016344:	4b7c      	ldr	r3, [pc, #496]	; (8016538 <report_realtime_status+0x520>)
 8016346:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801634a:	f003 0301 	and.w	r3, r3, #1
 801634e:	b2db      	uxtb	r3, r3
 8016350:	2b00      	cmp	r3, #0
 8016352:	d117      	bne.n	8016384 <report_realtime_status+0x36c>
                print_position[idx] -= wco[idx];
 8016354:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016356:	009b      	lsls	r3, r3, #2
 8016358:	3358      	adds	r3, #88	; 0x58
 801635a:	443b      	add	r3, r7
 801635c:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 8016360:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016362:	009b      	lsls	r3, r3, #2
 8016364:	3358      	adds	r3, #88	; 0x58
 8016366:	443b      	add	r3, r7
 8016368:	f853 3c40 	ldr.w	r3, [r3, #-64]
 801636c:	4619      	mov	r1, r3
 801636e:	4610      	mov	r0, r2
 8016370:	f7ea fc16 	bl	8000ba0 <__aeabi_fsub>
 8016374:	4603      	mov	r3, r0
 8016376:	461a      	mov	r2, r3
 8016378:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801637a:	009b      	lsls	r3, r3, #2
 801637c:	3358      	adds	r3, #88	; 0x58
 801637e:	443b      	add	r3, r7
 8016380:	f843 2c2c 	str.w	r2, [r3, #-44]
        for (idx = 0; idx < N_AXIS; idx++) {
 8016384:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016386:	3301      	adds	r3, #1
 8016388:	657b      	str	r3, [r7, #84]	; 0x54
 801638a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801638c:	2b02      	cmp	r3, #2
 801638e:	d9cf      	bls.n	8016330 <report_realtime_status+0x318>
        }
    }

    // Report position
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 8016390:	4b6a      	ldr	r3, [pc, #424]	; (801653c <report_realtime_status+0x524>)
 8016392:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016396:	4a68      	ldr	r2, [pc, #416]	; (8016538 <report_realtime_status+0x520>)
 8016398:	f892 20fc 	ldrb.w	r2, [r2, #252]	; 0xfc
 801639c:	f002 0201 	and.w	r2, r2, #1
 80163a0:	b2d2      	uxtb	r2, r2
 80163a2:	2a00      	cmp	r2, #0
 80163a4:	d001      	beq.n	80163aa <report_realtime_status+0x392>
 80163a6:	4a66      	ldr	r2, [pc, #408]	; (8016540 <report_realtime_status+0x528>)
 80163a8:	e000      	b.n	80163ac <report_realtime_status+0x394>
 80163aa:	4a66      	ldr	r2, [pc, #408]	; (8016544 <report_realtime_status+0x52c>)
 80163ac:	4610      	mov	r0, r2
 80163ae:	4798      	blx	r3
    hal.stream.write_all(get_axis_values(print_position));
 80163b0:	4b62      	ldr	r3, [pc, #392]	; (801653c <report_realtime_status+0x524>)
 80163b2:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80163b6:	4b64      	ldr	r3, [pc, #400]	; (8016548 <report_realtime_status+0x530>)
 80163b8:	681b      	ldr	r3, [r3, #0]
 80163ba:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80163be:	4610      	mov	r0, r2
 80163c0:	4798      	blx	r3
 80163c2:	4603      	mov	r3, r0
 80163c4:	4618      	mov	r0, r3
 80163c6:	47a0      	blx	r4

    // Returns planner and output stream buffer states.

    if (settings.status_report.buffer_state) {
 80163c8:	4b5b      	ldr	r3, [pc, #364]	; (8016538 <report_realtime_status+0x520>)
 80163ca:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 80163ce:	f003 0302 	and.w	r3, r3, #2
 80163d2:	b2db      	uxtb	r3, r3
 80163d4:	2b00      	cmp	r3, #0
 80163d6:	d023      	beq.n	8016420 <report_realtime_status+0x408>
        hal.stream.write_all("|Bf:");
 80163d8:	4b58      	ldr	r3, [pc, #352]	; (801653c <report_realtime_status+0x524>)
 80163da:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80163de:	485b      	ldr	r0, [pc, #364]	; (801654c <report_realtime_status+0x534>)
 80163e0:	4798      	blx	r3
        hal.stream.write_all(uitoa((uint32_t)plan_get_block_buffer_available()));
 80163e2:	4b56      	ldr	r3, [pc, #344]	; (801653c <report_realtime_status+0x524>)
 80163e4:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80163e8:	f7fb ff0e 	bl	8012208 <plan_get_block_buffer_available>
 80163ec:	4603      	mov	r3, r0
 80163ee:	4618      	mov	r0, r3
 80163f0:	f7f9 ff4c 	bl	801028c <uitoa>
 80163f4:	4603      	mov	r3, r0
 80163f6:	4618      	mov	r0, r3
 80163f8:	47a0      	blx	r4
        hal.stream.write_all(",");
 80163fa:	4b50      	ldr	r3, [pc, #320]	; (801653c <report_realtime_status+0x524>)
 80163fc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016400:	4853      	ldr	r0, [pc, #332]	; (8016550 <report_realtime_status+0x538>)
 8016402:	4798      	blx	r3
        hal.stream.write_all(uitoa(hal.stream.get_rx_buffer_free()));
 8016404:	4b4d      	ldr	r3, [pc, #308]	; (801653c <report_realtime_status+0x524>)
 8016406:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 801640a:	4b4c      	ldr	r3, [pc, #304]	; (801653c <report_realtime_status+0x524>)
 801640c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8016410:	4798      	blx	r3
 8016412:	4603      	mov	r3, r0
 8016414:	4618      	mov	r0, r3
 8016416:	f7f9 ff39 	bl	801028c <uitoa>
 801641a:	4603      	mov	r3, r0
 801641c:	4618      	mov	r0, r3
 801641e:	47a0      	blx	r4
    }

    if(settings.status_report.line_numbers) {
 8016420:	4b45      	ldr	r3, [pc, #276]	; (8016538 <report_realtime_status+0x520>)
 8016422:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8016426:	f003 0304 	and.w	r3, r3, #4
 801642a:	b2db      	uxtb	r3, r3
 801642c:	2b00      	cmp	r3, #0
 801642e:	d01a      	beq.n	8016466 <report_realtime_status+0x44e>
        // Report current line number
        plan_block_t *cur_block = plan_get_current_block();
 8016430:	f7fb fa54 	bl	80118dc <plan_get_current_block>
 8016434:	6438      	str	r0, [r7, #64]	; 0x40
        if (cur_block != NULL && cur_block->line_number > 0)
 8016436:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016438:	2b00      	cmp	r3, #0
 801643a:	d014      	beq.n	8016466 <report_realtime_status+0x44e>
 801643c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801643e:	699b      	ldr	r3, [r3, #24]
 8016440:	2b00      	cmp	r3, #0
 8016442:	dd10      	ble.n	8016466 <report_realtime_status+0x44e>
            hal.stream.write_all(appendbuf(2, "|Ln:", uitoa((uint32_t)cur_block->line_number)));
 8016444:	4b3d      	ldr	r3, [pc, #244]	; (801653c <report_realtime_status+0x524>)
 8016446:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 801644a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801644c:	699b      	ldr	r3, [r3, #24]
 801644e:	4618      	mov	r0, r3
 8016450:	f7f9 ff1c 	bl	801028c <uitoa>
 8016454:	4603      	mov	r3, r0
 8016456:	461a      	mov	r2, r3
 8016458:	493e      	ldr	r1, [pc, #248]	; (8016554 <report_realtime_status+0x53c>)
 801645a:	2002      	movs	r0, #2
 801645c:	f7fd fda6 	bl	8013fac <appendbuf>
 8016460:	4603      	mov	r3, r0
 8016462:	4618      	mov	r0, r3
 8016464:	47a0      	blx	r4
    }

    spindle_ptrs_t *spindle_0;
    spindle_state_t spindle_0_state;

    spindle_0 = spindle_get(0);
 8016466:	2000      	movs	r0, #0
 8016468:	f006 fb48 	bl	801cafc <spindle_get>
 801646c:	63f8      	str	r0, [r7, #60]	; 0x3c
    spindle_0_state = spindle_0->get_state(spindle_0);
 801646e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016470:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016472:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016474:	4798      	blx	r3
 8016476:	4603      	mov	r3, r0
 8016478:	753b      	strb	r3, [r7, #20]

    // Report realtime feed speed
    if(settings.status_report.feed_speed) {
 801647a:	4b2f      	ldr	r3, [pc, #188]	; (8016538 <report_realtime_status+0x520>)
 801647c:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8016480:	f003 0308 	and.w	r3, r3, #8
 8016484:	b2db      	uxtb	r3, r3
 8016486:	2b00      	cmp	r3, #0
 8016488:	d07d      	beq.n	8016586 <report_realtime_status+0x56e>
        if(spindle_0->cap.variable) {
 801648a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801648c:	7a9b      	ldrb	r3, [r3, #10]
 801648e:	f003 0301 	and.w	r3, r3, #1
 8016492:	b2db      	uxtb	r3, r3
 8016494:	2b00      	cmp	r3, #0
 8016496:	d063      	beq.n	8016560 <report_realtime_status+0x548>
            hal.stream.write_all(appendbuf(2, "|FS:", get_rate_value(st_get_realtime_rate())));
 8016498:	4b28      	ldr	r3, [pc, #160]	; (801653c <report_realtime_status+0x524>)
 801649a:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 801649e:	4b2e      	ldr	r3, [pc, #184]	; (8016558 <report_realtime_status+0x540>)
 80164a0:	681d      	ldr	r5, [r3, #0]
 80164a2:	f009 fe2b 	bl	80200fc <st_get_realtime_rate>
 80164a6:	4603      	mov	r3, r0
 80164a8:	4618      	mov	r0, r3
 80164aa:	47a8      	blx	r5
 80164ac:	4603      	mov	r3, r0
 80164ae:	461a      	mov	r2, r3
 80164b0:	492a      	ldr	r1, [pc, #168]	; (801655c <report_realtime_status+0x544>)
 80164b2:	2002      	movs	r0, #2
 80164b4:	f7fd fd7a 	bl	8013fac <appendbuf>
 80164b8:	4603      	mov	r3, r0
 80164ba:	4618      	mov	r0, r3
 80164bc:	47a0      	blx	r4
            hal.stream.write_all(appendbuf(2, ",", uitoa(spindle_0_state.on ? lroundf(spindle_0->param->rpm_overridden) : 0)));
 80164be:	4b1f      	ldr	r3, [pc, #124]	; (801653c <report_realtime_status+0x524>)
 80164c0:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80164c4:	7d3b      	ldrb	r3, [r7, #20]
 80164c6:	f003 0301 	and.w	r3, r3, #1
 80164ca:	b2db      	uxtb	r3, r3
 80164cc:	2b00      	cmp	r3, #0
 80164ce:	d007      	beq.n	80164e0 <report_realtime_status+0x4c8>
 80164d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80164d2:	685b      	ldr	r3, [r3, #4]
 80164d4:	685b      	ldr	r3, [r3, #4]
 80164d6:	4618      	mov	r0, r3
 80164d8:	f00e fb4c 	bl	8024b74 <lroundf>
 80164dc:	4603      	mov	r3, r0
 80164de:	e000      	b.n	80164e2 <report_realtime_status+0x4ca>
 80164e0:	2300      	movs	r3, #0
 80164e2:	4618      	mov	r0, r3
 80164e4:	f7f9 fed2 	bl	801028c <uitoa>
 80164e8:	4603      	mov	r3, r0
 80164ea:	461a      	mov	r2, r3
 80164ec:	4918      	ldr	r1, [pc, #96]	; (8016550 <report_realtime_status+0x538>)
 80164ee:	2002      	movs	r0, #2
 80164f0:	f7fd fd5c 	bl	8013fac <appendbuf>
 80164f4:	4603      	mov	r3, r0
 80164f6:	4618      	mov	r0, r3
 80164f8:	47a0      	blx	r4
            if(spindle_0->get_data /* && sys.mpg_mode */)
 80164fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80164fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80164fe:	2b00      	cmp	r3, #0
 8016500:	d041      	beq.n	8016586 <report_realtime_status+0x56e>
                hal.stream.write_all(appendbuf(2, ",", uitoa(lroundf(spindle_0->get_data(SpindleData_RPM)->rpm))));
 8016502:	4b0e      	ldr	r3, [pc, #56]	; (801653c <report_realtime_status+0x524>)
 8016504:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016508:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801650a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801650c:	2001      	movs	r0, #1
 801650e:	4798      	blx	r3
 8016510:	4603      	mov	r3, r0
 8016512:	681b      	ldr	r3, [r3, #0]
 8016514:	4618      	mov	r0, r3
 8016516:	f00e fb2d 	bl	8024b74 <lroundf>
 801651a:	4603      	mov	r3, r0
 801651c:	4618      	mov	r0, r3
 801651e:	f7f9 feb5 	bl	801028c <uitoa>
 8016522:	4603      	mov	r3, r0
 8016524:	461a      	mov	r2, r3
 8016526:	490a      	ldr	r1, [pc, #40]	; (8016550 <report_realtime_status+0x538>)
 8016528:	2002      	movs	r0, #2
 801652a:	f7fd fd3f 	bl	8013fac <appendbuf>
 801652e:	4603      	mov	r3, r0
 8016530:	4618      	mov	r0, r3
 8016532:	47a0      	blx	r4
 8016534:	e027      	b.n	8016586 <report_realtime_status+0x56e>
 8016536:	bf00      	nop
 8016538:	2000147c 	.word	0x2000147c
 801653c:	20000ed0 	.word	0x20000ed0
 8016540:	0802b5b8 	.word	0x0802b5b8
 8016544:	0802b5c0 	.word	0x0802b5c0
 8016548:	20001434 	.word	0x20001434
 801654c:	0802b5c8 	.word	0x0802b5c8
 8016550:	0802b184 	.word	0x0802b184
 8016554:	0802b5d0 	.word	0x0802b5d0
 8016558:	2000143c 	.word	0x2000143c
 801655c:	0802b5d8 	.word	0x0802b5d8
        } else
            hal.stream.write_all(appendbuf(2, "|F:", get_rate_value(st_get_realtime_rate())));
 8016560:	4b9f      	ldr	r3, [pc, #636]	; (80167e0 <report_realtime_status+0x7c8>)
 8016562:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016566:	4b9f      	ldr	r3, [pc, #636]	; (80167e4 <report_realtime_status+0x7cc>)
 8016568:	681d      	ldr	r5, [r3, #0]
 801656a:	f009 fdc7 	bl	80200fc <st_get_realtime_rate>
 801656e:	4603      	mov	r3, r0
 8016570:	4618      	mov	r0, r3
 8016572:	47a8      	blx	r5
 8016574:	4603      	mov	r3, r0
 8016576:	461a      	mov	r2, r3
 8016578:	499b      	ldr	r1, [pc, #620]	; (80167e8 <report_realtime_status+0x7d0>)
 801657a:	2002      	movs	r0, #2
 801657c:	f7fd fd16 	bl	8013fac <appendbuf>
 8016580:	4603      	mov	r3, r0
 8016582:	4618      	mov	r0, r3
 8016584:	47a0      	blx	r4
        }
    }

#endif

    if(settings.status_report.pin_state) {
 8016586:	4b99      	ldr	r3, [pc, #612]	; (80167ec <report_realtime_status+0x7d4>)
 8016588:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 801658c:	f003 0310 	and.w	r3, r3, #16
 8016590:	b2db      	uxtb	r3, r3
 8016592:	2b00      	cmp	r3, #0
 8016594:	d07a      	beq.n	801668c <report_realtime_status+0x674>

        axes_signals_t lim_pin_state = limit_signals_merge(hal.limits.get_state());
 8016596:	4b92      	ldr	r3, [pc, #584]	; (80167e0 <report_realtime_status+0x7c8>)
 8016598:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801659a:	4798      	blx	r3
 801659c:	4603      	mov	r3, r0
 801659e:	63bb      	str	r3, [r7, #56]	; 0x38
 80165a0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80165a2:	f7f5 fcd5 	bl	800bf50 <limit_signals_merge>
 80165a6:	4603      	mov	r3, r0
 80165a8:	743b      	strb	r3, [r7, #16]
        control_signals_t ctrl_pin_state = hal.control.get_state();
 80165aa:	4b8d      	ldr	r3, [pc, #564]	; (80167e0 <report_realtime_status+0x7c8>)
 80165ac:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80165ae:	4798      	blx	r3
 80165b0:	4603      	mov	r3, r0
 80165b2:	81bb      	strh	r3, [r7, #12]

        ctrl_pin_state.cycle_start |= sys.report.cycle_start;
 80165b4:	7b3b      	ldrb	r3, [r7, #12]
 80165b6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80165ba:	b2da      	uxtb	r2, r3
 80165bc:	4b8c      	ldr	r3, [pc, #560]	; (80167f0 <report_realtime_status+0x7d8>)
 80165be:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 80165c2:	f3c3 1380 	ubfx	r3, r3, #6, #1
 80165c6:	b2db      	uxtb	r3, r3
 80165c8:	4313      	orrs	r3, r2
 80165ca:	b2da      	uxtb	r2, r3
 80165cc:	7b3b      	ldrb	r3, [r7, #12]
 80165ce:	f362 0382 	bfi	r3, r2, #2, #1
 80165d2:	733b      	strb	r3, [r7, #12]

        if (lim_pin_state.value | ctrl_pin_state.value | probe_state.triggered | !probe_state.connected | sys.flags.block_delete_enabled) {
 80165d4:	7c3b      	ldrb	r3, [r7, #16]
 80165d6:	461a      	mov	r2, r3
 80165d8:	89bb      	ldrh	r3, [r7, #12]
 80165da:	4313      	orrs	r3, r2
 80165dc:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 80165e0:	f3c2 0200 	ubfx	r2, r2, #0, #1
 80165e4:	b2d2      	uxtb	r2, r2
 80165e6:	4313      	orrs	r3, r2
 80165e8:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 80165ec:	f002 0202 	and.w	r2, r2, #2
 80165f0:	b2d2      	uxtb	r2, r2
 80165f2:	2a00      	cmp	r2, #0
 80165f4:	bf0c      	ite	eq
 80165f6:	2201      	moveq	r2, #1
 80165f8:	2200      	movne	r2, #0
 80165fa:	b2d2      	uxtb	r2, r2
 80165fc:	4313      	orrs	r3, r2
 80165fe:	4a7c      	ldr	r2, [pc, #496]	; (80167f0 <report_realtime_status+0x7d8>)
 8016600:	7d92      	ldrb	r2, [r2, #22]
 8016602:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8016606:	b2d2      	uxtb	r2, r2
 8016608:	4313      	orrs	r3, r2
 801660a:	2b00      	cmp	r3, #0
 801660c:	d03e      	beq.n	801668c <report_realtime_status+0x674>

            char *append = &buf[4];
 801660e:	4b79      	ldr	r3, [pc, #484]	; (80167f4 <report_realtime_status+0x7dc>)
 8016610:	653b      	str	r3, [r7, #80]	; 0x50

            strcpy(buf, "|Pn:");
 8016612:	4b79      	ldr	r3, [pc, #484]	; (80167f8 <report_realtime_status+0x7e0>)
 8016614:	4a79      	ldr	r2, [pc, #484]	; (80167fc <report_realtime_status+0x7e4>)
 8016616:	e892 0003 	ldmia.w	r2, {r0, r1}
 801661a:	6018      	str	r0, [r3, #0]
 801661c:	3304      	adds	r3, #4
 801661e:	7019      	strb	r1, [r3, #0]

            if(probe_state.triggered)
 8016620:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8016624:	f003 0301 	and.w	r3, r3, #1
 8016628:	b2db      	uxtb	r3, r3
 801662a:	2b00      	cmp	r3, #0
 801662c:	d004      	beq.n	8016638 <report_realtime_status+0x620>
                *append++ = 'P';
 801662e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016630:	1c5a      	adds	r2, r3, #1
 8016632:	653a      	str	r2, [r7, #80]	; 0x50
 8016634:	2250      	movs	r2, #80	; 0x50
 8016636:	701a      	strb	r2, [r3, #0]

            if(!probe_state.connected)
 8016638:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 801663c:	f003 0302 	and.w	r3, r3, #2
 8016640:	b2db      	uxtb	r3, r3
 8016642:	2b00      	cmp	r3, #0
 8016644:	d104      	bne.n	8016650 <report_realtime_status+0x638>
                *append++ = 'O';
 8016646:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016648:	1c5a      	adds	r2, r3, #1
 801664a:	653a      	str	r2, [r7, #80]	; 0x50
 801664c:	224f      	movs	r2, #79	; 0x4f
 801664e:	701a      	strb	r2, [r3, #0]

            if(lim_pin_state.value && !ctrl_pin_state.limits_override)
 8016650:	7c3b      	ldrb	r3, [r7, #16]
 8016652:	2b00      	cmp	r3, #0
 8016654:	d00a      	beq.n	801666c <report_realtime_status+0x654>
 8016656:	7b7b      	ldrb	r3, [r7, #13]
 8016658:	f003 0304 	and.w	r3, r3, #4
 801665c:	b2db      	uxtb	r3, r3
 801665e:	2b00      	cmp	r3, #0
 8016660:	d104      	bne.n	801666c <report_realtime_status+0x654>
                append = axis_signals_tostring(append, lim_pin_state);
 8016662:	7c39      	ldrb	r1, [r7, #16]
 8016664:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8016666:	f7fd fe13 	bl	8014290 <axis_signals_tostring>
 801666a:	6538      	str	r0, [r7, #80]	; 0x50

            if(ctrl_pin_state.value)
 801666c:	89bb      	ldrh	r3, [r7, #12]
 801666e:	2b00      	cmp	r3, #0
 8016670:	d004      	beq.n	801667c <report_realtime_status+0x664>
                append = control_signals_tostring(append, ctrl_pin_state);
 8016672:	89b9      	ldrh	r1, [r7, #12]
 8016674:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8016676:	f7fd fe3b 	bl	80142f0 <control_signals_tostring>
 801667a:	6538      	str	r0, [r7, #80]	; 0x50

            *append = '\0';
 801667c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801667e:	2200      	movs	r2, #0
 8016680:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all(buf);
 8016682:	4b57      	ldr	r3, [pc, #348]	; (80167e0 <report_realtime_status+0x7c8>)
 8016684:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016688:	485b      	ldr	r0, [pc, #364]	; (80167f8 <report_realtime_status+0x7e0>)
 801668a:	4798      	blx	r3
        }
    }

    if(settings.status_report.work_coord_offset) {
 801668c:	4b57      	ldr	r3, [pc, #348]	; (80167ec <report_realtime_status+0x7d4>)
 801668e:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8016692:	f003 0320 	and.w	r3, r3, #32
 8016696:	b2db      	uxtb	r3, r3
 8016698:	2b00      	cmp	r3, #0
 801669a:	d02a      	beq.n	80166f2 <report_realtime_status+0x6da>

        if(wco_counter > 0 && !report.wco) {
 801669c:	4b58      	ldr	r3, [pc, #352]	; (8016800 <report_realtime_status+0x7e8>)
 801669e:	781b      	ldrb	r3, [r3, #0]
 80166a0:	2b00      	cmp	r3, #0
 80166a2:	d019      	beq.n	80166d8 <report_realtime_status+0x6c0>
 80166a4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80166a8:	f003 0301 	and.w	r3, r3, #1
 80166ac:	b2db      	uxtb	r3, r3
 80166ae:	2b00      	cmp	r3, #0
 80166b0:	d112      	bne.n	80166d8 <report_realtime_status+0x6c0>
            if(wco_counter > (REPORT_WCO_REFRESH_IDLE_COUNT - 1) && state_get() == STATE_IDLE)
 80166b2:	4b53      	ldr	r3, [pc, #332]	; (8016800 <report_realtime_status+0x7e8>)
 80166b4:	781b      	ldrb	r3, [r3, #0]
 80166b6:	2b09      	cmp	r3, #9
 80166b8:	d907      	bls.n	80166ca <report_realtime_status+0x6b2>
 80166ba:	f007 f901 	bl	801d8c0 <state_get>
 80166be:	4603      	mov	r3, r0
 80166c0:	2b00      	cmp	r3, #0
 80166c2:	d102      	bne.n	80166ca <report_realtime_status+0x6b2>
                wco_counter = REPORT_WCO_REFRESH_IDLE_COUNT - 1;
 80166c4:	4b4e      	ldr	r3, [pc, #312]	; (8016800 <report_realtime_status+0x7e8>)
 80166c6:	2209      	movs	r2, #9
 80166c8:	701a      	strb	r2, [r3, #0]
            wco_counter--;
 80166ca:	4b4d      	ldr	r3, [pc, #308]	; (8016800 <report_realtime_status+0x7e8>)
 80166cc:	781b      	ldrb	r3, [r3, #0]
 80166ce:	3b01      	subs	r3, #1
 80166d0:	b2da      	uxtb	r2, r3
 80166d2:	4b4b      	ldr	r3, [pc, #300]	; (8016800 <report_realtime_status+0x7e8>)
 80166d4:	701a      	strb	r2, [r3, #0]
 80166d6:	e012      	b.n	80166fe <report_realtime_status+0x6e6>
        } else
            wco_counter = state_get() & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 80166d8:	f007 f8f2 	bl	801d8c0 <state_get>
 80166dc:	4603      	mov	r3, r0
 80166de:	f003 037c 	and.w	r3, r3, #124	; 0x7c
 80166e2:	2b00      	cmp	r3, #0
 80166e4:	d001      	beq.n	80166ea <report_realtime_status+0x6d2>
 80166e6:	221d      	movs	r2, #29
 80166e8:	e000      	b.n	80166ec <report_realtime_status+0x6d4>
 80166ea:	2209      	movs	r2, #9
 80166ec:	4b44      	ldr	r3, [pc, #272]	; (8016800 <report_realtime_status+0x7e8>)
 80166ee:	701a      	strb	r2, [r3, #0]
 80166f0:	e005      	b.n	80166fe <report_realtime_status+0x6e6>
                            ? (REPORT_WCO_REFRESH_BUSY_COUNT - 1) // Reset counter for slow refresh
                            : (REPORT_WCO_REFRESH_IDLE_COUNT - 1);
    } else
        report.wco = Off;
 80166f2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80166f6:	f36f 0300 	bfc	r3, #0, #1
 80166fa:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    if(settings.status_report.overrides) {
 80166fe:	4b3b      	ldr	r3, [pc, #236]	; (80167ec <report_realtime_status+0x7d4>)
 8016700:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8016704:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8016708:	b2db      	uxtb	r3, r3
 801670a:	2b00      	cmp	r3, #0
 801670c:	d07c      	beq.n	8016808 <report_realtime_status+0x7f0>

        if (override_counter > 0 && !report.overrides)
 801670e:	4b3d      	ldr	r3, [pc, #244]	; (8016804 <report_realtime_status+0x7ec>)
 8016710:	781b      	ldrb	r3, [r3, #0]
 8016712:	2b00      	cmp	r3, #0
 8016714:	d00d      	beq.n	8016732 <report_realtime_status+0x71a>
 8016716:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801671a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801671e:	b2db      	uxtb	r3, r3
 8016720:	2b00      	cmp	r3, #0
 8016722:	d106      	bne.n	8016732 <report_realtime_status+0x71a>
            override_counter--;
 8016724:	4b37      	ldr	r3, [pc, #220]	; (8016804 <report_realtime_status+0x7ec>)
 8016726:	781b      	ldrb	r3, [r3, #0]
 8016728:	3b01      	subs	r3, #1
 801672a:	b2da      	uxtb	r2, r3
 801672c:	4b35      	ldr	r3, [pc, #212]	; (8016804 <report_realtime_status+0x7ec>)
 801672e:	701a      	strb	r2, [r3, #0]
 8016730:	e070      	b.n	8016814 <report_realtime_status+0x7fc>
        else if((report.overrides = !report.wco)) {
 8016732:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016736:	f003 0301 	and.w	r3, r3, #1
 801673a:	b2db      	uxtb	r3, r3
 801673c:	2b00      	cmp	r3, #0
 801673e:	bf0c      	ite	eq
 8016740:	2301      	moveq	r3, #1
 8016742:	2300      	movne	r3, #0
 8016744:	b2da      	uxtb	r2, r3
 8016746:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801674a:	f362 1386 	bfi	r3, r2, #6, #1
 801674e:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 8016752:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016756:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801675a:	b2db      	uxtb	r3, r3
 801675c:	2b00      	cmp	r3, #0
 801675e:	d059      	beq.n	8016814 <report_realtime_status+0x7fc>
            report.spindle = report.spindle || spindle_0_state.on;
 8016760:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016764:	f003 0310 	and.w	r3, r3, #16
 8016768:	b2db      	uxtb	r3, r3
 801676a:	2b00      	cmp	r3, #0
 801676c:	d105      	bne.n	801677a <report_realtime_status+0x762>
 801676e:	7d3b      	ldrb	r3, [r7, #20]
 8016770:	f003 0301 	and.w	r3, r3, #1
 8016774:	b2db      	uxtb	r3, r3
 8016776:	2b00      	cmp	r3, #0
 8016778:	d001      	beq.n	801677e <report_realtime_status+0x766>
 801677a:	2301      	movs	r3, #1
 801677c:	e000      	b.n	8016780 <report_realtime_status+0x768>
 801677e:	2300      	movs	r3, #0
 8016780:	f003 0301 	and.w	r3, r3, #1
 8016784:	b2da      	uxtb	r2, r3
 8016786:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801678a:	f362 1304 	bfi	r3, r2, #4, #1
 801678e:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            report.coolant = report.coolant || hal.coolant.get_state().value != 0;
 8016792:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016796:	f003 0320 	and.w	r3, r3, #32
 801679a:	b2db      	uxtb	r3, r3
 801679c:	2b00      	cmp	r3, #0
 801679e:	d106      	bne.n	80167ae <report_realtime_status+0x796>
 80167a0:	4b0f      	ldr	r3, [pc, #60]	; (80167e0 <report_realtime_status+0x7c8>)
 80167a2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80167a4:	4798      	blx	r3
 80167a6:	4603      	mov	r3, r0
 80167a8:	b2db      	uxtb	r3, r3
 80167aa:	2b00      	cmp	r3, #0
 80167ac:	d001      	beq.n	80167b2 <report_realtime_status+0x79a>
 80167ae:	2301      	movs	r3, #1
 80167b0:	e000      	b.n	80167b4 <report_realtime_status+0x79c>
 80167b2:	2300      	movs	r3, #0
 80167b4:	f003 0301 	and.w	r3, r3, #1
 80167b8:	b2da      	uxtb	r2, r3
 80167ba:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80167be:	f362 1345 	bfi	r3, r2, #5, #1
 80167c2:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            override_counter = state_get() & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 80167c6:	f007 f87b 	bl	801d8c0 <state_get>
 80167ca:	4603      	mov	r3, r0
 80167cc:	f003 037c 	and.w	r3, r3, #124	; 0x7c
 80167d0:	2b00      	cmp	r3, #0
 80167d2:	d001      	beq.n	80167d8 <report_realtime_status+0x7c0>
 80167d4:	2213      	movs	r2, #19
 80167d6:	e000      	b.n	80167da <report_realtime_status+0x7c2>
 80167d8:	2209      	movs	r2, #9
 80167da:	4b0a      	ldr	r3, [pc, #40]	; (8016804 <report_realtime_status+0x7ec>)
 80167dc:	701a      	strb	r2, [r3, #0]
 80167de:	e019      	b.n	8016814 <report_realtime_status+0x7fc>
 80167e0:	20000ed0 	.word	0x20000ed0
 80167e4:	2000143c 	.word	0x2000143c
 80167e8:	0802b5e0 	.word	0x0802b5e0
 80167ec:	2000147c 	.word	0x2000147c
 80167f0:	20000d3c 	.word	0x20000d3c
 80167f4:	20001408 	.word	0x20001408
 80167f8:	20001404 	.word	0x20001404
 80167fc:	0802b5e4 	.word	0x0802b5e4
 8016800:	20001441 	.word	0x20001441
 8016804:	20001440 	.word	0x20001440
                                 ? (REPORT_OVERRIDE_REFRESH_BUSY_COUNT - 1) // Reset counter for slow refresh
                                 : (REPORT_OVERRIDE_REFRESH_IDLE_COUNT - 1);
        }
    } else
        report.overrides = Off;
 8016808:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801680c:	f36f 1386 	bfc	r3, #6, #1
 8016810:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28

    if(report.value || gc_state.tool_change) {
 8016814:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016816:	2b00      	cmp	r3, #0
 8016818:	d105      	bne.n	8016826 <report_realtime_status+0x80e>
 801681a:	4ba3      	ldr	r3, [pc, #652]	; (8016aa8 <report_realtime_status+0xa90>)
 801681c:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 8016820:	2b00      	cmp	r3, #0
 8016822:	f000 822e 	beq.w	8016c82 <report_realtime_status+0xc6a>

        if(report.wco) {
 8016826:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801682a:	f003 0301 	and.w	r3, r3, #1
 801682e:	b2db      	uxtb	r3, r3
 8016830:	2b00      	cmp	r3, #0
 8016832:	d010      	beq.n	8016856 <report_realtime_status+0x83e>
            hal.stream.write_all("|WCO:");
 8016834:	4b9d      	ldr	r3, [pc, #628]	; (8016aac <report_realtime_status+0xa94>)
 8016836:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801683a:	489d      	ldr	r0, [pc, #628]	; (8016ab0 <report_realtime_status+0xa98>)
 801683c:	4798      	blx	r3
            hal.stream.write_all(get_axis_values(wco));
 801683e:	4b9b      	ldr	r3, [pc, #620]	; (8016aac <report_realtime_status+0xa94>)
 8016840:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016844:	4b9b      	ldr	r3, [pc, #620]	; (8016ab4 <report_realtime_status+0xa9c>)
 8016846:	681b      	ldr	r3, [r3, #0]
 8016848:	f107 0218 	add.w	r2, r7, #24
 801684c:	4610      	mov	r0, r2
 801684e:	4798      	blx	r3
 8016850:	4603      	mov	r3, r0
 8016852:	4618      	mov	r0, r3
 8016854:	47a0      	blx	r4
        }

        if(report.gwco) {
 8016856:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801685a:	f003 0302 	and.w	r3, r3, #2
 801685e:	b2db      	uxtb	r3, r3
 8016860:	2b00      	cmp	r3, #0
 8016862:	d00f      	beq.n	8016884 <report_realtime_status+0x86c>
            hal.stream.write_all("|WCS:G");
 8016864:	4b91      	ldr	r3, [pc, #580]	; (8016aac <report_realtime_status+0xa94>)
 8016866:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801686a:	4893      	ldr	r0, [pc, #588]	; (8016ab8 <report_realtime_status+0xaa0>)
 801686c:	4798      	blx	r3
            hal.stream.write_all(map_coord_system(gc_state.modal.coord_system.id));
 801686e:	4b8f      	ldr	r3, [pc, #572]	; (8016aac <report_realtime_status+0xa94>)
 8016870:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016874:	4b8c      	ldr	r3, [pc, #560]	; (8016aa8 <report_realtime_status+0xa90>)
 8016876:	7d1b      	ldrb	r3, [r3, #20]
 8016878:	4618      	mov	r0, r3
 801687a:	f7fd fbc5 	bl	8014008 <map_coord_system>
 801687e:	4603      	mov	r3, r0
 8016880:	4618      	mov	r0, r3
 8016882:	47a0      	blx	r4
        }

        if(report.overrides) {
 8016884:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016888:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801688c:	b2db      	uxtb	r3, r3
 801688e:	2b00      	cmp	r3, #0
 8016890:	d033      	beq.n	80168fa <report_realtime_status+0x8e2>
            hal.stream.write_all(appendbuf(2, "|Ov:", uitoa((uint32_t)sys.override.feed_rate)));
 8016892:	4b86      	ldr	r3, [pc, #536]	; (8016aac <report_realtime_status+0xa94>)
 8016894:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016898:	4b88      	ldr	r3, [pc, #544]	; (8016abc <report_realtime_status+0xaa4>)
 801689a:	69db      	ldr	r3, [r3, #28]
 801689c:	4618      	mov	r0, r3
 801689e:	f7f9 fcf5 	bl	801028c <uitoa>
 80168a2:	4603      	mov	r3, r0
 80168a4:	461a      	mov	r2, r3
 80168a6:	4986      	ldr	r1, [pc, #536]	; (8016ac0 <report_realtime_status+0xaa8>)
 80168a8:	2002      	movs	r0, #2
 80168aa:	f7fd fb7f 	bl	8013fac <appendbuf>
 80168ae:	4603      	mov	r3, r0
 80168b0:	4618      	mov	r0, r3
 80168b2:	47a0      	blx	r4
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.rapid_rate)));
 80168b4:	4b7d      	ldr	r3, [pc, #500]	; (8016aac <report_realtime_status+0xa94>)
 80168b6:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80168ba:	4b80      	ldr	r3, [pc, #512]	; (8016abc <report_realtime_status+0xaa4>)
 80168bc:	6a1b      	ldr	r3, [r3, #32]
 80168be:	4618      	mov	r0, r3
 80168c0:	f7f9 fce4 	bl	801028c <uitoa>
 80168c4:	4603      	mov	r3, r0
 80168c6:	461a      	mov	r2, r3
 80168c8:	497e      	ldr	r1, [pc, #504]	; (8016ac4 <report_realtime_status+0xaac>)
 80168ca:	2002      	movs	r0, #2
 80168cc:	f7fd fb6e 	bl	8013fac <appendbuf>
 80168d0:	4603      	mov	r3, r0
 80168d2:	4618      	mov	r0, r3
 80168d4:	47a0      	blx	r4
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)spindle_0->param->override_pct)));
 80168d6:	4b75      	ldr	r3, [pc, #468]	; (8016aac <report_realtime_status+0xa94>)
 80168d8:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 80168dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80168de:	685b      	ldr	r3, [r3, #4]
 80168e0:	68db      	ldr	r3, [r3, #12]
 80168e2:	4618      	mov	r0, r3
 80168e4:	f7f9 fcd2 	bl	801028c <uitoa>
 80168e8:	4603      	mov	r3, r0
 80168ea:	461a      	mov	r2, r3
 80168ec:	4975      	ldr	r1, [pc, #468]	; (8016ac4 <report_realtime_status+0xaac>)
 80168ee:	2002      	movs	r0, #2
 80168f0:	f7fd fb5c 	bl	8013fac <appendbuf>
 80168f4:	4603      	mov	r3, r0
 80168f6:	4618      	mov	r0, r3
 80168f8:	47a0      	blx	r4
        }

        if(report.spindle || report.coolant || report.tool || gc_state.tool_change) {
 80168fa:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80168fe:	f003 0310 	and.w	r3, r3, #16
 8016902:	b2db      	uxtb	r3, r3
 8016904:	2b00      	cmp	r3, #0
 8016906:	d112      	bne.n	801692e <report_realtime_status+0x916>
 8016908:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801690c:	f003 0320 	and.w	r3, r3, #32
 8016910:	b2db      	uxtb	r3, r3
 8016912:	2b00      	cmp	r3, #0
 8016914:	d10b      	bne.n	801692e <report_realtime_status+0x916>
 8016916:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 801691a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801691e:	b2db      	uxtb	r3, r3
 8016920:	2b00      	cmp	r3, #0
 8016922:	d104      	bne.n	801692e <report_realtime_status+0x916>
 8016924:	4b60      	ldr	r3, [pc, #384]	; (8016aa8 <report_realtime_status+0xa90>)
 8016926:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801692a:	2b00      	cmp	r3, #0
 801692c:	d05f      	beq.n	80169ee <report_realtime_status+0x9d6>

            coolant_state_t cl_state = hal.coolant.get_state();
 801692e:	4b5f      	ldr	r3, [pc, #380]	; (8016aac <report_realtime_status+0xa94>)
 8016930:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016932:	4798      	blx	r3
 8016934:	4603      	mov	r3, r0
 8016936:	723b      	strb	r3, [r7, #8]

            char *append = &buf[3];
 8016938:	4b63      	ldr	r3, [pc, #396]	; (8016ac8 <report_realtime_status+0xab0>)
 801693a:	64fb      	str	r3, [r7, #76]	; 0x4c

            strcpy(buf, "|A:");
 801693c:	4b63      	ldr	r3, [pc, #396]	; (8016acc <report_realtime_status+0xab4>)
 801693e:	4a64      	ldr	r2, [pc, #400]	; (8016ad0 <report_realtime_status+0xab8>)
 8016940:	601a      	str	r2, [r3, #0]

            if (spindle_0_state.on)
 8016942:	7d3b      	ldrb	r3, [r7, #20]
 8016944:	f003 0301 	and.w	r3, r3, #1
 8016948:	b2db      	uxtb	r3, r3
 801694a:	2b00      	cmp	r3, #0
 801694c:	d00d      	beq.n	801696a <report_realtime_status+0x952>

                *append++ = spindle_0_state.ccw ? 'C' : 'S';
 801694e:	7d3b      	ldrb	r3, [r7, #20]
 8016950:	f003 0302 	and.w	r3, r3, #2
 8016954:	b2db      	uxtb	r3, r3
 8016956:	2b00      	cmp	r3, #0
 8016958:	d001      	beq.n	801695e <report_realtime_status+0x946>
 801695a:	2143      	movs	r1, #67	; 0x43
 801695c:	e000      	b.n	8016960 <report_realtime_status+0x948>
 801695e:	2153      	movs	r1, #83	; 0x53
 8016960:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016962:	1c5a      	adds	r2, r3, #1
 8016964:	64fa      	str	r2, [r7, #76]	; 0x4c
 8016966:	460a      	mov	r2, r1
 8016968:	701a      	strb	r2, [r3, #0]

#if COMPATIBILITY_LEVEL == 0
            if(spindle_0_state.encoder_error && hal.driver_cap.spindle_sync)
 801696a:	7d3b      	ldrb	r3, [r7, #20]
 801696c:	f003 0320 	and.w	r3, r3, #32
 8016970:	b2db      	uxtb	r3, r3
 8016972:	2b00      	cmp	r3, #0
 8016974:	d00c      	beq.n	8016990 <report_realtime_status+0x978>
 8016976:	4b4d      	ldr	r3, [pc, #308]	; (8016aac <report_realtime_status+0xa94>)
 8016978:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801697c:	f003 0302 	and.w	r3, r3, #2
 8016980:	b2db      	uxtb	r3, r3
 8016982:	2b00      	cmp	r3, #0
 8016984:	d004      	beq.n	8016990 <report_realtime_status+0x978>
                *append++ = 'E';
 8016986:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016988:	1c5a      	adds	r2, r3, #1
 801698a:	64fa      	str	r2, [r7, #76]	; 0x4c
 801698c:	2245      	movs	r2, #69	; 0x45
 801698e:	701a      	strb	r2, [r3, #0]
#endif

            if (cl_state.flood)
 8016990:	7a3b      	ldrb	r3, [r7, #8]
 8016992:	f003 0301 	and.w	r3, r3, #1
 8016996:	b2db      	uxtb	r3, r3
 8016998:	2b00      	cmp	r3, #0
 801699a:	d004      	beq.n	80169a6 <report_realtime_status+0x98e>
                *append++ = 'F';
 801699c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801699e:	1c5a      	adds	r2, r3, #1
 80169a0:	64fa      	str	r2, [r7, #76]	; 0x4c
 80169a2:	2246      	movs	r2, #70	; 0x46
 80169a4:	701a      	strb	r2, [r3, #0]

            if (cl_state.mist)
 80169a6:	7a3b      	ldrb	r3, [r7, #8]
 80169a8:	f003 0302 	and.w	r3, r3, #2
 80169ac:	b2db      	uxtb	r3, r3
 80169ae:	2b00      	cmp	r3, #0
 80169b0:	d004      	beq.n	80169bc <report_realtime_status+0x9a4>
                *append++ = 'M';
 80169b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169b4:	1c5a      	adds	r2, r3, #1
 80169b6:	64fa      	str	r2, [r7, #76]	; 0x4c
 80169b8:	224d      	movs	r2, #77	; 0x4d
 80169ba:	701a      	strb	r2, [r3, #0]

            if(gc_state.tool_change && !report.tool)
 80169bc:	4b3a      	ldr	r3, [pc, #232]	; (8016aa8 <report_realtime_status+0xa90>)
 80169be:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 80169c2:	2b00      	cmp	r3, #0
 80169c4:	d00b      	beq.n	80169de <report_realtime_status+0x9c6>
 80169c6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80169ca:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80169ce:	b2db      	uxtb	r3, r3
 80169d0:	2b00      	cmp	r3, #0
 80169d2:	d104      	bne.n	80169de <report_realtime_status+0x9c6>
                *append++ = 'T';
 80169d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169d6:	1c5a      	adds	r2, r3, #1
 80169d8:	64fa      	str	r2, [r7, #76]	; 0x4c
 80169da:	2254      	movs	r2, #84	; 0x54
 80169dc:	701a      	strb	r2, [r3, #0]

            *append = '\0';
 80169de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80169e0:	2200      	movs	r2, #0
 80169e2:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all(buf);
 80169e4:	4b31      	ldr	r3, [pc, #196]	; (8016aac <report_realtime_status+0xa94>)
 80169e6:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80169ea:	4838      	ldr	r0, [pc, #224]	; (8016acc <report_realtime_status+0xab4>)
 80169ec:	4798      	blx	r3
        }

        if(report.scaling) {
 80169ee:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80169f2:	f003 0302 	and.w	r3, r3, #2
 80169f6:	b2db      	uxtb	r3, r3
 80169f8:	2b00      	cmp	r3, #0
 80169fa:	d010      	beq.n	8016a1e <report_realtime_status+0xa06>
            axis_signals_tostring(buf, gc_get_g51_state());
 80169fc:	f7ee ffc2 	bl	8005984 <gc_get_g51_state>
 8016a00:	4603      	mov	r3, r0
 8016a02:	4619      	mov	r1, r3
 8016a04:	4831      	ldr	r0, [pc, #196]	; (8016acc <report_realtime_status+0xab4>)
 8016a06:	f7fd fc43 	bl	8014290 <axis_signals_tostring>
            hal.stream.write_all("|Sc:");
 8016a0a:	4b28      	ldr	r3, [pc, #160]	; (8016aac <report_realtime_status+0xa94>)
 8016a0c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016a10:	4830      	ldr	r0, [pc, #192]	; (8016ad4 <report_realtime_status+0xabc>)
 8016a12:	4798      	blx	r3
            hal.stream.write_all(buf);
 8016a14:	4b25      	ldr	r3, [pc, #148]	; (8016aac <report_realtime_status+0xa94>)
 8016a16:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016a1a:	482c      	ldr	r0, [pc, #176]	; (8016acc <report_realtime_status+0xab4>)
 8016a1c:	4798      	blx	r3
        }

#if COMPATIBILITY_LEVEL <= 1
        if((report.all || report.mpg_mode) && settings.report_interval) {
 8016a1e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8016a22:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016a26:	b2db      	uxtb	r3, r3
 8016a28:	2b00      	cmp	r3, #0
 8016a2a:	d106      	bne.n	8016a3a <report_realtime_status+0xa22>
 8016a2c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016a30:	f003 0301 	and.w	r3, r3, #1
 8016a34:	b2db      	uxtb	r3, r3
 8016a36:	2b00      	cmp	r3, #0
 8016a38:	d024      	beq.n	8016a84 <report_realtime_status+0xa6c>
 8016a3a:	4b27      	ldr	r3, [pc, #156]	; (8016ad8 <report_realtime_status+0xac0>)
 8016a3c:	8a9b      	ldrh	r3, [r3, #20]
 8016a3e:	2b00      	cmp	r3, #0
 8016a40:	d020      	beq.n	8016a84 <report_realtime_status+0xa6c>
            hal.stream.write_all(sys.flags.auto_reporting ? "|AR:" : "|AR");
 8016a42:	4b1a      	ldr	r3, [pc, #104]	; (8016aac <report_realtime_status+0xa94>)
 8016a44:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016a48:	4a1c      	ldr	r2, [pc, #112]	; (8016abc <report_realtime_status+0xaa4>)
 8016a4a:	7dd2      	ldrb	r2, [r2, #23]
 8016a4c:	f002 0202 	and.w	r2, r2, #2
 8016a50:	b2d2      	uxtb	r2, r2
 8016a52:	2a00      	cmp	r2, #0
 8016a54:	d001      	beq.n	8016a5a <report_realtime_status+0xa42>
 8016a56:	4a21      	ldr	r2, [pc, #132]	; (8016adc <report_realtime_status+0xac4>)
 8016a58:	e000      	b.n	8016a5c <report_realtime_status+0xa44>
 8016a5a:	4a21      	ldr	r2, [pc, #132]	; (8016ae0 <report_realtime_status+0xac8>)
 8016a5c:	4610      	mov	r0, r2
 8016a5e:	4798      	blx	r3
            if(sys.flags.auto_reporting)
 8016a60:	4b16      	ldr	r3, [pc, #88]	; (8016abc <report_realtime_status+0xaa4>)
 8016a62:	7ddb      	ldrb	r3, [r3, #23]
 8016a64:	f003 0302 	and.w	r3, r3, #2
 8016a68:	b2db      	uxtb	r3, r3
 8016a6a:	2b00      	cmp	r3, #0
 8016a6c:	d00a      	beq.n	8016a84 <report_realtime_status+0xa6c>
                hal.stream.write_all(uitoa(settings.report_interval));
 8016a6e:	4b0f      	ldr	r3, [pc, #60]	; (8016aac <report_realtime_status+0xa94>)
 8016a70:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016a74:	4b18      	ldr	r3, [pc, #96]	; (8016ad8 <report_realtime_status+0xac0>)
 8016a76:	8a9b      	ldrh	r3, [r3, #20]
 8016a78:	4618      	mov	r0, r3
 8016a7a:	f7f9 fc07 	bl	801028c <uitoa>
 8016a7e:	4603      	mov	r3, r0
 8016a80:	4618      	mov	r0, r3
 8016a82:	47a0      	blx	r4
        }
#endif

        if(report.mpg_mode)
 8016a84:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016a88:	f003 0301 	and.w	r3, r3, #1
 8016a8c:	b2db      	uxtb	r3, r3
 8016a8e:	2b00      	cmp	r3, #0
 8016a90:	d02d      	beq.n	8016aee <report_realtime_status+0xad6>
            hal.stream.write_all(sys.mpg_mode ? "|MPG:1" : "|MPG:0");
 8016a92:	4b06      	ldr	r3, [pc, #24]	; (8016aac <report_realtime_status+0xa94>)
 8016a94:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016a98:	4a08      	ldr	r2, [pc, #32]	; (8016abc <report_realtime_status+0xaa4>)
 8016a9a:	f892 207f 	ldrb.w	r2, [r2, #127]	; 0x7f
 8016a9e:	2a00      	cmp	r2, #0
 8016aa0:	d022      	beq.n	8016ae8 <report_realtime_status+0xad0>
 8016aa2:	4a10      	ldr	r2, [pc, #64]	; (8016ae4 <report_realtime_status+0xacc>)
 8016aa4:	e021      	b.n	8016aea <report_realtime_status+0xad2>
 8016aa6:	bf00      	nop
 8016aa8:	20000bb0 	.word	0x20000bb0
 8016aac:	20000ed0 	.word	0x20000ed0
 8016ab0:	0802b5ec 	.word	0x0802b5ec
 8016ab4:	20001434 	.word	0x20001434
 8016ab8:	0802b5f4 	.word	0x0802b5f4
 8016abc:	20000d3c 	.word	0x20000d3c
 8016ac0:	0802b5fc 	.word	0x0802b5fc
 8016ac4:	0802b184 	.word	0x0802b184
 8016ac8:	20001407 	.word	0x20001407
 8016acc:	20001404 	.word	0x20001404
 8016ad0:	003a417c 	.word	0x003a417c
 8016ad4:	0802b604 	.word	0x0802b604
 8016ad8:	2000147c 	.word	0x2000147c
 8016adc:	0802b60c 	.word	0x0802b60c
 8016ae0:	0802b614 	.word	0x0802b614
 8016ae4:	0802b618 	.word	0x0802b618
 8016ae8:	4a9a      	ldr	r2, [pc, #616]	; (8016d54 <report_realtime_status+0xd3c>)
 8016aea:	4610      	mov	r0, r2
 8016aec:	4798      	blx	r3

        if(report.homed && (sys.homing.mask || settings.homing.flags.single_axis_commands || settings.homing.flags.manual)) {
 8016aee:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016af2:	f003 0304 	and.w	r3, r3, #4
 8016af6:	b2db      	uxtb	r3, r3
 8016af8:	2b00      	cmp	r3, #0
 8016afa:	d04d      	beq.n	8016b98 <report_realtime_status+0xb80>
 8016afc:	4b96      	ldr	r3, [pc, #600]	; (8016d58 <report_realtime_status+0xd40>)
 8016afe:	7e9b      	ldrb	r3, [r3, #26]
 8016b00:	2b00      	cmp	r3, #0
 8016b02:	d10f      	bne.n	8016b24 <report_realtime_status+0xb0c>
 8016b04:	4b95      	ldr	r3, [pc, #596]	; (8016d5c <report_realtime_status+0xd44>)
 8016b06:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8016b0a:	f003 0302 	and.w	r3, r3, #2
 8016b0e:	b2db      	uxtb	r3, r3
 8016b10:	2b00      	cmp	r3, #0
 8016b12:	d107      	bne.n	8016b24 <report_realtime_status+0xb0c>
 8016b14:	4b91      	ldr	r3, [pc, #580]	; (8016d5c <report_realtime_status+0xd44>)
 8016b16:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8016b1a:	f003 0310 	and.w	r3, r3, #16
 8016b1e:	b2db      	uxtb	r3, r3
 8016b20:	2b00      	cmp	r3, #0
 8016b22:	d039      	beq.n	8016b98 <report_realtime_status+0xb80>
            axes_signals_t homing = {sys.homing.mask ? sys.homing.mask : AXES_BITMASK};
 8016b24:	4b8c      	ldr	r3, [pc, #560]	; (8016d58 <report_realtime_status+0xd40>)
 8016b26:	7e9b      	ldrb	r3, [r3, #26]
 8016b28:	2b00      	cmp	r3, #0
 8016b2a:	d002      	beq.n	8016b32 <report_realtime_status+0xb1a>
 8016b2c:	4b8a      	ldr	r3, [pc, #552]	; (8016d58 <report_realtime_status+0xd40>)
 8016b2e:	7e9b      	ldrb	r3, [r3, #26]
 8016b30:	e000      	b.n	8016b34 <report_realtime_status+0xb1c>
 8016b32:	2307      	movs	r3, #7
 8016b34:	713b      	strb	r3, [r7, #4]
            hal.stream.write_all(appendbuf(2, "|H:", (homing.mask & sys.homed.mask) == homing.mask ? "1" : "0"));
 8016b36:	4b8a      	ldr	r3, [pc, #552]	; (8016d60 <report_realtime_status+0xd48>)
 8016b38:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016b3c:	793a      	ldrb	r2, [r7, #4]
 8016b3e:	4b86      	ldr	r3, [pc, #536]	; (8016d58 <report_realtime_status+0xd40>)
 8016b40:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8016b44:	4013      	ands	r3, r2
 8016b46:	b2da      	uxtb	r2, r3
 8016b48:	793b      	ldrb	r3, [r7, #4]
 8016b4a:	429a      	cmp	r2, r3
 8016b4c:	d101      	bne.n	8016b52 <report_realtime_status+0xb3a>
 8016b4e:	4b85      	ldr	r3, [pc, #532]	; (8016d64 <report_realtime_status+0xd4c>)
 8016b50:	e000      	b.n	8016b54 <report_realtime_status+0xb3c>
 8016b52:	4b85      	ldr	r3, [pc, #532]	; (8016d68 <report_realtime_status+0xd50>)
 8016b54:	461a      	mov	r2, r3
 8016b56:	4985      	ldr	r1, [pc, #532]	; (8016d6c <report_realtime_status+0xd54>)
 8016b58:	2002      	movs	r0, #2
 8016b5a:	f7fd fa27 	bl	8013fac <appendbuf>
 8016b5e:	4603      	mov	r3, r0
 8016b60:	4618      	mov	r0, r3
 8016b62:	47a0      	blx	r4
            if(settings.homing.flags.single_axis_commands)
 8016b64:	4b7d      	ldr	r3, [pc, #500]	; (8016d5c <report_realtime_status+0xd44>)
 8016b66:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8016b6a:	f003 0302 	and.w	r3, r3, #2
 8016b6e:	b2db      	uxtb	r3, r3
 8016b70:	2b00      	cmp	r3, #0
 8016b72:	d011      	beq.n	8016b98 <report_realtime_status+0xb80>
                hal.stream.write_all(appendbuf(2, ",", uitoa(sys.homed.mask)));
 8016b74:	4b7a      	ldr	r3, [pc, #488]	; (8016d60 <report_realtime_status+0xd48>)
 8016b76:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016b7a:	4b77      	ldr	r3, [pc, #476]	; (8016d58 <report_realtime_status+0xd40>)
 8016b7c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8016b80:	4618      	mov	r0, r3
 8016b82:	f7f9 fb83 	bl	801028c <uitoa>
 8016b86:	4603      	mov	r3, r0
 8016b88:	461a      	mov	r2, r3
 8016b8a:	4979      	ldr	r1, [pc, #484]	; (8016d70 <report_realtime_status+0xd58>)
 8016b8c:	2002      	movs	r0, #2
 8016b8e:	f7fd fa0d 	bl	8013fac <appendbuf>
 8016b92:	4603      	mov	r3, r0
 8016b94:	4618      	mov	r0, r3
 8016b96:	47a0      	blx	r4
        }

        if(report.xmode && settings.mode == Mode_Lathe)
 8016b98:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016b9c:	f003 0308 	and.w	r3, r3, #8
 8016ba0:	b2db      	uxtb	r3, r3
 8016ba2:	2b00      	cmp	r3, #0
 8016ba4:	d00f      	beq.n	8016bc6 <report_realtime_status+0xbae>
 8016ba6:	4b6d      	ldr	r3, [pc, #436]	; (8016d5c <report_realtime_status+0xd44>)
 8016ba8:	7e1b      	ldrb	r3, [r3, #24]
 8016baa:	2b02      	cmp	r3, #2
 8016bac:	d10b      	bne.n	8016bc6 <report_realtime_status+0xbae>
            hal.stream.write_all(gc_state.modal.diameter_mode ? "|D:1" : "|D:0");
 8016bae:	4b6c      	ldr	r3, [pc, #432]	; (8016d60 <report_realtime_status+0xd48>)
 8016bb0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016bb4:	4a6f      	ldr	r2, [pc, #444]	; (8016d74 <report_realtime_status+0xd5c>)
 8016bb6:	7952      	ldrb	r2, [r2, #5]
 8016bb8:	2a00      	cmp	r2, #0
 8016bba:	d001      	beq.n	8016bc0 <report_realtime_status+0xba8>
 8016bbc:	4a6e      	ldr	r2, [pc, #440]	; (8016d78 <report_realtime_status+0xd60>)
 8016bbe:	e000      	b.n	8016bc2 <report_realtime_status+0xbaa>
 8016bc0:	4a6e      	ldr	r2, [pc, #440]	; (8016d7c <report_realtime_status+0xd64>)
 8016bc2:	4610      	mov	r0, r2
 8016bc4:	4798      	blx	r3

        if(report.tool)
 8016bc6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8016bca:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016bce:	b2db      	uxtb	r3, r3
 8016bd0:	2b00      	cmp	r3, #0
 8016bd2:	d012      	beq.n	8016bfa <report_realtime_status+0xbe2>
            hal.stream.write_all(appendbuf(2, "|T:", uitoa((uint32_t)gc_state.tool->tool_id)));
 8016bd4:	4b62      	ldr	r3, [pc, #392]	; (8016d60 <report_realtime_status+0xd48>)
 8016bd6:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016bda:	4b66      	ldr	r3, [pc, #408]	; (8016d74 <report_realtime_status+0xd5c>)
 8016bdc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8016be0:	691b      	ldr	r3, [r3, #16]
 8016be2:	4618      	mov	r0, r3
 8016be4:	f7f9 fb52 	bl	801028c <uitoa>
 8016be8:	4603      	mov	r3, r0
 8016bea:	461a      	mov	r2, r3
 8016bec:	4964      	ldr	r1, [pc, #400]	; (8016d80 <report_realtime_status+0xd68>)
 8016bee:	2002      	movs	r0, #2
 8016bf0:	f7fd f9dc 	bl	8013fac <appendbuf>
 8016bf4:	4603      	mov	r3, r0
 8016bf6:	4618      	mov	r0, r3
 8016bf8:	47a0      	blx	r4

        if(report.tlo_reference)
 8016bfa:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016bfe:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016c02:	b2db      	uxtb	r3, r3
 8016c04:	2b00      	cmp	r3, #0
 8016c06:	d015      	beq.n	8016c34 <report_realtime_status+0xc1c>
            hal.stream.write_all(appendbuf(2, "|TLR:", uitoa(sys.tlo_reference_set.mask != 0)));
 8016c08:	4b55      	ldr	r3, [pc, #340]	; (8016d60 <report_realtime_status+0xd48>)
 8016c0a:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016c0e:	4b52      	ldr	r3, [pc, #328]	; (8016d58 <report_realtime_status+0xd40>)
 8016c10:	79db      	ldrb	r3, [r3, #7]
 8016c12:	2b00      	cmp	r3, #0
 8016c14:	bf14      	ite	ne
 8016c16:	2301      	movne	r3, #1
 8016c18:	2300      	moveq	r3, #0
 8016c1a:	b2db      	uxtb	r3, r3
 8016c1c:	4618      	mov	r0, r3
 8016c1e:	f7f9 fb35 	bl	801028c <uitoa>
 8016c22:	4603      	mov	r3, r0
 8016c24:	461a      	mov	r2, r3
 8016c26:	4957      	ldr	r1, [pc, #348]	; (8016d84 <report_realtime_status+0xd6c>)
 8016c28:	2002      	movs	r0, #2
 8016c2a:	f7fd f9bf 	bl	8013fac <appendbuf>
 8016c2e:	4603      	mov	r3, r0
 8016c30:	4618      	mov	r0, r3
 8016c32:	47a0      	blx	r4

        if(report.m66result && sys.var5399 > -2) { // M66 result
 8016c34:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016c38:	f003 0308 	and.w	r3, r3, #8
 8016c3c:	b2db      	uxtb	r3, r3
 8016c3e:	2b00      	cmp	r3, #0
 8016c40:	d01f      	beq.n	8016c82 <report_realtime_status+0xc6a>
 8016c42:	4b45      	ldr	r3, [pc, #276]	; (8016d58 <report_realtime_status+0xd40>)
 8016c44:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016c46:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016c4a:	db1a      	blt.n	8016c82 <report_realtime_status+0xc6a>
            if(sys.var5399 >= 0)
 8016c4c:	4b42      	ldr	r3, [pc, #264]	; (8016d58 <report_realtime_status+0xd40>)
 8016c4e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016c50:	2b00      	cmp	r3, #0
 8016c52:	db11      	blt.n	8016c78 <report_realtime_status+0xc60>
                hal.stream.write_all(appendbuf(2, "|In:", uitoa(sys.var5399)));
 8016c54:	4b42      	ldr	r3, [pc, #264]	; (8016d60 <report_realtime_status+0xd48>)
 8016c56:	f8d3 40b8 	ldr.w	r4, [r3, #184]	; 0xb8
 8016c5a:	4b3f      	ldr	r3, [pc, #252]	; (8016d58 <report_realtime_status+0xd40>)
 8016c5c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8016c5e:	4618      	mov	r0, r3
 8016c60:	f7f9 fb14 	bl	801028c <uitoa>
 8016c64:	4603      	mov	r3, r0
 8016c66:	461a      	mov	r2, r3
 8016c68:	4947      	ldr	r1, [pc, #284]	; (8016d88 <report_realtime_status+0xd70>)
 8016c6a:	2002      	movs	r0, #2
 8016c6c:	f7fd f99e 	bl	8013fac <appendbuf>
 8016c70:	4603      	mov	r3, r0
 8016c72:	4618      	mov	r0, r3
 8016c74:	47a0      	blx	r4
 8016c76:	e004      	b.n	8016c82 <report_realtime_status+0xc6a>
            else
                hal.stream.write_all("|In:-1");
 8016c78:	4b39      	ldr	r3, [pc, #228]	; (8016d60 <report_realtime_status+0xd48>)
 8016c7a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016c7e:	4843      	ldr	r0, [pc, #268]	; (8016d8c <report_realtime_status+0xd74>)
 8016c80:	4798      	blx	r3
        }
    }

    if(grbl.on_realtime_report)
 8016c82:	4b43      	ldr	r3, [pc, #268]	; (8016d90 <report_realtime_status+0xd78>)
 8016c84:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016c86:	2b00      	cmp	r3, #0
 8016c88:	d008      	beq.n	8016c9c <report_realtime_status+0xc84>
        grbl.on_realtime_report(hal.stream.write_all, sys.report);
 8016c8a:	4b41      	ldr	r3, [pc, #260]	; (8016d90 <report_realtime_status+0xd78>)
 8016c8c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016c8e:	4a34      	ldr	r2, [pc, #208]	; (8016d60 <report_realtime_status+0xd48>)
 8016c90:	f8d2 20b8 	ldr.w	r2, [r2, #184]	; 0xb8
 8016c94:	4930      	ldr	r1, [pc, #192]	; (8016d58 <report_realtime_status+0xd40>)
 8016c96:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8016c98:	4610      	mov	r0, r2
 8016c9a:	4798      	blx	r3

#if COMPATIBILITY_LEVEL <= 1
    if(report.all) {
 8016c9c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8016ca0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8016ca4:	b2db      	uxtb	r3, r3
 8016ca6:	2b00      	cmp	r3, #0
 8016ca8:	d00f      	beq.n	8016cca <report_realtime_status+0xcb2>
        hal.stream.write_all("|FW:grblHAL");
 8016caa:	4b2d      	ldr	r3, [pc, #180]	; (8016d60 <report_realtime_status+0xd48>)
 8016cac:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016cb0:	4838      	ldr	r0, [pc, #224]	; (8016d94 <report_realtime_status+0xd7c>)
 8016cb2:	4798      	blx	r3
        if(sys.blocking_event)
 8016cb4:	4b28      	ldr	r3, [pc, #160]	; (8016d58 <report_realtime_status+0xd40>)
 8016cb6:	795b      	ldrb	r3, [r3, #5]
 8016cb8:	2b00      	cmp	r3, #0
 8016cba:	f000 80c3 	beq.w	8016e44 <report_realtime_status+0xe2c>
            hal.stream.write_all("|$C:1");
 8016cbe:	4b28      	ldr	r3, [pc, #160]	; (8016d60 <report_realtime_status+0xd48>)
 8016cc0:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016cc4:	4834      	ldr	r0, [pc, #208]	; (8016d98 <report_realtime_status+0xd80>)
 8016cc6:	4798      	blx	r3
 8016cc8:	e0bc      	b.n	8016e44 <report_realtime_status+0xe2c>
    } else
#endif

    if(settings.status_report.parser_state) {
 8016cca:	4b24      	ldr	r3, [pc, #144]	; (8016d5c <report_realtime_status+0xd44>)
 8016ccc:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8016cd0:	f003 0302 	and.w	r3, r3, #2
 8016cd4:	b2db      	uxtb	r3, r3
 8016cd6:	2b00      	cmp	r3, #0
 8016cd8:	f000 80b4 	beq.w	8016e44 <report_realtime_status+0xe2c>
        static tool_id_t tool_id;
        static float feed_rate, spindle_rpm;
        static gc_modal_t last_state;
        static bool g92_active;

        bool is_changed = feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool_id != gc_state.tool->tool_id;
 8016cdc:	4b25      	ldr	r3, [pc, #148]	; (8016d74 <report_realtime_status+0xd5c>)
 8016cde:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016ce0:	4a2e      	ldr	r2, [pc, #184]	; (8016d9c <report_realtime_status+0xd84>)
 8016ce2:	6812      	ldr	r2, [r2, #0]
 8016ce4:	4611      	mov	r1, r2
 8016ce6:	4618      	mov	r0, r3
 8016ce8:	f7ea f9f8 	bl	80010dc <__aeabi_fcmpeq>
 8016cec:	4603      	mov	r3, r0
 8016cee:	2b00      	cmp	r3, #0
 8016cf0:	d012      	beq.n	8016d18 <report_realtime_status+0xd00>
 8016cf2:	4b20      	ldr	r3, [pc, #128]	; (8016d74 <report_realtime_status+0xd5c>)
 8016cf4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016cf6:	4a2a      	ldr	r2, [pc, #168]	; (8016da0 <report_realtime_status+0xd88>)
 8016cf8:	6812      	ldr	r2, [r2, #0]
 8016cfa:	4611      	mov	r1, r2
 8016cfc:	4618      	mov	r0, r3
 8016cfe:	f7ea f9ed 	bl	80010dc <__aeabi_fcmpeq>
 8016d02:	4603      	mov	r3, r0
 8016d04:	2b00      	cmp	r3, #0
 8016d06:	d007      	beq.n	8016d18 <report_realtime_status+0xd00>
 8016d08:	4b1a      	ldr	r3, [pc, #104]	; (8016d74 <report_realtime_status+0xd5c>)
 8016d0a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8016d0e:	691a      	ldr	r2, [r3, #16]
 8016d10:	4b24      	ldr	r3, [pc, #144]	; (8016da4 <report_realtime_status+0xd8c>)
 8016d12:	681b      	ldr	r3, [r3, #0]
 8016d14:	429a      	cmp	r2, r3
 8016d16:	d001      	beq.n	8016d1c <report_realtime_status+0xd04>
 8016d18:	2301      	movs	r3, #1
 8016d1a:	e000      	b.n	8016d1e <report_realtime_status+0xd06>
 8016d1c:	2300      	movs	r3, #0
 8016d1e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8016d22:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8016d26:	f003 0301 	and.w	r3, r3, #1
 8016d2a:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b

        if(is_changed) {
 8016d2e:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8016d32:	2b00      	cmp	r3, #0
 8016d34:	d038      	beq.n	8016da8 <report_realtime_status+0xd90>
            feed_rate = gc_state.feed_rate;
 8016d36:	4b0f      	ldr	r3, [pc, #60]	; (8016d74 <report_realtime_status+0xd5c>)
 8016d38:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8016d3a:	4a18      	ldr	r2, [pc, #96]	; (8016d9c <report_realtime_status+0xd84>)
 8016d3c:	6013      	str	r3, [r2, #0]
            tool_id = gc_state.tool->tool_id;
 8016d3e:	4b0d      	ldr	r3, [pc, #52]	; (8016d74 <report_realtime_status+0xd5c>)
 8016d40:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8016d44:	691b      	ldr	r3, [r3, #16]
 8016d46:	4a17      	ldr	r2, [pc, #92]	; (8016da4 <report_realtime_status+0xd8c>)
 8016d48:	6013      	str	r3, [r2, #0]
            spindle_rpm = gc_state.spindle.rpm;
 8016d4a:	4b0a      	ldr	r3, [pc, #40]	; (8016d74 <report_realtime_status+0xd5c>)
 8016d4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8016d4e:	4a14      	ldr	r2, [pc, #80]	; (8016da0 <report_realtime_status+0xd88>)
 8016d50:	6013      	str	r3, [r2, #0]
 8016d52:	e060      	b.n	8016e16 <report_realtime_status+0xdfe>
 8016d54:	0802b620 	.word	0x0802b620
 8016d58:	20000d3c 	.word	0x20000d3c
 8016d5c:	2000147c 	.word	0x2000147c
 8016d60:	20000ed0 	.word	0x20000ed0
 8016d64:	0802b628 	.word	0x0802b628
 8016d68:	0802b62c 	.word	0x0802b62c
 8016d6c:	0802b630 	.word	0x0802b630
 8016d70:	0802b184 	.word	0x0802b184
 8016d74:	20000bb0 	.word	0x20000bb0
 8016d78:	0802b634 	.word	0x0802b634
 8016d7c:	0802b63c 	.word	0x0802b63c
 8016d80:	0802b644 	.word	0x0802b644
 8016d84:	0802b648 	.word	0x0802b648
 8016d88:	0802b650 	.word	0x0802b650
 8016d8c:	0802b658 	.word	0x0802b658
 8016d90:	20000dd4 	.word	0x20000dd4
 8016d94:	0802b660 	.word	0x0802b660
 8016d98:	0802b66c 	.word	0x0802b66c
 8016d9c:	20001444 	.word	0x20001444
 8016da0:	20001448 	.word	0x20001448
 8016da4:	2000144c 	.word	0x2000144c
        } else if ((is_changed = g92_active != is_g92_active()))
 8016da8:	f7fe f958 	bl	801505c <is_g92_active>
 8016dac:	4603      	mov	r3, r0
 8016dae:	461a      	mov	r2, r3
 8016db0:	4b32      	ldr	r3, [pc, #200]	; (8016e7c <report_realtime_status+0xe64>)
 8016db2:	781b      	ldrb	r3, [r3, #0]
 8016db4:	429a      	cmp	r2, r3
 8016db6:	bf14      	ite	ne
 8016db8:	2301      	movne	r3, #1
 8016dba:	2300      	moveq	r3, #0
 8016dbc:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8016dc0:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8016dc4:	2b00      	cmp	r3, #0
 8016dc6:	d00f      	beq.n	8016de8 <report_realtime_status+0xdd0>
            g92_active = !g92_active;
 8016dc8:	4b2c      	ldr	r3, [pc, #176]	; (8016e7c <report_realtime_status+0xe64>)
 8016dca:	781b      	ldrb	r3, [r3, #0]
 8016dcc:	2b00      	cmp	r3, #0
 8016dce:	bf14      	ite	ne
 8016dd0:	2301      	movne	r3, #1
 8016dd2:	2300      	moveq	r3, #0
 8016dd4:	b2db      	uxtb	r3, r3
 8016dd6:	f083 0301 	eor.w	r3, r3, #1
 8016dda:	b2db      	uxtb	r3, r3
 8016ddc:	f003 0301 	and.w	r3, r3, #1
 8016de0:	b2da      	uxtb	r2, r3
 8016de2:	4b26      	ldr	r3, [pc, #152]	; (8016e7c <report_realtime_status+0xe64>)
 8016de4:	701a      	strb	r2, [r3, #0]
 8016de6:	e016      	b.n	8016e16 <report_realtime_status+0xdfe>
        else if(memcmp(&last_state, &gc_state.modal, sizeof(gc_modal_t))) {
 8016de8:	2228      	movs	r2, #40	; 0x28
 8016dea:	4925      	ldr	r1, [pc, #148]	; (8016e80 <report_realtime_status+0xe68>)
 8016dec:	4825      	ldr	r0, [pc, #148]	; (8016e84 <report_realtime_status+0xe6c>)
 8016dee:	f00c ff02 	bl	8023bf6 <memcmp>
 8016df2:	4603      	mov	r3, r0
 8016df4:	2b00      	cmp	r3, #0
 8016df6:	d00e      	beq.n	8016e16 <report_realtime_status+0xdfe>
            last_state = gc_state.modal;
 8016df8:	4a22      	ldr	r2, [pc, #136]	; (8016e84 <report_realtime_status+0xe6c>)
 8016dfa:	4b21      	ldr	r3, [pc, #132]	; (8016e80 <report_realtime_status+0xe68>)
 8016dfc:	4614      	mov	r4, r2
 8016dfe:	461d      	mov	r5, r3
 8016e00:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016e02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016e04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016e06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8016e08:	e895 0003 	ldmia.w	r5, {r0, r1}
 8016e0c:	e884 0003 	stmia.w	r4, {r0, r1}
            is_changed = true;
 8016e10:	2301      	movs	r3, #1
 8016e12:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
        }

        if (is_changed)
 8016e16:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8016e1a:	2b00      	cmp	r3, #0
 8016e1c:	d005      	beq.n	8016e2a <report_realtime_status+0xe12>
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 8016e1e:	4b1a      	ldr	r3, [pc, #104]	; (8016e88 <report_realtime_status+0xe70>)
 8016e20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8016e22:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8016e26:	4819      	ldr	r0, [pc, #100]	; (8016e8c <report_realtime_status+0xe74>)
 8016e28:	4798      	blx	r3

        if(report.tool_offset)
 8016e2a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016e2e:	f003 0304 	and.w	r3, r3, #4
 8016e32:	b2db      	uxtb	r3, r3
 8016e34:	2b00      	cmp	r3, #0
 8016e36:	d005      	beq.n	8016e44 <report_realtime_status+0xe2c>
            system_set_exec_state_flag(EXEC_TLO_REPORT);
 8016e38:	4b13      	ldr	r3, [pc, #76]	; (8016e88 <report_realtime_status+0xe70>)
 8016e3a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8016e3c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8016e40:	4812      	ldr	r0, [pc, #72]	; (8016e8c <report_realtime_status+0xe74>)
 8016e42:	4798      	blx	r3
    }

    hal.stream.write_all(">" ASCII_EOL);
 8016e44:	4b10      	ldr	r3, [pc, #64]	; (8016e88 <report_realtime_status+0xe70>)
 8016e46:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8016e4a:	4811      	ldr	r0, [pc, #68]	; (8016e90 <report_realtime_status+0xe78>)
 8016e4c:	4798      	blx	r3

    system_add_rt_report(Report_ClearAll);
 8016e4e:	2000      	movs	r0, #0
 8016e50:	f00b f8a4 	bl	8021f9c <system_add_rt_report>
    if(settings.status_report.work_coord_offset && wco_counter == 0)
 8016e54:	4b0f      	ldr	r3, [pc, #60]	; (8016e94 <report_realtime_status+0xe7c>)
 8016e56:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8016e5a:	f003 0320 	and.w	r3, r3, #32
 8016e5e:	b2db      	uxtb	r3, r3
 8016e60:	2b00      	cmp	r3, #0
 8016e62:	d007      	beq.n	8016e74 <report_realtime_status+0xe5c>
 8016e64:	4b0c      	ldr	r3, [pc, #48]	; (8016e98 <report_realtime_status+0xe80>)
 8016e66:	781b      	ldrb	r3, [r3, #0]
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d103      	bne.n	8016e74 <report_realtime_status+0xe5c>
        system_add_rt_report(Report_WCO); // Set to report on next request
 8016e6c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8016e70:	f00b f894 	bl	8021f9c <system_add_rt_report>
}
 8016e74:	bf00      	nop
 8016e76:	3758      	adds	r7, #88	; 0x58
 8016e78:	46bd      	mov	sp, r7
 8016e7a:	bdb0      	pop	{r4, r5, r7, pc}
 8016e7c:	20001450 	.word	0x20001450
 8016e80:	20000bb0 	.word	0x20000bb0
 8016e84:	20001454 	.word	0x20001454
 8016e88:	20000ed0 	.word	0x20000ed0
 8016e8c:	20000d84 	.word	0x20000d84
 8016e90:	0802b674 	.word	0x0802b674
 8016e94:	2000147c 	.word	0x2000147c
 8016e98:	20001441 	.word	0x20001441

08016e9c <report_bitfield>:

static void report_bitfield (const char *format, bool bitmap)
{
 8016e9c:	b590      	push	{r4, r7, lr}
 8016e9e:	b087      	sub	sp, #28
 8016ea0:	af00      	add	r7, sp, #0
 8016ea2:	6078      	str	r0, [r7, #4]
 8016ea4:	460b      	mov	r3, r1
 8016ea6:	70fb      	strb	r3, [r7, #3]
    char *s;
    uint_fast8_t bit = 0;
 8016ea8:	2300      	movs	r3, #0
 8016eaa:	617b      	str	r3, [r7, #20]
    uint_fast16_t val = 1;
 8016eac:	2301      	movs	r3, #1
 8016eae:	613b      	str	r3, [r7, #16]

    // Copy string from Flash to RAM, strtok cannot be used unless doing so.
    if((s = (char *)malloc(strlen(format) + 1))) {
 8016eb0:	6878      	ldr	r0, [r7, #4]
 8016eb2:	f7e9 f9c3 	bl	800023c <strlen>
 8016eb6:	4603      	mov	r3, r0
 8016eb8:	3301      	adds	r3, #1
 8016eba:	4618      	mov	r0, r3
 8016ebc:	f00c fafc 	bl	80234b8 <malloc>
 8016ec0:	4603      	mov	r3, r0
 8016ec2:	60bb      	str	r3, [r7, #8]
 8016ec4:	68bb      	ldr	r3, [r7, #8]
 8016ec6:	2b00      	cmp	r3, #0
 8016ec8:	d058      	beq.n	8016f7c <report_bitfield+0xe0>

        strcpy(s, format);
 8016eca:	6879      	ldr	r1, [r7, #4]
 8016ecc:	68b8      	ldr	r0, [r7, #8]
 8016ece:	f00c fff6 	bl	8023ebe <strcpy>
        char *element = strtok(s, ",");
 8016ed2:	492c      	ldr	r1, [pc, #176]	; (8016f84 <report_bitfield+0xe8>)
 8016ed4:	68b8      	ldr	r0, [r7, #8]
 8016ed6:	f00c fefd 	bl	8023cd4 <strtok>
 8016eda:	60f8      	str	r0, [r7, #12]

        while(element) {
 8016edc:	e048      	b.n	8016f70 <report_bitfield+0xd4>
            if(strcmp(element, "N/A")) {
 8016ede:	492a      	ldr	r1, [pc, #168]	; (8016f88 <report_bitfield+0xec>)
 8016ee0:	68f8      	ldr	r0, [r7, #12]
 8016ee2:	f7e9 f9a1 	bl	8000228 <strcmp>
 8016ee6:	4603      	mov	r3, r0
 8016ee8:	2b00      	cmp	r3, #0
 8016eea:	d036      	beq.n	8016f5a <report_bitfield+0xbe>
                hal.stream.write(ASCII_EOL);
 8016eec:	4b27      	ldr	r3, [pc, #156]	; (8016f8c <report_bitfield+0xf0>)
 8016eee:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016ef2:	4827      	ldr	r0, [pc, #156]	; (8016f90 <report_bitfield+0xf4>)
 8016ef4:	4798      	blx	r3
                hal.stream.write("    ");
 8016ef6:	4b25      	ldr	r3, [pc, #148]	; (8016f8c <report_bitfield+0xf0>)
 8016ef8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016efc:	4825      	ldr	r0, [pc, #148]	; (8016f94 <report_bitfield+0xf8>)
 8016efe:	4798      	blx	r3
                hal.stream.write(uitoa(bit));
 8016f00:	4b22      	ldr	r3, [pc, #136]	; (8016f8c <report_bitfield+0xf0>)
 8016f02:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8016f06:	6978      	ldr	r0, [r7, #20]
 8016f08:	f7f9 f9c0 	bl	801028c <uitoa>
 8016f0c:	4603      	mov	r3, r0
 8016f0e:	4618      	mov	r0, r3
 8016f10:	47a0      	blx	r4
                hal.stream.write(" - ");
 8016f12:	4b1e      	ldr	r3, [pc, #120]	; (8016f8c <report_bitfield+0xf0>)
 8016f14:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016f18:	481f      	ldr	r0, [pc, #124]	; (8016f98 <report_bitfield+0xfc>)
 8016f1a:	4798      	blx	r3
                if(*element)
 8016f1c:	68fb      	ldr	r3, [r7, #12]
 8016f1e:	781b      	ldrb	r3, [r3, #0]
 8016f20:	2b00      	cmp	r3, #0
 8016f22:	d004      	beq.n	8016f2e <report_bitfield+0x92>
                hal.stream.write(element);
 8016f24:	4b19      	ldr	r3, [pc, #100]	; (8016f8c <report_bitfield+0xf0>)
 8016f26:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016f2a:	68f8      	ldr	r0, [r7, #12]
 8016f2c:	4798      	blx	r3
                if(bitmap) {
 8016f2e:	78fb      	ldrb	r3, [r7, #3]
 8016f30:	2b00      	cmp	r3, #0
 8016f32:	d012      	beq.n	8016f5a <report_bitfield+0xbe>
                    hal.stream.write(" (");
 8016f34:	4b15      	ldr	r3, [pc, #84]	; (8016f8c <report_bitfield+0xf0>)
 8016f36:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016f3a:	4818      	ldr	r0, [pc, #96]	; (8016f9c <report_bitfield+0x100>)
 8016f3c:	4798      	blx	r3
                    hal.stream.write(uitoa(val));
 8016f3e:	4b13      	ldr	r3, [pc, #76]	; (8016f8c <report_bitfield+0xf0>)
 8016f40:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8016f44:	6938      	ldr	r0, [r7, #16]
 8016f46:	f7f9 f9a1 	bl	801028c <uitoa>
 8016f4a:	4603      	mov	r3, r0
 8016f4c:	4618      	mov	r0, r3
 8016f4e:	47a0      	blx	r4
                    hal.stream.write(")");
 8016f50:	4b0e      	ldr	r3, [pc, #56]	; (8016f8c <report_bitfield+0xf0>)
 8016f52:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016f56:	4812      	ldr	r0, [pc, #72]	; (8016fa0 <report_bitfield+0x104>)
 8016f58:	4798      	blx	r3
                }
            }
            bit++;
 8016f5a:	697b      	ldr	r3, [r7, #20]
 8016f5c:	3301      	adds	r3, #1
 8016f5e:	617b      	str	r3, [r7, #20]
            val <<= 1;
 8016f60:	693b      	ldr	r3, [r7, #16]
 8016f62:	005b      	lsls	r3, r3, #1
 8016f64:	613b      	str	r3, [r7, #16]
            element = strtok(NULL, ",");
 8016f66:	4907      	ldr	r1, [pc, #28]	; (8016f84 <report_bitfield+0xe8>)
 8016f68:	2000      	movs	r0, #0
 8016f6a:	f00c feb3 	bl	8023cd4 <strtok>
 8016f6e:	60f8      	str	r0, [r7, #12]
        while(element) {
 8016f70:	68fb      	ldr	r3, [r7, #12]
 8016f72:	2b00      	cmp	r3, #0
 8016f74:	d1b3      	bne.n	8016ede <report_bitfield+0x42>
        }

        free(s);
 8016f76:	68b8      	ldr	r0, [r7, #8]
 8016f78:	f00c faa6 	bl	80234c8 <free>
    }
}
 8016f7c:	bf00      	nop
 8016f7e:	371c      	adds	r7, #28
 8016f80:	46bd      	mov	sp, r7
 8016f82:	bd90      	pop	{r4, r7, pc}
 8016f84:	0802b184 	.word	0x0802b184
 8016f88:	0802b678 	.word	0x0802b678
 8016f8c:	20000ed0 	.word	0x20000ed0
 8016f90:	0802b190 	.word	0x0802b190
 8016f94:	0802b67c 	.word	0x0802b67c
 8016f98:	0802b684 	.word	0x0802b684
 8016f9c:	0802b688 	.word	0x0802b688
 8016fa0:	0802b68c 	.word	0x0802b68c

08016fa4 <write_quoted>:

static void write_quoted (const char *s, const char *sep)
{
 8016fa4:	b580      	push	{r7, lr}
 8016fa6:	b082      	sub	sp, #8
 8016fa8:	af00      	add	r7, sp, #0
 8016faa:	6078      	str	r0, [r7, #4]
 8016fac:	6039      	str	r1, [r7, #0]
    hal.stream.write("\"");
 8016fae:	4b0d      	ldr	r3, [pc, #52]	; (8016fe4 <write_quoted+0x40>)
 8016fb0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016fb4:	480c      	ldr	r0, [pc, #48]	; (8016fe8 <write_quoted+0x44>)
 8016fb6:	4798      	blx	r3
    hal.stream.write(s); // TODO: escape double quoutes
 8016fb8:	4b0a      	ldr	r3, [pc, #40]	; (8016fe4 <write_quoted+0x40>)
 8016fba:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016fbe:	6878      	ldr	r0, [r7, #4]
 8016fc0:	4798      	blx	r3
    hal.stream.write("\"");
 8016fc2:	4b08      	ldr	r3, [pc, #32]	; (8016fe4 <write_quoted+0x40>)
 8016fc4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016fc8:	4807      	ldr	r0, [pc, #28]	; (8016fe8 <write_quoted+0x44>)
 8016fca:	4798      	blx	r3
    if(sep)
 8016fcc:	683b      	ldr	r3, [r7, #0]
 8016fce:	2b00      	cmp	r3, #0
 8016fd0:	d004      	beq.n	8016fdc <write_quoted+0x38>
        hal.stream.write(sep);
 8016fd2:	4b04      	ldr	r3, [pc, #16]	; (8016fe4 <write_quoted+0x40>)
 8016fd4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8016fd8:	6838      	ldr	r0, [r7, #0]
 8016fda:	4798      	blx	r3
}
 8016fdc:	bf00      	nop
 8016fde:	3708      	adds	r7, #8
 8016fe0:	46bd      	mov	sp, r7
 8016fe2:	bd80      	pop	{r7, pc}
 8016fe4:	20000ed0 	.word	0x20000ed0
 8016fe8:	0802b690 	.word	0x0802b690

08016fec <write_name>:

static void write_name (const char *s, uint_fast8_t offset)
{
 8016fec:	b590      	push	{r4, r7, lr}
 8016fee:	b085      	sub	sp, #20
 8016ff0:	af00      	add	r7, sp, #0
 8016ff2:	6078      	str	r0, [r7, #4]
 8016ff4:	6039      	str	r1, [r7, #0]
    char *q = hal.stream.write_n ? strchr(s, '?') : NULL;
 8016ff6:	4b1d      	ldr	r3, [pc, #116]	; (801706c <write_name+0x80>)
 8016ff8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8016ffc:	2b00      	cmp	r3, #0
 8016ffe:	d005      	beq.n	801700c <write_name+0x20>
 8017000:	213f      	movs	r1, #63	; 0x3f
 8017002:	6878      	ldr	r0, [r7, #4]
 8017004:	f00c fe1e 	bl	8023c44 <strchr>
 8017008:	4603      	mov	r3, r0
 801700a:	e000      	b.n	801700e <write_name+0x22>
 801700c:	2300      	movs	r3, #0
 801700e:	60fb      	str	r3, [r7, #12]

    if(q) {
 8017010:	68fb      	ldr	r3, [r7, #12]
 8017012:	2b00      	cmp	r3, #0
 8017014:	d020      	beq.n	8017058 <write_name+0x6c>
        if(q != s)
 8017016:	68fa      	ldr	r2, [r7, #12]
 8017018:	687b      	ldr	r3, [r7, #4]
 801701a:	429a      	cmp	r2, r3
 801701c:	d009      	beq.n	8017032 <write_name+0x46>
            hal.stream.write_n(s, q - s);
 801701e:	4b13      	ldr	r3, [pc, #76]	; (801706c <write_name+0x80>)
 8017020:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8017024:	68f9      	ldr	r1, [r7, #12]
 8017026:	687a      	ldr	r2, [r7, #4]
 8017028:	1a8a      	subs	r2, r1, r2
 801702a:	b292      	uxth	r2, r2
 801702c:	4611      	mov	r1, r2
 801702e:	6878      	ldr	r0, [r7, #4]
 8017030:	4798      	blx	r3
        hal.stream.write(uitoa(offset + 1));
 8017032:	4b0e      	ldr	r3, [pc, #56]	; (801706c <write_name+0x80>)
 8017034:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017038:	683b      	ldr	r3, [r7, #0]
 801703a:	3301      	adds	r3, #1
 801703c:	4618      	mov	r0, r3
 801703e:	f7f9 f925 	bl	801028c <uitoa>
 8017042:	4603      	mov	r3, r0
 8017044:	4618      	mov	r0, r3
 8017046:	47a0      	blx	r4
        hal.stream.write(q + 1);
 8017048:	4b08      	ldr	r3, [pc, #32]	; (801706c <write_name+0x80>)
 801704a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801704e:	68fa      	ldr	r2, [r7, #12]
 8017050:	3201      	adds	r2, #1
 8017052:	4610      	mov	r0, r2
 8017054:	4798      	blx	r3
    } else
        hal.stream.write(s);
}
 8017056:	e004      	b.n	8017062 <write_name+0x76>
        hal.stream.write(s);
 8017058:	4b04      	ldr	r3, [pc, #16]	; (801706c <write_name+0x80>)
 801705a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801705e:	6878      	ldr	r0, [r7, #4]
 8017060:	4798      	blx	r3
}
 8017062:	bf00      	nop
 8017064:	3714      	adds	r7, #20
 8017066:	46bd      	mov	sp, r7
 8017068:	bd90      	pop	{r4, r7, pc}
 801706a:	bf00      	nop
 801706c:	20000ed0 	.word	0x20000ed0

08017070 <report_settings_detail>:

static void report_settings_detail (settings_format_t format, const setting_detail_t *setting, uint_fast8_t offset)
{
 8017070:	b590      	push	{r4, r7, lr}
 8017072:	b08b      	sub	sp, #44	; 0x2c
 8017074:	af00      	add	r7, sp, #0
 8017076:	4603      	mov	r3, r0
 8017078:	60b9      	str	r1, [r7, #8]
 801707a:	607a      	str	r2, [r7, #4]
 801707c:	73fb      	strb	r3, [r7, #15]
    uint_fast8_t suboffset = setting->flags.subgroups ? offset / setting->flags.increment : offset;
 801707e:	68bb      	ldr	r3, [r7, #8]
 8017080:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017084:	f003 0304 	and.w	r3, r3, #4
 8017088:	b2db      	uxtb	r3, r3
 801708a:	2b00      	cmp	r3, #0
 801708c:	d00a      	beq.n	80170a4 <report_settings_detail+0x34>
 801708e:	68bb      	ldr	r3, [r7, #8]
 8017090:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017094:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8017098:	b2db      	uxtb	r3, r3
 801709a:	461a      	mov	r2, r3
 801709c:	687b      	ldr	r3, [r7, #4]
 801709e:	fbb3 f3f2 	udiv	r3, r3, r2
 80170a2:	e000      	b.n	80170a6 <report_settings_detail+0x36>
 80170a4:	687b      	ldr	r3, [r7, #4]
 80170a6:	61bb      	str	r3, [r7, #24]

    switch(format)
 80170a8:	7bfb      	ldrb	r3, [r7, #15]
 80170aa:	2b03      	cmp	r3, #3
 80170ac:	f200 843e 	bhi.w	801792c <report_settings_detail+0x8bc>
 80170b0:	a201      	add	r2, pc, #4	; (adr r2, 80170b8 <report_settings_detail+0x48>)
 80170b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80170b6:	bf00      	nop
 80170b8:	080173e1 	.word	0x080173e1
 80170bc:	080170c9 	.word	0x080170c9
 80170c0:	080175ad 	.word	0x080175ad
 80170c4:	08017649 	.word	0x08017649
    {
        case SettingsFormat_HumanReadable:
            {
                bool reboot_newline = false;
 80170c8:	2300      	movs	r3, #0
 80170ca:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

                hal.stream.write(ASCII_EOL "$");
 80170ce:	4b8f      	ldr	r3, [pc, #572]	; (801730c <report_settings_detail+0x29c>)
 80170d0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80170d4:	488e      	ldr	r0, [pc, #568]	; (8017310 <report_settings_detail+0x2a0>)
 80170d6:	4798      	blx	r3
                hal.stream.write(uitoa(setting->id + offset));
 80170d8:	4b8c      	ldr	r3, [pc, #560]	; (801730c <report_settings_detail+0x29c>)
 80170da:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80170de:	68bb      	ldr	r3, [r7, #8]
 80170e0:	881b      	ldrh	r3, [r3, #0]
 80170e2:	461a      	mov	r2, r3
 80170e4:	687b      	ldr	r3, [r7, #4]
 80170e6:	4413      	add	r3, r2
 80170e8:	4618      	mov	r0, r3
 80170ea:	f7f9 f8cf 	bl	801028c <uitoa>
 80170ee:	4603      	mov	r3, r0
 80170f0:	4618      	mov	r0, r3
 80170f2:	47a0      	blx	r4
                hal.stream.write(": ");
 80170f4:	4b85      	ldr	r3, [pc, #532]	; (801730c <report_settings_detail+0x29c>)
 80170f6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80170fa:	4886      	ldr	r0, [pc, #536]	; (8017314 <report_settings_detail+0x2a4>)
 80170fc:	4798      	blx	r3
                if(setting->group == Group_Axis0)
 80170fe:	68bb      	ldr	r3, [r7, #8]
 8017100:	789b      	ldrb	r3, [r3, #2]
 8017102:	2b2b      	cmp	r3, #43	; 0x2b
 8017104:	d108      	bne.n	8017118 <report_settings_detail+0xa8>
                    hal.stream.write(axis_letter[offset]);
 8017106:	4b81      	ldr	r3, [pc, #516]	; (801730c <report_settings_detail+0x29c>)
 8017108:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801710c:	4982      	ldr	r1, [pc, #520]	; (8017318 <report_settings_detail+0x2a8>)
 801710e:	687a      	ldr	r2, [r7, #4]
 8017110:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8017114:	4610      	mov	r0, r2
 8017116:	4798      	blx	r3
                write_name(setting->name, suboffset);
 8017118:	68bb      	ldr	r3, [r7, #8]
 801711a:	685b      	ldr	r3, [r3, #4]
 801711c:	69b9      	ldr	r1, [r7, #24]
 801711e:	4618      	mov	r0, r3
 8017120:	f7ff ff64 	bl	8016fec <write_name>

                switch(setting_datatype_to_external(setting->datatype)) {
 8017124:	68bb      	ldr	r3, [r7, #8]
 8017126:	7b1b      	ldrb	r3, [r3, #12]
 8017128:	4618      	mov	r0, r3
 801712a:	f004 fa8b 	bl	801b644 <setting_datatype_to_external>
 801712e:	4603      	mov	r3, r0
 8017130:	2b09      	cmp	r3, #9
 8017132:	d856      	bhi.n	80171e2 <report_settings_detail+0x172>
 8017134:	a201      	add	r2, pc, #4	; (adr r2, 801713c <report_settings_detail+0xcc>)
 8017136:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801713a:	bf00      	nop
 801713c:	08017171 	.word	0x08017171
 8017140:	0801717d 	.word	0x0801717d
 8017144:	0801719b 	.word	0x0801719b
 8017148:	080171b9 	.word	0x080171b9
 801714c:	08017165 	.word	0x08017165
 8017150:	080171e3 	.word	0x080171e3
 8017154:	080171e3 	.word	0x080171e3
 8017158:	080171e3 	.word	0x080171e3
 801715c:	080171e3 	.word	0x080171e3
 8017160:	080171d7 	.word	0x080171d7

                    case Format_AxisMask:
                        hal.stream.write(" as axismask");
 8017164:	4b69      	ldr	r3, [pc, #420]	; (801730c <report_settings_detail+0x29c>)
 8017166:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801716a:	486c      	ldr	r0, [pc, #432]	; (801731c <report_settings_detail+0x2ac>)
 801716c:	4798      	blx	r3
                        break;
 801716e:	e049      	b.n	8017204 <report_settings_detail+0x194>

                    case Format_Bool:
                        hal.stream.write(" as boolean");
 8017170:	4b66      	ldr	r3, [pc, #408]	; (801730c <report_settings_detail+0x29c>)
 8017172:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017176:	486a      	ldr	r0, [pc, #424]	; (8017320 <report_settings_detail+0x2b0>)
 8017178:	4798      	blx	r3
                        break;
 801717a:	e043      	b.n	8017204 <report_settings_detail+0x194>

                    case Format_Bitfield:
                        hal.stream.write(" as bitfield:");
 801717c:	4b63      	ldr	r3, [pc, #396]	; (801730c <report_settings_detail+0x29c>)
 801717e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017182:	4868      	ldr	r0, [pc, #416]	; (8017324 <report_settings_detail+0x2b4>)
 8017184:	4798      	blx	r3
                        report_bitfield(setting->format, true);
 8017186:	68bb      	ldr	r3, [r7, #8]
 8017188:	691b      	ldr	r3, [r3, #16]
 801718a:	2101      	movs	r1, #1
 801718c:	4618      	mov	r0, r3
 801718e:	f7ff fe85 	bl	8016e9c <report_bitfield>
                        reboot_newline = true;
 8017192:	2301      	movs	r3, #1
 8017194:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                        break;
 8017198:	e034      	b.n	8017204 <report_settings_detail+0x194>

                    case Format_XBitfield:
                        hal.stream.write(" as bitfield where setting bit 0 enables the rest:");
 801719a:	4b5c      	ldr	r3, [pc, #368]	; (801730c <report_settings_detail+0x29c>)
 801719c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80171a0:	4861      	ldr	r0, [pc, #388]	; (8017328 <report_settings_detail+0x2b8>)
 80171a2:	4798      	blx	r3
                        report_bitfield(setting->format, true);
 80171a4:	68bb      	ldr	r3, [r7, #8]
 80171a6:	691b      	ldr	r3, [r3, #16]
 80171a8:	2101      	movs	r1, #1
 80171aa:	4618      	mov	r0, r3
 80171ac:	f7ff fe76 	bl	8016e9c <report_bitfield>
                        reboot_newline = true;
 80171b0:	2301      	movs	r3, #1
 80171b2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                        break;
 80171b6:	e025      	b.n	8017204 <report_settings_detail+0x194>

                    case Format_RadioButtons:
                        hal.stream.write(":");
 80171b8:	4b54      	ldr	r3, [pc, #336]	; (801730c <report_settings_detail+0x29c>)
 80171ba:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80171be:	485b      	ldr	r0, [pc, #364]	; (801732c <report_settings_detail+0x2bc>)
 80171c0:	4798      	blx	r3
                        report_bitfield(setting->format, false);
 80171c2:	68bb      	ldr	r3, [r7, #8]
 80171c4:	691b      	ldr	r3, [r3, #16]
 80171c6:	2100      	movs	r1, #0
 80171c8:	4618      	mov	r0, r3
 80171ca:	f7ff fe67 	bl	8016e9c <report_bitfield>
                        reboot_newline = true;
 80171ce:	2301      	movs	r3, #1
 80171d0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                        break;
 80171d4:	e016      	b.n	8017204 <report_settings_detail+0x194>

                    case Format_IPv4:
                        hal.stream.write(" as IP address");
 80171d6:	4b4d      	ldr	r3, [pc, #308]	; (801730c <report_settings_detail+0x29c>)
 80171d8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80171dc:	4854      	ldr	r0, [pc, #336]	; (8017330 <report_settings_detail+0x2c0>)
 80171de:	4798      	blx	r3
                        break;
 80171e0:	e010      	b.n	8017204 <report_settings_detail+0x194>

                    default:
                        if(setting->unit) {
 80171e2:	68bb      	ldr	r3, [r7, #8]
 80171e4:	689b      	ldr	r3, [r3, #8]
 80171e6:	2b00      	cmp	r3, #0
 80171e8:	d00b      	beq.n	8017202 <report_settings_detail+0x192>
                            hal.stream.write(" in ");
 80171ea:	4b48      	ldr	r3, [pc, #288]	; (801730c <report_settings_detail+0x29c>)
 80171ec:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80171f0:	4850      	ldr	r0, [pc, #320]	; (8017334 <report_settings_detail+0x2c4>)
 80171f2:	4798      	blx	r3
                            hal.stream.write(setting->unit);
 80171f4:	4b45      	ldr	r3, [pc, #276]	; (801730c <report_settings_detail+0x29c>)
 80171f6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80171fa:	68ba      	ldr	r2, [r7, #8]
 80171fc:	6892      	ldr	r2, [r2, #8]
 80171fe:	4610      	mov	r0, r2
 8017200:	4798      	blx	r3
                        }
                        break;
 8017202:	bf00      	nop
                }

                if(setting->min_value && setting->max_value) {
 8017204:	68bb      	ldr	r3, [r7, #8]
 8017206:	695b      	ldr	r3, [r3, #20]
 8017208:	2b00      	cmp	r3, #0
 801720a:	d01c      	beq.n	8017246 <report_settings_detail+0x1d6>
 801720c:	68bb      	ldr	r3, [r7, #8]
 801720e:	699b      	ldr	r3, [r3, #24]
 8017210:	2b00      	cmp	r3, #0
 8017212:	d018      	beq.n	8017246 <report_settings_detail+0x1d6>
                    hal.stream.write(", range: ");
 8017214:	4b3d      	ldr	r3, [pc, #244]	; (801730c <report_settings_detail+0x29c>)
 8017216:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801721a:	4847      	ldr	r0, [pc, #284]	; (8017338 <report_settings_detail+0x2c8>)
 801721c:	4798      	blx	r3
                    hal.stream.write(setting->min_value);
 801721e:	4b3b      	ldr	r3, [pc, #236]	; (801730c <report_settings_detail+0x29c>)
 8017220:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017224:	68ba      	ldr	r2, [r7, #8]
 8017226:	6952      	ldr	r2, [r2, #20]
 8017228:	4610      	mov	r0, r2
 801722a:	4798      	blx	r3
                    hal.stream.write(" - ");
 801722c:	4b37      	ldr	r3, [pc, #220]	; (801730c <report_settings_detail+0x29c>)
 801722e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017232:	4842      	ldr	r0, [pc, #264]	; (801733c <report_settings_detail+0x2cc>)
 8017234:	4798      	blx	r3
                    hal.stream.write(setting->max_value);
 8017236:	4b35      	ldr	r3, [pc, #212]	; (801730c <report_settings_detail+0x29c>)
 8017238:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801723c:	68ba      	ldr	r2, [r7, #8]
 801723e:	6992      	ldr	r2, [r2, #24]
 8017240:	4610      	mov	r0, r2
 8017242:	4798      	blx	r3
 8017244:	e028      	b.n	8017298 <report_settings_detail+0x228>
                } else if(!setting_is_list(setting)) {
 8017246:	68b8      	ldr	r0, [r7, #8]
 8017248:	f004 fa0f 	bl	801b66a <setting_is_list>
 801724c:	4603      	mov	r3, r0
 801724e:	f083 0301 	eor.w	r3, r3, #1
 8017252:	b2db      	uxtb	r3, r3
 8017254:	2b00      	cmp	r3, #0
 8017256:	d01f      	beq.n	8017298 <report_settings_detail+0x228>
                    if(setting->min_value) {
 8017258:	68bb      	ldr	r3, [r7, #8]
 801725a:	695b      	ldr	r3, [r3, #20]
 801725c:	2b00      	cmp	r3, #0
 801725e:	d00b      	beq.n	8017278 <report_settings_detail+0x208>
                        hal.stream.write(", min: ");
 8017260:	4b2a      	ldr	r3, [pc, #168]	; (801730c <report_settings_detail+0x29c>)
 8017262:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017266:	4836      	ldr	r0, [pc, #216]	; (8017340 <report_settings_detail+0x2d0>)
 8017268:	4798      	blx	r3
                        hal.stream.write(setting->min_value);
 801726a:	4b28      	ldr	r3, [pc, #160]	; (801730c <report_settings_detail+0x29c>)
 801726c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017270:	68ba      	ldr	r2, [r7, #8]
 8017272:	6952      	ldr	r2, [r2, #20]
 8017274:	4610      	mov	r0, r2
 8017276:	4798      	blx	r3
                    }
                    if(setting->max_value) {
 8017278:	68bb      	ldr	r3, [r7, #8]
 801727a:	699b      	ldr	r3, [r3, #24]
 801727c:	2b00      	cmp	r3, #0
 801727e:	d00b      	beq.n	8017298 <report_settings_detail+0x228>
                        hal.stream.write(", max: ");
 8017280:	4b22      	ldr	r3, [pc, #136]	; (801730c <report_settings_detail+0x29c>)
 8017282:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017286:	482f      	ldr	r0, [pc, #188]	; (8017344 <report_settings_detail+0x2d4>)
 8017288:	4798      	blx	r3
                        hal.stream.write(setting->max_value);
 801728a:	4b20      	ldr	r3, [pc, #128]	; (801730c <report_settings_detail+0x29c>)
 801728c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017290:	68ba      	ldr	r2, [r7, #8]
 8017292:	6992      	ldr	r2, [r2, #24]
 8017294:	4610      	mov	r0, r2
 8017296:	4798      	blx	r3
                    }
                }

                if(setting->flags.reboot_required)
 8017298:	68bb      	ldr	r3, [r7, #8]
 801729a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801729e:	f003 0301 	and.w	r3, r3, #1
 80172a2:	b2db      	uxtb	r3, r3
 80172a4:	2b00      	cmp	r3, #0
 80172a6:	d00b      	beq.n	80172c0 <report_settings_detail+0x250>
                    hal.stream.write(reboot_newline ? ASCII_EOL ASCII_EOL "Reboot required." : ", reboot required");
 80172a8:	4b18      	ldr	r3, [pc, #96]	; (801730c <report_settings_detail+0x29c>)
 80172aa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80172ae:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 80172b2:	2a00      	cmp	r2, #0
 80172b4:	d001      	beq.n	80172ba <report_settings_detail+0x24a>
 80172b6:	4a24      	ldr	r2, [pc, #144]	; (8017348 <report_settings_detail+0x2d8>)
 80172b8:	e000      	b.n	80172bc <report_settings_detail+0x24c>
 80172ba:	4a24      	ldr	r2, [pc, #144]	; (801734c <report_settings_detail+0x2dc>)
 80172bc:	4610      	mov	r0, r2
 80172be:	4798      	blx	r3

#ifndef NO_SETTINGS_DESCRIPTIONS
                // Add description if driver is capable of outputting it...
                if(hal.stream.write_n) {
 80172c0:	4b12      	ldr	r3, [pc, #72]	; (801730c <report_settings_detail+0x29c>)
 80172c2:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 80172c6:	2b00      	cmp	r3, #0
 80172c8:	f000 832f 	beq.w	801792a <report_settings_detail+0x8ba>
                    const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 80172cc:	68bb      	ldr	r3, [r7, #8]
 80172ce:	881a      	ldrh	r2, [r3, #0]
 80172d0:	687b      	ldr	r3, [r7, #4]
 80172d2:	b29b      	uxth	r3, r3
 80172d4:	4413      	add	r3, r2
 80172d6:	b29b      	uxth	r3, r3
 80172d8:	4618      	mov	r0, r3
 80172da:	f004 f843 	bl	801b364 <setting_get_description>
 80172de:	6238      	str	r0, [r7, #32]
                    if(description && *description != '\0') {
 80172e0:	6a3b      	ldr	r3, [r7, #32]
 80172e2:	2b00      	cmp	r3, #0
 80172e4:	d060      	beq.n	80173a8 <report_settings_detail+0x338>
 80172e6:	6a3b      	ldr	r3, [r7, #32]
 80172e8:	781b      	ldrb	r3, [r3, #0]
 80172ea:	2b00      	cmp	r3, #0
 80172ec:	d05c      	beq.n	80173a8 <report_settings_detail+0x338>
                        char *lf;
                        hal.stream.write(ASCII_EOL);
 80172ee:	4b07      	ldr	r3, [pc, #28]	; (801730c <report_settings_detail+0x29c>)
 80172f0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80172f4:	4816      	ldr	r0, [pc, #88]	; (8017350 <report_settings_detail+0x2e0>)
 80172f6:	4798      	blx	r3
                        if((lf = strstr(description, "\\n"))) while(lf) {
 80172f8:	4916      	ldr	r1, [pc, #88]	; (8017354 <report_settings_detail+0x2e4>)
 80172fa:	6a38      	ldr	r0, [r7, #32]
 80172fc:	f00c fd46 	bl	8023d8c <strstr>
 8017300:	61f8      	str	r0, [r7, #28]
 8017302:	69fb      	ldr	r3, [r7, #28]
 8017304:	2b00      	cmp	r3, #0
 8017306:	d041      	beq.n	801738c <report_settings_detail+0x31c>
 8017308:	e03d      	b.n	8017386 <report_settings_detail+0x316>
 801730a:	bf00      	nop
 801730c:	20000ed0 	.word	0x20000ed0
 8017310:	0802b694 	.word	0x0802b694
 8017314:	0802b698 	.word	0x0802b698
 8017318:	0803102c 	.word	0x0803102c
 801731c:	0802b69c 	.word	0x0802b69c
 8017320:	0802b6ac 	.word	0x0802b6ac
 8017324:	0802b6b8 	.word	0x0802b6b8
 8017328:	0802b6c8 	.word	0x0802b6c8
 801732c:	0802b2c4 	.word	0x0802b2c4
 8017330:	0802b6fc 	.word	0x0802b6fc
 8017334:	0802b70c 	.word	0x0802b70c
 8017338:	0802b714 	.word	0x0802b714
 801733c:	0802b684 	.word	0x0802b684
 8017340:	0802b720 	.word	0x0802b720
 8017344:	0802b728 	.word	0x0802b728
 8017348:	0802b730 	.word	0x0802b730
 801734c:	0802b748 	.word	0x0802b748
 8017350:	0802b190 	.word	0x0802b190
 8017354:	0802b75c 	.word	0x0802b75c
                            hal.stream.write(ASCII_EOL);
 8017358:	4b8b      	ldr	r3, [pc, #556]	; (8017588 <report_settings_detail+0x518>)
 801735a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801735e:	488b      	ldr	r0, [pc, #556]	; (801758c <report_settings_detail+0x51c>)
 8017360:	4798      	blx	r3
                            hal.stream.write_n(description, lf - description);
 8017362:	4b89      	ldr	r3, [pc, #548]	; (8017588 <report_settings_detail+0x518>)
 8017364:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8017368:	69f9      	ldr	r1, [r7, #28]
 801736a:	6a3a      	ldr	r2, [r7, #32]
 801736c:	1a8a      	subs	r2, r1, r2
 801736e:	b292      	uxth	r2, r2
 8017370:	4611      	mov	r1, r2
 8017372:	6a38      	ldr	r0, [r7, #32]
 8017374:	4798      	blx	r3
                            description = lf + 2;
 8017376:	69fb      	ldr	r3, [r7, #28]
 8017378:	3302      	adds	r3, #2
 801737a:	623b      	str	r3, [r7, #32]
                            lf = strstr(description, "\\n");
 801737c:	4984      	ldr	r1, [pc, #528]	; (8017590 <report_settings_detail+0x520>)
 801737e:	6a38      	ldr	r0, [r7, #32]
 8017380:	f00c fd04 	bl	8023d8c <strstr>
 8017384:	61f8      	str	r0, [r7, #28]
                        if((lf = strstr(description, "\\n"))) while(lf) {
 8017386:	69fb      	ldr	r3, [r7, #28]
 8017388:	2b00      	cmp	r3, #0
 801738a:	d1e5      	bne.n	8017358 <report_settings_detail+0x2e8>
                        }
                        if(*description != '\0') {
 801738c:	6a3b      	ldr	r3, [r7, #32]
 801738e:	781b      	ldrb	r3, [r3, #0]
 8017390:	2b00      	cmp	r3, #0
 8017392:	d009      	beq.n	80173a8 <report_settings_detail+0x338>
                            hal.stream.write(ASCII_EOL);
 8017394:	4b7c      	ldr	r3, [pc, #496]	; (8017588 <report_settings_detail+0x518>)
 8017396:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801739a:	487c      	ldr	r0, [pc, #496]	; (801758c <report_settings_detail+0x51c>)
 801739c:	4798      	blx	r3
                            hal.stream.write(description);
 801739e:	4b7a      	ldr	r3, [pc, #488]	; (8017588 <report_settings_detail+0x518>)
 80173a0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80173a4:	6a38      	ldr	r0, [r7, #32]
 80173a6:	4798      	blx	r3
                        }
                    }
                    if(setting->flags.reboot_required) {
 80173a8:	68bb      	ldr	r3, [r7, #8]
 80173aa:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80173ae:	f003 0301 	and.w	r3, r3, #1
 80173b2:	b2db      	uxtb	r3, r3
 80173b4:	2b00      	cmp	r3, #0
 80173b6:	f000 82b8 	beq.w	801792a <report_settings_detail+0x8ba>
                        if(description && *description != '\0')
 80173ba:	6a3b      	ldr	r3, [r7, #32]
 80173bc:	2b00      	cmp	r3, #0
 80173be:	d008      	beq.n	80173d2 <report_settings_detail+0x362>
 80173c0:	6a3b      	ldr	r3, [r7, #32]
 80173c2:	781b      	ldrb	r3, [r3, #0]
 80173c4:	2b00      	cmp	r3, #0
 80173c6:	d004      	beq.n	80173d2 <report_settings_detail+0x362>
                            hal.stream.write(ASCII_EOL ASCII_EOL);
 80173c8:	4b6f      	ldr	r3, [pc, #444]	; (8017588 <report_settings_detail+0x518>)
 80173ca:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80173ce:	4871      	ldr	r0, [pc, #452]	; (8017594 <report_settings_detail+0x524>)
 80173d0:	4798      	blx	r3
                        hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + 4);
 80173d2:	4b6d      	ldr	r3, [pc, #436]	; (8017588 <report_settings_detail+0x518>)
 80173d4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80173d8:	4a6f      	ldr	r2, [pc, #444]	; (8017598 <report_settings_detail+0x528>)
 80173da:	4610      	mov	r0, r2
 80173dc:	4798      	blx	r3
                    }
                }
#endif
            }
            break;
 80173de:	e2a4      	b.n	801792a <report_settings_detail+0x8ba>

        case SettingsFormat_MachineReadable:
            hal.stream.write("[SETTING:");
 80173e0:	4b69      	ldr	r3, [pc, #420]	; (8017588 <report_settings_detail+0x518>)
 80173e2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80173e6:	486d      	ldr	r0, [pc, #436]	; (801759c <report_settings_detail+0x52c>)
 80173e8:	4798      	blx	r3
            hal.stream.write(uitoa(setting->id + offset));
 80173ea:	4b67      	ldr	r3, [pc, #412]	; (8017588 <report_settings_detail+0x518>)
 80173ec:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80173f0:	68bb      	ldr	r3, [r7, #8]
 80173f2:	881b      	ldrh	r3, [r3, #0]
 80173f4:	461a      	mov	r2, r3
 80173f6:	687b      	ldr	r3, [r7, #4]
 80173f8:	4413      	add	r3, r2
 80173fa:	4618      	mov	r0, r3
 80173fc:	f7f8 ff46 	bl	801028c <uitoa>
 8017400:	4603      	mov	r3, r0
 8017402:	4618      	mov	r0, r3
 8017404:	47a0      	blx	r4
            hal.stream.write(vbar);
 8017406:	4b60      	ldr	r3, [pc, #384]	; (8017588 <report_settings_detail+0x518>)
 8017408:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801740c:	4864      	ldr	r0, [pc, #400]	; (80175a0 <report_settings_detail+0x530>)
 801740e:	4798      	blx	r3
            hal.stream.write(uitoa(setting->group + (setting->flags.subgroups ? suboffset : 0)));
 8017410:	4b5d      	ldr	r3, [pc, #372]	; (8017588 <report_settings_detail+0x518>)
 8017412:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017416:	68bb      	ldr	r3, [r7, #8]
 8017418:	789b      	ldrb	r3, [r3, #2]
 801741a:	461a      	mov	r2, r3
 801741c:	68bb      	ldr	r3, [r7, #8]
 801741e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017422:	f003 0304 	and.w	r3, r3, #4
 8017426:	b2db      	uxtb	r3, r3
 8017428:	2b00      	cmp	r3, #0
 801742a:	d001      	beq.n	8017430 <report_settings_detail+0x3c0>
 801742c:	69bb      	ldr	r3, [r7, #24]
 801742e:	e000      	b.n	8017432 <report_settings_detail+0x3c2>
 8017430:	2300      	movs	r3, #0
 8017432:	4413      	add	r3, r2
 8017434:	4618      	mov	r0, r3
 8017436:	f7f8 ff29 	bl	801028c <uitoa>
 801743a:	4603      	mov	r3, r0
 801743c:	4618      	mov	r0, r3
 801743e:	47a0      	blx	r4
            hal.stream.write(vbar);
 8017440:	4b51      	ldr	r3, [pc, #324]	; (8017588 <report_settings_detail+0x518>)
 8017442:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017446:	4856      	ldr	r0, [pc, #344]	; (80175a0 <report_settings_detail+0x530>)
 8017448:	4798      	blx	r3
            if(setting->group == Group_Axis0)
 801744a:	68bb      	ldr	r3, [r7, #8]
 801744c:	789b      	ldrb	r3, [r3, #2]
 801744e:	2b2b      	cmp	r3, #43	; 0x2b
 8017450:	d108      	bne.n	8017464 <report_settings_detail+0x3f4>
                hal.stream.write(axis_letter[offset]);
 8017452:	4b4d      	ldr	r3, [pc, #308]	; (8017588 <report_settings_detail+0x518>)
 8017454:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017458:	4952      	ldr	r1, [pc, #328]	; (80175a4 <report_settings_detail+0x534>)
 801745a:	687a      	ldr	r2, [r7, #4]
 801745c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8017460:	4610      	mov	r0, r2
 8017462:	4798      	blx	r3
            write_name(setting->name, suboffset);
 8017464:	68bb      	ldr	r3, [r7, #8]
 8017466:	685b      	ldr	r3, [r3, #4]
 8017468:	69b9      	ldr	r1, [r7, #24]
 801746a:	4618      	mov	r0, r3
 801746c:	f7ff fdbe 	bl	8016fec <write_name>
            hal.stream.write(vbar);
 8017470:	4b45      	ldr	r3, [pc, #276]	; (8017588 <report_settings_detail+0x518>)
 8017472:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017476:	484a      	ldr	r0, [pc, #296]	; (80175a0 <report_settings_detail+0x530>)
 8017478:	4798      	blx	r3
            if(setting->unit)
 801747a:	68bb      	ldr	r3, [r7, #8]
 801747c:	689b      	ldr	r3, [r3, #8]
 801747e:	2b00      	cmp	r3, #0
 8017480:	d006      	beq.n	8017490 <report_settings_detail+0x420>
                hal.stream.write(setting->unit);
 8017482:	4b41      	ldr	r3, [pc, #260]	; (8017588 <report_settings_detail+0x518>)
 8017484:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017488:	68ba      	ldr	r2, [r7, #8]
 801748a:	6892      	ldr	r2, [r2, #8]
 801748c:	4610      	mov	r0, r2
 801748e:	4798      	blx	r3
            hal.stream.write(vbar);
 8017490:	4b3d      	ldr	r3, [pc, #244]	; (8017588 <report_settings_detail+0x518>)
 8017492:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017496:	4842      	ldr	r0, [pc, #264]	; (80175a0 <report_settings_detail+0x530>)
 8017498:	4798      	blx	r3
            hal.stream.write(uitoa(setting_datatype_to_external(setting->datatype)));
 801749a:	4b3b      	ldr	r3, [pc, #236]	; (8017588 <report_settings_detail+0x518>)
 801749c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80174a0:	68bb      	ldr	r3, [r7, #8]
 80174a2:	7b1b      	ldrb	r3, [r3, #12]
 80174a4:	4618      	mov	r0, r3
 80174a6:	f004 f8cd 	bl	801b644 <setting_datatype_to_external>
 80174aa:	4603      	mov	r3, r0
 80174ac:	4618      	mov	r0, r3
 80174ae:	f7f8 feed 	bl	801028c <uitoa>
 80174b2:	4603      	mov	r3, r0
 80174b4:	4618      	mov	r0, r3
 80174b6:	47a0      	blx	r4
            hal.stream.write(vbar);
 80174b8:	4b33      	ldr	r3, [pc, #204]	; (8017588 <report_settings_detail+0x518>)
 80174ba:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80174be:	4838      	ldr	r0, [pc, #224]	; (80175a0 <report_settings_detail+0x530>)
 80174c0:	4798      	blx	r3
            if(setting->format)
 80174c2:	68bb      	ldr	r3, [r7, #8]
 80174c4:	691b      	ldr	r3, [r3, #16]
 80174c6:	2b00      	cmp	r3, #0
 80174c8:	d006      	beq.n	80174d8 <report_settings_detail+0x468>
                hal.stream.write(setting->format);
 80174ca:	4b2f      	ldr	r3, [pc, #188]	; (8017588 <report_settings_detail+0x518>)
 80174cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80174d0:	68ba      	ldr	r2, [r7, #8]
 80174d2:	6912      	ldr	r2, [r2, #16]
 80174d4:	4610      	mov	r0, r2
 80174d6:	4798      	blx	r3
            hal.stream.write(vbar);
 80174d8:	4b2b      	ldr	r3, [pc, #172]	; (8017588 <report_settings_detail+0x518>)
 80174da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80174de:	4830      	ldr	r0, [pc, #192]	; (80175a0 <report_settings_detail+0x530>)
 80174e0:	4798      	blx	r3
            if(setting->min_value && !setting_is_list(setting))
 80174e2:	68bb      	ldr	r3, [r7, #8]
 80174e4:	695b      	ldr	r3, [r3, #20]
 80174e6:	2b00      	cmp	r3, #0
 80174e8:	d00f      	beq.n	801750a <report_settings_detail+0x49a>
 80174ea:	68b8      	ldr	r0, [r7, #8]
 80174ec:	f004 f8bd 	bl	801b66a <setting_is_list>
 80174f0:	4603      	mov	r3, r0
 80174f2:	f083 0301 	eor.w	r3, r3, #1
 80174f6:	b2db      	uxtb	r3, r3
 80174f8:	2b00      	cmp	r3, #0
 80174fa:	d006      	beq.n	801750a <report_settings_detail+0x49a>
                hal.stream.write(setting->min_value);
 80174fc:	4b22      	ldr	r3, [pc, #136]	; (8017588 <report_settings_detail+0x518>)
 80174fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017502:	68ba      	ldr	r2, [r7, #8]
 8017504:	6952      	ldr	r2, [r2, #20]
 8017506:	4610      	mov	r0, r2
 8017508:	4798      	blx	r3
            hal.stream.write(vbar);
 801750a:	4b1f      	ldr	r3, [pc, #124]	; (8017588 <report_settings_detail+0x518>)
 801750c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017510:	4823      	ldr	r0, [pc, #140]	; (80175a0 <report_settings_detail+0x530>)
 8017512:	4798      	blx	r3
            if(setting->max_value)
 8017514:	68bb      	ldr	r3, [r7, #8]
 8017516:	699b      	ldr	r3, [r3, #24]
 8017518:	2b00      	cmp	r3, #0
 801751a:	d006      	beq.n	801752a <report_settings_detail+0x4ba>
                hal.stream.write(setting->max_value);
 801751c:	4b1a      	ldr	r3, [pc, #104]	; (8017588 <report_settings_detail+0x518>)
 801751e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017522:	68ba      	ldr	r2, [r7, #8]
 8017524:	6992      	ldr	r2, [r2, #24]
 8017526:	4610      	mov	r0, r2
 8017528:	4798      	blx	r3
            hal.stream.write(vbar);
 801752a:	4b17      	ldr	r3, [pc, #92]	; (8017588 <report_settings_detail+0x518>)
 801752c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017530:	481b      	ldr	r0, [pc, #108]	; (80175a0 <report_settings_detail+0x530>)
 8017532:	4798      	blx	r3
            hal.stream.write(uitoa(setting->flags.reboot_required));
 8017534:	4b14      	ldr	r3, [pc, #80]	; (8017588 <report_settings_detail+0x518>)
 8017536:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 801753a:	68bb      	ldr	r3, [r7, #8]
 801753c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017540:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8017544:	b2db      	uxtb	r3, r3
 8017546:	4618      	mov	r0, r3
 8017548:	f7f8 fea0 	bl	801028c <uitoa>
 801754c:	4603      	mov	r3, r0
 801754e:	4618      	mov	r0, r3
 8017550:	47a0      	blx	r4
            hal.stream.write(vbar);
 8017552:	4b0d      	ldr	r3, [pc, #52]	; (8017588 <report_settings_detail+0x518>)
 8017554:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017558:	4811      	ldr	r0, [pc, #68]	; (80175a0 <report_settings_detail+0x530>)
 801755a:	4798      	blx	r3
            hal.stream.write(uitoa(setting->flags.allow_null));
 801755c:	4b0a      	ldr	r3, [pc, #40]	; (8017588 <report_settings_detail+0x518>)
 801755e:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017562:	68bb      	ldr	r3, [r7, #8]
 8017564:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017568:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801756c:	b2db      	uxtb	r3, r3
 801756e:	4618      	mov	r0, r3
 8017570:	f7f8 fe8c 	bl	801028c <uitoa>
 8017574:	4603      	mov	r3, r0
 8017576:	4618      	mov	r0, r3
 8017578:	47a0      	blx	r4
            hal.stream.write("]");
 801757a:	4b03      	ldr	r3, [pc, #12]	; (8017588 <report_settings_detail+0x518>)
 801757c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017580:	4809      	ldr	r0, [pc, #36]	; (80175a8 <report_settings_detail+0x538>)
 8017582:	4798      	blx	r3
            break;
 8017584:	e1d2      	b.n	801792c <report_settings_detail+0x8bc>
 8017586:	bf00      	nop
 8017588:	20000ed0 	.word	0x20000ed0
 801758c:	0802b190 	.word	0x0802b190
 8017590:	0802b75c 	.word	0x0802b75c
 8017594:	0802b760 	.word	0x0802b760
 8017598:	0802b76c 	.word	0x0802b76c
 801759c:	0802b7bc 	.word	0x0802b7bc
 80175a0:	08031438 	.word	0x08031438
 80175a4:	0803102c 	.word	0x0803102c
 80175a8:	0802b7c8 	.word	0x0802b7c8

        case SettingsFormat_Grbl:
            {
                write_quoted(uitoa(setting->id + offset), ",");
 80175ac:	68bb      	ldr	r3, [r7, #8]
 80175ae:	881b      	ldrh	r3, [r3, #0]
 80175b0:	461a      	mov	r2, r3
 80175b2:	687b      	ldr	r3, [r7, #4]
 80175b4:	4413      	add	r3, r2
 80175b6:	4618      	mov	r0, r3
 80175b8:	f7f8 fe68 	bl	801028c <uitoa>
 80175bc:	4603      	mov	r3, r0
 80175be:	4996      	ldr	r1, [pc, #600]	; (8017818 <report_settings_detail+0x7a8>)
 80175c0:	4618      	mov	r0, r3
 80175c2:	f7ff fcef 	bl	8016fa4 <write_quoted>
                hal.stream.write("\"");
 80175c6:	4b95      	ldr	r3, [pc, #596]	; (801781c <report_settings_detail+0x7ac>)
 80175c8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80175cc:	4894      	ldr	r0, [pc, #592]	; (8017820 <report_settings_detail+0x7b0>)
 80175ce:	4798      	blx	r3
                if(setting->group == Group_Axis0)
 80175d0:	68bb      	ldr	r3, [r7, #8]
 80175d2:	789b      	ldrb	r3, [r3, #2]
 80175d4:	2b2b      	cmp	r3, #43	; 0x2b
 80175d6:	d108      	bne.n	80175ea <report_settings_detail+0x57a>
                    hal.stream.write(axis_letter[offset]);
 80175d8:	4b90      	ldr	r3, [pc, #576]	; (801781c <report_settings_detail+0x7ac>)
 80175da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80175de:	4991      	ldr	r1, [pc, #580]	; (8017824 <report_settings_detail+0x7b4>)
 80175e0:	687a      	ldr	r2, [r7, #4]
 80175e2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80175e6:	4610      	mov	r0, r2
 80175e8:	4798      	blx	r3
                write_name(setting->name, suboffset);
 80175ea:	68bb      	ldr	r3, [r7, #8]
 80175ec:	685b      	ldr	r3, [r3, #4]
 80175ee:	69b9      	ldr	r1, [r7, #24]
 80175f0:	4618      	mov	r0, r3
 80175f2:	f7ff fcfb 	bl	8016fec <write_name>
                hal.stream.write("\",");
 80175f6:	4b89      	ldr	r3, [pc, #548]	; (801781c <report_settings_detail+0x7ac>)
 80175f8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80175fc:	488a      	ldr	r0, [pc, #552]	; (8017828 <report_settings_detail+0x7b8>)
 80175fe:	4798      	blx	r3
                if(setting->unit) {
 8017600:	68bb      	ldr	r3, [r7, #8]
 8017602:	689b      	ldr	r3, [r3, #8]
 8017604:	2b00      	cmp	r3, #0
 8017606:	d006      	beq.n	8017616 <report_settings_detail+0x5a6>
                    write_quoted(setting->unit, ",");
 8017608:	68bb      	ldr	r3, [r7, #8]
 801760a:	689b      	ldr	r3, [r3, #8]
 801760c:	4982      	ldr	r1, [pc, #520]	; (8017818 <report_settings_detail+0x7a8>)
 801760e:	4618      	mov	r0, r3
 8017610:	f7ff fcc8 	bl	8016fa4 <write_quoted>
 8017614:	e003      	b.n	801761e <report_settings_detail+0x5ae>
                } else // TODO: output sensible unit from datatype
                    write_quoted("", ",");
 8017616:	4980      	ldr	r1, [pc, #512]	; (8017818 <report_settings_detail+0x7a8>)
 8017618:	4884      	ldr	r0, [pc, #528]	; (801782c <report_settings_detail+0x7bc>)
 801761a:	f7ff fcc3 	bl	8016fa4 <write_quoted>

    #ifndef NO_SETTINGS_DESCRIPTIONS
                const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 801761e:	68bb      	ldr	r3, [r7, #8]
 8017620:	881a      	ldrh	r2, [r3, #0]
 8017622:	687b      	ldr	r3, [r7, #4]
 8017624:	b29b      	uxth	r3, r3
 8017626:	4413      	add	r3, r2
 8017628:	b29b      	uxth	r3, r3
 801762a:	4618      	mov	r0, r3
 801762c:	f003 fe9a 	bl	801b364 <setting_get_description>
 8017630:	6138      	str	r0, [r7, #16]
                write_quoted(description ? description : "", ",");
 8017632:	693b      	ldr	r3, [r7, #16]
 8017634:	2b00      	cmp	r3, #0
 8017636:	d001      	beq.n	801763c <report_settings_detail+0x5cc>
 8017638:	693b      	ldr	r3, [r7, #16]
 801763a:	e000      	b.n	801763e <report_settings_detail+0x5ce>
 801763c:	4b7b      	ldr	r3, [pc, #492]	; (801782c <report_settings_detail+0x7bc>)
 801763e:	4976      	ldr	r1, [pc, #472]	; (8017818 <report_settings_detail+0x7a8>)
 8017640:	4618      	mov	r0, r3
 8017642:	f7ff fcaf 	bl	8016fa4 <write_quoted>
    #else
                write_quoted("", NULL);
    #endif
            }
            break;
 8017646:	e171      	b.n	801792c <report_settings_detail+0x8bc>

        case SettingsFormat_grblHAL:
            {
                hal.stream.write(uitoa(setting->id + offset));
 8017648:	4b74      	ldr	r3, [pc, #464]	; (801781c <report_settings_detail+0x7ac>)
 801764a:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 801764e:	68bb      	ldr	r3, [r7, #8]
 8017650:	881b      	ldrh	r3, [r3, #0]
 8017652:	461a      	mov	r2, r3
 8017654:	687b      	ldr	r3, [r7, #4]
 8017656:	4413      	add	r3, r2
 8017658:	4618      	mov	r0, r3
 801765a:	f7f8 fe17 	bl	801028c <uitoa>
 801765e:	4603      	mov	r3, r0
 8017660:	4618      	mov	r0, r3
 8017662:	47a0      	blx	r4

                hal.stream.write("\t");
 8017664:	4b6d      	ldr	r3, [pc, #436]	; (801781c <report_settings_detail+0x7ac>)
 8017666:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801766a:	4871      	ldr	r0, [pc, #452]	; (8017830 <report_settings_detail+0x7c0>)
 801766c:	4798      	blx	r3

                if(setting->group == Group_Axis0)
 801766e:	68bb      	ldr	r3, [r7, #8]
 8017670:	789b      	ldrb	r3, [r3, #2]
 8017672:	2b2b      	cmp	r3, #43	; 0x2b
 8017674:	d108      	bne.n	8017688 <report_settings_detail+0x618>
                    hal.stream.write(axis_letter[offset]);
 8017676:	4b69      	ldr	r3, [pc, #420]	; (801781c <report_settings_detail+0x7ac>)
 8017678:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801767c:	4969      	ldr	r1, [pc, #420]	; (8017824 <report_settings_detail+0x7b4>)
 801767e:	687a      	ldr	r2, [r7, #4]
 8017680:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8017684:	4610      	mov	r0, r2
 8017686:	4798      	blx	r3
                write_name(setting->name, suboffset);
 8017688:	68bb      	ldr	r3, [r7, #8]
 801768a:	685b      	ldr	r3, [r3, #4]
 801768c:	69b9      	ldr	r1, [r7, #24]
 801768e:	4618      	mov	r0, r3
 8017690:	f7ff fcac 	bl	8016fec <write_name>

                hal.stream.write("\t");
 8017694:	4b61      	ldr	r3, [pc, #388]	; (801781c <report_settings_detail+0x7ac>)
 8017696:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801769a:	4865      	ldr	r0, [pc, #404]	; (8017830 <report_settings_detail+0x7c0>)
 801769c:	4798      	blx	r3

                if(setting->unit)
 801769e:	68bb      	ldr	r3, [r7, #8]
 80176a0:	689b      	ldr	r3, [r3, #8]
 80176a2:	2b00      	cmp	r3, #0
 80176a4:	d007      	beq.n	80176b6 <report_settings_detail+0x646>
                    hal.stream.write(setting->unit);
 80176a6:	4b5d      	ldr	r3, [pc, #372]	; (801781c <report_settings_detail+0x7ac>)
 80176a8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80176ac:	68ba      	ldr	r2, [r7, #8]
 80176ae:	6892      	ldr	r2, [r2, #8]
 80176b0:	4610      	mov	r0, r2
 80176b2:	4798      	blx	r3
 80176b4:	e024      	b.n	8017700 <report_settings_detail+0x690>
                else if(setting->datatype == Format_AxisMask || setting->datatype == Format_Bitfield || setting->datatype == Format_XBitfield)
 80176b6:	68bb      	ldr	r3, [r7, #8]
 80176b8:	7b1b      	ldrb	r3, [r3, #12]
 80176ba:	2b04      	cmp	r3, #4
 80176bc:	d007      	beq.n	80176ce <report_settings_detail+0x65e>
 80176be:	68bb      	ldr	r3, [r7, #8]
 80176c0:	7b1b      	ldrb	r3, [r3, #12]
 80176c2:	2b01      	cmp	r3, #1
 80176c4:	d003      	beq.n	80176ce <report_settings_detail+0x65e>
 80176c6:	68bb      	ldr	r3, [r7, #8]
 80176c8:	7b1b      	ldrb	r3, [r3, #12]
 80176ca:	2b02      	cmp	r3, #2
 80176cc:	d105      	bne.n	80176da <report_settings_detail+0x66a>
                    hal.stream.write("mask");
 80176ce:	4b53      	ldr	r3, [pc, #332]	; (801781c <report_settings_detail+0x7ac>)
 80176d0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80176d4:	4857      	ldr	r0, [pc, #348]	; (8017834 <report_settings_detail+0x7c4>)
 80176d6:	4798      	blx	r3
 80176d8:	e012      	b.n	8017700 <report_settings_detail+0x690>
                else if(setting->datatype == Format_Bool)
 80176da:	68bb      	ldr	r3, [r7, #8]
 80176dc:	7b1b      	ldrb	r3, [r3, #12]
 80176de:	2b00      	cmp	r3, #0
 80176e0:	d105      	bne.n	80176ee <report_settings_detail+0x67e>
                    hal.stream.write("boolean");
 80176e2:	4b4e      	ldr	r3, [pc, #312]	; (801781c <report_settings_detail+0x7ac>)
 80176e4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80176e8:	4853      	ldr	r0, [pc, #332]	; (8017838 <report_settings_detail+0x7c8>)
 80176ea:	4798      	blx	r3
 80176ec:	e008      	b.n	8017700 <report_settings_detail+0x690>
                else if(setting->datatype == Format_RadioButtons)
 80176ee:	68bb      	ldr	r3, [r7, #8]
 80176f0:	7b1b      	ldrb	r3, [r3, #12]
 80176f2:	2b03      	cmp	r3, #3
 80176f4:	d104      	bne.n	8017700 <report_settings_detail+0x690>
                    hal.stream.write("integer");
 80176f6:	4b49      	ldr	r3, [pc, #292]	; (801781c <report_settings_detail+0x7ac>)
 80176f8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80176fc:	484f      	ldr	r0, [pc, #316]	; (801783c <report_settings_detail+0x7cc>)
 80176fe:	4798      	blx	r3

                hal.stream.write("\t");
 8017700:	4b46      	ldr	r3, [pc, #280]	; (801781c <report_settings_detail+0x7ac>)
 8017702:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017706:	484a      	ldr	r0, [pc, #296]	; (8017830 <report_settings_detail+0x7c0>)
 8017708:	4798      	blx	r3
                Format_IPv4,
                // For internal use only
                Format_Int8,
                Format_Int16,
    */
                switch(setting_datatype_to_external(setting->datatype)) {
 801770a:	68bb      	ldr	r3, [r7, #8]
 801770c:	7b1b      	ldrb	r3, [r3, #12]
 801770e:	4618      	mov	r0, r3
 8017710:	f003 ff98 	bl	801b644 <setting_datatype_to_external>
 8017714:	4603      	mov	r3, r0
 8017716:	2b09      	cmp	r3, #9
 8017718:	d84c      	bhi.n	80177b4 <report_settings_detail+0x744>
 801771a:	a201      	add	r2, pc, #4	; (adr r2, 8017720 <report_settings_detail+0x6b0>)
 801771c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017720:	08017761 	.word	0x08017761
 8017724:	0801776d 	.word	0x0801776d
 8017728:	08017779 	.word	0x08017779
 801772c:	08017785 	.word	0x08017785
 8017730:	0801776d 	.word	0x0801776d
 8017734:	08017749 	.word	0x08017749
 8017738:	08017755 	.word	0x08017755
 801773c:	0801779d 	.word	0x0801779d
 8017740:	080177a9 	.word	0x080177a9
 8017744:	08017791 	.word	0x08017791

                    case Format_Integer:
                        hal.stream.write("integer");
 8017748:	4b34      	ldr	r3, [pc, #208]	; (801781c <report_settings_detail+0x7ac>)
 801774a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801774e:	483b      	ldr	r0, [pc, #236]	; (801783c <report_settings_detail+0x7cc>)
 8017750:	4798      	blx	r3
                        break;
 8017752:	e030      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_Decimal:
                        hal.stream.write("float");
 8017754:	4b31      	ldr	r3, [pc, #196]	; (801781c <report_settings_detail+0x7ac>)
 8017756:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801775a:	4839      	ldr	r0, [pc, #228]	; (8017840 <report_settings_detail+0x7d0>)
 801775c:	4798      	blx	r3
                        break;
 801775e:	e02a      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_Bool:
                        hal.stream.write("bool");
 8017760:	4b2e      	ldr	r3, [pc, #184]	; (801781c <report_settings_detail+0x7ac>)
 8017762:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017766:	4837      	ldr	r0, [pc, #220]	; (8017844 <report_settings_detail+0x7d4>)
 8017768:	4798      	blx	r3
                        break;
 801776a:	e024      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_AxisMask:
                    case Format_Bitfield:
                        hal.stream.write("bitfield");
 801776c:	4b2b      	ldr	r3, [pc, #172]	; (801781c <report_settings_detail+0x7ac>)
 801776e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017772:	4835      	ldr	r0, [pc, #212]	; (8017848 <report_settings_detail+0x7d8>)
 8017774:	4798      	blx	r3
                        break;
 8017776:	e01e      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_XBitfield:
                        hal.stream.write("xbitfield");
 8017778:	4b28      	ldr	r3, [pc, #160]	; (801781c <report_settings_detail+0x7ac>)
 801777a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801777e:	4833      	ldr	r0, [pc, #204]	; (801784c <report_settings_detail+0x7dc>)
 8017780:	4798      	blx	r3
                        break;
 8017782:	e018      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_RadioButtons:
                        hal.stream.write("radiobuttons");
 8017784:	4b25      	ldr	r3, [pc, #148]	; (801781c <report_settings_detail+0x7ac>)
 8017786:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801778a:	4831      	ldr	r0, [pc, #196]	; (8017850 <report_settings_detail+0x7e0>)
 801778c:	4798      	blx	r3
                        break;
 801778e:	e012      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_IPv4:
                        hal.stream.write("ipv4");
 8017790:	4b22      	ldr	r3, [pc, #136]	; (801781c <report_settings_detail+0x7ac>)
 8017792:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017796:	482f      	ldr	r0, [pc, #188]	; (8017854 <report_settings_detail+0x7e4>)
 8017798:	4798      	blx	r3
                        break;
 801779a:	e00c      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_String:
                        hal.stream.write("string");
 801779c:	4b1f      	ldr	r3, [pc, #124]	; (801781c <report_settings_detail+0x7ac>)
 801779e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177a2:	482d      	ldr	r0, [pc, #180]	; (8017858 <report_settings_detail+0x7e8>)
 80177a4:	4798      	blx	r3
                        break;
 80177a6:	e006      	b.n	80177b6 <report_settings_detail+0x746>

                    case Format_Password:
                        hal.stream.write("password");
 80177a8:	4b1c      	ldr	r3, [pc, #112]	; (801781c <report_settings_detail+0x7ac>)
 80177aa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177ae:	482b      	ldr	r0, [pc, #172]	; (801785c <report_settings_detail+0x7ec>)
 80177b0:	4798      	blx	r3
                        break;
 80177b2:	e000      	b.n	80177b6 <report_settings_detail+0x746>

                    default:
                        break;
 80177b4:	bf00      	nop
                }

                hal.stream.write("\t");
 80177b6:	4b19      	ldr	r3, [pc, #100]	; (801781c <report_settings_detail+0x7ac>)
 80177b8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177bc:	481c      	ldr	r0, [pc, #112]	; (8017830 <report_settings_detail+0x7c0>)
 80177be:	4798      	blx	r3

                if(setting->format)
 80177c0:	68bb      	ldr	r3, [r7, #8]
 80177c2:	691b      	ldr	r3, [r3, #16]
 80177c4:	2b00      	cmp	r3, #0
 80177c6:	d007      	beq.n	80177d8 <report_settings_detail+0x768>
                    hal.stream.write(setting->format);
 80177c8:	4b14      	ldr	r3, [pc, #80]	; (801781c <report_settings_detail+0x7ac>)
 80177ca:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177ce:	68ba      	ldr	r2, [r7, #8]
 80177d0:	6912      	ldr	r2, [r2, #16]
 80177d2:	4610      	mov	r0, r2
 80177d4:	4798      	blx	r3
 80177d6:	e008      	b.n	80177ea <report_settings_detail+0x77a>
                else if (setting->datatype == Format_AxisMask)
 80177d8:	68bb      	ldr	r3, [r7, #8]
 80177da:	7b1b      	ldrb	r3, [r3, #12]
 80177dc:	2b04      	cmp	r3, #4
 80177de:	d104      	bne.n	80177ea <report_settings_detail+0x77a>
                    hal.stream.write("axes");
 80177e0:	4b0e      	ldr	r3, [pc, #56]	; (801781c <report_settings_detail+0x7ac>)
 80177e2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177e6:	481e      	ldr	r0, [pc, #120]	; (8017860 <report_settings_detail+0x7f0>)
 80177e8:	4798      	blx	r3

                hal.stream.write("\t");
 80177ea:	4b0c      	ldr	r3, [pc, #48]	; (801781c <report_settings_detail+0x7ac>)
 80177ec:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80177f0:	480f      	ldr	r0, [pc, #60]	; (8017830 <report_settings_detail+0x7c0>)
 80177f2:	4798      	blx	r3

    #ifndef NO_SETTINGS_DESCRIPTIONS
                const char *description = setting_get_description((setting_id_t)(setting->id + offset));
 80177f4:	68bb      	ldr	r3, [r7, #8]
 80177f6:	881a      	ldrh	r2, [r3, #0]
 80177f8:	687b      	ldr	r3, [r7, #4]
 80177fa:	b29b      	uxth	r3, r3
 80177fc:	4413      	add	r3, r2
 80177fe:	b29b      	uxth	r3, r3
 8017800:	4618      	mov	r0, r3
 8017802:	f003 fdaf 	bl	801b364 <setting_get_description>
 8017806:	6178      	str	r0, [r7, #20]
                hal.stream.write(description ? description : "");
 8017808:	4b04      	ldr	r3, [pc, #16]	; (801781c <report_settings_detail+0x7ac>)
 801780a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 801780e:	697b      	ldr	r3, [r7, #20]
 8017810:	2b00      	cmp	r3, #0
 8017812:	d027      	beq.n	8017864 <report_settings_detail+0x7f4>
 8017814:	697b      	ldr	r3, [r7, #20]
 8017816:	e026      	b.n	8017866 <report_settings_detail+0x7f6>
 8017818:	0802b184 	.word	0x0802b184
 801781c:	20000ed0 	.word	0x20000ed0
 8017820:	0802b690 	.word	0x0802b690
 8017824:	0803102c 	.word	0x0803102c
 8017828:	0802b7cc 	.word	0x0802b7cc
 801782c:	0802b1c4 	.word	0x0802b1c4
 8017830:	0802b7d0 	.word	0x0802b7d0
 8017834:	0802b7d4 	.word	0x0802b7d4
 8017838:	0802b7dc 	.word	0x0802b7dc
 801783c:	0802b7e4 	.word	0x0802b7e4
 8017840:	0802b7ec 	.word	0x0802b7ec
 8017844:	0802b7f4 	.word	0x0802b7f4
 8017848:	0802b7fc 	.word	0x0802b7fc
 801784c:	0802b808 	.word	0x0802b808
 8017850:	0802b814 	.word	0x0802b814
 8017854:	0802b824 	.word	0x0802b824
 8017858:	0802b82c 	.word	0x0802b82c
 801785c:	0802b834 	.word	0x0802b834
 8017860:	0802b840 	.word	0x0802b840
 8017864:	4b36      	ldr	r3, [pc, #216]	; (8017940 <report_settings_detail+0x8d0>)
 8017866:	4618      	mov	r0, r3
 8017868:	4790      	blx	r2
                if(setting->flags.reboot_required)
 801786a:	68bb      	ldr	r3, [r7, #8]
 801786c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017870:	f003 0301 	and.w	r3, r3, #1
 8017874:	b2db      	uxtb	r3, r3
 8017876:	2b00      	cmp	r3, #0
 8017878:	d00e      	beq.n	8017898 <report_settings_detail+0x828>
                    hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 801787a:	4b32      	ldr	r3, [pc, #200]	; (8017944 <report_settings_detail+0x8d4>)
 801787c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017880:	697a      	ldr	r2, [r7, #20]
 8017882:	2a00      	cmp	r2, #0
 8017884:	d005      	beq.n	8017892 <report_settings_detail+0x822>
 8017886:	697a      	ldr	r2, [r7, #20]
 8017888:	7812      	ldrb	r2, [r2, #0]
 801788a:	2a00      	cmp	r2, #0
 801788c:	d001      	beq.n	8017892 <report_settings_detail+0x822>
 801788e:	4a2e      	ldr	r2, [pc, #184]	; (8017948 <report_settings_detail+0x8d8>)
 8017890:	e000      	b.n	8017894 <report_settings_detail+0x824>
 8017892:	4a2e      	ldr	r2, [pc, #184]	; (801794c <report_settings_detail+0x8dc>)
 8017894:	4610      	mov	r0, r2
 8017896:	4798      	blx	r3
    #endif
                hal.stream.write("\t");
 8017898:	4b2a      	ldr	r3, [pc, #168]	; (8017944 <report_settings_detail+0x8d4>)
 801789a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801789e:	482c      	ldr	r0, [pc, #176]	; (8017950 <report_settings_detail+0x8e0>)
 80178a0:	4798      	blx	r3

                if(setting->min_value)
 80178a2:	68bb      	ldr	r3, [r7, #8]
 80178a4:	695b      	ldr	r3, [r3, #20]
 80178a6:	2b00      	cmp	r3, #0
 80178a8:	d006      	beq.n	80178b8 <report_settings_detail+0x848>
                    hal.stream.write(setting->min_value);
 80178aa:	4b26      	ldr	r3, [pc, #152]	; (8017944 <report_settings_detail+0x8d4>)
 80178ac:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80178b0:	68ba      	ldr	r2, [r7, #8]
 80178b2:	6952      	ldr	r2, [r2, #20]
 80178b4:	4610      	mov	r0, r2
 80178b6:	4798      	blx	r3

                hal.stream.write("\t");
 80178b8:	4b22      	ldr	r3, [pc, #136]	; (8017944 <report_settings_detail+0x8d4>)
 80178ba:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80178be:	4824      	ldr	r0, [pc, #144]	; (8017950 <report_settings_detail+0x8e0>)
 80178c0:	4798      	blx	r3

                if(setting->max_value)
 80178c2:	68bb      	ldr	r3, [r7, #8]
 80178c4:	699b      	ldr	r3, [r3, #24]
 80178c6:	2b00      	cmp	r3, #0
 80178c8:	d006      	beq.n	80178d8 <report_settings_detail+0x868>
                    hal.stream.write(setting->max_value);
 80178ca:	4b1e      	ldr	r3, [pc, #120]	; (8017944 <report_settings_detail+0x8d4>)
 80178cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80178d0:	68ba      	ldr	r2, [r7, #8]
 80178d2:	6992      	ldr	r2, [r2, #24]
 80178d4:	4610      	mov	r0, r2
 80178d6:	4798      	blx	r3

                hal.stream.write("\t");
 80178d8:	4b1a      	ldr	r3, [pc, #104]	; (8017944 <report_settings_detail+0x8d4>)
 80178da:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80178de:	481c      	ldr	r0, [pc, #112]	; (8017950 <report_settings_detail+0x8e0>)
 80178e0:	4798      	blx	r3
                hal.stream.write(uitoa(setting->flags.reboot_required));
 80178e2:	4b18      	ldr	r3, [pc, #96]	; (8017944 <report_settings_detail+0x8d4>)
 80178e4:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80178e8:	68bb      	ldr	r3, [r7, #8]
 80178ea:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80178ee:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80178f2:	b2db      	uxtb	r3, r3
 80178f4:	4618      	mov	r0, r3
 80178f6:	f7f8 fcc9 	bl	801028c <uitoa>
 80178fa:	4603      	mov	r3, r0
 80178fc:	4618      	mov	r0, r3
 80178fe:	47a0      	blx	r4
                hal.stream.write("\t");
 8017900:	4b10      	ldr	r3, [pc, #64]	; (8017944 <report_settings_detail+0x8d4>)
 8017902:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017906:	4812      	ldr	r0, [pc, #72]	; (8017950 <report_settings_detail+0x8e0>)
 8017908:	4798      	blx	r3
                hal.stream.write(uitoa(setting->flags.allow_null));
 801790a:	4b0e      	ldr	r3, [pc, #56]	; (8017944 <report_settings_detail+0x8d4>)
 801790c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017910:	68bb      	ldr	r3, [r7, #8]
 8017912:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017916:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801791a:	b2db      	uxtb	r3, r3
 801791c:	4618      	mov	r0, r3
 801791e:	f7f8 fcb5 	bl	801028c <uitoa>
 8017922:	4603      	mov	r3, r0
 8017924:	4618      	mov	r0, r3
 8017926:	47a0      	blx	r4
            }
            break;
 8017928:	e000      	b.n	801792c <report_settings_detail+0x8bc>
            break;
 801792a:	bf00      	nop
    }

    hal.stream.write(ASCII_EOL);
 801792c:	4b05      	ldr	r3, [pc, #20]	; (8017944 <report_settings_detail+0x8d4>)
 801792e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017932:	4808      	ldr	r0, [pc, #32]	; (8017954 <report_settings_detail+0x8e4>)
 8017934:	4798      	blx	r3
}
 8017936:	bf00      	nop
 8017938:	372c      	adds	r7, #44	; 0x2c
 801793a:	46bd      	mov	sp, r7
 801793c:	bd90      	pop	{r4, r7, pc}
 801793e:	bf00      	nop
 8017940:	0802b1c4 	.word	0x0802b1c4
 8017944:	20000ed0 	.word	0x20000ed0
 8017948:	0802b768 	.word	0x0802b768
 801794c:	0802b76c 	.word	0x0802b76c
 8017950:	0802b7d0 	.word	0x0802b7d0
 8017954:	0802b190 	.word	0x0802b190

08017958 <print_sorted>:
    setting_group_t group;
    uint_fast16_t offset;
} report_args_t;

static bool print_sorted (const setting_detail_t *setting, uint_fast16_t offset, void *args)
{
 8017958:	b580      	push	{r7, lr}
 801795a:	b084      	sub	sp, #16
 801795c:	af00      	add	r7, sp, #0
 801795e:	60f8      	str	r0, [r7, #12]
 8017960:	60b9      	str	r1, [r7, #8]
 8017962:	607a      	str	r2, [r7, #4]
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset))
 8017964:	687b      	ldr	r3, [r7, #4]
 8017966:	785a      	ldrb	r2, [r3, #1]
 8017968:	68fb      	ldr	r3, [r7, #12]
 801796a:	789b      	ldrb	r3, [r3, #2]
 801796c:	429a      	cmp	r2, r3
 801796e:	d104      	bne.n	801797a <print_sorted+0x22>
 8017970:	687b      	ldr	r3, [r7, #4]
 8017972:	685b      	ldr	r3, [r3, #4]
 8017974:	68ba      	ldr	r2, [r7, #8]
 8017976:	429a      	cmp	r2, r3
 8017978:	d106      	bne.n	8017988 <print_sorted+0x30>
        report_settings_detail (((report_args_t *)args)->format, setting, offset);
 801797a:	687b      	ldr	r3, [r7, #4]
 801797c:	781b      	ldrb	r3, [r3, #0]
 801797e:	68ba      	ldr	r2, [r7, #8]
 8017980:	68f9      	ldr	r1, [r7, #12]
 8017982:	4618      	mov	r0, r3
 8017984:	f7ff fb74 	bl	8017070 <report_settings_detail>

    return true;
 8017988:	2301      	movs	r3, #1
}
 801798a:	4618      	mov	r0, r3
 801798c:	3710      	adds	r7, #16
 801798e:	46bd      	mov	sp, r7
 8017990:	bd80      	pop	{r7, pc}

08017992 <print_unsorted>:

static bool print_unsorted (const setting_detail_t *setting, uint_fast16_t offset, void *args)
{
 8017992:	b580      	push	{r7, lr}
 8017994:	b084      	sub	sp, #16
 8017996:	af00      	add	r7, sp, #0
 8017998:	60f8      	str	r0, [r7, #12]
 801799a:	60b9      	str	r1, [r7, #8]
 801799c:	607a      	str	r2, [r7, #4]
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset) &&
 801799e:	687b      	ldr	r3, [r7, #4]
 80179a0:	785a      	ldrb	r2, [r3, #1]
 80179a2:	68fb      	ldr	r3, [r7, #12]
 80179a4:	789b      	ldrb	r3, [r3, #2]
 80179a6:	429a      	cmp	r2, r3
 80179a8:	d104      	bne.n	80179b4 <print_unsorted+0x22>
 80179aa:	687b      	ldr	r3, [r7, #4]
 80179ac:	685b      	ldr	r3, [r3, #4]
 80179ae:	68ba      	ldr	r2, [r7, #8]
 80179b0:	429a      	cmp	r2, r3
 80179b2:	d111      	bne.n	80179d8 <print_unsorted+0x46>
       (setting->is_available == NULL ||setting->is_available(setting)))
 80179b4:	68fb      	ldr	r3, [r7, #12]
 80179b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    if(!(((report_args_t *)args)->group == setting->group && ((report_args_t *)args)->offset != offset) &&
 80179b8:	2b00      	cmp	r3, #0
 80179ba:	d006      	beq.n	80179ca <print_unsorted+0x38>
       (setting->is_available == NULL ||setting->is_available(setting)))
 80179bc:	68fb      	ldr	r3, [r7, #12]
 80179be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80179c0:	68f8      	ldr	r0, [r7, #12]
 80179c2:	4798      	blx	r3
 80179c4:	4603      	mov	r3, r0
 80179c6:	2b00      	cmp	r3, #0
 80179c8:	d006      	beq.n	80179d8 <print_unsorted+0x46>
        report_settings_detail(((report_args_t *)args)->format, setting, offset);
 80179ca:	687b      	ldr	r3, [r7, #4]
 80179cc:	781b      	ldrb	r3, [r3, #0]
 80179ce:	68ba      	ldr	r2, [r7, #8]
 80179d0:	68f9      	ldr	r1, [r7, #12]
 80179d2:	4618      	mov	r0, r3
 80179d4:	f7ff fb4c 	bl	8017070 <report_settings_detail>

    return true;
 80179d8:	2301      	movs	r3, #1
}
 80179da:	4618      	mov	r0, r3
 80179dc:	3710      	adds	r7, #16
 80179de:	46bd      	mov	sp, r7
 80179e0:	bd80      	pop	{r7, pc}
	...

080179e4 <print_settings_details>:

static status_code_t print_settings_details (settings_format_t format, setting_group_t group)
{
 80179e4:	b580      	push	{r7, lr}
 80179e6:	b08c      	sub	sp, #48	; 0x30
 80179e8:	af00      	add	r7, sp, #0
 80179ea:	4603      	mov	r3, r0
 80179ec:	460a      	mov	r2, r1
 80179ee:	71fb      	strb	r3, [r7, #7]
 80179f0:	4613      	mov	r3, r2
 80179f2:	71bb      	strb	r3, [r7, #6]
    uint_fast16_t idx, n_settings = 0;
 80179f4:	2300      	movs	r3, #0
 80179f6:	62bb      	str	r3, [r7, #40]	; 0x28
    bool reported = group == Group_All;
 80179f8:	79bb      	ldrb	r3, [r7, #6]
 80179fa:	2b00      	cmp	r3, #0
 80179fc:	bf0c      	ite	eq
 80179fe:	2301      	moveq	r3, #1
 8017a00:	2300      	movne	r3, #0
 8017a02:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    const setting_detail_t *setting;
    report_args_t args;
    setting_detail_t **all_settings, **psetting;
    setting_details_t *details = settings_get_details();
 8017a06:	f001 f989 	bl	8018d1c <settings_get_details>
 8017a0a:	61f8      	str	r0, [r7, #28]

    args.group = settings_normalize_group(group);
 8017a0c:	79bb      	ldrb	r3, [r7, #6]
 8017a0e:	4618      	mov	r0, r3
 8017a10:	f003 fb8e 	bl	801b130 <settings_normalize_group>
 8017a14:	4603      	mov	r3, r0
 8017a16:	737b      	strb	r3, [r7, #13]
    args.offset = group - args.group;
 8017a18:	79bb      	ldrb	r3, [r7, #6]
 8017a1a:	7b7a      	ldrb	r2, [r7, #13]
 8017a1c:	1a9b      	subs	r3, r3, r2
 8017a1e:	613b      	str	r3, [r7, #16]
    args.format = format;
 8017a20:	79fb      	ldrb	r3, [r7, #7]
 8017a22:	733b      	strb	r3, [r7, #12]

    do {
        n_settings += details->n_settings;
 8017a24:	69fb      	ldr	r3, [r7, #28]
 8017a26:	891b      	ldrh	r3, [r3, #8]
 8017a28:	461a      	mov	r2, r3
 8017a2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017a2c:	4413      	add	r3, r2
 8017a2e:	62bb      	str	r3, [r7, #40]	; 0x28
    } while((details = details->next));
 8017a30:	69fb      	ldr	r3, [r7, #28]
 8017a32:	699b      	ldr	r3, [r3, #24]
 8017a34:	61fb      	str	r3, [r7, #28]
 8017a36:	69fb      	ldr	r3, [r7, #28]
 8017a38:	2b00      	cmp	r3, #0
 8017a3a:	d1f3      	bne.n	8017a24 <print_settings_details+0x40>

    if(format == SettingsFormat_Grbl)
 8017a3c:	79fb      	ldrb	r3, [r7, #7]
 8017a3e:	2b02      	cmp	r3, #2
 8017a40:	d105      	bne.n	8017a4e <print_settings_details+0x6a>
        hal.stream.write("\"$-Code\",\" Setting\",\" Units\",\" Setting Description\"" ASCII_EOL);
 8017a42:	4b5a      	ldr	r3, [pc, #360]	; (8017bac <print_settings_details+0x1c8>)
 8017a44:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017a48:	4859      	ldr	r0, [pc, #356]	; (8017bb0 <print_settings_details+0x1cc>)
 8017a4a:	4798      	blx	r3
 8017a4c:	e007      	b.n	8017a5e <print_settings_details+0x7a>
    else if(format == SettingsFormat_grblHAL)
 8017a4e:	79fb      	ldrb	r3, [r7, #7]
 8017a50:	2b03      	cmp	r3, #3
 8017a52:	d104      	bne.n	8017a5e <print_settings_details+0x7a>
        hal.stream.write("$-Code\tSetting\tUnits\tDatatype\tData format\tSetting Description\tMin\tMax" ASCII_EOL);
 8017a54:	4b55      	ldr	r3, [pc, #340]	; (8017bac <print_settings_details+0x1c8>)
 8017a56:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017a5a:	4856      	ldr	r0, [pc, #344]	; (8017bb4 <print_settings_details+0x1d0>)
 8017a5c:	4798      	blx	r3

    details = settings_get_details();
 8017a5e:	f001 f95d 	bl	8018d1c <settings_get_details>
 8017a62:	61f8      	str	r0, [r7, #28]

    if((all_settings = psetting = calloc(n_settings, sizeof(setting_detail_t *)))) {
 8017a64:	2104      	movs	r1, #4
 8017a66:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8017a68:	f00b fcf0 	bl	802344c <calloc>
 8017a6c:	4603      	mov	r3, r0
 8017a6e:	623b      	str	r3, [r7, #32]
 8017a70:	6a3b      	ldr	r3, [r7, #32]
 8017a72:	61bb      	str	r3, [r7, #24]
 8017a74:	69bb      	ldr	r3, [r7, #24]
 8017a76:	2b00      	cmp	r3, #0
 8017a78:	d05c      	beq.n	8017b34 <print_settings_details+0x150>

        n_settings = 0;
 8017a7a:	2300      	movs	r3, #0
 8017a7c:	62bb      	str	r3, [r7, #40]	; 0x28

        do {
            for(idx = 0; idx < details->n_settings; idx++) {
 8017a7e:	2300      	movs	r3, #0
 8017a80:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017a82:	e026      	b.n	8017ad2 <print_settings_details+0xee>
                setting = &details->settings[idx];
 8017a84:	69fb      	ldr	r3, [r7, #28]
 8017a86:	68d9      	ldr	r1, [r3, #12]
 8017a88:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017a8a:	4613      	mov	r3, r2
 8017a8c:	005b      	lsls	r3, r3, #1
 8017a8e:	4413      	add	r3, r2
 8017a90:	011b      	lsls	r3, r3, #4
 8017a92:	440b      	add	r3, r1
 8017a94:	617b      	str	r3, [r7, #20]
                if((group == Group_All || setting->group == args.group) && (setting->is_available == NULL || setting->is_available(setting))) {
 8017a96:	79bb      	ldrb	r3, [r7, #6]
 8017a98:	2b00      	cmp	r3, #0
 8017a9a:	d004      	beq.n	8017aa6 <print_settings_details+0xc2>
 8017a9c:	697b      	ldr	r3, [r7, #20]
 8017a9e:	789a      	ldrb	r2, [r3, #2]
 8017aa0:	7b7b      	ldrb	r3, [r7, #13]
 8017aa2:	429a      	cmp	r2, r3
 8017aa4:	d112      	bne.n	8017acc <print_settings_details+0xe8>
 8017aa6:	697b      	ldr	r3, [r7, #20]
 8017aa8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017aaa:	2b00      	cmp	r3, #0
 8017aac:	d006      	beq.n	8017abc <print_settings_details+0xd8>
 8017aae:	697b      	ldr	r3, [r7, #20]
 8017ab0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8017ab2:	6978      	ldr	r0, [r7, #20]
 8017ab4:	4798      	blx	r3
 8017ab6:	4603      	mov	r3, r0
 8017ab8:	2b00      	cmp	r3, #0
 8017aba:	d007      	beq.n	8017acc <print_settings_details+0xe8>
                    *psetting++ = (setting_detail_t *)setting;
 8017abc:	6a3b      	ldr	r3, [r7, #32]
 8017abe:	1d1a      	adds	r2, r3, #4
 8017ac0:	623a      	str	r2, [r7, #32]
 8017ac2:	697a      	ldr	r2, [r7, #20]
 8017ac4:	601a      	str	r2, [r3, #0]
                    n_settings++;
 8017ac6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017ac8:	3301      	adds	r3, #1
 8017aca:	62bb      	str	r3, [r7, #40]	; 0x28
            for(idx = 0; idx < details->n_settings; idx++) {
 8017acc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017ace:	3301      	adds	r3, #1
 8017ad0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017ad2:	69fb      	ldr	r3, [r7, #28]
 8017ad4:	891b      	ldrh	r3, [r3, #8]
 8017ad6:	461a      	mov	r2, r3
 8017ad8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017ada:	4293      	cmp	r3, r2
 8017adc:	d3d2      	bcc.n	8017a84 <print_settings_details+0xa0>
                }
            }
        } while((details = details->next));
 8017ade:	69fb      	ldr	r3, [r7, #28]
 8017ae0:	699b      	ldr	r3, [r3, #24]
 8017ae2:	61fb      	str	r3, [r7, #28]
 8017ae4:	69fb      	ldr	r3, [r7, #28]
 8017ae6:	2b00      	cmp	r3, #0
 8017ae8:	d1c9      	bne.n	8017a7e <print_settings_details+0x9a>

        qsort(all_settings, n_settings, sizeof(setting_detail_t *), cmp_settings);
 8017aea:	4b33      	ldr	r3, [pc, #204]	; (8017bb8 <print_settings_details+0x1d4>)
 8017aec:	2204      	movs	r2, #4
 8017aee:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8017af0:	69b8      	ldr	r0, [r7, #24]
 8017af2:	f00b fe17 	bl	8023724 <qsort>

        for(idx = 0; idx < n_settings; idx++) {
 8017af6:	2300      	movs	r3, #0
 8017af8:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017afa:	e013      	b.n	8017b24 <print_settings_details+0x140>
            if(settings_iterator(all_settings[idx], print_sorted, &args))
 8017afc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017afe:	009b      	lsls	r3, r3, #2
 8017b00:	69ba      	ldr	r2, [r7, #24]
 8017b02:	4413      	add	r3, r2
 8017b04:	681b      	ldr	r3, [r3, #0]
 8017b06:	f107 020c 	add.w	r2, r7, #12
 8017b0a:	492c      	ldr	r1, [pc, #176]	; (8017bbc <print_settings_details+0x1d8>)
 8017b0c:	4618      	mov	r0, r3
 8017b0e:	f003 fb23 	bl	801b158 <settings_iterator>
 8017b12:	4603      	mov	r3, r0
 8017b14:	2b00      	cmp	r3, #0
 8017b16:	d002      	beq.n	8017b1e <print_settings_details+0x13a>
                reported = true;
 8017b18:	2301      	movs	r3, #1
 8017b1a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        for(idx = 0; idx < n_settings; idx++) {
 8017b1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017b20:	3301      	adds	r3, #1
 8017b22:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017b24:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017b26:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017b28:	429a      	cmp	r2, r3
 8017b2a:	d3e7      	bcc.n	8017afc <print_settings_details+0x118>
        }

        free(all_settings);
 8017b2c:	69b8      	ldr	r0, [r7, #24]
 8017b2e:	f00b fccb 	bl	80234c8 <free>
 8017b32:	e02f      	b.n	8017b94 <print_settings_details+0x1b0>

    } else do {
        for(idx = 0; idx < details->n_settings; idx++) {
 8017b34:	2300      	movs	r3, #0
 8017b36:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017b38:	e020      	b.n	8017b7c <print_settings_details+0x198>

            setting = &details->settings[idx];
 8017b3a:	69fb      	ldr	r3, [r7, #28]
 8017b3c:	68d9      	ldr	r1, [r3, #12]
 8017b3e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8017b40:	4613      	mov	r3, r2
 8017b42:	005b      	lsls	r3, r3, #1
 8017b44:	4413      	add	r3, r2
 8017b46:	011b      	lsls	r3, r3, #4
 8017b48:	440b      	add	r3, r1
 8017b4a:	617b      	str	r3, [r7, #20]

            if(group == Group_All || setting->group == args.group) {
 8017b4c:	79bb      	ldrb	r3, [r7, #6]
 8017b4e:	2b00      	cmp	r3, #0
 8017b50:	d004      	beq.n	8017b5c <print_settings_details+0x178>
 8017b52:	697b      	ldr	r3, [r7, #20]
 8017b54:	789a      	ldrb	r2, [r3, #2]
 8017b56:	7b7b      	ldrb	r3, [r7, #13]
 8017b58:	429a      	cmp	r2, r3
 8017b5a:	d10c      	bne.n	8017b76 <print_settings_details+0x192>
                if(settings_iterator(setting, print_unsorted, &args))
 8017b5c:	f107 030c 	add.w	r3, r7, #12
 8017b60:	461a      	mov	r2, r3
 8017b62:	4917      	ldr	r1, [pc, #92]	; (8017bc0 <print_settings_details+0x1dc>)
 8017b64:	6978      	ldr	r0, [r7, #20]
 8017b66:	f003 faf7 	bl	801b158 <settings_iterator>
 8017b6a:	4603      	mov	r3, r0
 8017b6c:	2b00      	cmp	r3, #0
 8017b6e:	d002      	beq.n	8017b76 <print_settings_details+0x192>
                    reported = true;
 8017b70:	2301      	movs	r3, #1
 8017b72:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        for(idx = 0; idx < details->n_settings; idx++) {
 8017b76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017b78:	3301      	adds	r3, #1
 8017b7a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8017b7c:	69fb      	ldr	r3, [r7, #28]
 8017b7e:	891b      	ldrh	r3, [r3, #8]
 8017b80:	461a      	mov	r2, r3
 8017b82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017b84:	4293      	cmp	r3, r2
 8017b86:	d3d8      	bcc.n	8017b3a <print_settings_details+0x156>
            }
        }
    } while((details = details->next));
 8017b88:	69fb      	ldr	r3, [r7, #28]
 8017b8a:	699b      	ldr	r3, [r3, #24]
 8017b8c:	61fb      	str	r3, [r7, #28]
 8017b8e:	69fb      	ldr	r3, [r7, #28]
 8017b90:	2b00      	cmp	r3, #0
 8017b92:	d1cf      	bne.n	8017b34 <print_settings_details+0x150>

    return reported ? Status_OK : Status_SettingDisabled;
 8017b94:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8017b98:	2b00      	cmp	r3, #0
 8017b9a:	d001      	beq.n	8017ba0 <print_settings_details+0x1bc>
 8017b9c:	2300      	movs	r3, #0
 8017b9e:	e000      	b.n	8017ba2 <print_settings_details+0x1be>
 8017ba0:	2335      	movs	r3, #53	; 0x35
}
 8017ba2:	4618      	mov	r0, r3
 8017ba4:	3730      	adds	r7, #48	; 0x30
 8017ba6:	46bd      	mov	sp, r7
 8017ba8:	bd80      	pop	{r7, pc}
 8017baa:	bf00      	nop
 8017bac:	20000ed0 	.word	0x20000ed0
 8017bb0:	0802b848 	.word	0x0802b848
 8017bb4:	0802b880 	.word	0x0802b880
 8017bb8:	08014885 	.word	0x08014885
 8017bbc:	08017959 	.word	0x08017959
 8017bc0:	08017993 	.word	0x08017993

08017bc4 <report_settings_details>:

status_code_t report_settings_details (settings_format_t format, setting_id_t id, setting_group_t group)
{
 8017bc4:	b580      	push	{r7, lr}
 8017bc6:	b084      	sub	sp, #16
 8017bc8:	af00      	add	r7, sp, #0
 8017bca:	4603      	mov	r3, r0
 8017bcc:	71fb      	strb	r3, [r7, #7]
 8017bce:	460b      	mov	r3, r1
 8017bd0:	80bb      	strh	r3, [r7, #4]
 8017bd2:	4613      	mov	r3, r2
 8017bd4:	71bb      	strb	r3, [r7, #6]
    if(id != Setting_SettingsAll) {
 8017bd6:	88bb      	ldrh	r3, [r7, #4]
 8017bd8:	f240 22e5 	movw	r2, #741	; 0x2e5
 8017bdc:	4293      	cmp	r3, r2
 8017bde:	d019      	beq.n	8017c14 <report_settings_details+0x50>
        status_code_t status = Status_OK;
 8017be0:	2300      	movs	r3, #0
 8017be2:	73fb      	strb	r3, [r7, #15]

        const setting_detail_t *setting = setting_get_details(id, NULL);
 8017be4:	88bb      	ldrh	r3, [r7, #4]
 8017be6:	2100      	movs	r1, #0
 8017be8:	4618      	mov	r0, r3
 8017bea:	f003 fb15 	bl	801b218 <setting_get_details>
 8017bee:	60b8      	str	r0, [r7, #8]

        if(setting)
 8017bf0:	68bb      	ldr	r3, [r7, #8]
 8017bf2:	2b00      	cmp	r3, #0
 8017bf4:	d00a      	beq.n	8017c0c <report_settings_details+0x48>
            report_settings_detail(format, setting, id - setting->id);
 8017bf6:	88bb      	ldrh	r3, [r7, #4]
 8017bf8:	68ba      	ldr	r2, [r7, #8]
 8017bfa:	8812      	ldrh	r2, [r2, #0]
 8017bfc:	1a9b      	subs	r3, r3, r2
 8017bfe:	461a      	mov	r2, r3
 8017c00:	79fb      	ldrb	r3, [r7, #7]
 8017c02:	68b9      	ldr	r1, [r7, #8]
 8017c04:	4618      	mov	r0, r3
 8017c06:	f7ff fa33 	bl	8017070 <report_settings_detail>
 8017c0a:	e001      	b.n	8017c10 <report_settings_details+0x4c>
        else
            status = Status_SettingDisabled;
 8017c0c:	2335      	movs	r3, #53	; 0x35
 8017c0e:	73fb      	strb	r3, [r7, #15]

        return status;
 8017c10:	7bfb      	ldrb	r3, [r7, #15]
 8017c12:	e006      	b.n	8017c22 <report_settings_details+0x5e>
    }

    return print_settings_details(format, group);
 8017c14:	79ba      	ldrb	r2, [r7, #6]
 8017c16:	79fb      	ldrb	r3, [r7, #7]
 8017c18:	4611      	mov	r1, r2
 8017c1a:	4618      	mov	r0, r3
 8017c1c:	f7ff fee2 	bl	80179e4 <print_settings_details>
 8017c20:	4603      	mov	r3, r0
}
 8017c22:	4618      	mov	r0, r3
 8017c24:	3710      	adds	r7, #16
 8017c26:	46bd      	mov	sp, r7
 8017c28:	bd80      	pop	{r7, pc}
	...

08017c2c <report_setting_description>:

#ifndef NO_SETTINGS_DESCRIPTIONS

status_code_t report_setting_description (settings_format_t format, setting_id_t id)
{
 8017c2c:	b590      	push	{r4, r7, lr}
 8017c2e:	b085      	sub	sp, #20
 8017c30:	af00      	add	r7, sp, #0
 8017c32:	4603      	mov	r3, r0
 8017c34:	460a      	mov	r2, r1
 8017c36:	71fb      	strb	r3, [r7, #7]
 8017c38:	4613      	mov	r3, r2
 8017c3a:	80bb      	strh	r3, [r7, #4]
    const setting_detail_t *setting = setting_get_details(id, NULL);
 8017c3c:	88bb      	ldrh	r3, [r7, #4]
 8017c3e:	2100      	movs	r1, #0
 8017c40:	4618      	mov	r0, r3
 8017c42:	f003 fae9 	bl	801b218 <setting_get_details>
 8017c46:	60f8      	str	r0, [r7, #12]
    const char *description = setting_get_description(id);
 8017c48:	88bb      	ldrh	r3, [r7, #4]
 8017c4a:	4618      	mov	r0, r3
 8017c4c:	f003 fb8a 	bl	801b364 <setting_get_description>
 8017c50:	60b8      	str	r0, [r7, #8]

    if(format == SettingsFormat_MachineReadable) {
 8017c52:	79fb      	ldrb	r3, [r7, #7]
 8017c54:	2b00      	cmp	r3, #0
 8017c56:	d113      	bne.n	8017c80 <report_setting_description+0x54>
        hal.stream.write("[SETTINGDESCR:");
 8017c58:	4b25      	ldr	r3, [pc, #148]	; (8017cf0 <report_setting_description+0xc4>)
 8017c5a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017c5e:	4825      	ldr	r0, [pc, #148]	; (8017cf4 <report_setting_description+0xc8>)
 8017c60:	4798      	blx	r3
        hal.stream.write(uitoa(id));
 8017c62:	4b23      	ldr	r3, [pc, #140]	; (8017cf0 <report_setting_description+0xc4>)
 8017c64:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017c68:	88bb      	ldrh	r3, [r7, #4]
 8017c6a:	4618      	mov	r0, r3
 8017c6c:	f7f8 fb0e 	bl	801028c <uitoa>
 8017c70:	4603      	mov	r3, r0
 8017c72:	4618      	mov	r0, r3
 8017c74:	47a0      	blx	r4
        hal.stream.write(vbar);
 8017c76:	4b1e      	ldr	r3, [pc, #120]	; (8017cf0 <report_setting_description+0xc4>)
 8017c78:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017c7c:	481e      	ldr	r0, [pc, #120]	; (8017cf8 <report_setting_description+0xcc>)
 8017c7e:	4798      	blx	r3
    }
//    hal.stream.write(description == NULL ? (is_setting_available(setting_get_details(id, NULL)) ? "" : "N/A") : description); // TODO?
    hal.stream.write(description ? description : (setting ? "" : "N/A"));
 8017c80:	4b1b      	ldr	r3, [pc, #108]	; (8017cf0 <report_setting_description+0xc4>)
 8017c82:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 8017c86:	68bb      	ldr	r3, [r7, #8]
 8017c88:	2b00      	cmp	r3, #0
 8017c8a:	d106      	bne.n	8017c9a <report_setting_description+0x6e>
 8017c8c:	68fb      	ldr	r3, [r7, #12]
 8017c8e:	2b00      	cmp	r3, #0
 8017c90:	d001      	beq.n	8017c96 <report_setting_description+0x6a>
 8017c92:	4b1a      	ldr	r3, [pc, #104]	; (8017cfc <report_setting_description+0xd0>)
 8017c94:	e002      	b.n	8017c9c <report_setting_description+0x70>
 8017c96:	4b1a      	ldr	r3, [pc, #104]	; (8017d00 <report_setting_description+0xd4>)
 8017c98:	e000      	b.n	8017c9c <report_setting_description+0x70>
 8017c9a:	68bb      	ldr	r3, [r7, #8]
 8017c9c:	4618      	mov	r0, r3
 8017c9e:	4790      	blx	r2
    if(setting && setting->flags.reboot_required)
 8017ca0:	68fb      	ldr	r3, [r7, #12]
 8017ca2:	2b00      	cmp	r3, #0
 8017ca4:	d016      	beq.n	8017cd4 <report_setting_description+0xa8>
 8017ca6:	68fb      	ldr	r3, [r7, #12]
 8017ca8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8017cac:	f003 0301 	and.w	r3, r3, #1
 8017cb0:	b2db      	uxtb	r3, r3
 8017cb2:	2b00      	cmp	r3, #0
 8017cb4:	d00e      	beq.n	8017cd4 <report_setting_description+0xa8>
        hal.stream.write(SETTINGS_HARD_RESET_REQUIRED + (description && *description != '\0' ? 0 : 4));
 8017cb6:	4b0e      	ldr	r3, [pc, #56]	; (8017cf0 <report_setting_description+0xc4>)
 8017cb8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017cbc:	68ba      	ldr	r2, [r7, #8]
 8017cbe:	2a00      	cmp	r2, #0
 8017cc0:	d005      	beq.n	8017cce <report_setting_description+0xa2>
 8017cc2:	68ba      	ldr	r2, [r7, #8]
 8017cc4:	7812      	ldrb	r2, [r2, #0]
 8017cc6:	2a00      	cmp	r2, #0
 8017cc8:	d001      	beq.n	8017cce <report_setting_description+0xa2>
 8017cca:	4a0e      	ldr	r2, [pc, #56]	; (8017d04 <report_setting_description+0xd8>)
 8017ccc:	e000      	b.n	8017cd0 <report_setting_description+0xa4>
 8017cce:	4a0e      	ldr	r2, [pc, #56]	; (8017d08 <report_setting_description+0xdc>)
 8017cd0:	4610      	mov	r0, r2
 8017cd2:	4798      	blx	r3

    if(format == SettingsFormat_MachineReadable)
 8017cd4:	79fb      	ldrb	r3, [r7, #7]
 8017cd6:	2b00      	cmp	r3, #0
 8017cd8:	d104      	bne.n	8017ce4 <report_setting_description+0xb8>
        hal.stream.write("]" ASCII_EOL);
 8017cda:	4b05      	ldr	r3, [pc, #20]	; (8017cf0 <report_setting_description+0xc4>)
 8017cdc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017ce0:	480a      	ldr	r0, [pc, #40]	; (8017d0c <report_setting_description+0xe0>)
 8017ce2:	4798      	blx	r3

    return Status_OK;
 8017ce4:	2300      	movs	r3, #0
}
 8017ce6:	4618      	mov	r0, r3
 8017ce8:	3714      	adds	r7, #20
 8017cea:	46bd      	mov	sp, r7
 8017cec:	bd90      	pop	{r4, r7, pc}
 8017cee:	bf00      	nop
 8017cf0:	20000ed0 	.word	0x20000ed0
 8017cf4:	0802b8c8 	.word	0x0802b8c8
 8017cf8:	08031438 	.word	0x08031438
 8017cfc:	0802b1c4 	.word	0x0802b1c4
 8017d00:	0802b678 	.word	0x0802b678
 8017d04:	0802b768 	.word	0x0802b768
 8017d08:	0802b76c 	.word	0x0802b76c
 8017d0c:	0802b1c0 	.word	0x0802b1c0

08017d10 <cmp_alarms>:

#endif

static int cmp_alarms (const void *a, const void *b)
{
 8017d10:	b480      	push	{r7}
 8017d12:	b083      	sub	sp, #12
 8017d14:	af00      	add	r7, sp, #0
 8017d16:	6078      	str	r0, [r7, #4]
 8017d18:	6039      	str	r1, [r7, #0]
  return (*(alarm_detail_t **)(a))->id - (*(alarm_detail_t **)(b))->id;
 8017d1a:	687b      	ldr	r3, [r7, #4]
 8017d1c:	681b      	ldr	r3, [r3, #0]
 8017d1e:	781b      	ldrb	r3, [r3, #0]
 8017d20:	461a      	mov	r2, r3
 8017d22:	683b      	ldr	r3, [r7, #0]
 8017d24:	681b      	ldr	r3, [r3, #0]
 8017d26:	781b      	ldrb	r3, [r3, #0]
 8017d28:	1ad3      	subs	r3, r2, r3
}
 8017d2a:	4618      	mov	r0, r3
 8017d2c:	370c      	adds	r7, #12
 8017d2e:	46bd      	mov	sp, r7
 8017d30:	bc80      	pop	{r7}
 8017d32:	4770      	bx	lr

08017d34 <print_alarm>:

static void print_alarm (const alarm_detail_t *alarm, bool grbl_format)
{
 8017d34:	b590      	push	{r4, r7, lr}
 8017d36:	b083      	sub	sp, #12
 8017d38:	af00      	add	r7, sp, #0
 8017d3a:	6078      	str	r0, [r7, #4]
 8017d3c:	460b      	mov	r3, r1
 8017d3e:	70fb      	strb	r3, [r7, #3]
    if(grbl_format) {
 8017d40:	78fb      	ldrb	r3, [r7, #3]
 8017d42:	2b00      	cmp	r3, #0
 8017d44:	d01f      	beq.n	8017d86 <print_alarm+0x52>
        write_quoted(uitoa(alarm->id), ",");
 8017d46:	687b      	ldr	r3, [r7, #4]
 8017d48:	781b      	ldrb	r3, [r3, #0]
 8017d4a:	4618      	mov	r0, r3
 8017d4c:	f7f8 fa9e 	bl	801028c <uitoa>
 8017d50:	4603      	mov	r3, r0
 8017d52:	4924      	ldr	r1, [pc, #144]	; (8017de4 <print_alarm+0xb0>)
 8017d54:	4618      	mov	r0, r3
 8017d56:	f7ff f925 	bl	8016fa4 <write_quoted>
        write_quoted("N/A", ",");
 8017d5a:	4922      	ldr	r1, [pc, #136]	; (8017de4 <print_alarm+0xb0>)
 8017d5c:	4822      	ldr	r0, [pc, #136]	; (8017de8 <print_alarm+0xb4>)
 8017d5e:	f7ff f921 	bl	8016fa4 <write_quoted>
        write_quoted(alarm->description ? alarm->description : "", NULL);
 8017d62:	687b      	ldr	r3, [r7, #4]
 8017d64:	685b      	ldr	r3, [r3, #4]
 8017d66:	2b00      	cmp	r3, #0
 8017d68:	d002      	beq.n	8017d70 <print_alarm+0x3c>
 8017d6a:	687b      	ldr	r3, [r7, #4]
 8017d6c:	685b      	ldr	r3, [r3, #4]
 8017d6e:	e000      	b.n	8017d72 <print_alarm+0x3e>
 8017d70:	4b1e      	ldr	r3, [pc, #120]	; (8017dec <print_alarm+0xb8>)
 8017d72:	2100      	movs	r1, #0
 8017d74:	4618      	mov	r0, r3
 8017d76:	f7ff f915 	bl	8016fa4 <write_quoted>
        hal.stream.write(ASCII_EOL);
 8017d7a:	4b1d      	ldr	r3, [pc, #116]	; (8017df0 <print_alarm+0xbc>)
 8017d7c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017d80:	481c      	ldr	r0, [pc, #112]	; (8017df4 <print_alarm+0xc0>)
 8017d82:	4798      	blx	r3
        hal.stream.write(vbar);
        if(alarm->description)
            hal.stream.write(alarm->description);
        hal.stream.write("]" ASCII_EOL);
    }
}
 8017d84:	e029      	b.n	8017dda <print_alarm+0xa6>
        hal.stream.write("[ALARMCODE:");
 8017d86:	4b1a      	ldr	r3, [pc, #104]	; (8017df0 <print_alarm+0xbc>)
 8017d88:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017d8c:	481a      	ldr	r0, [pc, #104]	; (8017df8 <print_alarm+0xc4>)
 8017d8e:	4798      	blx	r3
        hal.stream.write(uitoa(alarm->id));
 8017d90:	4b17      	ldr	r3, [pc, #92]	; (8017df0 <print_alarm+0xbc>)
 8017d92:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017d96:	687b      	ldr	r3, [r7, #4]
 8017d98:	781b      	ldrb	r3, [r3, #0]
 8017d9a:	4618      	mov	r0, r3
 8017d9c:	f7f8 fa76 	bl	801028c <uitoa>
 8017da0:	4603      	mov	r3, r0
 8017da2:	4618      	mov	r0, r3
 8017da4:	47a0      	blx	r4
        hal.stream.write(vbar);
 8017da6:	4b12      	ldr	r3, [pc, #72]	; (8017df0 <print_alarm+0xbc>)
 8017da8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017dac:	4813      	ldr	r0, [pc, #76]	; (8017dfc <print_alarm+0xc8>)
 8017dae:	4798      	blx	r3
        hal.stream.write(vbar);
 8017db0:	4b0f      	ldr	r3, [pc, #60]	; (8017df0 <print_alarm+0xbc>)
 8017db2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017db6:	4811      	ldr	r0, [pc, #68]	; (8017dfc <print_alarm+0xc8>)
 8017db8:	4798      	blx	r3
        if(alarm->description)
 8017dba:	687b      	ldr	r3, [r7, #4]
 8017dbc:	685b      	ldr	r3, [r3, #4]
 8017dbe:	2b00      	cmp	r3, #0
 8017dc0:	d006      	beq.n	8017dd0 <print_alarm+0x9c>
            hal.stream.write(alarm->description);
 8017dc2:	4b0b      	ldr	r3, [pc, #44]	; (8017df0 <print_alarm+0xbc>)
 8017dc4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017dc8:	687a      	ldr	r2, [r7, #4]
 8017dca:	6852      	ldr	r2, [r2, #4]
 8017dcc:	4610      	mov	r0, r2
 8017dce:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 8017dd0:	4b07      	ldr	r3, [pc, #28]	; (8017df0 <print_alarm+0xbc>)
 8017dd2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017dd6:	480a      	ldr	r0, [pc, #40]	; (8017e00 <print_alarm+0xcc>)
 8017dd8:	4798      	blx	r3
}
 8017dda:	bf00      	nop
 8017ddc:	370c      	adds	r7, #12
 8017dde:	46bd      	mov	sp, r7
 8017de0:	bd90      	pop	{r4, r7, pc}
 8017de2:	bf00      	nop
 8017de4:	0802b184 	.word	0x0802b184
 8017de8:	0802b678 	.word	0x0802b678
 8017dec:	0802b1c4 	.word	0x0802b1c4
 8017df0:	20000ed0 	.word	0x20000ed0
 8017df4:	0802b190 	.word	0x0802b190
 8017df8:	0802b8d8 	.word	0x0802b8d8
 8017dfc:	08031438 	.word	0x08031438
 8017e00:	0802b1c0 	.word	0x0802b1c0

08017e04 <report_alarm_details>:

status_code_t report_alarm_details (bool grbl_format)
{
 8017e04:	b580      	push	{r7, lr}
 8017e06:	b088      	sub	sp, #32
 8017e08:	af00      	add	r7, sp, #0
 8017e0a:	4603      	mov	r3, r0
 8017e0c:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx, n_alarms = 0;
 8017e0e:	2300      	movs	r3, #0
 8017e10:	61bb      	str	r3, [r7, #24]
    alarm_details_t *details = grbl.on_get_alarms();
 8017e12:	4b40      	ldr	r3, [pc, #256]	; (8017f14 <report_alarm_details+0x110>)
 8017e14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017e16:	4798      	blx	r3
 8017e18:	6178      	str	r0, [r7, #20]
    alarm_detail_t **all_alarms, **palarm;

    if(grbl_format)
 8017e1a:	79fb      	ldrb	r3, [r7, #7]
 8017e1c:	2b00      	cmp	r3, #0
 8017e1e:	d004      	beq.n	8017e2a <report_alarm_details+0x26>
        hal.stream.write("\"Alarm Code in v1.1+\",\" Alarm Message in v1.0-\",\" Alarm Description\"" ASCII_EOL);
 8017e20:	4b3d      	ldr	r3, [pc, #244]	; (8017f18 <report_alarm_details+0x114>)
 8017e22:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017e26:	483d      	ldr	r0, [pc, #244]	; (8017f1c <report_alarm_details+0x118>)
 8017e28:	4798      	blx	r3

    do {
        n_alarms += details->n_alarms;
 8017e2a:	697b      	ldr	r3, [r7, #20]
 8017e2c:	881b      	ldrh	r3, [r3, #0]
 8017e2e:	461a      	mov	r2, r3
 8017e30:	69bb      	ldr	r3, [r7, #24]
 8017e32:	4413      	add	r3, r2
 8017e34:	61bb      	str	r3, [r7, #24]
    } while((details = details->next));
 8017e36:	697b      	ldr	r3, [r7, #20]
 8017e38:	689b      	ldr	r3, [r3, #8]
 8017e3a:	617b      	str	r3, [r7, #20]
 8017e3c:	697b      	ldr	r3, [r7, #20]
 8017e3e:	2b00      	cmp	r3, #0
 8017e40:	d1f3      	bne.n	8017e2a <report_alarm_details+0x26>

    details = grbl.on_get_alarms();
 8017e42:	4b34      	ldr	r3, [pc, #208]	; (8017f14 <report_alarm_details+0x110>)
 8017e44:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8017e46:	4798      	blx	r3
 8017e48:	6178      	str	r0, [r7, #20]

    if((all_alarms = palarm = calloc(n_alarms, sizeof(alarm_detail_t *)))) {
 8017e4a:	2104      	movs	r1, #4
 8017e4c:	69b8      	ldr	r0, [r7, #24]
 8017e4e:	f00b fafd 	bl	802344c <calloc>
 8017e52:	4603      	mov	r3, r0
 8017e54:	613b      	str	r3, [r7, #16]
 8017e56:	693b      	ldr	r3, [r7, #16]
 8017e58:	60fb      	str	r3, [r7, #12]
 8017e5a:	68fb      	ldr	r3, [r7, #12]
 8017e5c:	2b00      	cmp	r3, #0
 8017e5e:	d038      	beq.n	8017ed2 <report_alarm_details+0xce>

        do {
            for(idx = 0; idx < details->n_alarms; idx++)
 8017e60:	2300      	movs	r3, #0
 8017e62:	61fb      	str	r3, [r7, #28]
 8017e64:	e00b      	b.n	8017e7e <report_alarm_details+0x7a>
                *palarm++ = (alarm_detail_t *)&(details->alarms[idx]);
 8017e66:	697b      	ldr	r3, [r7, #20]
 8017e68:	6859      	ldr	r1, [r3, #4]
 8017e6a:	69fb      	ldr	r3, [r7, #28]
 8017e6c:	00da      	lsls	r2, r3, #3
 8017e6e:	693b      	ldr	r3, [r7, #16]
 8017e70:	1d18      	adds	r0, r3, #4
 8017e72:	6138      	str	r0, [r7, #16]
 8017e74:	440a      	add	r2, r1
 8017e76:	601a      	str	r2, [r3, #0]
            for(idx = 0; idx < details->n_alarms; idx++)
 8017e78:	69fb      	ldr	r3, [r7, #28]
 8017e7a:	3301      	adds	r3, #1
 8017e7c:	61fb      	str	r3, [r7, #28]
 8017e7e:	697b      	ldr	r3, [r7, #20]
 8017e80:	881b      	ldrh	r3, [r3, #0]
 8017e82:	461a      	mov	r2, r3
 8017e84:	69fb      	ldr	r3, [r7, #28]
 8017e86:	4293      	cmp	r3, r2
 8017e88:	d3ed      	bcc.n	8017e66 <report_alarm_details+0x62>
        } while((details = details->next));
 8017e8a:	697b      	ldr	r3, [r7, #20]
 8017e8c:	689b      	ldr	r3, [r3, #8]
 8017e8e:	617b      	str	r3, [r7, #20]
 8017e90:	697b      	ldr	r3, [r7, #20]
 8017e92:	2b00      	cmp	r3, #0
 8017e94:	d1e4      	bne.n	8017e60 <report_alarm_details+0x5c>

        qsort(all_alarms, n_alarms, sizeof(alarm_detail_t *), cmp_alarms);
 8017e96:	4b22      	ldr	r3, [pc, #136]	; (8017f20 <report_alarm_details+0x11c>)
 8017e98:	2204      	movs	r2, #4
 8017e9a:	69b9      	ldr	r1, [r7, #24]
 8017e9c:	68f8      	ldr	r0, [r7, #12]
 8017e9e:	f00b fc41 	bl	8023724 <qsort>

        for(idx = 0; idx < n_alarms; idx++)
 8017ea2:	2300      	movs	r3, #0
 8017ea4:	61fb      	str	r3, [r7, #28]
 8017ea6:	e00c      	b.n	8017ec2 <report_alarm_details+0xbe>
            print_alarm(all_alarms[idx], grbl_format);
 8017ea8:	69fb      	ldr	r3, [r7, #28]
 8017eaa:	009b      	lsls	r3, r3, #2
 8017eac:	68fa      	ldr	r2, [r7, #12]
 8017eae:	4413      	add	r3, r2
 8017eb0:	681b      	ldr	r3, [r3, #0]
 8017eb2:	79fa      	ldrb	r2, [r7, #7]
 8017eb4:	4611      	mov	r1, r2
 8017eb6:	4618      	mov	r0, r3
 8017eb8:	f7ff ff3c 	bl	8017d34 <print_alarm>
        for(idx = 0; idx < n_alarms; idx++)
 8017ebc:	69fb      	ldr	r3, [r7, #28]
 8017ebe:	3301      	adds	r3, #1
 8017ec0:	61fb      	str	r3, [r7, #28]
 8017ec2:	69fa      	ldr	r2, [r7, #28]
 8017ec4:	69bb      	ldr	r3, [r7, #24]
 8017ec6:	429a      	cmp	r2, r3
 8017ec8:	d3ee      	bcc.n	8017ea8 <report_alarm_details+0xa4>

        free(all_alarms);
 8017eca:	68f8      	ldr	r0, [r7, #12]
 8017ecc:	f00b fafc 	bl	80234c8 <free>
 8017ed0:	e01b      	b.n	8017f0a <report_alarm_details+0x106>

    } else do {
        for(idx = 0; idx < details->n_alarms; idx++)
 8017ed2:	2300      	movs	r3, #0
 8017ed4:	61fb      	str	r3, [r7, #28]
 8017ed6:	e00c      	b.n	8017ef2 <report_alarm_details+0xee>
            print_alarm(&details->alarms[idx], grbl_format);
 8017ed8:	697b      	ldr	r3, [r7, #20]
 8017eda:	685a      	ldr	r2, [r3, #4]
 8017edc:	69fb      	ldr	r3, [r7, #28]
 8017ede:	00db      	lsls	r3, r3, #3
 8017ee0:	4413      	add	r3, r2
 8017ee2:	79fa      	ldrb	r2, [r7, #7]
 8017ee4:	4611      	mov	r1, r2
 8017ee6:	4618      	mov	r0, r3
 8017ee8:	f7ff ff24 	bl	8017d34 <print_alarm>
        for(idx = 0; idx < details->n_alarms; idx++)
 8017eec:	69fb      	ldr	r3, [r7, #28]
 8017eee:	3301      	adds	r3, #1
 8017ef0:	61fb      	str	r3, [r7, #28]
 8017ef2:	697b      	ldr	r3, [r7, #20]
 8017ef4:	881b      	ldrh	r3, [r3, #0]
 8017ef6:	461a      	mov	r2, r3
 8017ef8:	69fb      	ldr	r3, [r7, #28]
 8017efa:	4293      	cmp	r3, r2
 8017efc:	d3ec      	bcc.n	8017ed8 <report_alarm_details+0xd4>
    } while((details = details->next));
 8017efe:	697b      	ldr	r3, [r7, #20]
 8017f00:	689b      	ldr	r3, [r3, #8]
 8017f02:	617b      	str	r3, [r7, #20]
 8017f04:	697b      	ldr	r3, [r7, #20]
 8017f06:	2b00      	cmp	r3, #0
 8017f08:	d1e3      	bne.n	8017ed2 <report_alarm_details+0xce>

    return Status_OK;
 8017f0a:	2300      	movs	r3, #0
}
 8017f0c:	4618      	mov	r0, r3
 8017f0e:	3720      	adds	r7, #32
 8017f10:	46bd      	mov	sp, r7
 8017f12:	bd80      	pop	{r7, pc}
 8017f14:	20000dd4 	.word	0x20000dd4
 8017f18:	20000ed0 	.word	0x20000ed0
 8017f1c:	0802b8e4 	.word	0x0802b8e4
 8017f20:	08017d11 	.word	0x08017d11

08017f24 <cmp_errors>:

static int cmp_errors (const void *a, const void *b)
{
 8017f24:	b480      	push	{r7}
 8017f26:	b083      	sub	sp, #12
 8017f28:	af00      	add	r7, sp, #0
 8017f2a:	6078      	str	r0, [r7, #4]
 8017f2c:	6039      	str	r1, [r7, #0]
  return (*(status_detail_t **)(a))->id - (*(status_detail_t **)(b))->id;
 8017f2e:	687b      	ldr	r3, [r7, #4]
 8017f30:	681b      	ldr	r3, [r3, #0]
 8017f32:	781b      	ldrb	r3, [r3, #0]
 8017f34:	461a      	mov	r2, r3
 8017f36:	683b      	ldr	r3, [r7, #0]
 8017f38:	681b      	ldr	r3, [r3, #0]
 8017f3a:	781b      	ldrb	r3, [r3, #0]
 8017f3c:	1ad3      	subs	r3, r2, r3
}
 8017f3e:	4618      	mov	r0, r3
 8017f40:	370c      	adds	r7, #12
 8017f42:	46bd      	mov	sp, r7
 8017f44:	bc80      	pop	{r7}
 8017f46:	4770      	bx	lr

08017f48 <print_error>:

static void print_error (const status_detail_t *error, bool grbl_format)
{
 8017f48:	b590      	push	{r4, r7, lr}
 8017f4a:	b083      	sub	sp, #12
 8017f4c:	af00      	add	r7, sp, #0
 8017f4e:	6078      	str	r0, [r7, #4]
 8017f50:	460b      	mov	r3, r1
 8017f52:	70fb      	strb	r3, [r7, #3]
    if(grbl_format) {
 8017f54:	78fb      	ldrb	r3, [r7, #3]
 8017f56:	2b00      	cmp	r3, #0
 8017f58:	d01f      	beq.n	8017f9a <print_error+0x52>
        write_quoted(uitoa(error->id), ",");
 8017f5a:	687b      	ldr	r3, [r7, #4]
 8017f5c:	781b      	ldrb	r3, [r3, #0]
 8017f5e:	4618      	mov	r0, r3
 8017f60:	f7f8 f994 	bl	801028c <uitoa>
 8017f64:	4603      	mov	r3, r0
 8017f66:	4924      	ldr	r1, [pc, #144]	; (8017ff8 <print_error+0xb0>)
 8017f68:	4618      	mov	r0, r3
 8017f6a:	f7ff f81b 	bl	8016fa4 <write_quoted>
        write_quoted("N/A", ",");
 8017f6e:	4922      	ldr	r1, [pc, #136]	; (8017ff8 <print_error+0xb0>)
 8017f70:	4822      	ldr	r0, [pc, #136]	; (8017ffc <print_error+0xb4>)
 8017f72:	f7ff f817 	bl	8016fa4 <write_quoted>
        write_quoted(error->description ? error->description : "", NULL);
 8017f76:	687b      	ldr	r3, [r7, #4]
 8017f78:	685b      	ldr	r3, [r3, #4]
 8017f7a:	2b00      	cmp	r3, #0
 8017f7c:	d002      	beq.n	8017f84 <print_error+0x3c>
 8017f7e:	687b      	ldr	r3, [r7, #4]
 8017f80:	685b      	ldr	r3, [r3, #4]
 8017f82:	e000      	b.n	8017f86 <print_error+0x3e>
 8017f84:	4b1e      	ldr	r3, [pc, #120]	; (8018000 <print_error+0xb8>)
 8017f86:	2100      	movs	r1, #0
 8017f88:	4618      	mov	r0, r3
 8017f8a:	f7ff f80b 	bl	8016fa4 <write_quoted>
        hal.stream.write(ASCII_EOL);
 8017f8e:	4b1d      	ldr	r3, [pc, #116]	; (8018004 <print_error+0xbc>)
 8017f90:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017f94:	481c      	ldr	r0, [pc, #112]	; (8018008 <print_error+0xc0>)
 8017f96:	4798      	blx	r3
        hal.stream.write(vbar);
        if(error->description)
            hal.stream.write(error->description);
        hal.stream.write("]" ASCII_EOL);
    }
}
 8017f98:	e029      	b.n	8017fee <print_error+0xa6>
        hal.stream.write("[ERRORCODE:");
 8017f9a:	4b1a      	ldr	r3, [pc, #104]	; (8018004 <print_error+0xbc>)
 8017f9c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017fa0:	481a      	ldr	r0, [pc, #104]	; (801800c <print_error+0xc4>)
 8017fa2:	4798      	blx	r3
        hal.stream.write(uitoa(error->id));
 8017fa4:	4b17      	ldr	r3, [pc, #92]	; (8018004 <print_error+0xbc>)
 8017fa6:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8017faa:	687b      	ldr	r3, [r7, #4]
 8017fac:	781b      	ldrb	r3, [r3, #0]
 8017fae:	4618      	mov	r0, r3
 8017fb0:	f7f8 f96c 	bl	801028c <uitoa>
 8017fb4:	4603      	mov	r3, r0
 8017fb6:	4618      	mov	r0, r3
 8017fb8:	47a0      	blx	r4
        hal.stream.write(vbar);
 8017fba:	4b12      	ldr	r3, [pc, #72]	; (8018004 <print_error+0xbc>)
 8017fbc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017fc0:	4813      	ldr	r0, [pc, #76]	; (8018010 <print_error+0xc8>)
 8017fc2:	4798      	blx	r3
        hal.stream.write(vbar);
 8017fc4:	4b0f      	ldr	r3, [pc, #60]	; (8018004 <print_error+0xbc>)
 8017fc6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017fca:	4811      	ldr	r0, [pc, #68]	; (8018010 <print_error+0xc8>)
 8017fcc:	4798      	blx	r3
        if(error->description)
 8017fce:	687b      	ldr	r3, [r7, #4]
 8017fd0:	685b      	ldr	r3, [r3, #4]
 8017fd2:	2b00      	cmp	r3, #0
 8017fd4:	d006      	beq.n	8017fe4 <print_error+0x9c>
            hal.stream.write(error->description);
 8017fd6:	4b0b      	ldr	r3, [pc, #44]	; (8018004 <print_error+0xbc>)
 8017fd8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017fdc:	687a      	ldr	r2, [r7, #4]
 8017fde:	6852      	ldr	r2, [r2, #4]
 8017fe0:	4610      	mov	r0, r2
 8017fe2:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 8017fe4:	4b07      	ldr	r3, [pc, #28]	; (8018004 <print_error+0xbc>)
 8017fe6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8017fea:	480a      	ldr	r0, [pc, #40]	; (8018014 <print_error+0xcc>)
 8017fec:	4798      	blx	r3
}
 8017fee:	bf00      	nop
 8017ff0:	370c      	adds	r7, #12
 8017ff2:	46bd      	mov	sp, r7
 8017ff4:	bd90      	pop	{r4, r7, pc}
 8017ff6:	bf00      	nop
 8017ff8:	0802b184 	.word	0x0802b184
 8017ffc:	0802b678 	.word	0x0802b678
 8018000:	0802b1c4 	.word	0x0802b1c4
 8018004:	20000ed0 	.word	0x20000ed0
 8018008:	0802b190 	.word	0x0802b190
 801800c:	0802b92c 	.word	0x0802b92c
 8018010:	08031438 	.word	0x08031438
 8018014:	0802b1c0 	.word	0x0802b1c0

08018018 <report_error_details>:

status_code_t report_error_details (bool grbl_format)
{
 8018018:	b580      	push	{r7, lr}
 801801a:	b088      	sub	sp, #32
 801801c:	af00      	add	r7, sp, #0
 801801e:	4603      	mov	r3, r0
 8018020:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx, n_errors = 0;
 8018022:	2300      	movs	r3, #0
 8018024:	61bb      	str	r3, [r7, #24]
    error_details_t *details = grbl.on_get_errors();
 8018026:	4b40      	ldr	r3, [pc, #256]	; (8018128 <report_error_details+0x110>)
 8018028:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801802a:	4798      	blx	r3
 801802c:	6178      	str	r0, [r7, #20]
    status_detail_t **all_errors, **perror;

    if(grbl_format)
 801802e:	79fb      	ldrb	r3, [r7, #7]
 8018030:	2b00      	cmp	r3, #0
 8018032:	d004      	beq.n	801803e <report_error_details+0x26>
        hal.stream.write("\"Error Code in v1.1+\",\"Error Message in v1.0-\",\"Error Description\"" ASCII_EOL);
 8018034:	4b3d      	ldr	r3, [pc, #244]	; (801812c <report_error_details+0x114>)
 8018036:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801803a:	483d      	ldr	r0, [pc, #244]	; (8018130 <report_error_details+0x118>)
 801803c:	4798      	blx	r3

    do {
        n_errors += details->n_errors;
 801803e:	697b      	ldr	r3, [r7, #20]
 8018040:	881b      	ldrh	r3, [r3, #0]
 8018042:	461a      	mov	r2, r3
 8018044:	69bb      	ldr	r3, [r7, #24]
 8018046:	4413      	add	r3, r2
 8018048:	61bb      	str	r3, [r7, #24]
    } while((details = details->next));
 801804a:	697b      	ldr	r3, [r7, #20]
 801804c:	689b      	ldr	r3, [r3, #8]
 801804e:	617b      	str	r3, [r7, #20]
 8018050:	697b      	ldr	r3, [r7, #20]
 8018052:	2b00      	cmp	r3, #0
 8018054:	d1f3      	bne.n	801803e <report_error_details+0x26>

    details = grbl.on_get_errors();
 8018056:	4b34      	ldr	r3, [pc, #208]	; (8018128 <report_error_details+0x110>)
 8018058:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 801805a:	4798      	blx	r3
 801805c:	6178      	str	r0, [r7, #20]

    if((all_errors = perror = calloc(n_errors, sizeof(status_detail_t *)))) {
 801805e:	2104      	movs	r1, #4
 8018060:	69b8      	ldr	r0, [r7, #24]
 8018062:	f00b f9f3 	bl	802344c <calloc>
 8018066:	4603      	mov	r3, r0
 8018068:	613b      	str	r3, [r7, #16]
 801806a:	693b      	ldr	r3, [r7, #16]
 801806c:	60fb      	str	r3, [r7, #12]
 801806e:	68fb      	ldr	r3, [r7, #12]
 8018070:	2b00      	cmp	r3, #0
 8018072:	d038      	beq.n	80180e6 <report_error_details+0xce>

        do {
            for(idx = 0; idx < details->n_errors; idx++)
 8018074:	2300      	movs	r3, #0
 8018076:	61fb      	str	r3, [r7, #28]
 8018078:	e00b      	b.n	8018092 <report_error_details+0x7a>
                *perror++ = (status_detail_t *)&(details->errors[idx]);
 801807a:	697b      	ldr	r3, [r7, #20]
 801807c:	6859      	ldr	r1, [r3, #4]
 801807e:	69fb      	ldr	r3, [r7, #28]
 8018080:	00da      	lsls	r2, r3, #3
 8018082:	693b      	ldr	r3, [r7, #16]
 8018084:	1d18      	adds	r0, r3, #4
 8018086:	6138      	str	r0, [r7, #16]
 8018088:	440a      	add	r2, r1
 801808a:	601a      	str	r2, [r3, #0]
            for(idx = 0; idx < details->n_errors; idx++)
 801808c:	69fb      	ldr	r3, [r7, #28]
 801808e:	3301      	adds	r3, #1
 8018090:	61fb      	str	r3, [r7, #28]
 8018092:	697b      	ldr	r3, [r7, #20]
 8018094:	881b      	ldrh	r3, [r3, #0]
 8018096:	461a      	mov	r2, r3
 8018098:	69fb      	ldr	r3, [r7, #28]
 801809a:	4293      	cmp	r3, r2
 801809c:	d3ed      	bcc.n	801807a <report_error_details+0x62>
        } while((details = details->next));
 801809e:	697b      	ldr	r3, [r7, #20]
 80180a0:	689b      	ldr	r3, [r3, #8]
 80180a2:	617b      	str	r3, [r7, #20]
 80180a4:	697b      	ldr	r3, [r7, #20]
 80180a6:	2b00      	cmp	r3, #0
 80180a8:	d1e4      	bne.n	8018074 <report_error_details+0x5c>

        qsort(all_errors, n_errors, sizeof(status_detail_t *), cmp_errors);
 80180aa:	4b22      	ldr	r3, [pc, #136]	; (8018134 <report_error_details+0x11c>)
 80180ac:	2204      	movs	r2, #4
 80180ae:	69b9      	ldr	r1, [r7, #24]
 80180b0:	68f8      	ldr	r0, [r7, #12]
 80180b2:	f00b fb37 	bl	8023724 <qsort>

        for(idx = 0; idx < n_errors; idx++)
 80180b6:	2300      	movs	r3, #0
 80180b8:	61fb      	str	r3, [r7, #28]
 80180ba:	e00c      	b.n	80180d6 <report_error_details+0xbe>
            print_error(all_errors[idx], grbl_format);
 80180bc:	69fb      	ldr	r3, [r7, #28]
 80180be:	009b      	lsls	r3, r3, #2
 80180c0:	68fa      	ldr	r2, [r7, #12]
 80180c2:	4413      	add	r3, r2
 80180c4:	681b      	ldr	r3, [r3, #0]
 80180c6:	79fa      	ldrb	r2, [r7, #7]
 80180c8:	4611      	mov	r1, r2
 80180ca:	4618      	mov	r0, r3
 80180cc:	f7ff ff3c 	bl	8017f48 <print_error>
        for(idx = 0; idx < n_errors; idx++)
 80180d0:	69fb      	ldr	r3, [r7, #28]
 80180d2:	3301      	adds	r3, #1
 80180d4:	61fb      	str	r3, [r7, #28]
 80180d6:	69fa      	ldr	r2, [r7, #28]
 80180d8:	69bb      	ldr	r3, [r7, #24]
 80180da:	429a      	cmp	r2, r3
 80180dc:	d3ee      	bcc.n	80180bc <report_error_details+0xa4>

        free(all_errors);
 80180de:	68f8      	ldr	r0, [r7, #12]
 80180e0:	f00b f9f2 	bl	80234c8 <free>
 80180e4:	e01b      	b.n	801811e <report_error_details+0x106>

    } else do {
        for(idx = 0; idx < details->n_errors; idx++)
 80180e6:	2300      	movs	r3, #0
 80180e8:	61fb      	str	r3, [r7, #28]
 80180ea:	e00c      	b.n	8018106 <report_error_details+0xee>
            print_error(&details->errors[idx], grbl_format);
 80180ec:	697b      	ldr	r3, [r7, #20]
 80180ee:	685a      	ldr	r2, [r3, #4]
 80180f0:	69fb      	ldr	r3, [r7, #28]
 80180f2:	00db      	lsls	r3, r3, #3
 80180f4:	4413      	add	r3, r2
 80180f6:	79fa      	ldrb	r2, [r7, #7]
 80180f8:	4611      	mov	r1, r2
 80180fa:	4618      	mov	r0, r3
 80180fc:	f7ff ff24 	bl	8017f48 <print_error>
        for(idx = 0; idx < details->n_errors; idx++)
 8018100:	69fb      	ldr	r3, [r7, #28]
 8018102:	3301      	adds	r3, #1
 8018104:	61fb      	str	r3, [r7, #28]
 8018106:	697b      	ldr	r3, [r7, #20]
 8018108:	881b      	ldrh	r3, [r3, #0]
 801810a:	461a      	mov	r2, r3
 801810c:	69fb      	ldr	r3, [r7, #28]
 801810e:	4293      	cmp	r3, r2
 8018110:	d3ec      	bcc.n	80180ec <report_error_details+0xd4>
    } while((details = details->next));
 8018112:	697b      	ldr	r3, [r7, #20]
 8018114:	689b      	ldr	r3, [r3, #8]
 8018116:	617b      	str	r3, [r7, #20]
 8018118:	697b      	ldr	r3, [r7, #20]
 801811a:	2b00      	cmp	r3, #0
 801811c:	d1e3      	bne.n	80180e6 <report_error_details+0xce>

    return Status_OK;
 801811e:	2300      	movs	r3, #0
}
 8018120:	4618      	mov	r0, r3
 8018122:	3720      	adds	r7, #32
 8018124:	46bd      	mov	sp, r7
 8018126:	bd80      	pop	{r7, pc}
 8018128:	20000dd4 	.word	0x20000dd4
 801812c:	20000ed0 	.word	0x20000ed0
 8018130:	0802b938 	.word	0x0802b938
 8018134:	08017f25 	.word	0x08017f25

08018138 <print_setting_group>:

static void print_setting_group (const setting_group_detail_t *group, char *prefix)
{
 8018138:	b590      	push	{r4, r7, lr}
 801813a:	b083      	sub	sp, #12
 801813c:	af00      	add	r7, sp, #0
 801813e:	6078      	str	r0, [r7, #4]
 8018140:	6039      	str	r1, [r7, #0]
    if(settings_is_group_available(group->id)) {
 8018142:	687b      	ldr	r3, [r7, #4]
 8018144:	785b      	ldrb	r3, [r3, #1]
 8018146:	4618      	mov	r0, r3
 8018148:	f002 ff28 	bl	801af9c <settings_is_group_available>
 801814c:	4603      	mov	r3, r0
 801814e:	2b00      	cmp	r3, #0
 8018150:	d049      	beq.n	80181e6 <print_setting_group+0xae>
        if(!prefix) {
 8018152:	683b      	ldr	r3, [r7, #0]
 8018154:	2b00      	cmp	r3, #0
 8018156:	d131      	bne.n	80181bc <print_setting_group+0x84>
            hal.stream.write("[SETTINGGROUP:");
 8018158:	4b25      	ldr	r3, [pc, #148]	; (80181f0 <print_setting_group+0xb8>)
 801815a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801815e:	4825      	ldr	r0, [pc, #148]	; (80181f4 <print_setting_group+0xbc>)
 8018160:	4798      	blx	r3
            hal.stream.write(uitoa(group->id));
 8018162:	4b23      	ldr	r3, [pc, #140]	; (80181f0 <print_setting_group+0xb8>)
 8018164:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018168:	687b      	ldr	r3, [r7, #4]
 801816a:	785b      	ldrb	r3, [r3, #1]
 801816c:	4618      	mov	r0, r3
 801816e:	f7f8 f88d 	bl	801028c <uitoa>
 8018172:	4603      	mov	r3, r0
 8018174:	4618      	mov	r0, r3
 8018176:	47a0      	blx	r4
            hal.stream.write(vbar);
 8018178:	4b1d      	ldr	r3, [pc, #116]	; (80181f0 <print_setting_group+0xb8>)
 801817a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801817e:	481e      	ldr	r0, [pc, #120]	; (80181f8 <print_setting_group+0xc0>)
 8018180:	4798      	blx	r3
            hal.stream.write(uitoa(group->parent));
 8018182:	4b1b      	ldr	r3, [pc, #108]	; (80181f0 <print_setting_group+0xb8>)
 8018184:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018188:	687b      	ldr	r3, [r7, #4]
 801818a:	781b      	ldrb	r3, [r3, #0]
 801818c:	4618      	mov	r0, r3
 801818e:	f7f8 f87d 	bl	801028c <uitoa>
 8018192:	4603      	mov	r3, r0
 8018194:	4618      	mov	r0, r3
 8018196:	47a0      	blx	r4
            hal.stream.write(vbar);
 8018198:	4b15      	ldr	r3, [pc, #84]	; (80181f0 <print_setting_group+0xb8>)
 801819a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801819e:	4816      	ldr	r0, [pc, #88]	; (80181f8 <print_setting_group+0xc0>)
 80181a0:	4798      	blx	r3
            hal.stream.write(group->name);
 80181a2:	4b13      	ldr	r3, [pc, #76]	; (80181f0 <print_setting_group+0xb8>)
 80181a4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80181a8:	687a      	ldr	r2, [r7, #4]
 80181aa:	6852      	ldr	r2, [r2, #4]
 80181ac:	4610      	mov	r0, r2
 80181ae:	4798      	blx	r3
            hal.stream.write("]" ASCII_EOL);
 80181b0:	4b0f      	ldr	r3, [pc, #60]	; (80181f0 <print_setting_group+0xb8>)
 80181b2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80181b6:	4811      	ldr	r0, [pc, #68]	; (80181fc <print_setting_group+0xc4>)
 80181b8:	4798      	blx	r3
            hal.stream.write(prefix);
            hal.stream.write(group->name);
            hal.stream.write(ASCII_EOL);
        }
    }
}
 80181ba:	e014      	b.n	80181e6 <print_setting_group+0xae>
        } else if(group->id != Group_Root) {
 80181bc:	687b      	ldr	r3, [r7, #4]
 80181be:	785b      	ldrb	r3, [r3, #1]
 80181c0:	2b00      	cmp	r3, #0
 80181c2:	d010      	beq.n	80181e6 <print_setting_group+0xae>
            hal.stream.write(prefix);
 80181c4:	4b0a      	ldr	r3, [pc, #40]	; (80181f0 <print_setting_group+0xb8>)
 80181c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80181ca:	6838      	ldr	r0, [r7, #0]
 80181cc:	4798      	blx	r3
            hal.stream.write(group->name);
 80181ce:	4b08      	ldr	r3, [pc, #32]	; (80181f0 <print_setting_group+0xb8>)
 80181d0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80181d4:	687a      	ldr	r2, [r7, #4]
 80181d6:	6852      	ldr	r2, [r2, #4]
 80181d8:	4610      	mov	r0, r2
 80181da:	4798      	blx	r3
            hal.stream.write(ASCII_EOL);
 80181dc:	4b04      	ldr	r3, [pc, #16]	; (80181f0 <print_setting_group+0xb8>)
 80181de:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80181e2:	4807      	ldr	r0, [pc, #28]	; (8018200 <print_setting_group+0xc8>)
 80181e4:	4798      	blx	r3
}
 80181e6:	bf00      	nop
 80181e8:	370c      	adds	r7, #12
 80181ea:	46bd      	mov	sp, r7
 80181ec:	bd90      	pop	{r4, r7, pc}
 80181ee:	bf00      	nop
 80181f0:	20000ed0 	.word	0x20000ed0
 80181f4:	0802b980 	.word	0x0802b980
 80181f8:	08031438 	.word	0x08031438
 80181fc:	0802b1c0 	.word	0x0802b1c0
 8018200:	0802b190 	.word	0x0802b190

08018204 <cmp_setting_group_id>:

static int cmp_setting_group_id (const void *a, const void *b)
{
 8018204:	b480      	push	{r7}
 8018206:	b083      	sub	sp, #12
 8018208:	af00      	add	r7, sp, #0
 801820a:	6078      	str	r0, [r7, #4]
 801820c:	6039      	str	r1, [r7, #0]
    return (*(setting_group_detail_t **)(a))->id - (*(setting_group_detail_t **)(b))->id;
 801820e:	687b      	ldr	r3, [r7, #4]
 8018210:	681b      	ldr	r3, [r3, #0]
 8018212:	785b      	ldrb	r3, [r3, #1]
 8018214:	461a      	mov	r2, r3
 8018216:	683b      	ldr	r3, [r7, #0]
 8018218:	681b      	ldr	r3, [r3, #0]
 801821a:	785b      	ldrb	r3, [r3, #1]
 801821c:	1ad3      	subs	r3, r2, r3
}
 801821e:	4618      	mov	r0, r3
 8018220:	370c      	adds	r7, #12
 8018222:	46bd      	mov	sp, r7
 8018224:	bc80      	pop	{r7}
 8018226:	4770      	bx	lr

08018228 <cmp_setting_group_name>:

static int cmp_setting_group_name (const void *a, const void *b)
{
 8018228:	b580      	push	{r7, lr}
 801822a:	b082      	sub	sp, #8
 801822c:	af00      	add	r7, sp, #0
 801822e:	6078      	str	r0, [r7, #4]
 8018230:	6039      	str	r1, [r7, #0]
    return strcmp((*(setting_group_detail_t **)(a))->name, (*(setting_group_detail_t **)(b))->name);
 8018232:	687b      	ldr	r3, [r7, #4]
 8018234:	681b      	ldr	r3, [r3, #0]
 8018236:	685a      	ldr	r2, [r3, #4]
 8018238:	683b      	ldr	r3, [r7, #0]
 801823a:	681b      	ldr	r3, [r3, #0]
 801823c:	685b      	ldr	r3, [r3, #4]
 801823e:	4619      	mov	r1, r3
 8018240:	4610      	mov	r0, r2
 8018242:	f7e7 fff1 	bl	8000228 <strcmp>
 8018246:	4603      	mov	r3, r0
}
 8018248:	4618      	mov	r0, r3
 801824a:	3708      	adds	r7, #8
 801824c:	46bd      	mov	sp, r7
 801824e:	bd80      	pop	{r7, pc}

08018250 <group_is_dup>:

static bool group_is_dup (setting_group_detail_t **groups, setting_group_t group)
{
 8018250:	b480      	push	{r7}
 8018252:	b083      	sub	sp, #12
 8018254:	af00      	add	r7, sp, #0
 8018256:	6078      	str	r0, [r7, #4]
 8018258:	460b      	mov	r3, r1
 801825a:	70fb      	strb	r3, [r7, #3]
    while(*groups) {
 801825c:	e00a      	b.n	8018274 <group_is_dup+0x24>
        if((*groups)->id == group)
 801825e:	687b      	ldr	r3, [r7, #4]
 8018260:	681b      	ldr	r3, [r3, #0]
 8018262:	785b      	ldrb	r3, [r3, #1]
 8018264:	78fa      	ldrb	r2, [r7, #3]
 8018266:	429a      	cmp	r2, r3
 8018268:	d101      	bne.n	801826e <group_is_dup+0x1e>
            return true;
 801826a:	2301      	movs	r3, #1
 801826c:	e007      	b.n	801827e <group_is_dup+0x2e>
        groups++;
 801826e:	687b      	ldr	r3, [r7, #4]
 8018270:	3304      	adds	r3, #4
 8018272:	607b      	str	r3, [r7, #4]
    while(*groups) {
 8018274:	687b      	ldr	r3, [r7, #4]
 8018276:	681b      	ldr	r3, [r3, #0]
 8018278:	2b00      	cmp	r3, #0
 801827a:	d1f0      	bne.n	801825e <group_is_dup+0xe>
    }

    return false;
 801827c:	2300      	movs	r3, #0
}
 801827e:	4618      	mov	r0, r3
 8018280:	370c      	adds	r7, #12
 8018282:	46bd      	mov	sp, r7
 8018284:	bc80      	pop	{r7}
 8018286:	4770      	bx	lr

08018288 <report_setting_group_details>:

status_code_t report_setting_group_details (bool by_id, char *prefix)
{
 8018288:	b580      	push	{r7, lr}
 801828a:	b088      	sub	sp, #32
 801828c:	af00      	add	r7, sp, #0
 801828e:	4603      	mov	r3, r0
 8018290:	6039      	str	r1, [r7, #0]
 8018292:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx, n_groups = 0;
 8018294:	2300      	movs	r3, #0
 8018296:	61bb      	str	r3, [r7, #24]
    setting_details_t *details = settings_get_details();
 8018298:	f000 fd40 	bl	8018d1c <settings_get_details>
 801829c:	6178      	str	r0, [r7, #20]
    setting_group_detail_t **all_groups, **group;

    do {
        n_groups += details->n_groups;
 801829e:	697b      	ldr	r3, [r7, #20]
 80182a0:	781b      	ldrb	r3, [r3, #0]
 80182a2:	461a      	mov	r2, r3
 80182a4:	69bb      	ldr	r3, [r7, #24]
 80182a6:	4413      	add	r3, r2
 80182a8:	61bb      	str	r3, [r7, #24]
    } while((details = details->next));
 80182aa:	697b      	ldr	r3, [r7, #20]
 80182ac:	699b      	ldr	r3, [r3, #24]
 80182ae:	617b      	str	r3, [r7, #20]
 80182b0:	697b      	ldr	r3, [r7, #20]
 80182b2:	2b00      	cmp	r3, #0
 80182b4:	d1f3      	bne.n	801829e <report_setting_group_details+0x16>

    details = settings_get_details();
 80182b6:	f000 fd31 	bl	8018d1c <settings_get_details>
 80182ba:	6178      	str	r0, [r7, #20]

    if((all_groups = group = calloc(n_groups, sizeof(setting_group_detail_t *)))) {
 80182bc:	2104      	movs	r1, #4
 80182be:	69b8      	ldr	r0, [r7, #24]
 80182c0:	f00b f8c4 	bl	802344c <calloc>
 80182c4:	4603      	mov	r3, r0
 80182c6:	613b      	str	r3, [r7, #16]
 80182c8:	693b      	ldr	r3, [r7, #16]
 80182ca:	60bb      	str	r3, [r7, #8]
 80182cc:	68bb      	ldr	r3, [r7, #8]
 80182ce:	2b00      	cmp	r3, #0
 80182d0:	d053      	beq.n	801837a <report_setting_group_details+0xf2>

        uint_fast16_t idx;

        do {
            for(idx = 0; idx < details->n_groups; idx++) {
 80182d2:	2300      	movs	r3, #0
 80182d4:	60fb      	str	r3, [r7, #12]
 80182d6:	e022      	b.n	801831e <report_setting_group_details+0x96>
                if(!group_is_dup(all_groups, details->groups[idx].id))
 80182d8:	697b      	ldr	r3, [r7, #20]
 80182da:	6859      	ldr	r1, [r3, #4]
 80182dc:	68fa      	ldr	r2, [r7, #12]
 80182de:	4613      	mov	r3, r2
 80182e0:	005b      	lsls	r3, r3, #1
 80182e2:	4413      	add	r3, r2
 80182e4:	009b      	lsls	r3, r3, #2
 80182e6:	440b      	add	r3, r1
 80182e8:	785b      	ldrb	r3, [r3, #1]
 80182ea:	4619      	mov	r1, r3
 80182ec:	68b8      	ldr	r0, [r7, #8]
 80182ee:	f7ff ffaf 	bl	8018250 <group_is_dup>
 80182f2:	4603      	mov	r3, r0
 80182f4:	f083 0301 	eor.w	r3, r3, #1
 80182f8:	b2db      	uxtb	r3, r3
 80182fa:	2b00      	cmp	r3, #0
 80182fc:	d00c      	beq.n	8018318 <report_setting_group_details+0x90>
                    *group++ = (setting_group_detail_t *)&details->groups[idx];
 80182fe:	697b      	ldr	r3, [r7, #20]
 8018300:	6859      	ldr	r1, [r3, #4]
 8018302:	68fa      	ldr	r2, [r7, #12]
 8018304:	4613      	mov	r3, r2
 8018306:	005b      	lsls	r3, r3, #1
 8018308:	4413      	add	r3, r2
 801830a:	009b      	lsls	r3, r3, #2
 801830c:	4618      	mov	r0, r3
 801830e:	693b      	ldr	r3, [r7, #16]
 8018310:	1d1a      	adds	r2, r3, #4
 8018312:	613a      	str	r2, [r7, #16]
 8018314:	180a      	adds	r2, r1, r0
 8018316:	601a      	str	r2, [r3, #0]
            for(idx = 0; idx < details->n_groups; idx++) {
 8018318:	68fb      	ldr	r3, [r7, #12]
 801831a:	3301      	adds	r3, #1
 801831c:	60fb      	str	r3, [r7, #12]
 801831e:	697b      	ldr	r3, [r7, #20]
 8018320:	781b      	ldrb	r3, [r3, #0]
 8018322:	461a      	mov	r2, r3
 8018324:	68fb      	ldr	r3, [r7, #12]
 8018326:	4293      	cmp	r3, r2
 8018328:	d3d6      	bcc.n	80182d8 <report_setting_group_details+0x50>
            }
        } while((details = details->next));
 801832a:	697b      	ldr	r3, [r7, #20]
 801832c:	699b      	ldr	r3, [r3, #24]
 801832e:	617b      	str	r3, [r7, #20]
 8018330:	697b      	ldr	r3, [r7, #20]
 8018332:	2b00      	cmp	r3, #0
 8018334:	d1cd      	bne.n	80182d2 <report_setting_group_details+0x4a>

        qsort(all_groups, n_groups, sizeof(setting_group_detail_t *), by_id ? cmp_setting_group_id : cmp_setting_group_name);
 8018336:	79fb      	ldrb	r3, [r7, #7]
 8018338:	2b00      	cmp	r3, #0
 801833a:	d001      	beq.n	8018340 <report_setting_group_details+0xb8>
 801833c:	4b20      	ldr	r3, [pc, #128]	; (80183c0 <report_setting_group_details+0x138>)
 801833e:	e000      	b.n	8018342 <report_setting_group_details+0xba>
 8018340:	4b20      	ldr	r3, [pc, #128]	; (80183c4 <report_setting_group_details+0x13c>)
 8018342:	2204      	movs	r2, #4
 8018344:	69b9      	ldr	r1, [r7, #24]
 8018346:	68b8      	ldr	r0, [r7, #8]
 8018348:	f00b f9ec 	bl	8023724 <qsort>

        for(idx = 0; idx < n_groups; idx++)
 801834c:	2300      	movs	r3, #0
 801834e:	60fb      	str	r3, [r7, #12]
 8018350:	e00b      	b.n	801836a <report_setting_group_details+0xe2>
            print_setting_group(all_groups[idx], prefix);
 8018352:	68fb      	ldr	r3, [r7, #12]
 8018354:	009b      	lsls	r3, r3, #2
 8018356:	68ba      	ldr	r2, [r7, #8]
 8018358:	4413      	add	r3, r2
 801835a:	681b      	ldr	r3, [r3, #0]
 801835c:	6839      	ldr	r1, [r7, #0]
 801835e:	4618      	mov	r0, r3
 8018360:	f7ff feea 	bl	8018138 <print_setting_group>
        for(idx = 0; idx < n_groups; idx++)
 8018364:	68fb      	ldr	r3, [r7, #12]
 8018366:	3301      	adds	r3, #1
 8018368:	60fb      	str	r3, [r7, #12]
 801836a:	68fa      	ldr	r2, [r7, #12]
 801836c:	69bb      	ldr	r3, [r7, #24]
 801836e:	429a      	cmp	r2, r3
 8018370:	d3ef      	bcc.n	8018352 <report_setting_group_details+0xca>

        free(all_groups);
 8018372:	68b8      	ldr	r0, [r7, #8]
 8018374:	f00b f8a8 	bl	80234c8 <free>
 8018378:	e01d      	b.n	80183b6 <report_setting_group_details+0x12e>

    } else do {
        for(idx = 0; idx < details->n_groups; idx++)
 801837a:	2300      	movs	r3, #0
 801837c:	61fb      	str	r3, [r7, #28]
 801837e:	e00e      	b.n	801839e <report_setting_group_details+0x116>
            print_setting_group(&details->groups[idx], prefix);
 8018380:	697b      	ldr	r3, [r7, #20]
 8018382:	6859      	ldr	r1, [r3, #4]
 8018384:	69fa      	ldr	r2, [r7, #28]
 8018386:	4613      	mov	r3, r2
 8018388:	005b      	lsls	r3, r3, #1
 801838a:	4413      	add	r3, r2
 801838c:	009b      	lsls	r3, r3, #2
 801838e:	440b      	add	r3, r1
 8018390:	6839      	ldr	r1, [r7, #0]
 8018392:	4618      	mov	r0, r3
 8018394:	f7ff fed0 	bl	8018138 <print_setting_group>
        for(idx = 0; idx < details->n_groups; idx++)
 8018398:	69fb      	ldr	r3, [r7, #28]
 801839a:	3301      	adds	r3, #1
 801839c:	61fb      	str	r3, [r7, #28]
 801839e:	697b      	ldr	r3, [r7, #20]
 80183a0:	781b      	ldrb	r3, [r3, #0]
 80183a2:	461a      	mov	r2, r3
 80183a4:	69fb      	ldr	r3, [r7, #28]
 80183a6:	4293      	cmp	r3, r2
 80183a8:	d3ea      	bcc.n	8018380 <report_setting_group_details+0xf8>
    } while((details = details->next));
 80183aa:	697b      	ldr	r3, [r7, #20]
 80183ac:	699b      	ldr	r3, [r3, #24]
 80183ae:	617b      	str	r3, [r7, #20]
 80183b0:	697b      	ldr	r3, [r7, #20]
 80183b2:	2b00      	cmp	r3, #0
 80183b4:	d1e1      	bne.n	801837a <report_setting_group_details+0xf2>

    return Status_OK;
 80183b6:	2300      	movs	r3, #0
}
 80183b8:	4618      	mov	r0, r3
 80183ba:	3720      	adds	r7, #32
 80183bc:	46bd      	mov	sp, r7
 80183be:	bd80      	pop	{r7, pc}
 80183c0:	08018205 	.word	0x08018205
 80183c4:	08018229 	.word	0x08018229

080183c8 <add_limits>:

static char *add_limits (char *buf, limit_signals_t limits)
{
 80183c8:	b580      	push	{r7, lr}
 80183ca:	b082      	sub	sp, #8
 80183cc:	af00      	add	r7, sp, #0
 80183ce:	6078      	str	r0, [r7, #4]
 80183d0:	6039      	str	r1, [r7, #0]
    buf = axis_signals_tostring(buf, limits.min);
 80183d2:	7839      	ldrb	r1, [r7, #0]
 80183d4:	6878      	ldr	r0, [r7, #4]
 80183d6:	f7fb ff5b 	bl	8014290 <axis_signals_tostring>
 80183da:	6078      	str	r0, [r7, #4]
    *buf++ = ',';
 80183dc:	687b      	ldr	r3, [r7, #4]
 80183de:	1c5a      	adds	r2, r3, #1
 80183e0:	607a      	str	r2, [r7, #4]
 80183e2:	222c      	movs	r2, #44	; 0x2c
 80183e4:	701a      	strb	r2, [r3, #0]
    buf = axis_signals_tostring(buf, limits.max);
 80183e6:	7879      	ldrb	r1, [r7, #1]
 80183e8:	6878      	ldr	r0, [r7, #4]
 80183ea:	f7fb ff51 	bl	8014290 <axis_signals_tostring>
 80183ee:	6078      	str	r0, [r7, #4]
    *buf++ = ',';
 80183f0:	687b      	ldr	r3, [r7, #4]
 80183f2:	1c5a      	adds	r2, r3, #1
 80183f4:	607a      	str	r2, [r7, #4]
 80183f6:	222c      	movs	r2, #44	; 0x2c
 80183f8:	701a      	strb	r2, [r3, #0]
    buf = axis_signals_tostring(buf, limits.min2);
 80183fa:	78b9      	ldrb	r1, [r7, #2]
 80183fc:	6878      	ldr	r0, [r7, #4]
 80183fe:	f7fb ff47 	bl	8014290 <axis_signals_tostring>
 8018402:	6078      	str	r0, [r7, #4]
    *buf++ = ',';
 8018404:	687b      	ldr	r3, [r7, #4]
 8018406:	1c5a      	adds	r2, r3, #1
 8018408:	607a      	str	r2, [r7, #4]
 801840a:	222c      	movs	r2, #44	; 0x2c
 801840c:	701a      	strb	r2, [r3, #0]
    buf = axis_signals_tostring(buf, limits.max2);
 801840e:	78f9      	ldrb	r1, [r7, #3]
 8018410:	6878      	ldr	r0, [r7, #4]
 8018412:	f7fb ff3d 	bl	8014290 <axis_signals_tostring>
 8018416:	6078      	str	r0, [r7, #4]

    return buf;
 8018418:	687b      	ldr	r3, [r7, #4]
}
 801841a:	4618      	mov	r0, r3
 801841c:	3708      	adds	r7, #8
 801841e:	46bd      	mov	sp, r7
 8018420:	bd80      	pop	{r7, pc}
	...

08018424 <report_last_signals_event>:

status_code_t report_last_signals_event (sys_state_t state, char *args)
{
 8018424:	b590      	push	{r4, r7, lr}
 8018426:	b085      	sub	sp, #20
 8018428:	af00      	add	r7, sp, #0
 801842a:	6078      	str	r0, [r7, #4]
 801842c:	6039      	str	r1, [r7, #0]
    char *append = &buf[12];
 801842e:	4b16      	ldr	r3, [pc, #88]	; (8018488 <report_last_signals_event+0x64>)
 8018430:	60fb      	str	r3, [r7, #12]

    strcpy(buf, "[LASTEVENTS:");
 8018432:	4a16      	ldr	r2, [pc, #88]	; (801848c <report_last_signals_event+0x68>)
 8018434:	4b16      	ldr	r3, [pc, #88]	; (8018490 <report_last_signals_event+0x6c>)
 8018436:	4614      	mov	r4, r2
 8018438:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801843a:	c407      	stmia	r4!, {r0, r1, r2}
 801843c:	7023      	strb	r3, [r4, #0]

    append = control_signals_tostring(append, sys.last_event.control);
 801843e:	4b15      	ldr	r3, [pc, #84]	; (8018494 <report_last_signals_event+0x70>)
 8018440:	f8b3 1080 	ldrh.w	r1, [r3, #128]	; 0x80
 8018444:	68f8      	ldr	r0, [r7, #12]
 8018446:	f7fb ff53 	bl	80142f0 <control_signals_tostring>
 801844a:	60f8      	str	r0, [r7, #12]
    *append++ = ',';
 801844c:	68fb      	ldr	r3, [r7, #12]
 801844e:	1c5a      	adds	r2, r3, #1
 8018450:	60fa      	str	r2, [r7, #12]
 8018452:	222c      	movs	r2, #44	; 0x2c
 8018454:	701a      	strb	r2, [r3, #0]
    append = add_limits(append, sys.last_event.limits);
 8018456:	4b0f      	ldr	r3, [pc, #60]	; (8018494 <report_last_signals_event+0x70>)
 8018458:	f8d3 2082 	ldr.w	r2, [r3, #130]	; 0x82
 801845c:	4613      	mov	r3, r2
 801845e:	4619      	mov	r1, r3
 8018460:	68f8      	ldr	r0, [r7, #12]
 8018462:	f7ff ffb1 	bl	80183c8 <add_limits>
 8018466:	60f8      	str	r0, [r7, #12]

    hal.stream.write(buf);
 8018468:	4b0b      	ldr	r3, [pc, #44]	; (8018498 <report_last_signals_event+0x74>)
 801846a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801846e:	4807      	ldr	r0, [pc, #28]	; (801848c <report_last_signals_event+0x68>)
 8018470:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8018472:	4b09      	ldr	r3, [pc, #36]	; (8018498 <report_last_signals_event+0x74>)
 8018474:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018478:	4808      	ldr	r0, [pc, #32]	; (801849c <report_last_signals_event+0x78>)
 801847a:	4798      	blx	r3

    return Status_OK;
 801847c:	2300      	movs	r3, #0
}
 801847e:	4618      	mov	r0, r3
 8018480:	3714      	adds	r7, #20
 8018482:	46bd      	mov	sp, r7
 8018484:	bd90      	pop	{r4, r7, pc}
 8018486:	bf00      	nop
 8018488:	20001410 	.word	0x20001410
 801848c:	20001404 	.word	0x20001404
 8018490:	0802b990 	.word	0x0802b990
 8018494:	20000d3c 	.word	0x20000d3c
 8018498:	20000ed0 	.word	0x20000ed0
 801849c:	0802b1c0 	.word	0x0802b1c0

080184a0 <report_current_limit_state>:

status_code_t report_current_limit_state (sys_state_t state, char *args)
{
 80184a0:	b580      	push	{r7, lr}
 80184a2:	b084      	sub	sp, #16
 80184a4:	af00      	add	r7, sp, #0
 80184a6:	6078      	str	r0, [r7, #4]
 80184a8:	6039      	str	r1, [r7, #0]
    char *append = &buf[8];
 80184aa:	4b10      	ldr	r3, [pc, #64]	; (80184ec <report_current_limit_state+0x4c>)
 80184ac:	60fb      	str	r3, [r7, #12]

    strcpy(buf, "[LIMITS:");
 80184ae:	4b10      	ldr	r3, [pc, #64]	; (80184f0 <report_current_limit_state+0x50>)
 80184b0:	4a10      	ldr	r2, [pc, #64]	; (80184f4 <report_current_limit_state+0x54>)
 80184b2:	ca07      	ldmia	r2, {r0, r1, r2}
 80184b4:	c303      	stmia	r3!, {r0, r1}
 80184b6:	701a      	strb	r2, [r3, #0]

    append = add_limits(append, hal.limits.get_state());
 80184b8:	4b0f      	ldr	r3, [pc, #60]	; (80184f8 <report_current_limit_state+0x58>)
 80184ba:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80184bc:	4798      	blx	r3
 80184be:	4603      	mov	r3, r0
 80184c0:	60bb      	str	r3, [r7, #8]
 80184c2:	68b9      	ldr	r1, [r7, #8]
 80184c4:	68f8      	ldr	r0, [r7, #12]
 80184c6:	f7ff ff7f 	bl	80183c8 <add_limits>
 80184ca:	60f8      	str	r0, [r7, #12]

    hal.stream.write(buf);
 80184cc:	4b0a      	ldr	r3, [pc, #40]	; (80184f8 <report_current_limit_state+0x58>)
 80184ce:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80184d2:	4807      	ldr	r0, [pc, #28]	; (80184f0 <report_current_limit_state+0x50>)
 80184d4:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 80184d6:	4b08      	ldr	r3, [pc, #32]	; (80184f8 <report_current_limit_state+0x58>)
 80184d8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80184dc:	4807      	ldr	r0, [pc, #28]	; (80184fc <report_current_limit_state+0x5c>)
 80184de:	4798      	blx	r3

    return Status_OK;
 80184e0:	2300      	movs	r3, #0
}
 80184e2:	4618      	mov	r0, r3
 80184e4:	3710      	adds	r7, #16
 80184e6:	46bd      	mov	sp, r7
 80184e8:	bd80      	pop	{r7, pc}
 80184ea:	bf00      	nop
 80184ec:	2000140c 	.word	0x2000140c
 80184f0:	20001404 	.word	0x20001404
 80184f4:	0802b9a0 	.word	0x0802b9a0
 80184f8:	20000ed0 	.word	0x20000ed0
 80184fc:	0802b1c0 	.word	0x0802b1c0

08018500 <report_current_home_signal_state>:

status_code_t report_current_home_signal_state (sys_state_t state, char *args)
{
 8018500:	b580      	push	{r7, lr}
 8018502:	b084      	sub	sp, #16
 8018504:	af00      	add	r7, sp, #0
 8018506:	6078      	str	r0, [r7, #4]
 8018508:	6039      	str	r1, [r7, #0]
    char *append = &buf[7];
 801850a:	4b1b      	ldr	r3, [pc, #108]	; (8018578 <report_current_home_signal_state+0x78>)
 801850c:	60fb      	str	r3, [r7, #12]
    home_signals_t home = hal.homing.get_state();
 801850e:	4b1b      	ldr	r3, [pc, #108]	; (801857c <report_current_home_signal_state+0x7c>)
 8018510:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8018512:	4798      	blx	r3
 8018514:	4603      	mov	r3, r0
 8018516:	813b      	strh	r3, [r7, #8]

    strcpy(buf, "[HOMES:");
 8018518:	4b19      	ldr	r3, [pc, #100]	; (8018580 <report_current_home_signal_state+0x80>)
 801851a:	4a1a      	ldr	r2, [pc, #104]	; (8018584 <report_current_home_signal_state+0x84>)
 801851c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8018520:	e883 0003 	stmia.w	r3, {r0, r1}

    append = axis_signals_tostring(append, home.a);
 8018524:	7a39      	ldrb	r1, [r7, #8]
 8018526:	68f8      	ldr	r0, [r7, #12]
 8018528:	f7fb feb2 	bl	8014290 <axis_signals_tostring>
 801852c:	60f8      	str	r0, [r7, #12]
    *append++ = ',';
 801852e:	68fb      	ldr	r3, [r7, #12]
 8018530:	1c5a      	adds	r2, r3, #1
 8018532:	60fa      	str	r2, [r7, #12]
 8018534:	222c      	movs	r2, #44	; 0x2c
 8018536:	701a      	strb	r2, [r3, #0]
    append = axis_signals_tostring(append, home.b);
 8018538:	7a79      	ldrb	r1, [r7, #9]
 801853a:	68f8      	ldr	r0, [r7, #12]
 801853c:	f7fb fea8 	bl	8014290 <axis_signals_tostring>
 8018540:	60f8      	str	r0, [r7, #12]

    strcat(append, hal.home_cap.a.mask ? ":H" : ":L");
 8018542:	4b0e      	ldr	r3, [pc, #56]	; (801857c <report_current_home_signal_state+0x7c>)
 8018544:	f893 31b2 	ldrb.w	r3, [r3, #434]	; 0x1b2
 8018548:	2b00      	cmp	r3, #0
 801854a:	d001      	beq.n	8018550 <report_current_home_signal_state+0x50>
 801854c:	4b0e      	ldr	r3, [pc, #56]	; (8018588 <report_current_home_signal_state+0x88>)
 801854e:	e000      	b.n	8018552 <report_current_home_signal_state+0x52>
 8018550:	4b0e      	ldr	r3, [pc, #56]	; (801858c <report_current_home_signal_state+0x8c>)
 8018552:	4619      	mov	r1, r3
 8018554:	68f8      	ldr	r0, [r7, #12]
 8018556:	f00b fb66 	bl	8023c26 <strcat>

    hal.stream.write(buf);
 801855a:	4b08      	ldr	r3, [pc, #32]	; (801857c <report_current_home_signal_state+0x7c>)
 801855c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018560:	4807      	ldr	r0, [pc, #28]	; (8018580 <report_current_home_signal_state+0x80>)
 8018562:	4798      	blx	r3
    hal.stream.write("]" ASCII_EOL);
 8018564:	4b05      	ldr	r3, [pc, #20]	; (801857c <report_current_home_signal_state+0x7c>)
 8018566:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801856a:	4809      	ldr	r0, [pc, #36]	; (8018590 <report_current_home_signal_state+0x90>)
 801856c:	4798      	blx	r3

    return Status_OK;
 801856e:	2300      	movs	r3, #0
}
 8018570:	4618      	mov	r0, r3
 8018572:	3710      	adds	r7, #16
 8018574:	46bd      	mov	sp, r7
 8018576:	bd80      	pop	{r7, pc}
 8018578:	2000140b 	.word	0x2000140b
 801857c:	20000ed0 	.word	0x20000ed0
 8018580:	20001404 	.word	0x20001404
 8018584:	0802b9ac 	.word	0x0802b9ac
 8018588:	0802b9b4 	.word	0x0802b9b4
 801858c:	0802b9b8 	.word	0x0802b9b8
 8018590:	0802b1c0 	.word	0x0802b1c0

08018594 <report_spindle_data>:

// Prints spindle data (encoder pulse and index count, angular position).
status_code_t report_spindle_data (sys_state_t state, char *args)
{
 8018594:	b590      	push	{r4, r7, lr}
 8018596:	b087      	sub	sp, #28
 8018598:	af00      	add	r7, sp, #0
 801859a:	6078      	str	r0, [r7, #4]
 801859c:	6039      	str	r1, [r7, #0]
    spindle_ptrs_t *spindle = gc_spindle_get();
 801859e:	f7ed fc23 	bl	8005de8 <gc_spindle_get>
 80185a2:	6178      	str	r0, [r7, #20]

    if(spindle->get_data) {
 80185a4:	697b      	ldr	r3, [r7, #20]
 80185a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80185a8:	2b00      	cmp	r3, #0
 80185aa:	d04f      	beq.n	801864c <report_spindle_data+0xb8>

        float apos = spindle->get_data(SpindleData_AngularPosition)->angular_position;
 80185ac:	697b      	ldr	r3, [r7, #20]
 80185ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80185b0:	2002      	movs	r0, #2
 80185b2:	4798      	blx	r3
 80185b4:	4603      	mov	r3, r0
 80185b6:	68db      	ldr	r3, [r3, #12]
 80185b8:	613b      	str	r3, [r7, #16]
        spindle_data_t *data = spindle->get_data(SpindleData_Counters);
 80185ba:	697b      	ldr	r3, [r7, #20]
 80185bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80185be:	2000      	movs	r0, #0
 80185c0:	4798      	blx	r3
 80185c2:	60f8      	str	r0, [r7, #12]

        hal.stream.write("[SPINDLEENCODER:");
 80185c4:	4b27      	ldr	r3, [pc, #156]	; (8018664 <report_spindle_data+0xd0>)
 80185c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80185ca:	4827      	ldr	r0, [pc, #156]	; (8018668 <report_spindle_data+0xd4>)
 80185cc:	4798      	blx	r3
        hal.stream.write(uitoa(data->index_count));
 80185ce:	4b25      	ldr	r3, [pc, #148]	; (8018664 <report_spindle_data+0xd0>)
 80185d0:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80185d4:	68fb      	ldr	r3, [r7, #12]
 80185d6:	695b      	ldr	r3, [r3, #20]
 80185d8:	4618      	mov	r0, r3
 80185da:	f7f7 fe57 	bl	801028c <uitoa>
 80185de:	4603      	mov	r3, r0
 80185e0:	4618      	mov	r0, r3
 80185e2:	47a0      	blx	r4
        hal.stream.write(",");
 80185e4:	4b1f      	ldr	r3, [pc, #124]	; (8018664 <report_spindle_data+0xd0>)
 80185e6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80185ea:	4820      	ldr	r0, [pc, #128]	; (801866c <report_spindle_data+0xd8>)
 80185ec:	4798      	blx	r3
        hal.stream.write(uitoa(data->pulse_count));
 80185ee:	4b1d      	ldr	r3, [pc, #116]	; (8018664 <report_spindle_data+0xd0>)
 80185f0:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80185f4:	68fb      	ldr	r3, [r7, #12]
 80185f6:	699b      	ldr	r3, [r3, #24]
 80185f8:	4618      	mov	r0, r3
 80185fa:	f7f7 fe47 	bl	801028c <uitoa>
 80185fe:	4603      	mov	r3, r0
 8018600:	4618      	mov	r0, r3
 8018602:	47a0      	blx	r4
        hal.stream.write(",");
 8018604:	4b17      	ldr	r3, [pc, #92]	; (8018664 <report_spindle_data+0xd0>)
 8018606:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801860a:	4818      	ldr	r0, [pc, #96]	; (801866c <report_spindle_data+0xd8>)
 801860c:	4798      	blx	r3
        hal.stream.write(uitoa(data->error_count));
 801860e:	4b15      	ldr	r3, [pc, #84]	; (8018664 <report_spindle_data+0xd0>)
 8018610:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018614:	68fb      	ldr	r3, [r7, #12]
 8018616:	69db      	ldr	r3, [r3, #28]
 8018618:	4618      	mov	r0, r3
 801861a:	f7f7 fe37 	bl	801028c <uitoa>
 801861e:	4603      	mov	r3, r0
 8018620:	4618      	mov	r0, r3
 8018622:	47a0      	blx	r4
        hal.stream.write(",");
 8018624:	4b0f      	ldr	r3, [pc, #60]	; (8018664 <report_spindle_data+0xd0>)
 8018626:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801862a:	4810      	ldr	r0, [pc, #64]	; (801866c <report_spindle_data+0xd8>)
 801862c:	4798      	blx	r3
        hal.stream.write(ftoa(apos, 3));
 801862e:	4b0d      	ldr	r3, [pc, #52]	; (8018664 <report_spindle_data+0xd0>)
 8018630:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018634:	2103      	movs	r1, #3
 8018636:	6938      	ldr	r0, [r7, #16]
 8018638:	f7f7 fe64 	bl	8010304 <ftoa>
 801863c:	4603      	mov	r3, r0
 801863e:	4618      	mov	r0, r3
 8018640:	47a0      	blx	r4
        hal.stream.write("]" ASCII_EOL);
 8018642:	4b08      	ldr	r3, [pc, #32]	; (8018664 <report_spindle_data+0xd0>)
 8018644:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018648:	4809      	ldr	r0, [pc, #36]	; (8018670 <report_spindle_data+0xdc>)
 801864a:	4798      	blx	r3
    }

    return spindle->get_data ? Status_OK : Status_InvalidStatement;
 801864c:	697b      	ldr	r3, [r7, #20]
 801864e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8018650:	2b00      	cmp	r3, #0
 8018652:	d001      	beq.n	8018658 <report_spindle_data+0xc4>
 8018654:	2300      	movs	r3, #0
 8018656:	e000      	b.n	801865a <report_spindle_data+0xc6>
 8018658:	2303      	movs	r3, #3
}
 801865a:	4618      	mov	r0, r3
 801865c:	371c      	adds	r7, #28
 801865e:	46bd      	mov	sp, r7
 8018660:	bd90      	pop	{r4, r7, pc}
 8018662:	bf00      	nop
 8018664:	20000ed0 	.word	0x20000ed0
 8018668:	0802b9bc 	.word	0x0802b9bc
 801866c:	0802b184 	.word	0x0802b184
 8018670:	0802b1c0 	.word	0x0802b1c0

08018674 <get_pinname>:

static const char *get_pinname (pin_function_t function)
{
 8018674:	b480      	push	{r7}
 8018676:	b085      	sub	sp, #20
 8018678:	af00      	add	r7, sp, #0
 801867a:	4603      	mov	r3, r0
 801867c:	71fb      	strb	r3, [r7, #7]
    const char *name = NULL;
 801867e:	2300      	movs	r3, #0
 8018680:	60fb      	str	r3, [r7, #12]
    uint_fast8_t idx = sizeof(pin_names) / sizeof(pin_name_t);
 8018682:	2376      	movs	r3, #118	; 0x76
 8018684:	60bb      	str	r3, [r7, #8]

    do {
        if(pin_names[--idx].function == function)
 8018686:	68bb      	ldr	r3, [r7, #8]
 8018688:	3b01      	subs	r3, #1
 801868a:	60bb      	str	r3, [r7, #8]
 801868c:	4a0e      	ldr	r2, [pc, #56]	; (80186c8 <get_pinname+0x54>)
 801868e:	68bb      	ldr	r3, [r7, #8]
 8018690:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
 8018694:	79fa      	ldrb	r2, [r7, #7]
 8018696:	429a      	cmp	r2, r3
 8018698:	d105      	bne.n	80186a6 <get_pinname+0x32>
            name = pin_names[idx].name;
 801869a:	4a0b      	ldr	r2, [pc, #44]	; (80186c8 <get_pinname+0x54>)
 801869c:	68bb      	ldr	r3, [r7, #8]
 801869e:	00db      	lsls	r3, r3, #3
 80186a0:	4413      	add	r3, r2
 80186a2:	685b      	ldr	r3, [r3, #4]
 80186a4:	60fb      	str	r3, [r7, #12]
    } while(idx && !name);
 80186a6:	68bb      	ldr	r3, [r7, #8]
 80186a8:	2b00      	cmp	r3, #0
 80186aa:	d002      	beq.n	80186b2 <get_pinname+0x3e>
 80186ac:	68fb      	ldr	r3, [r7, #12]
 80186ae:	2b00      	cmp	r3, #0
 80186b0:	d0e9      	beq.n	8018686 <get_pinname+0x12>

    return name ? name : "N/A";
 80186b2:	68fb      	ldr	r3, [r7, #12]
 80186b4:	2b00      	cmp	r3, #0
 80186b6:	d001      	beq.n	80186bc <get_pinname+0x48>
 80186b8:	68fb      	ldr	r3, [r7, #12]
 80186ba:	e000      	b.n	80186be <get_pinname+0x4a>
 80186bc:	4b03      	ldr	r3, [pc, #12]	; (80186cc <get_pinname+0x58>)
}
 80186be:	4618      	mov	r0, r3
 80186c0:	3714      	adds	r7, #20
 80186c2:	46bd      	mov	sp, r7
 80186c4:	bc80      	pop	{r7}
 80186c6:	4770      	bx	lr
 80186c8:	08031088 	.word	0x08031088
 80186cc:	0802b678 	.word	0x0802b678

080186d0 <report_pin>:

static void report_pin (xbar_t *pin, void *data)
{
 80186d0:	b590      	push	{r4, r7, lr}
 80186d2:	b083      	sub	sp, #12
 80186d4:	af00      	add	r7, sp, #0
 80186d6:	6078      	str	r0, [r7, #4]
 80186d8:	6039      	str	r1, [r7, #0]
    hal.stream.write("[PIN:");
 80186da:	4b22      	ldr	r3, [pc, #136]	; (8018764 <report_pin+0x94>)
 80186dc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80186e0:	4821      	ldr	r0, [pc, #132]	; (8018768 <report_pin+0x98>)
 80186e2:	4798      	blx	r3
    if(pin->port)
 80186e4:	687b      	ldr	r3, [r7, #4]
 80186e6:	689b      	ldr	r3, [r3, #8]
 80186e8:	2b00      	cmp	r3, #0
 80186ea:	d006      	beq.n	80186fa <report_pin+0x2a>
        hal.stream.write((char *)pin->port);
 80186ec:	4b1d      	ldr	r3, [pc, #116]	; (8018764 <report_pin+0x94>)
 80186ee:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80186f2:	687a      	ldr	r2, [r7, #4]
 80186f4:	6892      	ldr	r2, [r2, #8]
 80186f6:	4610      	mov	r0, r2
 80186f8:	4798      	blx	r3
    hal.stream.write(uitoa(pin->pin));
 80186fa:	4b1a      	ldr	r3, [pc, #104]	; (8018764 <report_pin+0x94>)
 80186fc:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018700:	687b      	ldr	r3, [r7, #4]
 8018702:	691b      	ldr	r3, [r3, #16]
 8018704:	4618      	mov	r0, r3
 8018706:	f7f7 fdc1 	bl	801028c <uitoa>
 801870a:	4603      	mov	r3, r0
 801870c:	4618      	mov	r0, r3
 801870e:	47a0      	blx	r4
    hal.stream.write(",");
 8018710:	4b14      	ldr	r3, [pc, #80]	; (8018764 <report_pin+0x94>)
 8018712:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018716:	4815      	ldr	r0, [pc, #84]	; (801876c <report_pin+0x9c>)
 8018718:	4798      	blx	r3
    hal.stream.write(get_pinname(pin->function));
 801871a:	4b12      	ldr	r3, [pc, #72]	; (8018764 <report_pin+0x94>)
 801871c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018720:	687b      	ldr	r3, [r7, #4]
 8018722:	781b      	ldrb	r3, [r3, #0]
 8018724:	4618      	mov	r0, r3
 8018726:	f7ff ffa5 	bl	8018674 <get_pinname>
 801872a:	4603      	mov	r3, r0
 801872c:	4618      	mov	r0, r3
 801872e:	47a0      	blx	r4
    if(pin->description) {
 8018730:	687b      	ldr	r3, [r7, #4]
 8018732:	68db      	ldr	r3, [r3, #12]
 8018734:	2b00      	cmp	r3, #0
 8018736:	d00b      	beq.n	8018750 <report_pin+0x80>
        hal.stream.write(",");
 8018738:	4b0a      	ldr	r3, [pc, #40]	; (8018764 <report_pin+0x94>)
 801873a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801873e:	480b      	ldr	r0, [pc, #44]	; (801876c <report_pin+0x9c>)
 8018740:	4798      	blx	r3
        hal.stream.write(pin->description);
 8018742:	4b08      	ldr	r3, [pc, #32]	; (8018764 <report_pin+0x94>)
 8018744:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018748:	687a      	ldr	r2, [r7, #4]
 801874a:	68d2      	ldr	r2, [r2, #12]
 801874c:	4610      	mov	r0, r2
 801874e:	4798      	blx	r3
    }
    hal.stream.write("]" ASCII_EOL);
 8018750:	4b04      	ldr	r3, [pc, #16]	; (8018764 <report_pin+0x94>)
 8018752:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018756:	4806      	ldr	r0, [pc, #24]	; (8018770 <report_pin+0xa0>)
 8018758:	4798      	blx	r3
}
 801875a:	bf00      	nop
 801875c:	370c      	adds	r7, #12
 801875e:	46bd      	mov	sp, r7
 8018760:	bd90      	pop	{r4, r7, pc}
 8018762:	bf00      	nop
 8018764:	20000ed0 	.word	0x20000ed0
 8018768:	0802b9d0 	.word	0x0802b9d0
 801876c:	0802b184 	.word	0x0802b184
 8018770:	0802b1c0 	.word	0x0802b1c0

08018774 <report_pins>:

status_code_t report_pins (sys_state_t state, char *args)
{
 8018774:	b580      	push	{r7, lr}
 8018776:	b082      	sub	sp, #8
 8018778:	af00      	add	r7, sp, #0
 801877a:	6078      	str	r0, [r7, #4]
 801877c:	6039      	str	r1, [r7, #0]
    if(hal.enumerate_pins)
 801877e:	4b08      	ldr	r3, [pc, #32]	; (80187a0 <report_pins+0x2c>)
 8018780:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 8018784:	2b00      	cmp	r3, #0
 8018786:	d006      	beq.n	8018796 <report_pins+0x22>
        hal.enumerate_pins(false, report_pin, NULL);
 8018788:	4b05      	ldr	r3, [pc, #20]	; (80187a0 <report_pins+0x2c>)
 801878a:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 801878e:	2200      	movs	r2, #0
 8018790:	4904      	ldr	r1, [pc, #16]	; (80187a4 <report_pins+0x30>)
 8018792:	2000      	movs	r0, #0
 8018794:	4798      	blx	r3

    return Status_OK;
 8018796:	2300      	movs	r3, #0
}
 8018798:	4618      	mov	r0, r3
 801879a:	3708      	adds	r7, #8
 801879c:	46bd      	mov	sp, r7
 801879e:	bd80      	pop	{r7, pc}
 80187a0:	20000ed0 	.word	0x20000ed0
 80187a4:	080186d1 	.word	0x080186d1

080187a8 <print_uito2a>:

static void print_uito2a (char *prefix, uint32_t v)
{
 80187a8:	b590      	push	{r4, r7, lr}
 80187aa:	b083      	sub	sp, #12
 80187ac:	af00      	add	r7, sp, #0
 80187ae:	6078      	str	r0, [r7, #4]
 80187b0:	6039      	str	r1, [r7, #0]
    hal.stream.write(prefix);
 80187b2:	4b0d      	ldr	r3, [pc, #52]	; (80187e8 <print_uito2a+0x40>)
 80187b4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80187b8:	6878      	ldr	r0, [r7, #4]
 80187ba:	4798      	blx	r3
    if(v < 10)
 80187bc:	683b      	ldr	r3, [r7, #0]
 80187be:	2b09      	cmp	r3, #9
 80187c0:	d804      	bhi.n	80187cc <print_uito2a+0x24>
        hal.stream.write("0");
 80187c2:	4b09      	ldr	r3, [pc, #36]	; (80187e8 <print_uito2a+0x40>)
 80187c4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80187c8:	4808      	ldr	r0, [pc, #32]	; (80187ec <print_uito2a+0x44>)
 80187ca:	4798      	blx	r3
    hal.stream.write(uitoa(v));
 80187cc:	4b06      	ldr	r3, [pc, #24]	; (80187e8 <print_uito2a+0x40>)
 80187ce:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80187d2:	6838      	ldr	r0, [r7, #0]
 80187d4:	f7f7 fd5a 	bl	801028c <uitoa>
 80187d8:	4603      	mov	r3, r0
 80187da:	4618      	mov	r0, r3
 80187dc:	47a0      	blx	r4
}
 80187de:	bf00      	nop
 80187e0:	370c      	adds	r7, #12
 80187e2:	46bd      	mov	sp, r7
 80187e4:	bd90      	pop	{r4, r7, pc}
 80187e6:	bf00      	nop
 80187e8:	20000ed0 	.word	0x20000ed0
 80187ec:	0802b62c 	.word	0x0802b62c

080187f0 <report_time>:

status_code_t report_time (void)
{
 80187f0:	b590      	push	{r4, r7, lr}
 80187f2:	b08b      	sub	sp, #44	; 0x2c
 80187f4:	af00      	add	r7, sp, #0
    bool ok = false;
 80187f6:	2300      	movs	r3, #0
 80187f8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    if(hal.rtc.get_datetime) {
 80187fc:	4b26      	ldr	r3, [pc, #152]	; (8018898 <report_time+0xa8>)
 80187fe:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8018802:	2b00      	cmp	r3, #0
 8018804:	d03c      	beq.n	8018880 <report_time+0x90>
        struct tm time;
        if((ok = !!hal.rtc.get_datetime(&time))) {
 8018806:	4b24      	ldr	r3, [pc, #144]	; (8018898 <report_time+0xa8>)
 8018808:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 801880c:	463a      	mov	r2, r7
 801880e:	4610      	mov	r0, r2
 8018810:	4798      	blx	r3
 8018812:	4603      	mov	r3, r0
 8018814:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8018818:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801881c:	2b00      	cmp	r3, #0
 801881e:	d02f      	beq.n	8018880 <report_time+0x90>
            hal.stream.write("[RTC:");
 8018820:	4b1d      	ldr	r3, [pc, #116]	; (8018898 <report_time+0xa8>)
 8018822:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018826:	481d      	ldr	r0, [pc, #116]	; (801889c <report_time+0xac>)
 8018828:	4798      	blx	r3
            hal.stream.write(uitoa(time.tm_year + 1900));
 801882a:	4b1b      	ldr	r3, [pc, #108]	; (8018898 <report_time+0xa8>)
 801882c:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018830:	697b      	ldr	r3, [r7, #20]
 8018832:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8018836:	4618      	mov	r0, r3
 8018838:	f7f7 fd28 	bl	801028c <uitoa>
 801883c:	4603      	mov	r3, r0
 801883e:	4618      	mov	r0, r3
 8018840:	47a0      	blx	r4
            print_uito2a("-", time.tm_mon + 1);
 8018842:	693b      	ldr	r3, [r7, #16]
 8018844:	3301      	adds	r3, #1
 8018846:	4619      	mov	r1, r3
 8018848:	4815      	ldr	r0, [pc, #84]	; (80188a0 <report_time+0xb0>)
 801884a:	f7ff ffad 	bl	80187a8 <print_uito2a>
            print_uito2a("-", time.tm_mday);
 801884e:	68fb      	ldr	r3, [r7, #12]
 8018850:	4619      	mov	r1, r3
 8018852:	4813      	ldr	r0, [pc, #76]	; (80188a0 <report_time+0xb0>)
 8018854:	f7ff ffa8 	bl	80187a8 <print_uito2a>
            print_uito2a("T", time.tm_hour);
 8018858:	68bb      	ldr	r3, [r7, #8]
 801885a:	4619      	mov	r1, r3
 801885c:	4811      	ldr	r0, [pc, #68]	; (80188a4 <report_time+0xb4>)
 801885e:	f7ff ffa3 	bl	80187a8 <print_uito2a>
            print_uito2a(":", time.tm_min);
 8018862:	687b      	ldr	r3, [r7, #4]
 8018864:	4619      	mov	r1, r3
 8018866:	4810      	ldr	r0, [pc, #64]	; (80188a8 <report_time+0xb8>)
 8018868:	f7ff ff9e 	bl	80187a8 <print_uito2a>
            print_uito2a(":", time.tm_sec);
 801886c:	683b      	ldr	r3, [r7, #0]
 801886e:	4619      	mov	r1, r3
 8018870:	480d      	ldr	r0, [pc, #52]	; (80188a8 <report_time+0xb8>)
 8018872:	f7ff ff99 	bl	80187a8 <print_uito2a>
            hal.stream.write("]" ASCII_EOL);
 8018876:	4b08      	ldr	r3, [pc, #32]	; (8018898 <report_time+0xa8>)
 8018878:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801887c:	480b      	ldr	r0, [pc, #44]	; (80188ac <report_time+0xbc>)
 801887e:	4798      	blx	r3
        }
    }

    return ok ? Status_OK : Status_InvalidStatement;
 8018880:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8018884:	2b00      	cmp	r3, #0
 8018886:	d001      	beq.n	801888c <report_time+0x9c>
 8018888:	2300      	movs	r3, #0
 801888a:	e000      	b.n	801888e <report_time+0x9e>
 801888c:	2303      	movs	r3, #3
}
 801888e:	4618      	mov	r0, r3
 8018890:	372c      	adds	r7, #44	; 0x2c
 8018892:	46bd      	mov	sp, r7
 8018894:	bd90      	pop	{r4, r7, pc}
 8018896:	bf00      	nop
 8018898:	20000ed0 	.word	0x20000ed0
 801889c:	0802b9d8 	.word	0x0802b9d8
 80188a0:	0802b9e0 	.word	0x0802b9e0
 80188a4:	0802b9e4 	.word	0x0802b9e4
 80188a8:	0802b2c4 	.word	0x0802b2c4
 80188ac:	0802b1c0 	.word	0x0802b1c0

080188b0 <report_spindle>:

static void report_spindle (spindle_info_t *spindle, void *data)
{
 80188b0:	b590      	push	{r4, r7, lr}
 80188b2:	b085      	sub	sp, #20
 80188b4:	af00      	add	r7, sp, #0
 80188b6:	6078      	str	r0, [r7, #4]
 80188b8:	6039      	str	r1, [r7, #0]
    if(data) {
 80188ba:	683b      	ldr	r3, [r7, #0]
 80188bc:	2b00      	cmp	r3, #0
 80188be:	f000 8104 	beq.w	8018aca <report_spindle+0x21a>
        char *caps = buf;
 80188c2:	4b92      	ldr	r3, [pc, #584]	; (8018b0c <report_spindle+0x25c>)
 80188c4:	60fb      	str	r3, [r7, #12]
        hal.stream.write("[SPINDLE:");
 80188c6:	4b92      	ldr	r3, [pc, #584]	; (8018b10 <report_spindle+0x260>)
 80188c8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80188cc:	4891      	ldr	r0, [pc, #580]	; (8018b14 <report_spindle+0x264>)
 80188ce:	4798      	blx	r3
        hal.stream.write(uitoa(spindle->id));
 80188d0:	4b8f      	ldr	r3, [pc, #572]	; (8018b10 <report_spindle+0x260>)
 80188d2:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80188d6:	687b      	ldr	r3, [r7, #4]
 80188d8:	f993 3000 	ldrsb.w	r3, [r3]
 80188dc:	4618      	mov	r0, r3
 80188de:	f7f7 fcd5 	bl	801028c <uitoa>
 80188e2:	4603      	mov	r3, r0
 80188e4:	4618      	mov	r0, r3
 80188e6:	47a0      	blx	r4
        hal.stream.write("|");
 80188e8:	4b89      	ldr	r3, [pc, #548]	; (8018b10 <report_spindle+0x260>)
 80188ea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80188ee:	488a      	ldr	r0, [pc, #552]	; (8018b18 <report_spindle+0x268>)
 80188f0:	4798      	blx	r3
        hal.stream.write(spindle->enabled ? uitoa(spindle->num) : "-");
 80188f2:	4b87      	ldr	r3, [pc, #540]	; (8018b10 <report_spindle+0x260>)
 80188f4:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 80188f8:	687b      	ldr	r3, [r7, #4]
 80188fa:	7a1b      	ldrb	r3, [r3, #8]
 80188fc:	2b00      	cmp	r3, #0
 80188fe:	d007      	beq.n	8018910 <report_spindle+0x60>
 8018900:	687b      	ldr	r3, [r7, #4]
 8018902:	f993 3001 	ldrsb.w	r3, [r3, #1]
 8018906:	4618      	mov	r0, r3
 8018908:	f7f7 fcc0 	bl	801028c <uitoa>
 801890c:	4603      	mov	r3, r0
 801890e:	e000      	b.n	8018912 <report_spindle+0x62>
 8018910:	4b82      	ldr	r3, [pc, #520]	; (8018b1c <report_spindle+0x26c>)
 8018912:	4618      	mov	r0, r3
 8018914:	47a0      	blx	r4
        hal.stream.write("|");
 8018916:	4b7e      	ldr	r3, [pc, #504]	; (8018b10 <report_spindle+0x260>)
 8018918:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801891c:	487e      	ldr	r0, [pc, #504]	; (8018b18 <report_spindle+0x268>)
 801891e:	4798      	blx	r3
        hal.stream.write(uitoa(spindle->hal->type));
 8018920:	4b7b      	ldr	r3, [pc, #492]	; (8018b10 <report_spindle+0x260>)
 8018922:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018926:	687b      	ldr	r3, [r7, #4]
 8018928:	68db      	ldr	r3, [r3, #12]
 801892a:	7a1b      	ldrb	r3, [r3, #8]
 801892c:	4618      	mov	r0, r3
 801892e:	f7f7 fcad 	bl	801028c <uitoa>
 8018932:	4603      	mov	r3, r0
 8018934:	4618      	mov	r0, r3
 8018936:	47a0      	blx	r4
        *caps++ = '|';
 8018938:	68fb      	ldr	r3, [r7, #12]
 801893a:	1c5a      	adds	r2, r3, #1
 801893c:	60fa      	str	r2, [r7, #12]
 801893e:	227c      	movs	r2, #124	; 0x7c
 8018940:	701a      	strb	r2, [r3, #0]
#if N_SYS_SPINDLE == 1
        if(spindle->is_current)
 8018942:	687b      	ldr	r3, [r7, #4]
 8018944:	7a5b      	ldrb	r3, [r3, #9]
 8018946:	2b00      	cmp	r3, #0
 8018948:	d004      	beq.n	8018954 <report_spindle+0xa4>
            *caps++ = '*';
 801894a:	68fb      	ldr	r3, [r7, #12]
 801894c:	1c5a      	adds	r2, r3, #1
 801894e:	60fa      	str	r2, [r7, #12]
 8018950:	222a      	movs	r2, #42	; 0x2a
 8018952:	701a      	strb	r2, [r3, #0]
#endif
        if(spindle->hal->cap.at_speed)
 8018954:	687b      	ldr	r3, [r7, #4]
 8018956:	68db      	ldr	r3, [r3, #12]
 8018958:	7a9b      	ldrb	r3, [r3, #10]
 801895a:	f003 0304 	and.w	r3, r3, #4
 801895e:	b2db      	uxtb	r3, r3
 8018960:	2b00      	cmp	r3, #0
 8018962:	d004      	beq.n	801896e <report_spindle+0xbe>
            *caps++ = 'S';
 8018964:	68fb      	ldr	r3, [r7, #12]
 8018966:	1c5a      	adds	r2, r3, #1
 8018968:	60fa      	str	r2, [r7, #12]
 801896a:	2253      	movs	r2, #83	; 0x53
 801896c:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.direction)
 801896e:	687b      	ldr	r3, [r7, #4]
 8018970:	68db      	ldr	r3, [r3, #12]
 8018972:	7a9b      	ldrb	r3, [r3, #10]
 8018974:	f003 0302 	and.w	r3, r3, #2
 8018978:	b2db      	uxtb	r3, r3
 801897a:	2b00      	cmp	r3, #0
 801897c:	d004      	beq.n	8018988 <report_spindle+0xd8>
            *caps++ = 'D';
 801897e:	68fb      	ldr	r3, [r7, #12]
 8018980:	1c5a      	adds	r2, r3, #1
 8018982:	60fa      	str	r2, [r7, #12]
 8018984:	2244      	movs	r2, #68	; 0x44
 8018986:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.laser)
 8018988:	687b      	ldr	r3, [r7, #4]
 801898a:	68db      	ldr	r3, [r3, #12]
 801898c:	7a9b      	ldrb	r3, [r3, #10]
 801898e:	f003 0308 	and.w	r3, r3, #8
 8018992:	b2db      	uxtb	r3, r3
 8018994:	2b00      	cmp	r3, #0
 8018996:	d004      	beq.n	80189a2 <report_spindle+0xf2>
            *caps++ = 'L';
 8018998:	68fb      	ldr	r3, [r7, #12]
 801899a:	1c5a      	adds	r2, r3, #1
 801899c:	60fa      	str	r2, [r7, #12]
 801899e:	224c      	movs	r2, #76	; 0x4c
 80189a0:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.pid)
 80189a2:	687b      	ldr	r3, [r7, #4]
 80189a4:	68db      	ldr	r3, [r3, #12]
 80189a6:	7a9b      	ldrb	r3, [r3, #10]
 80189a8:	f003 0320 	and.w	r3, r3, #32
 80189ac:	b2db      	uxtb	r3, r3
 80189ae:	2b00      	cmp	r3, #0
 80189b0:	d004      	beq.n	80189bc <report_spindle+0x10c>
            *caps++ = 'P';
 80189b2:	68fb      	ldr	r3, [r7, #12]
 80189b4:	1c5a      	adds	r2, r3, #1
 80189b6:	60fa      	str	r2, [r7, #12]
 80189b8:	2250      	movs	r2, #80	; 0x50
 80189ba:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.pwm_invert)
 80189bc:	687b      	ldr	r3, [r7, #4]
 80189be:	68db      	ldr	r3, [r3, #12]
 80189c0:	7a9b      	ldrb	r3, [r3, #10]
 80189c2:	f003 0310 	and.w	r3, r3, #16
 80189c6:	b2db      	uxtb	r3, r3
 80189c8:	2b00      	cmp	r3, #0
 80189ca:	d004      	beq.n	80189d6 <report_spindle+0x126>
            *caps++ = 'I';
 80189cc:	68fb      	ldr	r3, [r7, #12]
 80189ce:	1c5a      	adds	r2, r3, #1
 80189d0:	60fa      	str	r2, [r7, #12]
 80189d2:	2249      	movs	r2, #73	; 0x49
 80189d4:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.pwm_linearization)
 80189d6:	687b      	ldr	r3, [r7, #4]
 80189d8:	68db      	ldr	r3, [r3, #12]
 80189da:	7a9b      	ldrb	r3, [r3, #10]
 80189dc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80189e0:	b2db      	uxtb	r3, r3
 80189e2:	2b00      	cmp	r3, #0
 80189e4:	d004      	beq.n	80189f0 <report_spindle+0x140>
            *caps++ = 'N';
 80189e6:	68fb      	ldr	r3, [r7, #12]
 80189e8:	1c5a      	adds	r2, r3, #1
 80189ea:	60fa      	str	r2, [r7, #12]
 80189ec:	224e      	movs	r2, #78	; 0x4e
 80189ee:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.rpm_range_locked)
 80189f0:	687b      	ldr	r3, [r7, #4]
 80189f2:	68db      	ldr	r3, [r3, #12]
 80189f4:	7a9b      	ldrb	r3, [r3, #10]
 80189f6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80189fa:	b2db      	uxtb	r3, r3
 80189fc:	2b00      	cmp	r3, #0
 80189fe:	d004      	beq.n	8018a0a <report_spindle+0x15a>
            *caps++ = 'R';
 8018a00:	68fb      	ldr	r3, [r7, #12]
 8018a02:	1c5a      	adds	r2, r3, #1
 8018a04:	60fa      	str	r2, [r7, #12]
 8018a06:	2252      	movs	r2, #82	; 0x52
 8018a08:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->cap.variable)
 8018a0a:	687b      	ldr	r3, [r7, #4]
 8018a0c:	68db      	ldr	r3, [r3, #12]
 8018a0e:	7a9b      	ldrb	r3, [r3, #10]
 8018a10:	f003 0301 	and.w	r3, r3, #1
 8018a14:	b2db      	uxtb	r3, r3
 8018a16:	2b00      	cmp	r3, #0
 8018a18:	d004      	beq.n	8018a24 <report_spindle+0x174>
            *caps++ = 'V';
 8018a1a:	68fb      	ldr	r3, [r7, #12]
 8018a1c:	1c5a      	adds	r2, r3, #1
 8018a1e:	60fa      	str	r2, [r7, #12]
 8018a20:	2256      	movs	r2, #86	; 0x56
 8018a22:	701a      	strb	r2, [r3, #0]
        if(spindle->hal->get_data)
 8018a24:	687b      	ldr	r3, [r7, #4]
 8018a26:	68db      	ldr	r3, [r3, #12]
 8018a28:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8018a2a:	2b00      	cmp	r3, #0
 8018a2c:	d004      	beq.n	8018a38 <report_spindle+0x188>
            *caps++ = 'E';
 8018a2e:	68fb      	ldr	r3, [r7, #12]
 8018a30:	1c5a      	adds	r2, r3, #1
 8018a32:	60fa      	str	r2, [r7, #12]
 8018a34:	2245      	movs	r2, #69	; 0x45
 8018a36:	701a      	strb	r2, [r3, #0]
        *caps++ = '|';
 8018a38:	68fb      	ldr	r3, [r7, #12]
 8018a3a:	1c5a      	adds	r2, r3, #1
 8018a3c:	60fa      	str	r2, [r7, #12]
 8018a3e:	227c      	movs	r2, #124	; 0x7c
 8018a40:	701a      	strb	r2, [r3, #0]
        *caps = '\0';
 8018a42:	68fb      	ldr	r3, [r7, #12]
 8018a44:	2200      	movs	r2, #0
 8018a46:	701a      	strb	r2, [r3, #0]
        hal.stream.write(buf);
 8018a48:	4b31      	ldr	r3, [pc, #196]	; (8018b10 <report_spindle+0x260>)
 8018a4a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018a4e:	482f      	ldr	r0, [pc, #188]	; (8018b0c <report_spindle+0x25c>)
 8018a50:	4798      	blx	r3
        hal.stream.write(spindle->name);
 8018a52:	4b2f      	ldr	r3, [pc, #188]	; (8018b10 <report_spindle+0x260>)
 8018a54:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018a58:	687a      	ldr	r2, [r7, #4]
 8018a5a:	6852      	ldr	r2, [r2, #4]
 8018a5c:	4610      	mov	r0, r2
 8018a5e:	4798      	blx	r3
        if(spindle->hal->rpm_max > 0.0f) {
 8018a60:	687b      	ldr	r3, [r7, #4]
 8018a62:	68db      	ldr	r3, [r3, #12]
 8018a64:	699b      	ldr	r3, [r3, #24]
 8018a66:	f04f 0100 	mov.w	r1, #0
 8018a6a:	4618      	mov	r0, r3
 8018a6c:	f7e8 fb5e 	bl	800112c <__aeabi_fcmpgt>
 8018a70:	4603      	mov	r3, r0
 8018a72:	2b00      	cmp	r3, #0
 8018a74:	d023      	beq.n	8018abe <report_spindle+0x20e>
            hal.stream.write("|");
 8018a76:	4b26      	ldr	r3, [pc, #152]	; (8018b10 <report_spindle+0x260>)
 8018a78:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018a7c:	4826      	ldr	r0, [pc, #152]	; (8018b18 <report_spindle+0x268>)
 8018a7e:	4798      	blx	r3
            hal.stream.write(ftoa(spindle->hal->rpm_min, 1));
 8018a80:	4b23      	ldr	r3, [pc, #140]	; (8018b10 <report_spindle+0x260>)
 8018a82:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018a86:	687b      	ldr	r3, [r7, #4]
 8018a88:	68db      	ldr	r3, [r3, #12]
 8018a8a:	695b      	ldr	r3, [r3, #20]
 8018a8c:	2101      	movs	r1, #1
 8018a8e:	4618      	mov	r0, r3
 8018a90:	f7f7 fc38 	bl	8010304 <ftoa>
 8018a94:	4603      	mov	r3, r0
 8018a96:	4618      	mov	r0, r3
 8018a98:	47a0      	blx	r4
            hal.stream.write(",");
 8018a9a:	4b1d      	ldr	r3, [pc, #116]	; (8018b10 <report_spindle+0x260>)
 8018a9c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018aa0:	481f      	ldr	r0, [pc, #124]	; (8018b20 <report_spindle+0x270>)
 8018aa2:	4798      	blx	r3
            hal.stream.write(ftoa(spindle->hal->rpm_max, 1));
 8018aa4:	4b1a      	ldr	r3, [pc, #104]	; (8018b10 <report_spindle+0x260>)
 8018aa6:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018aaa:	687b      	ldr	r3, [r7, #4]
 8018aac:	68db      	ldr	r3, [r3, #12]
 8018aae:	699b      	ldr	r3, [r3, #24]
 8018ab0:	2101      	movs	r1, #1
 8018ab2:	4618      	mov	r0, r3
 8018ab4:	f7f7 fc26 	bl	8010304 <ftoa>
 8018ab8:	4603      	mov	r3, r0
 8018aba:	4618      	mov	r0, r3
 8018abc:	47a0      	blx	r4
        }
        hal.stream.write("]" ASCII_EOL);
 8018abe:	4b14      	ldr	r3, [pc, #80]	; (8018b10 <report_spindle+0x260>)
 8018ac0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018ac4:	4817      	ldr	r0, [pc, #92]	; (8018b24 <report_spindle+0x274>)
 8018ac6:	4798      	blx	r3
 #endif
#endif
        }
        hal.stream.write(ASCII_EOL);
    }
}
 8018ac8:	e01c      	b.n	8018b04 <report_spindle+0x254>
        hal.stream.write(uitoa(spindle->id));
 8018aca:	4b11      	ldr	r3, [pc, #68]	; (8018b10 <report_spindle+0x260>)
 8018acc:	f8d3 40b4 	ldr.w	r4, [r3, #180]	; 0xb4
 8018ad0:	687b      	ldr	r3, [r7, #4]
 8018ad2:	f993 3000 	ldrsb.w	r3, [r3]
 8018ad6:	4618      	mov	r0, r3
 8018ad8:	f7f7 fbd8 	bl	801028c <uitoa>
 8018adc:	4603      	mov	r3, r0
 8018ade:	4618      	mov	r0, r3
 8018ae0:	47a0      	blx	r4
        hal.stream.write(" - ");
 8018ae2:	4b0b      	ldr	r3, [pc, #44]	; (8018b10 <report_spindle+0x260>)
 8018ae4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018ae8:	480f      	ldr	r0, [pc, #60]	; (8018b28 <report_spindle+0x278>)
 8018aea:	4798      	blx	r3
        hal.stream.write(spindle->name);
 8018aec:	4b08      	ldr	r3, [pc, #32]	; (8018b10 <report_spindle+0x260>)
 8018aee:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018af2:	687a      	ldr	r2, [r7, #4]
 8018af4:	6852      	ldr	r2, [r2, #4]
 8018af6:	4610      	mov	r0, r2
 8018af8:	4798      	blx	r3
        hal.stream.write(ASCII_EOL);
 8018afa:	4b05      	ldr	r3, [pc, #20]	; (8018b10 <report_spindle+0x260>)
 8018afc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b00:	480a      	ldr	r0, [pc, #40]	; (8018b2c <report_spindle+0x27c>)
 8018b02:	4798      	blx	r3
}
 8018b04:	bf00      	nop
 8018b06:	3714      	adds	r7, #20
 8018b08:	46bd      	mov	sp, r7
 8018b0a:	bd90      	pop	{r4, r7, pc}
 8018b0c:	20001404 	.word	0x20001404
 8018b10:	20000ed0 	.word	0x20000ed0
 8018b14:	0802b9e8 	.word	0x0802b9e8
 8018b18:	0802b2fc 	.word	0x0802b2fc
 8018b1c:	0802b9e0 	.word	0x0802b9e0
 8018b20:	0802b184 	.word	0x0802b184
 8018b24:	0802b1c0 	.word	0x0802b1c0
 8018b28:	0802b684 	.word	0x0802b684
 8018b2c:	0802b190 	.word	0x0802b190

08018b30 <report_spindles>:

status_code_t report_spindles (bool machine_readable)
{
 8018b30:	b580      	push	{r7, lr}
 8018b32:	b082      	sub	sp, #8
 8018b34:	af00      	add	r7, sp, #0
 8018b36:	4603      	mov	r3, r0
 8018b38:	71fb      	strb	r3, [r7, #7]
    if(!spindle_enumerate_spindles(report_spindle, (void *)machine_readable) && !machine_readable)
 8018b3a:	79fb      	ldrb	r3, [r7, #7]
 8018b3c:	4619      	mov	r1, r3
 8018b3e:	480c      	ldr	r0, [pc, #48]	; (8018b70 <report_spindles+0x40>)
 8018b40:	f003 ff2e 	bl	801c9a0 <spindle_enumerate_spindles>
 8018b44:	4603      	mov	r3, r0
 8018b46:	f083 0301 	eor.w	r3, r3, #1
 8018b4a:	b2db      	uxtb	r3, r3
 8018b4c:	2b00      	cmp	r3, #0
 8018b4e:	d00a      	beq.n	8018b66 <report_spindles+0x36>
 8018b50:	79fb      	ldrb	r3, [r7, #7]
 8018b52:	f083 0301 	eor.w	r3, r3, #1
 8018b56:	b2db      	uxtb	r3, r3
 8018b58:	2b00      	cmp	r3, #0
 8018b5a:	d004      	beq.n	8018b66 <report_spindles+0x36>
        hal.stream.write("No spindles registered." ASCII_EOL);
 8018b5c:	4b05      	ldr	r3, [pc, #20]	; (8018b74 <report_spindles+0x44>)
 8018b5e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8018b62:	4805      	ldr	r0, [pc, #20]	; (8018b78 <report_spindles+0x48>)
 8018b64:	4798      	blx	r3

    return Status_OK;
 8018b66:	2300      	movs	r3, #0
}
 8018b68:	4618      	mov	r0, r3
 8018b6a:	3708      	adds	r7, #8
 8018b6c:	46bd      	mov	sp, r7
 8018b6e:	bd80      	pop	{r7, pc}
 8018b70:	080188b1 	.word	0x080188b1
 8018b74:	20000ed0 	.word	0x20000ed0
 8018b78:	0802b9f4 	.word	0x0802b9f4

08018b7c <report_pid_log>:

void report_pid_log (void)
{
 8018b7c:	b580      	push	{r7, lr}
 8018b7e:	af00      	add	r7, sp, #0
    } while(idx != sys.pid_log.idx);

    hal.stream.write("]" ASCII_EOL);
    grbl.report.status_message(Status_OK);
#else
    grbl.report.status_message(Status_GcodeUnsupportedCommand);
 8018b80:	4b02      	ldr	r3, [pc, #8]	; (8018b8c <report_pid_log+0x10>)
 8018b82:	689b      	ldr	r3, [r3, #8]
 8018b84:	2014      	movs	r0, #20
 8018b86:	4798      	blx	r3
#endif
}
 8018b88:	bf00      	nop
 8018b8a:	bd80      	pop	{r7, pc}
 8018b8c:	20000dd4 	.word	0x20000dd4

08018b90 <report_init_fns>:
    .alarm_message = report_alarm_message,
    .setting = report_setting
};

void report_init_fns (void)
{
 8018b90:	b5b0      	push	{r4, r5, r7, lr}
 8018b92:	af00      	add	r7, sp, #0
    memcpy(&grbl.report, &report_fns, sizeof(report_t));
 8018b94:	4a09      	ldr	r2, [pc, #36]	; (8018bbc <report_init_fns+0x2c>)
 8018b96:	4b0a      	ldr	r3, [pc, #40]	; (8018bc0 <report_init_fns+0x30>)
 8018b98:	4614      	mov	r4, r2
 8018b9a:	461d      	mov	r5, r3
 8018b9c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018b9e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018ba0:	e895 0003 	ldmia.w	r5, {r0, r1}
 8018ba4:	e884 0003 	stmia.w	r4, {r0, r1}

    if(grbl.on_report_handlers_init)
 8018ba8:	4b04      	ldr	r3, [pc, #16]	; (8018bbc <report_init_fns+0x2c>)
 8018baa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8018bac:	2b00      	cmp	r3, #0
 8018bae:	d002      	beq.n	8018bb6 <report_init_fns+0x26>
        grbl.on_report_handlers_init();
 8018bb0:	4b02      	ldr	r3, [pc, #8]	; (8018bbc <report_init_fns+0x2c>)
 8018bb2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8018bb4:	4798      	blx	r3
}
 8018bb6:	bf00      	nop
 8018bb8:	bdb0      	pop	{r4, r5, r7, pc}
 8018bba:	bf00      	nop
 8018bbc:	20000dd4 	.word	0x20000dd4
 8018bc0:	0803143c 	.word	0x0803143c

08018bc4 <group_is_available>:
    .safety_door.spindle_on_delay = DEFAULT_SAFETY_DOOR_SPINDLE_DELAY,
    .safety_door.coolant_on_delay = DEFAULT_SAFETY_DOOR_COOLANT_DELAY
};

static bool group_is_available (const setting_group_detail_t *group)
{
 8018bc4:	b480      	push	{r7}
 8018bc6:	b083      	sub	sp, #12
 8018bc8:	af00      	add	r7, sp, #0
 8018bca:	6078      	str	r0, [r7, #4]
    return true;
 8018bcc:	2301      	movs	r3, #1
}
 8018bce:	4618      	mov	r0, r3
 8018bd0:	370c      	adds	r7, #12
 8018bd2:	46bd      	mov	sp, r7
 8018bd4:	bc80      	pop	{r7}
 8018bd6:	4770      	bx	lr

08018bd8 <save_override_backup>:
    bool valid;
    float acceleration[N_AXIS];
} override_backup = { .valid = false };

static void save_override_backup (void)
{
 8018bd8:	b480      	push	{r7}
 8018bda:	b083      	sub	sp, #12
 8018bdc:	af00      	add	r7, sp, #0
    uint_fast8_t idx = N_AXIS;
 8018bde:	2303      	movs	r3, #3
 8018be0:	607b      	str	r3, [r7, #4]

    do {
        idx--;
 8018be2:	687b      	ldr	r3, [r7, #4]
 8018be4:	3b01      	subs	r3, #1
 8018be6:	607b      	str	r3, [r7, #4]
        override_backup.acceleration[idx] = settings.axis[idx].acceleration;
 8018be8:	490c      	ldr	r1, [pc, #48]	; (8018c1c <save_override_backup+0x44>)
 8018bea:	687a      	ldr	r2, [r7, #4]
 8018bec:	4613      	mov	r3, r2
 8018bee:	009b      	lsls	r3, r3, #2
 8018bf0:	4413      	add	r3, r2
 8018bf2:	009b      	lsls	r3, r3, #2
 8018bf4:	440b      	add	r3, r1
 8018bf6:	3338      	adds	r3, #56	; 0x38
 8018bf8:	681a      	ldr	r2, [r3, #0]
 8018bfa:	4909      	ldr	r1, [pc, #36]	; (8018c20 <save_override_backup+0x48>)
 8018bfc:	687b      	ldr	r3, [r7, #4]
 8018bfe:	009b      	lsls	r3, r3, #2
 8018c00:	440b      	add	r3, r1
 8018c02:	605a      	str	r2, [r3, #4]
    } while(idx);
 8018c04:	687b      	ldr	r3, [r7, #4]
 8018c06:	2b00      	cmp	r3, #0
 8018c08:	d1eb      	bne.n	8018be2 <save_override_backup+0xa>

    override_backup.valid = true;
 8018c0a:	4b05      	ldr	r3, [pc, #20]	; (8018c20 <save_override_backup+0x48>)
 8018c0c:	2201      	movs	r2, #1
 8018c0e:	701a      	strb	r2, [r3, #0]
}
 8018c10:	bf00      	nop
 8018c12:	370c      	adds	r7, #12
 8018c14:	46bd      	mov	sp, r7
 8018c16:	bc80      	pop	{r7}
 8018c18:	4770      	bx	lr
 8018c1a:	bf00      	nop
 8018c1c:	2000147c 	.word	0x2000147c
 8018c20:	20001650 	.word	0x20001650

08018c24 <restore_override_backup>:

static void restore_override_backup (void)
{
 8018c24:	b480      	push	{r7}
 8018c26:	b083      	sub	sp, #12
 8018c28:	af00      	add	r7, sp, #0
    uint_fast8_t idx = N_AXIS;
 8018c2a:	2303      	movs	r3, #3
 8018c2c:	607b      	str	r3, [r7, #4]

    if(override_backup.valid) do {
 8018c2e:	4b0e      	ldr	r3, [pc, #56]	; (8018c68 <restore_override_backup+0x44>)
 8018c30:	781b      	ldrb	r3, [r3, #0]
 8018c32:	2b00      	cmp	r3, #0
 8018c34:	d013      	beq.n	8018c5e <restore_override_backup+0x3a>
        idx--;
 8018c36:	687b      	ldr	r3, [r7, #4]
 8018c38:	3b01      	subs	r3, #1
 8018c3a:	607b      	str	r3, [r7, #4]
        settings.axis[idx].acceleration = override_backup.acceleration[idx];
 8018c3c:	4a0a      	ldr	r2, [pc, #40]	; (8018c68 <restore_override_backup+0x44>)
 8018c3e:	687b      	ldr	r3, [r7, #4]
 8018c40:	009b      	lsls	r3, r3, #2
 8018c42:	4413      	add	r3, r2
 8018c44:	6859      	ldr	r1, [r3, #4]
 8018c46:	4809      	ldr	r0, [pc, #36]	; (8018c6c <restore_override_backup+0x48>)
 8018c48:	687a      	ldr	r2, [r7, #4]
 8018c4a:	4613      	mov	r3, r2
 8018c4c:	009b      	lsls	r3, r3, #2
 8018c4e:	4413      	add	r3, r2
 8018c50:	009b      	lsls	r3, r3, #2
 8018c52:	4403      	add	r3, r0
 8018c54:	3338      	adds	r3, #56	; 0x38
 8018c56:	6019      	str	r1, [r3, #0]
    } while(idx);
 8018c58:	687b      	ldr	r3, [r7, #4]
 8018c5a:	2b00      	cmp	r3, #0
 8018c5c:	d1eb      	bne.n	8018c36 <restore_override_backup+0x12>
}
 8018c5e:	bf00      	nop
 8018c60:	370c      	adds	r7, #12
 8018c62:	46bd      	mov	sp, r7
 8018c64:	bc80      	pop	{r7}
 8018c66:	4770      	bx	lr
 8018c68:	20001650 	.word	0x20001650
 8018c6c:	2000147c 	.word	0x2000147c

08018c70 <settings_override_acceleration>:

// Temporarily override acceleration, if 0 restore to setting value.
// Note: only allowed when current state is idle.
bool settings_override_acceleration (uint8_t axis, float acceleration)
{
 8018c70:	b590      	push	{r4, r7, lr}
 8018c72:	b085      	sub	sp, #20
 8018c74:	af00      	add	r7, sp, #0
 8018c76:	4603      	mov	r3, r0
 8018c78:	6039      	str	r1, [r7, #0]
 8018c7a:	71fb      	strb	r3, [r7, #7]
    sys_state_t state = state_get();
 8018c7c:	f004 fe20 	bl	801d8c0 <state_get>
 8018c80:	60f8      	str	r0, [r7, #12]

    if(!(state == STATE_IDLE || (state & (STATE_HOMING|STATE_ALARM))))
 8018c82:	68fb      	ldr	r3, [r7, #12]
 8018c84:	2b00      	cmp	r3, #0
 8018c86:	d006      	beq.n	8018c96 <settings_override_acceleration+0x26>
 8018c88:	68fb      	ldr	r3, [r7, #12]
 8018c8a:	f003 0305 	and.w	r3, r3, #5
 8018c8e:	2b00      	cmp	r3, #0
 8018c90:	d101      	bne.n	8018c96 <settings_override_acceleration+0x26>
        return false;
 8018c92:	2300      	movs	r3, #0
 8018c94:	e038      	b.n	8018d08 <settings_override_acceleration+0x98>

    if(acceleration <= 0.0f) {
 8018c96:	f04f 0100 	mov.w	r1, #0
 8018c9a:	6838      	ldr	r0, [r7, #0]
 8018c9c:	f7e8 fa32 	bl	8001104 <__aeabi_fcmple>
 8018ca0:	4603      	mov	r3, r0
 8018ca2:	2b00      	cmp	r3, #0
 8018ca4:	d012      	beq.n	8018ccc <settings_override_acceleration+0x5c>
        if(override_backup.valid)
 8018ca6:	4b1a      	ldr	r3, [pc, #104]	; (8018d10 <settings_override_acceleration+0xa0>)
 8018ca8:	781b      	ldrb	r3, [r3, #0]
 8018caa:	2b00      	cmp	r3, #0
 8018cac:	d02b      	beq.n	8018d06 <settings_override_acceleration+0x96>
            settings.axis[axis].acceleration = override_backup.acceleration[axis];
 8018cae:	79fb      	ldrb	r3, [r7, #7]
 8018cb0:	79fa      	ldrb	r2, [r7, #7]
 8018cb2:	4917      	ldr	r1, [pc, #92]	; (8018d10 <settings_override_acceleration+0xa0>)
 8018cb4:	009b      	lsls	r3, r3, #2
 8018cb6:	440b      	add	r3, r1
 8018cb8:	6859      	ldr	r1, [r3, #4]
 8018cba:	4816      	ldr	r0, [pc, #88]	; (8018d14 <settings_override_acceleration+0xa4>)
 8018cbc:	4613      	mov	r3, r2
 8018cbe:	009b      	lsls	r3, r3, #2
 8018cc0:	4413      	add	r3, r2
 8018cc2:	009b      	lsls	r3, r3, #2
 8018cc4:	4403      	add	r3, r0
 8018cc6:	3338      	adds	r3, #56	; 0x38
 8018cc8:	6019      	str	r1, [r3, #0]
 8018cca:	e01c      	b.n	8018d06 <settings_override_acceleration+0x96>
    } else {
        if(!override_backup.valid)
 8018ccc:	4b10      	ldr	r3, [pc, #64]	; (8018d10 <settings_override_acceleration+0xa0>)
 8018cce:	781b      	ldrb	r3, [r3, #0]
 8018cd0:	f083 0301 	eor.w	r3, r3, #1
 8018cd4:	b2db      	uxtb	r3, r3
 8018cd6:	2b00      	cmp	r3, #0
 8018cd8:	d001      	beq.n	8018cde <settings_override_acceleration+0x6e>
            save_override_backup();
 8018cda:	f7ff ff7d 	bl	8018bd8 <save_override_backup>
        settings.axis[axis].acceleration = acceleration * 60.0f * 60.0f; // Limit max to setting value?
 8018cde:	490e      	ldr	r1, [pc, #56]	; (8018d18 <settings_override_acceleration+0xa8>)
 8018ce0:	6838      	ldr	r0, [r7, #0]
 8018ce2:	f7e8 f867 	bl	8000db4 <__aeabi_fmul>
 8018ce6:	4603      	mov	r3, r0
 8018ce8:	79fc      	ldrb	r4, [r7, #7]
 8018cea:	490b      	ldr	r1, [pc, #44]	; (8018d18 <settings_override_acceleration+0xa8>)
 8018cec:	4618      	mov	r0, r3
 8018cee:	f7e8 f861 	bl	8000db4 <__aeabi_fmul>
 8018cf2:	4603      	mov	r3, r0
 8018cf4:	4619      	mov	r1, r3
 8018cf6:	4a07      	ldr	r2, [pc, #28]	; (8018d14 <settings_override_acceleration+0xa4>)
 8018cf8:	4623      	mov	r3, r4
 8018cfa:	009b      	lsls	r3, r3, #2
 8018cfc:	4423      	add	r3, r4
 8018cfe:	009b      	lsls	r3, r3, #2
 8018d00:	4413      	add	r3, r2
 8018d02:	3338      	adds	r3, #56	; 0x38
 8018d04:	6019      	str	r1, [r3, #0]
    }

    return true;
 8018d06:	2301      	movs	r3, #1
}
 8018d08:	4618      	mov	r0, r3
 8018d0a:	3714      	adds	r7, #20
 8018d0c:	46bd      	mov	sp, r7
 8018d0e:	bd90      	pop	{r4, r7, pc}
 8018d10:	20001650 	.word	0x20001650
 8018d14:	2000147c 	.word	0x2000147c
 8018d18:	42700000 	.word	0x42700000

08018d1c <settings_get_details>:
    settingsd->next = details;
    settingsd = details;
}

setting_details_t *settings_get_details (void)
{
 8018d1c:	b480      	push	{r7}
 8018d1e:	af00      	add	r7, sp, #0
    return &setting_details;
 8018d20:	4b02      	ldr	r3, [pc, #8]	; (8018d2c <settings_get_details+0x10>)
}
 8018d22:	4618      	mov	r0, r3
 8018d24:	46bd      	mov	sp, r7
 8018d26:	bc80      	pop	{r7}
 8018d28:	4770      	bx	lr
 8018d2a:	bf00      	nop
 8018d2c:	20000360 	.word	0x20000360

08018d30 <set_probe_invert>:
}

#endif

static status_code_t set_probe_invert (setting_id_t id, uint_fast16_t int_value)
{
 8018d30:	b580      	push	{r7, lr}
 8018d32:	b082      	sub	sp, #8
 8018d34:	af00      	add	r7, sp, #0
 8018d36:	4603      	mov	r3, r0
 8018d38:	6039      	str	r1, [r7, #0]
 8018d3a:	80fb      	strh	r3, [r7, #6]
    if(!hal.probe.configure)
 8018d3c:	4b0f      	ldr	r3, [pc, #60]	; (8018d7c <set_probe_invert+0x4c>)
 8018d3e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8018d42:	2b00      	cmp	r3, #0
 8018d44:	d101      	bne.n	8018d4a <set_probe_invert+0x1a>
        return Status_SettingDisabled;
 8018d46:	2335      	movs	r3, #53	; 0x35
 8018d48:	e013      	b.n	8018d72 <set_probe_invert+0x42>

    settings.probe.invert_probe_pin = int_value != 0;
 8018d4a:	683b      	ldr	r3, [r7, #0]
 8018d4c:	2b00      	cmp	r3, #0
 8018d4e:	bf14      	ite	ne
 8018d50:	2301      	movne	r3, #1
 8018d52:	2300      	moveq	r3, #0
 8018d54:	b2d9      	uxtb	r1, r3
 8018d56:	4a0a      	ldr	r2, [pc, #40]	; (8018d80 <set_probe_invert+0x50>)
 8018d58:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
 8018d5c:	f361 0300 	bfi	r3, r1, #0, #1
 8018d60:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
    hal.probe.configure(false, false);
 8018d64:	4b05      	ldr	r3, [pc, #20]	; (8018d7c <set_probe_invert+0x4c>)
 8018d66:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8018d6a:	2100      	movs	r1, #0
 8018d6c:	2000      	movs	r0, #0
 8018d6e:	4798      	blx	r3

    return Status_OK;
 8018d70:	2300      	movs	r3, #0
}
 8018d72:	4618      	mov	r0, r3
 8018d74:	3708      	adds	r7, #8
 8018d76:	46bd      	mov	sp, r7
 8018d78:	bd80      	pop	{r7, pc}
 8018d7a:	bf00      	nop
 8018d7c:	20000ed0 	.word	0x20000ed0
 8018d80:	2000147c 	.word	0x2000147c

08018d84 <set_ganged_dir_invert>:

static status_code_t set_ganged_dir_invert (setting_id_t id, uint_fast16_t int_value)
{
 8018d84:	b580      	push	{r7, lr}
 8018d86:	b082      	sub	sp, #8
 8018d88:	af00      	add	r7, sp, #0
 8018d8a:	4603      	mov	r3, r0
 8018d8c:	6039      	str	r1, [r7, #0]
 8018d8e:	80fb      	strh	r3, [r7, #6]
    if(!hal.stepper.get_ganged)
 8018d90:	4b0c      	ldr	r3, [pc, #48]	; (8018dc4 <set_ganged_dir_invert+0x40>)
 8018d92:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8018d96:	2b00      	cmp	r3, #0
 8018d98:	d101      	bne.n	8018d9e <set_ganged_dir_invert+0x1a>
        return Status_SettingDisabled;
 8018d9a:	2335      	movs	r3, #53	; 0x35
 8018d9c:	e00e      	b.n	8018dbc <set_ganged_dir_invert+0x38>

    settings.steppers.ganged_dir_invert.mask = int_value & hal.stepper.get_ganged(false).mask;
 8018d9e:	4b09      	ldr	r3, [pc, #36]	; (8018dc4 <set_ganged_dir_invert+0x40>)
 8018da0:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8018da4:	2000      	movs	r0, #0
 8018da6:	4798      	blx	r3
 8018da8:	4603      	mov	r3, r0
 8018daa:	b2da      	uxtb	r2, r3
 8018dac:	683b      	ldr	r3, [r7, #0]
 8018dae:	b2db      	uxtb	r3, r3
 8018db0:	4013      	ands	r3, r2
 8018db2:	b2da      	uxtb	r2, r3
 8018db4:	4b04      	ldr	r3, [pc, #16]	; (8018dc8 <set_ganged_dir_invert+0x44>)
 8018db6:	f883 20ea 	strb.w	r2, [r3, #234]	; 0xea

    return Status_OK;
 8018dba:	2300      	movs	r3, #0
}
 8018dbc:	4618      	mov	r0, r3
 8018dbe:	3708      	adds	r7, #8
 8018dc0:	46bd      	mov	sp, r7
 8018dc2:	bd80      	pop	{r7, pc}
 8018dc4:	20000ed0 	.word	0x20000ed0
 8018dc8:	2000147c 	.word	0x2000147c

08018dcc <set_stepper_deenergize_mask>:

static status_code_t set_stepper_deenergize_mask (setting_id_t id, uint_fast16_t int_value)
{
 8018dcc:	b580      	push	{r7, lr}
 8018dce:	b082      	sub	sp, #8
 8018dd0:	af00      	add	r7, sp, #0
 8018dd2:	4603      	mov	r3, r0
 8018dd4:	6039      	str	r1, [r7, #0]
 8018dd6:	80fb      	strh	r3, [r7, #6]
    settings.steppers.deenergize.mask = int_value;
 8018dd8:	683b      	ldr	r3, [r7, #0]
 8018dda:	b2da      	uxtb	r2, r3
 8018ddc:	4b07      	ldr	r3, [pc, #28]	; (8018dfc <set_stepper_deenergize_mask+0x30>)
 8018dde:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec

    hal.stepper.enable(settings.steppers.deenergize);
 8018de2:	4b07      	ldr	r3, [pc, #28]	; (8018e00 <set_stepper_deenergize_mask+0x34>)
 8018de4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8018de8:	4a04      	ldr	r2, [pc, #16]	; (8018dfc <set_stepper_deenergize_mask+0x30>)
 8018dea:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 8018dee:	4798      	blx	r3

    return Status_OK;
 8018df0:	2300      	movs	r3, #0
}
 8018df2:	4618      	mov	r0, r3
 8018df4:	3708      	adds	r7, #8
 8018df6:	46bd      	mov	sp, r7
 8018df8:	bd80      	pop	{r7, pc}
 8018dfa:	bf00      	nop
 8018dfc:	2000147c 	.word	0x2000147c
 8018e00:	20000ed0 	.word	0x20000ed0

08018e04 <set_report_interval>:

static status_code_t set_report_interval (setting_id_t setting, uint_fast16_t int_value)
{
 8018e04:	b480      	push	{r7}
 8018e06:	b083      	sub	sp, #12
 8018e08:	af00      	add	r7, sp, #0
 8018e0a:	4603      	mov	r3, r0
 8018e0c:	6039      	str	r1, [r7, #0]
 8018e0e:	80fb      	strh	r3, [r7, #6]
    if((settings.report_interval = int_value) == 0)
 8018e10:	683b      	ldr	r3, [r7, #0]
 8018e12:	b29a      	uxth	r2, r3
 8018e14:	4b08      	ldr	r3, [pc, #32]	; (8018e38 <set_report_interval+0x34>)
 8018e16:	829a      	strh	r2, [r3, #20]
 8018e18:	4b07      	ldr	r3, [pc, #28]	; (8018e38 <set_report_interval+0x34>)
 8018e1a:	8a9b      	ldrh	r3, [r3, #20]
 8018e1c:	2b00      	cmp	r3, #0
 8018e1e:	d104      	bne.n	8018e2a <set_report_interval+0x26>
        sys.flags.auto_reporting = Off;
 8018e20:	4a06      	ldr	r2, [pc, #24]	; (8018e3c <set_report_interval+0x38>)
 8018e22:	7dd3      	ldrb	r3, [r2, #23]
 8018e24:	f36f 0341 	bfc	r3, #1, #1
 8018e28:	75d3      	strb	r3, [r2, #23]

    return Status_OK;
 8018e2a:	2300      	movs	r3, #0
}
 8018e2c:	4618      	mov	r0, r3
 8018e2e:	370c      	adds	r7, #12
 8018e30:	46bd      	mov	sp, r7
 8018e32:	bc80      	pop	{r7}
 8018e34:	4770      	bx	lr
 8018e36:	bf00      	nop
 8018e38:	2000147c 	.word	0x2000147c
 8018e3c:	20000d3c 	.word	0x20000d3c

08018e40 <set_report_mask>:

static status_code_t set_report_mask (setting_id_t id, uint_fast16_t int_value)
{
 8018e40:	b480      	push	{r7}
 8018e42:	b083      	sub	sp, #12
 8018e44:	af00      	add	r7, sp, #0
 8018e46:	4603      	mov	r3, r0
 8018e48:	6039      	str	r1, [r7, #0]
 8018e4a:	80fb      	strh	r3, [r7, #6]
#if COMPATIBILITY_LEVEL <= 1
    settings.status_report.mask = int_value;
 8018e4c:	683b      	ldr	r3, [r7, #0]
 8018e4e:	b29a      	uxth	r2, r3
 8018e50:	4b04      	ldr	r3, [pc, #16]	; (8018e64 <set_report_mask+0x24>)
 8018e52:	f8a3 20fc 	strh.w	r2, [r3, #252]	; 0xfc
#else
    int_value &= 0b11;
    settings.status_report.mask = (settings.status_report.mask & ~0b11) | int_value;
#endif

    return Status_OK;
 8018e56:	2300      	movs	r3, #0
}
 8018e58:	4618      	mov	r0, r3
 8018e5a:	370c      	adds	r7, #12
 8018e5c:	46bd      	mov	sp, r7
 8018e5e:	bc80      	pop	{r7}
 8018e60:	4770      	bx	lr
 8018e62:	bf00      	nop
 8018e64:	2000147c 	.word	0x2000147c

08018e68 <set_report_inches>:

static status_code_t set_report_inches (setting_id_t id, uint_fast16_t int_value)
{
 8018e68:	b580      	push	{r7, lr}
 8018e6a:	b082      	sub	sp, #8
 8018e6c:	af00      	add	r7, sp, #0
 8018e6e:	4603      	mov	r3, r0
 8018e70:	6039      	str	r1, [r7, #0]
 8018e72:	80fb      	strh	r3, [r7, #6]
    settings.flags.report_inches = int_value != 0;
 8018e74:	683b      	ldr	r3, [r7, #0]
 8018e76:	2b00      	cmp	r3, #0
 8018e78:	bf14      	ite	ne
 8018e7a:	2301      	movne	r3, #1
 8018e7c:	2300      	moveq	r3, #0
 8018e7e:	b2d9      	uxtb	r1, r3
 8018e80:	4a07      	ldr	r2, [pc, #28]	; (8018ea0 <set_report_inches+0x38>)
 8018e82:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 8018e86:	f361 0300 	bfi	r3, r1, #0, #1
 8018e8a:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe
    report_init();
 8018e8e:	f7fb fa9f 	bl	80143d0 <report_init>
    system_flag_wco_change(); // Make sure WCO is immediately updated.
 8018e92:	f008 ff9f 	bl	8021dd4 <system_flag_wco_change>

    return Status_OK;
 8018e96:	2300      	movs	r3, #0
}
 8018e98:	4618      	mov	r0, r3
 8018e9a:	3708      	adds	r7, #8
 8018e9c:	46bd      	mov	sp, r7
 8018e9e:	bd80      	pop	{r7, pc}
 8018ea0:	2000147c 	.word	0x2000147c

08018ea4 <set_control_invert>:
}

#endif

static status_code_t set_control_invert (setting_id_t id, uint_fast16_t int_value)
{
 8018ea4:	b480      	push	{r7}
 8018ea6:	b083      	sub	sp, #12
 8018ea8:	af00      	add	r7, sp, #0
 8018eaa:	4603      	mov	r3, r0
 8018eac:	6039      	str	r1, [r7, #0]
 8018eae:	80fb      	strh	r3, [r7, #6]
    settings.control_invert.mask = int_value & hal.signals_cap.mask;
 8018eb0:	4b07      	ldr	r3, [pc, #28]	; (8018ed0 <set_control_invert+0x2c>)
 8018eb2:	f8b3 21ac 	ldrh.w	r2, [r3, #428]	; 0x1ac
 8018eb6:	683b      	ldr	r3, [r7, #0]
 8018eb8:	b29b      	uxth	r3, r3
 8018eba:	4013      	ands	r3, r2
 8018ebc:	b29a      	uxth	r2, r3
 8018ebe:	4b05      	ldr	r3, [pc, #20]	; (8018ed4 <set_control_invert+0x30>)
 8018ec0:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c

    return Status_OK;
 8018ec4:	2300      	movs	r3, #0
}
 8018ec6:	4618      	mov	r0, r3
 8018ec8:	370c      	adds	r7, #12
 8018eca:	46bd      	mov	sp, r7
 8018ecc:	bc80      	pop	{r7}
 8018ece:	4770      	bx	lr
 8018ed0:	20000ed0 	.word	0x20000ed0
 8018ed4:	2000147c 	.word	0x2000147c

08018ed8 <set_pwm_mode>:

static status_code_t set_pwm_mode (setting_id_t id, uint_fast16_t int_value)
{
 8018ed8:	b480      	push	{r7}
 8018eda:	b083      	sub	sp, #12
 8018edc:	af00      	add	r7, sp, #0
 8018ede:	4603      	mov	r3, r0
 8018ee0:	6039      	str	r1, [r7, #0]
 8018ee2:	80fb      	strh	r3, [r7, #6]
    settings.spindle.flags.enable_rpm_controlled = int_value != 0;
 8018ee4:	683b      	ldr	r3, [r7, #0]
 8018ee6:	2b00      	cmp	r3, #0
 8018ee8:	bf14      	ite	ne
 8018eea:	2301      	movne	r3, #1
 8018eec:	2300      	moveq	r3, #0
 8018eee:	b2d9      	uxtb	r1, r3
 8018ef0:	4a06      	ldr	r2, [pc, #24]	; (8018f0c <set_pwm_mode+0x34>)
 8018ef2:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018ef6:	f361 0300 	bfi	r3, r1, #0, #1
 8018efa:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7

    return Status_OK;
 8018efe:	2300      	movs	r3, #0
}
 8018f00:	4618      	mov	r0, r3
 8018f02:	370c      	adds	r7, #12
 8018f04:	46bd      	mov	sp, r7
 8018f06:	bc80      	pop	{r7}
 8018f08:	4770      	bx	lr
 8018f0a:	bf00      	nop
 8018f0c:	2000147c 	.word	0x2000147c

08018f10 <set_pwm_options>:

static status_code_t set_pwm_options (setting_id_t id, uint_fast16_t int_value)
{
 8018f10:	b480      	push	{r7}
 8018f12:	b083      	sub	sp, #12
 8018f14:	af00      	add	r7, sp, #0
 8018f16:	4603      	mov	r3, r0
 8018f18:	6039      	str	r1, [r7, #0]
 8018f1a:	80fb      	strh	r3, [r7, #6]
    if(int_value & 0x01) {
 8018f1c:	683b      	ldr	r3, [r7, #0]
 8018f1e:	f003 0301 	and.w	r3, r3, #1
 8018f22:	2b00      	cmp	r3, #0
 8018f24:	d018      	beq.n	8018f58 <set_pwm_options+0x48>
        if(int_value > 0b11)
 8018f26:	683b      	ldr	r3, [r7, #0]
 8018f28:	2b03      	cmp	r3, #3
 8018f2a:	d901      	bls.n	8018f30 <set_pwm_options+0x20>
            return Status_SettingValueOutOfRange;
 8018f2c:	2334      	movs	r3, #52	; 0x34
 8018f2e:	e022      	b.n	8018f76 <set_pwm_options+0x66>
        settings.spindle.flags.pwm_disable = Off;
 8018f30:	4a13      	ldr	r2, [pc, #76]	; (8018f80 <set_pwm_options+0x70>)
 8018f32:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018f36:	f36f 13c7 	bfc	r3, #7, #1
 8018f3a:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7
        settings.spindle.flags.enable_rpm_controlled = (int_value & 0b10) >> 1;
 8018f3e:	683b      	ldr	r3, [r7, #0]
 8018f40:	085b      	lsrs	r3, r3, #1
 8018f42:	f003 0301 	and.w	r3, r3, #1
 8018f46:	b2d9      	uxtb	r1, r3
 8018f48:	4a0d      	ldr	r2, [pc, #52]	; (8018f80 <set_pwm_options+0x70>)
 8018f4a:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018f4e:	f361 0300 	bfi	r3, r1, #0, #1
 8018f52:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7
 8018f56:	e00d      	b.n	8018f74 <set_pwm_options+0x64>
    } else {
        settings.spindle.flags.pwm_disable = On;
 8018f58:	4a09      	ldr	r2, [pc, #36]	; (8018f80 <set_pwm_options+0x70>)
 8018f5a:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018f5e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8018f62:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7
        settings.spindle.flags.enable_rpm_controlled = Off;
 8018f66:	4a06      	ldr	r2, [pc, #24]	; (8018f80 <set_pwm_options+0x70>)
 8018f68:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018f6c:	f36f 0300 	bfc	r3, #0, #1
 8018f70:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7
    }

    return Status_OK;
 8018f74:	2300      	movs	r3, #0
}
 8018f76:	4618      	mov	r0, r3
 8018f78:	370c      	adds	r7, #12
 8018f7a:	46bd      	mov	sp, r7
 8018f7c:	bc80      	pop	{r7}
 8018f7e:	4770      	bx	lr
 8018f80:	2000147c 	.word	0x2000147c

08018f84 <set_spindle_type>:

static status_code_t set_spindle_type (setting_id_t id, uint_fast16_t int_value)
{
 8018f84:	b580      	push	{r7, lr}
 8018f86:	b082      	sub	sp, #8
 8018f88:	af00      	add	r7, sp, #0
 8018f8a:	4603      	mov	r3, r0
 8018f8c:	6039      	str	r1, [r7, #0]
 8018f8e:	80fb      	strh	r3, [r7, #6]
    if(spindle_get_count() < 2)
 8018f90:	f003 fcbe 	bl	801c910 <spindle_get_count>
 8018f94:	4603      	mov	r3, r0
 8018f96:	2b01      	cmp	r3, #1
 8018f98:	d801      	bhi.n	8018f9e <set_spindle_type+0x1a>
        return Status_SettingDisabled;
 8018f9a:	2335      	movs	r3, #53	; 0x35
 8018f9c:	e01e      	b.n	8018fdc <set_spindle_type+0x58>
    else if(int_value >= spindle_get_count())
 8018f9e:	f003 fcb7 	bl	801c910 <spindle_get_count>
 8018fa2:	4603      	mov	r3, r0
 8018fa4:	461a      	mov	r2, r3
 8018fa6:	683b      	ldr	r3, [r7, #0]
 8018fa8:	4293      	cmp	r3, r2
 8018faa:	d301      	bcc.n	8018fb0 <set_spindle_type+0x2c>
        return Status_SettingValueOutOfRange;
 8018fac:	2334      	movs	r3, #52	; 0x34
 8018fae:	e015      	b.n	8018fdc <set_spindle_type+0x58>

    settings.spindle.flags.type = int_value;
 8018fb0:	683b      	ldr	r3, [r7, #0]
 8018fb2:	f003 031f 	and.w	r3, r3, #31
 8018fb6:	b2d9      	uxtb	r1, r3
 8018fb8:	4a0a      	ldr	r2, [pc, #40]	; (8018fe4 <set_spindle_type+0x60>)
 8018fba:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 8018fbe:	f361 0386 	bfi	r3, r1, #2, #5
 8018fc2:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7

    spindle_select(settings.spindle.flags.type);
 8018fc6:	4b07      	ldr	r3, [pc, #28]	; (8018fe4 <set_spindle_type+0x60>)
 8018fc8:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 8018fcc:	f3c3 0384 	ubfx	r3, r3, #2, #5
 8018fd0:	b2db      	uxtb	r3, r3
 8018fd2:	b25b      	sxtb	r3, r3
 8018fd4:	4618      	mov	r0, r3
 8018fd6:	f003 fb27 	bl	801c628 <spindle_select>

    return Status_OK;
 8018fda:	2300      	movs	r3, #0
}
 8018fdc:	4618      	mov	r0, r3
 8018fde:	3708      	adds	r7, #8
 8018fe0:	46bd      	mov	sp, r7
 8018fe2:	bd80      	pop	{r7, pc}
 8018fe4:	2000147c 	.word	0x2000147c

08018fe8 <set_encoder_spindle>:

static status_code_t set_encoder_spindle (setting_id_t id, uint_fast16_t int_value)
{
 8018fe8:	b580      	push	{r7, lr}
 8018fea:	b082      	sub	sp, #8
 8018fec:	af00      	add	r7, sp, #0
 8018fee:	4603      	mov	r3, r0
 8018ff0:	6039      	str	r1, [r7, #0]
 8018ff2:	80fb      	strh	r3, [r7, #6]
    if(spindle_get_count() < 2)
 8018ff4:	f003 fc8c 	bl	801c910 <spindle_get_count>
 8018ff8:	4603      	mov	r3, r0
 8018ffa:	2b01      	cmp	r3, #1
 8018ffc:	d801      	bhi.n	8019002 <set_encoder_spindle+0x1a>
        return Status_SettingDisabled;
 8018ffe:	2335      	movs	r3, #53	; 0x35
 8019000:	e014      	b.n	801902c <set_encoder_spindle+0x44>
    else if(int_value >= spindle_get_count())
 8019002:	f003 fc85 	bl	801c910 <spindle_get_count>
 8019006:	4603      	mov	r3, r0
 8019008:	461a      	mov	r2, r3
 801900a:	683b      	ldr	r3, [r7, #0]
 801900c:	4293      	cmp	r3, r2
 801900e:	d301      	bcc.n	8019014 <set_encoder_spindle+0x2c>
        return Status_SettingValueOutOfRange;
 8019010:	2334      	movs	r3, #52	; 0x34
 8019012:	e00b      	b.n	801902c <set_encoder_spindle+0x44>

    settings.offset_lock.encoder_spindle = int_value;
 8019014:	683b      	ldr	r3, [r7, #0]
 8019016:	f003 031f 	and.w	r3, r3, #31
 801901a:	b2d9      	uxtb	r1, r3
 801901c:	4a05      	ldr	r2, [pc, #20]	; (8019034 <set_encoder_spindle+0x4c>)
 801901e:	f892 3101 	ldrb.w	r3, [r2, #257]	; 0x101
 8019022:	f361 03c7 	bfi	r3, r1, #3, #5
 8019026:	f882 3101 	strb.w	r3, [r2, #257]	; 0x101

    return Status_OK;
 801902a:	2300      	movs	r3, #0
}
 801902c:	4618      	mov	r0, r3
 801902e:	3708      	adds	r7, #8
 8019030:	46bd      	mov	sp, r7
 8019032:	bd80      	pop	{r7, pc}
 8019034:	2000147c 	.word	0x2000147c

08019038 <set_spindle_invert>:

static status_code_t set_spindle_invert (setting_id_t id, uint_fast16_t int_value)
{
 8019038:	b580      	push	{r7, lr}
 801903a:	b082      	sub	sp, #8
 801903c:	af00      	add	r7, sp, #0
 801903e:	4603      	mov	r3, r0
 8019040:	6039      	str	r1, [r7, #0]
 8019042:	80fb      	strh	r3, [r7, #6]
    settings.spindle.invert.mask = int_value;
 8019044:	683b      	ldr	r3, [r7, #0]
 8019046:	b2da      	uxtb	r2, r3
 8019048:	4b11      	ldr	r3, [pc, #68]	; (8019090 <set_spindle_invert+0x58>)
 801904a:	f883 20e6 	strb.w	r2, [r3, #230]	; 0xe6
    if(settings.spindle.invert.pwm && !spindle_get_caps(false).pwm_invert) {
 801904e:	4b10      	ldr	r3, [pc, #64]	; (8019090 <set_spindle_invert+0x58>)
 8019050:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 8019054:	f003 0304 	and.w	r3, r3, #4
 8019058:	b2db      	uxtb	r3, r3
 801905a:	2b00      	cmp	r3, #0
 801905c:	d012      	beq.n	8019084 <set_spindle_invert+0x4c>
 801905e:	2000      	movs	r0, #0
 8019060:	f003 fb9c 	bl	801c79c <spindle_get_caps>
 8019064:	4603      	mov	r3, r0
 8019066:	b2db      	uxtb	r3, r3
 8019068:	f003 0310 	and.w	r3, r3, #16
 801906c:	b2db      	uxtb	r3, r3
 801906e:	2b00      	cmp	r3, #0
 8019070:	d108      	bne.n	8019084 <set_spindle_invert+0x4c>
        settings.spindle.invert.pwm = Off;
 8019072:	4a07      	ldr	r2, [pc, #28]	; (8019090 <set_spindle_invert+0x58>)
 8019074:	f892 30e6 	ldrb.w	r3, [r2, #230]	; 0xe6
 8019078:	f36f 0382 	bfc	r3, #2, #1
 801907c:	f882 30e6 	strb.w	r3, [r2, #230]	; 0xe6
        return Status_SettingDisabled;
 8019080:	2335      	movs	r3, #53	; 0x35
 8019082:	e000      	b.n	8019086 <set_spindle_invert+0x4e>
    }

    return Status_OK;
 8019084:	2300      	movs	r3, #0
}
 8019086:	4618      	mov	r0, r3
 8019088:	3708      	adds	r7, #8
 801908a:	46bd      	mov	sp, r7
 801908c:	bd80      	pop	{r7, pc}
 801908e:	bf00      	nop
 8019090:	2000147c 	.word	0x2000147c

08019094 <set_control_disable_pullup>:

static status_code_t set_control_disable_pullup (setting_id_t id, uint_fast16_t int_value)
{
 8019094:	b480      	push	{r7}
 8019096:	b083      	sub	sp, #12
 8019098:	af00      	add	r7, sp, #0
 801909a:	4603      	mov	r3, r0
 801909c:	6039      	str	r1, [r7, #0]
 801909e:	80fb      	strh	r3, [r7, #6]
    settings.control_disable_pullup.mask = int_value & hal.signals_cap.mask;
 80190a0:	4b07      	ldr	r3, [pc, #28]	; (80190c0 <set_control_disable_pullup+0x2c>)
 80190a2:	f8b3 21ac 	ldrh.w	r2, [r3, #428]	; 0x1ac
 80190a6:	683b      	ldr	r3, [r7, #0]
 80190a8:	b29b      	uxth	r3, r3
 80190aa:	4013      	ands	r3, r2
 80190ac:	b29a      	uxth	r2, r3
 80190ae:	4b05      	ldr	r3, [pc, #20]	; (80190c4 <set_control_disable_pullup+0x30>)
 80190b0:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e

    return Status_OK;
 80190b4:	2300      	movs	r3, #0
}
 80190b6:	4618      	mov	r0, r3
 80190b8:	370c      	adds	r7, #12
 80190ba:	46bd      	mov	sp, r7
 80190bc:	bc80      	pop	{r7}
 80190be:	4770      	bx	lr
 80190c0:	20000ed0 	.word	0x20000ed0
 80190c4:	2000147c 	.word	0x2000147c

080190c8 <set_probe_disable_pullup>:

static status_code_t set_probe_disable_pullup (setting_id_t id, uint_fast16_t int_value)
{
 80190c8:	b480      	push	{r7}
 80190ca:	b083      	sub	sp, #12
 80190cc:	af00      	add	r7, sp, #0
 80190ce:	4603      	mov	r3, r0
 80190d0:	6039      	str	r1, [r7, #0]
 80190d2:	80fb      	strh	r3, [r7, #6]
    if(!hal.probe.configure)
 80190d4:	4b0c      	ldr	r3, [pc, #48]	; (8019108 <set_probe_disable_pullup+0x40>)
 80190d6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 80190da:	2b00      	cmp	r3, #0
 80190dc:	d101      	bne.n	80190e2 <set_probe_disable_pullup+0x1a>
        return Status_SettingDisabled;
 80190de:	2335      	movs	r3, #53	; 0x35
 80190e0:	e00d      	b.n	80190fe <set_probe_disable_pullup+0x36>

    settings.probe.disable_probe_pullup = int_value != 0;
 80190e2:	683b      	ldr	r3, [r7, #0]
 80190e4:	2b00      	cmp	r3, #0
 80190e6:	bf14      	ite	ne
 80190e8:	2301      	movne	r3, #1
 80190ea:	2300      	moveq	r3, #0
 80190ec:	b2d9      	uxtb	r1, r3
 80190ee:	4a07      	ldr	r2, [pc, #28]	; (801910c <set_probe_disable_pullup+0x44>)
 80190f0:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
 80190f4:	f361 0341 	bfi	r3, r1, #1, #1
 80190f8:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100

    return Status_OK;
 80190fc:	2300      	movs	r3, #0
}
 80190fe:	4618      	mov	r0, r3
 8019100:	370c      	adds	r7, #12
 8019102:	46bd      	mov	sp, r7
 8019104:	bc80      	pop	{r7}
 8019106:	4770      	bx	lr
 8019108:	20000ed0 	.word	0x20000ed0
 801910c:	2000147c 	.word	0x2000147c

08019110 <tmp_set_soft_limits>:

static void tmp_set_soft_limits (void)
{
 8019110:	b580      	push	{r7, lr}
 8019112:	b082      	sub	sp, #8
 8019114:	af00      	add	r7, sp, #0
    sys.soft_limits.mask = 0;
 8019116:	4b1b      	ldr	r3, [pc, #108]	; (8019184 <tmp_set_soft_limits+0x74>)
 8019118:	2200      	movs	r2, #0
 801911a:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95

    if(settings.limits.flags.soft_enabled) {
 801911e:	4b1a      	ldr	r3, [pc, #104]	; (8019188 <tmp_set_soft_limits+0x78>)
 8019120:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8019124:	f003 0302 	and.w	r3, r3, #2
 8019128:	b2db      	uxtb	r3, r3
 801912a:	2b00      	cmp	r3, #0
 801912c:	d025      	beq.n	801917a <tmp_set_soft_limits+0x6a>
        uint_fast8_t idx = N_AXIS;
 801912e:	2303      	movs	r3, #3
 8019130:	607b      	str	r3, [r7, #4]
        do {
            if(settings.axis[--idx].max_travel < -0.0f)
 8019132:	687b      	ldr	r3, [r7, #4]
 8019134:	3b01      	subs	r3, #1
 8019136:	607b      	str	r3, [r7, #4]
 8019138:	4913      	ldr	r1, [pc, #76]	; (8019188 <tmp_set_soft_limits+0x78>)
 801913a:	687a      	ldr	r2, [r7, #4]
 801913c:	4613      	mov	r3, r2
 801913e:	009b      	lsls	r3, r3, #2
 8019140:	4413      	add	r3, r2
 8019142:	009b      	lsls	r3, r3, #2
 8019144:	440b      	add	r3, r1
 8019146:	333c      	adds	r3, #60	; 0x3c
 8019148:	681b      	ldr	r3, [r3, #0]
 801914a:	f04f 0100 	mov.w	r1, #0
 801914e:	4618      	mov	r0, r3
 8019150:	f7e7 ffce 	bl	80010f0 <__aeabi_fcmplt>
 8019154:	4603      	mov	r3, r0
 8019156:	2b00      	cmp	r3, #0
 8019158:	d00c      	beq.n	8019174 <tmp_set_soft_limits+0x64>
                bit_true(sys.soft_limits.mask, bit(idx));
 801915a:	4b0a      	ldr	r3, [pc, #40]	; (8019184 <tmp_set_soft_limits+0x74>)
 801915c:	f893 2095 	ldrb.w	r2, [r3, #149]	; 0x95
 8019160:	2101      	movs	r1, #1
 8019162:	687b      	ldr	r3, [r7, #4]
 8019164:	fa01 f303 	lsl.w	r3, r1, r3
 8019168:	b2db      	uxtb	r3, r3
 801916a:	4313      	orrs	r3, r2
 801916c:	b2da      	uxtb	r2, r3
 801916e:	4b05      	ldr	r3, [pc, #20]	; (8019184 <tmp_set_soft_limits+0x74>)
 8019170:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
        } while(idx);
 8019174:	687b      	ldr	r3, [r7, #4]
 8019176:	2b00      	cmp	r3, #0
 8019178:	d1db      	bne.n	8019132 <tmp_set_soft_limits+0x22>
    }
}
 801917a:	bf00      	nop
 801917c:	3708      	adds	r7, #8
 801917e:	46bd      	mov	sp, r7
 8019180:	bd80      	pop	{r7, pc}
 8019182:	bf00      	nop
 8019184:	20000d3c 	.word	0x20000d3c
 8019188:	2000147c 	.word	0x2000147c

0801918c <set_soft_limits_enable>:

static status_code_t set_soft_limits_enable (setting_id_t id, uint_fast16_t int_value)
{
 801918c:	b580      	push	{r7, lr}
 801918e:	b082      	sub	sp, #8
 8019190:	af00      	add	r7, sp, #0
 8019192:	4603      	mov	r3, r0
 8019194:	6039      	str	r1, [r7, #0]
 8019196:	80fb      	strh	r3, [r7, #6]
    if(int_value && !settings.homing.flags.enabled)
 8019198:	683b      	ldr	r3, [r7, #0]
 801919a:	2b00      	cmp	r3, #0
 801919c:	d009      	beq.n	80191b2 <set_soft_limits_enable+0x26>
 801919e:	4b0f      	ldr	r3, [pc, #60]	; (80191dc <set_soft_limits_enable+0x50>)
 80191a0:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 80191a4:	f003 0301 	and.w	r3, r3, #1
 80191a8:	b2db      	uxtb	r3, r3
 80191aa:	2b00      	cmp	r3, #0
 80191ac:	d101      	bne.n	80191b2 <set_soft_limits_enable+0x26>
        return Status_SoftLimitError;
 80191ae:	230a      	movs	r3, #10
 80191b0:	e00f      	b.n	80191d2 <set_soft_limits_enable+0x46>

    settings.limits.flags.soft_enabled = int_value != 0;
 80191b2:	683b      	ldr	r3, [r7, #0]
 80191b4:	2b00      	cmp	r3, #0
 80191b6:	bf14      	ite	ne
 80191b8:	2301      	movne	r3, #1
 80191ba:	2300      	moveq	r3, #0
 80191bc:	b2d9      	uxtb	r1, r3
 80191be:	4a07      	ldr	r2, [pc, #28]	; (80191dc <set_soft_limits_enable+0x50>)
 80191c0:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 80191c4:	f361 0341 	bfi	r3, r1, #1, #1
 80191c8:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124

    tmp_set_soft_limits();
 80191cc:	f7ff ffa0 	bl	8019110 <tmp_set_soft_limits>

    return Status_OK;
 80191d0:	2300      	movs	r3, #0
}
 80191d2:	4618      	mov	r0, r3
 80191d4:	3708      	adds	r7, #8
 80191d6:	46bd      	mov	sp, r7
 80191d8:	bd80      	pop	{r7, pc}
 80191da:	bf00      	nop
 80191dc:	2000147c 	.word	0x2000147c

080191e0 <set_estop_unlock>:

static status_code_t set_estop_unlock (setting_id_t id, uint_fast16_t int_value)
{
 80191e0:	b480      	push	{r7}
 80191e2:	b083      	sub	sp, #12
 80191e4:	af00      	add	r7, sp, #0
 80191e6:	4603      	mov	r3, r0
 80191e8:	6039      	str	r1, [r7, #0]
 80191ea:	80fb      	strh	r3, [r7, #6]
    if(!hal.signals_cap.e_stop)
 80191ec:	4b0e      	ldr	r3, [pc, #56]	; (8019228 <set_estop_unlock+0x48>)
 80191ee:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 80191f2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80191f6:	b2db      	uxtb	r3, r3
 80191f8:	2b00      	cmp	r3, #0
 80191fa:	d101      	bne.n	8019200 <set_estop_unlock+0x20>
        return Status_SettingDisabled;
 80191fc:	2335      	movs	r3, #53	; 0x35
 80191fe:	e00d      	b.n	801921c <set_estop_unlock+0x3c>

    settings.flags.no_unlock_after_estop = int_value != 0;
 8019200:	683b      	ldr	r3, [r7, #0]
 8019202:	2b00      	cmp	r3, #0
 8019204:	bf14      	ite	ne
 8019206:	2301      	movne	r3, #1
 8019208:	2300      	moveq	r3, #0
 801920a:	b2d9      	uxtb	r1, r3
 801920c:	4a07      	ldr	r2, [pc, #28]	; (801922c <set_estop_unlock+0x4c>)
 801920e:	f892 30ff 	ldrb.w	r3, [r2, #255]	; 0xff
 8019212:	f361 13c7 	bfi	r3, r1, #7, #1
 8019216:	f882 30ff 	strb.w	r3, [r2, #255]	; 0xff

    return Status_OK;
 801921a:	2300      	movs	r3, #0
}
 801921c:	4618      	mov	r0, r3
 801921e:	370c      	adds	r7, #12
 8019220:	46bd      	mov	sp, r7
 8019222:	bc80      	pop	{r7}
 8019224:	4770      	bx	lr
 8019226:	bf00      	nop
 8019228:	20000ed0 	.word	0x20000ed0
 801922c:	2000147c 	.word	0x2000147c

08019230 <set_offset_lock>:

static status_code_t set_offset_lock (setting_id_t id, uint_fast16_t int_value)
{
 8019230:	b480      	push	{r7}
 8019232:	b083      	sub	sp, #12
 8019234:	af00      	add	r7, sp, #0
 8019236:	4603      	mov	r3, r0
 8019238:	6039      	str	r1, [r7, #0]
 801923a:	80fb      	strh	r3, [r7, #6]
    settings.parking.flags.offset_lock = int_value & 0b111; // TODO: remove
 801923c:	683b      	ldr	r3, [r7, #0]
 801923e:	f003 0307 	and.w	r3, r3, #7
 8019242:	b2d9      	uxtb	r1, r3
 8019244:	4a11      	ldr	r2, [pc, #68]	; (801928c <set_offset_lock+0x5c>)
 8019246:	f892 3128 	ldrb.w	r3, [r2, #296]	; 0x128
 801924a:	f361 1347 	bfi	r3, r1, #5, #3
 801924e:	f882 3128 	strb.w	r3, [r2, #296]	; 0x128
    settings.offset_lock.mask &= ~0b111; // TODO: remove
 8019252:	4b0e      	ldr	r3, [pc, #56]	; (801928c <set_offset_lock+0x5c>)
 8019254:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8019258:	f023 0307 	bic.w	r3, r3, #7
 801925c:	b2da      	uxtb	r2, r3
 801925e:	4b0b      	ldr	r3, [pc, #44]	; (801928c <set_offset_lock+0x5c>)
 8019260:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
    settings.offset_lock.mask |= settings.parking.flags.offset_lock;
 8019264:	4b09      	ldr	r3, [pc, #36]	; (801928c <set_offset_lock+0x5c>)
 8019266:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801926a:	4a08      	ldr	r2, [pc, #32]	; (801928c <set_offset_lock+0x5c>)
 801926c:	f892 2128 	ldrb.w	r2, [r2, #296]	; 0x128
 8019270:	f3c2 1242 	ubfx	r2, r2, #5, #3
 8019274:	b2d2      	uxtb	r2, r2
 8019276:	4313      	orrs	r3, r2
 8019278:	b2da      	uxtb	r2, r3
 801927a:	4b04      	ldr	r3, [pc, #16]	; (801928c <set_offset_lock+0x5c>)
 801927c:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101

    return Status_OK;
 8019280:	2300      	movs	r3, #0
}
 8019282:	4618      	mov	r0, r3
 8019284:	370c      	adds	r7, #12
 8019286:	46bd      	mov	sp, r7
 8019288:	bc80      	pop	{r7}
 801928a:	4770      	bx	lr
 801928c:	2000147c 	.word	0x2000147c

08019290 <tmp_set_hard_limits>:

static inline void tmp_set_hard_limits (void)
{
 8019290:	b480      	push	{r7}
 8019292:	af00      	add	r7, sp, #0
    sys.hard_limits.mask = settings.limits.flags.hard_enabled ? AXES_BITMASK : 0;
 8019294:	4b08      	ldr	r3, [pc, #32]	; (80192b8 <tmp_set_hard_limits+0x28>)
 8019296:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801929a:	f003 0301 	and.w	r3, r3, #1
 801929e:	b2db      	uxtb	r3, r3
 80192a0:	2b00      	cmp	r3, #0
 80192a2:	d001      	beq.n	80192a8 <tmp_set_hard_limits+0x18>
 80192a4:	2207      	movs	r2, #7
 80192a6:	e000      	b.n	80192aa <tmp_set_hard_limits+0x1a>
 80192a8:	2200      	movs	r2, #0
 80192aa:	4b04      	ldr	r3, [pc, #16]	; (80192bc <tmp_set_hard_limits+0x2c>)
 80192ac:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
  #if N_AXIS > 3
    if(settings.limits.flags.hard_disabled_rotary)
        sys.hard_limits.mask &= ~settings.steppers.is_rotational.mask;
  #endif
}
 80192b0:	bf00      	nop
 80192b2:	46bd      	mov	sp, r7
 80192b4:	bc80      	pop	{r7}
 80192b6:	4770      	bx	lr
 80192b8:	2000147c 	.word	0x2000147c
 80192bc:	20000d3c 	.word	0x20000d3c

080192c0 <set_hard_limits_enable>:

static status_code_t set_hard_limits_enable (setting_id_t id, uint_fast16_t int_value)
{
 80192c0:	b580      	push	{r7, lr}
 80192c2:	b082      	sub	sp, #8
 80192c4:	af00      	add	r7, sp, #0
 80192c6:	4603      	mov	r3, r0
 80192c8:	6039      	str	r1, [r7, #0]
 80192ca:	80fb      	strh	r3, [r7, #6]
    if((settings.limits.flags.hard_enabled = bit_istrue(int_value, bit(0)))) {
 80192cc:	683b      	ldr	r3, [r7, #0]
 80192ce:	f003 0301 	and.w	r3, r3, #1
 80192d2:	2b00      	cmp	r3, #0
 80192d4:	bf14      	ite	ne
 80192d6:	2301      	movne	r3, #1
 80192d8:	2300      	moveq	r3, #0
 80192da:	b2d9      	uxtb	r1, r3
 80192dc:	4a24      	ldr	r2, [pc, #144]	; (8019370 <set_hard_limits_enable+0xb0>)
 80192de:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 80192e2:	f361 0300 	bfi	r3, r1, #0, #1
 80192e6:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
 80192ea:	4b21      	ldr	r3, [pc, #132]	; (8019370 <set_hard_limits_enable+0xb0>)
 80192ec:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 80192f0:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80192f4:	b2db      	uxtb	r3, r3
 80192f6:	2b00      	cmp	r3, #0
 80192f8:	d00f      	beq.n	801931a <set_hard_limits_enable+0x5a>
#if COMPATIBILITY_LEVEL <= 1
        settings.limits.flags.check_at_init = bit_istrue(int_value, bit(1));
 80192fa:	683b      	ldr	r3, [r7, #0]
 80192fc:	f003 0302 	and.w	r3, r3, #2
 8019300:	2b00      	cmp	r3, #0
 8019302:	bf14      	ite	ne
 8019304:	2301      	movne	r3, #1
 8019306:	2300      	moveq	r3, #0
 8019308:	b2d9      	uxtb	r1, r3
 801930a:	4a19      	ldr	r2, [pc, #100]	; (8019370 <set_hard_limits_enable+0xb0>)
 801930c:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 8019310:	f361 0382 	bfi	r3, r1, #2, #1
 8019314:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
 8019318:	e013      	b.n	8019342 <set_hard_limits_enable+0x82>
  #if N_AXIS > 3
        settings.limits.flags.hard_disabled_rotary = bit_istrue(int_value, bit(2));
  #endif
#endif
    } else
        settings.limits.flags.check_at_init = settings.limits.flags.hard_disabled_rotary = Off;
 801931a:	4a15      	ldr	r2, [pc, #84]	; (8019370 <set_hard_limits_enable+0xb0>)
 801931c:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 8019320:	f36f 1345 	bfc	r3, #5, #1
 8019324:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
 8019328:	4b11      	ldr	r3, [pc, #68]	; (8019370 <set_hard_limits_enable+0xb0>)
 801932a:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801932e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8019332:	b2d9      	uxtb	r1, r3
 8019334:	4a0e      	ldr	r2, [pc, #56]	; (8019370 <set_hard_limits_enable+0xb0>)
 8019336:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 801933a:	f361 0382 	bfi	r3, r1, #2, #1
 801933e:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124

    tmp_set_hard_limits();
 8019342:	f7ff ffa5 	bl	8019290 <tmp_set_hard_limits>
    hal.limits.enable(settings.limits.flags.hard_enabled, (axes_signals_t){0}); // Change immediately. NOTE: Nice to have but could be problematic later.
 8019346:	4b0b      	ldr	r3, [pc, #44]	; (8019374 <set_hard_limits_enable+0xb4>)
 8019348:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801934a:	4a09      	ldr	r2, [pc, #36]	; (8019370 <set_hard_limits_enable+0xb0>)
 801934c:	f892 2124 	ldrb.w	r2, [r2, #292]	; 0x124
 8019350:	f3c2 0200 	ubfx	r2, r2, #0, #1
 8019354:	b2d2      	uxtb	r2, r2
 8019356:	2a00      	cmp	r2, #0
 8019358:	bf14      	ite	ne
 801935a:	2201      	movne	r2, #1
 801935c:	2200      	moveq	r2, #0
 801935e:	b2d2      	uxtb	r2, r2
 8019360:	2100      	movs	r1, #0
 8019362:	4610      	mov	r0, r2
 8019364:	4798      	blx	r3

    return Status_OK;
 8019366:	2300      	movs	r3, #0
}
 8019368:	4618      	mov	r0, r3
 801936a:	3708      	adds	r7, #8
 801936c:	46bd      	mov	sp, r7
 801936e:	bd80      	pop	{r7, pc}
 8019370:	2000147c 	.word	0x2000147c
 8019374:	20000ed0 	.word	0x20000ed0

08019378 <set_jog_soft_limited>:

static status_code_t set_jog_soft_limited (setting_id_t id, uint_fast16_t int_value)
{
 8019378:	b480      	push	{r7}
 801937a:	b083      	sub	sp, #12
 801937c:	af00      	add	r7, sp, #0
 801937e:	4603      	mov	r3, r0
 8019380:	6039      	str	r1, [r7, #0]
 8019382:	80fb      	strh	r3, [r7, #6]
    if (int_value && !settings.homing.flags.enabled)
 8019384:	683b      	ldr	r3, [r7, #0]
 8019386:	2b00      	cmp	r3, #0
 8019388:	d009      	beq.n	801939e <set_jog_soft_limited+0x26>
 801938a:	4b0e      	ldr	r3, [pc, #56]	; (80193c4 <set_jog_soft_limited+0x4c>)
 801938c:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8019390:	f003 0301 	and.w	r3, r3, #1
 8019394:	b2db      	uxtb	r3, r3
 8019396:	2b00      	cmp	r3, #0
 8019398:	d101      	bne.n	801939e <set_jog_soft_limited+0x26>
        return Status_SoftLimitError;
 801939a:	230a      	movs	r3, #10
 801939c:	e00d      	b.n	80193ba <set_jog_soft_limited+0x42>

    settings.limits.flags.jog_soft_limited = int_value != 0;
 801939e:	683b      	ldr	r3, [r7, #0]
 80193a0:	2b00      	cmp	r3, #0
 80193a2:	bf14      	ite	ne
 80193a4:	2301      	movne	r3, #1
 80193a6:	2300      	moveq	r3, #0
 80193a8:	b2d9      	uxtb	r1, r3
 80193aa:	4a06      	ldr	r2, [pc, #24]	; (80193c4 <set_jog_soft_limited+0x4c>)
 80193ac:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 80193b0:	f361 03c3 	bfi	r3, r1, #3, #1
 80193b4:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124

    return Status_OK;
 80193b8:	2300      	movs	r3, #0
}
 80193ba:	4618      	mov	r0, r3
 80193bc:	370c      	adds	r7, #12
 80193be:	46bd      	mov	sp, r7
 80193c0:	bc80      	pop	{r7}
 80193c2:	4770      	bx	lr
 80193c4:	2000147c 	.word	0x2000147c

080193c8 <set_homing_enable>:

static status_code_t set_homing_enable (setting_id_t id, uint_fast16_t int_value)
{
 80193c8:	b480      	push	{r7}
 80193ca:	b083      	sub	sp, #12
 80193cc:	af00      	add	r7, sp, #0
 80193ce:	4603      	mov	r3, r0
 80193d0:	6039      	str	r1, [r7, #0]
 80193d2:	80fb      	strh	r3, [r7, #6]
    if (bit_istrue(int_value, bit(0))) {
 80193d4:	683b      	ldr	r3, [r7, #0]
 80193d6:	f003 0301 	and.w	r3, r3, #1
 80193da:	2b00      	cmp	r3, #0
 80193dc:	d044      	beq.n	8019468 <set_homing_enable+0xa0>
        settings.homing.flags.manual = DEFAULT_HOMING_ALLOW_MANUAL;
        settings.homing.flags.override_locks = DEFAULT_HOMING_OVERRIDE_LOCKS;
        settings.homing.flags.keep_on_reset = DEFAULT_HOMING_KEEP_STATUS_ON_RESET;
        settings.limits.flags.two_switches = DEFAULT_LIMITS_TWO_SWITCHES_ON_AXES;
#else
        settings.homing.flags.value = int_value & 0x0F;
 80193de:	683b      	ldr	r3, [r7, #0]
 80193e0:	b2db      	uxtb	r3, r3
 80193e2:	f003 030f 	and.w	r3, r3, #15
 80193e6:	b2da      	uxtb	r2, r3
 80193e8:	4b2b      	ldr	r3, [pc, #172]	; (8019498 <set_homing_enable+0xd0>)
 80193ea:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 80193ee:	683b      	ldr	r3, [r7, #0]
 80193f0:	f003 0310 	and.w	r3, r3, #16
 80193f4:	2b00      	cmp	r3, #0
 80193f6:	bf14      	ite	ne
 80193f8:	2301      	movne	r3, #1
 80193fa:	2300      	moveq	r3, #0
 80193fc:	b2d9      	uxtb	r1, r3
 80193fe:	4a26      	ldr	r2, [pc, #152]	; (8019498 <set_homing_enable+0xd0>)
 8019400:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 8019404:	f361 1304 	bfi	r3, r1, #4, #1
 8019408:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
        settings.homing.flags.manual = bit_istrue(int_value, bit(5));
 801940c:	683b      	ldr	r3, [r7, #0]
 801940e:	f003 0320 	and.w	r3, r3, #32
 8019412:	2b00      	cmp	r3, #0
 8019414:	bf14      	ite	ne
 8019416:	2301      	movne	r3, #1
 8019418:	2300      	moveq	r3, #0
 801941a:	b2d9      	uxtb	r1, r3
 801941c:	4a1e      	ldr	r2, [pc, #120]	; (8019498 <set_homing_enable+0xd0>)
 801941e:	f892 3114 	ldrb.w	r3, [r2, #276]	; 0x114
 8019422:	f361 1304 	bfi	r3, r1, #4, #1
 8019426:	f882 3114 	strb.w	r3, [r2, #276]	; 0x114
        settings.homing.flags.override_locks = bit_istrue(int_value, bit(6));
 801942a:	683b      	ldr	r3, [r7, #0]
 801942c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8019430:	2b00      	cmp	r3, #0
 8019432:	bf14      	ite	ne
 8019434:	2301      	movne	r3, #1
 8019436:	2300      	moveq	r3, #0
 8019438:	b2d9      	uxtb	r1, r3
 801943a:	4a17      	ldr	r2, [pc, #92]	; (8019498 <set_homing_enable+0xd0>)
 801943c:	f892 3114 	ldrb.w	r3, [r2, #276]	; 0x114
 8019440:	f361 1345 	bfi	r3, r1, #5, #1
 8019444:	f882 3114 	strb.w	r3, [r2, #276]	; 0x114
        settings.homing.flags.keep_on_reset = bit_istrue(int_value, bit(7));
 8019448:	683b      	ldr	r3, [r7, #0]
 801944a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801944e:	2b00      	cmp	r3, #0
 8019450:	bf14      	ite	ne
 8019452:	2301      	movne	r3, #1
 8019454:	2300      	moveq	r3, #0
 8019456:	b2d9      	uxtb	r1, r3
 8019458:	4a0f      	ldr	r2, [pc, #60]	; (8019498 <set_homing_enable+0xd0>)
 801945a:	f892 3114 	ldrb.w	r3, [r2, #276]	; 0x114
 801945e:	f361 1386 	bfi	r3, r1, #6, #1
 8019462:	f882 3114 	strb.w	r3, [r2, #276]	; 0x114
 8019466:	e011      	b.n	801948c <set_homing_enable+0xc4>
#endif
    } else {
        settings.homing.flags.value = 0;
 8019468:	4b0b      	ldr	r3, [pc, #44]	; (8019498 <set_homing_enable+0xd0>)
 801946a:	2200      	movs	r2, #0
 801946c:	f883 2114 	strb.w	r2, [r3, #276]	; 0x114
        settings.limits.flags.soft_enabled = Off; // Force disable soft-limits.
 8019470:	4a09      	ldr	r2, [pc, #36]	; (8019498 <set_homing_enable+0xd0>)
 8019472:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 8019476:	f36f 0341 	bfc	r3, #1, #1
 801947a:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
        settings.limits.flags.jog_soft_limited = Off;
 801947e:	4a06      	ldr	r2, [pc, #24]	; (8019498 <set_homing_enable+0xd0>)
 8019480:	f892 3124 	ldrb.w	r3, [r2, #292]	; 0x124
 8019484:	f36f 03c3 	bfc	r3, #3, #1
 8019488:	f882 3124 	strb.w	r3, [r2, #292]	; 0x124
    }

    return Status_OK;
 801948c:	2300      	movs	r3, #0
}
 801948e:	4618      	mov	r0, r3
 8019490:	370c      	adds	r7, #12
 8019492:	46bd      	mov	sp, r7
 8019494:	bc80      	pop	{r7}
 8019496:	4770      	bx	lr
 8019498:	2000147c 	.word	0x2000147c

0801949c <set_enable_legacy_rt_commands>:

static status_code_t set_enable_legacy_rt_commands (setting_id_t id, uint_fast16_t int_value)
{
 801949c:	b480      	push	{r7}
 801949e:	b083      	sub	sp, #12
 80194a0:	af00      	add	r7, sp, #0
 80194a2:	4603      	mov	r3, r0
 80194a4:	6039      	str	r1, [r7, #0]
 80194a6:	80fb      	strh	r3, [r7, #6]
    settings.flags.legacy_rt_commands = int_value != 0;
 80194a8:	683b      	ldr	r3, [r7, #0]
 80194aa:	2b00      	cmp	r3, #0
 80194ac:	bf14      	ite	ne
 80194ae:	2301      	movne	r3, #1
 80194b0:	2300      	moveq	r3, #0
 80194b2:	b2d9      	uxtb	r1, r3
 80194b4:	4a06      	ldr	r2, [pc, #24]	; (80194d0 <set_enable_legacy_rt_commands+0x34>)
 80194b6:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 80194ba:	f361 1386 	bfi	r3, r1, #6, #1
 80194be:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe

    return Status_OK;
 80194c2:	2300      	movs	r3, #0
}
 80194c4:	4618      	mov	r0, r3
 80194c6:	370c      	adds	r7, #12
 80194c8:	46bd      	mov	sp, r7
 80194ca:	bc80      	pop	{r7}
 80194cc:	4770      	bx	lr
 80194ce:	bf00      	nop
 80194d0:	2000147c 	.word	0x2000147c

080194d4 <set_homing_cycle>:

static status_code_t set_homing_cycle (setting_id_t id, uint_fast16_t int_value)
{
 80194d4:	b580      	push	{r7, lr}
 80194d6:	b082      	sub	sp, #8
 80194d8:	af00      	add	r7, sp, #0
 80194da:	4603      	mov	r3, r0
 80194dc:	6039      	str	r1, [r7, #0]
 80194de:	80fb      	strh	r3, [r7, #6]
    settings.homing.cycle[id - Setting_HomingCycle_1].mask = int_value;
 80194e0:	88fb      	ldrh	r3, [r7, #6]
 80194e2:	3b2c      	subs	r3, #44	; 0x2c
 80194e4:	683a      	ldr	r2, [r7, #0]
 80194e6:	b2d1      	uxtb	r1, r2
 80194e8:	4a05      	ldr	r2, [pc, #20]	; (8019500 <set_homing_cycle+0x2c>)
 80194ea:	4413      	add	r3, r2
 80194ec:	460a      	mov	r2, r1
 80194ee:	f883 2115 	strb.w	r2, [r3, #277]	; 0x115
    limits_set_homing_axes();
 80194f2:	f7f3 fbeb 	bl	800cccc <limits_set_homing_axes>

    return Status_OK;
 80194f6:	2300      	movs	r3, #0
}
 80194f8:	4618      	mov	r0, r3
 80194fa:	3708      	adds	r7, #8
 80194fc:	46bd      	mov	sp, r7
 80194fe:	bd80      	pop	{r7, pc}
 8019500:	2000147c 	.word	0x2000147c

08019504 <set_mode>:

#if !LATHE_UVW_OPTION

static status_code_t set_mode (setting_id_t id, uint_fast16_t int_value)
{
 8019504:	b580      	push	{r7, lr}
 8019506:	b082      	sub	sp, #8
 8019508:	af00      	add	r7, sp, #0
 801950a:	4603      	mov	r3, r0
 801950c:	6039      	str	r1, [r7, #0]
 801950e:	80fb      	strh	r3, [r7, #6]
    switch((machine_mode_t)int_value) {
 8019510:	683b      	ldr	r3, [r7, #0]
 8019512:	b2db      	uxtb	r3, r3
 8019514:	2b02      	cmp	r3, #2
 8019516:	d01c      	beq.n	8019552 <set_mode+0x4e>
 8019518:	2b02      	cmp	r3, #2
 801951a:	dc18      	bgt.n	801954e <set_mode+0x4a>
 801951c:	2b00      	cmp	r3, #0
 801951e:	d002      	beq.n	8019526 <set_mode+0x22>
 8019520:	2b01      	cmp	r3, #1
 8019522:	d004      	beq.n	801952e <set_mode+0x2a>
 8019524:	e013      	b.n	801954e <set_mode+0x4a>

        case Mode_Standard:
           gc_state.modal.diameter_mode = false;
 8019526:	4b11      	ldr	r3, [pc, #68]	; (801956c <set_mode+0x68>)
 8019528:	2200      	movs	r2, #0
 801952a:	715a      	strb	r2, [r3, #5]
           break;
 801952c:	e012      	b.n	8019554 <set_mode+0x50>

        case Mode_Laser:
            if(!spindle_get_caps(false).laser)
 801952e:	2000      	movs	r0, #0
 8019530:	f003 f934 	bl	801c79c <spindle_get_caps>
 8019534:	4603      	mov	r3, r0
 8019536:	b2db      	uxtb	r3, r3
 8019538:	f003 0308 	and.w	r3, r3, #8
 801953c:	b2db      	uxtb	r3, r3
 801953e:	2b00      	cmp	r3, #0
 8019540:	d101      	bne.n	8019546 <set_mode+0x42>
                return Status_SettingDisabledLaser;
 8019542:	2311      	movs	r3, #17
 8019544:	e00e      	b.n	8019564 <set_mode+0x60>
            gc_state.modal.diameter_mode = false;
 8019546:	4b09      	ldr	r3, [pc, #36]	; (801956c <set_mode+0x68>)
 8019548:	2200      	movs	r2, #0
 801954a:	715a      	strb	r2, [r3, #5]
            break;
 801954c:	e002      	b.n	8019554 <set_mode+0x50>

         case Mode_Lathe:
            break;

         default: // Mode_Standard
            return Status_InvalidStatement;
 801954e:	2303      	movs	r3, #3
 8019550:	e008      	b.n	8019564 <set_mode+0x60>
            break;
 8019552:	bf00      	nop
    }

    machine_mode_changed = true;
 8019554:	4b06      	ldr	r3, [pc, #24]	; (8019570 <set_mode+0x6c>)
 8019556:	2201      	movs	r2, #1
 8019558:	701a      	strb	r2, [r3, #0]
    settings.mode = (machine_mode_t)int_value;
 801955a:	683b      	ldr	r3, [r7, #0]
 801955c:	b2da      	uxtb	r2, r3
 801955e:	4b05      	ldr	r3, [pc, #20]	; (8019574 <set_mode+0x70>)
 8019560:	761a      	strb	r2, [r3, #24]

    return Status_OK;
 8019562:	2300      	movs	r3, #0
}
 8019564:	4618      	mov	r0, r3
 8019566:	3708      	adds	r7, #8
 8019568:	46bd      	mov	sp, r7
 801956a:	bd80      	pop	{r7, pc}
 801956c:	20000bb0 	.word	0x20000bb0
 8019570:	200015e8 	.word	0x200015e8
 8019574:	2000147c 	.word	0x2000147c

08019578 <set_parking_enable>:
#endif // LATHE_UVW_OPTION

#ifndef NO_SAFETY_DOOR_SUPPORT

static status_code_t set_parking_enable (setting_id_t id, uint_fast16_t int_value)
{
 8019578:	b480      	push	{r7}
 801957a:	b083      	sub	sp, #12
 801957c:	af00      	add	r7, sp, #0
 801957e:	4603      	mov	r3, r0
 8019580:	6039      	str	r1, [r7, #0]
 8019582:	80fb      	strh	r3, [r7, #6]
    settings.parking.flags.value = bit_istrue(int_value, bit(0)) ? (int_value & 0x07) : 0;
 8019584:	683b      	ldr	r3, [r7, #0]
 8019586:	f003 0301 	and.w	r3, r3, #1
 801958a:	2b00      	cmp	r3, #0
 801958c:	d005      	beq.n	801959a <set_parking_enable+0x22>
 801958e:	683b      	ldr	r3, [r7, #0]
 8019590:	b2db      	uxtb	r3, r3
 8019592:	f003 0307 	and.w	r3, r3, #7
 8019596:	b2db      	uxtb	r3, r3
 8019598:	e000      	b.n	801959c <set_parking_enable+0x24>
 801959a:	2300      	movs	r3, #0
 801959c:	4a04      	ldr	r2, [pc, #16]	; (80195b0 <set_parking_enable+0x38>)
 801959e:	f882 3128 	strb.w	r3, [r2, #296]	; 0x128

    return Status_OK;
 80195a2:	2300      	movs	r3, #0
}
 80195a4:	4618      	mov	r0, r3
 80195a6:	370c      	adds	r7, #12
 80195a8:	46bd      	mov	sp, r7
 80195aa:	bc80      	pop	{r7}
 80195ac:	4770      	bx	lr
 80195ae:	bf00      	nop
 80195b0:	2000147c 	.word	0x2000147c

080195b4 <set_restore_overrides>:

static status_code_t set_restore_overrides (setting_id_t id, uint_fast16_t int_value)
{
 80195b4:	b480      	push	{r7}
 80195b6:	b083      	sub	sp, #12
 80195b8:	af00      	add	r7, sp, #0
 80195ba:	4603      	mov	r3, r0
 80195bc:	6039      	str	r1, [r7, #0]
 80195be:	80fb      	strh	r3, [r7, #6]
    settings.flags.restore_overrides = int_value != 0;
 80195c0:	683b      	ldr	r3, [r7, #0]
 80195c2:	2b00      	cmp	r3, #0
 80195c4:	bf14      	ite	ne
 80195c6:	2301      	movne	r3, #1
 80195c8:	2300      	moveq	r3, #0
 80195ca:	b2d9      	uxtb	r1, r3
 80195cc:	4a06      	ldr	r2, [pc, #24]	; (80195e8 <set_restore_overrides+0x34>)
 80195ce:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 80195d2:	f361 0341 	bfi	r3, r1, #1, #1
 80195d6:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe

    return Status_OK;
 80195da:	2300      	movs	r3, #0
}
 80195dc:	4618      	mov	r0, r3
 80195de:	370c      	adds	r7, #12
 80195e0:	46bd      	mov	sp, r7
 80195e2:	bc80      	pop	{r7}
 80195e4:	4770      	bx	lr
 80195e6:	bf00      	nop
 80195e8:	2000147c 	.word	0x2000147c

080195ec <set_sleep_enable>:

#endif // NO_SAFETY_DOOR_SUPPORT

static status_code_t set_sleep_enable (setting_id_t id, uint_fast16_t int_value)
{
 80195ec:	b480      	push	{r7}
 80195ee:	b083      	sub	sp, #12
 80195f0:	af00      	add	r7, sp, #0
 80195f2:	4603      	mov	r3, r0
 80195f4:	6039      	str	r1, [r7, #0]
 80195f6:	80fb      	strh	r3, [r7, #6]
    settings.flags.sleep_enable = int_value != 0;
 80195f8:	683b      	ldr	r3, [r7, #0]
 80195fa:	2b00      	cmp	r3, #0
 80195fc:	bf14      	ite	ne
 80195fe:	2301      	movne	r3, #1
 8019600:	2300      	moveq	r3, #0
 8019602:	b2d9      	uxtb	r1, r3
 8019604:	4a06      	ldr	r2, [pc, #24]	; (8019620 <set_sleep_enable+0x34>)
 8019606:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 801960a:	f361 03c3 	bfi	r3, r1, #3, #1
 801960e:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe

    return Status_OK;
 8019612:	2300      	movs	r3, #0
}
 8019614:	4618      	mov	r0, r3
 8019616:	370c      	adds	r7, #12
 8019618:	46bd      	mov	sp, r7
 801961a:	bc80      	pop	{r7}
 801961c:	4770      	bx	lr
 801961e:	bf00      	nop
 8019620:	2000147c 	.word	0x2000147c

08019624 <set_hold_actions>:

static status_code_t set_hold_actions (setting_id_t id, uint_fast16_t int_value)
{
 8019624:	b480      	push	{r7}
 8019626:	b083      	sub	sp, #12
 8019628:	af00      	add	r7, sp, #0
 801962a:	4603      	mov	r3, r0
 801962c:	6039      	str	r1, [r7, #0]
 801962e:	80fb      	strh	r3, [r7, #6]
    settings.flags.disable_laser_during_hold = bit_istrue(int_value, bit(0));
 8019630:	683b      	ldr	r3, [r7, #0]
 8019632:	f003 0301 	and.w	r3, r3, #1
 8019636:	2b00      	cmp	r3, #0
 8019638:	bf14      	ite	ne
 801963a:	2301      	movne	r3, #1
 801963c:	2300      	moveq	r3, #0
 801963e:	b2d9      	uxtb	r1, r3
 8019640:	4a0d      	ldr	r2, [pc, #52]	; (8019678 <set_hold_actions+0x54>)
 8019642:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 8019646:	f361 1304 	bfi	r3, r1, #4, #1
 801964a:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe
    settings.flags.restore_after_feed_hold = bit_istrue(int_value, bit(1));
 801964e:	683b      	ldr	r3, [r7, #0]
 8019650:	f003 0302 	and.w	r3, r3, #2
 8019654:	2b00      	cmp	r3, #0
 8019656:	bf14      	ite	ne
 8019658:	2301      	movne	r3, #1
 801965a:	2300      	moveq	r3, #0
 801965c:	b2d9      	uxtb	r1, r3
 801965e:	4a06      	ldr	r2, [pc, #24]	; (8019678 <set_hold_actions+0x54>)
 8019660:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 8019664:	f361 13c7 	bfi	r3, r1, #7, #1
 8019668:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe

    return Status_OK;
 801966c:	2300      	movs	r3, #0
}
 801966e:	4618      	mov	r0, r3
 8019670:	370c      	adds	r7, #12
 8019672:	46bd      	mov	sp, r7
 8019674:	bc80      	pop	{r7}
 8019676:	4770      	bx	lr
 8019678:	2000147c 	.word	0x2000147c

0801967c <set_g92_disable_persistence>:

#if COMPATIBILITY_LEVEL <= 1
static status_code_t set_g92_disable_persistence (setting_id_t id, uint_fast16_t int_value)
{
 801967c:	b480      	push	{r7}
 801967e:	b083      	sub	sp, #12
 8019680:	af00      	add	r7, sp, #0
 8019682:	4603      	mov	r3, r0
 8019684:	6039      	str	r1, [r7, #0]
 8019686:	80fb      	strh	r3, [r7, #6]
    settings.flags.g92_is_volatile = int_value != 0;
 8019688:	683b      	ldr	r3, [r7, #0]
 801968a:	2b00      	cmp	r3, #0
 801968c:	bf14      	ite	ne
 801968e:	2301      	movne	r3, #1
 8019690:	2300      	moveq	r3, #0
 8019692:	b2d9      	uxtb	r1, r3
 8019694:	4a06      	ldr	r2, [pc, #24]	; (80196b0 <set_g92_disable_persistence+0x34>)
 8019696:	f892 30ff 	ldrb.w	r3, [r2, #255]	; 0xff
 801969a:	f361 0341 	bfi	r3, r1, #1, #1
 801969e:	f882 30ff 	strb.w	r3, [r2, #255]	; 0xff

    return Status_OK;
 80196a2:	2300      	movs	r3, #0
}
 80196a4:	4618      	mov	r0, r3
 80196a6:	370c      	adds	r7, #12
 80196a8:	46bd      	mov	sp, r7
 80196aa:	bc80      	pop	{r7}
 80196ac:	4770      	bx	lr
 80196ae:	bf00      	nop
 80196b0:	2000147c 	.word	0x2000147c

080196b4 <set_force_initialization_alarm>:
#endif

static status_code_t set_force_initialization_alarm (setting_id_t id, uint_fast16_t int_value)
{
 80196b4:	b480      	push	{r7}
 80196b6:	b083      	sub	sp, #12
 80196b8:	af00      	add	r7, sp, #0
 80196ba:	4603      	mov	r3, r0
 80196bc:	6039      	str	r1, [r7, #0]
 80196be:	80fb      	strh	r3, [r7, #6]
    settings.flags.force_initialization_alarm = int_value != 0;
 80196c0:	683b      	ldr	r3, [r7, #0]
 80196c2:	2b00      	cmp	r3, #0
 80196c4:	bf14      	ite	ne
 80196c6:	2301      	movne	r3, #1
 80196c8:	2300      	moveq	r3, #0
 80196ca:	b2d9      	uxtb	r1, r3
 80196cc:	4a06      	ldr	r2, [pc, #24]	; (80196e8 <set_force_initialization_alarm+0x34>)
 80196ce:	f892 30fe 	ldrb.w	r3, [r2, #254]	; 0xfe
 80196d2:	f361 1345 	bfi	r3, r1, #5, #1
 80196d6:	f882 30fe 	strb.w	r3, [r2, #254]	; 0xfe

    return Status_OK;
 80196da:	2300      	movs	r3, #0
}
 80196dc:	4618      	mov	r0, r3
 80196de:	370c      	adds	r7, #12
 80196e0:	46bd      	mov	sp, r7
 80196e2:	bc80      	pop	{r7}
 80196e4:	4770      	bx	lr
 80196e6:	bf00      	nop
 80196e8:	2000147c 	.word	0x2000147c

080196ec <set_probe_allow_feed_override>:

static status_code_t set_probe_allow_feed_override (setting_id_t id, uint_fast16_t int_value)
{
 80196ec:	b480      	push	{r7}
 80196ee:	b083      	sub	sp, #12
 80196f0:	af00      	add	r7, sp, #0
 80196f2:	4603      	mov	r3, r0
 80196f4:	6039      	str	r1, [r7, #0]
 80196f6:	80fb      	strh	r3, [r7, #6]
    settings.probe.allow_feed_override = int_value != 0;
 80196f8:	683b      	ldr	r3, [r7, #0]
 80196fa:	2b00      	cmp	r3, #0
 80196fc:	bf14      	ite	ne
 80196fe:	2301      	movne	r3, #1
 8019700:	2300      	moveq	r3, #0
 8019702:	b2d9      	uxtb	r1, r3
 8019704:	4a06      	ldr	r2, [pc, #24]	; (8019720 <set_probe_allow_feed_override+0x34>)
 8019706:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
 801970a:	f361 1304 	bfi	r3, r1, #4, #1
 801970e:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100

    return Status_OK;
 8019712:	2300      	movs	r3, #0
}
 8019714:	4618      	mov	r0, r3
 8019716:	370c      	adds	r7, #12
 8019718:	46bd      	mov	sp, r7
 801971a:	bc80      	pop	{r7}
 801971c:	4770      	bx	lr
 801971e:	bf00      	nop
 8019720:	2000147c 	.word	0x2000147c

08019724 <set_tool_change_mode>:

static status_code_t set_tool_change_mode (setting_id_t id, uint_fast16_t int_value)
{
 8019724:	b580      	push	{r7, lr}
 8019726:	b082      	sub	sp, #8
 8019728:	af00      	add	r7, sp, #0
 801972a:	4603      	mov	r3, r0
 801972c:	6039      	str	r1, [r7, #0]
 801972e:	80fb      	strh	r3, [r7, #6]
    if(!hal.driver_cap.atc && hal.stream.suspend_read && int_value <= ToolChange_Ignore) {
 8019730:	4b0e      	ldr	r3, [pc, #56]	; (801976c <set_tool_change_mode+0x48>)
 8019732:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8019736:	f003 0304 	and.w	r3, r3, #4
 801973a:	b2db      	uxtb	r3, r3
 801973c:	2b00      	cmp	r3, #0
 801973e:	d110      	bne.n	8019762 <set_tool_change_mode+0x3e>
 8019740:	4b0a      	ldr	r3, [pc, #40]	; (801976c <set_tool_change_mode+0x48>)
 8019742:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8019746:	2b00      	cmp	r3, #0
 8019748:	d00b      	beq.n	8019762 <set_tool_change_mode+0x3e>
 801974a:	683b      	ldr	r3, [r7, #0]
 801974c:	2b04      	cmp	r3, #4
 801974e:	d808      	bhi.n	8019762 <set_tool_change_mode+0x3e>
#if COMPATIBILITY_LEVEL > 1
        if((toolchange_mode_t)int_value == ToolChange_Manual_G59_3 || (toolchange_mode_t)int_value == ToolChange_SemiAutomatic)
            return Status_InvalidStatement;
#endif
        settings.tool_change.mode = (toolchange_mode_t)int_value;
 8019750:	683b      	ldr	r3, [r7, #0]
 8019752:	b2da      	uxtb	r2, r3
 8019754:	4b06      	ldr	r3, [pc, #24]	; (8019770 <set_tool_change_mode+0x4c>)
 8019756:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        tc_init();
 801975a:	f009 f981 	bl	8022a60 <tc_init>
    } else
        return Status_InvalidStatement;

    return Status_OK;
 801975e:	2300      	movs	r3, #0
 8019760:	e000      	b.n	8019764 <set_tool_change_mode+0x40>
        return Status_InvalidStatement;
 8019762:	2303      	movs	r3, #3
}
 8019764:	4618      	mov	r0, r3
 8019766:	3708      	adds	r7, #8
 8019768:	46bd      	mov	sp, r7
 801976a:	bd80      	pop	{r7, pc}
 801976c:	20000ed0 	.word	0x20000ed0
 8019770:	2000147c 	.word	0x2000147c

08019774 <set_tool_change_probing_distance>:

static status_code_t set_tool_change_probing_distance (setting_id_t id, float value)
{
 8019774:	b480      	push	{r7}
 8019776:	b083      	sub	sp, #12
 8019778:	af00      	add	r7, sp, #0
 801977a:	4603      	mov	r3, r0
 801977c:	6039      	str	r1, [r7, #0]
 801977e:	80fb      	strh	r3, [r7, #6]
    if(hal.driver_cap.atc)
 8019780:	4b09      	ldr	r3, [pc, #36]	; (80197a8 <set_tool_change_probing_distance+0x34>)
 8019782:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8019786:	f003 0304 	and.w	r3, r3, #4
 801978a:	b2db      	uxtb	r3, r3
 801978c:	2b00      	cmp	r3, #0
 801978e:	d001      	beq.n	8019794 <set_tool_change_probing_distance+0x20>
        return Status_InvalidStatement;
 8019790:	2303      	movs	r3, #3
 8019792:	e003      	b.n	801979c <set_tool_change_probing_distance+0x28>

    settings.tool_change.probing_distance = value;
 8019794:	4a05      	ldr	r2, [pc, #20]	; (80197ac <set_tool_change_probing_distance+0x38>)
 8019796:	683b      	ldr	r3, [r7, #0]
 8019798:	6293      	str	r3, [r2, #40]	; 0x28

    return Status_OK;
 801979a:	2300      	movs	r3, #0
}
 801979c:	4618      	mov	r0, r3
 801979e:	370c      	adds	r7, #12
 80197a0:	46bd      	mov	sp, r7
 80197a2:	bc80      	pop	{r7}
 80197a4:	4770      	bx	lr
 80197a6:	bf00      	nop
 80197a8:	20000ed0 	.word	0x20000ed0
 80197ac:	2000147c 	.word	0x2000147c

080197b0 <set_tool_restore_pos>:

static status_code_t set_tool_restore_pos (setting_id_t id, uint_fast16_t int_value)
{
 80197b0:	b480      	push	{r7}
 80197b2:	b083      	sub	sp, #12
 80197b4:	af00      	add	r7, sp, #0
 80197b6:	4603      	mov	r3, r0
 80197b8:	6039      	str	r1, [r7, #0]
 80197ba:	80fb      	strh	r3, [r7, #6]
    if(hal.driver_cap.atc)
 80197bc:	4b0e      	ldr	r3, [pc, #56]	; (80197f8 <set_tool_restore_pos+0x48>)
 80197be:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 80197c2:	f003 0304 	and.w	r3, r3, #4
 80197c6:	b2db      	uxtb	r3, r3
 80197c8:	2b00      	cmp	r3, #0
 80197ca:	d001      	beq.n	80197d0 <set_tool_restore_pos+0x20>
        return Status_InvalidStatement;
 80197cc:	2303      	movs	r3, #3
 80197ce:	e00d      	b.n	80197ec <set_tool_restore_pos+0x3c>

    settings.flags.no_restore_position_after_M6 = int_value == 0;
 80197d0:	683b      	ldr	r3, [r7, #0]
 80197d2:	2b00      	cmp	r3, #0
 80197d4:	bf0c      	ite	eq
 80197d6:	2301      	moveq	r3, #1
 80197d8:	2300      	movne	r3, #0
 80197da:	b2d9      	uxtb	r1, r3
 80197dc:	4a07      	ldr	r2, [pc, #28]	; (80197fc <set_tool_restore_pos+0x4c>)
 80197de:	f892 30ff 	ldrb.w	r3, [r2, #255]	; 0xff
 80197e2:	f361 1386 	bfi	r3, r1, #6, #1
 80197e6:	f882 30ff 	strb.w	r3, [r2, #255]	; 0xff

    return Status_OK;
 80197ea:	2300      	movs	r3, #0
}
 80197ec:	4618      	mov	r0, r3
 80197ee:	370c      	adds	r7, #12
 80197f0:	46bd      	mov	sp, r7
 80197f2:	bc80      	pop	{r7}
 80197f4:	4770      	bx	lr
 80197f6:	bf00      	nop
 80197f8:	20000ed0 	.word	0x20000ed0
 80197fc:	2000147c 	.word	0x2000147c

08019800 <set_axis_unit>:

static inline void set_axis_unit (const setting_detail_t *setting, const char *unit)
{
 8019800:	b580      	push	{r7, lr}
 8019802:	b082      	sub	sp, #8
 8019804:	af00      	add	r7, sp, #0
 8019806:	6078      	str	r0, [r7, #4]
 8019808:	6039      	str	r1, [r7, #0]
    // TODO: add length check
    if(unit)
 801980a:	683b      	ldr	r3, [r7, #0]
 801980c:	2b00      	cmp	r3, #0
 801980e:	d005      	beq.n	801981c <set_axis_unit+0x1c>
        strcpy((char *)setting->unit, unit);
 8019810:	687b      	ldr	r3, [r7, #4]
 8019812:	689b      	ldr	r3, [r3, #8]
 8019814:	6839      	ldr	r1, [r7, #0]
 8019816:	4618      	mov	r0, r3
 8019818:	f00a fb51 	bl	8023ebe <strcpy>
}
 801981c:	bf00      	nop
 801981e:	3708      	adds	r7, #8
 8019820:	46bd      	mov	sp, r7
 8019822:	bd80      	pop	{r7, pc}

08019824 <normalize_id>:
}

#endif

inline static setting_id_t normalize_id (setting_id_t id)
{
 8019824:	b480      	push	{r7}
 8019826:	b083      	sub	sp, #12
 8019828:	af00      	add	r7, sp, #0
 801982a:	4603      	mov	r3, r0
 801982c:	80fb      	strh	r3, [r7, #6]
    if((id > Setting_AxisSettingsBase && id <= Setting_AxisSettingsMax) ||
 801982e:	88fb      	ldrh	r3, [r7, #6]
 8019830:	2b64      	cmp	r3, #100	; 0x64
 8019832:	d902      	bls.n	801983a <normalize_id+0x16>
 8019834:	88fb      	ldrh	r3, [r7, #6]
 8019836:	2bc1      	cmp	r3, #193	; 0xc1
 8019838:	d906      	bls.n	8019848 <normalize_id+0x24>
 801983a:	88fb      	ldrh	r3, [r7, #6]
 801983c:	2bc8      	cmp	r3, #200	; 0xc8
 801983e:	d912      	bls.n	8019866 <normalize_id+0x42>
       (id > Setting_AxisSettingsBase2 && id <= Setting_AxisSettingsMax2))
 8019840:	88fb      	ldrh	r3, [r7, #6]
 8019842:	f5b3 7f93 	cmp.w	r3, #294	; 0x126
 8019846:	d20e      	bcs.n	8019866 <normalize_id+0x42>
        id -= id % AXIS_SETTINGS_INCREMENT;
 8019848:	88fa      	ldrh	r2, [r7, #6]
 801984a:	4b20      	ldr	r3, [pc, #128]	; (80198cc <normalize_id+0xa8>)
 801984c:	fba3 1302 	umull	r1, r3, r3, r2
 8019850:	08d9      	lsrs	r1, r3, #3
 8019852:	460b      	mov	r3, r1
 8019854:	009b      	lsls	r3, r3, #2
 8019856:	440b      	add	r3, r1
 8019858:	005b      	lsls	r3, r3, #1
 801985a:	1ad3      	subs	r3, r2, r3
 801985c:	b29b      	uxth	r3, r3
 801985e:	88fa      	ldrh	r2, [r7, #6]
 8019860:	1ad3      	subs	r3, r2, r3
 8019862:	80fb      	strh	r3, [r7, #6]
 8019864:	e02b      	b.n	80198be <normalize_id+0x9a>
    else if(id > Setting_EncoderSettingsBase && id <= Setting_EncoderSettingsMax)
 8019866:	88fb      	ldrh	r3, [r7, #6]
 8019868:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 801986c:	d912      	bls.n	8019894 <normalize_id+0x70>
 801986e:	88fb      	ldrh	r3, [r7, #6]
 8019870:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
 8019874:	d20e      	bcs.n	8019894 <normalize_id+0x70>
        id = (setting_id_t)(Setting_EncoderSettingsBase + (id % ENCODER_SETTINGS_INCREMENT));
 8019876:	88fa      	ldrh	r2, [r7, #6]
 8019878:	4b14      	ldr	r3, [pc, #80]	; (80198cc <normalize_id+0xa8>)
 801987a:	fba3 1302 	umull	r1, r3, r3, r2
 801987e:	08d9      	lsrs	r1, r3, #3
 8019880:	460b      	mov	r3, r1
 8019882:	009b      	lsls	r3, r3, #2
 8019884:	440b      	add	r3, r1
 8019886:	005b      	lsls	r3, r3, #1
 8019888:	1ad3      	subs	r3, r2, r3
 801988a:	b29b      	uxth	r3, r3
 801988c:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8019890:	80fb      	strh	r3, [r7, #6]
 8019892:	e014      	b.n	80198be <normalize_id+0x9a>
    else if(id > Setting_ModbusTCPBase && id <= Setting_ModbusTCPMax)
 8019894:	88fb      	ldrh	r3, [r7, #6]
 8019896:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 801989a:	d910      	bls.n	80198be <normalize_id+0x9a>
 801989c:	88fb      	ldrh	r3, [r7, #6]
 801989e:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
 80198a2:	d20c      	bcs.n	80198be <normalize_id+0x9a>
        id = (setting_id_t)(Setting_ModbusTCPBase + (id % MODBUS_TCP_SETTINGS_INCREMENT));
 80198a4:	88fa      	ldrh	r2, [r7, #6]
 80198a6:	4b09      	ldr	r3, [pc, #36]	; (80198cc <normalize_id+0xa8>)
 80198a8:	fba3 1302 	umull	r1, r3, r3, r2
 80198ac:	0899      	lsrs	r1, r3, #2
 80198ae:	460b      	mov	r3, r1
 80198b0:	009b      	lsls	r3, r3, #2
 80198b2:	440b      	add	r3, r1
 80198b4:	1ad3      	subs	r3, r2, r3
 80198b6:	b29b      	uxth	r3, r3
 80198b8:	f503 7316 	add.w	r3, r3, #600	; 0x258
 80198bc:	80fb      	strh	r3, [r7, #6]

    return id;
 80198be:	88fb      	ldrh	r3, [r7, #6]
}
 80198c0:	4618      	mov	r0, r3
 80198c2:	370c      	adds	r7, #12
 80198c4:	46bd      	mov	sp, r7
 80198c6:	bc80      	pop	{r7}
 80198c8:	4770      	bx	lr
 80198ca:	bf00      	nop
 80198cc:	cccccccd 	.word	0xcccccccd

080198d0 <settings_get_axis_base>:

setting_id_t settings_get_axis_base (setting_id_t id, uint_fast8_t *idx)
{
 80198d0:	b580      	push	{r7, lr}
 80198d2:	b084      	sub	sp, #16
 80198d4:	af00      	add	r7, sp, #0
 80198d6:	4603      	mov	r3, r0
 80198d8:	6039      	str	r1, [r7, #0]
 80198da:	80fb      	strh	r3, [r7, #6]
    setting_id_t base = normalize_id(id);
 80198dc:	88fb      	ldrh	r3, [r7, #6]
 80198de:	4618      	mov	r0, r3
 80198e0:	f7ff ffa0 	bl	8019824 <normalize_id>
 80198e4:	4603      	mov	r3, r0
 80198e6:	81fb      	strh	r3, [r7, #14]
    *idx = id - base;
 80198e8:	88fa      	ldrh	r2, [r7, #6]
 80198ea:	89fb      	ldrh	r3, [r7, #14]
 80198ec:	1ad3      	subs	r3, r2, r3
 80198ee:	461a      	mov	r2, r3
 80198f0:	683b      	ldr	r3, [r7, #0]
 80198f2:	601a      	str	r2, [r3, #0]

    return *idx < N_AXIS ? base : Setting_SettingsMax;
 80198f4:	683b      	ldr	r3, [r7, #0]
 80198f6:	681b      	ldr	r3, [r3, #0]
 80198f8:	2b02      	cmp	r3, #2
 80198fa:	d801      	bhi.n	8019900 <settings_get_axis_base+0x30>
 80198fc:	89fb      	ldrh	r3, [r7, #14]
 80198fe:	e001      	b.n	8019904 <settings_get_axis_base+0x34>
 8019900:	f240 23e5 	movw	r3, #741	; 0x2e5
}
 8019904:	4618      	mov	r0, r3
 8019906:	3710      	adds	r7, #16
 8019908:	46bd      	mov	sp, r7
 801990a:	bd80      	pop	{r7, pc}

0801990c <set_axis_setting>:

static status_code_t set_axis_setting (setting_id_t setting, float value)
{
 801990c:	b590      	push	{r4, r7, lr}
 801990e:	b087      	sub	sp, #28
 8019910:	af00      	add	r7, sp, #0
 8019912:	4603      	mov	r3, r0
 8019914:	6039      	str	r1, [r7, #0]
 8019916:	80fb      	strh	r3, [r7, #6]
    uint_fast8_t idx;
    status_code_t status = Status_OK;
 8019918:	2300      	movs	r3, #0
 801991a:	75fb      	strb	r3, [r7, #23]

    switch(settings_get_axis_base(setting, &idx)) {
 801991c:	f107 020c 	add.w	r2, r7, #12
 8019920:	88fb      	ldrh	r3, [r7, #6]
 8019922:	4611      	mov	r1, r2
 8019924:	4618      	mov	r0, r3
 8019926:	f7ff ffd3 	bl	80198d0 <settings_get_axis_base>
 801992a:	4603      	mov	r3, r0
 801992c:	2baa      	cmp	r3, #170	; 0xaa
 801992e:	f000 81c2 	beq.w	8019cb6 <set_axis_setting+0x3aa>
 8019932:	2baa      	cmp	r3, #170	; 0xaa
 8019934:	f300 81e1 	bgt.w	8019cfa <set_axis_setting+0x3ee>
 8019938:	2b82      	cmp	r3, #130	; 0x82
 801993a:	dc47      	bgt.n	80199cc <set_axis_setting+0xc0>
 801993c:	2b64      	cmp	r3, #100	; 0x64
 801993e:	f2c0 81dc 	blt.w	8019cfa <set_axis_setting+0x3ee>
 8019942:	3b64      	subs	r3, #100	; 0x64
 8019944:	2b1e      	cmp	r3, #30
 8019946:	f200 81d8 	bhi.w	8019cfa <set_axis_setting+0x3ee>
 801994a:	a201      	add	r2, pc, #4	; (adr r2, 8019950 <set_axis_setting+0x44>)
 801994c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019950:	080199d5 	.word	0x080199d5
 8019954:	08019cfb 	.word	0x08019cfb
 8019958:	08019cfb 	.word	0x08019cfb
 801995c:	08019cfb 	.word	0x08019cfb
 8019960:	08019cfb 	.word	0x08019cfb
 8019964:	08019cfb 	.word	0x08019cfb
 8019968:	08019cfb 	.word	0x08019cfb
 801996c:	08019cfb 	.word	0x08019cfb
 8019970:	08019cfb 	.word	0x08019cfb
 8019974:	08019cfb 	.word	0x08019cfb
 8019978:	08019b57 	.word	0x08019b57
 801997c:	08019cfb 	.word	0x08019cfb
 8019980:	08019cfb 	.word	0x08019cfb
 8019984:	08019cfb 	.word	0x08019cfb
 8019988:	08019cfb 	.word	0x08019cfb
 801998c:	08019cfb 	.word	0x08019cfb
 8019990:	08019cfb 	.word	0x08019cfb
 8019994:	08019cfb 	.word	0x08019cfb
 8019998:	08019cfb 	.word	0x08019cfb
 801999c:	08019cfb 	.word	0x08019cfb
 80199a0:	08019bbd 	.word	0x08019bbd
 80199a4:	08019cfb 	.word	0x08019cfb
 80199a8:	08019cfb 	.word	0x08019cfb
 80199ac:	08019cfb 	.word	0x08019cfb
 80199b0:	08019cfb 	.word	0x08019cfb
 80199b4:	08019cfb 	.word	0x08019cfb
 80199b8:	08019cfb 	.word	0x08019cfb
 80199bc:	08019cfb 	.word	0x08019cfb
 80199c0:	08019cfb 	.word	0x08019cfb
 80199c4:	08019cfb 	.word	0x08019cfb
 80199c8:	08019c15 	.word	0x08019c15
 80199cc:	2ba0      	cmp	r3, #160	; 0xa0
 80199ce:	f000 816f 	beq.w	8019cb0 <set_axis_setting+0x3a4>
 80199d2:	e192      	b.n	8019cfa <set_axis_setting+0x3ee>

        case Setting_AxisStepsPerMM:
            if (hal.max_step_rate && value * settings.axis[idx].max_rate > (float)hal.max_step_rate * 60.0f)
 80199d4:	4b88      	ldr	r3, [pc, #544]	; (8019bf8 <set_axis_setting+0x2ec>)
 80199d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80199d8:	2b00      	cmp	r3, #0
 80199da:	d023      	beq.n	8019a24 <set_axis_setting+0x118>
 80199dc:	68fa      	ldr	r2, [r7, #12]
 80199de:	4987      	ldr	r1, [pc, #540]	; (8019bfc <set_axis_setting+0x2f0>)
 80199e0:	4613      	mov	r3, r2
 80199e2:	009b      	lsls	r3, r3, #2
 80199e4:	4413      	add	r3, r2
 80199e6:	009b      	lsls	r3, r3, #2
 80199e8:	440b      	add	r3, r1
 80199ea:	3334      	adds	r3, #52	; 0x34
 80199ec:	681b      	ldr	r3, [r3, #0]
 80199ee:	6839      	ldr	r1, [r7, #0]
 80199f0:	4618      	mov	r0, r3
 80199f2:	f7e7 f9df 	bl	8000db4 <__aeabi_fmul>
 80199f6:	4603      	mov	r3, r0
 80199f8:	461c      	mov	r4, r3
 80199fa:	4b7f      	ldr	r3, [pc, #508]	; (8019bf8 <set_axis_setting+0x2ec>)
 80199fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80199fe:	4618      	mov	r0, r3
 8019a00:	f7e7 f980 	bl	8000d04 <__aeabi_ui2f>
 8019a04:	4603      	mov	r3, r0
 8019a06:	497e      	ldr	r1, [pc, #504]	; (8019c00 <set_axis_setting+0x2f4>)
 8019a08:	4618      	mov	r0, r3
 8019a0a:	f7e7 f9d3 	bl	8000db4 <__aeabi_fmul>
 8019a0e:	4603      	mov	r3, r0
 8019a10:	4619      	mov	r1, r3
 8019a12:	4620      	mov	r0, r4
 8019a14:	f7e7 fb8a 	bl	800112c <__aeabi_fcmpgt>
 8019a18:	4603      	mov	r3, r0
 8019a1a:	2b00      	cmp	r3, #0
 8019a1c:	d002      	beq.n	8019a24 <set_axis_setting+0x118>
                status = Status_MaxStepRateExceeded;
 8019a1e:	230c      	movs	r3, #12
 8019a20:	75fb      	strb	r3, [r7, #23]
                    sys.tlo_reference[idx] *= comp;
                    sync_position();
                }
                settings.axis[idx].steps_per_mm = value;
            }
            break;
 8019a22:	e16d      	b.n	8019d00 <set_axis_setting+0x3f4>
                if(settings.axis[idx].steps_per_mm > 0.0f && settings.axis[idx].steps_per_mm != value) {
 8019a24:	68fa      	ldr	r2, [r7, #12]
 8019a26:	4975      	ldr	r1, [pc, #468]	; (8019bfc <set_axis_setting+0x2f0>)
 8019a28:	4613      	mov	r3, r2
 8019a2a:	009b      	lsls	r3, r3, #2
 8019a2c:	4413      	add	r3, r2
 8019a2e:	009b      	lsls	r3, r3, #2
 8019a30:	440b      	add	r3, r1
 8019a32:	3330      	adds	r3, #48	; 0x30
 8019a34:	681b      	ldr	r3, [r3, #0]
 8019a36:	f04f 0100 	mov.w	r1, #0
 8019a3a:	4618      	mov	r0, r3
 8019a3c:	f7e7 fb76 	bl	800112c <__aeabi_fcmpgt>
 8019a40:	4603      	mov	r3, r0
 8019a42:	2b00      	cmp	r3, #0
 8019a44:	d07c      	beq.n	8019b40 <set_axis_setting+0x234>
 8019a46:	68fa      	ldr	r2, [r7, #12]
 8019a48:	496c      	ldr	r1, [pc, #432]	; (8019bfc <set_axis_setting+0x2f0>)
 8019a4a:	4613      	mov	r3, r2
 8019a4c:	009b      	lsls	r3, r3, #2
 8019a4e:	4413      	add	r3, r2
 8019a50:	009b      	lsls	r3, r3, #2
 8019a52:	440b      	add	r3, r1
 8019a54:	3330      	adds	r3, #48	; 0x30
 8019a56:	681b      	ldr	r3, [r3, #0]
 8019a58:	4619      	mov	r1, r3
 8019a5a:	6838      	ldr	r0, [r7, #0]
 8019a5c:	f7e7 fb3e 	bl	80010dc <__aeabi_fcmpeq>
 8019a60:	4603      	mov	r3, r0
 8019a62:	2b00      	cmp	r3, #0
 8019a64:	d16c      	bne.n	8019b40 <set_axis_setting+0x234>
                    float comp = value / settings.axis[idx].steps_per_mm;
 8019a66:	68fa      	ldr	r2, [r7, #12]
 8019a68:	4964      	ldr	r1, [pc, #400]	; (8019bfc <set_axis_setting+0x2f0>)
 8019a6a:	4613      	mov	r3, r2
 8019a6c:	009b      	lsls	r3, r3, #2
 8019a6e:	4413      	add	r3, r2
 8019a70:	009b      	lsls	r3, r3, #2
 8019a72:	440b      	add	r3, r1
 8019a74:	3330      	adds	r3, #48	; 0x30
 8019a76:	681b      	ldr	r3, [r3, #0]
 8019a78:	4619      	mov	r1, r3
 8019a7a:	6838      	ldr	r0, [r7, #0]
 8019a7c:	f7e7 fa4e 	bl	8000f1c <__aeabi_fdiv>
 8019a80:	4603      	mov	r3, r0
 8019a82:	613b      	str	r3, [r7, #16]
                    sys.position[idx] *= comp;
 8019a84:	68fb      	ldr	r3, [r7, #12]
 8019a86:	4a5f      	ldr	r2, [pc, #380]	; (8019c04 <set_axis_setting+0x2f8>)
 8019a88:	3322      	adds	r3, #34	; 0x22
 8019a8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019a8e:	4618      	mov	r0, r3
 8019a90:	f7e7 f93c 	bl	8000d0c <__aeabi_i2f>
 8019a94:	4603      	mov	r3, r0
 8019a96:	6939      	ldr	r1, [r7, #16]
 8019a98:	4618      	mov	r0, r3
 8019a9a:	f7e7 f98b 	bl	8000db4 <__aeabi_fmul>
 8019a9e:	4603      	mov	r3, r0
 8019aa0:	68fc      	ldr	r4, [r7, #12]
 8019aa2:	4618      	mov	r0, r3
 8019aa4:	f7e7 fb62 	bl	800116c <__aeabi_f2iz>
 8019aa8:	4602      	mov	r2, r0
 8019aaa:	4956      	ldr	r1, [pc, #344]	; (8019c04 <set_axis_setting+0x2f8>)
 8019aac:	f104 0322 	add.w	r3, r4, #34	; 0x22
 8019ab0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    sys.home_position[idx] *= comp;
 8019ab4:	68fb      	ldr	r3, [r7, #12]
 8019ab6:	4a53      	ldr	r2, [pc, #332]	; (8019c04 <set_axis_setting+0x2f8>)
 8019ab8:	3316      	adds	r3, #22
 8019aba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019abe:	68fc      	ldr	r4, [r7, #12]
 8019ac0:	6939      	ldr	r1, [r7, #16]
 8019ac2:	4618      	mov	r0, r3
 8019ac4:	f7e7 f976 	bl	8000db4 <__aeabi_fmul>
 8019ac8:	4603      	mov	r3, r0
 8019aca:	4619      	mov	r1, r3
 8019acc:	4a4d      	ldr	r2, [pc, #308]	; (8019c04 <set_axis_setting+0x2f8>)
 8019ace:	f104 0316 	add.w	r3, r4, #22
 8019ad2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    sys.probe_position[idx] *= comp;
 8019ad6:	68fb      	ldr	r3, [r7, #12]
 8019ad8:	4a4a      	ldr	r2, [pc, #296]	; (8019c04 <set_axis_setting+0x2f8>)
 8019ada:	330e      	adds	r3, #14
 8019adc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019ae0:	4618      	mov	r0, r3
 8019ae2:	f7e7 f913 	bl	8000d0c <__aeabi_i2f>
 8019ae6:	4603      	mov	r3, r0
 8019ae8:	6939      	ldr	r1, [r7, #16]
 8019aea:	4618      	mov	r0, r3
 8019aec:	f7e7 f962 	bl	8000db4 <__aeabi_fmul>
 8019af0:	4603      	mov	r3, r0
 8019af2:	68fc      	ldr	r4, [r7, #12]
 8019af4:	4618      	mov	r0, r3
 8019af6:	f7e7 fb39 	bl	800116c <__aeabi_f2iz>
 8019afa:	4602      	mov	r2, r0
 8019afc:	4941      	ldr	r1, [pc, #260]	; (8019c04 <set_axis_setting+0x2f8>)
 8019afe:	f104 030e 	add.w	r3, r4, #14
 8019b02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    sys.tlo_reference[idx] *= comp;
 8019b06:	68fb      	ldr	r3, [r7, #12]
 8019b08:	4a3e      	ldr	r2, [pc, #248]	; (8019c04 <set_axis_setting+0x2f8>)
 8019b0a:	3302      	adds	r3, #2
 8019b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019b10:	4618      	mov	r0, r3
 8019b12:	f7e7 f8fb 	bl	8000d0c <__aeabi_i2f>
 8019b16:	4603      	mov	r3, r0
 8019b18:	6939      	ldr	r1, [r7, #16]
 8019b1a:	4618      	mov	r0, r3
 8019b1c:	f7e7 f94a 	bl	8000db4 <__aeabi_fmul>
 8019b20:	4603      	mov	r3, r0
 8019b22:	68fc      	ldr	r4, [r7, #12]
 8019b24:	4618      	mov	r0, r3
 8019b26:	f7e7 fb21 	bl	800116c <__aeabi_f2iz>
 8019b2a:	4602      	mov	r2, r0
 8019b2c:	4935      	ldr	r1, [pc, #212]	; (8019c04 <set_axis_setting+0x2f8>)
 8019b2e:	1ca3      	adds	r3, r4, #2
 8019b30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    sync_position();
 8019b34:	f7f8 fb56 	bl	80121e4 <plan_sync_position>
 8019b38:	4933      	ldr	r1, [pc, #204]	; (8019c08 <set_axis_setting+0x2fc>)
 8019b3a:	4834      	ldr	r0, [pc, #208]	; (8019c0c <set_axis_setting+0x300>)
 8019b3c:	f008 f968 	bl	8021e10 <system_convert_array_steps_to_mpos>
                settings.axis[idx].steps_per_mm = value;
 8019b40:	68fa      	ldr	r2, [r7, #12]
 8019b42:	492e      	ldr	r1, [pc, #184]	; (8019bfc <set_axis_setting+0x2f0>)
 8019b44:	4613      	mov	r3, r2
 8019b46:	009b      	lsls	r3, r3, #2
 8019b48:	4413      	add	r3, r2
 8019b4a:	009b      	lsls	r3, r3, #2
 8019b4c:	440b      	add	r3, r1
 8019b4e:	3330      	adds	r3, #48	; 0x30
 8019b50:	683a      	ldr	r2, [r7, #0]
 8019b52:	601a      	str	r2, [r3, #0]
            break;
 8019b54:	e0d4      	b.n	8019d00 <set_axis_setting+0x3f4>

        case Setting_AxisMaxRate:
            if (hal.max_step_rate && value * settings.axis[idx].steps_per_mm > (float)hal.max_step_rate * 60.0f)
 8019b56:	4b28      	ldr	r3, [pc, #160]	; (8019bf8 <set_axis_setting+0x2ec>)
 8019b58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019b5a:	2b00      	cmp	r3, #0
 8019b5c:	d023      	beq.n	8019ba6 <set_axis_setting+0x29a>
 8019b5e:	68fa      	ldr	r2, [r7, #12]
 8019b60:	4926      	ldr	r1, [pc, #152]	; (8019bfc <set_axis_setting+0x2f0>)
 8019b62:	4613      	mov	r3, r2
 8019b64:	009b      	lsls	r3, r3, #2
 8019b66:	4413      	add	r3, r2
 8019b68:	009b      	lsls	r3, r3, #2
 8019b6a:	440b      	add	r3, r1
 8019b6c:	3330      	adds	r3, #48	; 0x30
 8019b6e:	681b      	ldr	r3, [r3, #0]
 8019b70:	6839      	ldr	r1, [r7, #0]
 8019b72:	4618      	mov	r0, r3
 8019b74:	f7e7 f91e 	bl	8000db4 <__aeabi_fmul>
 8019b78:	4603      	mov	r3, r0
 8019b7a:	461c      	mov	r4, r3
 8019b7c:	4b1e      	ldr	r3, [pc, #120]	; (8019bf8 <set_axis_setting+0x2ec>)
 8019b7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019b80:	4618      	mov	r0, r3
 8019b82:	f7e7 f8bf 	bl	8000d04 <__aeabi_ui2f>
 8019b86:	4603      	mov	r3, r0
 8019b88:	491d      	ldr	r1, [pc, #116]	; (8019c00 <set_axis_setting+0x2f4>)
 8019b8a:	4618      	mov	r0, r3
 8019b8c:	f7e7 f912 	bl	8000db4 <__aeabi_fmul>
 8019b90:	4603      	mov	r3, r0
 8019b92:	4619      	mov	r1, r3
 8019b94:	4620      	mov	r0, r4
 8019b96:	f7e7 fac9 	bl	800112c <__aeabi_fcmpgt>
 8019b9a:	4603      	mov	r3, r0
 8019b9c:	2b00      	cmp	r3, #0
 8019b9e:	d002      	beq.n	8019ba6 <set_axis_setting+0x29a>
                status = Status_MaxStepRateExceeded;
 8019ba0:	230c      	movs	r3, #12
 8019ba2:	75fb      	strb	r3, [r7, #23]
            else
                settings.axis[idx].max_rate = value;
            break;
 8019ba4:	e0ac      	b.n	8019d00 <set_axis_setting+0x3f4>
                settings.axis[idx].max_rate = value;
 8019ba6:	68fa      	ldr	r2, [r7, #12]
 8019ba8:	4914      	ldr	r1, [pc, #80]	; (8019bfc <set_axis_setting+0x2f0>)
 8019baa:	4613      	mov	r3, r2
 8019bac:	009b      	lsls	r3, r3, #2
 8019bae:	4413      	add	r3, r2
 8019bb0:	009b      	lsls	r3, r3, #2
 8019bb2:	440b      	add	r3, r1
 8019bb4:	3334      	adds	r3, #52	; 0x34
 8019bb6:	683a      	ldr	r2, [r7, #0]
 8019bb8:	601a      	str	r2, [r3, #0]
            break;
 8019bba:	e0a1      	b.n	8019d00 <set_axis_setting+0x3f4>

        case Setting_AxisAcceleration:
            settings.axis[idx].acceleration = override_backup.acceleration[idx] = value * 60.0f * 60.0f; // Convert to mm/min^2 for grbl internal use.
 8019bbc:	4910      	ldr	r1, [pc, #64]	; (8019c00 <set_axis_setting+0x2f4>)
 8019bbe:	6838      	ldr	r0, [r7, #0]
 8019bc0:	f7e7 f8f8 	bl	8000db4 <__aeabi_fmul>
 8019bc4:	4603      	mov	r3, r0
 8019bc6:	68fc      	ldr	r4, [r7, #12]
 8019bc8:	490d      	ldr	r1, [pc, #52]	; (8019c00 <set_axis_setting+0x2f4>)
 8019bca:	4618      	mov	r0, r3
 8019bcc:	f7e7 f8f2 	bl	8000db4 <__aeabi_fmul>
 8019bd0:	4603      	mov	r3, r0
 8019bd2:	4619      	mov	r1, r3
 8019bd4:	4a0e      	ldr	r2, [pc, #56]	; (8019c10 <set_axis_setting+0x304>)
 8019bd6:	00a3      	lsls	r3, r4, #2
 8019bd8:	4413      	add	r3, r2
 8019bda:	6059      	str	r1, [r3, #4]
 8019bdc:	68fa      	ldr	r2, [r7, #12]
 8019bde:	490c      	ldr	r1, [pc, #48]	; (8019c10 <set_axis_setting+0x304>)
 8019be0:	00a3      	lsls	r3, r4, #2
 8019be2:	440b      	add	r3, r1
 8019be4:	6859      	ldr	r1, [r3, #4]
 8019be6:	4805      	ldr	r0, [pc, #20]	; (8019bfc <set_axis_setting+0x2f0>)
 8019be8:	4613      	mov	r3, r2
 8019bea:	009b      	lsls	r3, r3, #2
 8019bec:	4413      	add	r3, r2
 8019bee:	009b      	lsls	r3, r3, #2
 8019bf0:	4403      	add	r3, r0
 8019bf2:	3338      	adds	r3, #56	; 0x38
 8019bf4:	6019      	str	r1, [r3, #0]
            break;
 8019bf6:	e083      	b.n	8019d00 <set_axis_setting+0x3f4>
 8019bf8:	20000ed0 	.word	0x20000ed0
 8019bfc:	2000147c 	.word	0x2000147c
 8019c00:	42700000 	.word	0x42700000
 8019c04:	20000d3c 	.word	0x20000d3c
 8019c08:	20000dc4 	.word	0x20000dc4
 8019c0c:	20000c0c 	.word	0x20000c0c
 8019c10:	20001650 	.word	0x20001650

        case Setting_AxisMaxTravel:
            if(settings.axis[idx].max_travel != -value) {
 8019c14:	68fa      	ldr	r2, [r7, #12]
 8019c16:	493d      	ldr	r1, [pc, #244]	; (8019d0c <set_axis_setting+0x400>)
 8019c18:	4613      	mov	r3, r2
 8019c1a:	009b      	lsls	r3, r3, #2
 8019c1c:	4413      	add	r3, r2
 8019c1e:	009b      	lsls	r3, r3, #2
 8019c20:	440b      	add	r3, r1
 8019c22:	333c      	adds	r3, #60	; 0x3c
 8019c24:	681a      	ldr	r2, [r3, #0]
 8019c26:	683b      	ldr	r3, [r7, #0]
 8019c28:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8019c2c:	4619      	mov	r1, r3
 8019c2e:	4610      	mov	r0, r2
 8019c30:	f7e7 fa54 	bl	80010dc <__aeabi_fcmpeq>
 8019c34:	4603      	mov	r3, r0
 8019c36:	2b00      	cmp	r3, #0
 8019c38:	d111      	bne.n	8019c5e <set_axis_setting+0x352>
                bit_false(sys.homed.mask, bit(idx));
 8019c3a:	4b35      	ldr	r3, [pc, #212]	; (8019d10 <set_axis_setting+0x404>)
 8019c3c:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 8019c40:	68fb      	ldr	r3, [r7, #12]
 8019c42:	2101      	movs	r1, #1
 8019c44:	fa01 f303 	lsl.w	r3, r1, r3
 8019c48:	b2db      	uxtb	r3, r3
 8019c4a:	43db      	mvns	r3, r3
 8019c4c:	b2db      	uxtb	r3, r3
 8019c4e:	4013      	ands	r3, r2
 8019c50:	b2da      	uxtb	r2, r3
 8019c52:	4b2f      	ldr	r3, [pc, #188]	; (8019d10 <set_axis_setting+0x404>)
 8019c54:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
                system_add_rt_report(Report_Homed);
 8019c58:	2004      	movs	r0, #4
 8019c5a:	f008 f99f 	bl	8021f9c <system_add_rt_report>
            }
            settings.axis[idx].max_travel = -value; // Store as negative for grbl internal use.
 8019c5e:	68fa      	ldr	r2, [r7, #12]
 8019c60:	683b      	ldr	r3, [r7, #0]
 8019c62:	f083 4100 	eor.w	r1, r3, #2147483648	; 0x80000000
 8019c66:	4829      	ldr	r0, [pc, #164]	; (8019d0c <set_axis_setting+0x400>)
 8019c68:	4613      	mov	r3, r2
 8019c6a:	009b      	lsls	r3, r3, #2
 8019c6c:	4413      	add	r3, r2
 8019c6e:	009b      	lsls	r3, r3, #2
 8019c70:	4403      	add	r3, r0
 8019c72:	333c      	adds	r3, #60	; 0x3c
 8019c74:	6019      	str	r1, [r3, #0]
            if(settings.homing.flags.init_lock && (sys.homing.mask & sys.homed.mask) != sys.homing.mask) {
 8019c76:	4b25      	ldr	r3, [pc, #148]	; (8019d0c <set_axis_setting+0x400>)
 8019c78:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8019c7c:	f003 0304 	and.w	r3, r3, #4
 8019c80:	b2db      	uxtb	r3, r3
 8019c82:	2b00      	cmp	r3, #0
 8019c84:	d011      	beq.n	8019caa <set_axis_setting+0x39e>
 8019c86:	4b22      	ldr	r3, [pc, #136]	; (8019d10 <set_axis_setting+0x404>)
 8019c88:	7e9a      	ldrb	r2, [r3, #26]
 8019c8a:	4b21      	ldr	r3, [pc, #132]	; (8019d10 <set_axis_setting+0x404>)
 8019c8c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8019c90:	4013      	ands	r3, r2
 8019c92:	b2da      	uxtb	r2, r3
 8019c94:	4b1e      	ldr	r3, [pc, #120]	; (8019d10 <set_axis_setting+0x404>)
 8019c96:	7e9b      	ldrb	r3, [r3, #26]
 8019c98:	429a      	cmp	r2, r3
 8019c9a:	d006      	beq.n	8019caa <set_axis_setting+0x39e>
                system_raise_alarm(Alarm_HomingRequired);
 8019c9c:	200b      	movs	r0, #11
 8019c9e:	f008 f911 	bl	8021ec4 <system_raise_alarm>
                grbl.report.feedback_message(Message_HomingCycleRequired);
 8019ca2:	4b1c      	ldr	r3, [pc, #112]	; (8019d14 <set_axis_setting+0x408>)
 8019ca4:	68db      	ldr	r3, [r3, #12]
 8019ca6:	200d      	movs	r0, #13
 8019ca8:	4798      	blx	r3
            }
            tmp_set_soft_limits();
 8019caa:	f7ff fa31 	bl	8019110 <tmp_set_soft_limits>
            break;
 8019cae:	e027      	b.n	8019d00 <set_axis_setting+0x3f4>
                axes.mask = bit(idx);
                settings.axis[idx].backlash = value;
                mc_backlash_init(axes);
            }
#else
            status = Status_SettingDisabled;
 8019cb0:	2335      	movs	r3, #53	; 0x35
 8019cb2:	75fb      	strb	r3, [r7, #23]
#endif
            break;
 8019cb4:	e024      	b.n	8019d00 <set_axis_setting+0x3f4>

        case Setting_AxisAutoSquareOffset:
            if(hal.stepper.get_ganged && bit_istrue(hal.stepper.get_ganged(true).mask, bit(idx)))
 8019cb6:	4b18      	ldr	r3, [pc, #96]	; (8019d18 <set_axis_setting+0x40c>)
 8019cb8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8019cbc:	2b00      	cmp	r3, #0
 8019cbe:	d019      	beq.n	8019cf4 <set_axis_setting+0x3e8>
 8019cc0:	4b15      	ldr	r3, [pc, #84]	; (8019d18 <set_axis_setting+0x40c>)
 8019cc2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8019cc6:	2001      	movs	r0, #1
 8019cc8:	4798      	blx	r3
 8019cca:	4603      	mov	r3, r0
 8019ccc:	b2db      	uxtb	r3, r3
 8019cce:	461a      	mov	r2, r3
 8019cd0:	68fb      	ldr	r3, [r7, #12]
 8019cd2:	fa22 f303 	lsr.w	r3, r2, r3
 8019cd6:	f003 0301 	and.w	r3, r3, #1
 8019cda:	2b00      	cmp	r3, #0
 8019cdc:	d00a      	beq.n	8019cf4 <set_axis_setting+0x3e8>
                settings.axis[idx].dual_axis_offset = value;
 8019cde:	68fa      	ldr	r2, [r7, #12]
 8019ce0:	490a      	ldr	r1, [pc, #40]	; (8019d0c <set_axis_setting+0x400>)
 8019ce2:	4613      	mov	r3, r2
 8019ce4:	009b      	lsls	r3, r3, #2
 8019ce6:	4413      	add	r3, r2
 8019ce8:	009b      	lsls	r3, r3, #2
 8019cea:	440b      	add	r3, r1
 8019cec:	3340      	adds	r3, #64	; 0x40
 8019cee:	683a      	ldr	r2, [r7, #0]
 8019cf0:	601a      	str	r2, [r3, #0]
            else
                status = Status_SettingDisabled;
            break;
 8019cf2:	e005      	b.n	8019d00 <set_axis_setting+0x3f4>
                status = Status_SettingDisabled;
 8019cf4:	2335      	movs	r3, #53	; 0x35
 8019cf6:	75fb      	strb	r3, [r7, #23]
            break;
 8019cf8:	e002      	b.n	8019d00 <set_axis_setting+0x3f4>

        default:
            status = Status_SettingDisabled;
 8019cfa:	2335      	movs	r3, #53	; 0x35
 8019cfc:	75fb      	strb	r3, [r7, #23]
            break;
 8019cfe:	bf00      	nop
    }

    return status;
 8019d00:	7dfb      	ldrb	r3, [r7, #23]
}
 8019d02:	4618      	mov	r0, r3
 8019d04:	371c      	adds	r7, #28
 8019d06:	46bd      	mov	sp, r7
 8019d08:	bd90      	pop	{r4, r7, pc}
 8019d0a:	bf00      	nop
 8019d0c:	2000147c 	.word	0x2000147c
 8019d10:	20000d3c 	.word	0x20000d3c
 8019d14:	20000dd4 	.word	0x20000dd4
 8019d18:	20000ed0 	.word	0x20000ed0

08019d1c <get_float>:

static float get_float (setting_id_t setting)
{
 8019d1c:	b580      	push	{r7, lr}
 8019d1e:	b084      	sub	sp, #16
 8019d20:	af00      	add	r7, sp, #0
 8019d22:	4603      	mov	r3, r0
 8019d24:	80fb      	strh	r3, [r7, #6]
    float value = 0.0f;
 8019d26:	f04f 0300 	mov.w	r3, #0
 8019d2a:	60fb      	str	r3, [r7, #12]

    if (setting >= Setting_AxisSettingsBase && setting <= Setting_AxisSettingsMax) {
 8019d2c:	88fb      	ldrh	r3, [r7, #6]
 8019d2e:	2b63      	cmp	r3, #99	; 0x63
 8019d30:	f240 8099 	bls.w	8019e66 <get_float+0x14a>
 8019d34:	88fb      	ldrh	r3, [r7, #6]
 8019d36:	2bc1      	cmp	r3, #193	; 0xc1
 8019d38:	f200 8095 	bhi.w	8019e66 <get_float+0x14a>

        uint_fast8_t idx;

        switch(settings_get_axis_base(setting, &idx)) {
 8019d3c:	f107 0208 	add.w	r2, r7, #8
 8019d40:	88fb      	ldrh	r3, [r7, #6]
 8019d42:	4611      	mov	r1, r2
 8019d44:	4618      	mov	r0, r3
 8019d46:	f7ff fdc3 	bl	80198d0 <settings_get_axis_base>
 8019d4a:	4603      	mov	r3, r0
 8019d4c:	2b82      	cmp	r3, #130	; 0x82
 8019d4e:	dc47      	bgt.n	8019de0 <get_float+0xc4>
 8019d50:	2b64      	cmp	r3, #100	; 0x64
 8019d52:	f2c0 8086 	blt.w	8019e62 <get_float+0x146>
 8019d56:	3b64      	subs	r3, #100	; 0x64
 8019d58:	2b1e      	cmp	r3, #30
 8019d5a:	f200 8082 	bhi.w	8019e62 <get_float+0x146>
 8019d5e:	a201      	add	r2, pc, #4	; (adr r2, 8019d64 <get_float+0x48>)
 8019d60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019d64:	08019de7 	.word	0x08019de7
 8019d68:	08019e63 	.word	0x08019e63
 8019d6c:	08019e63 	.word	0x08019e63
 8019d70:	08019e63 	.word	0x08019e63
 8019d74:	08019e63 	.word	0x08019e63
 8019d78:	08019e63 	.word	0x08019e63
 8019d7c:	08019e63 	.word	0x08019e63
 8019d80:	08019e63 	.word	0x08019e63
 8019d84:	08019e63 	.word	0x08019e63
 8019d88:	08019e63 	.word	0x08019e63
 8019d8c:	08019dfd 	.word	0x08019dfd
 8019d90:	08019e63 	.word	0x08019e63
 8019d94:	08019e63 	.word	0x08019e63
 8019d98:	08019e63 	.word	0x08019e63
 8019d9c:	08019e63 	.word	0x08019e63
 8019da0:	08019e63 	.word	0x08019e63
 8019da4:	08019e63 	.word	0x08019e63
 8019da8:	08019e63 	.word	0x08019e63
 8019dac:	08019e63 	.word	0x08019e63
 8019db0:	08019e63 	.word	0x08019e63
 8019db4:	08019e13 	.word	0x08019e13
 8019db8:	08019e63 	.word	0x08019e63
 8019dbc:	08019e63 	.word	0x08019e63
 8019dc0:	08019e63 	.word	0x08019e63
 8019dc4:	08019e63 	.word	0x08019e63
 8019dc8:	08019e63 	.word	0x08019e63
 8019dcc:	08019e63 	.word	0x08019e63
 8019dd0:	08019e63 	.word	0x08019e63
 8019dd4:	08019e63 	.word	0x08019e63
 8019dd8:	08019e63 	.word	0x08019e63
 8019ddc:	08019e33 	.word	0x08019e33
 8019de0:	2baa      	cmp	r3, #170	; 0xaa
 8019de2:	d033      	beq.n	8019e4c <get_float+0x130>
            case Setting_AxisAutoSquareOffset:
                value = settings.axis[idx].dual_axis_offset;
                break;

            default: // for stopping compiler warning
                break;
 8019de4:	e03d      	b.n	8019e62 <get_float+0x146>
                value = settings.axis[idx].steps_per_mm;
 8019de6:	68ba      	ldr	r2, [r7, #8]
 8019de8:	4926      	ldr	r1, [pc, #152]	; (8019e84 <get_float+0x168>)
 8019dea:	4613      	mov	r3, r2
 8019dec:	009b      	lsls	r3, r3, #2
 8019dee:	4413      	add	r3, r2
 8019df0:	009b      	lsls	r3, r3, #2
 8019df2:	440b      	add	r3, r1
 8019df4:	3330      	adds	r3, #48	; 0x30
 8019df6:	681b      	ldr	r3, [r3, #0]
 8019df8:	60fb      	str	r3, [r7, #12]
                break;
 8019dfa:	e033      	b.n	8019e64 <get_float+0x148>
                value = settings.axis[idx].max_rate;
 8019dfc:	68ba      	ldr	r2, [r7, #8]
 8019dfe:	4921      	ldr	r1, [pc, #132]	; (8019e84 <get_float+0x168>)
 8019e00:	4613      	mov	r3, r2
 8019e02:	009b      	lsls	r3, r3, #2
 8019e04:	4413      	add	r3, r2
 8019e06:	009b      	lsls	r3, r3, #2
 8019e08:	440b      	add	r3, r1
 8019e0a:	3334      	adds	r3, #52	; 0x34
 8019e0c:	681b      	ldr	r3, [r3, #0]
 8019e0e:	60fb      	str	r3, [r7, #12]
                break;
 8019e10:	e028      	b.n	8019e64 <get_float+0x148>
                value = settings.axis[idx].acceleration / (60.0f * 60.0f); // Convert from mm/min^2 to mm/sec^2.
 8019e12:	68ba      	ldr	r2, [r7, #8]
 8019e14:	491b      	ldr	r1, [pc, #108]	; (8019e84 <get_float+0x168>)
 8019e16:	4613      	mov	r3, r2
 8019e18:	009b      	lsls	r3, r3, #2
 8019e1a:	4413      	add	r3, r2
 8019e1c:	009b      	lsls	r3, r3, #2
 8019e1e:	440b      	add	r3, r1
 8019e20:	3338      	adds	r3, #56	; 0x38
 8019e22:	681b      	ldr	r3, [r3, #0]
 8019e24:	4918      	ldr	r1, [pc, #96]	; (8019e88 <get_float+0x16c>)
 8019e26:	4618      	mov	r0, r3
 8019e28:	f7e7 f878 	bl	8000f1c <__aeabi_fdiv>
 8019e2c:	4603      	mov	r3, r0
 8019e2e:	60fb      	str	r3, [r7, #12]
                break;
 8019e30:	e018      	b.n	8019e64 <get_float+0x148>
                value = -settings.axis[idx].max_travel; // Store as negative for grbl internal use.
 8019e32:	68ba      	ldr	r2, [r7, #8]
 8019e34:	4913      	ldr	r1, [pc, #76]	; (8019e84 <get_float+0x168>)
 8019e36:	4613      	mov	r3, r2
 8019e38:	009b      	lsls	r3, r3, #2
 8019e3a:	4413      	add	r3, r2
 8019e3c:	009b      	lsls	r3, r3, #2
 8019e3e:	440b      	add	r3, r1
 8019e40:	333c      	adds	r3, #60	; 0x3c
 8019e42:	681b      	ldr	r3, [r3, #0]
 8019e44:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 8019e48:	60fb      	str	r3, [r7, #12]
                break;
 8019e4a:	e00b      	b.n	8019e64 <get_float+0x148>
                value = settings.axis[idx].dual_axis_offset;
 8019e4c:	68ba      	ldr	r2, [r7, #8]
 8019e4e:	490d      	ldr	r1, [pc, #52]	; (8019e84 <get_float+0x168>)
 8019e50:	4613      	mov	r3, r2
 8019e52:	009b      	lsls	r3, r3, #2
 8019e54:	4413      	add	r3, r2
 8019e56:	009b      	lsls	r3, r3, #2
 8019e58:	440b      	add	r3, r1
 8019e5a:	3340      	adds	r3, #64	; 0x40
 8019e5c:	681b      	ldr	r3, [r3, #0]
 8019e5e:	60fb      	str	r3, [r7, #12]
                break;
 8019e60:	e000      	b.n	8019e64 <get_float+0x148>
                break;
 8019e62:	bf00      	nop
    if (setting >= Setting_AxisSettingsBase && setting <= Setting_AxisSettingsMax) {
 8019e64:	e008      	b.n	8019e78 <get_float+0x15c>
        }
    } else switch(setting) {
 8019e66:	88fb      	ldrh	r3, [r7, #6]
 8019e68:	f5b3 7fab 	cmp.w	r3, #342	; 0x156
 8019e6c:	d103      	bne.n	8019e76 <get_float+0x15a>

        case Setting_ToolChangeProbingDistance:
            value = settings.tool_change.probing_distance;
 8019e6e:	4b05      	ldr	r3, [pc, #20]	; (8019e84 <get_float+0x168>)
 8019e70:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019e72:	60fb      	str	r3, [r7, #12]
            break;
 8019e74:	e000      	b.n	8019e78 <get_float+0x15c>

        default:
            break;
 8019e76:	bf00      	nop
    }

    return value;
 8019e78:	68fb      	ldr	r3, [r7, #12]
}
 8019e7a:	4618      	mov	r0, r3
 8019e7c:	3710      	adds	r7, #16
 8019e7e:	46bd      	mov	sp, r7
 8019e80:	bd80      	pop	{r7, pc}
 8019e82:	bf00      	nop
 8019e84:	2000147c 	.word	0x2000147c
 8019e88:	45610000 	.word	0x45610000

08019e8c <get_int>:

static uint32_t get_int (setting_id_t id)
{
 8019e8c:	b480      	push	{r7}
 8019e8e:	b085      	sub	sp, #20
 8019e90:	af00      	add	r7, sp, #0
 8019e92:	4603      	mov	r3, r0
 8019e94:	80fb      	strh	r3, [r7, #6]
    uint32_t value = 0;
 8019e96:	2300      	movs	r3, #0
 8019e98:	60fb      	str	r3, [r7, #12]

    switch(id) {
 8019e9a:	88fb      	ldrh	r3, [r7, #6]
 8019e9c:	f240 2207 	movw	r2, #519	; 0x207
 8019ea0:	4293      	cmp	r3, r2
 8019ea2:	f000 81e8 	beq.w	801a276 <get_int+0x3ea>
 8019ea6:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 8019eaa:	f280 81ec 	bge.w	801a286 <get_int+0x3fa>
 8019eae:	f5b3 7ff3 	cmp.w	r3, #486	; 0x1e6
 8019eb2:	f000 81d9 	beq.w	801a268 <get_int+0x3dc>
 8019eb6:	f5b3 7ff3 	cmp.w	r3, #486	; 0x1e6
 8019eba:	f300 81e4 	bgt.w	801a286 <get_int+0x3fa>
 8019ebe:	f5b3 7ff2 	cmp.w	r3, #484	; 0x1e4
 8019ec2:	f000 81c7 	beq.w	801a254 <get_int+0x3c8>
 8019ec6:	f5b3 7ff2 	cmp.w	r3, #484	; 0x1e4
 8019eca:	f300 81dc 	bgt.w	801a286 <get_int+0x3fa>
 8019ece:	f240 12e1 	movw	r2, #481	; 0x1e1
 8019ed2:	4293      	cmp	r3, r2
 8019ed4:	f000 81ba 	beq.w	801a24c <get_int+0x3c0>
 8019ed8:	f5b3 7ff1 	cmp.w	r3, #482	; 0x1e2
 8019edc:	f280 81d3 	bge.w	801a286 <get_int+0x3fa>
 8019ee0:	f240 128b 	movw	r2, #395	; 0x18b
 8019ee4:	4293      	cmp	r3, r2
 8019ee6:	f000 81a9 	beq.w	801a23c <get_int+0x3b0>
 8019eea:	f5b3 7fc6 	cmp.w	r3, #396	; 0x18c
 8019eee:	f280 81ca 	bge.w	801a286 <get_int+0x3fa>
 8019ef2:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 8019ef6:	f000 8199 	beq.w	801a22c <get_int+0x3a0>
 8019efa:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 8019efe:	f300 81c2 	bgt.w	801a286 <get_int+0x3fa>
 8019f02:	f5b3 7fad 	cmp.w	r3, #346	; 0x15a
 8019f06:	f000 8184 	beq.w	801a212 <get_int+0x386>
 8019f0a:	f5b3 7fad 	cmp.w	r3, #346	; 0x15a
 8019f0e:	f300 81ba 	bgt.w	801a286 <get_int+0x3fa>
 8019f12:	2b41      	cmp	r3, #65	; 0x41
 8019f14:	f300 8082 	bgt.w	801a01c <get_int+0x190>
 8019f18:	2b06      	cmp	r3, #6
 8019f1a:	f2c0 81b4 	blt.w	801a286 <get_int+0x3fa>
 8019f1e:	3b06      	subs	r3, #6
 8019f20:	2b3b      	cmp	r3, #59	; 0x3b
 8019f22:	f200 81b0 	bhi.w	801a286 <get_int+0x3fa>
 8019f26:	a201      	add	r2, pc, #4	; (adr r2, 8019f2c <get_int+0xa0>)
 8019f28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019f2c:	0801a05f 	.word	0x0801a05f
 8019f30:	0801a287 	.word	0x0801a287
 8019f34:	0801a06f 	.word	0x0801a06f
 8019f38:	0801a029 	.word	0x0801a029
 8019f3c:	0801a079 	.word	0x0801a079
 8019f40:	0801a287 	.word	0x0801a287
 8019f44:	0801a287 	.word	0x0801a287
 8019f48:	0801a083 	.word	0x0801a083
 8019f4c:	0801a093 	.word	0x0801a093
 8019f50:	0801a287 	.word	0x0801a287
 8019f54:	0801a0a7 	.word	0x0801a0a7
 8019f58:	0801a0b1 	.word	0x0801a0b1
 8019f5c:	0801a287 	.word	0x0801a287
 8019f60:	0801a0c5 	.word	0x0801a0c5
 8019f64:	0801a0d5 	.word	0x0801a0d5
 8019f68:	0801a0e5 	.word	0x0801a0e5
 8019f6c:	0801a12f 	.word	0x0801a12f
 8019f70:	0801a287 	.word	0x0801a287
 8019f74:	0801a287 	.word	0x0801a287
 8019f78:	0801a287 	.word	0x0801a287
 8019f7c:	0801a287 	.word	0x0801a287
 8019f80:	0801a287 	.word	0x0801a287
 8019f84:	0801a287 	.word	0x0801a287
 8019f88:	0801a287 	.word	0x0801a287
 8019f8c:	0801a287 	.word	0x0801a287
 8019f90:	0801a287 	.word	0x0801a287
 8019f94:	0801a057 	.word	0x0801a057
 8019f98:	0801a287 	.word	0x0801a287
 8019f9c:	0801a287 	.word	0x0801a287
 8019fa0:	0801a287 	.word	0x0801a287
 8019fa4:	0801a287 	.word	0x0801a287
 8019fa8:	0801a173 	.word	0x0801a173
 8019fac:	0801a287 	.word	0x0801a287
 8019fb0:	0801a17d 	.word	0x0801a17d
 8019fb4:	0801a11f 	.word	0x0801a11f
 8019fb8:	0801a18d 	.word	0x0801a18d
 8019fbc:	0801a287 	.word	0x0801a287
 8019fc0:	0801a287 	.word	0x0801a287
 8019fc4:	0801a197 	.word	0x0801a197
 8019fc8:	0801a197 	.word	0x0801a197
 8019fcc:	0801a197 	.word	0x0801a197
 8019fd0:	0801a197 	.word	0x0801a197
 8019fd4:	0801a197 	.word	0x0801a197
 8019fd8:	0801a197 	.word	0x0801a197
 8019fdc:	0801a287 	.word	0x0801a287
 8019fe0:	0801a287 	.word	0x0801a287
 8019fe4:	0801a287 	.word	0x0801a287
 8019fe8:	0801a287 	.word	0x0801a287
 8019fec:	0801a287 	.word	0x0801a287
 8019ff0:	0801a287 	.word	0x0801a287
 8019ff4:	0801a287 	.word	0x0801a287
 8019ff8:	0801a287 	.word	0x0801a287
 8019ffc:	0801a287 	.word	0x0801a287
 801a000:	0801a287 	.word	0x0801a287
 801a004:	0801a1a7 	.word	0x0801a1a7
 801a008:	0801a287 	.word	0x0801a287
 801a00c:	0801a1b7 	.word	0x0801a1b7
 801a010:	0801a1c7 	.word	0x0801a1c7
 801a014:	0801a1e9 	.word	0x0801a1e9
 801a018:	0801a1f9 	.word	0x0801a1f9
 801a01c:	f240 1255 	movw	r2, #341	; 0x155
 801a020:	4293      	cmp	r3, r2
 801a022:	f000 80f1 	beq.w	801a208 <get_int+0x37c>
            value = settings.flags.ngc_debug_out;
            break;
#endif

        default:
            break;
 801a026:	e12e      	b.n	801a286 <get_int+0x3fa>
            value = settings.spindle.flags.pwm_disable ? 0 : (settings.spindle.flags.enable_rpm_controlled ? 0b11 : 0b01);
 801a028:	4b9a      	ldr	r3, [pc, #616]	; (801a294 <get_int+0x408>)
 801a02a:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 801a02e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801a032:	b2db      	uxtb	r3, r3
 801a034:	2b00      	cmp	r3, #0
 801a036:	d10b      	bne.n	801a050 <get_int+0x1c4>
 801a038:	4b96      	ldr	r3, [pc, #600]	; (801a294 <get_int+0x408>)
 801a03a:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 801a03e:	f003 0301 	and.w	r3, r3, #1
 801a042:	b2db      	uxtb	r3, r3
 801a044:	2b00      	cmp	r3, #0
 801a046:	d001      	beq.n	801a04c <get_int+0x1c0>
 801a048:	2303      	movs	r3, #3
 801a04a:	e002      	b.n	801a052 <get_int+0x1c6>
 801a04c:	2301      	movs	r3, #1
 801a04e:	e000      	b.n	801a052 <get_int+0x1c6>
 801a050:	2300      	movs	r3, #0
 801a052:	60fb      	str	r3, [r7, #12]
            break;
 801a054:	e118      	b.n	801a288 <get_int+0x3fc>
            value = settings.mode;
 801a056:	4b8f      	ldr	r3, [pc, #572]	; (801a294 <get_int+0x408>)
 801a058:	7e1b      	ldrb	r3, [r3, #24]
 801a05a:	60fb      	str	r3, [r7, #12]
            break;
 801a05c:	e114      	b.n	801a288 <get_int+0x3fc>
            value = settings.probe.invert_probe_pin;
 801a05e:	4b8d      	ldr	r3, [pc, #564]	; (801a294 <get_int+0x408>)
 801a060:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 801a064:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801a068:	b2db      	uxtb	r3, r3
 801a06a:	60fb      	str	r3, [r7, #12]
            break;
 801a06c:	e10c      	b.n	801a288 <get_int+0x3fc>
            value = settings.steppers.ganged_dir_invert.mask;
 801a06e:	4b89      	ldr	r3, [pc, #548]	; (801a294 <get_int+0x408>)
 801a070:	f893 30ea 	ldrb.w	r3, [r3, #234]	; 0xea
 801a074:	60fb      	str	r3, [r7, #12]
            break;
 801a076:	e107      	b.n	801a288 <get_int+0x3fc>
            value = settings.status_report.mask;
 801a078:	4b86      	ldr	r3, [pc, #536]	; (801a294 <get_int+0x408>)
 801a07a:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
 801a07e:	60fb      	str	r3, [r7, #12]
            break;
 801a080:	e102      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.report_inches;
 801a082:	4b84      	ldr	r3, [pc, #528]	; (801a294 <get_int+0x408>)
 801a084:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a088:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801a08c:	b2db      	uxtb	r3, r3
 801a08e:	60fb      	str	r3, [r7, #12]
            break;
 801a090:	e0fa      	b.n	801a288 <get_int+0x3fc>
            value = settings.control_invert.mask & hal.signals_cap.mask;
 801a092:	4b80      	ldr	r3, [pc, #512]	; (801a294 <get_int+0x408>)
 801a094:	f8b3 206c 	ldrh.w	r2, [r3, #108]	; 0x6c
 801a098:	4b7f      	ldr	r3, [pc, #508]	; (801a298 <get_int+0x40c>)
 801a09a:	f8b3 31ac 	ldrh.w	r3, [r3, #428]	; 0x1ac
 801a09e:	4013      	ands	r3, r2
 801a0a0:	b29b      	uxth	r3, r3
 801a0a2:	60fb      	str	r3, [r7, #12]
            break;
 801a0a4:	e0f0      	b.n	801a288 <get_int+0x3fc>
            value = settings.spindle.invert.mask;
 801a0a6:	4b7b      	ldr	r3, [pc, #492]	; (801a294 <get_int+0x408>)
 801a0a8:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 801a0ac:	60fb      	str	r3, [r7, #12]
            break;
 801a0ae:	e0eb      	b.n	801a288 <get_int+0x3fc>
            value = settings.control_disable_pullup.mask & hal.signals_cap.mask;
 801a0b0:	4b78      	ldr	r3, [pc, #480]	; (801a294 <get_int+0x408>)
 801a0b2:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 801a0b6:	4b78      	ldr	r3, [pc, #480]	; (801a298 <get_int+0x40c>)
 801a0b8:	f8b3 31ac 	ldrh.w	r3, [r3, #428]	; 0x1ac
 801a0bc:	4013      	ands	r3, r2
 801a0be:	b29b      	uxth	r3, r3
 801a0c0:	60fb      	str	r3, [r7, #12]
            break;
 801a0c2:	e0e1      	b.n	801a288 <get_int+0x3fc>
            value = settings.probe.disable_probe_pullup;
 801a0c4:	4b73      	ldr	r3, [pc, #460]	; (801a294 <get_int+0x408>)
 801a0c6:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 801a0ca:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801a0ce:	b2db      	uxtb	r3, r3
 801a0d0:	60fb      	str	r3, [r7, #12]
            break;
 801a0d2:	e0d9      	b.n	801a288 <get_int+0x3fc>
            value = settings.limits.flags.soft_enabled;
 801a0d4:	4b6f      	ldr	r3, [pc, #444]	; (801a294 <get_int+0x408>)
 801a0d6:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a0da:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801a0de:	b2db      	uxtb	r3, r3
 801a0e0:	60fb      	str	r3, [r7, #12]
            break;
 801a0e2:	e0d1      	b.n	801a288 <get_int+0x3fc>
            value = ((settings.limits.flags.hard_enabled & bit(0)) ? bit(0) |
 801a0e4:	4b6b      	ldr	r3, [pc, #428]	; (801a294 <get_int+0x408>)
 801a0e6:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a0ea:	f003 0301 	and.w	r3, r3, #1
 801a0ee:	b2db      	uxtb	r3, r3
                      (settings.limits.flags.hard_disabled_rotary ? bit(2) : 0) : 0);
 801a0f0:	2b00      	cmp	r3, #0
 801a0f2:	d011      	beq.n	801a118 <get_int+0x28c>
                     (settings.limits.flags.check_at_init ? bit(1) : 0) |
 801a0f4:	4b67      	ldr	r3, [pc, #412]	; (801a294 <get_int+0x408>)
 801a0f6:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a0fa:	085b      	lsrs	r3, r3, #1
 801a0fc:	b2db      	uxtb	r3, r3
 801a0fe:	f003 0202 	and.w	r2, r3, #2
                      (settings.limits.flags.hard_disabled_rotary ? bit(2) : 0) : 0);
 801a102:	4b64      	ldr	r3, [pc, #400]	; (801a294 <get_int+0x408>)
 801a104:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a108:	08db      	lsrs	r3, r3, #3
 801a10a:	b2db      	uxtb	r3, r3
 801a10c:	f003 0304 	and.w	r3, r3, #4
                     (settings.limits.flags.check_at_init ? bit(1) : 0) |
 801a110:	4313      	orrs	r3, r2
                      (settings.limits.flags.hard_disabled_rotary ? bit(2) : 0) : 0);
 801a112:	f043 0301 	orr.w	r3, r3, #1
 801a116:	e000      	b.n	801a11a <get_int+0x28e>
 801a118:	2300      	movs	r3, #0
            value = ((settings.limits.flags.hard_enabled & bit(0)) ? bit(0) |
 801a11a:	60fb      	str	r3, [r7, #12]
            break;
 801a11c:	e0b4      	b.n	801a288 <get_int+0x3fc>
            value = settings.limits.flags.jog_soft_limited;
 801a11e:	4b5d      	ldr	r3, [pc, #372]	; (801a294 <get_int+0x408>)
 801a120:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a124:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801a128:	b2db      	uxtb	r3, r3
 801a12a:	60fb      	str	r3, [r7, #12]
            break;
 801a12c:	e0ac      	b.n	801a288 <get_int+0x3fc>
            value = (settings.homing.flags.value & 0x0F) |
 801a12e:	4b59      	ldr	r3, [pc, #356]	; (801a294 <get_int+0x408>)
 801a130:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801a134:	f003 020f 	and.w	r2, r3, #15
                     (settings.limits.flags.two_switches ? bit(4) : 0) |
 801a138:	4b56      	ldr	r3, [pc, #344]	; (801a294 <get_int+0x408>)
 801a13a:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 801a13e:	f003 0310 	and.w	r3, r3, #16
            value = (settings.homing.flags.value & 0x0F) |
 801a142:	431a      	orrs	r2, r3
                      (settings.homing.flags.manual ? bit(5) : 0) |
 801a144:	4b53      	ldr	r3, [pc, #332]	; (801a294 <get_int+0x408>)
 801a146:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801a14a:	005b      	lsls	r3, r3, #1
 801a14c:	f003 0320 	and.w	r3, r3, #32
                     (settings.limits.flags.two_switches ? bit(4) : 0) |
 801a150:	431a      	orrs	r2, r3
                       (settings.homing.flags.override_locks ? bit(6) : 0) |
 801a152:	4b50      	ldr	r3, [pc, #320]	; (801a294 <get_int+0x408>)
 801a154:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801a158:	005b      	lsls	r3, r3, #1
 801a15a:	f003 0340 	and.w	r3, r3, #64	; 0x40
                      (settings.homing.flags.manual ? bit(5) : 0) |
 801a15e:	431a      	orrs	r2, r3
                        (settings.homing.flags.keep_on_reset ? bit(7) : 0);
 801a160:	4b4c      	ldr	r3, [pc, #304]	; (801a294 <get_int+0x408>)
 801a162:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 801a166:	005b      	lsls	r3, r3, #1
 801a168:	f003 0380 	and.w	r3, r3, #128	; 0x80
            value = (settings.homing.flags.value & 0x0F) |
 801a16c:	4313      	orrs	r3, r2
 801a16e:	60fb      	str	r3, [r7, #12]
            break;
 801a170:	e08a      	b.n	801a288 <get_int+0x3fc>
            value = settings.steppers.deenergize.mask;
 801a172:	4b48      	ldr	r3, [pc, #288]	; (801a294 <get_int+0x408>)
 801a174:	f893 30ec 	ldrb.w	r3, [r3, #236]	; 0xec
 801a178:	60fb      	str	r3, [r7, #12]
            break;
 801a17a:	e085      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.legacy_rt_commands;
 801a17c:	4b45      	ldr	r3, [pc, #276]	; (801a294 <get_int+0x408>)
 801a17e:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a182:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801a186:	b2db      	uxtb	r3, r3
 801a188:	60fb      	str	r3, [r7, #12]
            break;
 801a18a:	e07d      	b.n	801a288 <get_int+0x3fc>
            value = settings.parking.flags.value;
 801a18c:	4b41      	ldr	r3, [pc, #260]	; (801a294 <get_int+0x408>)
 801a18e:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801a192:	60fb      	str	r3, [r7, #12]
            break;
 801a194:	e078      	b.n	801a288 <get_int+0x3fc>
            value = settings.homing.cycle[id - Setting_HomingCycle_1].mask;
 801a196:	88fb      	ldrh	r3, [r7, #6]
 801a198:	3b2c      	subs	r3, #44	; 0x2c
 801a19a:	4a3e      	ldr	r2, [pc, #248]	; (801a294 <get_int+0x408>)
 801a19c:	4413      	add	r3, r2
 801a19e:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 801a1a2:	60fb      	str	r3, [r7, #12]
            break;
 801a1a4:	e070      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.restore_overrides;
 801a1a6:	4b3b      	ldr	r3, [pc, #236]	; (801a294 <get_int+0x408>)
 801a1a8:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a1ac:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801a1b0:	b2db      	uxtb	r3, r3
 801a1b2:	60fb      	str	r3, [r7, #12]
            break;
 801a1b4:	e068      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.sleep_enable;
 801a1b6:	4b37      	ldr	r3, [pc, #220]	; (801a294 <get_int+0x408>)
 801a1b8:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a1bc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801a1c0:	b2db      	uxtb	r3, r3
 801a1c2:	60fb      	str	r3, [r7, #12]
            break;
 801a1c4:	e060      	b.n	801a288 <get_int+0x3fc>
            value = (settings.flags.disable_laser_during_hold ? bit(0) : 0) | (settings.flags.restore_after_feed_hold ? bit(1) : 0);
 801a1c6:	4b33      	ldr	r3, [pc, #204]	; (801a294 <get_int+0x408>)
 801a1c8:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a1cc:	091b      	lsrs	r3, r3, #4
 801a1ce:	b2db      	uxtb	r3, r3
 801a1d0:	f003 0201 	and.w	r2, r3, #1
 801a1d4:	4b2f      	ldr	r3, [pc, #188]	; (801a294 <get_int+0x408>)
 801a1d6:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a1da:	099b      	lsrs	r3, r3, #6
 801a1dc:	b2db      	uxtb	r3, r3
 801a1de:	f003 0302 	and.w	r3, r3, #2
 801a1e2:	4313      	orrs	r3, r2
 801a1e4:	60fb      	str	r3, [r7, #12]
            break;
 801a1e6:	e04f      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.force_initialization_alarm;
 801a1e8:	4b2a      	ldr	r3, [pc, #168]	; (801a294 <get_int+0x408>)
 801a1ea:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801a1ee:	f3c3 1340 	ubfx	r3, r3, #5, #1
 801a1f2:	b2db      	uxtb	r3, r3
 801a1f4:	60fb      	str	r3, [r7, #12]
            break;
 801a1f6:	e047      	b.n	801a288 <get_int+0x3fc>
            value = settings.probe.allow_feed_override;
 801a1f8:	4b26      	ldr	r3, [pc, #152]	; (801a294 <get_int+0x408>)
 801a1fa:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 801a1fe:	f3c3 1300 	ubfx	r3, r3, #4, #1
 801a202:	b2db      	uxtb	r3, r3
 801a204:	60fb      	str	r3, [r7, #12]
            break;
 801a206:	e03f      	b.n	801a288 <get_int+0x3fc>
            value = settings.tool_change.mode;
 801a208:	4b22      	ldr	r3, [pc, #136]	; (801a294 <get_int+0x408>)
 801a20a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801a20e:	60fb      	str	r3, [r7, #12]
            break;
 801a210:	e03a      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.no_restore_position_after_M6 ? 0 : 1;
 801a212:	4b20      	ldr	r3, [pc, #128]	; (801a294 <get_int+0x408>)
 801a214:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 801a218:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801a21c:	b2db      	uxtb	r3, r3
 801a21e:	2b00      	cmp	r3, #0
 801a220:	bf0c      	ite	eq
 801a222:	2301      	moveq	r3, #1
 801a224:	2300      	movne	r3, #0
 801a226:	b2db      	uxtb	r3, r3
 801a228:	60fb      	str	r3, [r7, #12]
            break;
 801a22a:	e02d      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.g92_is_volatile;
 801a22c:	4b19      	ldr	r3, [pc, #100]	; (801a294 <get_int+0x408>)
 801a22e:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 801a232:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801a236:	b2db      	uxtb	r3, r3
 801a238:	60fb      	str	r3, [r7, #12]
            break;
 801a23a:	e025      	b.n	801a288 <get_int+0x3fc>
            value = settings.spindle.flags.type;
 801a23c:	4b15      	ldr	r3, [pc, #84]	; (801a294 <get_int+0x408>)
 801a23e:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 801a242:	f3c3 0384 	ubfx	r3, r3, #2, #5
 801a246:	b2db      	uxtb	r3, r3
 801a248:	60fb      	str	r3, [r7, #12]
            break;
 801a24a:	e01d      	b.n	801a288 <get_int+0x3fc>
            value = settings.report_interval;
 801a24c:	4b11      	ldr	r3, [pc, #68]	; (801a294 <get_int+0x408>)
 801a24e:	8a9b      	ldrh	r3, [r3, #20]
 801a250:	60fb      	str	r3, [r7, #12]
            break;
 801a252:	e019      	b.n	801a288 <get_int+0x3fc>
            value = settings.flags.no_unlock_after_estop ? 0 : 1;
 801a254:	4b0f      	ldr	r3, [pc, #60]	; (801a294 <get_int+0x408>)
 801a256:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 801a25a:	b25b      	sxtb	r3, r3
 801a25c:	43db      	mvns	r3, r3
 801a25e:	b2db      	uxtb	r3, r3
 801a260:	09db      	lsrs	r3, r3, #7
 801a262:	b2db      	uxtb	r3, r3
 801a264:	60fb      	str	r3, [r7, #12]
            break;
 801a266:	e00f      	b.n	801a288 <get_int+0x3fc>
            value = settings.offset_lock.mask & 0b111;
 801a268:	4b0a      	ldr	r3, [pc, #40]	; (801a294 <get_int+0x408>)
 801a26a:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801a26e:	f003 0307 	and.w	r3, r3, #7
 801a272:	60fb      	str	r3, [r7, #12]
            break;
 801a274:	e008      	b.n	801a288 <get_int+0x3fc>
            value = settings.offset_lock.encoder_spindle;
 801a276:	4b07      	ldr	r3, [pc, #28]	; (801a294 <get_int+0x408>)
 801a278:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801a27c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801a280:	b2db      	uxtb	r3, r3
 801a282:	60fb      	str	r3, [r7, #12]
            break;
 801a284:	e000      	b.n	801a288 <get_int+0x3fc>
            break;
 801a286:	bf00      	nop
    }

    return value;
 801a288:	68fb      	ldr	r3, [r7, #12]
}
 801a28a:	4618      	mov	r0, r3
 801a28c:	3714      	adds	r7, #20
 801a28e:	46bd      	mov	sp, r7
 801a290:	bc80      	pop	{r7}
 801a292:	4770      	bx	lr
 801a294:	2000147c 	.word	0x2000147c
 801a298:	20000ed0 	.word	0x20000ed0

0801a29c <get_decimal_places>:

inline static uint8_t get_decimal_places (const char *format)
{
 801a29c:	b580      	push	{r7, lr}
 801a29e:	b084      	sub	sp, #16
 801a2a0:	af00      	add	r7, sp, #0
 801a2a2:	6078      	str	r0, [r7, #4]
    char *dp = format == NULL ? NULL : strchr(format, '.');
 801a2a4:	687b      	ldr	r3, [r7, #4]
 801a2a6:	2b00      	cmp	r3, #0
 801a2a8:	d005      	beq.n	801a2b6 <get_decimal_places+0x1a>
 801a2aa:	212e      	movs	r1, #46	; 0x2e
 801a2ac:	6878      	ldr	r0, [r7, #4]
 801a2ae:	f009 fcc9 	bl	8023c44 <strchr>
 801a2b2:	4603      	mov	r3, r0
 801a2b4:	e000      	b.n	801a2b8 <get_decimal_places+0x1c>
 801a2b6:	2300      	movs	r3, #0
 801a2b8:	60fb      	str	r3, [r7, #12]

    return dp ? strchr(format, '\0') - dp - 1 : 1;
 801a2ba:	68fb      	ldr	r3, [r7, #12]
 801a2bc:	2b00      	cmp	r3, #0
 801a2be:	d00c      	beq.n	801a2da <get_decimal_places+0x3e>
 801a2c0:	6878      	ldr	r0, [r7, #4]
 801a2c2:	f7e5 ffbb 	bl	800023c <strlen>
 801a2c6:	4603      	mov	r3, r0
 801a2c8:	461a      	mov	r2, r3
 801a2ca:	687b      	ldr	r3, [r7, #4]
 801a2cc:	441a      	add	r2, r3
 801a2ce:	68fb      	ldr	r3, [r7, #12]
 801a2d0:	1ad3      	subs	r3, r2, r3
 801a2d2:	b2db      	uxtb	r3, r3
 801a2d4:	3b01      	subs	r3, #1
 801a2d6:	b2db      	uxtb	r3, r3
 801a2d8:	e000      	b.n	801a2dc <get_decimal_places+0x40>
 801a2da:	2301      	movs	r3, #1
}
 801a2dc:	4618      	mov	r0, r3
 801a2de:	3710      	adds	r7, #16
 801a2e0:	46bd      	mov	sp, r7
 801a2e2:	bd80      	pop	{r7, pc}

0801a2e4 <setting_get_value>:

char *setting_get_value (const setting_detail_t *setting, uint_fast16_t offset)
{
 801a2e4:	b590      	push	{r4, r7, lr}
 801a2e6:	b085      	sub	sp, #20
 801a2e8:	af00      	add	r7, sp, #0
 801a2ea:	6078      	str	r0, [r7, #4]
 801a2ec:	6039      	str	r1, [r7, #0]
    char *value = NULL;
 801a2ee:	2300      	movs	r3, #0
 801a2f0:	60fb      	str	r3, [r7, #12]

    if(setting == NULL)
 801a2f2:	687b      	ldr	r3, [r7, #4]
 801a2f4:	2b00      	cmp	r3, #0
 801a2f6:	d101      	bne.n	801a2fc <setting_get_value+0x18>
        return NULL;
 801a2f8:	2300      	movs	r3, #0
 801a2fa:	e0cd      	b.n	801a498 <setting_get_value+0x1b4>

    switch(setting->type) {
 801a2fc:	687b      	ldr	r3, [r7, #4]
 801a2fe:	7f1b      	ldrb	r3, [r3, #28]
 801a300:	2b07      	cmp	r3, #7
 801a302:	bf8c      	ite	hi
 801a304:	2201      	movhi	r2, #1
 801a306:	2200      	movls	r2, #0
 801a308:	b2d2      	uxtb	r2, r2
 801a30a:	2a00      	cmp	r2, #0
 801a30c:	f040 80c3 	bne.w	801a496 <setting_get_value+0x1b2>
 801a310:	2201      	movs	r2, #1
 801a312:	fa02 f303 	lsl.w	r3, r2, r3
 801a316:	f003 02aa 	and.w	r2, r3, #170	; 0xaa
 801a31a:	2a00      	cmp	r2, #0
 801a31c:	bf14      	ite	ne
 801a31e:	2201      	movne	r2, #1
 801a320:	2200      	moveq	r2, #0
 801a322:	b2d2      	uxtb	r2, r2
 801a324:	2a00      	cmp	r2, #0
 801a326:	d164      	bne.n	801a3f2 <setting_get_value+0x10e>
 801a328:	f003 0355 	and.w	r3, r3, #85	; 0x55
 801a32c:	2b00      	cmp	r3, #0
 801a32e:	bf14      	ite	ne
 801a330:	2301      	movne	r3, #1
 801a332:	2300      	moveq	r3, #0
 801a334:	b2db      	uxtb	r3, r3
 801a336:	2b00      	cmp	r3, #0
 801a338:	f000 80ad 	beq.w	801a496 <setting_get_value+0x1b2>

        case Setting_NonCore:
        case Setting_IsExtended:
        case Setting_IsLegacy:
        case Setting_IsExpanded:
            switch(setting->datatype) {
 801a33c:	687b      	ldr	r3, [r7, #4]
 801a33e:	7b1b      	ldrb	r3, [r3, #12]
 801a340:	2b0b      	cmp	r3, #11
 801a342:	d854      	bhi.n	801a3ee <setting_get_value+0x10a>
 801a344:	a201      	add	r2, pc, #4	; (adr r2, 801a34c <setting_get_value+0x68>)
 801a346:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a34a:	bf00      	nop
 801a34c:	0801a39b 	.word	0x0801a39b
 801a350:	0801a39b 	.word	0x0801a39b
 801a354:	0801a39b 	.word	0x0801a39b
 801a358:	0801a39b 	.word	0x0801a39b
 801a35c:	0801a39b 	.word	0x0801a39b
 801a360:	0801a3bb 	.word	0x0801a3bb
 801a364:	0801a37d 	.word	0x0801a37d
 801a368:	0801a3e7 	.word	0x0801a3e7
 801a36c:	0801a3cb 	.word	0x0801a3cb
 801a370:	0801a3e7 	.word	0x0801a3e7
 801a374:	0801a39b 	.word	0x0801a39b
 801a378:	0801a3ab 	.word	0x0801a3ab

                case Format_Decimal:
                    value = ftoa(*((float *)(setting->value)), get_decimal_places(setting->format));
 801a37c:	687b      	ldr	r3, [r7, #4]
 801a37e:	6a1b      	ldr	r3, [r3, #32]
 801a380:	681c      	ldr	r4, [r3, #0]
 801a382:	687b      	ldr	r3, [r7, #4]
 801a384:	691b      	ldr	r3, [r3, #16]
 801a386:	4618      	mov	r0, r3
 801a388:	f7ff ff88 	bl	801a29c <get_decimal_places>
 801a38c:	4603      	mov	r3, r0
 801a38e:	4619      	mov	r1, r3
 801a390:	4620      	mov	r0, r4
 801a392:	f7f5 ffb7 	bl	8010304 <ftoa>
 801a396:	60f8      	str	r0, [r7, #12]
                    break;
 801a398:	e02a      	b.n	801a3f0 <setting_get_value+0x10c>
                case Format_Bool:
                case Format_Bitfield:
                case Format_XBitfield:
                case Format_AxisMask:
                case Format_RadioButtons:
                    value = uitoa(*((uint8_t *)(setting->value)));
 801a39a:	687b      	ldr	r3, [r7, #4]
 801a39c:	6a1b      	ldr	r3, [r3, #32]
 801a39e:	781b      	ldrb	r3, [r3, #0]
 801a3a0:	4618      	mov	r0, r3
 801a3a2:	f7f5 ff73 	bl	801028c <uitoa>
 801a3a6:	60f8      	str	r0, [r7, #12]
                    break;
 801a3a8:	e022      	b.n	801a3f0 <setting_get_value+0x10c>

                case Format_Int16:
                    value = uitoa(*((uint16_t *)(setting->value)));
 801a3aa:	687b      	ldr	r3, [r7, #4]
 801a3ac:	6a1b      	ldr	r3, [r3, #32]
 801a3ae:	881b      	ldrh	r3, [r3, #0]
 801a3b0:	4618      	mov	r0, r3
 801a3b2:	f7f5 ff6b 	bl	801028c <uitoa>
 801a3b6:	60f8      	str	r0, [r7, #12]
                    break;
 801a3b8:	e01a      	b.n	801a3f0 <setting_get_value+0x10c>

                case Format_Integer:
                    value = uitoa(*((uint32_t *)(setting->value)));
 801a3ba:	687b      	ldr	r3, [r7, #4]
 801a3bc:	6a1b      	ldr	r3, [r3, #32]
 801a3be:	681b      	ldr	r3, [r3, #0]
 801a3c0:	4618      	mov	r0, r3
 801a3c2:	f7f5 ff63 	bl	801028c <uitoa>
 801a3c6:	60f8      	str	r0, [r7, #12]
                    break;
 801a3c8:	e012      	b.n	801a3f0 <setting_get_value+0x10c>

                case Format_Password:
                    value = hal.stream.state.webui_connected ? PASSWORD_MASK : ((char *)(setting->value));
 801a3ca:	4b35      	ldr	r3, [pc, #212]	; (801a4a0 <setting_get_value+0x1bc>)
 801a3cc:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801a3d0:	f003 0302 	and.w	r3, r3, #2
 801a3d4:	b2db      	uxtb	r3, r3
 801a3d6:	2b00      	cmp	r3, #0
 801a3d8:	d102      	bne.n	801a3e0 <setting_get_value+0xfc>
 801a3da:	687b      	ldr	r3, [r7, #4]
 801a3dc:	6a1b      	ldr	r3, [r3, #32]
 801a3de:	e000      	b.n	801a3e2 <setting_get_value+0xfe>
 801a3e0:	4b30      	ldr	r3, [pc, #192]	; (801a4a4 <setting_get_value+0x1c0>)
 801a3e2:	60fb      	str	r3, [r7, #12]
                    break;
 801a3e4:	e004      	b.n	801a3f0 <setting_get_value+0x10c>

                case Format_String:
                case Format_IPv4:
                    value = ((char *)(setting->value));
 801a3e6:	687b      	ldr	r3, [r7, #4]
 801a3e8:	6a1b      	ldr	r3, [r3, #32]
 801a3ea:	60fb      	str	r3, [r7, #12]
                    break;
 801a3ec:	e000      	b.n	801a3f0 <setting_get_value+0x10c>

                default:
                    break;
 801a3ee:	bf00      	nop
            }
            break;
 801a3f0:	e051      	b.n	801a496 <setting_get_value+0x1b2>
        case Setting_NonCoreFn:
        case Setting_IsExtendedFn:
        case Setting_IsLegacyFn:
        case Setting_IsExpandedFn:;

            setting_id_t id = (setting_id_t)(setting->id + offset);
 801a3f2:	687b      	ldr	r3, [r7, #4]
 801a3f4:	881a      	ldrh	r2, [r3, #0]
 801a3f6:	683b      	ldr	r3, [r7, #0]
 801a3f8:	b29b      	uxth	r3, r3
 801a3fa:	4413      	add	r3, r2
 801a3fc:	817b      	strh	r3, [r7, #10]

            switch(setting->datatype) {
 801a3fe:	687b      	ldr	r3, [r7, #4]
 801a400:	7b1b      	ldrb	r3, [r3, #12]
 801a402:	3b06      	subs	r3, #6
 801a404:	2b03      	cmp	r3, #3
 801a406:	d839      	bhi.n	801a47c <setting_get_value+0x198>
 801a408:	a201      	add	r2, pc, #4	; (adr r2, 801a410 <setting_get_value+0x12c>)
 801a40a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a40e:	bf00      	nop
 801a410:	0801a421 	.word	0x0801a421
 801a414:	0801a46d 	.word	0x0801a46d
 801a418:	0801a447 	.word	0x0801a447
 801a41c:	0801a46d 	.word	0x0801a46d

                case Format_Decimal:
                    value = ftoa(((setting_get_float_ptr)(setting->get_value))(id), get_decimal_places(setting->format));
 801a420:	687b      	ldr	r3, [r7, #4]
 801a422:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a424:	461a      	mov	r2, r3
 801a426:	897b      	ldrh	r3, [r7, #10]
 801a428:	4618      	mov	r0, r3
 801a42a:	4790      	blx	r2
 801a42c:	4604      	mov	r4, r0
 801a42e:	687b      	ldr	r3, [r7, #4]
 801a430:	691b      	ldr	r3, [r3, #16]
 801a432:	4618      	mov	r0, r3
 801a434:	f7ff ff32 	bl	801a29c <get_decimal_places>
 801a438:	4603      	mov	r3, r0
 801a43a:	4619      	mov	r1, r3
 801a43c:	4620      	mov	r0, r4
 801a43e:	f7f5 ff61 	bl	8010304 <ftoa>
 801a442:	60f8      	str	r0, [r7, #12]
                    break;
 801a444:	e026      	b.n	801a494 <setting_get_value+0x1b0>

                case Format_Password:
                    value = hal.stream.state.webui_connected ? "********" : ((setting_get_string_ptr)(setting->get_value))(id);
 801a446:	4b16      	ldr	r3, [pc, #88]	; (801a4a0 <setting_get_value+0x1bc>)
 801a448:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801a44c:	f003 0302 	and.w	r3, r3, #2
 801a450:	b2db      	uxtb	r3, r3
 801a452:	2b00      	cmp	r3, #0
 801a454:	d107      	bne.n	801a466 <setting_get_value+0x182>
 801a456:	687b      	ldr	r3, [r7, #4]
 801a458:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a45a:	461a      	mov	r2, r3
 801a45c:	897b      	ldrh	r3, [r7, #10]
 801a45e:	4618      	mov	r0, r3
 801a460:	4790      	blx	r2
 801a462:	4603      	mov	r3, r0
 801a464:	e000      	b.n	801a468 <setting_get_value+0x184>
 801a466:	4b0f      	ldr	r3, [pc, #60]	; (801a4a4 <setting_get_value+0x1c0>)
 801a468:	60fb      	str	r3, [r7, #12]
                    break;
 801a46a:	e013      	b.n	801a494 <setting_get_value+0x1b0>

                case Format_String:
                case Format_IPv4:
                    value = ((setting_get_string_ptr)(setting->get_value))(id);
 801a46c:	687b      	ldr	r3, [r7, #4]
 801a46e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a470:	461a      	mov	r2, r3
 801a472:	897b      	ldrh	r3, [r7, #10]
 801a474:	4618      	mov	r0, r3
 801a476:	4790      	blx	r2
 801a478:	60f8      	str	r0, [r7, #12]
                    break;
 801a47a:	e00b      	b.n	801a494 <setting_get_value+0x1b0>

                default:
                    value = uitoa(((setting_get_int_ptr)(setting->get_value))(id));
 801a47c:	687b      	ldr	r3, [r7, #4]
 801a47e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a480:	461a      	mov	r2, r3
 801a482:	897b      	ldrh	r3, [r7, #10]
 801a484:	4618      	mov	r0, r3
 801a486:	4790      	blx	r2
 801a488:	4603      	mov	r3, r0
 801a48a:	4618      	mov	r0, r3
 801a48c:	f7f5 fefe 	bl	801028c <uitoa>
 801a490:	60f8      	str	r0, [r7, #12]
                    break;
 801a492:	bf00      	nop
            }
            break;
 801a494:	bf00      	nop
    }

    return value;
 801a496:	68fb      	ldr	r3, [r7, #12]
}
 801a498:	4618      	mov	r0, r3
 801a49a:	3714      	adds	r7, #20
 801a49c:	46bd      	mov	sp, r7
 801a49e:	bd90      	pop	{r4, r7, pc}
 801a4a0:	20000ed0 	.word	0x20000ed0
 801a4a4:	0802ea00 	.word	0x0802ea00

0801a4a8 <setting_get_int_value>:

uint32_t setting_get_int_value (const setting_detail_t *setting, uint_fast16_t offset)
{
 801a4a8:	b580      	push	{r7, lr}
 801a4aa:	b084      	sub	sp, #16
 801a4ac:	af00      	add	r7, sp, #0
 801a4ae:	6078      	str	r0, [r7, #4]
 801a4b0:	6039      	str	r1, [r7, #0]
    uint32_t value = 0;
 801a4b2:	2300      	movs	r3, #0
 801a4b4:	60fb      	str	r3, [r7, #12]

    if(setting) switch(setting->type) {
 801a4b6:	687b      	ldr	r3, [r7, #4]
 801a4b8:	2b00      	cmp	r3, #0
 801a4ba:	d062      	beq.n	801a582 <setting_get_int_value+0xda>
 801a4bc:	687b      	ldr	r3, [r7, #4]
 801a4be:	7f1b      	ldrb	r3, [r3, #28]
 801a4c0:	2b07      	cmp	r3, #7
 801a4c2:	bf8c      	ite	hi
 801a4c4:	2201      	movhi	r2, #1
 801a4c6:	2200      	movls	r2, #0
 801a4c8:	b2d2      	uxtb	r2, r2
 801a4ca:	2a00      	cmp	r2, #0
 801a4cc:	d159      	bne.n	801a582 <setting_get_int_value+0xda>
 801a4ce:	2201      	movs	r2, #1
 801a4d0:	fa02 f303 	lsl.w	r3, r2, r3
 801a4d4:	f003 02aa 	and.w	r2, r3, #170	; 0xaa
 801a4d8:	2a00      	cmp	r2, #0
 801a4da:	bf14      	ite	ne
 801a4dc:	2201      	movne	r2, #1
 801a4de:	2200      	moveq	r2, #0
 801a4e0:	b2d2      	uxtb	r2, r2
 801a4e2:	2a00      	cmp	r2, #0
 801a4e4:	d139      	bne.n	801a55a <setting_get_int_value+0xb2>
 801a4e6:	f003 0355 	and.w	r3, r3, #85	; 0x55
 801a4ea:	2b00      	cmp	r3, #0
 801a4ec:	bf14      	ite	ne
 801a4ee:	2301      	movne	r3, #1
 801a4f0:	2300      	moveq	r3, #0
 801a4f2:	b2db      	uxtb	r3, r3
 801a4f4:	2b00      	cmp	r3, #0
 801a4f6:	d044      	beq.n	801a582 <setting_get_int_value+0xda>

        case Setting_NonCore:
        case Setting_IsExtended:
        case Setting_IsLegacy:
        case Setting_IsExpanded:
            switch(setting->datatype) {
 801a4f8:	687b      	ldr	r3, [r7, #4]
 801a4fa:	7b1b      	ldrb	r3, [r3, #12]
 801a4fc:	2b0b      	cmp	r3, #11
 801a4fe:	d82a      	bhi.n	801a556 <setting_get_int_value+0xae>
 801a500:	a201      	add	r2, pc, #4	; (adr r2, 801a508 <setting_get_int_value+0x60>)
 801a502:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a506:	bf00      	nop
 801a508:	0801a539 	.word	0x0801a539
 801a50c:	0801a539 	.word	0x0801a539
 801a510:	0801a539 	.word	0x0801a539
 801a514:	0801a539 	.word	0x0801a539
 801a518:	0801a539 	.word	0x0801a539
 801a51c:	0801a54d 	.word	0x0801a54d
 801a520:	0801a557 	.word	0x0801a557
 801a524:	0801a557 	.word	0x0801a557
 801a528:	0801a557 	.word	0x0801a557
 801a52c:	0801a557 	.word	0x0801a557
 801a530:	0801a539 	.word	0x0801a539
 801a534:	0801a543 	.word	0x0801a543
                case Format_Bool:
                case Format_Bitfield:
                case Format_XBitfield:
                case Format_AxisMask:
                case Format_RadioButtons:
                    value = *((uint8_t *)(setting->value));
 801a538:	687b      	ldr	r3, [r7, #4]
 801a53a:	6a1b      	ldr	r3, [r3, #32]
 801a53c:	781b      	ldrb	r3, [r3, #0]
 801a53e:	60fb      	str	r3, [r7, #12]
                    break;
 801a540:	e00a      	b.n	801a558 <setting_get_int_value+0xb0>

                case Format_Int16:
                    value = *((uint16_t *)(setting->value));
 801a542:	687b      	ldr	r3, [r7, #4]
 801a544:	6a1b      	ldr	r3, [r3, #32]
 801a546:	881b      	ldrh	r3, [r3, #0]
 801a548:	60fb      	str	r3, [r7, #12]
                    break;
 801a54a:	e005      	b.n	801a558 <setting_get_int_value+0xb0>

                case Format_Integer:
                    value = *((uint32_t *)(setting->value));
 801a54c:	687b      	ldr	r3, [r7, #4]
 801a54e:	6a1b      	ldr	r3, [r3, #32]
 801a550:	681b      	ldr	r3, [r3, #0]
 801a552:	60fb      	str	r3, [r7, #12]
                    break;
 801a554:	e000      	b.n	801a558 <setting_get_int_value+0xb0>

                default:
                    break;
 801a556:	bf00      	nop
            }
            break;
 801a558:	e013      	b.n	801a582 <setting_get_int_value+0xda>

        case Setting_NonCoreFn:
        case Setting_IsExtendedFn:
        case Setting_IsLegacyFn:
        case Setting_IsExpandedFn:
            switch(setting->datatype) {
 801a55a:	687b      	ldr	r3, [r7, #4]
 801a55c:	7b1b      	ldrb	r3, [r3, #12]
 801a55e:	3b06      	subs	r3, #6
 801a560:	2b03      	cmp	r3, #3
 801a562:	d90c      	bls.n	801a57e <setting_get_int_value+0xd6>
                case Format_Password:
                case Format_IPv4:
                    break;

                default:
                    value = ((setting_get_int_ptr)(setting->get_value))((setting_id_t)(setting->id + offset));
 801a564:	687b      	ldr	r3, [r7, #4]
 801a566:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801a568:	4619      	mov	r1, r3
 801a56a:	687b      	ldr	r3, [r7, #4]
 801a56c:	881a      	ldrh	r2, [r3, #0]
 801a56e:	683b      	ldr	r3, [r7, #0]
 801a570:	b29b      	uxth	r3, r3
 801a572:	4413      	add	r3, r2
 801a574:	b29b      	uxth	r3, r3
 801a576:	4618      	mov	r0, r3
 801a578:	4788      	blx	r1
 801a57a:	60f8      	str	r0, [r7, #12]
                    break;
 801a57c:	e000      	b.n	801a580 <setting_get_int_value+0xd8>
                    break;
 801a57e:	bf00      	nop
            }
            break;
 801a580:	bf00      	nop
    }

    return value;
 801a582:	68fb      	ldr	r3, [r7, #12]
}
 801a584:	4618      	mov	r0, r3
 801a586:	3710      	adds	r7, #16
 801a588:	46bd      	mov	sp, r7
 801a58a:	bd80      	pop	{r7, pc}

0801a58c <is_setting_available>:

    return value;
}

static bool is_setting_available (const setting_detail_t *setting)
{
 801a58c:	b580      	push	{r7, lr}
 801a58e:	b084      	sub	sp, #16
 801a590:	af00      	add	r7, sp, #0
 801a592:	6078      	str	r0, [r7, #4]
    bool available = false;
 801a594:	2300      	movs	r3, #0
 801a596:	73fb      	strb	r3, [r7, #15]

    if(setting) switch(normalize_id(setting->id)) {
 801a598:	687b      	ldr	r3, [r7, #4]
 801a59a:	2b00      	cmp	r3, #0
 801a59c:	f000 825b 	beq.w	801aa56 <is_setting_available+0x4ca>
 801a5a0:	687b      	ldr	r3, [r7, #4]
 801a5a2:	881b      	ldrh	r3, [r3, #0]
 801a5a4:	4618      	mov	r0, r3
 801a5a6:	f7ff f93d 	bl	8019824 <normalize_id>
 801a5aa:	4603      	mov	r3, r0
 801a5ac:	f240 228a 	movw	r2, #650	; 0x28a
 801a5b0:	4293      	cmp	r3, r2
 801a5b2:	f000 8236 	beq.w	801aa22 <is_setting_available+0x496>
 801a5b6:	f240 228a 	movw	r2, #650	; 0x28a
 801a5ba:	4293      	cmp	r3, r2
 801a5bc:	f300 824a 	bgt.w	801aa54 <is_setting_available+0x4c8>
 801a5c0:	f240 2207 	movw	r2, #519	; 0x207
 801a5c4:	4293      	cmp	r3, r2
 801a5c6:	f000 8216 	beq.w	801a9f6 <is_setting_available+0x46a>
 801a5ca:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 801a5ce:	f280 8241 	bge.w	801aa54 <is_setting_available+0x4c8>
 801a5d2:	f5b3 7ff2 	cmp.w	r3, #484	; 0x1e4
 801a5d6:	f000 8202 	beq.w	801a9de <is_setting_available+0x452>
 801a5da:	f5b3 7ff2 	cmp.w	r3, #484	; 0x1e4
 801a5de:	f300 8239 	bgt.w	801aa54 <is_setting_available+0x4c8>
 801a5e2:	f5b3 7ff1 	cmp.w	r3, #482	; 0x1e2
 801a5e6:	f000 81f1 	beq.w	801a9cc <is_setting_available+0x440>
 801a5ea:	f5b3 7ff1 	cmp.w	r3, #482	; 0x1e2
 801a5ee:	f300 8231 	bgt.w	801aa54 <is_setting_available+0x4c8>
 801a5f2:	f240 12e1 	movw	r2, #481	; 0x1e1
 801a5f6:	4293      	cmp	r3, r2
 801a5f8:	f000 81df 	beq.w	801a9ba <is_setting_available+0x42e>
 801a5fc:	f5b3 7ff1 	cmp.w	r3, #482	; 0x1e2
 801a600:	f280 8228 	bge.w	801aa54 <is_setting_available+0x4c8>
 801a604:	f5b3 7fc6 	cmp.w	r3, #396	; 0x18c
 801a608:	f280 8224 	bge.w	801aa54 <is_setting_available+0x4c8>
 801a60c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 801a610:	da05      	bge.n	801a61e <is_setting_available+0x92>
 801a612:	2b41      	cmp	r3, #65	; 0x41
 801a614:	f300 80fc 	bgt.w	801a810 <is_setting_available+0x284>
 801a618:	2b06      	cmp	r3, #6
 801a61a:	da79      	bge.n	801a710 <is_setting_available+0x184>
        case Setting_FSOptions:
            available = hal.driver_cap.sd_card || hal.driver_cap.littlefs;
            break;

        default:
            break;
 801a61c:	e21a      	b.n	801aa54 <is_setting_available+0x4c8>
    if(setting) switch(normalize_id(setting->id)) {
 801a61e:	f5a3 73aa 	sub.w	r3, r3, #340	; 0x154
 801a622:	2b37      	cmp	r3, #55	; 0x37
 801a624:	f200 8216 	bhi.w	801aa54 <is_setting_available+0x4c8>
 801a628:	a201      	add	r2, pc, #4	; (adr r2, 801a630 <is_setting_available+0xa4>)
 801a62a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a62e:	bf00      	nop
 801a630:	0801a94f 	.word	0x0801a94f
 801a634:	0801aa55 	.word	0x0801aa55
 801a638:	0801aa55 	.word	0x0801aa55
 801a63c:	0801aa55 	.word	0x0801aa55
 801a640:	0801aa55 	.word	0x0801aa55
 801a644:	0801aa55 	.word	0x0801aa55
 801a648:	0801aa55 	.word	0x0801aa55
 801a64c:	0801a909 	.word	0x0801a909
 801a650:	0801a909 	.word	0x0801a909
 801a654:	0801a909 	.word	0x0801a909
 801a658:	0801aa55 	.word	0x0801aa55
 801a65c:	0801aa55 	.word	0x0801aa55
 801a660:	0801aa55 	.word	0x0801aa55
 801a664:	0801aa55 	.word	0x0801aa55
 801a668:	0801aa55 	.word	0x0801aa55
 801a66c:	0801aa55 	.word	0x0801aa55
 801a670:	0801aa55 	.word	0x0801aa55
 801a674:	0801aa55 	.word	0x0801aa55
 801a678:	0801aa55 	.word	0x0801aa55
 801a67c:	0801aa55 	.word	0x0801aa55
 801a680:	0801aa55 	.word	0x0801aa55
 801a684:	0801aa55 	.word	0x0801aa55
 801a688:	0801aa55 	.word	0x0801aa55
 801a68c:	0801aa55 	.word	0x0801aa55
 801a690:	0801aa55 	.word	0x0801aa55
 801a694:	0801aa55 	.word	0x0801aa55
 801a698:	0801aa55 	.word	0x0801aa55
 801a69c:	0801aa55 	.word	0x0801aa55
 801a6a0:	0801aa55 	.word	0x0801aa55
 801a6a4:	0801aa55 	.word	0x0801aa55
 801a6a8:	0801aa55 	.word	0x0801aa55
 801a6ac:	0801aa55 	.word	0x0801aa55
 801a6b0:	0801aa55 	.word	0x0801aa55
 801a6b4:	0801aa55 	.word	0x0801aa55
 801a6b8:	0801aa55 	.word	0x0801aa55
 801a6bc:	0801aa55 	.word	0x0801aa55
 801a6c0:	0801aa55 	.word	0x0801aa55
 801a6c4:	0801aa55 	.word	0x0801aa55
 801a6c8:	0801aa55 	.word	0x0801aa55
 801a6cc:	0801aa55 	.word	0x0801aa55
 801a6d0:	0801aa55 	.word	0x0801aa55
 801a6d4:	0801aa55 	.word	0x0801aa55
 801a6d8:	0801aa55 	.word	0x0801aa55
 801a6dc:	0801aa55 	.word	0x0801aa55
 801a6e0:	0801aa55 	.word	0x0801aa55
 801a6e4:	0801aa55 	.word	0x0801aa55
 801a6e8:	0801aa55 	.word	0x0801aa55
 801a6ec:	0801aa55 	.word	0x0801aa55
 801a6f0:	0801aa55 	.word	0x0801aa55
 801a6f4:	0801aa55 	.word	0x0801aa55
 801a6f8:	0801aa55 	.word	0x0801aa55
 801a6fc:	0801aa55 	.word	0x0801aa55
 801a700:	0801a937 	.word	0x0801a937
 801a704:	0801a937 	.word	0x0801a937
 801a708:	0801a985 	.word	0x0801a985
 801a70c:	0801a8c5 	.word	0x0801a8c5
 801a710:	3b06      	subs	r3, #6
 801a712:	2b3b      	cmp	r3, #59	; 0x3b
 801a714:	f200 819e 	bhi.w	801aa54 <is_setting_available+0x4c8>
 801a718:	a201      	add	r2, pc, #4	; (adr r2, 801a720 <is_setting_available+0x194>)
 801a71a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a71e:	bf00      	nop
 801a720:	0801a845 	.word	0x0801a845
 801a724:	0801a857 	.word	0x0801a857
 801a728:	0801a817 	.word	0x0801a817
 801a72c:	0801a85d 	.word	0x0801a85d
 801a730:	0801aa55 	.word	0x0801aa55
 801a734:	0801aa55 	.word	0x0801aa55
 801a738:	0801aa55 	.word	0x0801aa55
 801a73c:	0801aa55 	.word	0x0801aa55
 801a740:	0801aa55 	.word	0x0801aa55
 801a744:	0801aa55 	.word	0x0801aa55
 801a748:	0801a893 	.word	0x0801a893
 801a74c:	0801aa55 	.word	0x0801aa55
 801a750:	0801aa55 	.word	0x0801aa55
 801a754:	0801a845 	.word	0x0801a845
 801a758:	0801aa55 	.word	0x0801aa55
 801a75c:	0801aa55 	.word	0x0801aa55
 801a760:	0801aa55 	.word	0x0801aa55
 801a764:	0801aa55 	.word	0x0801aa55
 801a768:	0801aa55 	.word	0x0801aa55
 801a76c:	0801aa55 	.word	0x0801aa55
 801a770:	0801aa55 	.word	0x0801aa55
 801a774:	0801aa55 	.word	0x0801aa55
 801a778:	0801aa55 	.word	0x0801aa55
 801a77c:	0801aa55 	.word	0x0801aa55
 801a780:	0801a8ef 	.word	0x0801a8ef
 801a784:	0801a8ef 	.word	0x0801a8ef
 801a788:	0801aa55 	.word	0x0801aa55
 801a78c:	0801a8ad 	.word	0x0801a8ad
 801a790:	0801a8ad 	.word	0x0801a8ad
 801a794:	0801a8ad 	.word	0x0801a8ad
 801a798:	0801a8ad 	.word	0x0801a8ad
 801a79c:	0801aa55 	.word	0x0801aa55
 801a7a0:	0801a8d7 	.word	0x0801a8d7
 801a7a4:	0801aa55 	.word	0x0801aa55
 801a7a8:	0801aa55 	.word	0x0801aa55
 801a7ac:	0801a937 	.word	0x0801a937
 801a7b0:	0801a937 	.word	0x0801a937
 801a7b4:	0801aa55 	.word	0x0801aa55
 801a7b8:	0801aa55 	.word	0x0801aa55
 801a7bc:	0801aa55 	.word	0x0801aa55
 801a7c0:	0801aa55 	.word	0x0801aa55
 801a7c4:	0801aa55 	.word	0x0801aa55
 801a7c8:	0801aa55 	.word	0x0801aa55
 801a7cc:	0801aa55 	.word	0x0801aa55
 801a7d0:	0801aa55 	.word	0x0801aa55
 801a7d4:	0801aa55 	.word	0x0801aa55
 801a7d8:	0801aa55 	.word	0x0801aa55
 801a7dc:	0801aa55 	.word	0x0801aa55
 801a7e0:	0801aa55 	.word	0x0801aa55
 801a7e4:	0801aa55 	.word	0x0801aa55
 801a7e8:	0801a937 	.word	0x0801a937
 801a7ec:	0801a937 	.word	0x0801a937
 801a7f0:	0801a937 	.word	0x0801a937
 801a7f4:	0801a937 	.word	0x0801a937
 801a7f8:	0801a937 	.word	0x0801a937
 801a7fc:	0801a937 	.word	0x0801a937
 801a800:	0801aa55 	.word	0x0801aa55
 801a804:	0801aa55 	.word	0x0801aa55
 801a808:	0801aa55 	.word	0x0801aa55
 801a80c:	0801a845 	.word	0x0801a845
 801a810:	2baa      	cmp	r3, #170	; 0xaa
 801a812:	d079      	beq.n	801a908 <is_setting_available+0x37c>
            break;
 801a814:	e11e      	b.n	801aa54 <is_setting_available+0x4c8>
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(false).mask != 0;
 801a816:	4b92      	ldr	r3, [pc, #584]	; (801aa60 <is_setting_available+0x4d4>)
 801a818:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801a81c:	2b00      	cmp	r3, #0
 801a81e:	d00a      	beq.n	801a836 <is_setting_available+0x2aa>
 801a820:	4b8f      	ldr	r3, [pc, #572]	; (801aa60 <is_setting_available+0x4d4>)
 801a822:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801a826:	2000      	movs	r0, #0
 801a828:	4798      	blx	r3
 801a82a:	4603      	mov	r3, r0
 801a82c:	b2db      	uxtb	r3, r3
 801a82e:	2b00      	cmp	r3, #0
 801a830:	d001      	beq.n	801a836 <is_setting_available+0x2aa>
 801a832:	2301      	movs	r3, #1
 801a834:	e000      	b.n	801a838 <is_setting_available+0x2ac>
 801a836:	2300      	movs	r3, #0
 801a838:	73fb      	strb	r3, [r7, #15]
 801a83a:	7bfb      	ldrb	r3, [r7, #15]
 801a83c:	f003 0301 	and.w	r3, r3, #1
 801a840:	73fb      	strb	r3, [r7, #15]
            break;
 801a842:	e108      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.probe.get_state != NULL;
 801a844:	4b86      	ldr	r3, [pc, #536]	; (801aa60 <is_setting_available+0x4d4>)
 801a846:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801a84a:	2b00      	cmp	r3, #0
 801a84c:	bf14      	ite	ne
 801a84e:	2301      	movne	r3, #1
 801a850:	2300      	moveq	r3, #0
 801a852:	73fb      	strb	r3, [r7, #15]
            break;
 801a854:	e0ff      	b.n	801aa56 <is_setting_available+0x4ca>
            available = false;
 801a856:	2300      	movs	r3, #0
 801a858:	73fb      	strb	r3, [r7, #15]
            break;
 801a85a:	e0fc      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.driver_cap.pwm_spindle && spindle_get_caps(false).laser;
 801a85c:	4b80      	ldr	r3, [pc, #512]	; (801aa60 <is_setting_available+0x4d4>)
 801a85e:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 801a862:	f003 0320 	and.w	r3, r3, #32
 801a866:	b2db      	uxtb	r3, r3
 801a868:	2b00      	cmp	r3, #0
 801a86a:	d00b      	beq.n	801a884 <is_setting_available+0x2f8>
 801a86c:	2000      	movs	r0, #0
 801a86e:	f001 ff95 	bl	801c79c <spindle_get_caps>
 801a872:	4603      	mov	r3, r0
 801a874:	b2db      	uxtb	r3, r3
 801a876:	f003 0308 	and.w	r3, r3, #8
 801a87a:	b2db      	uxtb	r3, r3
 801a87c:	2b00      	cmp	r3, #0
 801a87e:	d001      	beq.n	801a884 <is_setting_available+0x2f8>
 801a880:	2301      	movs	r3, #1
 801a882:	e000      	b.n	801a886 <is_setting_available+0x2fa>
 801a884:	2300      	movs	r3, #0
 801a886:	73fb      	strb	r3, [r7, #15]
 801a888:	7bfb      	ldrb	r3, [r7, #15]
 801a88a:	f003 0301 	and.w	r3, r3, #1
 801a88e:	73fb      	strb	r3, [r7, #15]
            break;
 801a890:	e0e1      	b.n	801aa56 <is_setting_available+0x4ca>
            available = spindle_get_caps(false).gpio_controlled;
 801a892:	2000      	movs	r0, #0
 801a894:	f001 ff82 	bl	801c79c <spindle_get_caps>
 801a898:	4603      	mov	r3, r0
 801a89a:	f3c3 2300 	ubfx	r3, r3, #8, #1
 801a89e:	b2db      	uxtb	r3, r3
 801a8a0:	2b00      	cmp	r3, #0
 801a8a2:	bf14      	ite	ne
 801a8a4:	2301      	movne	r3, #1
 801a8a6:	2300      	moveq	r3, #0
 801a8a8:	73fb      	strb	r3, [r7, #15]
            break;
 801a8aa:	e0d4      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.driver_cap.pwm_spindle;
 801a8ac:	4b6c      	ldr	r3, [pc, #432]	; (801aa60 <is_setting_available+0x4d4>)
 801a8ae:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 801a8b2:	f3c3 1340 	ubfx	r3, r3, #5, #1
 801a8b6:	b2db      	uxtb	r3, r3
 801a8b8:	2b00      	cmp	r3, #0
 801a8ba:	bf14      	ite	ne
 801a8bc:	2301      	movne	r3, #1
 801a8be:	2300      	moveq	r3, #0
 801a8c0:	73fb      	strb	r3, [r7, #15]
            break;
 801a8c2:	e0c8      	b.n	801aa56 <is_setting_available+0x4ca>
            available = spindle_get_count() > 1;
 801a8c4:	f002 f824 	bl	801c910 <spindle_get_count>
 801a8c8:	4603      	mov	r3, r0
 801a8ca:	2b01      	cmp	r3, #1
 801a8cc:	bf8c      	ite	hi
 801a8ce:	2301      	movhi	r3, #1
 801a8d0:	2300      	movls	r3, #0
 801a8d2:	73fb      	strb	r3, [r7, #15]
            break;
 801a8d4:	e0bf      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.driver_cap.spindle_encoder;
 801a8d6:	4b62      	ldr	r3, [pc, #392]	; (801aa60 <is_setting_available+0x4d4>)
 801a8d8:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801a8dc:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801a8e0:	b2db      	uxtb	r3, r3
 801a8e2:	2b00      	cmp	r3, #0
 801a8e4:	bf14      	ite	ne
 801a8e6:	2301      	movne	r3, #1
 801a8e8:	2300      	moveq	r3, #0
 801a8ea:	73fb      	strb	r3, [r7, #15]
            break;
 801a8ec:	e0b3      	b.n	801aa56 <is_setting_available+0x4ca>
            available = spindle_get_caps(false).variable;
 801a8ee:	2000      	movs	r0, #0
 801a8f0:	f001 ff54 	bl	801c79c <spindle_get_caps>
 801a8f4:	4603      	mov	r3, r0
 801a8f6:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801a8fa:	b2db      	uxtb	r3, r3
 801a8fc:	2b00      	cmp	r3, #0
 801a8fe:	bf14      	ite	ne
 801a900:	2301      	movne	r3, #1
 801a902:	2300      	moveq	r3, #0
 801a904:	73fb      	strb	r3, [r7, #15]
            break;
 801a906:	e0a6      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(true).mask != 0;
 801a908:	4b55      	ldr	r3, [pc, #340]	; (801aa60 <is_setting_available+0x4d4>)
 801a90a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801a90e:	2b00      	cmp	r3, #0
 801a910:	d00a      	beq.n	801a928 <is_setting_available+0x39c>
 801a912:	4b53      	ldr	r3, [pc, #332]	; (801aa60 <is_setting_available+0x4d4>)
 801a914:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801a918:	2001      	movs	r0, #1
 801a91a:	4798      	blx	r3
 801a91c:	4603      	mov	r3, r0
 801a91e:	b2db      	uxtb	r3, r3
 801a920:	2b00      	cmp	r3, #0
 801a922:	d001      	beq.n	801a928 <is_setting_available+0x39c>
 801a924:	2301      	movs	r3, #1
 801a926:	e000      	b.n	801a92a <is_setting_available+0x39e>
 801a928:	2300      	movs	r3, #0
 801a92a:	73fb      	strb	r3, [r7, #15]
 801a92c:	7bfb      	ldrb	r3, [r7, #15]
 801a92e:	f003 0301 	and.w	r3, r3, #1
 801a932:	73fb      	strb	r3, [r7, #15]
            break;
 801a934:	e08f      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.signals_cap.safety_door_ajar;
 801a936:	4b4a      	ldr	r3, [pc, #296]	; (801aa60 <is_setting_available+0x4d4>)
 801a938:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 801a93c:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801a940:	b2db      	uxtb	r3, r3
 801a942:	2b00      	cmp	r3, #0
 801a944:	bf14      	ite	ne
 801a946:	2301      	movne	r3, #1
 801a948:	2300      	moveq	r3, #0
 801a94a:	73fb      	strb	r3, [r7, #15]
            break;
 801a94c:	e083      	b.n	801aa56 <is_setting_available+0x4ca>
            available = spindle_get_caps(true).at_speed || hal.driver_cap.spindle_encoder;
 801a94e:	2001      	movs	r0, #1
 801a950:	f001 ff24 	bl	801c79c <spindle_get_caps>
 801a954:	4603      	mov	r3, r0
 801a956:	b2db      	uxtb	r3, r3
 801a958:	f003 0304 	and.w	r3, r3, #4
 801a95c:	b2db      	uxtb	r3, r3
 801a95e:	2b00      	cmp	r3, #0
 801a960:	d107      	bne.n	801a972 <is_setting_available+0x3e6>
 801a962:	4b3f      	ldr	r3, [pc, #252]	; (801aa60 <is_setting_available+0x4d4>)
 801a964:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801a968:	f003 0301 	and.w	r3, r3, #1
 801a96c:	b2db      	uxtb	r3, r3
 801a96e:	2b00      	cmp	r3, #0
 801a970:	d001      	beq.n	801a976 <is_setting_available+0x3ea>
 801a972:	2301      	movs	r3, #1
 801a974:	e000      	b.n	801a978 <is_setting_available+0x3ec>
 801a976:	2300      	movs	r3, #0
 801a978:	73fb      	strb	r3, [r7, #15]
 801a97a:	7bfb      	ldrb	r3, [r7, #15]
 801a97c:	f003 0301 	and.w	r3, r3, #1
 801a980:	73fb      	strb	r3, [r7, #15]
            break;
 801a982:	e068      	b.n	801aa56 <is_setting_available+0x4ca>
            available = !hal.signals_cap.safety_door_ajar && spindle_get_caps(true).at_speed;
 801a984:	4b36      	ldr	r3, [pc, #216]	; (801aa60 <is_setting_available+0x4d4>)
 801a986:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 801a98a:	f003 0308 	and.w	r3, r3, #8
 801a98e:	b2db      	uxtb	r3, r3
 801a990:	2b00      	cmp	r3, #0
 801a992:	d10b      	bne.n	801a9ac <is_setting_available+0x420>
 801a994:	2001      	movs	r0, #1
 801a996:	f001 ff01 	bl	801c79c <spindle_get_caps>
 801a99a:	4603      	mov	r3, r0
 801a99c:	b2db      	uxtb	r3, r3
 801a99e:	f003 0304 	and.w	r3, r3, #4
 801a9a2:	b2db      	uxtb	r3, r3
 801a9a4:	2b00      	cmp	r3, #0
 801a9a6:	d001      	beq.n	801a9ac <is_setting_available+0x420>
 801a9a8:	2301      	movs	r3, #1
 801a9aa:	e000      	b.n	801a9ae <is_setting_available+0x422>
 801a9ac:	2300      	movs	r3, #0
 801a9ae:	73fb      	strb	r3, [r7, #15]
 801a9b0:	7bfb      	ldrb	r3, [r7, #15]
 801a9b2:	f003 0301 	and.w	r3, r3, #1
 801a9b6:	73fb      	strb	r3, [r7, #15]
            break;
 801a9b8:	e04d      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.get_elapsed_ticks != NULL;
 801a9ba:	4b29      	ldr	r3, [pc, #164]	; (801aa60 <is_setting_available+0x4d4>)
 801a9bc:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801a9c0:	2b00      	cmp	r3, #0
 801a9c2:	bf14      	ite	ne
 801a9c4:	2301      	movne	r3, #1
 801a9c6:	2300      	moveq	r3, #0
 801a9c8:	73fb      	strb	r3, [r7, #15]
            break;
 801a9ca:	e044      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.rtc.set_datetime != NULL;
 801a9cc:	4b24      	ldr	r3, [pc, #144]	; (801aa60 <is_setting_available+0x4d4>)
 801a9ce:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 801a9d2:	2b00      	cmp	r3, #0
 801a9d4:	bf14      	ite	ne
 801a9d6:	2301      	movne	r3, #1
 801a9d8:	2300      	moveq	r3, #0
 801a9da:	73fb      	strb	r3, [r7, #15]
            break;
 801a9dc:	e03b      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.signals_cap.e_stop;
 801a9de:	4b20      	ldr	r3, [pc, #128]	; (801aa60 <is_setting_available+0x4d4>)
 801a9e0:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 801a9e4:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801a9e8:	b2db      	uxtb	r3, r3
 801a9ea:	2b00      	cmp	r3, #0
 801a9ec:	bf14      	ite	ne
 801a9ee:	2301      	movne	r3, #1
 801a9f0:	2300      	moveq	r3, #0
 801a9f2:	73fb      	strb	r3, [r7, #15]
            break;
 801a9f4:	e02f      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.driver_cap.spindle_encoder && spindle_get_count() > 1;
 801a9f6:	4b1a      	ldr	r3, [pc, #104]	; (801aa60 <is_setting_available+0x4d4>)
 801a9f8:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801a9fc:	f003 0301 	and.w	r3, r3, #1
 801aa00:	b2db      	uxtb	r3, r3
 801aa02:	2b00      	cmp	r3, #0
 801aa04:	d006      	beq.n	801aa14 <is_setting_available+0x488>
 801aa06:	f001 ff83 	bl	801c910 <spindle_get_count>
 801aa0a:	4603      	mov	r3, r0
 801aa0c:	2b01      	cmp	r3, #1
 801aa0e:	d901      	bls.n	801aa14 <is_setting_available+0x488>
 801aa10:	2301      	movs	r3, #1
 801aa12:	e000      	b.n	801aa16 <is_setting_available+0x48a>
 801aa14:	2300      	movs	r3, #0
 801aa16:	73fb      	strb	r3, [r7, #15]
 801aa18:	7bfb      	ldrb	r3, [r7, #15]
 801aa1a:	f003 0301 	and.w	r3, r3, #1
 801aa1e:	73fb      	strb	r3, [r7, #15]
            break;
 801aa20:	e019      	b.n	801aa56 <is_setting_available+0x4ca>
            available = hal.driver_cap.sd_card || hal.driver_cap.littlefs;
 801aa22:	4b0f      	ldr	r3, [pc, #60]	; (801aa60 <is_setting_available+0x4d4>)
 801aa24:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801aa28:	f003 0304 	and.w	r3, r3, #4
 801aa2c:	b2db      	uxtb	r3, r3
 801aa2e:	2b00      	cmp	r3, #0
 801aa30:	d107      	bne.n	801aa42 <is_setting_available+0x4b6>
 801aa32:	4b0b      	ldr	r3, [pc, #44]	; (801aa60 <is_setting_available+0x4d4>)
 801aa34:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801aa38:	f003 0308 	and.w	r3, r3, #8
 801aa3c:	b2db      	uxtb	r3, r3
 801aa3e:	2b00      	cmp	r3, #0
 801aa40:	d001      	beq.n	801aa46 <is_setting_available+0x4ba>
 801aa42:	2301      	movs	r3, #1
 801aa44:	e000      	b.n	801aa48 <is_setting_available+0x4bc>
 801aa46:	2300      	movs	r3, #0
 801aa48:	73fb      	strb	r3, [r7, #15]
 801aa4a:	7bfb      	ldrb	r3, [r7, #15]
 801aa4c:	f003 0301 	and.w	r3, r3, #1
 801aa50:	73fb      	strb	r3, [r7, #15]
            break;
 801aa52:	e000      	b.n	801aa56 <is_setting_available+0x4ca>
            break;
 801aa54:	bf00      	nop
    }

    return available;
 801aa56:	7bfb      	ldrb	r3, [r7, #15]
}
 801aa58:	4618      	mov	r0, r3
 801aa5a:	3710      	adds	r7, #16
 801aa5c:	46bd      	mov	sp, r7
 801aa5e:	bd80      	pop	{r7, pc}
 801aa60:	20000ed0 	.word	0x20000ed0

0801aa64 <settings_write_build_info>:

// Write build info to persistent storage
void settings_write_build_info (char *line)
{
 801aa64:	b590      	push	{r4, r7, lr}
 801aa66:	b083      	sub	sp, #12
 801aa68:	af00      	add	r7, sp, #0
 801aa6a:	6078      	str	r0, [r7, #4]
    if(hal.nvs.type != NVS_None)
 801aa6c:	4b08      	ldr	r3, [pc, #32]	; (801aa90 <settings_write_build_info+0x2c>)
 801aa6e:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801aa72:	2b00      	cmp	r3, #0
 801aa74:	d008      	beq.n	801aa88 <settings_write_build_info+0x24>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_BUILD_INFO, (uint8_t *)line, sizeof(stored_line_t), true);
 801aa76:	4b06      	ldr	r3, [pc, #24]	; (801aa90 <settings_write_build_info+0x2c>)
 801aa78:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801aa7c:	2301      	movs	r3, #1
 801aa7e:	2246      	movs	r2, #70	; 0x46
 801aa80:	6879      	ldr	r1, [r7, #4]
 801aa82:	f240 30ae 	movw	r0, #942	; 0x3ae
 801aa86:	47a0      	blx	r4
}
 801aa88:	bf00      	nop
 801aa8a:	370c      	adds	r7, #12
 801aa8c:	46bd      	mov	sp, r7
 801aa8e:	bd90      	pop	{r4, r7, pc}
 801aa90:	20000ed0 	.word	0x20000ed0

0801aa94 <settings_read_build_info>:

// Read build info from persistent storage.
bool settings_read_build_info(char *line)
{
 801aa94:	b590      	push	{r4, r7, lr}
 801aa96:	b083      	sub	sp, #12
 801aa98:	af00      	add	r7, sp, #0
 801aa9a:	6078      	str	r0, [r7, #4]
    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)line, NVS_ADDR_BUILD_INFO, sizeof(stored_line_t), true) == NVS_TransferResult_OK)) {
 801aa9c:	4b0e      	ldr	r3, [pc, #56]	; (801aad8 <settings_read_build_info+0x44>)
 801aa9e:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801aaa2:	2b00      	cmp	r3, #0
 801aaa4:	d00b      	beq.n	801aabe <settings_read_build_info+0x2a>
 801aaa6:	4b0c      	ldr	r3, [pc, #48]	; (801aad8 <settings_read_build_info+0x44>)
 801aaa8:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 801aaac:	2301      	movs	r3, #1
 801aaae:	2246      	movs	r2, #70	; 0x46
 801aab0:	f240 31ae 	movw	r1, #942	; 0x3ae
 801aab4:	6878      	ldr	r0, [r7, #4]
 801aab6:	47a0      	blx	r4
 801aab8:	4603      	mov	r3, r0
 801aaba:	2b02      	cmp	r3, #2
 801aabc:	d007      	beq.n	801aace <settings_read_build_info+0x3a>
        // Reset line with default value
        line[0] = 0; // Empty line
 801aabe:	687b      	ldr	r3, [r7, #4]
 801aac0:	2200      	movs	r2, #0
 801aac2:	701a      	strb	r2, [r3, #0]
        settings_write_build_info(line);
 801aac4:	6878      	ldr	r0, [r7, #4]
 801aac6:	f7ff ffcd 	bl	801aa64 <settings_write_build_info>
        return false;
 801aaca:	2300      	movs	r3, #0
 801aacc:	e000      	b.n	801aad0 <settings_read_build_info+0x3c>
    }
    return true;
 801aace:	2301      	movs	r3, #1
}
 801aad0:	4618      	mov	r0, r3
 801aad2:	370c      	adds	r7, #12
 801aad4:	46bd      	mov	sp, r7
 801aad6:	bd90      	pop	{r4, r7, pc}
 801aad8:	20000ed0 	.word	0x20000ed0

0801aadc <settings_write_startup_line>:

// Write startup line to persistent storage
void settings_write_startup_line (uint8_t idx, char *line)
{
 801aadc:	b590      	push	{r4, r7, lr}
 801aade:	b083      	sub	sp, #12
 801aae0:	af00      	add	r7, sp, #0
 801aae2:	4603      	mov	r3, r0
 801aae4:	6039      	str	r1, [r7, #0]
 801aae6:	71fb      	strb	r3, [r7, #7]
    assert(idx < N_STARTUP_LINE);
 801aae8:	79fb      	ldrb	r3, [r7, #7]
 801aaea:	2b01      	cmp	r3, #1
 801aaec:	d906      	bls.n	801aafc <settings_write_startup_line+0x20>
 801aaee:	4b0f      	ldr	r3, [pc, #60]	; (801ab2c <settings_write_startup_line+0x50>)
 801aaf0:	4a0f      	ldr	r2, [pc, #60]	; (801ab30 <settings_write_startup_line+0x54>)
 801aaf2:	f240 71e3 	movw	r1, #2019	; 0x7e3
 801aaf6:	480f      	ldr	r0, [pc, #60]	; (801ab34 <settings_write_startup_line+0x58>)
 801aaf8:	f008 fc8a 	bl	8023410 <__assert_func>

#ifdef FORCE_BUFFER_SYNC_DURING_NVS_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing.
#endif

    if(hal.nvs.type != NVS_None)
 801aafc:	4b0e      	ldr	r3, [pc, #56]	; (801ab38 <settings_write_startup_line+0x5c>)
 801aafe:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ab02:	2b00      	cmp	r3, #0
 801ab04:	d00e      	beq.n	801ab24 <settings_write_startup_line+0x48>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES), (uint8_t *)line, sizeof(stored_line_t), true);
 801ab06:	4b0c      	ldr	r3, [pc, #48]	; (801ab38 <settings_write_startup_line+0x5c>)
 801ab08:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801ab0c:	79fa      	ldrb	r2, [r7, #7]
 801ab0e:	4613      	mov	r3, r2
 801ab10:	00db      	lsls	r3, r3, #3
 801ab12:	4413      	add	r3, r2
 801ab14:	00db      	lsls	r3, r3, #3
 801ab16:	1a9b      	subs	r3, r3, r2
 801ab18:	f203 301f 	addw	r0, r3, #799	; 0x31f
 801ab1c:	2301      	movs	r3, #1
 801ab1e:	2246      	movs	r2, #70	; 0x46
 801ab20:	6839      	ldr	r1, [r7, #0]
 801ab22:	47a0      	blx	r4
}
 801ab24:	bf00      	nop
 801ab26:	370c      	adds	r7, #12
 801ab28:	46bd      	mov	sp, r7
 801ab2a:	bd90      	pop	{r4, r7, pc}
 801ab2c:	0802ea0c 	.word	0x0802ea0c
 801ab30:	08032b0c 	.word	0x08032b0c
 801ab34:	0802ea24 	.word	0x0802ea24
 801ab38:	20000ed0 	.word	0x20000ed0

0801ab3c <settings_read_startup_line>:

// Read startup line to persistent storage.
bool settings_read_startup_line (uint8_t idx, char *line)
{
 801ab3c:	b590      	push	{r4, r7, lr}
 801ab3e:	b083      	sub	sp, #12
 801ab40:	af00      	add	r7, sp, #0
 801ab42:	4603      	mov	r3, r0
 801ab44:	6039      	str	r1, [r7, #0]
 801ab46:	71fb      	strb	r3, [r7, #7]
    assert(idx < N_STARTUP_LINE);
 801ab48:	79fb      	ldrb	r3, [r7, #7]
 801ab4a:	2b01      	cmp	r3, #1
 801ab4c:	d906      	bls.n	801ab5c <settings_read_startup_line+0x20>
 801ab4e:	4b16      	ldr	r3, [pc, #88]	; (801aba8 <settings_read_startup_line+0x6c>)
 801ab50:	4a16      	ldr	r2, [pc, #88]	; (801abac <settings_read_startup_line+0x70>)
 801ab52:	f44f 61fe 	mov.w	r1, #2032	; 0x7f0
 801ab56:	4816      	ldr	r0, [pc, #88]	; (801abb0 <settings_read_startup_line+0x74>)
 801ab58:	f008 fc5a 	bl	8023410 <__assert_func>

    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)line, NVS_ADDR_STARTUP_BLOCK + idx * (sizeof(stored_line_t) + NVS_CRC_BYTES), sizeof(stored_line_t), true) == NVS_TransferResult_OK)) {
 801ab5c:	4b15      	ldr	r3, [pc, #84]	; (801abb4 <settings_read_startup_line+0x78>)
 801ab5e:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ab62:	2b00      	cmp	r3, #0
 801ab64:	d011      	beq.n	801ab8a <settings_read_startup_line+0x4e>
 801ab66:	4b13      	ldr	r3, [pc, #76]	; (801abb4 <settings_read_startup_line+0x78>)
 801ab68:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 801ab6c:	79fa      	ldrb	r2, [r7, #7]
 801ab6e:	4613      	mov	r3, r2
 801ab70:	00db      	lsls	r3, r3, #3
 801ab72:	4413      	add	r3, r2
 801ab74:	00db      	lsls	r3, r3, #3
 801ab76:	1a9b      	subs	r3, r3, r2
 801ab78:	f203 311f 	addw	r1, r3, #799	; 0x31f
 801ab7c:	2301      	movs	r3, #1
 801ab7e:	2246      	movs	r2, #70	; 0x46
 801ab80:	6838      	ldr	r0, [r7, #0]
 801ab82:	47a0      	blx	r4
 801ab84:	4603      	mov	r3, r0
 801ab86:	2b02      	cmp	r3, #2
 801ab88:	d009      	beq.n	801ab9e <settings_read_startup_line+0x62>
        // Reset line with default value
        *line = '\0'; // Empty line
 801ab8a:	683b      	ldr	r3, [r7, #0]
 801ab8c:	2200      	movs	r2, #0
 801ab8e:	701a      	strb	r2, [r3, #0]
        settings_write_startup_line(idx, line);
 801ab90:	79fb      	ldrb	r3, [r7, #7]
 801ab92:	6839      	ldr	r1, [r7, #0]
 801ab94:	4618      	mov	r0, r3
 801ab96:	f7ff ffa1 	bl	801aadc <settings_write_startup_line>
        return false;
 801ab9a:	2300      	movs	r3, #0
 801ab9c:	e000      	b.n	801aba0 <settings_read_startup_line+0x64>
    }
    return true;
 801ab9e:	2301      	movs	r3, #1
}
 801aba0:	4618      	mov	r0, r3
 801aba2:	370c      	adds	r7, #12
 801aba4:	46bd      	mov	sp, r7
 801aba6:	bd90      	pop	{r4, r7, pc}
 801aba8:	0802ea0c 	.word	0x0802ea0c
 801abac:	08032b28 	.word	0x08032b28
 801abb0:	0802ea24 	.word	0x0802ea24
 801abb4:	20000ed0 	.word	0x20000ed0

0801abb8 <settings_write_coord_data>:

// Write selected coordinate data to persistent storage.
void settings_write_coord_data (coord_system_id_t id, float (*coord_data)[N_AXIS])
{
 801abb8:	b590      	push	{r4, r7, lr}
 801abba:	b083      	sub	sp, #12
 801abbc:	af00      	add	r7, sp, #0
 801abbe:	4603      	mov	r3, r0
 801abc0:	6039      	str	r1, [r7, #0]
 801abc2:	71fb      	strb	r3, [r7, #7]
    assert(id <= N_CoordinateSystems);
 801abc4:	79fb      	ldrb	r3, [r7, #7]
 801abc6:	2b0c      	cmp	r3, #12
 801abc8:	d906      	bls.n	801abd8 <settings_write_coord_data+0x20>
 801abca:	4b0f      	ldr	r3, [pc, #60]	; (801ac08 <settings_write_coord_data+0x50>)
 801abcc:	4a0f      	ldr	r2, [pc, #60]	; (801ac0c <settings_write_coord_data+0x54>)
 801abce:	f240 71fe 	movw	r1, #2046	; 0x7fe
 801abd2:	480f      	ldr	r0, [pc, #60]	; (801ac10 <settings_write_coord_data+0x58>)
 801abd4:	f008 fc1c 	bl	8023410 <__assert_func>

#ifdef FORCE_BUFFER_SYNC_DURING_NVS_WRITE
    protocol_buffer_synchronize();
#endif

    if(hal.nvs.type != NVS_None)
 801abd8:	4b0e      	ldr	r3, [pc, #56]	; (801ac14 <settings_write_coord_data+0x5c>)
 801abda:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801abde:	2b00      	cmp	r3, #0
 801abe0:	d00e      	beq.n	801ac00 <settings_write_coord_data+0x48>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_PARAMETERS + id * (sizeof(coord_data_t) + NVS_CRC_BYTES), (uint8_t *)coord_data, sizeof(coord_data_t), true);
 801abe2:	4b0c      	ldr	r3, [pc, #48]	; (801ac14 <settings_write_coord_data+0x5c>)
 801abe4:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801abe8:	79fa      	ldrb	r2, [r7, #7]
 801abea:	4613      	mov	r3, r2
 801abec:	005b      	lsls	r3, r3, #1
 801abee:	4413      	add	r3, r2
 801abf0:	009b      	lsls	r3, r3, #2
 801abf2:	4413      	add	r3, r2
 801abf4:	f503 7000 	add.w	r0, r3, #512	; 0x200
 801abf8:	2301      	movs	r3, #1
 801abfa:	220c      	movs	r2, #12
 801abfc:	6839      	ldr	r1, [r7, #0]
 801abfe:	47a0      	blx	r4
}
 801ac00:	bf00      	nop
 801ac02:	370c      	adds	r7, #12
 801ac04:	46bd      	mov	sp, r7
 801ac06:	bd90      	pop	{r4, r7, pc}
 801ac08:	0802ea38 	.word	0x0802ea38
 801ac0c:	08032b44 	.word	0x08032b44
 801ac10:	0802ea24 	.word	0x0802ea24
 801ac14:	20000ed0 	.word	0x20000ed0

0801ac18 <settings_read_coord_data>:

// Read selected coordinate data from persistent storage.
bool settings_read_coord_data (coord_system_id_t id, float (*coord_data)[N_AXIS])
{
 801ac18:	b590      	push	{r4, r7, lr}
 801ac1a:	b083      	sub	sp, #12
 801ac1c:	af00      	add	r7, sp, #0
 801ac1e:	4603      	mov	r3, r0
 801ac20:	6039      	str	r1, [r7, #0]
 801ac22:	71fb      	strb	r3, [r7, #7]
    assert(id <= N_CoordinateSystems);
 801ac24:	79fb      	ldrb	r3, [r7, #7]
 801ac26:	2b0c      	cmp	r3, #12
 801ac28:	d906      	bls.n	801ac38 <settings_read_coord_data+0x20>
 801ac2a:	4b17      	ldr	r3, [pc, #92]	; (801ac88 <settings_read_coord_data+0x70>)
 801ac2c:	4a17      	ldr	r2, [pc, #92]	; (801ac8c <settings_read_coord_data+0x74>)
 801ac2e:	f640 010b 	movw	r1, #2059	; 0x80b
 801ac32:	4817      	ldr	r0, [pc, #92]	; (801ac90 <settings_read_coord_data+0x78>)
 801ac34:	f008 fbec 	bl	8023410 <__assert_func>

    if (!(hal.nvs.type != NVS_None && hal.nvs.memcpy_from_nvs((uint8_t *)coord_data, NVS_ADDR_PARAMETERS + id * (sizeof(coord_data_t) + NVS_CRC_BYTES), sizeof(coord_data_t), true) == NVS_TransferResult_OK)) {
 801ac38:	4b16      	ldr	r3, [pc, #88]	; (801ac94 <settings_read_coord_data+0x7c>)
 801ac3a:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ac3e:	2b00      	cmp	r3, #0
 801ac40:	d011      	beq.n	801ac66 <settings_read_coord_data+0x4e>
 801ac42:	4b14      	ldr	r3, [pc, #80]	; (801ac94 <settings_read_coord_data+0x7c>)
 801ac44:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 801ac48:	79fa      	ldrb	r2, [r7, #7]
 801ac4a:	4613      	mov	r3, r2
 801ac4c:	005b      	lsls	r3, r3, #1
 801ac4e:	4413      	add	r3, r2
 801ac50:	009b      	lsls	r3, r3, #2
 801ac52:	4413      	add	r3, r2
 801ac54:	f503 7100 	add.w	r1, r3, #512	; 0x200
 801ac58:	2301      	movs	r3, #1
 801ac5a:	220c      	movs	r2, #12
 801ac5c:	6838      	ldr	r0, [r7, #0]
 801ac5e:	47a0      	blx	r4
 801ac60:	4603      	mov	r3, r0
 801ac62:	2b02      	cmp	r3, #2
 801ac64:	d00b      	beq.n	801ac7e <settings_read_coord_data+0x66>
        // Reset with default zero vector
        memset(coord_data, 0, sizeof(coord_data_t));
 801ac66:	220c      	movs	r2, #12
 801ac68:	2100      	movs	r1, #0
 801ac6a:	6838      	ldr	r0, [r7, #0]
 801ac6c:	f008 ffd3 	bl	8023c16 <memset>
        settings_write_coord_data(id, coord_data);
 801ac70:	79fb      	ldrb	r3, [r7, #7]
 801ac72:	6839      	ldr	r1, [r7, #0]
 801ac74:	4618      	mov	r0, r3
 801ac76:	f7ff ff9f 	bl	801abb8 <settings_write_coord_data>
        return false;
 801ac7a:	2300      	movs	r3, #0
 801ac7c:	e000      	b.n	801ac80 <settings_read_coord_data+0x68>
    }
    return true;
 801ac7e:	2301      	movs	r3, #1
}
 801ac80:	4618      	mov	r0, r3
 801ac82:	370c      	adds	r7, #12
 801ac84:	46bd      	mov	sp, r7
 801ac86:	bd90      	pop	{r4, r7, pc}
 801ac88:	0802ea38 	.word	0x0802ea38
 801ac8c:	08032b60 	.word	0x08032b60
 801ac90:	0802ea24 	.word	0x0802ea24
 801ac94:	20000ed0 	.word	0x20000ed0

0801ac98 <read_global_settings>:
#endif // N_TOOLS

// Read global settings from persistent storage.
// Checks version-byte of non-volatile storage and global settings copy.
bool read_global_settings ()
{
 801ac98:	b590      	push	{r4, r7, lr}
 801ac9a:	b083      	sub	sp, #12
 801ac9c:	af00      	add	r7, sp, #0
    bool ok = hal.nvs.type != NVS_None && SETTINGS_VERSION == hal.nvs.get_byte(0) && hal.nvs.memcpy_from_nvs((uint8_t *)&settings, NVS_ADDR_GLOBAL, sizeof(settings_t), true) == NVS_TransferResult_OK;
 801ac9e:	4b2d      	ldr	r3, [pc, #180]	; (801ad54 <read_global_settings+0xbc>)
 801aca0:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801aca4:	2b00      	cmp	r3, #0
 801aca6:	d015      	beq.n	801acd4 <read_global_settings+0x3c>
 801aca8:	4b2a      	ldr	r3, [pc, #168]	; (801ad54 <read_global_settings+0xbc>)
 801acaa:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 801acae:	2000      	movs	r0, #0
 801acb0:	4798      	blx	r3
 801acb2:	4603      	mov	r3, r0
 801acb4:	2b16      	cmp	r3, #22
 801acb6:	d10d      	bne.n	801acd4 <read_global_settings+0x3c>
 801acb8:	4b26      	ldr	r3, [pc, #152]	; (801ad54 <read_global_settings+0xbc>)
 801acba:	f8d3 4164 	ldr.w	r4, [r3, #356]	; 0x164
 801acbe:	2301      	movs	r3, #1
 801acc0:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 801acc4:	2101      	movs	r1, #1
 801acc6:	4824      	ldr	r0, [pc, #144]	; (801ad58 <read_global_settings+0xc0>)
 801acc8:	47a0      	blx	r4
 801acca:	4603      	mov	r3, r0
 801accc:	2b02      	cmp	r3, #2
 801acce:	d101      	bne.n	801acd4 <read_global_settings+0x3c>
 801acd0:	2301      	movs	r3, #1
 801acd2:	e000      	b.n	801acd6 <read_global_settings+0x3e>
 801acd4:	2300      	movs	r3, #0
 801acd6:	71fb      	strb	r3, [r7, #7]
 801acd8:	79fb      	ldrb	r3, [r7, #7]
 801acda:	f003 0301 	and.w	r3, r3, #1
 801acde:	71fb      	strb	r3, [r7, #7]

    // Sanity check of settings, board map could have been changed...
#if LATHE_UVW_OPTION
    settings.mode = Mode_Lathe;
#else
    if(settings.mode == Mode_Laser && !spindle_get_caps(false).laser)
 801ace0:	4b1d      	ldr	r3, [pc, #116]	; (801ad58 <read_global_settings+0xc0>)
 801ace2:	7e1b      	ldrb	r3, [r3, #24]
 801ace4:	2b01      	cmp	r3, #1
 801ace6:	d10c      	bne.n	801ad02 <read_global_settings+0x6a>
 801ace8:	2000      	movs	r0, #0
 801acea:	f001 fd57 	bl	801c79c <spindle_get_caps>
 801acee:	4603      	mov	r3, r0
 801acf0:	b2db      	uxtb	r3, r3
 801acf2:	f003 0308 	and.w	r3, r3, #8
 801acf6:	b2db      	uxtb	r3, r3
 801acf8:	2b00      	cmp	r3, #0
 801acfa:	d102      	bne.n	801ad02 <read_global_settings+0x6a>
        settings.mode = Mode_Standard;
 801acfc:	4b16      	ldr	r3, [pc, #88]	; (801ad58 <read_global_settings+0xc0>)
 801acfe:	2200      	movs	r2, #0
 801ad00:	761a      	strb	r2, [r3, #24]
#endif

    if(settings.planner_buffer_blocks < 30 || settings.planner_buffer_blocks > 1000)
 801ad02:	4b15      	ldr	r3, [pc, #84]	; (801ad58 <read_global_settings+0xc0>)
 801ad04:	8adb      	ldrh	r3, [r3, #22]
 801ad06:	2b1d      	cmp	r3, #29
 801ad08:	d904      	bls.n	801ad14 <read_global_settings+0x7c>
 801ad0a:	4b13      	ldr	r3, [pc, #76]	; (801ad58 <read_global_settings+0xc0>)
 801ad0c:	8adb      	ldrh	r3, [r3, #22]
 801ad0e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 801ad12:	d902      	bls.n	801ad1a <read_global_settings+0x82>
        settings.planner_buffer_blocks = 35;
 801ad14:	4b10      	ldr	r3, [pc, #64]	; (801ad58 <read_global_settings+0xc0>)
 801ad16:	2223      	movs	r2, #35	; 0x23
 801ad18:	82da      	strh	r2, [r3, #22]

    if(!hal.driver_cap.spindle_encoder)
 801ad1a:	4b0e      	ldr	r3, [pc, #56]	; (801ad54 <read_global_settings+0xbc>)
 801ad1c:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801ad20:	f003 0301 	and.w	r3, r3, #1
 801ad24:	b2db      	uxtb	r3, r3
 801ad26:	2b00      	cmp	r3, #0
 801ad28:	d103      	bne.n	801ad32 <read_global_settings+0x9a>
        settings.spindle.ppr = 0;
 801ad2a:	4b0b      	ldr	r3, [pc, #44]	; (801ad58 <read_global_settings+0xc0>)
 801ad2c:	2200      	movs	r2, #0
 801ad2e:	f8a3 20e4 	strh.w	r2, [r3, #228]	; 0xe4
#if COMPATIBILITY_LEVEL > 2
    if(settings.steppers.enable_invert.mask)
        settings.steppers.enable_invert.mask = AXES_BITMASK;
#endif

    return ok && settings.version == SETTINGS_VERSION;
 801ad32:	79fb      	ldrb	r3, [r7, #7]
 801ad34:	2b00      	cmp	r3, #0
 801ad36:	d005      	beq.n	801ad44 <read_global_settings+0xac>
 801ad38:	4b07      	ldr	r3, [pc, #28]	; (801ad58 <read_global_settings+0xc0>)
 801ad3a:	681b      	ldr	r3, [r3, #0]
 801ad3c:	2b16      	cmp	r3, #22
 801ad3e:	d101      	bne.n	801ad44 <read_global_settings+0xac>
 801ad40:	2301      	movs	r3, #1
 801ad42:	e000      	b.n	801ad46 <read_global_settings+0xae>
 801ad44:	2300      	movs	r3, #0
 801ad46:	f003 0301 	and.w	r3, r3, #1
 801ad4a:	b2db      	uxtb	r3, r3
}
 801ad4c:	4618      	mov	r0, r3
 801ad4e:	370c      	adds	r7, #12
 801ad50:	46bd      	mov	sp, r7
 801ad52:	bd90      	pop	{r4, r7, pc}
 801ad54:	20000ed0 	.word	0x20000ed0
 801ad58:	2000147c 	.word	0x2000147c

0801ad5c <settings_write_global>:


// Write global settings to persistent storage
void settings_write_global (void)
{
 801ad5c:	b598      	push	{r3, r4, r7, lr}
 801ad5e:	af00      	add	r7, sp, #0
    if(override_backup.valid)
 801ad60:	4b0e      	ldr	r3, [pc, #56]	; (801ad9c <settings_write_global+0x40>)
 801ad62:	781b      	ldrb	r3, [r3, #0]
 801ad64:	2b00      	cmp	r3, #0
 801ad66:	d001      	beq.n	801ad6c <settings_write_global+0x10>
        restore_override_backup();
 801ad68:	f7fd ff5c 	bl	8018c24 <restore_override_backup>

    settings.flags.compatibility_level = COMPATIBILITY_LEVEL;
 801ad6c:	4a0c      	ldr	r2, [pc, #48]	; (801ada0 <settings_write_global+0x44>)
 801ad6e:	f892 30ff 	ldrb.w	r3, [r2, #255]	; 0xff
 801ad72:	f36f 0385 	bfc	r3, #2, #4
 801ad76:	f882 30ff 	strb.w	r3, [r2, #255]	; 0xff

    if(hal.nvs.type != NVS_None)
 801ad7a:	4b0a      	ldr	r3, [pc, #40]	; (801ada4 <settings_write_global+0x48>)
 801ad7c:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801ad80:	2b00      	cmp	r3, #0
 801ad82:	d008      	beq.n	801ad96 <settings_write_global+0x3a>
        hal.nvs.memcpy_to_nvs(NVS_ADDR_GLOBAL, (uint8_t *)&settings, sizeof(settings_t), true);
 801ad84:	4b07      	ldr	r3, [pc, #28]	; (801ada4 <settings_write_global+0x48>)
 801ad86:	f8d3 4160 	ldr.w	r4, [r3, #352]	; 0x160
 801ad8a:	2301      	movs	r3, #1
 801ad8c:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 801ad90:	4903      	ldr	r1, [pc, #12]	; (801ada0 <settings_write_global+0x44>)
 801ad92:	2001      	movs	r0, #1
 801ad94:	47a0      	blx	r4
}
 801ad96:	bf00      	nop
 801ad98:	bd98      	pop	{r3, r4, r7, pc}
 801ad9a:	bf00      	nop
 801ad9c:	20001650 	.word	0x20001650
 801ada0:	2000147c 	.word	0x2000147c
 801ada4:	20000ed0 	.word	0x20000ed0

0801ada8 <settings_restore>:


// Restore global settings to defaults and write to persistent storage
void settings_restore (settings_restore_t restore)
{
 801ada8:	b580      	push	{r7, lr}
 801adaa:	b09a      	sub	sp, #104	; 0x68
 801adac:	af00      	add	r7, sp, #0
 801adae:	7138      	strb	r0, [r7, #4]
    uint_fast8_t idx;
    stored_line_t empty_line;

    memset(empty_line, 0xFF, sizeof(stored_line_t));
 801adb0:	f107 0318 	add.w	r3, r7, #24
 801adb4:	2246      	movs	r2, #70	; 0x46
 801adb6:	21ff      	movs	r1, #255	; 0xff
 801adb8:	4618      	mov	r0, r3
 801adba:	f008 ff2c 	bl	8023c16 <memset>
    *empty_line = '\0';
 801adbe:	2300      	movs	r3, #0
 801adc0:	763b      	strb	r3, [r7, #24]

    hal.nvs.put_byte(0, SETTINGS_VERSION); // Forces write to physical storage
 801adc2:	4b5d      	ldr	r3, [pc, #372]	; (801af38 <settings_restore+0x190>)
 801adc4:	f8d3 315c 	ldr.w	r3, [r3, #348]	; 0x15c
 801adc8:	2116      	movs	r1, #22
 801adca:	2000      	movs	r0, #0
 801adcc:	4798      	blx	r3

    if (restore.defaults) {
 801adce:	793b      	ldrb	r3, [r7, #4]
 801add0:	f003 0301 	and.w	r3, r3, #1
 801add4:	b2db      	uxtb	r3, r3
 801add6:	2b00      	cmp	r3, #0
 801add8:	d04b      	beq.n	801ae72 <settings_restore+0xca>

        memcpy(&settings, &defaults, sizeof(settings_t));
 801adda:	4a58      	ldr	r2, [pc, #352]	; (801af3c <settings_restore+0x194>)
 801addc:	4b58      	ldr	r3, [pc, #352]	; (801af40 <settings_restore+0x198>)
 801adde:	4610      	mov	r0, r2
 801ade0:	4619      	mov	r1, r3
 801ade2:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 801ade6:	461a      	mov	r2, r3
 801ade8:	f009 f871 	bl	8023ece <memcpy>

        settings.control_invert.mask &= hal.signals_cap.mask;
 801adec:	4b53      	ldr	r3, [pc, #332]	; (801af3c <settings_restore+0x194>)
 801adee:	f8b3 206c 	ldrh.w	r2, [r3, #108]	; 0x6c
 801adf2:	4b51      	ldr	r3, [pc, #324]	; (801af38 <settings_restore+0x190>)
 801adf4:	f8b3 31ac 	ldrh.w	r3, [r3, #428]	; 0x1ac
 801adf8:	4013      	ands	r3, r2
 801adfa:	b29a      	uxth	r2, r3
 801adfc:	4b4f      	ldr	r3, [pc, #316]	; (801af3c <settings_restore+0x194>)
 801adfe:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
        settings.spindle.invert.ccw &= spindle_get_caps(false).direction;
 801ae02:	2000      	movs	r0, #0
 801ae04:	f001 fcca 	bl	801c79c <spindle_get_caps>
 801ae08:	4603      	mov	r3, r0
 801ae0a:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801ae0e:	b2d9      	uxtb	r1, r3
 801ae10:	4b4a      	ldr	r3, [pc, #296]	; (801af3c <settings_restore+0x194>)
 801ae12:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 801ae16:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801ae1a:	b2db      	uxtb	r3, r3
 801ae1c:	461a      	mov	r2, r3
 801ae1e:	460b      	mov	r3, r1
 801ae20:	4013      	ands	r3, r2
 801ae22:	b2db      	uxtb	r3, r3
 801ae24:	f003 0301 	and.w	r3, r3, #1
 801ae28:	b2d9      	uxtb	r1, r3
 801ae2a:	4a44      	ldr	r2, [pc, #272]	; (801af3c <settings_restore+0x194>)
 801ae2c:	f892 30e6 	ldrb.w	r3, [r2, #230]	; 0xe6
 801ae30:	f361 0341 	bfi	r3, r1, #1, #1
 801ae34:	f882 30e6 	strb.w	r3, [r2, #230]	; 0xe6
        settings.spindle.invert.pwm &= spindle_get_caps(false).pwm_invert;
 801ae38:	2000      	movs	r0, #0
 801ae3a:	f001 fcaf 	bl	801c79c <spindle_get_caps>
 801ae3e:	4603      	mov	r3, r0
 801ae40:	f3c3 1300 	ubfx	r3, r3, #4, #1
 801ae44:	b2d9      	uxtb	r1, r3
 801ae46:	4b3d      	ldr	r3, [pc, #244]	; (801af3c <settings_restore+0x194>)
 801ae48:	f893 30e6 	ldrb.w	r3, [r3, #230]	; 0xe6
 801ae4c:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801ae50:	b2db      	uxtb	r3, r3
 801ae52:	461a      	mov	r2, r3
 801ae54:	460b      	mov	r3, r1
 801ae56:	4013      	ands	r3, r2
 801ae58:	b2db      	uxtb	r3, r3
 801ae5a:	f003 0301 	and.w	r3, r3, #1
 801ae5e:	b2d9      	uxtb	r1, r3
 801ae60:	4a36      	ldr	r2, [pc, #216]	; (801af3c <settings_restore+0x194>)
 801ae62:	f892 30e6 	ldrb.w	r3, [r2, #230]	; 0xe6
 801ae66:	f361 0382 	bfi	r3, r1, #2, #1
 801ae6a:	f882 30e6 	strb.w	r3, [r2, #230]	; 0xe6
#if ENABLE_BACKLASH_COMPENSATION
        if(sys.driver_started)
            mc_backlash_init((axes_signals_t){AXES_BITMASK});
#endif
        settings_write_global();
 801ae6e:	f7ff ff75 	bl	801ad5c <settings_write_global>
    }

    if (restore.parameters) {
 801ae72:	793b      	ldrb	r3, [r7, #4]
 801ae74:	f003 0302 	and.w	r3, r3, #2
 801ae78:	b2db      	uxtb	r3, r3
 801ae7a:	2b00      	cmp	r3, #0
 801ae7c:	d01d      	beq.n	801aeba <settings_restore+0x112>
        float coord_data[N_AXIS];

        memset(coord_data, 0, sizeof(coord_data));
 801ae7e:	f107 030c 	add.w	r3, r7, #12
 801ae82:	220c      	movs	r2, #12
 801ae84:	2100      	movs	r1, #0
 801ae86:	4618      	mov	r0, r3
 801ae88:	f008 fec5 	bl	8023c16 <memset>
        for (idx = 0; idx <= N_WorkCoordinateSystems; idx++)
 801ae8c:	2300      	movs	r3, #0
 801ae8e:	667b      	str	r3, [r7, #100]	; 0x64
 801ae90:	e00a      	b.n	801aea8 <settings_restore+0x100>
            settings_write_coord_data((coord_system_id_t)idx, &coord_data);
 801ae92:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801ae94:	b2db      	uxtb	r3, r3
 801ae96:	f107 020c 	add.w	r2, r7, #12
 801ae9a:	4611      	mov	r1, r2
 801ae9c:	4618      	mov	r0, r3
 801ae9e:	f7ff fe8b 	bl	801abb8 <settings_write_coord_data>
        for (idx = 0; idx <= N_WorkCoordinateSystems; idx++)
 801aea2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801aea4:	3301      	adds	r3, #1
 801aea6:	667b      	str	r3, [r7, #100]	; 0x64
 801aea8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801aeaa:	2b09      	cmp	r3, #9
 801aeac:	d9f1      	bls.n	801ae92 <settings_restore+0xea>

        settings_write_coord_data(CoordinateSystem_G92, &coord_data); // Clear G92 offsets
 801aeae:	f107 030c 	add.w	r3, r7, #12
 801aeb2:	4619      	mov	r1, r3
 801aeb4:	200b      	movs	r0, #11
 801aeb6:	f7ff fe7f 	bl	801abb8 <settings_write_coord_data>
#if N_TOOLS
        settings_clear_tool_data();
#endif
    }

    if (restore.startup_lines) {
 801aeba:	793b      	ldrb	r3, [r7, #4]
 801aebc:	f003 0304 	and.w	r3, r3, #4
 801aec0:	b2db      	uxtb	r3, r3
 801aec2:	2b00      	cmp	r3, #0
 801aec4:	d010      	beq.n	801aee8 <settings_restore+0x140>
        for (idx = 0; idx < N_STARTUP_LINE; idx++)
 801aec6:	2300      	movs	r3, #0
 801aec8:	667b      	str	r3, [r7, #100]	; 0x64
 801aeca:	e00a      	b.n	801aee2 <settings_restore+0x13a>
            settings_write_startup_line(idx, empty_line);
 801aecc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801aece:	b2db      	uxtb	r3, r3
 801aed0:	f107 0218 	add.w	r2, r7, #24
 801aed4:	4611      	mov	r1, r2
 801aed6:	4618      	mov	r0, r3
 801aed8:	f7ff fe00 	bl	801aadc <settings_write_startup_line>
        for (idx = 0; idx < N_STARTUP_LINE; idx++)
 801aedc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801aede:	3301      	adds	r3, #1
 801aee0:	667b      	str	r3, [r7, #100]	; 0x64
 801aee2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801aee4:	2b01      	cmp	r3, #1
 801aee6:	d9f1      	bls.n	801aecc <settings_restore+0x124>
    }

    if (restore.build_info) {
 801aee8:	793b      	ldrb	r3, [r7, #4]
 801aeea:	f003 0308 	and.w	r3, r3, #8
 801aeee:	b2db      	uxtb	r3, r3
 801aef0:	2b00      	cmp	r3, #0
 801aef2:	d007      	beq.n	801af04 <settings_restore+0x15c>
        settings_write_build_info(empty_line);
 801aef4:	f107 0318 	add.w	r3, r7, #24
 801aef8:	4618      	mov	r0, r3
 801aefa:	f7ff fdb3 	bl	801aa64 <settings_write_build_info>
        settings_write_build_info(BUILD_INFO);
 801aefe:	4811      	ldr	r0, [pc, #68]	; (801af44 <settings_restore+0x19c>)
 801af00:	f7ff fdb0 	bl	801aa64 <settings_write_build_info>
    }

    setting_details_t *details = setting_details.next;
 801af04:	4b10      	ldr	r3, [pc, #64]	; (801af48 <settings_restore+0x1a0>)
 801af06:	699b      	ldr	r3, [r3, #24]
 801af08:	663b      	str	r3, [r7, #96]	; 0x60

    if(details) do {
 801af0a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801af0c:	2b00      	cmp	r3, #0
 801af0e:	d00c      	beq.n	801af2a <settings_restore+0x182>
        if(details->restore)
 801af10:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801af12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801af14:	2b00      	cmp	r3, #0
 801af16:	d002      	beq.n	801af1e <settings_restore+0x176>
            details->restore();
 801af18:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801af1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801af1c:	4798      	blx	r3
    } while((details = details->next));
 801af1e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801af20:	699b      	ldr	r3, [r3, #24]
 801af22:	663b      	str	r3, [r7, #96]	; 0x60
 801af24:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801af26:	2b00      	cmp	r3, #0
 801af28:	d1f2      	bne.n	801af10 <settings_restore+0x168>

    nvs_buffer_sync_physical();
 801af2a:	f7f6 f85f 	bl	8010fec <nvs_buffer_sync_physical>
}
 801af2e:	bf00      	nop
 801af30:	3768      	adds	r7, #104	; 0x68
 801af32:	46bd      	mov	sp, r7
 801af34:	bd80      	pop	{r7, pc}
 801af36:	bf00      	nop
 801af38:	20000ed0 	.word	0x20000ed0
 801af3c:	2000147c 	.word	0x2000147c
 801af40:	0803146c 	.word	0x0803146c
 801af44:	0802e09c 	.word	0x0802e09c
 801af48:	20000360 	.word	0x20000360

0801af4c <is_available>:

inline static bool is_available (const setting_detail_t *setting)
{
 801af4c:	b580      	push	{r7, lr}
 801af4e:	b082      	sub	sp, #8
 801af50:	af00      	add	r7, sp, #0
 801af52:	6078      	str	r0, [r7, #4]
    return setting->is_available == NULL || setting->is_available(setting);
 801af54:	687b      	ldr	r3, [r7, #4]
 801af56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801af58:	2b00      	cmp	r3, #0
 801af5a:	d006      	beq.n	801af6a <is_available+0x1e>
 801af5c:	687b      	ldr	r3, [r7, #4]
 801af5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801af60:	6878      	ldr	r0, [r7, #4]
 801af62:	4798      	blx	r3
 801af64:	4603      	mov	r3, r0
 801af66:	2b00      	cmp	r3, #0
 801af68:	d001      	beq.n	801af6e <is_available+0x22>
 801af6a:	2301      	movs	r3, #1
 801af6c:	e000      	b.n	801af70 <is_available+0x24>
 801af6e:	2300      	movs	r3, #0
 801af70:	f003 0301 	and.w	r3, r3, #1
 801af74:	b2db      	uxtb	r3, r3
}
 801af76:	4618      	mov	r0, r3
 801af78:	3708      	adds	r7, #8
 801af7a:	46bd      	mov	sp, r7
 801af7c:	bd80      	pop	{r7, pc}

0801af7e <is_group_available>:

static bool is_group_available (const setting_detail_t *setting)
{
 801af7e:	b580      	push	{r7, lr}
 801af80:	b082      	sub	sp, #8
 801af82:	af00      	add	r7, sp, #0
 801af84:	6078      	str	r0, [r7, #4]
    return settings_is_group_available(setting->group);
 801af86:	687b      	ldr	r3, [r7, #4]
 801af88:	789b      	ldrb	r3, [r3, #2]
 801af8a:	4618      	mov	r0, r3
 801af8c:	f000 f806 	bl	801af9c <settings_is_group_available>
 801af90:	4603      	mov	r3, r0
}
 801af92:	4618      	mov	r0, r3
 801af94:	3708      	adds	r7, #8
 801af96:	46bd      	mov	sp, r7
 801af98:	bd80      	pop	{r7, pc}
	...

0801af9c <settings_is_group_available>:

bool settings_is_group_available (setting_group_t id)
{
 801af9c:	b580      	push	{r7, lr}
 801af9e:	b086      	sub	sp, #24
 801afa0:	af00      	add	r7, sp, #0
 801afa2:	4603      	mov	r3, r0
 801afa4:	71fb      	strb	r3, [r7, #7]
    const setting_group_detail_t *group = setting_get_group_details(id);
 801afa6:	79fb      	ldrb	r3, [r7, #7]
 801afa8:	4618      	mov	r0, r3
 801afaa:	f000 fa2d 	bl	801b408 <setting_get_group_details>
 801afae:	60b8      	str	r0, [r7, #8]

    if(!group)
 801afb0:	68bb      	ldr	r3, [r7, #8]
 801afb2:	2b00      	cmp	r3, #0
 801afb4:	d101      	bne.n	801afba <settings_is_group_available+0x1e>
        return false;
 801afb6:	2300      	movs	r3, #0
 801afb8:	e0b1      	b.n	801b11e <settings_is_group_available+0x182>

    bool available = group->is_available ? group->is_available(group) : false;
 801afba:	68bb      	ldr	r3, [r7, #8]
 801afbc:	689b      	ldr	r3, [r3, #8]
 801afbe:	2b00      	cmp	r3, #0
 801afc0:	d008      	beq.n	801afd4 <settings_is_group_available+0x38>
 801afc2:	68bb      	ldr	r3, [r7, #8]
 801afc4:	689b      	ldr	r3, [r3, #8]
 801afc6:	68b8      	ldr	r0, [r7, #8]
 801afc8:	4798      	blx	r3
 801afca:	4603      	mov	r3, r0
 801afcc:	2b00      	cmp	r3, #0
 801afce:	d001      	beq.n	801afd4 <settings_is_group_available+0x38>
 801afd0:	2301      	movs	r3, #1
 801afd2:	e000      	b.n	801afd6 <settings_is_group_available+0x3a>
 801afd4:	2300      	movs	r3, #0
 801afd6:	75fb      	strb	r3, [r7, #23]

    if(!available) switch(group->id) {
 801afd8:	7dfb      	ldrb	r3, [r7, #23]
 801afda:	f083 0301 	eor.w	r3, r3, #1
 801afde:	b2db      	uxtb	r3, r3
 801afe0:	2b00      	cmp	r3, #0
 801afe2:	f000 809b 	beq.w	801b11c <settings_is_group_available+0x180>
 801afe6:	68bb      	ldr	r3, [r7, #8]
 801afe8:	785b      	ldrb	r3, [r3, #1]
 801afea:	3b02      	subs	r3, #2
 801afec:	2b0c      	cmp	r3, #12
 801afee:	d858      	bhi.n	801b0a2 <settings_is_group_available+0x106>
 801aff0:	a201      	add	r2, pc, #4	; (adr r2, 801aff8 <settings_is_group_available+0x5c>)
 801aff2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801aff6:	bf00      	nop
 801aff8:	0801b09d 	.word	0x0801b09d
 801affc:	0801b09d 	.word	0x0801b09d
 801b000:	0801b06f 	.word	0x0801b06f
 801b004:	0801b0a3 	.word	0x0801b0a3
 801b008:	0801b09d 	.word	0x0801b09d
 801b00c:	0801b03f 	.word	0x0801b03f
 801b010:	0801b057 	.word	0x0801b057
 801b014:	0801b0a3 	.word	0x0801b0a3
 801b018:	0801b0a3 	.word	0x0801b0a3
 801b01c:	0801b09d 	.word	0x0801b09d
 801b020:	0801b02d 	.word	0x0801b02d
 801b024:	0801b0a3 	.word	0x0801b0a3
 801b028:	0801b09d 	.word	0x0801b09d

        case Group_Probing:
            available = hal.probe.get_state != NULL;
 801b02c:	4b3e      	ldr	r3, [pc, #248]	; (801b128 <settings_is_group_available+0x18c>)
 801b02e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801b032:	2b00      	cmp	r3, #0
 801b034:	bf14      	ite	ne
 801b036:	2301      	movne	r3, #1
 801b038:	2300      	moveq	r3, #0
 801b03a:	75fb      	strb	r3, [r7, #23]
            break;
 801b03c:	e06e      	b.n	801b11c <settings_is_group_available+0x180>

        case Group_Spindle_Sync:
            available = hal.driver_cap.spindle_sync;
 801b03e:	4b3a      	ldr	r3, [pc, #232]	; (801b128 <settings_is_group_available+0x18c>)
 801b040:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801b044:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801b048:	b2db      	uxtb	r3, r3
 801b04a:	2b00      	cmp	r3, #0
 801b04c:	bf14      	ite	ne
 801b04e:	2301      	movne	r3, #1
 801b050:	2300      	moveq	r3, #0
 801b052:	75fb      	strb	r3, [r7, #23]
            break;
 801b054:	e062      	b.n	801b11c <settings_is_group_available+0x180>

        case Group_Spindle_ClosedLoop:
            available = hal.driver_cap.spindle_pid;
 801b056:	4b34      	ldr	r3, [pc, #208]	; (801b128 <settings_is_group_available+0x18c>)
 801b058:	f893 31a9 	ldrb.w	r3, [r3, #425]	; 0x1a9
 801b05c:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 801b060:	b2db      	uxtb	r3, r3
 801b062:	2b00      	cmp	r3, #0
 801b064:	bf14      	ite	ne
 801b066:	2301      	movne	r3, #1
 801b068:	2300      	moveq	r3, #0
 801b06a:	75fb      	strb	r3, [r7, #23]
            break;
 801b06c:	e056      	b.n	801b11c <settings_is_group_available+0x180>

        case Group_Limits_DualAxis:
            available = hal.stepper.get_ganged && hal.stepper.get_ganged(true).mask != 0;
 801b06e:	4b2e      	ldr	r3, [pc, #184]	; (801b128 <settings_is_group_available+0x18c>)
 801b070:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801b074:	2b00      	cmp	r3, #0
 801b076:	d00a      	beq.n	801b08e <settings_is_group_available+0xf2>
 801b078:	4b2b      	ldr	r3, [pc, #172]	; (801b128 <settings_is_group_available+0x18c>)
 801b07a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801b07e:	2001      	movs	r0, #1
 801b080:	4798      	blx	r3
 801b082:	4603      	mov	r3, r0
 801b084:	b2db      	uxtb	r3, r3
 801b086:	2b00      	cmp	r3, #0
 801b088:	d001      	beq.n	801b08e <settings_is_group_available+0xf2>
 801b08a:	2301      	movs	r3, #1
 801b08c:	e000      	b.n	801b090 <settings_is_group_available+0xf4>
 801b08e:	2300      	movs	r3, #0
 801b090:	75fb      	strb	r3, [r7, #23]
 801b092:	7dfb      	ldrb	r3, [r7, #23]
 801b094:	f003 0301 	and.w	r3, r3, #1
 801b098:	75fb      	strb	r3, [r7, #23]
            break;
 801b09a:	e03f      	b.n	801b11c <settings_is_group_available+0x180>
        case Group_Homing:
        case Group_Jogging:
        case Group_Limits:
        case Group_ControlSignals:
        case Group_Spindle:
            available = true;
 801b09c:	2301      	movs	r3, #1
 801b09e:	75fb      	strb	r3, [r7, #23]
            break;
 801b0a0:	e03c      	b.n	801b11c <settings_is_group_available+0x180>

        default:
            {
                uint_fast16_t idx;
                setting_details_t *details = &setting_details;
 801b0a2:	4b22      	ldr	r3, [pc, #136]	; (801b12c <settings_is_group_available+0x190>)
 801b0a4:	60fb      	str	r3, [r7, #12]

                do {
                    if(details->settings) {
 801b0a6:	68fb      	ldr	r3, [r7, #12]
 801b0a8:	68db      	ldr	r3, [r3, #12]
 801b0aa:	2b00      	cmp	r3, #0
 801b0ac:	d029      	beq.n	801b102 <settings_is_group_available+0x166>
                        for(idx = 0; idx < details->n_settings; idx++) {
 801b0ae:	2300      	movs	r3, #0
 801b0b0:	613b      	str	r3, [r7, #16]
 801b0b2:	e01e      	b.n	801b0f2 <settings_is_group_available+0x156>
                            if(details->settings[idx].group == id && (available = is_available(&details->settings[idx])))
 801b0b4:	68fb      	ldr	r3, [r7, #12]
 801b0b6:	68d9      	ldr	r1, [r3, #12]
 801b0b8:	693a      	ldr	r2, [r7, #16]
 801b0ba:	4613      	mov	r3, r2
 801b0bc:	005b      	lsls	r3, r3, #1
 801b0be:	4413      	add	r3, r2
 801b0c0:	011b      	lsls	r3, r3, #4
 801b0c2:	440b      	add	r3, r1
 801b0c4:	789b      	ldrb	r3, [r3, #2]
 801b0c6:	79fa      	ldrb	r2, [r7, #7]
 801b0c8:	429a      	cmp	r2, r3
 801b0ca:	d10f      	bne.n	801b0ec <settings_is_group_available+0x150>
 801b0cc:	68fb      	ldr	r3, [r7, #12]
 801b0ce:	68d9      	ldr	r1, [r3, #12]
 801b0d0:	693a      	ldr	r2, [r7, #16]
 801b0d2:	4613      	mov	r3, r2
 801b0d4:	005b      	lsls	r3, r3, #1
 801b0d6:	4413      	add	r3, r2
 801b0d8:	011b      	lsls	r3, r3, #4
 801b0da:	440b      	add	r3, r1
 801b0dc:	4618      	mov	r0, r3
 801b0de:	f7ff ff35 	bl	801af4c <is_available>
 801b0e2:	4603      	mov	r3, r0
 801b0e4:	75fb      	strb	r3, [r7, #23]
 801b0e6:	7dfb      	ldrb	r3, [r7, #23]
 801b0e8:	2b00      	cmp	r3, #0
 801b0ea:	d109      	bne.n	801b100 <settings_is_group_available+0x164>
                        for(idx = 0; idx < details->n_settings; idx++) {
 801b0ec:	693b      	ldr	r3, [r7, #16]
 801b0ee:	3301      	adds	r3, #1
 801b0f0:	613b      	str	r3, [r7, #16]
 801b0f2:	68fb      	ldr	r3, [r7, #12]
 801b0f4:	891b      	ldrh	r3, [r3, #8]
 801b0f6:	461a      	mov	r2, r3
 801b0f8:	693b      	ldr	r3, [r7, #16]
 801b0fa:	4293      	cmp	r3, r2
 801b0fc:	d3da      	bcc.n	801b0b4 <settings_is_group_available+0x118>
 801b0fe:	e000      	b.n	801b102 <settings_is_group_available+0x166>
                                break;
 801b100:	bf00      	nop
                        }
                    }
                } while(!available && (details = details->next));
 801b102:	7dfb      	ldrb	r3, [r7, #23]
 801b104:	f083 0301 	eor.w	r3, r3, #1
 801b108:	b2db      	uxtb	r3, r3
 801b10a:	2b00      	cmp	r3, #0
 801b10c:	d005      	beq.n	801b11a <settings_is_group_available+0x17e>
 801b10e:	68fb      	ldr	r3, [r7, #12]
 801b110:	699b      	ldr	r3, [r3, #24]
 801b112:	60fb      	str	r3, [r7, #12]
 801b114:	68fb      	ldr	r3, [r7, #12]
 801b116:	2b00      	cmp	r3, #0
 801b118:	d1c5      	bne.n	801b0a6 <settings_is_group_available+0x10a>
            }
            break;
 801b11a:	bf00      	nop
    }

    return available;
 801b11c:	7dfb      	ldrb	r3, [r7, #23]
}
 801b11e:	4618      	mov	r0, r3
 801b120:	3718      	adds	r7, #24
 801b122:	46bd      	mov	sp, r7
 801b124:	bd80      	pop	{r7, pc}
 801b126:	bf00      	nop
 801b128:	20000ed0 	.word	0x20000ed0
 801b12c:	20000360 	.word	0x20000360

0801b130 <settings_normalize_group>:

setting_group_t settings_normalize_group (setting_group_t group)
{
 801b130:	b480      	push	{r7}
 801b132:	b083      	sub	sp, #12
 801b134:	af00      	add	r7, sp, #0
 801b136:	4603      	mov	r3, r0
 801b138:	71fb      	strb	r3, [r7, #7]
    return (group > Group_Axis0 && group < Group_Axis0 + N_AXIS) ? Group_Axis0 : group;
 801b13a:	79fb      	ldrb	r3, [r7, #7]
 801b13c:	2b2b      	cmp	r3, #43	; 0x2b
 801b13e:	d902      	bls.n	801b146 <settings_normalize_group+0x16>
 801b140:	79fb      	ldrb	r3, [r7, #7]
 801b142:	2b2d      	cmp	r3, #45	; 0x2d
 801b144:	d901      	bls.n	801b14a <settings_normalize_group+0x1a>
 801b146:	79fb      	ldrb	r3, [r7, #7]
 801b148:	e000      	b.n	801b14c <settings_normalize_group+0x1c>
 801b14a:	232b      	movs	r3, #43	; 0x2b
}
 801b14c:	4618      	mov	r0, r3
 801b14e:	370c      	adds	r7, #12
 801b150:	46bd      	mov	sp, r7
 801b152:	bc80      	pop	{r7}
 801b154:	4770      	bx	lr
	...

0801b158 <settings_iterator>:

bool settings_iterator (const setting_detail_t *setting, setting_output_ptr callback, void *data)
{
 801b158:	b580      	push	{r7, lr}
 801b15a:	b088      	sub	sp, #32
 801b15c:	af00      	add	r7, sp, #0
 801b15e:	60f8      	str	r0, [r7, #12]
 801b160:	60b9      	str	r1, [r7, #8]
 801b162:	607a      	str	r2, [r7, #4]
    bool ok = false;
 801b164:	2300      	movs	r3, #0
 801b166:	77fb      	strb	r3, [r7, #31]

    if(setting->group == Group_Axis0) {
 801b168:	68fb      	ldr	r3, [r7, #12]
 801b16a:	789b      	ldrb	r3, [r3, #2]
 801b16c:	2b2b      	cmp	r3, #43	; 0x2b
 801b16e:	d127      	bne.n	801b1c0 <settings_iterator+0x68>

        uint_fast8_t axis_idx = 0;
 801b170:	2300      	movs	r3, #0
 801b172:	61bb      	str	r3, [r7, #24]

        for(axis_idx = 0; axis_idx < N_AXIS; axis_idx++) {
 801b174:	2300      	movs	r3, #0
 801b176:	61bb      	str	r3, [r7, #24]
 801b178:	e01e      	b.n	801b1b8 <settings_iterator+0x60>

            if(grbl.on_set_axis_setting_unit)
 801b17a:	4b26      	ldr	r3, [pc, #152]	; (801b214 <settings_iterator+0xbc>)
 801b17c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801b180:	2b00      	cmp	r3, #0
 801b182:	d00c      	beq.n	801b19e <settings_iterator+0x46>
                set_axis_unit(setting, grbl.on_set_axis_setting_unit(setting->id, axis_idx));
 801b184:	4b23      	ldr	r3, [pc, #140]	; (801b214 <settings_iterator+0xbc>)
 801b186:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801b18a:	68fa      	ldr	r2, [r7, #12]
 801b18c:	8812      	ldrh	r2, [r2, #0]
 801b18e:	69b9      	ldr	r1, [r7, #24]
 801b190:	4610      	mov	r0, r2
 801b192:	4798      	blx	r3
 801b194:	4603      	mov	r3, r0
 801b196:	4619      	mov	r1, r3
 801b198:	68f8      	ldr	r0, [r7, #12]
 801b19a:	f7fe fb31 	bl	8019800 <set_axis_unit>

            if(callback(setting, axis_idx, data))
 801b19e:	68bb      	ldr	r3, [r7, #8]
 801b1a0:	687a      	ldr	r2, [r7, #4]
 801b1a2:	69b9      	ldr	r1, [r7, #24]
 801b1a4:	68f8      	ldr	r0, [r7, #12]
 801b1a6:	4798      	blx	r3
 801b1a8:	4603      	mov	r3, r0
 801b1aa:	2b00      	cmp	r3, #0
 801b1ac:	d001      	beq.n	801b1b2 <settings_iterator+0x5a>
                ok = true;
 801b1ae:	2301      	movs	r3, #1
 801b1b0:	77fb      	strb	r3, [r7, #31]
        for(axis_idx = 0; axis_idx < N_AXIS; axis_idx++) {
 801b1b2:	69bb      	ldr	r3, [r7, #24]
 801b1b4:	3301      	adds	r3, #1
 801b1b6:	61bb      	str	r3, [r7, #24]
 801b1b8:	69bb      	ldr	r3, [r7, #24]
 801b1ba:	2b02      	cmp	r3, #2
 801b1bc:	d9dd      	bls.n	801b17a <settings_iterator+0x22>
 801b1be:	e024      	b.n	801b20a <settings_iterator+0xb2>
        }
    } else if(setting->flags.increment) {
 801b1c0:	68fb      	ldr	r3, [r7, #12]
 801b1c2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801b1c6:	f003 0378 	and.w	r3, r3, #120	; 0x78
 801b1ca:	b2db      	uxtb	r3, r3
 801b1cc:	2b00      	cmp	r3, #0
 801b1ce:	d015      	beq.n	801b1fc <settings_iterator+0xa4>
        setting_details_t *set;
        setting = setting_get_details(setting->id, &set);
 801b1d0:	68fb      	ldr	r3, [r7, #12]
 801b1d2:	881b      	ldrh	r3, [r3, #0]
 801b1d4:	f107 0214 	add.w	r2, r7, #20
 801b1d8:	4611      	mov	r1, r2
 801b1da:	4618      	mov	r0, r3
 801b1dc:	f000 f81c 	bl	801b218 <setting_get_details>
 801b1e0:	60f8      	str	r0, [r7, #12]
        if(set->iterator)
 801b1e2:	697b      	ldr	r3, [r7, #20]
 801b1e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b1e6:	2b00      	cmp	r3, #0
 801b1e8:	d00f      	beq.n	801b20a <settings_iterator+0xb2>
            ok = set->iterator(setting, callback, data);
 801b1ea:	697b      	ldr	r3, [r7, #20]
 801b1ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b1ee:	687a      	ldr	r2, [r7, #4]
 801b1f0:	68b9      	ldr	r1, [r7, #8]
 801b1f2:	68f8      	ldr	r0, [r7, #12]
 801b1f4:	4798      	blx	r3
 801b1f6:	4603      	mov	r3, r0
 801b1f8:	77fb      	strb	r3, [r7, #31]
 801b1fa:	e006      	b.n	801b20a <settings_iterator+0xb2>
    } else
        ok = callback(setting, 0, data);
 801b1fc:	68bb      	ldr	r3, [r7, #8]
 801b1fe:	687a      	ldr	r2, [r7, #4]
 801b200:	2100      	movs	r1, #0
 801b202:	68f8      	ldr	r0, [r7, #12]
 801b204:	4798      	blx	r3
 801b206:	4603      	mov	r3, r0
 801b208:	77fb      	strb	r3, [r7, #31]

    return ok;
 801b20a:	7ffb      	ldrb	r3, [r7, #31]
}
 801b20c:	4618      	mov	r0, r3
 801b20e:	3720      	adds	r7, #32
 801b210:	46bd      	mov	sp, r7
 801b212:	bd80      	pop	{r7, pc}
 801b214:	20000dd4 	.word	0x20000dd4

0801b218 <setting_get_details>:

const setting_detail_t *setting_get_details (setting_id_t id, setting_details_t **set)
{
 801b218:	b5b0      	push	{r4, r5, r7, lr}
 801b21a:	b086      	sub	sp, #24
 801b21c:	af00      	add	r7, sp, #0
 801b21e:	4603      	mov	r3, r0
 801b220:	6039      	str	r1, [r7, #0]
 801b222:	80fb      	strh	r3, [r7, #6]
    uint_fast16_t idx, offset = id - normalize_id(id);
 801b224:	88fc      	ldrh	r4, [r7, #6]
 801b226:	88fb      	ldrh	r3, [r7, #6]
 801b228:	4618      	mov	r0, r3
 801b22a:	f7fe fafb 	bl	8019824 <normalize_id>
 801b22e:	4603      	mov	r3, r0
 801b230:	1ae3      	subs	r3, r4, r3
 801b232:	60fb      	str	r3, [r7, #12]
    setting_details_t *details = settings_get_details();
 801b234:	f7fd fd72 	bl	8018d1c <settings_get_details>
 801b238:	6138      	str	r0, [r7, #16]

    id -= offset;
 801b23a:	68fb      	ldr	r3, [r7, #12]
 801b23c:	b29b      	uxth	r3, r3
 801b23e:	88fa      	ldrh	r2, [r7, #6]
 801b240:	1ad3      	subs	r3, r2, r3
 801b242:	80fb      	strh	r3, [r7, #6]

    do {
        for(idx = 0; idx < details->n_settings; idx++) {
 801b244:	2300      	movs	r3, #0
 801b246:	617b      	str	r3, [r7, #20]
 801b248:	e076      	b.n	801b338 <setting_get_details+0x120>
            if(details->settings[idx].id == id && is_available(&details->settings[idx])) {
 801b24a:	693b      	ldr	r3, [r7, #16]
 801b24c:	68d9      	ldr	r1, [r3, #12]
 801b24e:	697a      	ldr	r2, [r7, #20]
 801b250:	4613      	mov	r3, r2
 801b252:	005b      	lsls	r3, r3, #1
 801b254:	4413      	add	r3, r2
 801b256:	011b      	lsls	r3, r3, #4
 801b258:	440b      	add	r3, r1
 801b25a:	881b      	ldrh	r3, [r3, #0]
 801b25c:	88fa      	ldrh	r2, [r7, #6]
 801b25e:	429a      	cmp	r2, r3
 801b260:	d167      	bne.n	801b332 <setting_get_details+0x11a>
 801b262:	693b      	ldr	r3, [r7, #16]
 801b264:	68d9      	ldr	r1, [r3, #12]
 801b266:	697a      	ldr	r2, [r7, #20]
 801b268:	4613      	mov	r3, r2
 801b26a:	005b      	lsls	r3, r3, #1
 801b26c:	4413      	add	r3, r2
 801b26e:	011b      	lsls	r3, r3, #4
 801b270:	440b      	add	r3, r1
 801b272:	4618      	mov	r0, r3
 801b274:	f7ff fe6a 	bl	801af4c <is_available>
 801b278:	4603      	mov	r3, r0
 801b27a:	2b00      	cmp	r3, #0
 801b27c:	d059      	beq.n	801b332 <setting_get_details+0x11a>

                if(details->settings[idx].group == Group_Axis0 && grbl.on_set_axis_setting_unit)
 801b27e:	693b      	ldr	r3, [r7, #16]
 801b280:	68d9      	ldr	r1, [r3, #12]
 801b282:	697a      	ldr	r2, [r7, #20]
 801b284:	4613      	mov	r3, r2
 801b286:	005b      	lsls	r3, r3, #1
 801b288:	4413      	add	r3, r2
 801b28a:	011b      	lsls	r3, r3, #4
 801b28c:	440b      	add	r3, r1
 801b28e:	789b      	ldrb	r3, [r3, #2]
 801b290:	2b2b      	cmp	r3, #43	; 0x2b
 801b292:	d120      	bne.n	801b2d6 <setting_get_details+0xbe>
 801b294:	4b31      	ldr	r3, [pc, #196]	; (801b35c <setting_get_details+0x144>)
 801b296:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801b29a:	2b00      	cmp	r3, #0
 801b29c:	d01b      	beq.n	801b2d6 <setting_get_details+0xbe>
                    set_axis_unit(&details->settings[idx], grbl.on_set_axis_setting_unit(details->settings[idx].id, offset));
 801b29e:	693b      	ldr	r3, [r7, #16]
 801b2a0:	68d9      	ldr	r1, [r3, #12]
 801b2a2:	697a      	ldr	r2, [r7, #20]
 801b2a4:	4613      	mov	r3, r2
 801b2a6:	005b      	lsls	r3, r3, #1
 801b2a8:	4413      	add	r3, r2
 801b2aa:	011b      	lsls	r3, r3, #4
 801b2ac:	18cd      	adds	r5, r1, r3
 801b2ae:	4b2b      	ldr	r3, [pc, #172]	; (801b35c <setting_get_details+0x144>)
 801b2b0:	f8d3 40a4 	ldr.w	r4, [r3, #164]	; 0xa4
 801b2b4:	693b      	ldr	r3, [r7, #16]
 801b2b6:	68d9      	ldr	r1, [r3, #12]
 801b2b8:	697a      	ldr	r2, [r7, #20]
 801b2ba:	4613      	mov	r3, r2
 801b2bc:	005b      	lsls	r3, r3, #1
 801b2be:	4413      	add	r3, r2
 801b2c0:	011b      	lsls	r3, r3, #4
 801b2c2:	440b      	add	r3, r1
 801b2c4:	881b      	ldrh	r3, [r3, #0]
 801b2c6:	68f9      	ldr	r1, [r7, #12]
 801b2c8:	4618      	mov	r0, r3
 801b2ca:	47a0      	blx	r4
 801b2cc:	4603      	mov	r3, r0
 801b2ce:	4619      	mov	r1, r3
 801b2d0:	4628      	mov	r0, r5
 801b2d2:	f7fe fa95 	bl	8019800 <set_axis_unit>

                if(offset && details->iterator == NULL && offset >= (details->settings[idx].group == Group_Encoder0 ? hal.encoder.get_n_encoders() : N_AXIS))
 801b2d6:	68fb      	ldr	r3, [r7, #12]
 801b2d8:	2b00      	cmp	r3, #0
 801b2da:	d01b      	beq.n	801b314 <setting_get_details+0xfc>
 801b2dc:	693b      	ldr	r3, [r7, #16]
 801b2de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b2e0:	2b00      	cmp	r3, #0
 801b2e2:	d117      	bne.n	801b314 <setting_get_details+0xfc>
 801b2e4:	693b      	ldr	r3, [r7, #16]
 801b2e6:	68d9      	ldr	r1, [r3, #12]
 801b2e8:	697a      	ldr	r2, [r7, #20]
 801b2ea:	4613      	mov	r3, r2
 801b2ec:	005b      	lsls	r3, r3, #1
 801b2ee:	4413      	add	r3, r2
 801b2f0:	011b      	lsls	r3, r3, #4
 801b2f2:	440b      	add	r3, r1
 801b2f4:	789b      	ldrb	r3, [r3, #2]
 801b2f6:	2b1d      	cmp	r3, #29
 801b2f8:	d106      	bne.n	801b308 <setting_get_details+0xf0>
 801b2fa:	4b19      	ldr	r3, [pc, #100]	; (801b360 <setting_get_details+0x148>)
 801b2fc:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 801b300:	4798      	blx	r3
 801b302:	4603      	mov	r3, r0
 801b304:	461a      	mov	r2, r3
 801b306:	e000      	b.n	801b30a <setting_get_details+0xf2>
 801b308:	2203      	movs	r2, #3
 801b30a:	68fb      	ldr	r3, [r7, #12]
 801b30c:	429a      	cmp	r2, r3
 801b30e:	d801      	bhi.n	801b314 <setting_get_details+0xfc>
                    return NULL;
 801b310:	2300      	movs	r3, #0
 801b312:	e01f      	b.n	801b354 <setting_get_details+0x13c>

                if(set)
 801b314:	683b      	ldr	r3, [r7, #0]
 801b316:	2b00      	cmp	r3, #0
 801b318:	d002      	beq.n	801b320 <setting_get_details+0x108>
                    *set = details;
 801b31a:	683b      	ldr	r3, [r7, #0]
 801b31c:	693a      	ldr	r2, [r7, #16]
 801b31e:	601a      	str	r2, [r3, #0]

                return &details->settings[idx];
 801b320:	693b      	ldr	r3, [r7, #16]
 801b322:	68d9      	ldr	r1, [r3, #12]
 801b324:	697a      	ldr	r2, [r7, #20]
 801b326:	4613      	mov	r3, r2
 801b328:	005b      	lsls	r3, r3, #1
 801b32a:	4413      	add	r3, r2
 801b32c:	011b      	lsls	r3, r3, #4
 801b32e:	440b      	add	r3, r1
 801b330:	e010      	b.n	801b354 <setting_get_details+0x13c>
        for(idx = 0; idx < details->n_settings; idx++) {
 801b332:	697b      	ldr	r3, [r7, #20]
 801b334:	3301      	adds	r3, #1
 801b336:	617b      	str	r3, [r7, #20]
 801b338:	693b      	ldr	r3, [r7, #16]
 801b33a:	891b      	ldrh	r3, [r3, #8]
 801b33c:	461a      	mov	r2, r3
 801b33e:	697b      	ldr	r3, [r7, #20]
 801b340:	4293      	cmp	r3, r2
 801b342:	d382      	bcc.n	801b24a <setting_get_details+0x32>
            }
        }
    } while((details = details->next));
 801b344:	693b      	ldr	r3, [r7, #16]
 801b346:	699b      	ldr	r3, [r3, #24]
 801b348:	613b      	str	r3, [r7, #16]
 801b34a:	693b      	ldr	r3, [r7, #16]
 801b34c:	2b00      	cmp	r3, #0
 801b34e:	f47f af79 	bne.w	801b244 <setting_get_details+0x2c>

    return NULL;
 801b352:	2300      	movs	r3, #0
}
 801b354:	4618      	mov	r0, r3
 801b356:	3718      	adds	r7, #24
 801b358:	46bd      	mov	sp, r7
 801b35a:	bdb0      	pop	{r4, r5, r7, pc}
 801b35c:	20000dd4 	.word	0x20000dd4
 801b360:	20000ed0 	.word	0x20000ed0

0801b364 <setting_get_description>:

const char *setting_get_description (setting_id_t id)
{
 801b364:	b580      	push	{r7, lr}
 801b366:	b086      	sub	sp, #24
 801b368:	af00      	add	r7, sp, #0
 801b36a:	4603      	mov	r3, r0
 801b36c:	80fb      	strh	r3, [r7, #6]
    const char *description = NULL;
 801b36e:	2300      	movs	r3, #0
 801b370:	617b      	str	r3, [r7, #20]

#ifndef NO_SETTINGS_DESCRIPTIONS

    if(grbl.on_setting_get_description == NULL || (description = grbl.on_setting_get_description(id)) == NULL) {
 801b372:	4b24      	ldr	r3, [pc, #144]	; (801b404 <setting_get_description+0xa0>)
 801b374:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 801b376:	2b00      	cmp	r3, #0
 801b378:	d008      	beq.n	801b38c <setting_get_description+0x28>
 801b37a:	4b22      	ldr	r3, [pc, #136]	; (801b404 <setting_get_description+0xa0>)
 801b37c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 801b37e:	88fa      	ldrh	r2, [r7, #6]
 801b380:	4610      	mov	r0, r2
 801b382:	4798      	blx	r3
 801b384:	6178      	str	r0, [r7, #20]
 801b386:	697b      	ldr	r3, [r7, #20]
 801b388:	2b00      	cmp	r3, #0
 801b38a:	d135      	bne.n	801b3f8 <setting_get_description+0x94>

        uint_fast16_t idx;
        setting_details_t *settings = settings_get_details();
 801b38c:	f7fd fcc6 	bl	8018d1c <settings_get_details>
 801b390:	60f8      	str	r0, [r7, #12]
        const setting_detail_t *setting = setting_get_details(id, NULL);
 801b392:	88fb      	ldrh	r3, [r7, #6]
 801b394:	2100      	movs	r1, #0
 801b396:	4618      	mov	r0, r3
 801b398:	f7ff ff3e 	bl	801b218 <setting_get_details>
 801b39c:	60b8      	str	r0, [r7, #8]

        if(setting) do {
 801b39e:	68bb      	ldr	r3, [r7, #8]
 801b3a0:	2b00      	cmp	r3, #0
 801b3a2:	d029      	beq.n	801b3f8 <setting_get_description+0x94>
            if(settings->descriptions) {
 801b3a4:	68fb      	ldr	r3, [r7, #12]
 801b3a6:	695b      	ldr	r3, [r3, #20]
 801b3a8:	2b00      	cmp	r3, #0
 801b3aa:	d01c      	beq.n	801b3e6 <setting_get_description+0x82>
                idx = settings->n_descriptions;
 801b3ac:	68fb      	ldr	r3, [r7, #12]
 801b3ae:	8a1b      	ldrh	r3, [r3, #16]
 801b3b0:	613b      	str	r3, [r7, #16]
                do {
                    if(settings->descriptions[--idx].id == setting->id) {
 801b3b2:	68fb      	ldr	r3, [r7, #12]
 801b3b4:	695a      	ldr	r2, [r3, #20]
 801b3b6:	693b      	ldr	r3, [r7, #16]
 801b3b8:	3b01      	subs	r3, #1
 801b3ba:	613b      	str	r3, [r7, #16]
 801b3bc:	693b      	ldr	r3, [r7, #16]
 801b3be:	00db      	lsls	r3, r3, #3
 801b3c0:	4413      	add	r3, r2
 801b3c2:	881a      	ldrh	r2, [r3, #0]
 801b3c4:	68bb      	ldr	r3, [r7, #8]
 801b3c6:	881b      	ldrh	r3, [r3, #0]
 801b3c8:	429a      	cmp	r2, r3
 801b3ca:	d106      	bne.n	801b3da <setting_get_description+0x76>
  #if N_AXIS > 3
                        if(setting->id == Setting_AxisStepsPerMM && axis_is_rotary(id - setting->id))
                            idx++;
  #endif
                        description = settings->descriptions[idx].description;
 801b3cc:	68fb      	ldr	r3, [r7, #12]
 801b3ce:	695a      	ldr	r2, [r3, #20]
 801b3d0:	693b      	ldr	r3, [r7, #16]
 801b3d2:	00db      	lsls	r3, r3, #3
 801b3d4:	4413      	add	r3, r2
 801b3d6:	685b      	ldr	r3, [r3, #4]
 801b3d8:	617b      	str	r3, [r7, #20]
                    }
                } while(idx && description == NULL);
 801b3da:	693b      	ldr	r3, [r7, #16]
 801b3dc:	2b00      	cmp	r3, #0
 801b3de:	d002      	beq.n	801b3e6 <setting_get_description+0x82>
 801b3e0:	697b      	ldr	r3, [r7, #20]
 801b3e2:	2b00      	cmp	r3, #0
 801b3e4:	d0e5      	beq.n	801b3b2 <setting_get_description+0x4e>
            }
        } while(description == NULL && (settings = settings->next));
 801b3e6:	697b      	ldr	r3, [r7, #20]
 801b3e8:	2b00      	cmp	r3, #0
 801b3ea:	d105      	bne.n	801b3f8 <setting_get_description+0x94>
 801b3ec:	68fb      	ldr	r3, [r7, #12]
 801b3ee:	699b      	ldr	r3, [r3, #24]
 801b3f0:	60fb      	str	r3, [r7, #12]
 801b3f2:	68fb      	ldr	r3, [r7, #12]
 801b3f4:	2b00      	cmp	r3, #0
 801b3f6:	d1d5      	bne.n	801b3a4 <setting_get_description+0x40>
    }

#endif

    return description;
 801b3f8:	697b      	ldr	r3, [r7, #20]
}
 801b3fa:	4618      	mov	r0, r3
 801b3fc:	3718      	adds	r7, #24
 801b3fe:	46bd      	mov	sp, r7
 801b400:	bd80      	pop	{r7, pc}
 801b402:	bf00      	nop
 801b404:	20000dd4 	.word	0x20000dd4

0801b408 <setting_get_group_details>:

const setting_group_detail_t *setting_get_group_details (setting_group_t id)
{
 801b408:	b580      	push	{r7, lr}
 801b40a:	b086      	sub	sp, #24
 801b40c:	af00      	add	r7, sp, #0
 801b40e:	4603      	mov	r3, r0
 801b410:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t idx;
    setting_details_t *details = settings_get_details();
 801b412:	f7fd fc83 	bl	8018d1c <settings_get_details>
 801b416:	6138      	str	r0, [r7, #16]
    const setting_group_detail_t *detail = NULL;
 801b418:	2300      	movs	r3, #0
 801b41a:	60fb      	str	r3, [r7, #12]

    do {
        for(idx = 0; idx < details->n_groups; idx++) {
 801b41c:	2300      	movs	r3, #0
 801b41e:	617b      	str	r3, [r7, #20]
 801b420:	e017      	b.n	801b452 <setting_get_group_details+0x4a>
            if(details->groups[idx].id == id)
 801b422:	693b      	ldr	r3, [r7, #16]
 801b424:	6859      	ldr	r1, [r3, #4]
 801b426:	697a      	ldr	r2, [r7, #20]
 801b428:	4613      	mov	r3, r2
 801b42a:	005b      	lsls	r3, r3, #1
 801b42c:	4413      	add	r3, r2
 801b42e:	009b      	lsls	r3, r3, #2
 801b430:	440b      	add	r3, r1
 801b432:	785b      	ldrb	r3, [r3, #1]
 801b434:	79fa      	ldrb	r2, [r7, #7]
 801b436:	429a      	cmp	r2, r3
 801b438:	d108      	bne.n	801b44c <setting_get_group_details+0x44>
                detail = &details->groups[idx];
 801b43a:	693b      	ldr	r3, [r7, #16]
 801b43c:	6859      	ldr	r1, [r3, #4]
 801b43e:	697a      	ldr	r2, [r7, #20]
 801b440:	4613      	mov	r3, r2
 801b442:	005b      	lsls	r3, r3, #1
 801b444:	4413      	add	r3, r2
 801b446:	009b      	lsls	r3, r3, #2
 801b448:	440b      	add	r3, r1
 801b44a:	60fb      	str	r3, [r7, #12]
        for(idx = 0; idx < details->n_groups; idx++) {
 801b44c:	697b      	ldr	r3, [r7, #20]
 801b44e:	3301      	adds	r3, #1
 801b450:	617b      	str	r3, [r7, #20]
 801b452:	693b      	ldr	r3, [r7, #16]
 801b454:	781b      	ldrb	r3, [r3, #0]
 801b456:	461a      	mov	r2, r3
 801b458:	697b      	ldr	r3, [r7, #20]
 801b45a:	4293      	cmp	r3, r2
 801b45c:	d3e1      	bcc.n	801b422 <setting_get_group_details+0x1a>
        }
    } while(detail == NULL && (details = details->next));
 801b45e:	68fb      	ldr	r3, [r7, #12]
 801b460:	2b00      	cmp	r3, #0
 801b462:	d105      	bne.n	801b470 <setting_get_group_details+0x68>
 801b464:	693b      	ldr	r3, [r7, #16]
 801b466:	699b      	ldr	r3, [r3, #24]
 801b468:	613b      	str	r3, [r7, #16]
 801b46a:	693b      	ldr	r3, [r7, #16]
 801b46c:	2b00      	cmp	r3, #0
 801b46e:	d1d5      	bne.n	801b41c <setting_get_group_details+0x14>

    return detail;
 801b470:	68fb      	ldr	r3, [r7, #12]
}
 801b472:	4618      	mov	r0, r3
 801b474:	3718      	adds	r7, #24
 801b476:	46bd      	mov	sp, r7
 801b478:	bd80      	pop	{r7, pc}

0801b47a <validate_value>:
    return group ? group->parent : Group_Unknown;
}
*/

static status_code_t validate_value (const setting_detail_t *setting, float value)
{
 801b47a:	b590      	push	{r4, r7, lr}
 801b47c:	b085      	sub	sp, #20
 801b47e:	af00      	add	r7, sp, #0
 801b480:	6078      	str	r0, [r7, #4]
 801b482:	6039      	str	r1, [r7, #0]
    float val;
    uint_fast8_t set_idx = 0;
 801b484:	2300      	movs	r3, #0
 801b486:	60bb      	str	r3, [r7, #8]

    if(setting->min_value) {
 801b488:	687b      	ldr	r3, [r7, #4]
 801b48a:	695b      	ldr	r3, [r3, #20]
 801b48c:	2b00      	cmp	r3, #0
 801b48e:	d034      	beq.n	801b4fa <validate_value+0x80>
        if(!read_float((char *)setting->min_value, &set_idx, &val))
 801b490:	687b      	ldr	r3, [r7, #4]
 801b492:	695b      	ldr	r3, [r3, #20]
 801b494:	f107 020c 	add.w	r2, r7, #12
 801b498:	f107 0108 	add.w	r1, r7, #8
 801b49c:	4618      	mov	r0, r3
 801b49e:	f7f5 f889 	bl	80105b4 <read_float>
 801b4a2:	4603      	mov	r3, r0
 801b4a4:	f083 0301 	eor.w	r3, r3, #1
 801b4a8:	b2db      	uxtb	r3, r3
 801b4aa:	2b00      	cmp	r3, #0
 801b4ac:	d001      	beq.n	801b4b2 <validate_value+0x38>
            return Status_BadNumberFormat;
 801b4ae:	2302      	movs	r3, #2
 801b4b0:	e04f      	b.n	801b552 <validate_value+0xd8>

        if(!(value >= val || (setting->flags.allow_null && value == 0.0f)))
 801b4b2:	68fb      	ldr	r3, [r7, #12]
 801b4b4:	2201      	movs	r2, #1
 801b4b6:	4614      	mov	r4, r2
 801b4b8:	4619      	mov	r1, r3
 801b4ba:	6838      	ldr	r0, [r7, #0]
 801b4bc:	f7e5 fe2c 	bl	8001118 <__aeabi_fcmpge>
 801b4c0:	4603      	mov	r3, r0
 801b4c2:	2b00      	cmp	r3, #0
 801b4c4:	d101      	bne.n	801b4ca <validate_value+0x50>
 801b4c6:	2300      	movs	r3, #0
 801b4c8:	461c      	mov	r4, r3
 801b4ca:	b2e3      	uxtb	r3, r4
 801b4cc:	f083 0301 	eor.w	r3, r3, #1
 801b4d0:	b2db      	uxtb	r3, r3
 801b4d2:	2b00      	cmp	r3, #0
 801b4d4:	d01b      	beq.n	801b50e <validate_value+0x94>
 801b4d6:	687b      	ldr	r3, [r7, #4]
 801b4d8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801b4dc:	f003 0302 	and.w	r3, r3, #2
 801b4e0:	b2db      	uxtb	r3, r3
 801b4e2:	2b00      	cmp	r3, #0
 801b4e4:	d007      	beq.n	801b4f6 <validate_value+0x7c>
 801b4e6:	f04f 0100 	mov.w	r1, #0
 801b4ea:	6838      	ldr	r0, [r7, #0]
 801b4ec:	f7e5 fdf6 	bl	80010dc <__aeabi_fcmpeq>
 801b4f0:	4603      	mov	r3, r0
 801b4f2:	2b00      	cmp	r3, #0
 801b4f4:	d10b      	bne.n	801b50e <validate_value+0x94>
            return Status_SettingValueOutOfRange;
 801b4f6:	2334      	movs	r3, #52	; 0x34
 801b4f8:	e02b      	b.n	801b552 <validate_value+0xd8>

    } else if(value < 0.0f)
 801b4fa:	f04f 0100 	mov.w	r1, #0
 801b4fe:	6838      	ldr	r0, [r7, #0]
 801b500:	f7e5 fdf6 	bl	80010f0 <__aeabi_fcmplt>
 801b504:	4603      	mov	r3, r0
 801b506:	2b00      	cmp	r3, #0
 801b508:	d001      	beq.n	801b50e <validate_value+0x94>
        return Status_NegativeValue;
 801b50a:	2304      	movs	r3, #4
 801b50c:	e021      	b.n	801b552 <validate_value+0xd8>

    if(setting->max_value) {
 801b50e:	687b      	ldr	r3, [r7, #4]
 801b510:	699b      	ldr	r3, [r3, #24]
 801b512:	2b00      	cmp	r3, #0
 801b514:	d01c      	beq.n	801b550 <validate_value+0xd6>
        set_idx = 0;
 801b516:	2300      	movs	r3, #0
 801b518:	60bb      	str	r3, [r7, #8]

        if(!read_float((char *)setting->max_value, &set_idx, &val))
 801b51a:	687b      	ldr	r3, [r7, #4]
 801b51c:	699b      	ldr	r3, [r3, #24]
 801b51e:	f107 020c 	add.w	r2, r7, #12
 801b522:	f107 0108 	add.w	r1, r7, #8
 801b526:	4618      	mov	r0, r3
 801b528:	f7f5 f844 	bl	80105b4 <read_float>
 801b52c:	4603      	mov	r3, r0
 801b52e:	f083 0301 	eor.w	r3, r3, #1
 801b532:	b2db      	uxtb	r3, r3
 801b534:	2b00      	cmp	r3, #0
 801b536:	d001      	beq.n	801b53c <validate_value+0xc2>
            return Status_BadNumberFormat;
 801b538:	2302      	movs	r3, #2
 801b53a:	e00a      	b.n	801b552 <validate_value+0xd8>

        if(value > val)
 801b53c:	68fb      	ldr	r3, [r7, #12]
 801b53e:	4619      	mov	r1, r3
 801b540:	6838      	ldr	r0, [r7, #0]
 801b542:	f7e5 fdf3 	bl	800112c <__aeabi_fcmpgt>
 801b546:	4603      	mov	r3, r0
 801b548:	2b00      	cmp	r3, #0
 801b54a:	d001      	beq.n	801b550 <validate_value+0xd6>
            return Status_SettingValueOutOfRange;
 801b54c:	2334      	movs	r3, #52	; 0x34
 801b54e:	e000      	b.n	801b552 <validate_value+0xd8>
    }

    return Status_OK;
 801b550:	2300      	movs	r3, #0
}
 801b552:	4618      	mov	r0, r3
 801b554:	3714      	adds	r7, #20
 801b556:	46bd      	mov	sp, r7
 801b558:	bd90      	pop	{r4, r7, pc}

0801b55a <validate_uint_value>:

static status_code_t validate_uint_value (const setting_detail_t *setting, uint32_t value)
{
 801b55a:	b580      	push	{r7, lr}
 801b55c:	b086      	sub	sp, #24
 801b55e:	af00      	add	r7, sp, #0
 801b560:	6078      	str	r0, [r7, #4]
 801b562:	6039      	str	r1, [r7, #0]
    uint32_t val;
    uint_fast8_t set_idx = 0;
 801b564:	2300      	movs	r3, #0
 801b566:	60fb      	str	r3, [r7, #12]
    status_code_t status;

    if(setting->min_value) {
 801b568:	687b      	ldr	r3, [r7, #4]
 801b56a:	695b      	ldr	r3, [r3, #20]
 801b56c:	2b00      	cmp	r3, #0
 801b56e:	d020      	beq.n	801b5b2 <validate_uint_value+0x58>
        if((status = read_uint((char *)setting->min_value, &set_idx, &val)) != Status_OK)
 801b570:	687b      	ldr	r3, [r7, #4]
 801b572:	695b      	ldr	r3, [r3, #20]
 801b574:	f107 0210 	add.w	r2, r7, #16
 801b578:	f107 010c 	add.w	r1, r7, #12
 801b57c:	4618      	mov	r0, r3
 801b57e:	f7f4 ff87 	bl	8010490 <read_uint>
 801b582:	4603      	mov	r3, r0
 801b584:	75fb      	strb	r3, [r7, #23]
 801b586:	7dfb      	ldrb	r3, [r7, #23]
 801b588:	2b00      	cmp	r3, #0
 801b58a:	d001      	beq.n	801b590 <validate_uint_value+0x36>
            return status;
 801b58c:	7dfb      	ldrb	r3, [r7, #23]
 801b58e:	e02d      	b.n	801b5ec <validate_uint_value+0x92>

        if(!(value >= val || (setting->flags.allow_null && value == 0)))
 801b590:	693b      	ldr	r3, [r7, #16]
 801b592:	683a      	ldr	r2, [r7, #0]
 801b594:	429a      	cmp	r2, r3
 801b596:	d20c      	bcs.n	801b5b2 <validate_uint_value+0x58>
 801b598:	687b      	ldr	r3, [r7, #4]
 801b59a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801b59e:	f003 0302 	and.w	r3, r3, #2
 801b5a2:	b2db      	uxtb	r3, r3
 801b5a4:	2b00      	cmp	r3, #0
 801b5a6:	d002      	beq.n	801b5ae <validate_uint_value+0x54>
 801b5a8:	683b      	ldr	r3, [r7, #0]
 801b5aa:	2b00      	cmp	r3, #0
 801b5ac:	d001      	beq.n	801b5b2 <validate_uint_value+0x58>
            return Status_SettingValueOutOfRange;
 801b5ae:	2334      	movs	r3, #52	; 0x34
 801b5b0:	e01c      	b.n	801b5ec <validate_uint_value+0x92>

    } else if(value < 0.0f)
        return Status_NegativeValue;

    if(setting->max_value) {
 801b5b2:	687b      	ldr	r3, [r7, #4]
 801b5b4:	699b      	ldr	r3, [r3, #24]
 801b5b6:	2b00      	cmp	r3, #0
 801b5b8:	d017      	beq.n	801b5ea <validate_uint_value+0x90>
        set_idx = 0;
 801b5ba:	2300      	movs	r3, #0
 801b5bc:	60fb      	str	r3, [r7, #12]

        if((status = read_uint((char *)setting->max_value, &set_idx, &val)) != Status_OK)
 801b5be:	687b      	ldr	r3, [r7, #4]
 801b5c0:	699b      	ldr	r3, [r3, #24]
 801b5c2:	f107 0210 	add.w	r2, r7, #16
 801b5c6:	f107 010c 	add.w	r1, r7, #12
 801b5ca:	4618      	mov	r0, r3
 801b5cc:	f7f4 ff60 	bl	8010490 <read_uint>
 801b5d0:	4603      	mov	r3, r0
 801b5d2:	75fb      	strb	r3, [r7, #23]
 801b5d4:	7dfb      	ldrb	r3, [r7, #23]
 801b5d6:	2b00      	cmp	r3, #0
 801b5d8:	d001      	beq.n	801b5de <validate_uint_value+0x84>
            return Status_BadNumberFormat;
 801b5da:	2302      	movs	r3, #2
 801b5dc:	e006      	b.n	801b5ec <validate_uint_value+0x92>

        if(value > val)
 801b5de:	693b      	ldr	r3, [r7, #16]
 801b5e0:	683a      	ldr	r2, [r7, #0]
 801b5e2:	429a      	cmp	r2, r3
 801b5e4:	d901      	bls.n	801b5ea <validate_uint_value+0x90>
            return Status_SettingValueOutOfRange;
 801b5e6:	2334      	movs	r3, #52	; 0x34
 801b5e8:	e000      	b.n	801b5ec <validate_uint_value+0x92>
    }

    return Status_OK;
 801b5ea:	2300      	movs	r3, #0
}
 801b5ec:	4618      	mov	r0, r3
 801b5ee:	3718      	adds	r7, #24
 801b5f0:	46bd      	mov	sp, r7
 801b5f2:	bd80      	pop	{r7, pc}

0801b5f4 <strnumentries>:

static uint32_t strnumentries (const char *s, const char delimiter)
{
 801b5f4:	b580      	push	{r7, lr}
 801b5f6:	b084      	sub	sp, #16
 801b5f8:	af00      	add	r7, sp, #0
 801b5fa:	6078      	str	r0, [r7, #4]
 801b5fc:	460b      	mov	r3, r1
 801b5fe:	70fb      	strb	r3, [r7, #3]
    if(s == NULL || *s == '\0')
 801b600:	687b      	ldr	r3, [r7, #4]
 801b602:	2b00      	cmp	r3, #0
 801b604:	d003      	beq.n	801b60e <strnumentries+0x1a>
 801b606:	687b      	ldr	r3, [r7, #4]
 801b608:	781b      	ldrb	r3, [r3, #0]
 801b60a:	2b00      	cmp	r3, #0
 801b60c:	d101      	bne.n	801b612 <strnumentries+0x1e>
        return 0;
 801b60e:	2300      	movs	r3, #0
 801b610:	e014      	b.n	801b63c <strnumentries+0x48>

    char *p = (char *)s;
 801b612:	687b      	ldr	r3, [r7, #4]
 801b614:	60fb      	str	r3, [r7, #12]
    uint32_t entries = 1;
 801b616:	2301      	movs	r3, #1
 801b618:	60bb      	str	r3, [r7, #8]

    while((p = strchr(p, delimiter))) {
 801b61a:	e005      	b.n	801b628 <strnumentries+0x34>
        p++;
 801b61c:	68fb      	ldr	r3, [r7, #12]
 801b61e:	3301      	adds	r3, #1
 801b620:	60fb      	str	r3, [r7, #12]
        entries++;
 801b622:	68bb      	ldr	r3, [r7, #8]
 801b624:	3301      	adds	r3, #1
 801b626:	60bb      	str	r3, [r7, #8]
    while((p = strchr(p, delimiter))) {
 801b628:	78fb      	ldrb	r3, [r7, #3]
 801b62a:	4619      	mov	r1, r3
 801b62c:	68f8      	ldr	r0, [r7, #12]
 801b62e:	f008 fb09 	bl	8023c44 <strchr>
 801b632:	60f8      	str	r0, [r7, #12]
 801b634:	68fb      	ldr	r3, [r7, #12]
 801b636:	2b00      	cmp	r3, #0
 801b638:	d1f0      	bne.n	801b61c <strnumentries+0x28>
    }

    return entries;
 801b63a:	68bb      	ldr	r3, [r7, #8]
}
 801b63c:	4618      	mov	r0, r3
 801b63e:	3710      	adds	r7, #16
 801b640:	46bd      	mov	sp, r7
 801b642:	bd80      	pop	{r7, pc}

0801b644 <setting_datatype_to_external>:

setting_datatype_t setting_datatype_to_external (setting_datatype_t datatype)
{
 801b644:	b480      	push	{r7}
 801b646:	b083      	sub	sp, #12
 801b648:	af00      	add	r7, sp, #0
 801b64a:	4603      	mov	r3, r0
 801b64c:	71fb      	strb	r3, [r7, #7]
    switch(datatype) {
 801b64e:	79fb      	ldrb	r3, [r7, #7]
 801b650:	3b0a      	subs	r3, #10
 801b652:	2b01      	cmp	r3, #1
 801b654:	d802      	bhi.n	801b65c <setting_datatype_to_external+0x18>

        case Format_Int8:
        case Format_Int16:
            datatype = Format_Integer;
 801b656:	2305      	movs	r3, #5
 801b658:	71fb      	strb	r3, [r7, #7]
            break;
 801b65a:	e000      	b.n	801b65e <setting_datatype_to_external+0x1a>

        default:
            break;
 801b65c:	bf00      	nop
    }

    return datatype;
 801b65e:	79fb      	ldrb	r3, [r7, #7]
}
 801b660:	4618      	mov	r0, r3
 801b662:	370c      	adds	r7, #12
 801b664:	46bd      	mov	sp, r7
 801b666:	bc80      	pop	{r7}
 801b668:	4770      	bx	lr

0801b66a <setting_is_list>:

bool setting_is_list (const setting_detail_t *setting)
{
 801b66a:	b480      	push	{r7}
 801b66c:	b083      	sub	sp, #12
 801b66e:	af00      	add	r7, sp, #0
 801b670:	6078      	str	r0, [r7, #4]
    return setting->datatype == Format_Bitfield || setting->datatype == Format_XBitfield || setting->datatype == Format_RadioButtons;
 801b672:	687b      	ldr	r3, [r7, #4]
 801b674:	7b1b      	ldrb	r3, [r3, #12]
 801b676:	2b01      	cmp	r3, #1
 801b678:	d007      	beq.n	801b68a <setting_is_list+0x20>
 801b67a:	687b      	ldr	r3, [r7, #4]
 801b67c:	7b1b      	ldrb	r3, [r3, #12]
 801b67e:	2b02      	cmp	r3, #2
 801b680:	d003      	beq.n	801b68a <setting_is_list+0x20>
 801b682:	687b      	ldr	r3, [r7, #4]
 801b684:	7b1b      	ldrb	r3, [r3, #12]
 801b686:	2b03      	cmp	r3, #3
 801b688:	d101      	bne.n	801b68e <setting_is_list+0x24>
 801b68a:	2301      	movs	r3, #1
 801b68c:	e000      	b.n	801b690 <setting_is_list+0x26>
 801b68e:	2300      	movs	r3, #0
 801b690:	f003 0301 	and.w	r3, r3, #1
 801b694:	b2db      	uxtb	r3, r3
}
 801b696:	4618      	mov	r0, r3
 801b698:	370c      	adds	r7, #12
 801b69a:	46bd      	mov	sp, r7
 801b69c:	bc80      	pop	{r7}
 801b69e:	4770      	bx	lr

0801b6a0 <remove_element>:
{
    return setting->datatype == Format_Integer || setting->datatype == Format_Int8 || setting->datatype == Format_Int16;
}

static char *remove_element (char *s, uint_fast8_t entry)
{
 801b6a0:	b480      	push	{r7}
 801b6a2:	b085      	sub	sp, #20
 801b6a4:	af00      	add	r7, sp, #0
 801b6a6:	6078      	str	r0, [r7, #4]
 801b6a8:	6039      	str	r1, [r7, #0]
    while(entry && *s) {
 801b6aa:	e009      	b.n	801b6c0 <remove_element+0x20>
        if(*s == ',')
 801b6ac:	687b      	ldr	r3, [r7, #4]
 801b6ae:	781b      	ldrb	r3, [r3, #0]
 801b6b0:	2b2c      	cmp	r3, #44	; 0x2c
 801b6b2:	d102      	bne.n	801b6ba <remove_element+0x1a>
            entry--;
 801b6b4:	683b      	ldr	r3, [r7, #0]
 801b6b6:	3b01      	subs	r3, #1
 801b6b8:	603b      	str	r3, [r7, #0]
        s++;
 801b6ba:	687b      	ldr	r3, [r7, #4]
 801b6bc:	3301      	adds	r3, #1
 801b6be:	607b      	str	r3, [r7, #4]
    while(entry && *s) {
 801b6c0:	683b      	ldr	r3, [r7, #0]
 801b6c2:	2b00      	cmp	r3, #0
 801b6c4:	d003      	beq.n	801b6ce <remove_element+0x2e>
 801b6c6:	687b      	ldr	r3, [r7, #4]
 801b6c8:	781b      	ldrb	r3, [r3, #0]
 801b6ca:	2b00      	cmp	r3, #0
 801b6cc:	d1ee      	bne.n	801b6ac <remove_element+0xc>
    }

    if(entry == 0) {
 801b6ce:	683b      	ldr	r3, [r7, #0]
 801b6d0:	2b00      	cmp	r3, #0
 801b6d2:	d12c      	bne.n	801b72e <remove_element+0x8e>
        *s++ = 'N';
 801b6d4:	687b      	ldr	r3, [r7, #4]
 801b6d6:	1c5a      	adds	r2, r3, #1
 801b6d8:	607a      	str	r2, [r7, #4]
 801b6da:	224e      	movs	r2, #78	; 0x4e
 801b6dc:	701a      	strb	r2, [r3, #0]
        *s++ = '/';
 801b6de:	687b      	ldr	r3, [r7, #4]
 801b6e0:	1c5a      	adds	r2, r3, #1
 801b6e2:	607a      	str	r2, [r7, #4]
 801b6e4:	222f      	movs	r2, #47	; 0x2f
 801b6e6:	701a      	strb	r2, [r3, #0]
        *s++ = 'A';
 801b6e8:	687b      	ldr	r3, [r7, #4]
 801b6ea:	1c5a      	adds	r2, r3, #1
 801b6ec:	607a      	str	r2, [r7, #4]
 801b6ee:	2241      	movs	r2, #65	; 0x41
 801b6f0:	701a      	strb	r2, [r3, #0]
        char *s2 = s;
 801b6f2:	687b      	ldr	r3, [r7, #4]
 801b6f4:	60fb      	str	r3, [r7, #12]
        while(*s2 && *s2 != ',')
 801b6f6:	e002      	b.n	801b6fe <remove_element+0x5e>
            s2++;
 801b6f8:	68fb      	ldr	r3, [r7, #12]
 801b6fa:	3301      	adds	r3, #1
 801b6fc:	60fb      	str	r3, [r7, #12]
        while(*s2 && *s2 != ',')
 801b6fe:	68fb      	ldr	r3, [r7, #12]
 801b700:	781b      	ldrb	r3, [r3, #0]
 801b702:	2b00      	cmp	r3, #0
 801b704:	d00c      	beq.n	801b720 <remove_element+0x80>
 801b706:	68fb      	ldr	r3, [r7, #12]
 801b708:	781b      	ldrb	r3, [r3, #0]
 801b70a:	2b2c      	cmp	r3, #44	; 0x2c
 801b70c:	d1f4      	bne.n	801b6f8 <remove_element+0x58>
        while(*s2)
 801b70e:	e007      	b.n	801b720 <remove_element+0x80>
            *s++ = *s2++;
 801b710:	68fa      	ldr	r2, [r7, #12]
 801b712:	1c53      	adds	r3, r2, #1
 801b714:	60fb      	str	r3, [r7, #12]
 801b716:	687b      	ldr	r3, [r7, #4]
 801b718:	1c59      	adds	r1, r3, #1
 801b71a:	6079      	str	r1, [r7, #4]
 801b71c:	7812      	ldrb	r2, [r2, #0]
 801b71e:	701a      	strb	r2, [r3, #0]
        while(*s2)
 801b720:	68fb      	ldr	r3, [r7, #12]
 801b722:	781b      	ldrb	r3, [r3, #0]
 801b724:	2b00      	cmp	r3, #0
 801b726:	d1f3      	bne.n	801b710 <remove_element+0x70>
        *s = '\0';
 801b728:	687b      	ldr	r3, [r7, #4]
 801b72a:	2200      	movs	r2, #0
 801b72c:	701a      	strb	r2, [r3, #0]
    }

    return s;
 801b72e:	687b      	ldr	r3, [r7, #4]
}
 801b730:	4618      	mov	r0, r3
 801b732:	3714      	adds	r7, #20
 801b734:	46bd      	mov	sp, r7
 801b736:	bc80      	pop	{r7}
 801b738:	4770      	bx	lr

0801b73a <setting_remove_element>:

static void setting_remove_element (setting_id_t id, uint_fast8_t pos)
{
 801b73a:	b580      	push	{r7, lr}
 801b73c:	b084      	sub	sp, #16
 801b73e:	af00      	add	r7, sp, #0
 801b740:	4603      	mov	r3, r0
 801b742:	6039      	str	r1, [r7, #0]
 801b744:	80fb      	strh	r3, [r7, #6]
    const setting_detail_t *setting = setting_get_details(id, NULL);
 801b746:	88fb      	ldrh	r3, [r7, #6]
 801b748:	2100      	movs	r1, #0
 801b74a:	4618      	mov	r0, r3
 801b74c:	f7ff fd64 	bl	801b218 <setting_get_details>
 801b750:	60f8      	str	r0, [r7, #12]

    if(setting && setting_is_list(setting))
 801b752:	68fb      	ldr	r3, [r7, #12]
 801b754:	2b00      	cmp	r3, #0
 801b756:	d00b      	beq.n	801b770 <setting_remove_element+0x36>
 801b758:	68f8      	ldr	r0, [r7, #12]
 801b75a:	f7ff ff86 	bl	801b66a <setting_is_list>
 801b75e:	4603      	mov	r3, r0
 801b760:	2b00      	cmp	r3, #0
 801b762:	d005      	beq.n	801b770 <setting_remove_element+0x36>
        remove_element((char *)setting->format, pos);
 801b764:	68fb      	ldr	r3, [r7, #12]
 801b766:	691b      	ldr	r3, [r3, #16]
 801b768:	6839      	ldr	r1, [r7, #0]
 801b76a:	4618      	mov	r0, r3
 801b76c:	f7ff ff98 	bl	801b6a0 <remove_element>
}
 801b770:	bf00      	nop
 801b772:	3710      	adds	r7, #16
 801b774:	46bd      	mov	sp, r7
 801b776:	bd80      	pop	{r7, pc}

0801b778 <setting_remove_elements>:

// Flag setting elements for bitfields as N/A according to a mask
// Note: setting format string has to reside in RAM.
void setting_remove_elements (setting_id_t id, uint32_t mask)
{
 801b778:	b580      	push	{r7, lr}
 801b77a:	b086      	sub	sp, #24
 801b77c:	af00      	add	r7, sp, #0
 801b77e:	4603      	mov	r3, r0
 801b780:	6039      	str	r1, [r7, #0]
 801b782:	80fb      	strh	r3, [r7, #6]
    char *format = (char *)setting_get_details(id, NULL)->format, *s;
 801b784:	88fb      	ldrh	r3, [r7, #6]
 801b786:	2100      	movs	r1, #0
 801b788:	4618      	mov	r0, r3
 801b78a:	f7ff fd45 	bl	801b218 <setting_get_details>
 801b78e:	4603      	mov	r3, r0
 801b790:	691b      	ldr	r3, [r3, #16]
 801b792:	613b      	str	r3, [r7, #16]
    uint_fast8_t idx, entries = strnumentries(format, ',');
 801b794:	212c      	movs	r1, #44	; 0x2c
 801b796:	6938      	ldr	r0, [r7, #16]
 801b798:	f7ff ff2c 	bl	801b5f4 <strnumentries>
 801b79c:	60f8      	str	r0, [r7, #12]

    for(idx = 0; idx < entries; idx++ ) {
 801b79e:	2300      	movs	r3, #0
 801b7a0:	617b      	str	r3, [r7, #20]
 801b7a2:	e00f      	b.n	801b7c4 <setting_remove_elements+0x4c>
        if(!(mask & 0x1))
 801b7a4:	683b      	ldr	r3, [r7, #0]
 801b7a6:	f003 0301 	and.w	r3, r3, #1
 801b7aa:	2b00      	cmp	r3, #0
 801b7ac:	d104      	bne.n	801b7b8 <setting_remove_elements+0x40>
            setting_remove_element(id, idx);
 801b7ae:	88fb      	ldrh	r3, [r7, #6]
 801b7b0:	6979      	ldr	r1, [r7, #20]
 801b7b2:	4618      	mov	r0, r3
 801b7b4:	f7ff ffc1 	bl	801b73a <setting_remove_element>
        mask >>= 1;
 801b7b8:	683b      	ldr	r3, [r7, #0]
 801b7ba:	085b      	lsrs	r3, r3, #1
 801b7bc:	603b      	str	r3, [r7, #0]
    for(idx = 0; idx < entries; idx++ ) {
 801b7be:	697b      	ldr	r3, [r7, #20]
 801b7c0:	3301      	adds	r3, #1
 801b7c2:	617b      	str	r3, [r7, #20]
 801b7c4:	697a      	ldr	r2, [r7, #20]
 801b7c6:	68fb      	ldr	r3, [r7, #12]
 801b7c8:	429a      	cmp	r2, r3
 801b7ca:	d3eb      	bcc.n	801b7a4 <setting_remove_elements+0x2c>
    }

    // Strip trailing N/A's
    while((s = strrchr(format, ','))) {
 801b7cc:	e00a      	b.n	801b7e4 <setting_remove_elements+0x6c>
        if(strncmp(s, ",N/A", 4))
 801b7ce:	2204      	movs	r2, #4
 801b7d0:	490b      	ldr	r1, [pc, #44]	; (801b800 <setting_remove_elements+0x88>)
 801b7d2:	68b8      	ldr	r0, [r7, #8]
 801b7d4:	f008 fa43 	bl	8023c5e <strncmp>
 801b7d8:	4603      	mov	r3, r0
 801b7da:	2b00      	cmp	r3, #0
 801b7dc:	d10b      	bne.n	801b7f6 <setting_remove_elements+0x7e>
            break;
        *s = '\0';
 801b7de:	68bb      	ldr	r3, [r7, #8]
 801b7e0:	2200      	movs	r2, #0
 801b7e2:	701a      	strb	r2, [r3, #0]
    while((s = strrchr(format, ','))) {
 801b7e4:	212c      	movs	r1, #44	; 0x2c
 801b7e6:	6938      	ldr	r0, [r7, #16]
 801b7e8:	f008 fa5e 	bl	8023ca8 <strrchr>
 801b7ec:	60b8      	str	r0, [r7, #8]
 801b7ee:	68bb      	ldr	r3, [r7, #8]
 801b7f0:	2b00      	cmp	r3, #0
 801b7f2:	d1ec      	bne.n	801b7ce <setting_remove_elements+0x56>
    }
}
 801b7f4:	e000      	b.n	801b7f8 <setting_remove_elements+0x80>
            break;
 801b7f6:	bf00      	nop
}
 801b7f8:	bf00      	nop
 801b7fa:	3718      	adds	r7, #24
 801b7fc:	46bd      	mov	sp, r7
 801b7fe:	bd80      	pop	{r7, pc}
 801b800:	0802ea54 	.word	0x0802ea54

0801b804 <setting_is_string>:

inline static bool setting_is_string (setting_datatype_t  datatype)
{
 801b804:	b480      	push	{r7}
 801b806:	b083      	sub	sp, #12
 801b808:	af00      	add	r7, sp, #0
 801b80a:	4603      	mov	r3, r0
 801b80c:	71fb      	strb	r3, [r7, #7]
    return datatype == Format_String || datatype == Format_Password || datatype == Format_IPv4;
 801b80e:	79fb      	ldrb	r3, [r7, #7]
 801b810:	2b07      	cmp	r3, #7
 801b812:	d005      	beq.n	801b820 <setting_is_string+0x1c>
 801b814:	79fb      	ldrb	r3, [r7, #7]
 801b816:	2b08      	cmp	r3, #8
 801b818:	d002      	beq.n	801b820 <setting_is_string+0x1c>
 801b81a:	79fb      	ldrb	r3, [r7, #7]
 801b81c:	2b09      	cmp	r3, #9
 801b81e:	d101      	bne.n	801b824 <setting_is_string+0x20>
 801b820:	2301      	movs	r3, #1
 801b822:	e000      	b.n	801b826 <setting_is_string+0x22>
 801b824:	2300      	movs	r3, #0
 801b826:	f003 0301 	and.w	r3, r3, #1
 801b82a:	b2db      	uxtb	r3, r3
}
 801b82c:	4618      	mov	r0, r3
 801b82e:	370c      	adds	r7, #12
 801b830:	46bd      	mov	sp, r7
 801b832:	bc80      	pop	{r7}
 801b834:	4770      	bx	lr

0801b836 <setting_is_core>:

inline static bool setting_is_core (setting_type_t type)
{
 801b836:	b480      	push	{r7}
 801b838:	b083      	sub	sp, #12
 801b83a:	af00      	add	r7, sp, #0
 801b83c:	4603      	mov	r3, r0
 801b83e:	71fb      	strb	r3, [r7, #7]
    return !(type == Setting_NonCore || type == Setting_NonCoreFn);
 801b840:	79fb      	ldrb	r3, [r7, #7]
 801b842:	2b00      	cmp	r3, #0
 801b844:	d004      	beq.n	801b850 <setting_is_core+0x1a>
 801b846:	79fb      	ldrb	r3, [r7, #7]
 801b848:	2b01      	cmp	r3, #1
 801b84a:	d001      	beq.n	801b850 <setting_is_core+0x1a>
 801b84c:	2301      	movs	r3, #1
 801b84e:	e000      	b.n	801b852 <setting_is_core+0x1c>
 801b850:	2300      	movs	r3, #0
 801b852:	f003 0301 	and.w	r3, r3, #1
 801b856:	b2db      	uxtb	r3, r3
}
 801b858:	4618      	mov	r0, r3
 801b85a:	370c      	adds	r7, #12
 801b85c:	46bd      	mov	sp, r7
 801b85e:	bc80      	pop	{r7}
 801b860:	4770      	bx	lr
	...

0801b864 <setting_validate_me_uint>:

static status_code_t setting_validate_me_uint (const setting_detail_t *setting, char *svalue)
{
 801b864:	b580      	push	{r7, lr}
 801b866:	b086      	sub	sp, #24
 801b868:	af00      	add	r7, sp, #0
 801b86a:	6078      	str	r0, [r7, #4]
 801b86c:	6039      	str	r1, [r7, #0]
    uint_fast8_t idx = 0;
 801b86e:	2300      	movs	r3, #0
 801b870:	613b      	str	r3, [r7, #16]
    uint32_t value;
    status_code_t status;

    if((status = read_uint(svalue, &idx, &value)) != Status_OK)
 801b872:	f107 020c 	add.w	r2, r7, #12
 801b876:	f107 0310 	add.w	r3, r7, #16
 801b87a:	4619      	mov	r1, r3
 801b87c:	6838      	ldr	r0, [r7, #0]
 801b87e:	f7f4 fe07 	bl	8010490 <read_uint>
 801b882:	4603      	mov	r3, r0
 801b884:	75fb      	strb	r3, [r7, #23]
 801b886:	7dfb      	ldrb	r3, [r7, #23]
 801b888:	2b00      	cmp	r3, #0
 801b88a:	d001      	beq.n	801b890 <setting_validate_me_uint+0x2c>
        return status;
 801b88c:	7dfb      	ldrb	r3, [r7, #23]
 801b88e:	e05c      	b.n	801b94a <setting_validate_me_uint+0xe6>

    switch(setting->datatype) {
 801b890:	687b      	ldr	r3, [r7, #4]
 801b892:	7b1b      	ldrb	r3, [r3, #12]
 801b894:	2b0b      	cmp	r3, #11
 801b896:	d84e      	bhi.n	801b936 <setting_validate_me_uint+0xd2>
 801b898:	a201      	add	r2, pc, #4	; (adr r2, 801b8a0 <setting_validate_me_uint+0x3c>)
 801b89a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b89e:	bf00      	nop
 801b8a0:	0801b8d1 	.word	0x0801b8d1
 801b8a4:	0801b8e3 	.word	0x0801b8e3
 801b8a8:	0801b8e3 	.word	0x0801b8e3
 801b8ac:	0801b901 	.word	0x0801b901
 801b8b0:	0801b91b 	.word	0x0801b91b
 801b8b4:	0801b927 	.word	0x0801b927
 801b8b8:	0801b937 	.word	0x0801b937
 801b8bc:	0801b937 	.word	0x0801b937
 801b8c0:	0801b937 	.word	0x0801b937
 801b8c4:	0801b937 	.word	0x0801b937
 801b8c8:	0801b927 	.word	0x0801b927
 801b8cc:	0801b927 	.word	0x0801b927

        case Format_Bool:
            if(!(value == 0 || value == 1))
 801b8d0:	68fb      	ldr	r3, [r7, #12]
 801b8d2:	2b00      	cmp	r3, #0
 801b8d4:	d031      	beq.n	801b93a <setting_validate_me_uint+0xd6>
 801b8d6:	68fb      	ldr	r3, [r7, #12]
 801b8d8:	2b01      	cmp	r3, #1
 801b8da:	d02e      	beq.n	801b93a <setting_validate_me_uint+0xd6>
                status = Status_SettingValueOutOfRange;
 801b8dc:	2334      	movs	r3, #52	; 0x34
 801b8de:	75fb      	strb	r3, [r7, #23]
            break;
 801b8e0:	e02b      	b.n	801b93a <setting_validate_me_uint+0xd6>

        case Format_Bitfield:
        case Format_XBitfield:;
            if(value >= (1UL << strnumentries(setting->format, ',')))
 801b8e2:	687b      	ldr	r3, [r7, #4]
 801b8e4:	691b      	ldr	r3, [r3, #16]
 801b8e6:	212c      	movs	r1, #44	; 0x2c
 801b8e8:	4618      	mov	r0, r3
 801b8ea:	f7ff fe83 	bl	801b5f4 <strnumentries>
 801b8ee:	4603      	mov	r3, r0
 801b8f0:	2201      	movs	r2, #1
 801b8f2:	409a      	lsls	r2, r3
 801b8f4:	68fb      	ldr	r3, [r7, #12]
 801b8f6:	429a      	cmp	r2, r3
 801b8f8:	d821      	bhi.n	801b93e <setting_validate_me_uint+0xda>
                status = Status_SettingValueOutOfRange;
 801b8fa:	2334      	movs	r3, #52	; 0x34
 801b8fc:	75fb      	strb	r3, [r7, #23]
            break;
 801b8fe:	e01e      	b.n	801b93e <setting_validate_me_uint+0xda>

        case Format_RadioButtons:
            if(value >= strnumentries(setting->format, ','))
 801b900:	687b      	ldr	r3, [r7, #4]
 801b902:	691b      	ldr	r3, [r3, #16]
 801b904:	212c      	movs	r1, #44	; 0x2c
 801b906:	4618      	mov	r0, r3
 801b908:	f7ff fe74 	bl	801b5f4 <strnumentries>
 801b90c:	4602      	mov	r2, r0
 801b90e:	68fb      	ldr	r3, [r7, #12]
 801b910:	429a      	cmp	r2, r3
 801b912:	d816      	bhi.n	801b942 <setting_validate_me_uint+0xde>
                status = Status_SettingValueOutOfRange;
 801b914:	2334      	movs	r3, #52	; 0x34
 801b916:	75fb      	strb	r3, [r7, #23]
            break;
 801b918:	e013      	b.n	801b942 <setting_validate_me_uint+0xde>

        case Format_AxisMask:
            if(value >= (1 << N_AXIS))
 801b91a:	68fb      	ldr	r3, [r7, #12]
 801b91c:	2b07      	cmp	r3, #7
 801b91e:	d912      	bls.n	801b946 <setting_validate_me_uint+0xe2>
                status = Status_SettingValueOutOfRange;
 801b920:	2334      	movs	r3, #52	; 0x34
 801b922:	75fb      	strb	r3, [r7, #23]
            break;
 801b924:	e00f      	b.n	801b946 <setting_validate_me_uint+0xe2>

        case Format_Int8:
        case Format_Int16:
        case Format_Integer:
            status = validate_uint_value(setting, value);
 801b926:	68fb      	ldr	r3, [r7, #12]
 801b928:	4619      	mov	r1, r3
 801b92a:	6878      	ldr	r0, [r7, #4]
 801b92c:	f7ff fe15 	bl	801b55a <validate_uint_value>
 801b930:	4603      	mov	r3, r0
 801b932:	75fb      	strb	r3, [r7, #23]
            break;
 801b934:	e008      	b.n	801b948 <setting_validate_me_uint+0xe4>

        default:
            break;
 801b936:	bf00      	nop
 801b938:	e006      	b.n	801b948 <setting_validate_me_uint+0xe4>
            break;
 801b93a:	bf00      	nop
 801b93c:	e004      	b.n	801b948 <setting_validate_me_uint+0xe4>
            break;
 801b93e:	bf00      	nop
 801b940:	e002      	b.n	801b948 <setting_validate_me_uint+0xe4>
            break;
 801b942:	bf00      	nop
 801b944:	e000      	b.n	801b948 <setting_validate_me_uint+0xe4>
            break;
 801b946:	bf00      	nop
    }

    return status;
 801b948:	7dfb      	ldrb	r3, [r7, #23]
}
 801b94a:	4618      	mov	r0, r3
 801b94c:	3718      	adds	r7, #24
 801b94e:	46bd      	mov	sp, r7
 801b950:	bd80      	pop	{r7, pc}
 801b952:	bf00      	nop

0801b954 <setting_validate_me>:

status_code_t setting_validate_me (const setting_detail_t *setting, float value, char *svalue)
{
 801b954:	b580      	push	{r7, lr}
 801b956:	b088      	sub	sp, #32
 801b958:	af00      	add	r7, sp, #0
 801b95a:	60f8      	str	r0, [r7, #12]
 801b95c:	60b9      	str	r1, [r7, #8]
 801b95e:	607a      	str	r2, [r7, #4]
    status_code_t status = Status_OK;
 801b960:	2300      	movs	r3, #0
 801b962:	77fb      	strb	r3, [r7, #31]

    switch(setting->datatype) {
 801b964:	68fb      	ldr	r3, [r7, #12]
 801b966:	7b1b      	ldrb	r3, [r3, #12]
 801b968:	2b0b      	cmp	r3, #11
 801b96a:	d85c      	bhi.n	801ba26 <setting_validate_me+0xd2>
 801b96c:	a201      	add	r2, pc, #4	; (adr r2, 801b974 <setting_validate_me+0x20>)
 801b96e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b972:	bf00      	nop
 801b974:	0801b9a5 	.word	0x0801b9a5
 801b978:	0801b9a5 	.word	0x0801b9a5
 801b97c:	0801b9a5 	.word	0x0801b9a5
 801b980:	0801b9a5 	.word	0x0801b9a5
 801b984:	0801b9a5 	.word	0x0801b9a5
 801b988:	0801b9a5 	.word	0x0801b9a5
 801b98c:	0801b9b3 	.word	0x0801b9b3
 801b990:	0801ba09 	.word	0x0801ba09
 801b994:	0801b9c1 	.word	0x0801b9c1
 801b998:	0801ba27 	.word	0x0801ba27
 801b99c:	0801b9a5 	.word	0x0801b9a5
 801b9a0:	0801b9a5 	.word	0x0801b9a5
        case Format_RadioButtons:
        case Format_AxisMask:
        case Format_Int8:
        case Format_Int16:
        case Format_Integer:
            status = setting_validate_me_uint(setting, svalue);
 801b9a4:	6879      	ldr	r1, [r7, #4]
 801b9a6:	68f8      	ldr	r0, [r7, #12]
 801b9a8:	f7ff ff5c 	bl	801b864 <setting_validate_me_uint>
 801b9ac:	4603      	mov	r3, r0
 801b9ae:	77fb      	strb	r3, [r7, #31]
            break;
 801b9b0:	e039      	b.n	801ba26 <setting_validate_me+0xd2>

        case Format_Decimal:
            status = validate_value(setting, value);
 801b9b2:	68b9      	ldr	r1, [r7, #8]
 801b9b4:	68f8      	ldr	r0, [r7, #12]
 801b9b6:	f7ff fd60 	bl	801b47a <validate_value>
 801b9ba:	4603      	mov	r3, r0
 801b9bc:	77fb      	strb	r3, [r7, #31]
            break;
 801b9be:	e032      	b.n	801ba26 <setting_validate_me+0xd2>

        case Format_Password:
            {
                uint_fast16_t len = strlen(svalue);
 801b9c0:	6878      	ldr	r0, [r7, #4]
 801b9c2:	f7e4 fc3b 	bl	800023c <strlen>
 801b9c6:	61b8      	str	r0, [r7, #24]
                if(hal.stream.state.webui_connected && len == strlen(PASSWORD_MASK) && !strcmp(PASSWORD_MASK, svalue))
 801b9c8:	4b19      	ldr	r3, [pc, #100]	; (801ba30 <setting_validate_me+0xdc>)
 801b9ca:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 801b9ce:	f003 0302 	and.w	r3, r3, #2
 801b9d2:	b2db      	uxtb	r3, r3
 801b9d4:	2b00      	cmp	r3, #0
 801b9d6:	d00c      	beq.n	801b9f2 <setting_validate_me+0x9e>
 801b9d8:	69bb      	ldr	r3, [r7, #24]
 801b9da:	2b08      	cmp	r3, #8
 801b9dc:	d109      	bne.n	801b9f2 <setting_validate_me+0x9e>
 801b9de:	6879      	ldr	r1, [r7, #4]
 801b9e0:	4814      	ldr	r0, [pc, #80]	; (801ba34 <setting_validate_me+0xe0>)
 801b9e2:	f7e4 fc21 	bl	8000228 <strcmp>
 801b9e6:	4603      	mov	r3, r0
 801b9e8:	2b00      	cmp	r3, #0
 801b9ea:	d102      	bne.n	801b9f2 <setting_validate_me+0x9e>
                    status = Status_InvalidStatement;
 801b9ec:	2303      	movs	r3, #3
 801b9ee:	77fb      	strb	r3, [r7, #31]
                else
                    status = validate_value(setting, (float)len);
            }
            break;
 801b9f0:	e019      	b.n	801ba26 <setting_validate_me+0xd2>
                    status = validate_value(setting, (float)len);
 801b9f2:	69b8      	ldr	r0, [r7, #24]
 801b9f4:	f7e5 f986 	bl	8000d04 <__aeabi_ui2f>
 801b9f8:	4603      	mov	r3, r0
 801b9fa:	4619      	mov	r1, r3
 801b9fc:	68f8      	ldr	r0, [r7, #12]
 801b9fe:	f7ff fd3c 	bl	801b47a <validate_value>
 801ba02:	4603      	mov	r3, r0
 801ba04:	77fb      	strb	r3, [r7, #31]
            break;
 801ba06:	e00e      	b.n	801ba26 <setting_validate_me+0xd2>

        case Format_String:
            {
                uint_fast16_t len = strlen(svalue);
 801ba08:	6878      	ldr	r0, [r7, #4]
 801ba0a:	f7e4 fc17 	bl	800023c <strlen>
 801ba0e:	6178      	str	r0, [r7, #20]
                status = validate_value(setting, (float)len);
 801ba10:	6978      	ldr	r0, [r7, #20]
 801ba12:	f7e5 f977 	bl	8000d04 <__aeabi_ui2f>
 801ba16:	4603      	mov	r3, r0
 801ba18:	4619      	mov	r1, r3
 801ba1a:	68f8      	ldr	r0, [r7, #12]
 801ba1c:	f7ff fd2d 	bl	801b47a <validate_value>
 801ba20:	4603      	mov	r3, r0
 801ba22:	77fb      	strb	r3, [r7, #31]
            }
            break;
 801ba24:	bf00      	nop
        case Format_IPv4:
            // handled by driver or plugin, dependent on network library
            break;
    }

    return status;
 801ba26:	7ffb      	ldrb	r3, [r7, #31]
}
 801ba28:	4618      	mov	r0, r3
 801ba2a:	3720      	adds	r7, #32
 801ba2c:	46bd      	mov	sp, r7
 801ba2e:	bd80      	pop	{r7, pc}
 801ba30:	20000ed0 	.word	0x20000ed0
 801ba34:	0802ea00 	.word	0x0802ea00

0801ba38 <settings_changed_spindle>:
    // If no details available setting could nevertheless be a valid setting id.
    return setting == NULL ? Status_OK : setting_validate_me(setting, value, svalue);
}

static bool settings_changed_spindle (void)
{
 801ba38:	b580      	push	{r7, lr}
 801ba3a:	b082      	sub	sp, #8
 801ba3c:	af00      	add	r7, sp, #0
    static spindle_settings_t spindle_settings = {0};

    bool changed;

    if((changed = memcmp(&spindle_settings, &settings.spindle, sizeof(spindle_settings_t))) != 0)
 801ba3e:	2274      	movs	r2, #116	; 0x74
 801ba40:	490c      	ldr	r1, [pc, #48]	; (801ba74 <settings_changed_spindle+0x3c>)
 801ba42:	480d      	ldr	r0, [pc, #52]	; (801ba78 <settings_changed_spindle+0x40>)
 801ba44:	f008 f8d7 	bl	8023bf6 <memcmp>
 801ba48:	4603      	mov	r3, r0
 801ba4a:	2b00      	cmp	r3, #0
 801ba4c:	bf14      	ite	ne
 801ba4e:	2301      	movne	r3, #1
 801ba50:	2300      	moveq	r3, #0
 801ba52:	71fb      	strb	r3, [r7, #7]
 801ba54:	79fb      	ldrb	r3, [r7, #7]
 801ba56:	2b00      	cmp	r3, #0
 801ba58:	d007      	beq.n	801ba6a <settings_changed_spindle+0x32>
        memcpy(&spindle_settings, &settings.spindle, sizeof(spindle_settings_t));
 801ba5a:	4a07      	ldr	r2, [pc, #28]	; (801ba78 <settings_changed_spindle+0x40>)
 801ba5c:	4b07      	ldr	r3, [pc, #28]	; (801ba7c <settings_changed_spindle+0x44>)
 801ba5e:	4610      	mov	r0, r2
 801ba60:	3374      	adds	r3, #116	; 0x74
 801ba62:	2274      	movs	r2, #116	; 0x74
 801ba64:	4619      	mov	r1, r3
 801ba66:	f008 fa32 	bl	8023ece <memcpy>

    return changed;
 801ba6a:	79fb      	ldrb	r3, [r7, #7]
}
 801ba6c:	4618      	mov	r0, r3
 801ba6e:	3708      	adds	r7, #8
 801ba70:	46bd      	mov	sp, r7
 801ba72:	bd80      	pop	{r7, pc}
 801ba74:	200014f0 	.word	0x200014f0
 801ba78:	20001660 	.word	0x20001660
 801ba7c:	2000147c 	.word	0x2000147c

0801ba80 <settings_store_setting>:

// A helper method to set settings from command line
status_code_t settings_store_setting (setting_id_t id, char *svalue)
{
 801ba80:	b590      	push	{r4, r7, lr}
 801ba82:	b08b      	sub	sp, #44	; 0x2c
 801ba84:	af00      	add	r7, sp, #0
 801ba86:	4603      	mov	r3, r0
 801ba88:	6039      	str	r1, [r7, #0]
 801ba8a:	80fb      	strh	r3, [r7, #6]
    uint_fast8_t set_idx = 0;
 801ba8c:	2300      	movs	r3, #0
 801ba8e:	61fb      	str	r3, [r7, #28]
    uint32_t int_value = 0;
 801ba90:	2300      	movs	r3, #0
 801ba92:	61bb      	str	r3, [r7, #24]
    float value = NAN;
 801ba94:	4ba1      	ldr	r3, [pc, #644]	; (801bd1c <settings_store_setting+0x29c>)
 801ba96:	617b      	str	r3, [r7, #20]
    status_code_t status = Status_OK;
 801ba98:	2300      	movs	r3, #0
 801ba9a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    setting_details_t *set;
    const setting_detail_t *setting = setting_get_details(id, &set);
 801ba9e:	f107 0210 	add.w	r2, r7, #16
 801baa2:	88fb      	ldrh	r3, [r7, #6]
 801baa4:	4611      	mov	r1, r2
 801baa6:	4618      	mov	r0, r3
 801baa8:	f7ff fbb6 	bl	801b218 <setting_get_details>
 801baac:	6238      	str	r0, [r7, #32]

    if(setting == NULL) {
 801baae:	6a3b      	ldr	r3, [r7, #32]
 801bab0:	2b00      	cmp	r3, #0
 801bab2:	d10c      	bne.n	801bace <settings_store_setting+0x4e>
        if(id == Setting_SpindlePWMBehaviour) {
 801bab4:	88fb      	ldrh	r3, [r7, #6]
 801bab6:	2b07      	cmp	r3, #7
 801bab8:	d104      	bne.n	801bac4 <settings_store_setting+0x44>
            set = &setting_details;
 801baba:	4b99      	ldr	r3, [pc, #612]	; (801bd20 <settings_store_setting+0x2a0>)
 801babc:	613b      	str	r3, [r7, #16]
            setting = &setting_detail[Setting_SpindlePWMBehaviour];
 801babe:	4b99      	ldr	r3, [pc, #612]	; (801bd24 <settings_store_setting+0x2a4>)
 801bac0:	623b      	str	r3, [r7, #32]
 801bac2:	e004      	b.n	801bace <settings_store_setting+0x4e>
        } else
            return Status_SettingDisabled;
 801bac4:	2335      	movs	r3, #53	; 0x35
 801bac6:	e124      	b.n	801bd12 <settings_store_setting+0x292>
    }

    // Trim leading spaces
    while(*svalue == ' ')
        svalue++;
 801bac8:	683b      	ldr	r3, [r7, #0]
 801baca:	3301      	adds	r3, #1
 801bacc:	603b      	str	r3, [r7, #0]
    while(*svalue == ' ')
 801bace:	683b      	ldr	r3, [r7, #0]
 801bad0:	781b      	ldrb	r3, [r3, #0]
 801bad2:	2b20      	cmp	r3, #32
 801bad4:	d0f8      	beq.n	801bac8 <settings_store_setting+0x48>

    if(setting->datatype == Format_Decimal)  {
 801bad6:	6a3b      	ldr	r3, [r7, #32]
 801bad8:	7b1b      	ldrb	r3, [r3, #12]
 801bada:	2b06      	cmp	r3, #6
 801badc:	d117      	bne.n	801bb0e <settings_store_setting+0x8e>
        if(!read_float(svalue, &set_idx, &value) && setting_is_core(setting->type))
 801bade:	f107 0214 	add.w	r2, r7, #20
 801bae2:	f107 031c 	add.w	r3, r7, #28
 801bae6:	4619      	mov	r1, r3
 801bae8:	6838      	ldr	r0, [r7, #0]
 801baea:	f7f4 fd63 	bl	80105b4 <read_float>
 801baee:	4603      	mov	r3, r0
 801baf0:	f083 0301 	eor.w	r3, r3, #1
 801baf4:	b2db      	uxtb	r3, r3
 801baf6:	2b00      	cmp	r3, #0
 801baf8:	d029      	beq.n	801bb4e <settings_store_setting+0xce>
 801bafa:	6a3b      	ldr	r3, [r7, #32]
 801bafc:	7f1b      	ldrb	r3, [r3, #28]
 801bafe:	4618      	mov	r0, r3
 801bb00:	f7ff fe99 	bl	801b836 <setting_is_core>
 801bb04:	4603      	mov	r3, r0
 801bb06:	2b00      	cmp	r3, #0
 801bb08:	d021      	beq.n	801bb4e <settings_store_setting+0xce>
            return Status_BadNumberFormat;
 801bb0a:	2302      	movs	r3, #2
 801bb0c:	e101      	b.n	801bd12 <settings_store_setting+0x292>
    } else if(!setting_is_string(setting->datatype) && read_uint(svalue, &set_idx, &int_value) != Status_OK && setting_is_core(setting->type))
 801bb0e:	6a3b      	ldr	r3, [r7, #32]
 801bb10:	7b1b      	ldrb	r3, [r3, #12]
 801bb12:	4618      	mov	r0, r3
 801bb14:	f7ff fe76 	bl	801b804 <setting_is_string>
 801bb18:	4603      	mov	r3, r0
 801bb1a:	f083 0301 	eor.w	r3, r3, #1
 801bb1e:	b2db      	uxtb	r3, r3
 801bb20:	2b00      	cmp	r3, #0
 801bb22:	d014      	beq.n	801bb4e <settings_store_setting+0xce>
 801bb24:	f107 0218 	add.w	r2, r7, #24
 801bb28:	f107 031c 	add.w	r3, r7, #28
 801bb2c:	4619      	mov	r1, r3
 801bb2e:	6838      	ldr	r0, [r7, #0]
 801bb30:	f7f4 fcae 	bl	8010490 <read_uint>
 801bb34:	4603      	mov	r3, r0
 801bb36:	2b00      	cmp	r3, #0
 801bb38:	d009      	beq.n	801bb4e <settings_store_setting+0xce>
 801bb3a:	6a3b      	ldr	r3, [r7, #32]
 801bb3c:	7f1b      	ldrb	r3, [r3, #28]
 801bb3e:	4618      	mov	r0, r3
 801bb40:	f7ff fe79 	bl	801b836 <setting_is_core>
 801bb44:	4603      	mov	r3, r0
 801bb46:	2b00      	cmp	r3, #0
 801bb48:	d001      	beq.n	801bb4e <settings_store_setting+0xce>
        return Status_BadNumberFormat;
 801bb4a:	2302      	movs	r3, #2
 801bb4c:	e0e1      	b.n	801bd12 <settings_store_setting+0x292>

    if((status = setting_validate_me(setting, value, svalue)) != Status_OK) {
 801bb4e:	697b      	ldr	r3, [r7, #20]
 801bb50:	683a      	ldr	r2, [r7, #0]
 801bb52:	4619      	mov	r1, r3
 801bb54:	6a38      	ldr	r0, [r7, #32]
 801bb56:	f7ff fefd 	bl	801b954 <setting_validate_me>
 801bb5a:	4603      	mov	r3, r0
 801bb5c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 801bb60:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801bb64:	2b00      	cmp	r3, #0
 801bb66:	d00c      	beq.n	801bb82 <settings_store_setting+0x102>
        if(setting == Setting_PulseMicroseconds && status == Status_SettingValueOutOfRange)
 801bb68:	6a3b      	ldr	r3, [r7, #32]
 801bb6a:	2b00      	cmp	r3, #0
 801bb6c:	d106      	bne.n	801bb7c <settings_store_setting+0xfc>
 801bb6e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801bb72:	2b34      	cmp	r3, #52	; 0x34
 801bb74:	d102      	bne.n	801bb7c <settings_store_setting+0xfc>
            status =  Status_SettingStepPulseMin;
 801bb76:	2306      	movs	r3, #6
 801bb78:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

        return status;
 801bb7c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801bb80:	e0c7      	b.n	801bd12 <settings_store_setting+0x292>
    }

    switch(setting->type) {
 801bb82:	6a3b      	ldr	r3, [r7, #32]
 801bb84:	7f1b      	ldrb	r3, [r3, #28]
 801bb86:	2b07      	cmp	r3, #7
 801bb88:	bf8c      	ite	hi
 801bb8a:	2201      	movhi	r2, #1
 801bb8c:	2200      	movls	r2, #0
 801bb8e:	b2d2      	uxtb	r2, r2
 801bb90:	2a00      	cmp	r2, #0
 801bb92:	f040 808e 	bne.w	801bcb2 <settings_store_setting+0x232>
 801bb96:	2201      	movs	r2, #1
 801bb98:	fa02 f303 	lsl.w	r3, r2, r3
 801bb9c:	f003 02aa 	and.w	r2, r3, #170	; 0xaa
 801bba0:	2a00      	cmp	r2, #0
 801bba2:	bf14      	ite	ne
 801bba4:	2201      	movne	r2, #1
 801bba6:	2200      	moveq	r2, #0
 801bba8:	b2d2      	uxtb	r2, r2
 801bbaa:	2a00      	cmp	r2, #0
 801bbac:	d153      	bne.n	801bc56 <settings_store_setting+0x1d6>
 801bbae:	f003 0355 	and.w	r3, r3, #85	; 0x55
 801bbb2:	2b00      	cmp	r3, #0
 801bbb4:	bf14      	ite	ne
 801bbb6:	2301      	movne	r3, #1
 801bbb8:	2300      	moveq	r3, #0
 801bbba:	b2db      	uxtb	r3, r3
 801bbbc:	2b00      	cmp	r3, #0
 801bbbe:	d078      	beq.n	801bcb2 <settings_store_setting+0x232>

        case Setting_NonCore:
        case Setting_IsExtended:
        case Setting_IsLegacy:
        case Setting_IsExpanded:
            switch(setting->datatype) {
 801bbc0:	6a3b      	ldr	r3, [r7, #32]
 801bbc2:	7b1b      	ldrb	r3, [r3, #12]
 801bbc4:	2b0b      	cmp	r3, #11
 801bbc6:	d841      	bhi.n	801bc4c <settings_store_setting+0x1cc>
 801bbc8:	a201      	add	r2, pc, #4	; (adr r2, 801bbd0 <settings_store_setting+0x150>)
 801bbca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bbce:	bf00      	nop
 801bbd0:	0801bc2b 	.word	0x0801bc2b
 801bbd4:	0801bc2b 	.word	0x0801bc2b
 801bbd8:	0801bc2b 	.word	0x0801bc2b
 801bbdc:	0801bc2b 	.word	0x0801bc2b
 801bbe0:	0801bc19 	.word	0x0801bc19
 801bbe4:	0801bc43 	.word	0x0801bc43
 801bbe8:	0801bc01 	.word	0x0801bc01
 801bbec:	0801bc0b 	.word	0x0801bc0b
 801bbf0:	0801bc0b 	.word	0x0801bc0b
 801bbf4:	0801bc4d 	.word	0x0801bc4d
 801bbf8:	0801bc2b 	.word	0x0801bc2b
 801bbfc:	0801bc37 	.word	0x0801bc37

                case Format_Decimal:
                    *((float *)(setting->value)) = value;
 801bc00:	6a3b      	ldr	r3, [r7, #32]
 801bc02:	6a1b      	ldr	r3, [r3, #32]
 801bc04:	697a      	ldr	r2, [r7, #20]
 801bc06:	601a      	str	r2, [r3, #0]
                    break;
 801bc08:	e024      	b.n	801bc54 <settings_store_setting+0x1d4>

                case Format_String:
                case Format_Password:
                    strcpy(((char *)(setting->value)), svalue);
 801bc0a:	6a3b      	ldr	r3, [r7, #32]
 801bc0c:	6a1b      	ldr	r3, [r3, #32]
 801bc0e:	6839      	ldr	r1, [r7, #0]
 801bc10:	4618      	mov	r0, r3
 801bc12:	f008 f954 	bl	8023ebe <strcpy>
                    break;
 801bc16:	e01d      	b.n	801bc54 <settings_store_setting+0x1d4>

                case Format_AxisMask:
                    *((uint8_t *)(setting->value)) = (uint8_t)int_value & AXES_BITMASK;
 801bc18:	69bb      	ldr	r3, [r7, #24]
 801bc1a:	b2da      	uxtb	r2, r3
 801bc1c:	6a3b      	ldr	r3, [r7, #32]
 801bc1e:	6a1b      	ldr	r3, [r3, #32]
 801bc20:	f002 0207 	and.w	r2, r2, #7
 801bc24:	b2d2      	uxtb	r2, r2
 801bc26:	701a      	strb	r2, [r3, #0]
                    break;
 801bc28:	e014      	b.n	801bc54 <settings_store_setting+0x1d4>
                case Format_Bool:
                case Format_Bitfield:
                case Format_XBitfield:
                case Format_RadioButtons:
                case Format_Int8:
                    *((uint8_t *)(setting->value)) = (uint8_t)int_value;
 801bc2a:	69ba      	ldr	r2, [r7, #24]
 801bc2c:	6a3b      	ldr	r3, [r7, #32]
 801bc2e:	6a1b      	ldr	r3, [r3, #32]
 801bc30:	b2d2      	uxtb	r2, r2
 801bc32:	701a      	strb	r2, [r3, #0]
                    break;
 801bc34:	e00e      	b.n	801bc54 <settings_store_setting+0x1d4>

                case Format_Int16:
                    *((uint16_t *)(setting->value)) = (uint16_t)int_value;
 801bc36:	69ba      	ldr	r2, [r7, #24]
 801bc38:	6a3b      	ldr	r3, [r7, #32]
 801bc3a:	6a1b      	ldr	r3, [r3, #32]
 801bc3c:	b292      	uxth	r2, r2
 801bc3e:	801a      	strh	r2, [r3, #0]
                    break;
 801bc40:	e008      	b.n	801bc54 <settings_store_setting+0x1d4>

                case Format_Integer:
                    *((uint32_t *)(setting->value)) = (uint32_t)int_value;
 801bc42:	6a3b      	ldr	r3, [r7, #32]
 801bc44:	6a1b      	ldr	r3, [r3, #32]
 801bc46:	69ba      	ldr	r2, [r7, #24]
 801bc48:	601a      	str	r2, [r3, #0]
                    break;
 801bc4a:	e003      	b.n	801bc54 <settings_store_setting+0x1d4>

                default:
                    status = Status_BadNumberFormat;
 801bc4c:	2302      	movs	r3, #2
 801bc4e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                    break;
 801bc52:	bf00      	nop
            }
            break;
 801bc54:	e02d      	b.n	801bcb2 <settings_store_setting+0x232>

        case Setting_NonCoreFn:
        case Setting_IsExtendedFn:
        case Setting_IsLegacyFn:
        case Setting_IsExpandedFn:
            switch(setting->datatype) {
 801bc56:	6a3b      	ldr	r3, [r7, #32]
 801bc58:	7b1b      	ldrb	r3, [r3, #12]
 801bc5a:	2b06      	cmp	r3, #6
 801bc5c:	d005      	beq.n	801bc6a <settings_store_setting+0x1ea>
 801bc5e:	2b06      	cmp	r3, #6
 801bc60:	db1a      	blt.n	801bc98 <settings_store_setting+0x218>
 801bc62:	3b07      	subs	r3, #7
 801bc64:	2b02      	cmp	r3, #2
 801bc66:	d817      	bhi.n	801bc98 <settings_store_setting+0x218>
 801bc68:	e00b      	b.n	801bc82 <settings_store_setting+0x202>

                case Format_Decimal:
                    status = ((setting_set_float_ptr)(setting->value))(id, value);
 801bc6a:	6a3b      	ldr	r3, [r7, #32]
 801bc6c:	6a1b      	ldr	r3, [r3, #32]
 801bc6e:	461c      	mov	r4, r3
 801bc70:	697a      	ldr	r2, [r7, #20]
 801bc72:	88fb      	ldrh	r3, [r7, #6]
 801bc74:	4611      	mov	r1, r2
 801bc76:	4618      	mov	r0, r3
 801bc78:	47a0      	blx	r4
 801bc7a:	4603      	mov	r3, r0
 801bc7c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                    break;
 801bc80:	e016      	b.n	801bcb0 <settings_store_setting+0x230>

                case Format_String:
                case Format_Password:
                case Format_IPv4:
                    status = ((setting_set_string_ptr)(setting->value))(id, svalue);
 801bc82:	6a3b      	ldr	r3, [r7, #32]
 801bc84:	6a1b      	ldr	r3, [r3, #32]
 801bc86:	461a      	mov	r2, r3
 801bc88:	88fb      	ldrh	r3, [r7, #6]
 801bc8a:	6839      	ldr	r1, [r7, #0]
 801bc8c:	4618      	mov	r0, r3
 801bc8e:	4790      	blx	r2
 801bc90:	4603      	mov	r3, r0
 801bc92:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                    break;
 801bc96:	e00b      	b.n	801bcb0 <settings_store_setting+0x230>

                default:
                    status = ((setting_set_int_ptr)(setting->value))(id, (uint_fast16_t)int_value);
 801bc98:	6a3b      	ldr	r3, [r7, #32]
 801bc9a:	6a1b      	ldr	r3, [r3, #32]
 801bc9c:	461c      	mov	r4, r3
 801bc9e:	69ba      	ldr	r2, [r7, #24]
 801bca0:	88fb      	ldrh	r3, [r7, #6]
 801bca2:	4611      	mov	r1, r2
 801bca4:	4618      	mov	r0, r3
 801bca6:	47a0      	blx	r4
 801bca8:	4603      	mov	r3, r0
 801bcaa:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
                    break;
 801bcae:	bf00      	nop
            }
            break;
 801bcb0:	bf00      	nop
    }

    if(status == Status_OK) {
 801bcb2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801bcb6:	2b00      	cmp	r3, #0
 801bcb8:	d129      	bne.n	801bd0e <settings_store_setting+0x28e>

        xbar_set_homing_source();
 801bcba:	f7e9 fd37 	bl	800572c <xbar_set_homing_source>

        if(set->save)
 801bcbe:	693b      	ldr	r3, [r7, #16]
 801bcc0:	6a1b      	ldr	r3, [r3, #32]
 801bcc2:	2b00      	cmp	r3, #0
 801bcc4:	d002      	beq.n	801bccc <settings_store_setting+0x24c>
            set->save();
 801bcc6:	693b      	ldr	r3, [r7, #16]
 801bcc8:	6a1b      	ldr	r3, [r3, #32]
 801bcca:	4798      	blx	r3

        if(set->on_changed) {
 801bccc:	693b      	ldr	r3, [r7, #16]
 801bcce:	69db      	ldr	r3, [r3, #28]
 801bcd0:	2b00      	cmp	r3, #0
 801bcd2:	d01c      	beq.n	801bd0e <settings_store_setting+0x28e>

            settings_changed_flags_t changed = {0};
 801bcd4:	2300      	movs	r3, #0
 801bcd6:	733b      	strb	r3, [r7, #12]

            changed.spindle = settings_changed_spindle() || machine_mode_changed;
 801bcd8:	f7ff feae 	bl	801ba38 <settings_changed_spindle>
 801bcdc:	4603      	mov	r3, r0
 801bcde:	2b00      	cmp	r3, #0
 801bce0:	d103      	bne.n	801bcea <settings_store_setting+0x26a>
 801bce2:	4b11      	ldr	r3, [pc, #68]	; (801bd28 <settings_store_setting+0x2a8>)
 801bce4:	781b      	ldrb	r3, [r3, #0]
 801bce6:	2b00      	cmp	r3, #0
 801bce8:	d001      	beq.n	801bcee <settings_store_setting+0x26e>
 801bcea:	2301      	movs	r3, #1
 801bcec:	e000      	b.n	801bcf0 <settings_store_setting+0x270>
 801bcee:	2300      	movs	r3, #0
 801bcf0:	f003 0301 	and.w	r3, r3, #1
 801bcf4:	b2da      	uxtb	r2, r3
 801bcf6:	7b3b      	ldrb	r3, [r7, #12]
 801bcf8:	f362 0300 	bfi	r3, r2, #0, #1
 801bcfc:	733b      	strb	r3, [r7, #12]
            machine_mode_changed = false;
 801bcfe:	4b0a      	ldr	r3, [pc, #40]	; (801bd28 <settings_store_setting+0x2a8>)
 801bd00:	2200      	movs	r2, #0
 801bd02:	701a      	strb	r2, [r3, #0]

            set->on_changed(&settings, changed);
 801bd04:	693b      	ldr	r3, [r7, #16]
 801bd06:	69db      	ldr	r3, [r3, #28]
 801bd08:	7b39      	ldrb	r1, [r7, #12]
 801bd0a:	4808      	ldr	r0, [pc, #32]	; (801bd2c <settings_store_setting+0x2ac>)
 801bd0c:	4798      	blx	r3
        }
    }

    return status;
 801bd0e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 801bd12:	4618      	mov	r0, r3
 801bd14:	372c      	adds	r7, #44	; 0x2c
 801bd16:	46bd      	mov	sp, r7
 801bd18:	bd90      	pop	{r4, r7, pc}
 801bd1a:	bf00      	nop
 801bd1c:	7fc00000 	.word	0x7fc00000
 801bd20:	20000360 	.word	0x20000360
 801bd24:	0803180c 	.word	0x0803180c
 801bd28:	200015e8 	.word	0x200015e8
 801bd2c:	2000147c 	.word	0x2000147c

0801bd30 <settings_add_spindle_type>:

bool settings_add_spindle_type (const char *type)
{
 801bd30:	b590      	push	{r4, r7, lr}
 801bd32:	b085      	sub	sp, #20
 801bd34:	af00      	add	r7, sp, #0
 801bd36:	6078      	str	r0, [r7, #4]
    bool ok;

    if((ok = strlen(spindle_types) + strlen(type) + 1 < sizeof(spindle_types))) {
 801bd38:	4815      	ldr	r0, [pc, #84]	; (801bd90 <settings_add_spindle_type+0x60>)
 801bd3a:	f7e4 fa7f 	bl	800023c <strlen>
 801bd3e:	4604      	mov	r4, r0
 801bd40:	6878      	ldr	r0, [r7, #4]
 801bd42:	f7e4 fa7b 	bl	800023c <strlen>
 801bd46:	4603      	mov	r3, r0
 801bd48:	4423      	add	r3, r4
 801bd4a:	3301      	adds	r3, #1
 801bd4c:	2b63      	cmp	r3, #99	; 0x63
 801bd4e:	bf94      	ite	ls
 801bd50:	2301      	movls	r3, #1
 801bd52:	2300      	movhi	r3, #0
 801bd54:	73fb      	strb	r3, [r7, #15]
 801bd56:	7bfb      	ldrb	r3, [r7, #15]
 801bd58:	2b00      	cmp	r3, #0
 801bd5a:	d013      	beq.n	801bd84 <settings_add_spindle_type+0x54>
        if(*spindle_types != '\0')
 801bd5c:	4b0c      	ldr	r3, [pc, #48]	; (801bd90 <settings_add_spindle_type+0x60>)
 801bd5e:	781b      	ldrb	r3, [r3, #0]
 801bd60:	2b00      	cmp	r3, #0
 801bd62:	d00b      	beq.n	801bd7c <settings_add_spindle_type+0x4c>
            strcat(spindle_types, ",");
 801bd64:	480a      	ldr	r0, [pc, #40]	; (801bd90 <settings_add_spindle_type+0x60>)
 801bd66:	f7e4 fa69 	bl	800023c <strlen>
 801bd6a:	4603      	mov	r3, r0
 801bd6c:	461a      	mov	r2, r3
 801bd6e:	4b08      	ldr	r3, [pc, #32]	; (801bd90 <settings_add_spindle_type+0x60>)
 801bd70:	4413      	add	r3, r2
 801bd72:	4908      	ldr	r1, [pc, #32]	; (801bd94 <settings_add_spindle_type+0x64>)
 801bd74:	461a      	mov	r2, r3
 801bd76:	460b      	mov	r3, r1
 801bd78:	881b      	ldrh	r3, [r3, #0]
 801bd7a:	8013      	strh	r3, [r2, #0]
        strcat(spindle_types, type);
 801bd7c:	6879      	ldr	r1, [r7, #4]
 801bd7e:	4804      	ldr	r0, [pc, #16]	; (801bd90 <settings_add_spindle_type+0x60>)
 801bd80:	f007 ff51 	bl	8023c26 <strcat>
    }

    return ok;
 801bd84:	7bfb      	ldrb	r3, [r7, #15]
}
 801bd86:	4618      	mov	r0, r3
 801bd88:	3714      	adds	r7, #20
 801bd8a:	46bd      	mov	sp, r7
 801bd8c:	bd90      	pop	{r4, r7, pc}
 801bd8e:	bf00      	nop
 801bd90:	200015ec 	.word	0x200015ec
 801bd94:	0802ea5c 	.word	0x0802ea5c

0801bd98 <settings_clear>:

// Clear settings chain
void settings_clear (void)
{
 801bd98:	b480      	push	{r7}
 801bd9a:	af00      	add	r7, sp, #0
    setting_details.next = NULL;
 801bd9c:	4b04      	ldr	r3, [pc, #16]	; (801bdb0 <settings_clear+0x18>)
 801bd9e:	2200      	movs	r2, #0
 801bda0:	619a      	str	r2, [r3, #24]
    settingsd = &setting_details;
 801bda2:	4b04      	ldr	r3, [pc, #16]	; (801bdb4 <settings_clear+0x1c>)
 801bda4:	4a02      	ldr	r2, [pc, #8]	; (801bdb0 <settings_clear+0x18>)
 801bda6:	601a      	str	r2, [r3, #0]
}
 801bda8:	bf00      	nop
 801bdaa:	46bd      	mov	sp, r7
 801bdac:	bc80      	pop	{r7}
 801bdae:	4770      	bx	lr
 801bdb0:	20000360 	.word	0x20000360
 801bdb4:	20000390 	.word	0x20000390

0801bdb8 <settings_init>:

// Initialize the config subsystem
void settings_init (void)
{
 801bdb8:	b590      	push	{r4, r7, lr}
 801bdba:	b087      	sub	sp, #28
 801bdbc:	af00      	add	r7, sp, #0
    settings_changed_flags_t changed = {0};
 801bdbe:	2300      	movs	r3, #0
 801bdc0:	733b      	strb	r3, [r7, #12]
    grbl.tool_table.read = settings_read_tool_data;
    grbl.tool_table.write = settings_write_tool_data;
    grbl.tool_table.clear = settings_clear_tool_data;
#else
    static tool_data_t tools;
    if(grbl.tool_table.tool == NULL) {
 801bdc2:	4b9e      	ldr	r3, [pc, #632]	; (801c03c <settings_init+0x284>)
 801bdc4:	69db      	ldr	r3, [r3, #28]
 801bdc6:	2b00      	cmp	r3, #0
 801bdc8:	d105      	bne.n	801bdd6 <settings_init+0x1e>
        grbl.tool_table.n_tools = 0;
 801bdca:	4b9c      	ldr	r3, [pc, #624]	; (801c03c <settings_init+0x284>)
 801bdcc:	2200      	movs	r2, #0
 801bdce:	619a      	str	r2, [r3, #24]
        grbl.tool_table.tool = &tools;
 801bdd0:	4b9a      	ldr	r3, [pc, #616]	; (801c03c <settings_init+0x284>)
 801bdd2:	4a9b      	ldr	r2, [pc, #620]	; (801c040 <settings_init+0x288>)
 801bdd4:	61da      	str	r2, [r3, #28]
    }
#endif

    if(!read_global_settings()) {
 801bdd6:	f7fe ff5f 	bl	801ac98 <read_global_settings>
 801bdda:	4603      	mov	r3, r0
 801bddc:	f083 0301 	eor.w	r3, r3, #1
 801bde0:	b2db      	uxtb	r3, r3
 801bde2:	2b00      	cmp	r3, #0
 801bde4:	d034      	beq.n	801be50 <settings_init+0x98>

        settings_restore_t settings = settings_all;
 801bde6:	2300      	movs	r3, #0
 801bde8:	713b      	strb	r3, [r7, #4]
 801bdea:	793b      	ldrb	r3, [r7, #4]
 801bdec:	f043 0301 	orr.w	r3, r3, #1
 801bdf0:	713b      	strb	r3, [r7, #4]
 801bdf2:	793b      	ldrb	r3, [r7, #4]
 801bdf4:	f043 0302 	orr.w	r3, r3, #2
 801bdf8:	713b      	strb	r3, [r7, #4]
 801bdfa:	793b      	ldrb	r3, [r7, #4]
 801bdfc:	f043 0304 	orr.w	r3, r3, #4
 801be00:	713b      	strb	r3, [r7, #4]
 801be02:	793b      	ldrb	r3, [r7, #4]
 801be04:	f043 0308 	orr.w	r3, r3, #8
 801be08:	713b      	strb	r3, [r7, #4]
 801be0a:	793b      	ldrb	r3, [r7, #4]
 801be0c:	f043 0310 	orr.w	r3, r3, #16
 801be10:	713b      	strb	r3, [r7, #4]
        settings.defaults = 1; // Ensure global settings get restored
 801be12:	793b      	ldrb	r3, [r7, #4]
 801be14:	f043 0301 	orr.w	r3, r3, #1
 801be18:	713b      	strb	r3, [r7, #4]

        if(hal.nvs.type != NVS_None)
 801be1a:	4b8a      	ldr	r3, [pc, #552]	; (801c044 <settings_init+0x28c>)
 801be1c:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 801be20:	2b00      	cmp	r3, #0
 801be22:	d003      	beq.n	801be2c <settings_init+0x74>
            grbl.report.status_message(Status_SettingReadFail);
 801be24:	4b85      	ldr	r3, [pc, #532]	; (801c03c <settings_init+0x284>)
 801be26:	689b      	ldr	r3, [r3, #8]
 801be28:	2007      	movs	r0, #7
 801be2a:	4798      	blx	r3

        settings_restore(settings); // Force restore all non-volatile storage data.
 801be2c:	7938      	ldrb	r0, [r7, #4]
 801be2e:	f7fe ffbb 	bl	801ada8 <settings_restore>
        report_init();
 801be32:	f7f8 facd 	bl	80143d0 <report_init>
#if COMPATIBILITY_LEVEL <= 1
        report_grbl_settings(true, NULL);
 801be36:	2100      	movs	r1, #0
 801be38:	2001      	movs	r0, #1
 801be3a:	f7f8 fdc9 	bl	80149d0 <report_grbl_settings>
#else
        report_grbl_settings(false, NULL);
#endif
        changed.spindle = settings_changed_spindle();
 801be3e:	f7ff fdfb 	bl	801ba38 <settings_changed_spindle>
 801be42:	4603      	mov	r3, r0
 801be44:	461a      	mov	r2, r3
 801be46:	7b3b      	ldrb	r3, [r7, #12]
 801be48:	f362 0300 	bfi	r3, r2, #0, #1
 801be4c:	733b      	strb	r3, [r7, #12]
 801be4e:	e03d      	b.n	801becc <settings_init+0x114>
    } else {

        memset(grbl.tool_table.tool, 0, sizeof(tool_data_t)); // First entry is for tools not in tool table
 801be50:	4b7a      	ldr	r3, [pc, #488]	; (801c03c <settings_init+0x284>)
 801be52:	69db      	ldr	r3, [r3, #28]
 801be54:	2214      	movs	r2, #20
 801be56:	2100      	movs	r1, #0
 801be58:	4618      	mov	r0, r3
 801be5a:	f007 fedc 	bl	8023c16 <memset>

        if(grbl.tool_table.n_tools) {
 801be5e:	4b77      	ldr	r3, [pc, #476]	; (801c03c <settings_init+0x284>)
 801be60:	699b      	ldr	r3, [r3, #24]
 801be62:	2b00      	cmp	r3, #0
 801be64:	d017      	beq.n	801be96 <settings_init+0xde>
            uint_fast8_t idx;
            for(idx = 1; idx <= grbl.tool_table.n_tools; idx++)
 801be66:	2301      	movs	r3, #1
 801be68:	617b      	str	r3, [r7, #20]
 801be6a:	e00f      	b.n	801be8c <settings_init+0xd4>
                grbl.tool_table.read(idx, &grbl.tool_table.tool[idx]);
 801be6c:	4b73      	ldr	r3, [pc, #460]	; (801c03c <settings_init+0x284>)
 801be6e:	6a1c      	ldr	r4, [r3, #32]
 801be70:	4b72      	ldr	r3, [pc, #456]	; (801c03c <settings_init+0x284>)
 801be72:	69d9      	ldr	r1, [r3, #28]
 801be74:	697a      	ldr	r2, [r7, #20]
 801be76:	4613      	mov	r3, r2
 801be78:	009b      	lsls	r3, r3, #2
 801be7a:	4413      	add	r3, r2
 801be7c:	009b      	lsls	r3, r3, #2
 801be7e:	440b      	add	r3, r1
 801be80:	4619      	mov	r1, r3
 801be82:	6978      	ldr	r0, [r7, #20]
 801be84:	47a0      	blx	r4
            for(idx = 1; idx <= grbl.tool_table.n_tools; idx++)
 801be86:	697b      	ldr	r3, [r7, #20]
 801be88:	3301      	adds	r3, #1
 801be8a:	617b      	str	r3, [r7, #20]
 801be8c:	4b6b      	ldr	r3, [pc, #428]	; (801c03c <settings_init+0x284>)
 801be8e:	699b      	ldr	r3, [r3, #24]
 801be90:	697a      	ldr	r2, [r7, #20]
 801be92:	429a      	cmp	r2, r3
 801be94:	d9ea      	bls.n	801be6c <settings_init+0xb4>
        }

        report_init();
 801be96:	f7f8 fa9b 	bl	80143d0 <report_init>

        changed.spindle = settings_changed_spindle();
 801be9a:	f7ff fdcd 	bl	801ba38 <settings_changed_spindle>
 801be9e:	4603      	mov	r3, r0
 801bea0:	461a      	mov	r2, r3
 801bea2:	7b3b      	ldrb	r3, [r7, #12]
 801bea4:	f362 0300 	bfi	r3, r2, #0, #1
 801bea8:	733b      	strb	r3, [r7, #12]

        hal.settings_changed(&settings, changed);
 801beaa:	4b66      	ldr	r3, [pc, #408]	; (801c044 <settings_init+0x28c>)
 801beac:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801beb0:	7b39      	ldrb	r1, [r7, #12]
 801beb2:	4865      	ldr	r0, [pc, #404]	; (801c048 <settings_init+0x290>)
 801beb4:	4798      	blx	r3

        if(hal.probe.configure) // Initialize probe invert mask.
 801beb6:	4b63      	ldr	r3, [pc, #396]	; (801c044 <settings_init+0x28c>)
 801beb8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801bebc:	2b00      	cmp	r3, #0
 801bebe:	d005      	beq.n	801becc <settings_init+0x114>
            hal.probe.configure(false, false);
 801bec0:	4b60      	ldr	r3, [pc, #384]	; (801c044 <settings_init+0x28c>)
 801bec2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801bec6:	2100      	movs	r1, #0
 801bec8:	2000      	movs	r0, #0
 801beca:	4798      	blx	r3
    }

    settings.offset_lock.mask &= ~0b111; // TODO: remove
 801becc:	4b5e      	ldr	r3, [pc, #376]	; (801c048 <settings_init+0x290>)
 801bece:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801bed2:	f023 0307 	bic.w	r3, r3, #7
 801bed6:	b2da      	uxtb	r2, r3
 801bed8:	4b5b      	ldr	r3, [pc, #364]	; (801c048 <settings_init+0x290>)
 801beda:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
    settings.offset_lock.mask |= settings.parking.flags.offset_lock; // TODO: remove
 801bede:	4b5a      	ldr	r3, [pc, #360]	; (801c048 <settings_init+0x290>)
 801bee0:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801bee4:	4a58      	ldr	r2, [pc, #352]	; (801c048 <settings_init+0x290>)
 801bee6:	f892 2128 	ldrb.w	r2, [r2, #296]	; 0x128
 801beea:	f3c2 1242 	ubfx	r2, r2, #5, #3
 801beee:	b2d2      	uxtb	r2, r2
 801bef0:	4313      	orrs	r3, r2
 801bef2:	b2da      	uxtb	r2, r3
 801bef4:	4b54      	ldr	r3, [pc, #336]	; (801c048 <settings_init+0x290>)
 801bef6:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101

    xbar_set_homing_source();
 801befa:	f7e9 fc17 	bl	800572c <xbar_set_homing_source>

    tmp_set_soft_limits();
 801befe:	f7fd f907 	bl	8019110 <tmp_set_soft_limits>
    tmp_set_hard_limits();
 801bf02:	f7fd f9c5 	bl	8019290 <tmp_set_hard_limits>

    if(spindle_get_count() == 0)
 801bf06:	f000 fd03 	bl	801c910 <spindle_get_count>
 801bf0a:	4603      	mov	r3, r0
 801bf0c:	2b00      	cmp	r3, #0
 801bf0e:	d101      	bne.n	801bf14 <settings_init+0x15c>
        spindle_add_null();
 801bf10:	f000 fe54 	bl	801cbbc <spindle_add_null>

    spindle_cap_t spindle_cap = spindle_get_caps(false);
 801bf14:	2000      	movs	r0, #0
 801bf16:	f000 fc41 	bl	801c79c <spindle_get_caps>
 801bf1a:	4603      	mov	r3, r0
 801bf1c:	813b      	strh	r3, [r7, #8]
    if(spindle_cap.gpio_controlled) {
 801bf1e:	7a7b      	ldrb	r3, [r7, #9]
 801bf20:	f003 0301 	and.w	r3, r3, #1
 801bf24:	b2db      	uxtb	r3, r3
 801bf26:	2b00      	cmp	r3, #0
 801bf28:	d01a      	beq.n	801bf60 <settings_init+0x1a8>

        spindle_state_t spindle_state = { .on = On };
 801bf2a:	2300      	movs	r3, #0
 801bf2c:	703b      	strb	r3, [r7, #0]
 801bf2e:	783b      	ldrb	r3, [r7, #0]
 801bf30:	f043 0301 	orr.w	r3, r3, #1
 801bf34:	703b      	strb	r3, [r7, #0]
        spindle_state.ccw = spindle_cap.direction;
 801bf36:	7a3b      	ldrb	r3, [r7, #8]
 801bf38:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801bf3c:	b2da      	uxtb	r2, r3
 801bf3e:	783b      	ldrb	r3, [r7, #0]
 801bf40:	f362 0341 	bfi	r3, r2, #1, #1
 801bf44:	703b      	strb	r3, [r7, #0]
        spindle_state.pwm = spindle_cap.pwm_invert;
 801bf46:	7a3b      	ldrb	r3, [r7, #8]
 801bf48:	f3c3 1300 	ubfx	r3, r3, #4, #1
 801bf4c:	b2da      	uxtb	r2, r3
 801bf4e:	783b      	ldrb	r3, [r7, #0]
 801bf50:	f362 0382 	bfi	r3, r2, #2, #1
 801bf54:	703b      	strb	r3, [r7, #0]

        setting_remove_elements(Setting_SpindleInvertMask, spindle_state.mask);
 801bf56:	783b      	ldrb	r3, [r7, #0]
 801bf58:	4619      	mov	r1, r3
 801bf5a:	2010      	movs	r0, #16
 801bf5c:	f7ff fc0c 	bl	801b778 <setting_remove_elements>
    }

    setting_remove_elements(Setting_ControlInvertMask, hal.signals_cap.mask);
 801bf60:	4b38      	ldr	r3, [pc, #224]	; (801c044 <settings_init+0x28c>)
 801bf62:	f8b3 31ac 	ldrh.w	r3, [r3, #428]	; 0x1ac
 801bf66:	4619      	mov	r1, r3
 801bf68:	200e      	movs	r0, #14
 801bf6a:	f7ff fc05 	bl	801b778 <setting_remove_elements>

    if(hal.stepper.get_ganged)
 801bf6e:	4b35      	ldr	r3, [pc, #212]	; (801c044 <settings_init+0x28c>)
 801bf70:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801bf74:	2b00      	cmp	r3, #0
 801bf76:	d00a      	beq.n	801bf8e <settings_init+0x1d6>
        setting_remove_elements(Setting_GangedDirInvertMask, hal.stepper.get_ganged(false).mask);
 801bf78:	4b32      	ldr	r3, [pc, #200]	; (801c044 <settings_init+0x28c>)
 801bf7a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 801bf7e:	2000      	movs	r0, #0
 801bf80:	4798      	blx	r3
 801bf82:	4603      	mov	r3, r0
 801bf84:	b2db      	uxtb	r3, r3
 801bf86:	4619      	mov	r1, r3
 801bf88:	2008      	movs	r0, #8
 801bf8a:	f7ff fbf5 	bl	801b778 <setting_remove_elements>

    if(!hal.driver_cap.mist_control)
 801bf8e:	4b2d      	ldr	r3, [pc, #180]	; (801c044 <settings_init+0x28c>)
 801bf90:	f893 31a8 	ldrb.w	r3, [r3, #424]	; 0x1a8
 801bf94:	f003 0301 	and.w	r3, r3, #1
 801bf98:	b2db      	uxtb	r3, r3
 801bf9a:	2b00      	cmp	r3, #0
 801bf9c:	d103      	bne.n	801bfa6 <settings_init+0x1ee>
        setting_remove_element(Setting_CoolantInvertMask, 1);
 801bf9e:	2101      	movs	r1, #1
 801bfa0:	200f      	movs	r0, #15
 801bfa2:	f7ff fbca 	bl	801b73a <setting_remove_element>

    setting_details_t *details = setting_details.next;
 801bfa6:	4b29      	ldr	r3, [pc, #164]	; (801c04c <settings_init+0x294>)
 801bfa8:	699b      	ldr	r3, [r3, #24]
 801bfaa:	613b      	str	r3, [r7, #16]

    if(details) do {
 801bfac:	693b      	ldr	r3, [r7, #16]
 801bfae:	2b00      	cmp	r3, #0
 801bfb0:	d015      	beq.n	801bfde <settings_init+0x226>
        if(details->load)
 801bfb2:	693b      	ldr	r3, [r7, #16]
 801bfb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801bfb6:	2b00      	cmp	r3, #0
 801bfb8:	d002      	beq.n	801bfc0 <settings_init+0x208>
            details->load();
 801bfba:	693b      	ldr	r3, [r7, #16]
 801bfbc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801bfbe:	4798      	blx	r3
        if(details->on_changed)
 801bfc0:	693b      	ldr	r3, [r7, #16]
 801bfc2:	69db      	ldr	r3, [r3, #28]
 801bfc4:	2b00      	cmp	r3, #0
 801bfc6:	d004      	beq.n	801bfd2 <settings_init+0x21a>
            details->on_changed(&settings, changed);
 801bfc8:	693b      	ldr	r3, [r7, #16]
 801bfca:	69db      	ldr	r3, [r3, #28]
 801bfcc:	7b39      	ldrb	r1, [r7, #12]
 801bfce:	481e      	ldr	r0, [pc, #120]	; (801c048 <settings_init+0x290>)
 801bfd0:	4798      	blx	r3
    } while((details = details->next));
 801bfd2:	693b      	ldr	r3, [r7, #16]
 801bfd4:	699b      	ldr	r3, [r3, #24]
 801bfd6:	613b      	str	r3, [r7, #16]
 801bfd8:	693b      	ldr	r3, [r7, #16]
 801bfda:	2b00      	cmp	r3, #0
 801bfdc:	d1e9      	bne.n	801bfb2 <settings_init+0x1fa>

    setting_details.on_changed = hal.settings_changed;
 801bfde:	4b19      	ldr	r3, [pc, #100]	; (801c044 <settings_init+0x28c>)
 801bfe0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801bfe4:	4a19      	ldr	r2, [pc, #100]	; (801c04c <settings_init+0x294>)
 801bfe6:	61d3      	str	r3, [r2, #28]

    // Sanity checks for spindle configuration
    if(settings.spindle.flags.type >= spindle_get_count())
 801bfe8:	4b17      	ldr	r3, [pc, #92]	; (801c048 <settings_init+0x290>)
 801bfea:	f893 30e7 	ldrb.w	r3, [r3, #231]	; 0xe7
 801bfee:	f3c3 0384 	ubfx	r3, r3, #2, #5
 801bff2:	b2db      	uxtb	r3, r3
 801bff4:	461c      	mov	r4, r3
 801bff6:	f000 fc8b 	bl	801c910 <spindle_get_count>
 801bffa:	4603      	mov	r3, r0
 801bffc:	429c      	cmp	r4, r3
 801bffe:	db06      	blt.n	801c00e <settings_init+0x256>
        settings.spindle.flags.type = 0;
 801c000:	4a11      	ldr	r2, [pc, #68]	; (801c048 <settings_init+0x290>)
 801c002:	f892 30e7 	ldrb.w	r3, [r2, #231]	; 0xe7
 801c006:	f36f 0386 	bfc	r3, #2, #5
 801c00a:	f882 30e7 	strb.w	r3, [r2, #231]	; 0xe7
    if(settings.offset_lock.encoder_spindle >= spindle_get_count())
 801c00e:	4b0e      	ldr	r3, [pc, #56]	; (801c048 <settings_init+0x290>)
 801c010:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801c014:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801c018:	b2db      	uxtb	r3, r3
 801c01a:	461c      	mov	r4, r3
 801c01c:	f000 fc78 	bl	801c910 <spindle_get_count>
 801c020:	4603      	mov	r3, r0
 801c022:	429c      	cmp	r4, r3
 801c024:	db06      	blt.n	801c034 <settings_init+0x27c>
        settings.offset_lock.encoder_spindle = 0;
 801c026:	4a08      	ldr	r2, [pc, #32]	; (801c048 <settings_init+0x290>)
 801c028:	f892 3101 	ldrb.w	r3, [r2, #257]	; 0x101
 801c02c:	f36f 03c7 	bfc	r3, #3, #5
 801c030:	f882 3101 	strb.w	r3, [r2, #257]	; 0x101
}
 801c034:	bf00      	nop
 801c036:	371c      	adds	r7, #28
 801c038:	46bd      	mov	sp, r7
 801c03a:	bd90      	pop	{r4, r7, pc}
 801c03c:	20000dd4 	.word	0x20000dd4
 801c040:	200016d4 	.word	0x200016d4
 801c044:	20000ed0 	.word	0x20000ed0
 801c048:	2000147c 	.word	0x2000147c
 801c04c:	20000360 	.word	0x20000360

0801c050 <fall_asleep>:
#include "state_machine.h"

static volatile bool slumber;

static void fall_asleep()
{
 801c050:	b480      	push	{r7}
 801c052:	af00      	add	r7, sp, #0
    slumber = false;
 801c054:	4b03      	ldr	r3, [pc, #12]	; (801c064 <fall_asleep+0x14>)
 801c056:	2200      	movs	r2, #0
 801c058:	701a      	strb	r2, [r3, #0]
}
 801c05a:	bf00      	nop
 801c05c:	46bd      	mov	sp, r7
 801c05e:	bc80      	pop	{r7}
 801c060:	4770      	bx	lr
 801c062:	bf00      	nop
 801c064:	200016e8 	.word	0x200016e8

0801c068 <sleep_execute>:

// Starts sleep timer if running conditions are satisfied. When elapsed, sleep mode is executed.
static void sleep_execute()
{
 801c068:	b590      	push	{r4, r7, lr}
 801c06a:	b083      	sub	sp, #12
 801c06c:	af00      	add	r7, sp, #0
    // Enable sleep timeout
    slumber = true;
 801c06e:	4b1d      	ldr	r3, [pc, #116]	; (801c0e4 <sleep_execute+0x7c>)
 801c070:	2201      	movs	r2, #1
 801c072:	701a      	strb	r2, [r3, #0]
    hal.delay_ms((uint32_t)(SLEEP_DURATION * 1000.0f * 60.0f), fall_asleep);
 801c074:	4b1c      	ldr	r3, [pc, #112]	; (801c0e8 <sleep_execute+0x80>)
 801c076:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801c078:	491c      	ldr	r1, [pc, #112]	; (801c0ec <sleep_execute+0x84>)
 801c07a:	481d      	ldr	r0, [pc, #116]	; (801c0f0 <sleep_execute+0x88>)
 801c07c:	4798      	blx	r3

    // Fetch current number of buffered characters in input stream buffer.
    uint16_t rx_initial = hal.stream.get_rx_buffer_free();
 801c07e:	4b1a      	ldr	r3, [pc, #104]	; (801c0e8 <sleep_execute+0x80>)
 801c080:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 801c084:	4798      	blx	r3
 801c086:	4603      	mov	r3, r0
 801c088:	80fb      	strh	r3, [r7, #6]

    do {
        grbl.on_execute_realtime(state_get());
 801c08a:	4b1a      	ldr	r3, [pc, #104]	; (801c0f4 <sleep_execute+0x8c>)
 801c08c:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 801c08e:	f001 fc17 	bl	801d8c0 <state_get>
 801c092:	4603      	mov	r3, r0
 801c094:	4618      	mov	r0, r3
 801c096:	47a0      	blx	r4
        // Monitor for any new input stream data or external events (queries, buttons, alarms) to exit.
        if ((hal.stream.get_rx_buffer_free() != rx_initial) || sys.rt_exec_state || sys.rt_exec_alarm ) {
 801c098:	4b13      	ldr	r3, [pc, #76]	; (801c0e8 <sleep_execute+0x80>)
 801c09a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 801c09e:	4798      	blx	r3
 801c0a0:	4603      	mov	r3, r0
 801c0a2:	461a      	mov	r2, r3
 801c0a4:	88fb      	ldrh	r3, [r7, #6]
 801c0a6:	4293      	cmp	r3, r2
 801c0a8:	d107      	bne.n	801c0ba <sleep_execute+0x52>
 801c0aa:	4b13      	ldr	r3, [pc, #76]	; (801c0f8 <sleep_execute+0x90>)
 801c0ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801c0ae:	2b00      	cmp	r3, #0
 801c0b0:	d103      	bne.n	801c0ba <sleep_execute+0x52>
 801c0b2:	4b11      	ldr	r3, [pc, #68]	; (801c0f8 <sleep_execute+0x90>)
 801c0b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801c0b6:	2b00      	cmp	r3, #0
 801c0b8:	d005      	beq.n	801c0c6 <sleep_execute+0x5e>
            // Disable sleep timeout and return to normal operation.
            hal.delay_ms(0, NULL);
 801c0ba:	4b0b      	ldr	r3, [pc, #44]	; (801c0e8 <sleep_execute+0x80>)
 801c0bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801c0be:	2100      	movs	r1, #0
 801c0c0:	2000      	movs	r0, #0
 801c0c2:	4798      	blx	r3
            return;
 801c0c4:	e00a      	b.n	801c0dc <sleep_execute+0x74>
        }
    } while(slumber);
 801c0c6:	4b07      	ldr	r3, [pc, #28]	; (801c0e4 <sleep_execute+0x7c>)
 801c0c8:	781b      	ldrb	r3, [r3, #0]
 801c0ca:	b2db      	uxtb	r3, r3
 801c0cc:	2b00      	cmp	r3, #0
 801c0ce:	d1dc      	bne.n	801c08a <sleep_execute+0x22>

    // If reached, sleep counter has expired. Execute sleep procedures.
    // Notify user that Grbl has timed out and will be parking.
    // To exit sleep, resume or reset. Either way, the job will not be recoverable.
    system_set_exec_state_flag(EXEC_SLEEP);
 801c0d0:	4b05      	ldr	r3, [pc, #20]	; (801c0e8 <sleep_execute+0x80>)
 801c0d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801c0d4:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c0d8:	4808      	ldr	r0, [pc, #32]	; (801c0fc <sleep_execute+0x94>)
 801c0da:	4798      	blx	r3
}
 801c0dc:	370c      	adds	r7, #12
 801c0de:	46bd      	mov	sp, r7
 801c0e0:	bd90      	pop	{r4, r7, pc}
 801c0e2:	bf00      	nop
 801c0e4:	200016e8 	.word	0x200016e8
 801c0e8:	20000ed0 	.word	0x20000ed0
 801c0ec:	0801c051 	.word	0x0801c051
 801c0f0:	000493e0 	.word	0x000493e0
 801c0f4:	20000dd4 	.word	0x20000dd4
 801c0f8:	20000d3c 	.word	0x20000d3c
 801c0fc:	20000d84 	.word	0x20000d84

0801c100 <sleep_check>:
// Checks running conditions for sleep. If satisfied, enables sleep timeout and executes
// sleep mode upon elapse.
// NOTE: Sleep procedures can be blocking, since Grbl isn't receiving any commands, nor moving.
// Hence, make sure any valid running state that executes the sleep timer is not one that is moving.
void sleep_check()
{
 801c100:	b580      	push	{r7, lr}
 801c102:	af00      	add	r7, sp, #0
    // The sleep execution feature will continue only if the machine is in an IDLE or HOLD state and
    // has any powered components enabled.
    // NOTE: With overrides or in laser mode, modal spindle and coolant state are not guaranteed. Need
    // to directly monitor and record running state during parking to ensure proper function.
    if (!sys.steppers_deenergize && (gc_state.modal.spindle.state.value || gc_state.modal.coolant.value)) {
 801c104:	4b19      	ldr	r3, [pc, #100]	; (801c16c <sleep_check+0x6c>)
 801c106:	799b      	ldrb	r3, [r3, #6]
 801c108:	b2db      	uxtb	r3, r3
 801c10a:	f083 0301 	eor.w	r3, r3, #1
 801c10e:	b2db      	uxtb	r3, r3
 801c110:	2b00      	cmp	r3, #0
 801c112:	d029      	beq.n	801c168 <sleep_check+0x68>
 801c114:	4b16      	ldr	r3, [pc, #88]	; (801c170 <sleep_check+0x70>)
 801c116:	7e9b      	ldrb	r3, [r3, #26]
 801c118:	2b00      	cmp	r3, #0
 801c11a:	d103      	bne.n	801c124 <sleep_check+0x24>
 801c11c:	4b14      	ldr	r3, [pc, #80]	; (801c170 <sleep_check+0x70>)
 801c11e:	7e5b      	ldrb	r3, [r3, #25]
 801c120:	2b00      	cmp	r3, #0
 801c122:	d021      	beq.n	801c168 <sleep_check+0x68>
        switch(state_get()) {
 801c124:	f001 fbcc 	bl	801d8c0 <state_get>
 801c128:	4603      	mov	r3, r0
 801c12a:	2b40      	cmp	r3, #64	; 0x40
 801c12c:	d011      	beq.n	801c152 <sleep_check+0x52>
 801c12e:	2b40      	cmp	r3, #64	; 0x40
 801c130:	d81a      	bhi.n	801c168 <sleep_check+0x68>
 801c132:	2b00      	cmp	r3, #0
 801c134:	d002      	beq.n	801c13c <sleep_check+0x3c>
 801c136:	2b10      	cmp	r3, #16
 801c138:	d003      	beq.n	801c142 <sleep_check+0x42>
                if(sys.parking_state == Parking_DoorAjar)
                    sleep_execute();
                break;
        }
    }
}
 801c13a:	e015      	b.n	801c168 <sleep_check+0x68>
                sleep_execute();
 801c13c:	f7ff ff94 	bl	801c068 <sleep_execute>
                break;
 801c140:	e012      	b.n	801c168 <sleep_check+0x68>
                if(sys.holding_state == Hold_Complete)
 801c142:	4b0a      	ldr	r3, [pc, #40]	; (801c16c <sleep_check+0x6c>)
 801c144:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801c148:	2b01      	cmp	r3, #1
 801c14a:	d10a      	bne.n	801c162 <sleep_check+0x62>
                    sleep_execute();
 801c14c:	f7ff ff8c 	bl	801c068 <sleep_execute>
                break;
 801c150:	e007      	b.n	801c162 <sleep_check+0x62>
                if(sys.parking_state == Parking_DoorAjar)
 801c152:	4b06      	ldr	r3, [pc, #24]	; (801c16c <sleep_check+0x6c>)
 801c154:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c158:	2b01      	cmp	r3, #1
 801c15a:	d104      	bne.n	801c166 <sleep_check+0x66>
                    sleep_execute();
 801c15c:	f7ff ff84 	bl	801c068 <sleep_execute>
                break;
 801c160:	e001      	b.n	801c166 <sleep_check+0x66>
                break;
 801c162:	bf00      	nop
 801c164:	e000      	b.n	801c168 <sleep_check+0x68>
                break;
 801c166:	bf00      	nop
}
 801c168:	bf00      	nop
 801c16a:	bd80      	pop	{r7, pc}
 801c16c:	20000d3c 	.word	0x20000d3c
 801c170:	20000bb0 	.word	0x20000bb0

0801c174 <spindle_activate>:
\param spindle_id spindle id of spindle to activate as a \ref spindle_id_t.
\param spindle_num spindle number to set as enabled as a \ref spindle_num_t.
\returns \a true if succsesful, \a false if not.
*/
static bool spindle_activate (spindle_id_t spindle_id, spindle_num_t spindle_num)
{
 801c174:	b580      	push	{r7, lr}
 801c176:	b094      	sub	sp, #80	; 0x50
 801c178:	af00      	add	r7, sp, #0
 801c17a:	4603      	mov	r3, r0
 801c17c:	460a      	mov	r2, r1
 801c17e:	71fb      	strb	r3, [r7, #7]
 801c180:	4613      	mov	r3, r2
 801c182:	71bb      	strb	r3, [r7, #6]
    bool ok;
    spindle_reg_t *spindle;

    // Always configure PWM spindle on startup to ensure outputs are set correctly.
    if(pwm_spindle && pwm_spindle->cfg->config && pwm_spindle != &spindles[spindle_id]) {
 801c184:	4b87      	ldr	r3, [pc, #540]	; (801c3a4 <spindle_activate+0x230>)
 801c186:	681b      	ldr	r3, [r3, #0]
 801c188:	2b00      	cmp	r3, #0
 801c18a:	d04b      	beq.n	801c224 <spindle_activate+0xb0>
 801c18c:	4b85      	ldr	r3, [pc, #532]	; (801c3a4 <spindle_activate+0x230>)
 801c18e:	681b      	ldr	r3, [r3, #0]
 801c190:	681b      	ldr	r3, [r3, #0]
 801c192:	69db      	ldr	r3, [r3, #28]
 801c194:	2b00      	cmp	r3, #0
 801c196:	d045      	beq.n	801c224 <spindle_activate+0xb0>
 801c198:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c19c:	224c      	movs	r2, #76	; 0x4c
 801c19e:	fb02 f303 	mul.w	r3, r2, r3
 801c1a2:	4a81      	ldr	r2, [pc, #516]	; (801c3a8 <spindle_activate+0x234>)
 801c1a4:	441a      	add	r2, r3
 801c1a6:	4b7f      	ldr	r3, [pc, #508]	; (801c3a4 <spindle_activate+0x230>)
 801c1a8:	681b      	ldr	r3, [r3, #0]
 801c1aa:	429a      	cmp	r2, r3
 801c1ac:	d03a      	beq.n	801c224 <spindle_activate+0xb0>

        if(!pwm_spindle->hal.cap.rpm_range_locked) {
 801c1ae:	4b7d      	ldr	r3, [pc, #500]	; (801c3a4 <spindle_activate+0x230>)
 801c1b0:	681b      	ldr	r3, [r3, #0]
 801c1b2:	7b9b      	ldrb	r3, [r3, #14]
 801c1b4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801c1b8:	b2db      	uxtb	r3, r3
 801c1ba:	2b00      	cmp	r3, #0
 801c1bc:	d109      	bne.n	801c1d2 <spindle_activate+0x5e>
            pwm_spindle->hal.rpm_min = settings.spindle.rpm_min;
 801c1be:	4b79      	ldr	r3, [pc, #484]	; (801c3a4 <spindle_activate+0x230>)
 801c1c0:	681b      	ldr	r3, [r3, #0]
 801c1c2:	4a7a      	ldr	r2, [pc, #488]	; (801c3ac <spindle_activate+0x238>)
 801c1c4:	6f92      	ldr	r2, [r2, #120]	; 0x78
 801c1c6:	619a      	str	r2, [r3, #24]
            pwm_spindle->hal.rpm_max = settings.spindle.rpm_max;
 801c1c8:	4b76      	ldr	r3, [pc, #472]	; (801c3a4 <spindle_activate+0x230>)
 801c1ca:	681b      	ldr	r3, [r3, #0]
 801c1cc:	4a77      	ldr	r2, [pc, #476]	; (801c3ac <spindle_activate+0x238>)
 801c1ce:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801c1d0:	61da      	str	r2, [r3, #28]
        }

        if((pwm_spindle->init_ok = pwm_spindle->hal.config == NULL || pwm_spindle->hal.config(&pwm_spindle->hal)))
 801c1d2:	4b74      	ldr	r3, [pc, #464]	; (801c3a4 <spindle_activate+0x230>)
 801c1d4:	681b      	ldr	r3, [r3, #0]
 801c1d6:	6a1b      	ldr	r3, [r3, #32]
 801c1d8:	2b00      	cmp	r3, #0
 801c1da:	d00a      	beq.n	801c1f2 <spindle_activate+0x7e>
 801c1dc:	4b71      	ldr	r3, [pc, #452]	; (801c3a4 <spindle_activate+0x230>)
 801c1de:	681b      	ldr	r3, [r3, #0]
 801c1e0:	6a1b      	ldr	r3, [r3, #32]
 801c1e2:	4a70      	ldr	r2, [pc, #448]	; (801c3a4 <spindle_activate+0x230>)
 801c1e4:	6812      	ldr	r2, [r2, #0]
 801c1e6:	3204      	adds	r2, #4
 801c1e8:	4610      	mov	r0, r2
 801c1ea:	4798      	blx	r3
 801c1ec:	4603      	mov	r3, r0
 801c1ee:	2b00      	cmp	r3, #0
 801c1f0:	d001      	beq.n	801c1f6 <spindle_activate+0x82>
 801c1f2:	2201      	movs	r2, #1
 801c1f4:	e000      	b.n	801c1f8 <spindle_activate+0x84>
 801c1f6:	2200      	movs	r2, #0
 801c1f8:	4b6a      	ldr	r3, [pc, #424]	; (801c3a4 <spindle_activate+0x230>)
 801c1fa:	681b      	ldr	r3, [r3, #0]
 801c1fc:	f002 0201 	and.w	r2, r2, #1
 801c200:	b2d2      	uxtb	r2, r2
 801c202:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
 801c206:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c20a:	2b00      	cmp	r3, #0
 801c20c:	d00a      	beq.n	801c224 <spindle_activate+0xb0>
            pwm_spindle->hal.set_state(&pwm_spindle->hal, (spindle_state_t){0}, 0.0f);
 801c20e:	4b65      	ldr	r3, [pc, #404]	; (801c3a4 <spindle_activate+0x230>)
 801c210:	681b      	ldr	r3, [r3, #0]
 801c212:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c214:	4a63      	ldr	r2, [pc, #396]	; (801c3a4 <spindle_activate+0x230>)
 801c216:	6812      	ldr	r2, [r2, #0]
 801c218:	1d10      	adds	r0, r2, #4
 801c21a:	2200      	movs	r2, #0
 801c21c:	4611      	mov	r1, r2
 801c21e:	f04f 0200 	mov.w	r2, #0
 801c222:	4798      	blx	r3
    }
    pwm_spindle = NULL;
 801c224:	4b5f      	ldr	r3, [pc, #380]	; (801c3a4 <spindle_activate+0x230>)
 801c226:	2200      	movs	r2, #0
 801c228:	601a      	str	r2, [r3, #0]

    if((ok = spindle_id >= 0 && spindle_id < n_spindle && !!spindles[spindle_id].cfg)) {
 801c22a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c22e:	2b00      	cmp	r3, #0
 801c230:	db11      	blt.n	801c256 <spindle_activate+0xe2>
 801c232:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c236:	4a5e      	ldr	r2, [pc, #376]	; (801c3b0 <spindle_activate+0x23c>)
 801c238:	7812      	ldrb	r2, [r2, #0]
 801c23a:	4293      	cmp	r3, r2
 801c23c:	da0b      	bge.n	801c256 <spindle_activate+0xe2>
 801c23e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c242:	4a59      	ldr	r2, [pc, #356]	; (801c3a8 <spindle_activate+0x234>)
 801c244:	214c      	movs	r1, #76	; 0x4c
 801c246:	fb01 f303 	mul.w	r3, r1, r3
 801c24a:	4413      	add	r3, r2
 801c24c:	681b      	ldr	r3, [r3, #0]
 801c24e:	2b00      	cmp	r3, #0
 801c250:	d001      	beq.n	801c256 <spindle_activate+0xe2>
 801c252:	2301      	movs	r3, #1
 801c254:	e000      	b.n	801c258 <spindle_activate+0xe4>
 801c256:	2300      	movs	r3, #0
 801c258:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
 801c25c:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801c260:	f003 0301 	and.w	r3, r3, #1
 801c264:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
 801c268:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801c26c:	2b00      	cmp	r3, #0
 801c26e:	f000 8141 	beq.w	801c4f4 <spindle_activate+0x380>

        spindle = &spindles[spindle_id];
 801c272:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c276:	224c      	movs	r2, #76	; 0x4c
 801c278:	fb02 f303 	mul.w	r3, r2, r3
 801c27c:	4a4a      	ldr	r2, [pc, #296]	; (801c3a8 <spindle_activate+0x234>)
 801c27e:	4413      	add	r3, r2
 801c280:	64bb      	str	r3, [r7, #72]	; 0x48

        if(sys_spindle[spindle_num].enabled && sys_spindle[spindle_num].hal.id != spindle_id && sys_spindle[spindle_num].hal.set_state)
 801c282:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c286:	494b      	ldr	r1, [pc, #300]	; (801c3b4 <spindle_activate+0x240>)
 801c288:	4613      	mov	r3, r2
 801c28a:	00db      	lsls	r3, r3, #3
 801c28c:	1a9b      	subs	r3, r3, r2
 801c28e:	011b      	lsls	r3, r3, #4
 801c290:	440b      	add	r3, r1
 801c292:	336c      	adds	r3, #108	; 0x6c
 801c294:	781b      	ldrb	r3, [r3, #0]
 801c296:	2b00      	cmp	r3, #0
 801c298:	d01c      	beq.n	801c2d4 <spindle_activate+0x160>
 801c29a:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c29e:	4945      	ldr	r1, [pc, #276]	; (801c3b4 <spindle_activate+0x240>)
 801c2a0:	4613      	mov	r3, r2
 801c2a2:	00db      	lsls	r3, r3, #3
 801c2a4:	1a9b      	subs	r3, r3, r2
 801c2a6:	011b      	lsls	r3, r3, #4
 801c2a8:	440b      	add	r3, r1
 801c2aa:	332c      	adds	r3, #44	; 0x2c
 801c2ac:	f993 3000 	ldrsb.w	r3, [r3]
 801c2b0:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801c2b4:	429a      	cmp	r2, r3
 801c2b6:	d00d      	beq.n	801c2d4 <spindle_activate+0x160>
 801c2b8:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c2bc:	493d      	ldr	r1, [pc, #244]	; (801c3b4 <spindle_activate+0x240>)
 801c2be:	4613      	mov	r3, r2
 801c2c0:	00db      	lsls	r3, r3, #3
 801c2c2:	1a9b      	subs	r3, r3, r2
 801c2c4:	011b      	lsls	r3, r3, #4
 801c2c6:	440b      	add	r3, r1
 801c2c8:	334c      	adds	r3, #76	; 0x4c
 801c2ca:	681b      	ldr	r3, [r3, #0]
 801c2cc:	2b00      	cmp	r3, #0
 801c2ce:	d001      	beq.n	801c2d4 <spindle_activate+0x160>
            gc_spindle_off(); // TODO: switch off only the default spindle?
 801c2d0:	f7e9 fd64 	bl	8005d9c <gc_spindle_off>

        if(!spindle->hal.cap.rpm_range_locked) {
 801c2d4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c2d6:	7b9b      	ldrb	r3, [r3, #14]
 801c2d8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801c2dc:	b2db      	uxtb	r3, r3
 801c2de:	2b00      	cmp	r3, #0
 801c2e0:	d107      	bne.n	801c2f2 <spindle_activate+0x17e>
            spindle->hal.rpm_min = settings.spindle.rpm_min;
 801c2e2:	4b32      	ldr	r3, [pc, #200]	; (801c3ac <spindle_activate+0x238>)
 801c2e4:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 801c2e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c2e8:	619a      	str	r2, [r3, #24]
            spindle->hal.rpm_max = settings.spindle.rpm_max;
 801c2ea:	4b30      	ldr	r3, [pc, #192]	; (801c3ac <spindle_activate+0x238>)
 801c2ec:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 801c2ee:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c2f0:	61da      	str	r2, [r3, #28]
        }

        if(!spindle->init_ok)
 801c2f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c2f4:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c2f8:	f083 0301 	eor.w	r3, r3, #1
 801c2fc:	b2db      	uxtb	r3, r3
 801c2fe:	2b00      	cmp	r3, #0
 801c300:	d01a      	beq.n	801c338 <spindle_activate+0x1c4>
            ok = spindle->init_ok = spindle->hal.config == NULL || spindle->hal.config(&spindle->hal);
 801c302:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c304:	6a1b      	ldr	r3, [r3, #32]
 801c306:	2b00      	cmp	r3, #0
 801c308:	d008      	beq.n	801c31c <spindle_activate+0x1a8>
 801c30a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c30c:	6a1b      	ldr	r3, [r3, #32]
 801c30e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801c310:	3204      	adds	r2, #4
 801c312:	4610      	mov	r0, r2
 801c314:	4798      	blx	r3
 801c316:	4603      	mov	r3, r0
 801c318:	2b00      	cmp	r3, #0
 801c31a:	d001      	beq.n	801c320 <spindle_activate+0x1ac>
 801c31c:	2301      	movs	r3, #1
 801c31e:	e000      	b.n	801c322 <spindle_activate+0x1ae>
 801c320:	2300      	movs	r3, #0
 801c322:	f003 0301 	and.w	r3, r3, #1
 801c326:	b2da      	uxtb	r2, r3
 801c328:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c32a:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
 801c32e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c330:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c334:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

        if(ok) {
 801c338:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801c33c:	2b00      	cmp	r3, #0
 801c33e:	f000 80d9 	beq.w	801c4f4 <spindle_activate+0x380>

            spindle_ptrs_t spindle_hal;

            memcpy(&spindle_hal, &spindle->hal, sizeof(spindle_ptrs_t));
 801c342:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c344:	1d19      	adds	r1, r3, #4
 801c346:	f107 0308 	add.w	r3, r7, #8
 801c34a:	2240      	movs	r2, #64	; 0x40
 801c34c:	4618      	mov	r0, r3
 801c34e:	f007 fdbe 	bl	8023ece <memcpy>

            if(spindle->cfg->get_data == NULL) {
 801c352:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c354:	681b      	ldr	r3, [r3, #0]
 801c356:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801c358:	2b00      	cmp	r3, #0
 801c35a:	d13f      	bne.n	801c3dc <spindle_activate+0x268>
                if(settings.offset_lock.encoder_spindle == spindle_id) {
 801c35c:	4b13      	ldr	r3, [pc, #76]	; (801c3ac <spindle_activate+0x238>)
 801c35e:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 801c362:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801c366:	b2db      	uxtb	r3, r3
 801c368:	461a      	mov	r2, r3
 801c36a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c36e:	429a      	cmp	r2, r3
 801c370:	d124      	bne.n	801c3bc <spindle_activate+0x248>
                    spindle_hal.get_data = hal.spindle_data.get;
 801c372:	4b11      	ldr	r3, [pc, #68]	; (801c3b8 <spindle_activate+0x244>)
 801c374:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801c376:	643b      	str	r3, [r7, #64]	; 0x40
                    spindle_hal.reset_data = hal.spindle_data.reset;
 801c378:	4b0f      	ldr	r3, [pc, #60]	; (801c3b8 <spindle_activate+0x244>)
 801c37a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 801c37c:	647b      	str	r3, [r7, #68]	; 0x44
                    if(!spindle->cfg->cap.at_speed)
 801c37e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c380:	681b      	ldr	r3, [r3, #0]
 801c382:	7a9b      	ldrb	r3, [r3, #10]
 801c384:	f003 0304 	and.w	r3, r3, #4
 801c388:	b2db      	uxtb	r3, r3
 801c38a:	2b00      	cmp	r3, #0
 801c38c:	d126      	bne.n	801c3dc <spindle_activate+0x268>
                        spindle_hal.cap.at_speed = !!spindle_hal.get_data;
 801c38e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c390:	2b00      	cmp	r3, #0
 801c392:	bf14      	ite	ne
 801c394:	2301      	movne	r3, #1
 801c396:	2300      	moveq	r3, #0
 801c398:	b2da      	uxtb	r2, r3
 801c39a:	7cbb      	ldrb	r3, [r7, #18]
 801c39c:	f362 0382 	bfi	r3, r2, #2, #1
 801c3a0:	74bb      	strb	r3, [r7, #18]
 801c3a2:	e01b      	b.n	801c3dc <spindle_activate+0x268>
 801c3a4:	200017a8 	.word	0x200017a8
 801c3a8:	2000175c 	.word	0x2000175c
 801c3ac:	2000147c 	.word	0x2000147c
 801c3b0:	200016e9 	.word	0x200016e9
 801c3b4:	200016ec 	.word	0x200016ec
 801c3b8:	20000ed0 	.word	0x20000ed0
                } else {
                    spindle_hal.get_data = NULL;
 801c3bc:	2300      	movs	r3, #0
 801c3be:	643b      	str	r3, [r7, #64]	; 0x40
                    spindle_hal.reset_data = NULL;
 801c3c0:	2300      	movs	r3, #0
 801c3c2:	647b      	str	r3, [r7, #68]	; 0x44
                    if(!spindle->cfg->cap.at_speed)
 801c3c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c3c6:	681b      	ldr	r3, [r3, #0]
 801c3c8:	7a9b      	ldrb	r3, [r3, #10]
 801c3ca:	f003 0304 	and.w	r3, r3, #4
 801c3ce:	b2db      	uxtb	r3, r3
 801c3d0:	2b00      	cmp	r3, #0
 801c3d2:	d103      	bne.n	801c3dc <spindle_activate+0x268>
                        spindle_hal.cap.at_speed = Off;
 801c3d4:	7cbb      	ldrb	r3, [r7, #18]
 801c3d6:	f36f 0382 	bfc	r3, #2, #1
 801c3da:	74bb      	strb	r3, [r7, #18]
                }
            }

            spindle_hal.cap.laser &= settings.mode == Mode_Laser;
 801c3dc:	7cbb      	ldrb	r3, [r7, #18]
 801c3de:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801c3e2:	b2db      	uxtb	r3, r3
 801c3e4:	b25a      	sxtb	r2, r3
 801c3e6:	4b46      	ldr	r3, [pc, #280]	; (801c500 <spindle_activate+0x38c>)
 801c3e8:	7e1b      	ldrb	r3, [r3, #24]
 801c3ea:	2b01      	cmp	r3, #1
 801c3ec:	bf0c      	ite	eq
 801c3ee:	2301      	moveq	r3, #1
 801c3f0:	2300      	movne	r3, #0
 801c3f2:	b2db      	uxtb	r3, r3
 801c3f4:	b25b      	sxtb	r3, r3
 801c3f6:	4013      	ands	r3, r2
 801c3f8:	b25b      	sxtb	r3, r3
 801c3fa:	f003 0301 	and.w	r3, r3, #1
 801c3fe:	b2da      	uxtb	r2, r3
 801c400:	7cbb      	ldrb	r3, [r7, #18]
 801c402:	f362 03c3 	bfi	r3, r2, #3, #1
 801c406:	74bb      	strb	r3, [r7, #18]

            if(grbl.on_spindle_select)
 801c408:	4b3e      	ldr	r3, [pc, #248]	; (801c504 <spindle_activate+0x390>)
 801c40a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801c40e:	2b00      	cmp	r3, #0
 801c410:	d009      	beq.n	801c426 <spindle_activate+0x2b2>
                ok = grbl.on_spindle_select(&spindle_hal);
 801c412:	4b3c      	ldr	r3, [pc, #240]	; (801c504 <spindle_activate+0x390>)
 801c414:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 801c418:	f107 0208 	add.w	r2, r7, #8
 801c41c:	4610      	mov	r0, r2
 801c41e:	4798      	blx	r3
 801c420:	4603      	mov	r3, r0
 801c422:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

            if(ok) {
 801c426:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801c42a:	2b00      	cmp	r3, #0
 801c42c:	d062      	beq.n	801c4f4 <spindle_activate+0x380>
                sys_spindle[spindle_num].enabled = true;
 801c42e:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c432:	4935      	ldr	r1, [pc, #212]	; (801c508 <spindle_activate+0x394>)
 801c434:	4613      	mov	r3, r2
 801c436:	00db      	lsls	r3, r3, #3
 801c438:	1a9b      	subs	r3, r3, r2
 801c43a:	011b      	lsls	r3, r3, #4
 801c43c:	440b      	add	r3, r1
 801c43e:	336c      	adds	r3, #108	; 0x6c
 801c440:	2201      	movs	r2, #1
 801c442:	701a      	strb	r2, [r3, #0]
                sys_spindle[spindle_num].param.hal = &sys_spindle[spindle_num].hal;
 801c444:	f997 1006 	ldrsb.w	r1, [r7, #6]
 801c448:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c44c:	460b      	mov	r3, r1
 801c44e:	00db      	lsls	r3, r3, #3
 801c450:	1a5b      	subs	r3, r3, r1
 801c452:	011b      	lsls	r3, r3, #4
 801c454:	3328      	adds	r3, #40	; 0x28
 801c456:	492c      	ldr	r1, [pc, #176]	; (801c508 <spindle_activate+0x394>)
 801c458:	440b      	add	r3, r1
 801c45a:	1d19      	adds	r1, r3, #4
 801c45c:	482a      	ldr	r0, [pc, #168]	; (801c508 <spindle_activate+0x394>)
 801c45e:	4613      	mov	r3, r2
 801c460:	00db      	lsls	r3, r3, #3
 801c462:	1a9b      	subs	r3, r3, r2
 801c464:	011b      	lsls	r3, r3, #4
 801c466:	4403      	add	r3, r0
 801c468:	3328      	adds	r3, #40	; 0x28
 801c46a:	6019      	str	r1, [r3, #0]
                if(sys_spindle[spindle_num].param.override_pct == 0)
 801c46c:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c470:	4925      	ldr	r1, [pc, #148]	; (801c508 <spindle_activate+0x394>)
 801c472:	4613      	mov	r3, r2
 801c474:	00db      	lsls	r3, r3, #3
 801c476:	1a9b      	subs	r3, r3, r2
 801c478:	011b      	lsls	r3, r3, #4
 801c47a:	440b      	add	r3, r1
 801c47c:	330c      	adds	r3, #12
 801c47e:	681b      	ldr	r3, [r3, #0]
 801c480:	2b00      	cmp	r3, #0
 801c482:	d10a      	bne.n	801c49a <spindle_activate+0x326>
                    sys_spindle[spindle_num].param.override_pct = DEFAULT_SPINDLE_RPM_OVERRIDE;
 801c484:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c488:	491f      	ldr	r1, [pc, #124]	; (801c508 <spindle_activate+0x394>)
 801c48a:	4613      	mov	r3, r2
 801c48c:	00db      	lsls	r3, r3, #3
 801c48e:	1a9b      	subs	r3, r3, r2
 801c490:	011b      	lsls	r3, r3, #4
 801c492:	440b      	add	r3, r1
 801c494:	330c      	adds	r3, #12
 801c496:	2264      	movs	r2, #100	; 0x64
 801c498:	601a      	str	r2, [r3, #0]
                spindle_hal.param = &sys_spindle[spindle_num].param;
 801c49a:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c49e:	4613      	mov	r3, r2
 801c4a0:	00db      	lsls	r3, r3, #3
 801c4a2:	1a9b      	subs	r3, r3, r2
 801c4a4:	011b      	lsls	r3, r3, #4
 801c4a6:	4a18      	ldr	r2, [pc, #96]	; (801c508 <spindle_activate+0x394>)
 801c4a8:	4413      	add	r3, r2
 801c4aa:	60fb      	str	r3, [r7, #12]
                memcpy(&sys_spindle[spindle_num].hal, &spindle_hal, sizeof(spindle_ptrs_t));
 801c4ac:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c4b0:	4613      	mov	r3, r2
 801c4b2:	00db      	lsls	r3, r3, #3
 801c4b4:	1a9b      	subs	r3, r3, r2
 801c4b6:	011b      	lsls	r3, r3, #4
 801c4b8:	3328      	adds	r3, #40	; 0x28
 801c4ba:	4a13      	ldr	r2, [pc, #76]	; (801c508 <spindle_activate+0x394>)
 801c4bc:	4413      	add	r3, r2
 801c4be:	3304      	adds	r3, #4
 801c4c0:	f107 0108 	add.w	r1, r7, #8
 801c4c4:	2240      	movs	r2, #64	; 0x40
 801c4c6:	4618      	mov	r0, r3
 801c4c8:	f007 fd01 	bl	8023ece <memcpy>
                if(grbl.on_spindle_selected)
 801c4cc:	4b0d      	ldr	r3, [pc, #52]	; (801c504 <spindle_activate+0x390>)
 801c4ce:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 801c4d2:	2b00      	cmp	r3, #0
 801c4d4:	d00e      	beq.n	801c4f4 <spindle_activate+0x380>
                    grbl.on_spindle_selected(&sys_spindle[spindle_num].hal);
 801c4d6:	4b0b      	ldr	r3, [pc, #44]	; (801c504 <spindle_activate+0x390>)
 801c4d8:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
 801c4dc:	f997 2006 	ldrsb.w	r2, [r7, #6]
 801c4e0:	4613      	mov	r3, r2
 801c4e2:	00db      	lsls	r3, r3, #3
 801c4e4:	1a9b      	subs	r3, r3, r2
 801c4e6:	011b      	lsls	r3, r3, #4
 801c4e8:	3328      	adds	r3, #40	; 0x28
 801c4ea:	4a07      	ldr	r2, [pc, #28]	; (801c508 <spindle_activate+0x394>)
 801c4ec:	4413      	add	r3, r2
 801c4ee:	3304      	adds	r3, #4
 801c4f0:	4618      	mov	r0, r3
 801c4f2:	4788      	blx	r1
            }
        }
    }

    return ok;
 801c4f4:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
}
 801c4f8:	4618      	mov	r0, r3
 801c4fa:	3750      	adds	r7, #80	; 0x50
 801c4fc:	46bd      	mov	sp, r7
 801c4fe:	bd80      	pop	{r7, pc}
 801c500:	2000147c 	.word	0x2000147c
 801c504:	20000dd4 	.word	0x20000dd4
 801c508:	200016ec 	.word	0x200016ec

0801c50c <spindle_register>:

__NOTE:__ The first spindle registered will become the default active spindle.
__NOTE:__ up to \ref N_SPINDLE spindles can be registered at a time.
*/
spindle_id_t spindle_register (const spindle_ptrs_t *spindle, const char *name)
{
 801c50c:	b580      	push	{r7, lr}
 801c50e:	b082      	sub	sp, #8
 801c510:	af00      	add	r7, sp, #0
 801c512:	6078      	str	r0, [r7, #4]
 801c514:	6039      	str	r1, [r7, #0]
    if(n_spindle == 1 && spindles[0].cfg->type == SpindleType_Null)
 801c516:	4b3f      	ldr	r3, [pc, #252]	; (801c614 <spindle_register+0x108>)
 801c518:	781b      	ldrb	r3, [r3, #0]
 801c51a:	2b01      	cmp	r3, #1
 801c51c:	d107      	bne.n	801c52e <spindle_register+0x22>
 801c51e:	4b3e      	ldr	r3, [pc, #248]	; (801c618 <spindle_register+0x10c>)
 801c520:	681b      	ldr	r3, [r3, #0]
 801c522:	7a1b      	ldrb	r3, [r3, #8]
 801c524:	2b05      	cmp	r3, #5
 801c526:	d102      	bne.n	801c52e <spindle_register+0x22>
        n_spindle = 0;
 801c528:	4b3a      	ldr	r3, [pc, #232]	; (801c614 <spindle_register+0x108>)
 801c52a:	2200      	movs	r2, #0
 801c52c:	701a      	strb	r2, [r3, #0]

    if(n_spindle < N_SPINDLE && settings_add_spindle_type(name)) {
 801c52e:	4b39      	ldr	r3, [pc, #228]	; (801c614 <spindle_register+0x108>)
 801c530:	781b      	ldrb	r3, [r3, #0]
 801c532:	2b00      	cmp	r3, #0
 801c534:	d168      	bne.n	801c608 <spindle_register+0xfc>
 801c536:	6838      	ldr	r0, [r7, #0]
 801c538:	f7ff fbfa 	bl	801bd30 <settings_add_spindle_type>
 801c53c:	4603      	mov	r3, r0
 801c53e:	2b00      	cmp	r3, #0
 801c540:	d062      	beq.n	801c608 <spindle_register+0xfc>

        spindles[n_spindle].cfg = spindle;
 801c542:	4b34      	ldr	r3, [pc, #208]	; (801c614 <spindle_register+0x108>)
 801c544:	781b      	ldrb	r3, [r3, #0]
 801c546:	4619      	mov	r1, r3
 801c548:	4a33      	ldr	r2, [pc, #204]	; (801c618 <spindle_register+0x10c>)
 801c54a:	234c      	movs	r3, #76	; 0x4c
 801c54c:	fb01 f303 	mul.w	r3, r1, r3
 801c550:	4413      	add	r3, r2
 801c552:	687a      	ldr	r2, [r7, #4]
 801c554:	601a      	str	r2, [r3, #0]
        spindles[n_spindle].name = name;
 801c556:	4b2f      	ldr	r3, [pc, #188]	; (801c614 <spindle_register+0x108>)
 801c558:	781b      	ldrb	r3, [r3, #0]
 801c55a:	4619      	mov	r1, r3
 801c55c:	4a2e      	ldr	r2, [pc, #184]	; (801c618 <spindle_register+0x10c>)
 801c55e:	234c      	movs	r3, #76	; 0x4c
 801c560:	fb01 f303 	mul.w	r3, r1, r3
 801c564:	4413      	add	r3, r2
 801c566:	3344      	adds	r3, #68	; 0x44
 801c568:	683a      	ldr	r2, [r7, #0]
 801c56a:	601a      	str	r2, [r3, #0]
        memcpy(&spindles[n_spindle].hal, spindles[n_spindle].cfg, sizeof(spindle_ptrs_t));
 801c56c:	4b29      	ldr	r3, [pc, #164]	; (801c614 <spindle_register+0x108>)
 801c56e:	781b      	ldrb	r3, [r3, #0]
 801c570:	461a      	mov	r2, r3
 801c572:	234c      	movs	r3, #76	; 0x4c
 801c574:	fb02 f303 	mul.w	r3, r2, r3
 801c578:	4a27      	ldr	r2, [pc, #156]	; (801c618 <spindle_register+0x10c>)
 801c57a:	4413      	add	r3, r2
 801c57c:	1d18      	adds	r0, r3, #4
 801c57e:	4b25      	ldr	r3, [pc, #148]	; (801c614 <spindle_register+0x108>)
 801c580:	781b      	ldrb	r3, [r3, #0]
 801c582:	4619      	mov	r1, r3
 801c584:	4a24      	ldr	r2, [pc, #144]	; (801c618 <spindle_register+0x10c>)
 801c586:	234c      	movs	r3, #76	; 0x4c
 801c588:	fb01 f303 	mul.w	r3, r1, r3
 801c58c:	4413      	add	r3, r2
 801c58e:	681b      	ldr	r3, [r3, #0]
 801c590:	2240      	movs	r2, #64	; 0x40
 801c592:	4619      	mov	r1, r3
 801c594:	f007 fc9b 	bl	8023ece <memcpy>
        spindles[n_spindle].hal.id = n_spindle;
 801c598:	4b1e      	ldr	r3, [pc, #120]	; (801c614 <spindle_register+0x108>)
 801c59a:	781a      	ldrb	r2, [r3, #0]
 801c59c:	4b1d      	ldr	r3, [pc, #116]	; (801c614 <spindle_register+0x108>)
 801c59e:	781b      	ldrb	r3, [r3, #0]
 801c5a0:	4618      	mov	r0, r3
 801c5a2:	b251      	sxtb	r1, r2
 801c5a4:	4a1c      	ldr	r2, [pc, #112]	; (801c618 <spindle_register+0x10c>)
 801c5a6:	234c      	movs	r3, #76	; 0x4c
 801c5a8:	fb00 f303 	mul.w	r3, r0, r3
 801c5ac:	4413      	add	r3, r2
 801c5ae:	3304      	adds	r3, #4
 801c5b0:	460a      	mov	r2, r1
 801c5b2:	701a      	strb	r2, [r3, #0]

        if(spindle->type == SpindleType_PWM && pwm_spindle == NULL) {
 801c5b4:	687b      	ldr	r3, [r7, #4]
 801c5b6:	7a1b      	ldrb	r3, [r3, #8]
 801c5b8:	2b00      	cmp	r3, #0
 801c5ba:	d114      	bne.n	801c5e6 <spindle_register+0xda>
 801c5bc:	4b17      	ldr	r3, [pc, #92]	; (801c61c <spindle_register+0x110>)
 801c5be:	681b      	ldr	r3, [r3, #0]
 801c5c0:	2b00      	cmp	r3, #0
 801c5c2:	d110      	bne.n	801c5e6 <spindle_register+0xda>
            pwm_spindle = &spindles[n_spindle];
 801c5c4:	4b13      	ldr	r3, [pc, #76]	; (801c614 <spindle_register+0x108>)
 801c5c6:	781b      	ldrb	r3, [r3, #0]
 801c5c8:	461a      	mov	r2, r3
 801c5ca:	234c      	movs	r3, #76	; 0x4c
 801c5cc:	fb02 f303 	mul.w	r3, r2, r3
 801c5d0:	4a11      	ldr	r2, [pc, #68]	; (801c618 <spindle_register+0x10c>)
 801c5d2:	4413      	add	r3, r2
 801c5d4:	4a11      	ldr	r2, [pc, #68]	; (801c61c <spindle_register+0x110>)
 801c5d6:	6013      	str	r3, [r2, #0]
            hal.driver_cap.pwm_spindle = On;
 801c5d8:	4a11      	ldr	r2, [pc, #68]	; (801c620 <spindle_register+0x114>)
 801c5da:	f892 31aa 	ldrb.w	r3, [r2, #426]	; 0x1aa
 801c5de:	f043 0320 	orr.w	r3, r3, #32
 801c5e2:	f882 31aa 	strb.w	r3, [r2, #426]	; 0x1aa
        }

        if(n_spindle == 0)
 801c5e6:	4b0b      	ldr	r3, [pc, #44]	; (801c614 <spindle_register+0x108>)
 801c5e8:	781b      	ldrb	r3, [r3, #0]
 801c5ea:	2b00      	cmp	r3, #0
 801c5ec:	d104      	bne.n	801c5f8 <spindle_register+0xec>
            memcpy(&sys_spindle[0].hal, spindle, sizeof(spindle_ptrs_t));
 801c5ee:	2240      	movs	r2, #64	; 0x40
 801c5f0:	6879      	ldr	r1, [r7, #4]
 801c5f2:	480c      	ldr	r0, [pc, #48]	; (801c624 <spindle_register+0x118>)
 801c5f4:	f007 fc6b 	bl	8023ece <memcpy>

        return n_spindle++;
 801c5f8:	4b06      	ldr	r3, [pc, #24]	; (801c614 <spindle_register+0x108>)
 801c5fa:	781b      	ldrb	r3, [r3, #0]
 801c5fc:	1c5a      	adds	r2, r3, #1
 801c5fe:	b2d1      	uxtb	r1, r2
 801c600:	4a04      	ldr	r2, [pc, #16]	; (801c614 <spindle_register+0x108>)
 801c602:	7011      	strb	r1, [r2, #0]
 801c604:	b25b      	sxtb	r3, r3
 801c606:	e001      	b.n	801c60c <spindle_register+0x100>
    }

    return -1;
 801c608:	f04f 33ff 	mov.w	r3, #4294967295
}
 801c60c:	4618      	mov	r0, r3
 801c60e:	3708      	adds	r7, #8
 801c610:	46bd      	mov	sp, r7
 801c612:	bd80      	pop	{r7, pc}
 801c614:	200016e9 	.word	0x200016e9
 801c618:	2000175c 	.word	0x2000175c
 801c61c:	200017a8 	.word	0x200017a8
 801c620:	20000ed0 	.word	0x20000ed0
 801c624:	20001718 	.word	0x20001718

0801c628 <spindle_select>:
/*! \brief Enables a spindle and sets it as default spindle (spindle number 0).
\param spindle_id spindle id as a \ref spindle_id_t.
\returns \a true if succsesful, \a false if not.
*/
bool spindle_select (spindle_id_t spindle_id)
{
 801c628:	b580      	push	{r7, lr}
 801c62a:	b082      	sub	sp, #8
 801c62c:	af00      	add	r7, sp, #0
 801c62e:	4603      	mov	r3, r0
 801c630:	71fb      	strb	r3, [r7, #7]
    if(n_spindle == 0 && spindle_id >= 0) {
 801c632:	4b15      	ldr	r3, [pc, #84]	; (801c688 <spindle_select+0x60>)
 801c634:	781b      	ldrb	r3, [r3, #0]
 801c636:	2b00      	cmp	r3, #0
 801c638:	d107      	bne.n	801c64a <spindle_select+0x22>
 801c63a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c63e:	2b00      	cmp	r3, #0
 801c640:	db03      	blt.n	801c64a <spindle_select+0x22>
        spindle_id = 0;
 801c642:	2300      	movs	r3, #0
 801c644:	71fb      	strb	r3, [r7, #7]
        spindle_add_null();
 801c646:	f000 fab9 	bl	801cbbc <spindle_add_null>
    }

    return (sys_spindle[0].enabled && sys_spindle[0].hal.id == spindle_id) || spindle_activate(spindle_id, 0);
 801c64a:	4b10      	ldr	r3, [pc, #64]	; (801c68c <spindle_select+0x64>)
 801c64c:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 801c650:	2b00      	cmp	r3, #0
 801c652:	d006      	beq.n	801c662 <spindle_select+0x3a>
 801c654:	4b0d      	ldr	r3, [pc, #52]	; (801c68c <spindle_select+0x64>)
 801c656:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801c65a:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801c65e:	429a      	cmp	r2, r3
 801c660:	d008      	beq.n	801c674 <spindle_select+0x4c>
 801c662:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c666:	2100      	movs	r1, #0
 801c668:	4618      	mov	r0, r3
 801c66a:	f7ff fd83 	bl	801c174 <spindle_activate>
 801c66e:	4603      	mov	r3, r0
 801c670:	2b00      	cmp	r3, #0
 801c672:	d001      	beq.n	801c678 <spindle_select+0x50>
 801c674:	2301      	movs	r3, #1
 801c676:	e000      	b.n	801c67a <spindle_select+0x52>
 801c678:	2300      	movs	r3, #0
 801c67a:	f003 0301 	and.w	r3, r3, #1
 801c67e:	b2db      	uxtb	r3, r3
}
 801c680:	4618      	mov	r0, r3
 801c682:	3708      	adds	r7, #8
 801c684:	46bd      	mov	sp, r7
 801c686:	bd80      	pop	{r7, pc}
 801c688:	200016e9 	.word	0x200016e9
 801c68c:	200016ec 	.word	0x200016ec

0801c690 <spindle_get_hal>:
\returns pointer to a \ref spindle_ptrs_t structure if successful, \a NULL if not.

__NOTE:__ do not modify the returned structure!
*/
spindle_ptrs_t *spindle_get_hal (spindle_id_t spindle_id, spindle_hal_t hal)
{
 801c690:	b480      	push	{r7}
 801c692:	b085      	sub	sp, #20
 801c694:	af00      	add	r7, sp, #0
 801c696:	4603      	mov	r3, r0
 801c698:	460a      	mov	r2, r1
 801c69a:	71fb      	strb	r3, [r7, #7]
 801c69c:	4613      	mov	r3, r2
 801c69e:	71bb      	strb	r3, [r7, #6]
    spindle_ptrs_t *spindle = NULL;
 801c6a0:	2300      	movs	r3, #0
 801c6a2:	60fb      	str	r3, [r7, #12]

    if(hal == SpindleHAL_Active) {
 801c6a4:	79bb      	ldrb	r3, [r7, #6]
 801c6a6:	2b02      	cmp	r3, #2
 801c6a8:	d12e      	bne.n	801c708 <spindle_get_hal+0x78>

        uint_fast8_t idx = N_SYS_SPINDLE;
 801c6aa:	2301      	movs	r3, #1
 801c6ac:	60bb      	str	r3, [r7, #8]

        do {
            idx--;
 801c6ae:	68bb      	ldr	r3, [r7, #8]
 801c6b0:	3b01      	subs	r3, #1
 801c6b2:	60bb      	str	r3, [r7, #8]
            if(sys_spindle[idx].hal.id == spindle_id && sys_spindle[idx].enabled)
 801c6b4:	492c      	ldr	r1, [pc, #176]	; (801c768 <spindle_get_hal+0xd8>)
 801c6b6:	68ba      	ldr	r2, [r7, #8]
 801c6b8:	4613      	mov	r3, r2
 801c6ba:	00db      	lsls	r3, r3, #3
 801c6bc:	1a9b      	subs	r3, r3, r2
 801c6be:	011b      	lsls	r3, r3, #4
 801c6c0:	440b      	add	r3, r1
 801c6c2:	332c      	adds	r3, #44	; 0x2c
 801c6c4:	f993 3000 	ldrsb.w	r3, [r3]
 801c6c8:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801c6cc:	429a      	cmp	r2, r3
 801c6ce:	d114      	bne.n	801c6fa <spindle_get_hal+0x6a>
 801c6d0:	4925      	ldr	r1, [pc, #148]	; (801c768 <spindle_get_hal+0xd8>)
 801c6d2:	68ba      	ldr	r2, [r7, #8]
 801c6d4:	4613      	mov	r3, r2
 801c6d6:	00db      	lsls	r3, r3, #3
 801c6d8:	1a9b      	subs	r3, r3, r2
 801c6da:	011b      	lsls	r3, r3, #4
 801c6dc:	440b      	add	r3, r1
 801c6de:	336c      	adds	r3, #108	; 0x6c
 801c6e0:	781b      	ldrb	r3, [r3, #0]
 801c6e2:	2b00      	cmp	r3, #0
 801c6e4:	d009      	beq.n	801c6fa <spindle_get_hal+0x6a>
                spindle = &sys_spindle[idx].hal;
 801c6e6:	68ba      	ldr	r2, [r7, #8]
 801c6e8:	4613      	mov	r3, r2
 801c6ea:	00db      	lsls	r3, r3, #3
 801c6ec:	1a9b      	subs	r3, r3, r2
 801c6ee:	011b      	lsls	r3, r3, #4
 801c6f0:	3328      	adds	r3, #40	; 0x28
 801c6f2:	4a1d      	ldr	r2, [pc, #116]	; (801c768 <spindle_get_hal+0xd8>)
 801c6f4:	4413      	add	r3, r2
 801c6f6:	3304      	adds	r3, #4
 801c6f8:	60fb      	str	r3, [r7, #12]
        } while(idx && spindle == NULL);
 801c6fa:	68bb      	ldr	r3, [r7, #8]
 801c6fc:	2b00      	cmp	r3, #0
 801c6fe:	d02c      	beq.n	801c75a <spindle_get_hal+0xca>
 801c700:	68fb      	ldr	r3, [r7, #12]
 801c702:	2b00      	cmp	r3, #0
 801c704:	d0d3      	beq.n	801c6ae <spindle_get_hal+0x1e>
 801c706:	e028      	b.n	801c75a <spindle_get_hal+0xca>

    } else if(spindle_id >= 0 && spindle_id < n_spindle && spindles[spindle_id].cfg)
 801c708:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c70c:	2b00      	cmp	r3, #0
 801c70e:	db24      	blt.n	801c75a <spindle_get_hal+0xca>
 801c710:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c714:	4a15      	ldr	r2, [pc, #84]	; (801c76c <spindle_get_hal+0xdc>)
 801c716:	7812      	ldrb	r2, [r2, #0]
 801c718:	4293      	cmp	r3, r2
 801c71a:	da1e      	bge.n	801c75a <spindle_get_hal+0xca>
 801c71c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c720:	4a13      	ldr	r2, [pc, #76]	; (801c770 <spindle_get_hal+0xe0>)
 801c722:	214c      	movs	r1, #76	; 0x4c
 801c724:	fb01 f303 	mul.w	r3, r1, r3
 801c728:	4413      	add	r3, r2
 801c72a:	681b      	ldr	r3, [r3, #0]
 801c72c:	2b00      	cmp	r3, #0
 801c72e:	d014      	beq.n	801c75a <spindle_get_hal+0xca>
        spindle = hal == SpindleHAL_Raw ? (spindle_ptrs_t *)spindles[spindle_id].cfg : &spindles[spindle_id].hal;
 801c730:	79bb      	ldrb	r3, [r7, #6]
 801c732:	2b00      	cmp	r3, #0
 801c734:	d108      	bne.n	801c748 <spindle_get_hal+0xb8>
 801c736:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c73a:	4a0d      	ldr	r2, [pc, #52]	; (801c770 <spindle_get_hal+0xe0>)
 801c73c:	214c      	movs	r1, #76	; 0x4c
 801c73e:	fb01 f303 	mul.w	r3, r1, r3
 801c742:	4413      	add	r3, r2
 801c744:	681b      	ldr	r3, [r3, #0]
 801c746:	e007      	b.n	801c758 <spindle_get_hal+0xc8>
 801c748:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c74c:	224c      	movs	r2, #76	; 0x4c
 801c74e:	fb02 f303 	mul.w	r3, r2, r3
 801c752:	4a07      	ldr	r2, [pc, #28]	; (801c770 <spindle_get_hal+0xe0>)
 801c754:	4413      	add	r3, r2
 801c756:	3304      	adds	r3, #4
 801c758:	60fb      	str	r3, [r7, #12]

    return spindle;
 801c75a:	68fb      	ldr	r3, [r7, #12]
}
 801c75c:	4618      	mov	r0, r3
 801c75e:	3714      	adds	r7, #20
 801c760:	46bd      	mov	sp, r7
 801c762:	bc80      	pop	{r7}
 801c764:	4770      	bx	lr
 801c766:	bf00      	nop
 801c768:	200016ec 	.word	0x200016ec
 801c76c:	200016e9 	.word	0x200016e9
 801c770:	2000175c 	.word	0x2000175c

0801c774 <spindle_get_default>:

/*! \brief Get the spindle id of the default spindle (spindle number 0).
\returns spindle id as a \ref spindle_id_t if successful, \a -2 if not (no spindle available).
*/
spindle_id_t spindle_get_default (void)
{
 801c774:	b480      	push	{r7}
 801c776:	af00      	add	r7, sp, #0
    return sys_spindle[0].enabled ? sys_spindle[0].hal.id : -2;
 801c778:	4b07      	ldr	r3, [pc, #28]	; (801c798 <spindle_get_default+0x24>)
 801c77a:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 801c77e:	2b00      	cmp	r3, #0
 801c780:	d003      	beq.n	801c78a <spindle_get_default+0x16>
 801c782:	4b05      	ldr	r3, [pc, #20]	; (801c798 <spindle_get_default+0x24>)
 801c784:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801c788:	e001      	b.n	801c78e <spindle_get_default+0x1a>
 801c78a:	f06f 0301 	mvn.w	r3, #1
}
 801c78e:	4618      	mov	r0, r3
 801c790:	46bd      	mov	sp, r7
 801c792:	bc80      	pop	{r7}
 801c794:	4770      	bx	lr
 801c796:	bf00      	nop
 801c798:	200016ec 	.word	0x200016ec

0801c79c <spindle_get_caps>:
/*! \brief Get the merged spindle capabilities of all registered spindles.
\param active true to return active capabilities, false to return default capabilities.
\returns capabilities in a \ref spindle_cap_t structure.
*/
spindle_cap_t spindle_get_caps (bool active)
{
 801c79c:	b480      	push	{r7}
 801c79e:	b085      	sub	sp, #20
 801c7a0:	af00      	add	r7, sp, #0
 801c7a2:	4603      	mov	r3, r0
 801c7a4:	71fb      	strb	r3, [r7, #7]
    spindle_cap_t caps = {0};
 801c7a6:	2300      	movs	r3, #0
 801c7a8:	813b      	strh	r3, [r7, #8]
    uint_fast8_t idx = n_spindle;
 801c7aa:	4b15      	ldr	r3, [pc, #84]	; (801c800 <spindle_get_caps+0x64>)
 801c7ac:	781b      	ldrb	r3, [r3, #0]
 801c7ae:	60fb      	str	r3, [r7, #12]

    do {
        --idx;
 801c7b0:	68fb      	ldr	r3, [r7, #12]
 801c7b2:	3b01      	subs	r3, #1
 801c7b4:	60fb      	str	r3, [r7, #12]
        caps.value |= (active ? spindles[idx].hal.cap.value : spindles[idx].cfg->cap.value);
 801c7b6:	893b      	ldrh	r3, [r7, #8]
 801c7b8:	b21a      	sxth	r2, r3
 801c7ba:	79fb      	ldrb	r3, [r7, #7]
 801c7bc:	2b00      	cmp	r3, #0
 801c7be:	d009      	beq.n	801c7d4 <spindle_get_caps+0x38>
 801c7c0:	4910      	ldr	r1, [pc, #64]	; (801c804 <spindle_get_caps+0x68>)
 801c7c2:	68fb      	ldr	r3, [r7, #12]
 801c7c4:	204c      	movs	r0, #76	; 0x4c
 801c7c6:	fb00 f303 	mul.w	r3, r0, r3
 801c7ca:	440b      	add	r3, r1
 801c7cc:	330e      	adds	r3, #14
 801c7ce:	881b      	ldrh	r3, [r3, #0]
 801c7d0:	b21b      	sxth	r3, r3
 801c7d2:	e008      	b.n	801c7e6 <spindle_get_caps+0x4a>
 801c7d4:	490b      	ldr	r1, [pc, #44]	; (801c804 <spindle_get_caps+0x68>)
 801c7d6:	68fb      	ldr	r3, [r7, #12]
 801c7d8:	204c      	movs	r0, #76	; 0x4c
 801c7da:	fb00 f303 	mul.w	r3, r0, r3
 801c7de:	440b      	add	r3, r1
 801c7e0:	681b      	ldr	r3, [r3, #0]
 801c7e2:	895b      	ldrh	r3, [r3, #10]
 801c7e4:	b21b      	sxth	r3, r3
 801c7e6:	4313      	orrs	r3, r2
 801c7e8:	b21b      	sxth	r3, r3
 801c7ea:	b29b      	uxth	r3, r3
 801c7ec:	813b      	strh	r3, [r7, #8]
    } while(idx);
 801c7ee:	68fb      	ldr	r3, [r7, #12]
 801c7f0:	2b00      	cmp	r3, #0
 801c7f2:	d1dd      	bne.n	801c7b0 <spindle_get_caps+0x14>

    return caps;
 801c7f4:	893b      	ldrh	r3, [r7, #8]
}
 801c7f6:	4618      	mov	r0, r3
 801c7f8:	3714      	adds	r7, #20
 801c7fa:	46bd      	mov	sp, r7
 801c7fc:	bc80      	pop	{r7}
 801c7fe:	4770      	bx	lr
 801c800:	200016e9 	.word	0x200016e9
 801c804:	2000175c 	.word	0x2000175c

0801c808 <spindle_update_caps>:
May be used by the driver on spindle initialization or when spindle settings has been changed.
\param spindle pointer to a \ref spindle_ptrs_t structure.
\param pwm_caps pointer to a \ref spindle_pwm_t structure.
*/
void spindle_update_caps (spindle_ptrs_t *spindle, spindle_pwm_t *pwm_caps)
{
 801c808:	b480      	push	{r7}
 801c80a:	b085      	sub	sp, #20
 801c80c:	af00      	add	r7, sp, #0
 801c80e:	6078      	str	r0, [r7, #4]
 801c810:	6039      	str	r1, [r7, #0]
    uint_fast8_t idx = N_SYS_SPINDLE;
 801c812:	2301      	movs	r3, #1
 801c814:	60fb      	str	r3, [r7, #12]

    spindle->type = pwm_caps ? SpindleType_PWM : SpindleType_Basic;
 801c816:	683b      	ldr	r3, [r7, #0]
 801c818:	2b00      	cmp	r3, #0
 801c81a:	bf0c      	ite	eq
 801c81c:	2301      	moveq	r3, #1
 801c81e:	2300      	movne	r3, #0
 801c820:	b2db      	uxtb	r3, r3
 801c822:	461a      	mov	r2, r3
 801c824:	687b      	ldr	r3, [r7, #4]
 801c826:	721a      	strb	r2, [r3, #8]
    spindle->cap.laser = !!pwm_caps && !!spindle->update_pwm && settings.mode == Mode_Laser;
 801c828:	683b      	ldr	r3, [r7, #0]
 801c82a:	2b00      	cmp	r3, #0
 801c82c:	d009      	beq.n	801c842 <spindle_update_caps+0x3a>
 801c82e:	687b      	ldr	r3, [r7, #4]
 801c830:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801c832:	2b00      	cmp	r3, #0
 801c834:	d005      	beq.n	801c842 <spindle_update_caps+0x3a>
 801c836:	4b34      	ldr	r3, [pc, #208]	; (801c908 <spindle_update_caps+0x100>)
 801c838:	7e1b      	ldrb	r3, [r3, #24]
 801c83a:	2b01      	cmp	r3, #1
 801c83c:	d101      	bne.n	801c842 <spindle_update_caps+0x3a>
 801c83e:	2301      	movs	r3, #1
 801c840:	e000      	b.n	801c844 <spindle_update_caps+0x3c>
 801c842:	2300      	movs	r3, #0
 801c844:	f003 0301 	and.w	r3, r3, #1
 801c848:	b2d9      	uxtb	r1, r3
 801c84a:	687a      	ldr	r2, [r7, #4]
 801c84c:	7a93      	ldrb	r3, [r2, #10]
 801c84e:	f361 03c3 	bfi	r3, r1, #3, #1
 801c852:	7293      	strb	r3, [r2, #10]
    spindle->pwm_off_value = pwm_caps ? pwm_caps->off_value : 0;
 801c854:	683b      	ldr	r3, [r7, #0]
 801c856:	2b00      	cmp	r3, #0
 801c858:	d002      	beq.n	801c860 <spindle_update_caps+0x58>
 801c85a:	683b      	ldr	r3, [r7, #0]
 801c85c:	68db      	ldr	r3, [r3, #12]
 801c85e:	e000      	b.n	801c862 <spindle_update_caps+0x5a>
 801c860:	2300      	movs	r3, #0
 801c862:	687a      	ldr	r2, [r7, #4]
 801c864:	6113      	str	r3, [r2, #16]

    do {
        idx--;
 801c866:	68fb      	ldr	r3, [r7, #12]
 801c868:	3b01      	subs	r3, #1
 801c86a:	60fb      	str	r3, [r7, #12]
        if(sys_spindle[idx].enabled && spindle->id == sys_spindle[idx].hal.id) {
 801c86c:	4927      	ldr	r1, [pc, #156]	; (801c90c <spindle_update_caps+0x104>)
 801c86e:	68fa      	ldr	r2, [r7, #12]
 801c870:	4613      	mov	r3, r2
 801c872:	00db      	lsls	r3, r3, #3
 801c874:	1a9b      	subs	r3, r3, r2
 801c876:	011b      	lsls	r3, r3, #4
 801c878:	440b      	add	r3, r1
 801c87a:	336c      	adds	r3, #108	; 0x6c
 801c87c:	781b      	ldrb	r3, [r3, #0]
 801c87e:	2b00      	cmp	r3, #0
 801c880:	d038      	beq.n	801c8f4 <spindle_update_caps+0xec>
 801c882:	687b      	ldr	r3, [r7, #4]
 801c884:	f993 1000 	ldrsb.w	r1, [r3]
 801c888:	4820      	ldr	r0, [pc, #128]	; (801c90c <spindle_update_caps+0x104>)
 801c88a:	68fa      	ldr	r2, [r7, #12]
 801c88c:	4613      	mov	r3, r2
 801c88e:	00db      	lsls	r3, r3, #3
 801c890:	1a9b      	subs	r3, r3, r2
 801c892:	011b      	lsls	r3, r3, #4
 801c894:	4403      	add	r3, r0
 801c896:	332c      	adds	r3, #44	; 0x2c
 801c898:	f993 3000 	ldrsb.w	r3, [r3]
 801c89c:	4299      	cmp	r1, r3
 801c89e:	d129      	bne.n	801c8f4 <spindle_update_caps+0xec>
            sys_spindle[idx].hal.type = spindle->type;
 801c8a0:	687b      	ldr	r3, [r7, #4]
 801c8a2:	7a18      	ldrb	r0, [r3, #8]
 801c8a4:	4919      	ldr	r1, [pc, #100]	; (801c90c <spindle_update_caps+0x104>)
 801c8a6:	68fa      	ldr	r2, [r7, #12]
 801c8a8:	4613      	mov	r3, r2
 801c8aa:	00db      	lsls	r3, r3, #3
 801c8ac:	1a9b      	subs	r3, r3, r2
 801c8ae:	011b      	lsls	r3, r3, #4
 801c8b0:	440b      	add	r3, r1
 801c8b2:	3334      	adds	r3, #52	; 0x34
 801c8b4:	4602      	mov	r2, r0
 801c8b6:	701a      	strb	r2, [r3, #0]
            sys_spindle[idx].hal.cap.laser = spindle->cap.laser;
 801c8b8:	687b      	ldr	r3, [r7, #4]
 801c8ba:	7a9b      	ldrb	r3, [r3, #10]
 801c8bc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801c8c0:	b2d9      	uxtb	r1, r3
 801c8c2:	4812      	ldr	r0, [pc, #72]	; (801c90c <spindle_update_caps+0x104>)
 801c8c4:	68fa      	ldr	r2, [r7, #12]
 801c8c6:	4613      	mov	r3, r2
 801c8c8:	00db      	lsls	r3, r3, #3
 801c8ca:	1a9b      	subs	r3, r3, r2
 801c8cc:	011b      	lsls	r3, r3, #4
 801c8ce:	4403      	add	r3, r0
 801c8d0:	f103 0230 	add.w	r2, r3, #48	; 0x30
 801c8d4:	7993      	ldrb	r3, [r2, #6]
 801c8d6:	f361 03c3 	bfi	r3, r1, #3, #1
 801c8da:	7193      	strb	r3, [r2, #6]
            sys_spindle[idx].hal.pwm_off_value =  spindle->pwm_off_value;
 801c8dc:	687b      	ldr	r3, [r7, #4]
 801c8de:	6919      	ldr	r1, [r3, #16]
 801c8e0:	480a      	ldr	r0, [pc, #40]	; (801c90c <spindle_update_caps+0x104>)
 801c8e2:	68fa      	ldr	r2, [r7, #12]
 801c8e4:	4613      	mov	r3, r2
 801c8e6:	00db      	lsls	r3, r3, #3
 801c8e8:	1a9b      	subs	r3, r3, r2
 801c8ea:	011b      	lsls	r3, r3, #4
 801c8ec:	4403      	add	r3, r0
 801c8ee:	333c      	adds	r3, #60	; 0x3c
 801c8f0:	6019      	str	r1, [r3, #0]
            break;
 801c8f2:	e003      	b.n	801c8fc <spindle_update_caps+0xf4>
        }
    } while(idx);
 801c8f4:	68fb      	ldr	r3, [r7, #12]
 801c8f6:	2b00      	cmp	r3, #0
 801c8f8:	d1b5      	bne.n	801c866 <spindle_update_caps+0x5e>
}
 801c8fa:	bf00      	nop
 801c8fc:	bf00      	nop
 801c8fe:	3714      	adds	r7, #20
 801c900:	46bd      	mov	sp, r7
 801c902:	bc80      	pop	{r7}
 801c904:	4770      	bx	lr
 801c906:	bf00      	nop
 801c908:	2000147c 	.word	0x2000147c
 801c90c:	200016ec 	.word	0x200016ec

0801c910 <spindle_get_count>:

/*! \brief Get number of registered spindles.
\returns number of registered spindles.
*/
uint8_t spindle_get_count (void)
{
 801c910:	b580      	push	{r7, lr}
 801c912:	af00      	add	r7, sp, #0
    if(n_spindle == 0)
 801c914:	4b05      	ldr	r3, [pc, #20]	; (801c92c <spindle_get_count+0x1c>)
 801c916:	781b      	ldrb	r3, [r3, #0]
 801c918:	2b00      	cmp	r3, #0
 801c91a:	d102      	bne.n	801c922 <spindle_get_count+0x12>
        spindle_select(0);
 801c91c:	2000      	movs	r0, #0
 801c91e:	f7ff fe83 	bl	801c628 <spindle_select>

    return n_spindle;
 801c922:	4b02      	ldr	r3, [pc, #8]	; (801c92c <spindle_get_count+0x1c>)
 801c924:	781b      	ldrb	r3, [r3, #0]
}
 801c926:	4618      	mov	r0, r3
 801c928:	bd80      	pop	{r7, pc}
 801c92a:	bf00      	nop
 801c92c:	200016e9 	.word	0x200016e9

0801c930 <spindle_get_num>:

static spindle_num_t spindle_get_num (spindle_id_t spindle_id)
{
 801c930:	b580      	push	{r7, lr}
 801c932:	b086      	sub	sp, #24
 801c934:	af00      	add	r7, sp, #0
 801c936:	4603      	mov	r3, r0
 801c938:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t idx = N_SPINDLE_SELECTABLE;
 801c93a:	2301      	movs	r3, #1
 801c93c:	617b      	str	r3, [r7, #20]
    spindle_num_t spindle_num = -1;
 801c93e:	23ff      	movs	r3, #255	; 0xff
 801c940:	74fb      	strb	r3, [r7, #19]

    const setting_detail_t *setting;

    do {
        idx--;
 801c942:	697b      	ldr	r3, [r7, #20]
 801c944:	3b01      	subs	r3, #1
 801c946:	617b      	str	r3, [r7, #20]
        if((setting = setting_get_details(idx == 0 ? Setting_SpindleType : (setting_id_t)(Setting_SpindleEnable0 + idx), NULL))) {
 801c948:	697b      	ldr	r3, [r7, #20]
 801c94a:	2b00      	cmp	r3, #0
 801c94c:	d005      	beq.n	801c95a <spindle_get_num+0x2a>
 801c94e:	697b      	ldr	r3, [r7, #20]
 801c950:	b29b      	uxth	r3, r3
 801c952:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 801c956:	b29b      	uxth	r3, r3
 801c958:	e001      	b.n	801c95e <spindle_get_num+0x2e>
 801c95a:	f240 138b 	movw	r3, #395	; 0x18b
 801c95e:	2100      	movs	r1, #0
 801c960:	4618      	mov	r0, r3
 801c962:	f7fe fc59 	bl	801b218 <setting_get_details>
 801c966:	60f8      	str	r0, [r7, #12]
 801c968:	68fb      	ldr	r3, [r7, #12]
 801c96a:	2b00      	cmp	r3, #0
 801c96c:	d00a      	beq.n	801c984 <spindle_get_num+0x54>
            if(setting_get_int_value(setting, 0) == spindle_id)
 801c96e:	2100      	movs	r1, #0
 801c970:	68f8      	ldr	r0, [r7, #12]
 801c972:	f7fd fd99 	bl	801a4a8 <setting_get_int_value>
 801c976:	4602      	mov	r2, r0
 801c978:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801c97c:	429a      	cmp	r2, r3
 801c97e:	d101      	bne.n	801c984 <spindle_get_num+0x54>
                spindle_num = idx;
 801c980:	697b      	ldr	r3, [r7, #20]
 801c982:	74fb      	strb	r3, [r7, #19]
        }
    } while(idx && spindle_num == -1);
 801c984:	697b      	ldr	r3, [r7, #20]
 801c986:	2b00      	cmp	r3, #0
 801c988:	d004      	beq.n	801c994 <spindle_get_num+0x64>
 801c98a:	f997 3013 	ldrsb.w	r3, [r7, #19]
 801c98e:	f1b3 3fff 	cmp.w	r3, #4294967295
 801c992:	d0d6      	beq.n	801c942 <spindle_get_num+0x12>

    return spindle_num;
 801c994:	f997 3013 	ldrsb.w	r3, [r7, #19]
}
 801c998:	4618      	mov	r0, r3
 801c99a:	3718      	adds	r7, #24
 801c99c:	46bd      	mov	sp, r7
 801c99e:	bd80      	pop	{r7, pc}

0801c9a0 <spindle_enumerate_spindles>:
\param callback pointer to a \ref spindle_enumerate_callback_ptr type function.
\param data pointer to optional data to pass to the callback function.
\returns \a true if spindles are registered and a callback function was provided, \a false otherwise.
*/
bool spindle_enumerate_spindles (spindle_enumerate_callback_ptr callback, void *data)
{
 801c9a0:	b580      	push	{r7, lr}
 801c9a2:	b088      	sub	sp, #32
 801c9a4:	af00      	add	r7, sp, #0
 801c9a6:	6078      	str	r0, [r7, #4]
 801c9a8:	6039      	str	r1, [r7, #0]
    if(callback == NULL || n_spindle == 0)
 801c9aa:	687b      	ldr	r3, [r7, #4]
 801c9ac:	2b00      	cmp	r3, #0
 801c9ae:	d003      	beq.n	801c9b8 <spindle_enumerate_spindles+0x18>
 801c9b0:	4b38      	ldr	r3, [pc, #224]	; (801ca94 <spindle_enumerate_spindles+0xf4>)
 801c9b2:	781b      	ldrb	r3, [r3, #0]
 801c9b4:	2b00      	cmp	r3, #0
 801c9b6:	d101      	bne.n	801c9bc <spindle_enumerate_spindles+0x1c>
        return false;
 801c9b8:	2300      	movs	r3, #0
 801c9ba:	e066      	b.n	801ca8a <spindle_enumerate_spindles+0xea>

    uint_fast8_t idx;
    spindle_info_t spindle;

    for(idx = 0; idx < n_spindle; idx++) {
 801c9bc:	2300      	movs	r3, #0
 801c9be:	61fb      	str	r3, [r7, #28]
 801c9c0:	e05c      	b.n	801ca7c <spindle_enumerate_spindles+0xdc>

        spindle.id = idx;
 801c9c2:	69fb      	ldr	r3, [r7, #28]
 801c9c4:	b25b      	sxtb	r3, r3
 801c9c6:	733b      	strb	r3, [r7, #12]
        spindle.name = spindles[idx].name;
 801c9c8:	4a33      	ldr	r2, [pc, #204]	; (801ca98 <spindle_enumerate_spindles+0xf8>)
 801c9ca:	69fb      	ldr	r3, [r7, #28]
 801c9cc:	214c      	movs	r1, #76	; 0x4c
 801c9ce:	fb01 f303 	mul.w	r3, r1, r3
 801c9d2:	4413      	add	r3, r2
 801c9d4:	3344      	adds	r3, #68	; 0x44
 801c9d6:	681b      	ldr	r3, [r3, #0]
 801c9d8:	613b      	str	r3, [r7, #16]
        spindle.num = spindle_get_num(idx);
 801c9da:	69fb      	ldr	r3, [r7, #28]
 801c9dc:	b25b      	sxtb	r3, r3
 801c9de:	4618      	mov	r0, r3
 801c9e0:	f7ff ffa6 	bl	801c930 <spindle_get_num>
 801c9e4:	4603      	mov	r3, r0
 801c9e6:	737b      	strb	r3, [r7, #13]
        spindle.enabled = spindle.num != -1;
 801c9e8:	f997 300d 	ldrsb.w	r3, [r7, #13]
 801c9ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 801c9f0:	bf14      	ite	ne
 801c9f2:	2301      	movne	r3, #1
 801c9f4:	2300      	moveq	r3, #0
 801c9f6:	b2db      	uxtb	r3, r3
 801c9f8:	753b      	strb	r3, [r7, #20]
        spindle.hal = spindle.enabled && sys_spindle[spindle.num].hal.id == spindle.id ? &sys_spindle[spindle.num].hal : &spindles[idx].hal;
 801c9fa:	7d3b      	ldrb	r3, [r7, #20]
 801c9fc:	2b00      	cmp	r3, #0
 801c9fe:	d01b      	beq.n	801ca38 <spindle_enumerate_spindles+0x98>
 801ca00:	f997 300d 	ldrsb.w	r3, [r7, #13]
 801ca04:	4619      	mov	r1, r3
 801ca06:	4a25      	ldr	r2, [pc, #148]	; (801ca9c <spindle_enumerate_spindles+0xfc>)
 801ca08:	460b      	mov	r3, r1
 801ca0a:	00db      	lsls	r3, r3, #3
 801ca0c:	1a5b      	subs	r3, r3, r1
 801ca0e:	011b      	lsls	r3, r3, #4
 801ca10:	4413      	add	r3, r2
 801ca12:	332c      	adds	r3, #44	; 0x2c
 801ca14:	f993 2000 	ldrsb.w	r2, [r3]
 801ca18:	f997 300c 	ldrsb.w	r3, [r7, #12]
 801ca1c:	429a      	cmp	r2, r3
 801ca1e:	d10b      	bne.n	801ca38 <spindle_enumerate_spindles+0x98>
 801ca20:	f997 300d 	ldrsb.w	r3, [r7, #13]
 801ca24:	461a      	mov	r2, r3
 801ca26:	4613      	mov	r3, r2
 801ca28:	00db      	lsls	r3, r3, #3
 801ca2a:	1a9b      	subs	r3, r3, r2
 801ca2c:	011b      	lsls	r3, r3, #4
 801ca2e:	3328      	adds	r3, #40	; 0x28
 801ca30:	4a1a      	ldr	r2, [pc, #104]	; (801ca9c <spindle_enumerate_spindles+0xfc>)
 801ca32:	4413      	add	r3, r2
 801ca34:	3304      	adds	r3, #4
 801ca36:	e006      	b.n	801ca46 <spindle_enumerate_spindles+0xa6>
 801ca38:	69fb      	ldr	r3, [r7, #28]
 801ca3a:	224c      	movs	r2, #76	; 0x4c
 801ca3c:	fb02 f303 	mul.w	r3, r2, r3
 801ca40:	4a15      	ldr	r2, [pc, #84]	; (801ca98 <spindle_enumerate_spindles+0xf8>)
 801ca42:	4413      	add	r3, r2
 801ca44:	3304      	adds	r3, #4
 801ca46:	61bb      	str	r3, [r7, #24]
        spindle.is_current = spindle.enabled && sys_spindle[0].hal.id == idx;
 801ca48:	7d3b      	ldrb	r3, [r7, #20]
 801ca4a:	2b00      	cmp	r3, #0
 801ca4c:	d008      	beq.n	801ca60 <spindle_enumerate_spindles+0xc0>
 801ca4e:	4b13      	ldr	r3, [pc, #76]	; (801ca9c <spindle_enumerate_spindles+0xfc>)
 801ca50:	f993 302c 	ldrsb.w	r3, [r3, #44]	; 0x2c
 801ca54:	461a      	mov	r2, r3
 801ca56:	69fb      	ldr	r3, [r7, #28]
 801ca58:	4293      	cmp	r3, r2
 801ca5a:	d101      	bne.n	801ca60 <spindle_enumerate_spindles+0xc0>
 801ca5c:	2301      	movs	r3, #1
 801ca5e:	e000      	b.n	801ca62 <spindle_enumerate_spindles+0xc2>
 801ca60:	2300      	movs	r3, #0
 801ca62:	f003 0301 	and.w	r3, r3, #1
 801ca66:	b2db      	uxtb	r3, r3
 801ca68:	757b      	strb	r3, [r7, #21]

        callback(&spindle, data);
 801ca6a:	f107 020c 	add.w	r2, r7, #12
 801ca6e:	687b      	ldr	r3, [r7, #4]
 801ca70:	6839      	ldr	r1, [r7, #0]
 801ca72:	4610      	mov	r0, r2
 801ca74:	4798      	blx	r3
    for(idx = 0; idx < n_spindle; idx++) {
 801ca76:	69fb      	ldr	r3, [r7, #28]
 801ca78:	3301      	adds	r3, #1
 801ca7a:	61fb      	str	r3, [r7, #28]
 801ca7c:	4b05      	ldr	r3, [pc, #20]	; (801ca94 <spindle_enumerate_spindles+0xf4>)
 801ca7e:	781b      	ldrb	r3, [r3, #0]
 801ca80:	461a      	mov	r2, r3
 801ca82:	69fb      	ldr	r3, [r7, #28]
 801ca84:	4293      	cmp	r3, r2
 801ca86:	d39c      	bcc.n	801c9c2 <spindle_enumerate_spindles+0x22>
    }

    return true;
 801ca88:	2301      	movs	r3, #1
}
 801ca8a:	4618      	mov	r0, r3
 801ca8c:	3720      	adds	r7, #32
 801ca8e:	46bd      	mov	sp, r7
 801ca90:	bd80      	pop	{r7, pc}
 801ca92:	bf00      	nop
 801ca94:	200016e9 	.word	0x200016e9
 801ca98:	2000175c 	.word	0x2000175c
 801ca9c:	200016ec 	.word	0x200016ec

0801caa0 <spindle_is_enabled>:
/*! \brief Check if a spindle is enabled and available or not.
\param spindle_num spindle number as a \ref spindle_num_t.
\returns \a true if the spindle is enabled, \a false otherwise.
*/
bool spindle_is_enabled (spindle_num_t spindle_num)
{
 801caa0:	b480      	push	{r7}
 801caa2:	b083      	sub	sp, #12
 801caa4:	af00      	add	r7, sp, #0
 801caa6:	4603      	mov	r3, r0
 801caa8:	71fb      	strb	r3, [r7, #7]
    if(spindle_num == -1)
 801caaa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801caae:	f1b3 3fff 	cmp.w	r3, #4294967295
 801cab2:	d101      	bne.n	801cab8 <spindle_is_enabled+0x18>
        spindle_num = 0;
 801cab4:	2300      	movs	r3, #0
 801cab6:	71fb      	strb	r3, [r7, #7]

    return spindle_num >= 0 && spindle_num < N_SYS_SPINDLE && sys_spindle[spindle_num].enabled;
 801cab8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801cabc:	2b00      	cmp	r3, #0
 801cabe:	db11      	blt.n	801cae4 <spindle_is_enabled+0x44>
 801cac0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801cac4:	2b00      	cmp	r3, #0
 801cac6:	dc0d      	bgt.n	801cae4 <spindle_is_enabled+0x44>
 801cac8:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801cacc:	490a      	ldr	r1, [pc, #40]	; (801caf8 <spindle_is_enabled+0x58>)
 801cace:	4613      	mov	r3, r2
 801cad0:	00db      	lsls	r3, r3, #3
 801cad2:	1a9b      	subs	r3, r3, r2
 801cad4:	011b      	lsls	r3, r3, #4
 801cad6:	440b      	add	r3, r1
 801cad8:	336c      	adds	r3, #108	; 0x6c
 801cada:	781b      	ldrb	r3, [r3, #0]
 801cadc:	2b00      	cmp	r3, #0
 801cade:	d001      	beq.n	801cae4 <spindle_is_enabled+0x44>
 801cae0:	2301      	movs	r3, #1
 801cae2:	e000      	b.n	801cae6 <spindle_is_enabled+0x46>
 801cae4:	2300      	movs	r3, #0
 801cae6:	f003 0301 	and.w	r3, r3, #1
 801caea:	b2db      	uxtb	r3, r3
}
 801caec:	4618      	mov	r0, r3
 801caee:	370c      	adds	r7, #12
 801caf0:	46bd      	mov	sp, r7
 801caf2:	bc80      	pop	{r7}
 801caf4:	4770      	bx	lr
 801caf6:	bf00      	nop
 801caf8:	200016ec 	.word	0x200016ec

0801cafc <spindle_get>:
\returns pointer to a \ref spindle_ptrs_t structure if successful, \a NULL if not.

__NOTE:__ do not modify the returned structure!
*/
spindle_ptrs_t *spindle_get (spindle_num_t spindle_num)
{
 801cafc:	b480      	push	{r7}
 801cafe:	b083      	sub	sp, #12
 801cb00:	af00      	add	r7, sp, #0
 801cb02:	4603      	mov	r3, r0
 801cb04:	71fb      	strb	r3, [r7, #7]
    return spindle_num >= 0 && spindle_num < N_SYS_SPINDLE && sys_spindle[spindle_num].enabled ? &sys_spindle[spindle_num].hal : NULL;
 801cb06:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801cb0a:	2b00      	cmp	r3, #0
 801cb0c:	db1a      	blt.n	801cb44 <spindle_get+0x48>
 801cb0e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801cb12:	2b00      	cmp	r3, #0
 801cb14:	dc16      	bgt.n	801cb44 <spindle_get+0x48>
 801cb16:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801cb1a:	490d      	ldr	r1, [pc, #52]	; (801cb50 <spindle_get+0x54>)
 801cb1c:	4613      	mov	r3, r2
 801cb1e:	00db      	lsls	r3, r3, #3
 801cb20:	1a9b      	subs	r3, r3, r2
 801cb22:	011b      	lsls	r3, r3, #4
 801cb24:	440b      	add	r3, r1
 801cb26:	336c      	adds	r3, #108	; 0x6c
 801cb28:	781b      	ldrb	r3, [r3, #0]
 801cb2a:	2b00      	cmp	r3, #0
 801cb2c:	d00a      	beq.n	801cb44 <spindle_get+0x48>
 801cb2e:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801cb32:	4613      	mov	r3, r2
 801cb34:	00db      	lsls	r3, r3, #3
 801cb36:	1a9b      	subs	r3, r3, r2
 801cb38:	011b      	lsls	r3, r3, #4
 801cb3a:	3328      	adds	r3, #40	; 0x28
 801cb3c:	4a04      	ldr	r2, [pc, #16]	; (801cb50 <spindle_get+0x54>)
 801cb3e:	4413      	add	r3, r2
 801cb40:	3304      	adds	r3, #4
 801cb42:	e000      	b.n	801cb46 <spindle_get+0x4a>
 801cb44:	2300      	movs	r3, #0
}
 801cb46:	4618      	mov	r0, r3
 801cb48:	370c      	adds	r7, #12
 801cb4a:	46bd      	mov	sp, r7
 801cb4c:	bc80      	pop	{r7}
 801cb4e:	4770      	bx	lr
 801cb50:	200016ec 	.word	0x200016ec

0801cb54 <null_set_state>:
//
// Null (dummy) spindle, automatically installed if no spindles are registered.
//

static void null_set_state (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 801cb54:	b480      	push	{r7}
 801cb56:	b085      	sub	sp, #20
 801cb58:	af00      	add	r7, sp, #0
 801cb5a:	60f8      	str	r0, [r7, #12]
 801cb5c:	7239      	strb	r1, [r7, #8]
 801cb5e:	607a      	str	r2, [r7, #4]
    UNUSED(spindle);
    UNUSED(state);
    UNUSED(rpm);
}
 801cb60:	bf00      	nop
 801cb62:	3714      	adds	r7, #20
 801cb64:	46bd      	mov	sp, r7
 801cb66:	bc80      	pop	{r7}
 801cb68:	4770      	bx	lr

0801cb6a <null_get_state>:

static spindle_state_t null_get_state (spindle_ptrs_t *spindle)
{
 801cb6a:	b480      	push	{r7}
 801cb6c:	b083      	sub	sp, #12
 801cb6e:	af00      	add	r7, sp, #0
 801cb70:	6078      	str	r0, [r7, #4]
    UNUSED(spindle);

    return (spindle_state_t){0};
 801cb72:	2300      	movs	r3, #0
}
 801cb74:	4618      	mov	r0, r3
 801cb76:	370c      	adds	r7, #12
 801cb78:	46bd      	mov	sp, r7
 801cb7a:	bc80      	pop	{r7}
 801cb7c:	4770      	bx	lr

0801cb7e <null_update_pwm>:

// Sets spindle speed
static void null_update_pwm (spindle_ptrs_t *spindle, uint_fast16_t pwm_value)
{
 801cb7e:	b480      	push	{r7}
 801cb80:	b083      	sub	sp, #12
 801cb82:	af00      	add	r7, sp, #0
 801cb84:	6078      	str	r0, [r7, #4]
 801cb86:	6039      	str	r1, [r7, #0]
    UNUSED(spindle);
    UNUSED(pwm_value);
}
 801cb88:	bf00      	nop
 801cb8a:	370c      	adds	r7, #12
 801cb8c:	46bd      	mov	sp, r7
 801cb8e:	bc80      	pop	{r7}
 801cb90:	4770      	bx	lr

0801cb92 <null_get_pwm>:

static uint_fast16_t null_get_pwm (spindle_ptrs_t *spindle, float rpm)
{
 801cb92:	b480      	push	{r7}
 801cb94:	b083      	sub	sp, #12
 801cb96:	af00      	add	r7, sp, #0
 801cb98:	6078      	str	r0, [r7, #4]
 801cb9a:	6039      	str	r1, [r7, #0]
    UNUSED(spindle);
    UNUSED(rpm);

    return 0;
 801cb9c:	2300      	movs	r3, #0
}
 801cb9e:	4618      	mov	r0, r3
 801cba0:	370c      	adds	r7, #12
 801cba2:	46bd      	mov	sp, r7
 801cba4:	bc80      	pop	{r7}
 801cba6:	4770      	bx	lr

0801cba8 <null_update_rpm>:

static void null_update_rpm (spindle_ptrs_t *spindle, float rpm)
{
 801cba8:	b480      	push	{r7}
 801cbaa:	b083      	sub	sp, #12
 801cbac:	af00      	add	r7, sp, #0
 801cbae:	6078      	str	r0, [r7, #4]
 801cbb0:	6039      	str	r1, [r7, #0]
    UNUSED(spindle);
    UNUSED(rpm);
}
 801cbb2:	bf00      	nop
 801cbb4:	370c      	adds	r7, #12
 801cbb6:	46bd      	mov	sp, r7
 801cbb8:	bc80      	pop	{r7}
 801cbba:	4770      	bx	lr

0801cbbc <spindle_add_null>:
/*! \brief Register a null spindle that has no connection to the outside world.
This is done automatically on startup if no spindle can be succesfully enabled.
\returns assigned spindle id as a \ref spindle_id_t if successful, \a -1 if not.
*/
spindle_id_t spindle_add_null (void)
{
 801cbbc:	b580      	push	{r7, lr}
 801cbbe:	b082      	sub	sp, #8
 801cbc0:	af00      	add	r7, sp, #0
        .get_pwm = null_get_pwm,
        .update_pwm = null_update_pwm,
        .update_rpm = null_update_rpm
    };

    bool registered = false;
 801cbc2:	2300      	movs	r3, #0
 801cbc4:	71fb      	strb	r3, [r7, #7]
    uint_fast8_t idx = n_spindle;
 801cbc6:	4b18      	ldr	r3, [pc, #96]	; (801cc28 <spindle_add_null+0x6c>)
 801cbc8:	781b      	ldrb	r3, [r3, #0]
 801cbca:	603b      	str	r3, [r7, #0]

    if(idx) do {
 801cbcc:	683b      	ldr	r3, [r7, #0]
 801cbce:	2b00      	cmp	r3, #0
 801cbd0:	d017      	beq.n	801cc02 <spindle_add_null+0x46>
        if((registered = spindles[--idx].hal.type == SpindleType_Null))
 801cbd2:	683b      	ldr	r3, [r7, #0]
 801cbd4:	3b01      	subs	r3, #1
 801cbd6:	603b      	str	r3, [r7, #0]
 801cbd8:	4a14      	ldr	r2, [pc, #80]	; (801cc2c <spindle_add_null+0x70>)
 801cbda:	683b      	ldr	r3, [r7, #0]
 801cbdc:	214c      	movs	r1, #76	; 0x4c
 801cbde:	fb01 f303 	mul.w	r3, r1, r3
 801cbe2:	4413      	add	r3, r2
 801cbe4:	330c      	adds	r3, #12
 801cbe6:	781b      	ldrb	r3, [r3, #0]
 801cbe8:	2b05      	cmp	r3, #5
 801cbea:	bf0c      	ite	eq
 801cbec:	2301      	moveq	r3, #1
 801cbee:	2300      	movne	r3, #0
 801cbf0:	71fb      	strb	r3, [r7, #7]
 801cbf2:	79fb      	ldrb	r3, [r7, #7]
 801cbf4:	2b00      	cmp	r3, #0
 801cbf6:	d103      	bne.n	801cc00 <spindle_add_null+0x44>
            break;
    } while(idx);
 801cbf8:	683b      	ldr	r3, [r7, #0]
 801cbfa:	2b00      	cmp	r3, #0
 801cbfc:	d1e9      	bne.n	801cbd2 <spindle_add_null+0x16>
 801cbfe:	e000      	b.n	801cc02 <spindle_add_null+0x46>
            break;
 801cc00:	bf00      	nop

    if(!registered)
 801cc02:	79fb      	ldrb	r3, [r7, #7]
 801cc04:	f083 0301 	eor.w	r3, r3, #1
 801cc08:	b2db      	uxtb	r3, r3
 801cc0a:	2b00      	cmp	r3, #0
 801cc0c:	d005      	beq.n	801cc1a <spindle_add_null+0x5e>
        return spindle_register(&spindle, "NULL");
 801cc0e:	4908      	ldr	r1, [pc, #32]	; (801cc30 <spindle_add_null+0x74>)
 801cc10:	4808      	ldr	r0, [pc, #32]	; (801cc34 <spindle_add_null+0x78>)
 801cc12:	f7ff fc7b 	bl	801c50c <spindle_register>
 801cc16:	4603      	mov	r3, r0
 801cc18:	e001      	b.n	801cc1e <spindle_add_null+0x62>

    return idx;
 801cc1a:	683b      	ldr	r3, [r7, #0]
 801cc1c:	b25b      	sxtb	r3, r3
}
 801cc1e:	4618      	mov	r0, r3
 801cc20:	3708      	adds	r7, #8
 801cc22:	46bd      	mov	sp, r7
 801cc24:	bd80      	pop	{r7, pc}
 801cc26:	bf00      	nop
 801cc28:	200016e9 	.word	0x200016e9
 801cc2c:	2000175c 	.word	0x2000175c
 801cc30:	0802f00c 	.word	0x0802f00c
 801cc34:	08032b7c 	.word	0x08032b7c

0801cc38 <spindle_set_override>:
\param speed_override override as a percentage of the programmed RPM.

__NOTE:__ Unlike motion overrides, spindle overrides do not require a planner reinitialization.
*/
void spindle_set_override (spindle_ptrs_t *spindle, override_t speed_override)
{
 801cc38:	b590      	push	{r4, r7, lr}
 801cc3a:	b083      	sub	sp, #12
 801cc3c:	af00      	add	r7, sp, #0
 801cc3e:	6078      	str	r0, [r7, #4]
 801cc40:	6039      	str	r1, [r7, #0]
//    if(speed_override != 100 && sys.override.control.spindle_rpm_disable)
//        return;

    if(speed_override != 100 && spindle->param->state.override_disable)
 801cc42:	683b      	ldr	r3, [r7, #0]
 801cc44:	2b64      	cmp	r3, #100	; 0x64
 801cc46:	d007      	beq.n	801cc58 <spindle_set_override+0x20>
 801cc48:	687b      	ldr	r3, [r7, #4]
 801cc4a:	685b      	ldr	r3, [r3, #4]
 801cc4c:	7a1b      	ldrb	r3, [r3, #8]
 801cc4e:	f003 0310 	and.w	r3, r3, #16
 801cc52:	b2db      	uxtb	r3, r3
 801cc54:	2b00      	cmp	r3, #0
 801cc56:	d148      	bne.n	801ccea <spindle_set_override+0xb2>
        return;

    speed_override = constrain(speed_override, MIN_SPINDLE_RPM_OVERRIDE, MAX_SPINDLE_RPM_OVERRIDE);
 801cc58:	683b      	ldr	r3, [r7, #0]
 801cc5a:	2b09      	cmp	r3, #9
 801cc5c:	d904      	bls.n	801cc68 <spindle_set_override+0x30>
 801cc5e:	683b      	ldr	r3, [r7, #0]
 801cc60:	2bc8      	cmp	r3, #200	; 0xc8
 801cc62:	bf28      	it	cs
 801cc64:	23c8      	movcs	r3, #200	; 0xc8
 801cc66:	e000      	b.n	801cc6a <spindle_set_override+0x32>
 801cc68:	230a      	movs	r3, #10
 801cc6a:	603b      	str	r3, [r7, #0]

    if ((uint8_t)speed_override != spindle->param->override_pct) {
 801cc6c:	683b      	ldr	r3, [r7, #0]
 801cc6e:	b2db      	uxtb	r3, r3
 801cc70:	461a      	mov	r2, r3
 801cc72:	687b      	ldr	r3, [r7, #4]
 801cc74:	685b      	ldr	r3, [r3, #4]
 801cc76:	68db      	ldr	r3, [r3, #12]
 801cc78:	429a      	cmp	r2, r3
 801cc7a:	d037      	beq.n	801ccec <spindle_set_override+0xb4>

        spindle->param->override_pct = speed_override;
 801cc7c:	687b      	ldr	r3, [r7, #4]
 801cc7e:	685b      	ldr	r3, [r3, #4]
 801cc80:	683a      	ldr	r2, [r7, #0]
 801cc82:	60da      	str	r2, [r3, #12]

        if(state_get() == STATE_IDLE)
 801cc84:	f000 fe1c 	bl	801d8c0 <state_get>
 801cc88:	4603      	mov	r3, r0
 801cc8a:	2b00      	cmp	r3, #0
 801cc8c:	d108      	bne.n	801cca0 <spindle_set_override+0x68>
            spindle_set_state(spindle, gc_state.modal.spindle.state, gc_state.spindle.rpm);
 801cc8e:	4b19      	ldr	r3, [pc, #100]	; (801ccf4 <spindle_set_override+0xbc>)
 801cc90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801cc92:	4918      	ldr	r1, [pc, #96]	; (801ccf4 <spindle_set_override+0xbc>)
 801cc94:	461a      	mov	r2, r3
 801cc96:	7e89      	ldrb	r1, [r1, #26]
 801cc98:	6878      	ldr	r0, [r7, #4]
 801cc9a:	f000 f89b 	bl	801cdd4 <spindle_set_state>
 801cc9e:	e004      	b.n	801ccaa <spindle_set_override+0x72>
        else
            sys.step_control.update_spindle_rpm = On;
 801cca0:	4a15      	ldr	r2, [pc, #84]	; (801ccf8 <spindle_set_override+0xc0>)
 801cca2:	7e13      	ldrb	r3, [r2, #24]
 801cca4:	f043 0308 	orr.w	r3, r3, #8
 801cca8:	7613      	strb	r3, [r2, #24]

        system_add_rt_report(Report_Overrides); // Set to report change immediately
 801ccaa:	2040      	movs	r0, #64	; 0x40
 801ccac:	f005 f976 	bl	8021f9c <system_add_rt_report>

       if(grbl.on_spindle_programmed)
 801ccb0:	4b12      	ldr	r3, [pc, #72]	; (801ccfc <spindle_set_override+0xc4>)
 801ccb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801ccb4:	2b00      	cmp	r3, #0
 801ccb6:	d00f      	beq.n	801ccd8 <spindle_set_override+0xa0>
           grbl.on_spindle_programmed(spindle, gc_state.modal.spindle.state, spindle_set_rpm(spindle, gc_state.spindle.rpm, speed_override), gc_state.modal.spindle.rpm_mode);
 801ccb8:	4b10      	ldr	r3, [pc, #64]	; (801ccfc <spindle_set_override+0xc4>)
 801ccba:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 801ccbc:	4b0d      	ldr	r3, [pc, #52]	; (801ccf4 <spindle_set_override+0xbc>)
 801ccbe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801ccc0:	683a      	ldr	r2, [r7, #0]
 801ccc2:	4619      	mov	r1, r3
 801ccc4:	6878      	ldr	r0, [r7, #4]
 801ccc6:	f000 f9b7 	bl	801d038 <spindle_set_rpm>
 801ccca:	4602      	mov	r2, r0
 801cccc:	4b09      	ldr	r3, [pc, #36]	; (801ccf4 <spindle_set_override+0xbc>)
 801ccce:	7edb      	ldrb	r3, [r3, #27]
 801ccd0:	4908      	ldr	r1, [pc, #32]	; (801ccf4 <spindle_set_override+0xbc>)
 801ccd2:	7e89      	ldrb	r1, [r1, #26]
 801ccd4:	6878      	ldr	r0, [r7, #4]
 801ccd6:	47a0      	blx	r4

       if(grbl.on_override_changed)
 801ccd8:	4b08      	ldr	r3, [pc, #32]	; (801ccfc <spindle_set_override+0xc4>)
 801ccda:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801ccdc:	2b00      	cmp	r3, #0
 801ccde:	d005      	beq.n	801ccec <spindle_set_override+0xb4>
           grbl.on_override_changed(OverrideChanged_SpindleRPM);
 801cce0:	4b06      	ldr	r3, [pc, #24]	; (801ccfc <spindle_set_override+0xc4>)
 801cce2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801cce4:	2000      	movs	r0, #0
 801cce6:	4798      	blx	r3
 801cce8:	e000      	b.n	801ccec <spindle_set_override+0xb4>
        return;
 801ccea:	bf00      	nop
    }
}
 801ccec:	370c      	adds	r7, #12
 801ccee:	46bd      	mov	sp, r7
 801ccf0:	bd90      	pop	{r4, r7, pc}
 801ccf2:	bf00      	nop
 801ccf4:	20000bb0 	.word	0x20000bb0
 801ccf8:	20000d3c 	.word	0x20000d3c
 801ccfc:	20000dd4 	.word	0x20000dd4

0801cd00 <set_state>:
\param state a \ref spindle_state_t structure.
\param rpm the spindle RPM to set.
\returns \a true if successful, \a false if the current controller state is \ref ABORTED.
*/
static bool set_state (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 801cd00:	b590      	push	{r4, r7, lr}
 801cd02:	b085      	sub	sp, #20
 801cd04:	af00      	add	r7, sp, #0
 801cd06:	60f8      	str	r0, [r7, #12]
 801cd08:	7239      	strb	r1, [r7, #8]
 801cd0a:	607a      	str	r2, [r7, #4]
    if (!ABORTED) { // Block during abort.
 801cd0c:	4b30      	ldr	r3, [pc, #192]	; (801cdd0 <set_state+0xd0>)
 801cd0e:	781b      	ldrb	r3, [r3, #0]
 801cd10:	f083 0301 	eor.w	r3, r3, #1
 801cd14:	b2db      	uxtb	r3, r3
 801cd16:	2b00      	cmp	r3, #0
 801cd18:	d041      	beq.n	801cd9e <set_state+0x9e>
 801cd1a:	4b2d      	ldr	r3, [pc, #180]	; (801cdd0 <set_state+0xd0>)
 801cd1c:	785b      	ldrb	r3, [r3, #1]
 801cd1e:	f083 0301 	eor.w	r3, r3, #1
 801cd22:	b2db      	uxtb	r3, r3
 801cd24:	2b00      	cmp	r3, #0
 801cd26:	d03a      	beq.n	801cd9e <set_state+0x9e>

        if (!state.on) { // Halt or set spindle direction and rpm.
 801cd28:	7a3b      	ldrb	r3, [r7, #8]
 801cd2a:	f003 0301 	and.w	r3, r3, #1
 801cd2e:	b2db      	uxtb	r3, r3
 801cd30:	2b00      	cmp	r3, #0
 801cd32:	d10f      	bne.n	801cd54 <set_state+0x54>
            spindle->param->rpm = rpm = 0.0f;
 801cd34:	f04f 0300 	mov.w	r3, #0
 801cd38:	607b      	str	r3, [r7, #4]
 801cd3a:	68fb      	ldr	r3, [r7, #12]
 801cd3c:	685b      	ldr	r3, [r3, #4]
 801cd3e:	687a      	ldr	r2, [r7, #4]
 801cd40:	601a      	str	r2, [r3, #0]
            spindle->set_state(spindle, (spindle_state_t){0}, 0.0f);
 801cd42:	68fb      	ldr	r3, [r7, #12]
 801cd44:	6a1b      	ldr	r3, [r3, #32]
 801cd46:	2200      	movs	r2, #0
 801cd48:	4611      	mov	r1, r2
 801cd4a:	f04f 0200 	mov.w	r2, #0
 801cd4e:	68f8      	ldr	r0, [r7, #12]
 801cd50:	4798      	blx	r3
 801cd52:	e01e      	b.n	801cd92 <set_state+0x92>
        } else {
            // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
            // TODO: alarm/interlock if going from CW to CCW directly in non-laser mode?
            if (spindle->cap.laser && state.ccw)
 801cd54:	68fb      	ldr	r3, [r7, #12]
 801cd56:	7a9b      	ldrb	r3, [r3, #10]
 801cd58:	f003 0308 	and.w	r3, r3, #8
 801cd5c:	b2db      	uxtb	r3, r3
 801cd5e:	2b00      	cmp	r3, #0
 801cd60:	d008      	beq.n	801cd74 <set_state+0x74>
 801cd62:	7a3b      	ldrb	r3, [r7, #8]
 801cd64:	f003 0302 	and.w	r3, r3, #2
 801cd68:	b2db      	uxtb	r3, r3
 801cd6a:	2b00      	cmp	r3, #0
 801cd6c:	d002      	beq.n	801cd74 <set_state+0x74>
                rpm = 0.0f; // TODO: May need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE);
 801cd6e:	f04f 0300 	mov.w	r3, #0
 801cd72:	607b      	str	r3, [r7, #4]

            spindle->set_state(spindle, state, spindle_set_rpm(spindle, rpm, spindle->param->override_pct));
 801cd74:	68fb      	ldr	r3, [r7, #12]
 801cd76:	6a1c      	ldr	r4, [r3, #32]
 801cd78:	68fb      	ldr	r3, [r7, #12]
 801cd7a:	685b      	ldr	r3, [r3, #4]
 801cd7c:	68db      	ldr	r3, [r3, #12]
 801cd7e:	461a      	mov	r2, r3
 801cd80:	6879      	ldr	r1, [r7, #4]
 801cd82:	68f8      	ldr	r0, [r7, #12]
 801cd84:	f000 f958 	bl	801d038 <spindle_set_rpm>
 801cd88:	4603      	mov	r3, r0
 801cd8a:	461a      	mov	r2, r3
 801cd8c:	7a39      	ldrb	r1, [r7, #8]
 801cd8e:	68f8      	ldr	r0, [r7, #12]
 801cd90:	47a0      	blx	r4
        }

        system_add_rt_report(Report_Spindle); // Set to report change immediately
 801cd92:	2010      	movs	r0, #16
 801cd94:	f005 f902 	bl	8021f9c <system_add_rt_report>

        st_rpm_changed(rpm);
 801cd98:	6878      	ldr	r0, [r7, #4]
 801cd9a:	f002 f9e5 	bl	801f168 <st_rpm_changed>
    }

    return !ABORTED;
 801cd9e:	4b0c      	ldr	r3, [pc, #48]	; (801cdd0 <set_state+0xd0>)
 801cda0:	781b      	ldrb	r3, [r3, #0]
 801cda2:	f083 0301 	eor.w	r3, r3, #1
 801cda6:	b2db      	uxtb	r3, r3
 801cda8:	2b00      	cmp	r3, #0
 801cdaa:	d008      	beq.n	801cdbe <set_state+0xbe>
 801cdac:	4b08      	ldr	r3, [pc, #32]	; (801cdd0 <set_state+0xd0>)
 801cdae:	785b      	ldrb	r3, [r3, #1]
 801cdb0:	f083 0301 	eor.w	r3, r3, #1
 801cdb4:	b2db      	uxtb	r3, r3
 801cdb6:	2b00      	cmp	r3, #0
 801cdb8:	d001      	beq.n	801cdbe <set_state+0xbe>
 801cdba:	2301      	movs	r3, #1
 801cdbc:	e000      	b.n	801cdc0 <set_state+0xc0>
 801cdbe:	2300      	movs	r3, #0
 801cdc0:	f003 0301 	and.w	r3, r3, #1
 801cdc4:	b2db      	uxtb	r3, r3
}
 801cdc6:	4618      	mov	r0, r3
 801cdc8:	3714      	adds	r7, #20
 801cdca:	46bd      	mov	sp, r7
 801cdcc:	bd90      	pop	{r4, r7, pc}
 801cdce:	bf00      	nop
 801cdd0:	20000d3c 	.word	0x20000d3c

0801cdd4 <spindle_set_state>:
\param state a \ref spindle_state_t structure.
\param rpm the spindle RPM to set.
\returns \a true if successful, \a false if the current controller state is \ref ABORTED.
*/
bool spindle_set_state (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 801cdd4:	b580      	push	{r7, lr}
 801cdd6:	b084      	sub	sp, #16
 801cdd8:	af00      	add	r7, sp, #0
 801cdda:	60f8      	str	r0, [r7, #12]
 801cddc:	7239      	strb	r1, [r7, #8]
 801cdde:	607a      	str	r2, [r7, #4]
    return set_state(spindle, state, rpm);
 801cde0:	687a      	ldr	r2, [r7, #4]
 801cde2:	7a39      	ldrb	r1, [r7, #8]
 801cde4:	68f8      	ldr	r0, [r7, #12]
 801cde6:	f7ff ff8b 	bl	801cd00 <set_state>
 801cdea:	4603      	mov	r3, r0
}
 801cdec:	4618      	mov	r0, r3
 801cdee:	3710      	adds	r7, #16
 801cdf0:	46bd      	mov	sp, r7
 801cdf2:	bd80      	pop	{r7, pc}

0801cdf4 <spindle_sync>:
\param state a \ref spindle_state_t structure.
\param rpm the spindle RPM to set.
\returns \a true if successful, \a false if the current controller state is \ref ABORTED.
*/
bool spindle_sync (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 801cdf4:	b580      	push	{r7, lr}
 801cdf6:	b086      	sub	sp, #24
 801cdf8:	af00      	add	r7, sp, #0
 801cdfa:	60f8      	str	r0, [r7, #12]
 801cdfc:	7239      	strb	r1, [r7, #8]
 801cdfe:	607a      	str	r2, [r7, #4]
    bool ok;

    if (!(ok = state_get() == STATE_CHECK_MODE)) {
 801ce00:	f000 fd5e 	bl	801d8c0 <state_get>
 801ce04:	4603      	mov	r3, r0
 801ce06:	2b02      	cmp	r3, #2
 801ce08:	bf0c      	ite	eq
 801ce0a:	2301      	moveq	r3, #1
 801ce0c:	2300      	movne	r3, #0
 801ce0e:	75fb      	strb	r3, [r7, #23]
 801ce10:	7dfb      	ldrb	r3, [r7, #23]
 801ce12:	f083 0301 	eor.w	r3, r3, #1
 801ce16:	b2db      	uxtb	r3, r3
 801ce18:	2b00      	cmp	r3, #0
 801ce1a:	d076      	beq.n	801cf0a <spindle_sync+0x116>

        bool at_speed = !state.on || !spindle->cap.at_speed || settings.spindle.at_speed_tolerance <= 0.0f;
 801ce1c:	7a3b      	ldrb	r3, [r7, #8]
 801ce1e:	f003 0301 	and.w	r3, r3, #1
 801ce22:	b2db      	uxtb	r3, r3
 801ce24:	2b00      	cmp	r3, #0
 801ce26:	d011      	beq.n	801ce4c <spindle_sync+0x58>
 801ce28:	68fb      	ldr	r3, [r7, #12]
 801ce2a:	7a9b      	ldrb	r3, [r3, #10]
 801ce2c:	f003 0304 	and.w	r3, r3, #4
 801ce30:	b2db      	uxtb	r3, r3
 801ce32:	2b00      	cmp	r3, #0
 801ce34:	d00a      	beq.n	801ce4c <spindle_sync+0x58>
 801ce36:	4b37      	ldr	r3, [pc, #220]	; (801cf14 <spindle_sync+0x120>)
 801ce38:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801ce3c:	f04f 0100 	mov.w	r1, #0
 801ce40:	4618      	mov	r0, r3
 801ce42:	f7e4 f95f 	bl	8001104 <__aeabi_fcmple>
 801ce46:	4603      	mov	r3, r0
 801ce48:	2b00      	cmp	r3, #0
 801ce4a:	d001      	beq.n	801ce50 <spindle_sync+0x5c>
 801ce4c:	2301      	movs	r3, #1
 801ce4e:	e000      	b.n	801ce52 <spindle_sync+0x5e>
 801ce50:	2300      	movs	r3, #0
 801ce52:	75bb      	strb	r3, [r7, #22]
 801ce54:	7dbb      	ldrb	r3, [r7, #22]
 801ce56:	f003 0301 	and.w	r3, r3, #1
 801ce5a:	75bb      	strb	r3, [r7, #22]

        // Empty planner buffer to ensure spindle is set when programmed.
        if((ok = protocol_buffer_synchronize()) && set_state(spindle, state, rpm) && !at_speed) {
 801ce5c:	f7f5 ff50 	bl	8012d00 <protocol_buffer_synchronize>
 801ce60:	4603      	mov	r3, r0
 801ce62:	75fb      	strb	r3, [r7, #23]
 801ce64:	7dfb      	ldrb	r3, [r7, #23]
 801ce66:	2b00      	cmp	r3, #0
 801ce68:	d047      	beq.n	801cefa <spindle_sync+0x106>
 801ce6a:	687a      	ldr	r2, [r7, #4]
 801ce6c:	7a39      	ldrb	r1, [r7, #8]
 801ce6e:	68f8      	ldr	r0, [r7, #12]
 801ce70:	f7ff ff46 	bl	801cd00 <set_state>
 801ce74:	4603      	mov	r3, r0
 801ce76:	2b00      	cmp	r3, #0
 801ce78:	d03f      	beq.n	801cefa <spindle_sync+0x106>
 801ce7a:	7dbb      	ldrb	r3, [r7, #22]
 801ce7c:	f083 0301 	eor.w	r3, r3, #1
 801ce80:	b2db      	uxtb	r3, r3
 801ce82:	2b00      	cmp	r3, #0
 801ce84:	d039      	beq.n	801cefa <spindle_sync+0x106>
            float on_delay = 0.0f;
 801ce86:	f04f 0300 	mov.w	r3, #0
 801ce8a:	613b      	str	r3, [r7, #16]
            while(!(at_speed = spindle->get_state(spindle).at_speed)) {
 801ce8c:	e022      	b.n	801ced4 <spindle_sync+0xe0>
                delay_sec(0.2f, DelayMode_Dwell);
 801ce8e:	2100      	movs	r1, #0
 801ce90:	4821      	ldr	r0, [pc, #132]	; (801cf18 <spindle_sync+0x124>)
 801ce92:	f7f3 fc77 	bl	8010784 <delay_sec>
                on_delay += 0.2f;
 801ce96:	4920      	ldr	r1, [pc, #128]	; (801cf18 <spindle_sync+0x124>)
 801ce98:	6938      	ldr	r0, [r7, #16]
 801ce9a:	f7e3 fe83 	bl	8000ba4 <__addsf3>
 801ce9e:	4603      	mov	r3, r0
 801cea0:	613b      	str	r3, [r7, #16]
                if(ABORTED)
 801cea2:	4b1e      	ldr	r3, [pc, #120]	; (801cf1c <spindle_sync+0x128>)
 801cea4:	781b      	ldrb	r3, [r3, #0]
 801cea6:	2b00      	cmp	r3, #0
 801cea8:	d127      	bne.n	801cefa <spindle_sync+0x106>
 801ceaa:	4b1c      	ldr	r3, [pc, #112]	; (801cf1c <spindle_sync+0x128>)
 801ceac:	785b      	ldrb	r3, [r3, #1]
 801ceae:	2b00      	cmp	r3, #0
 801ceb0:	d123      	bne.n	801cefa <spindle_sync+0x106>
                    break;
                if(on_delay >= settings.safety_door.spindle_on_delay) {
 801ceb2:	4b18      	ldr	r3, [pc, #96]	; (801cf14 <spindle_sync+0x120>)
 801ceb4:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 801ceb8:	4619      	mov	r1, r3
 801ceba:	6938      	ldr	r0, [r7, #16]
 801cebc:	f7e4 f92c 	bl	8001118 <__aeabi_fcmpge>
 801cec0:	4603      	mov	r3, r0
 801cec2:	2b00      	cmp	r3, #0
 801cec4:	d100      	bne.n	801cec8 <spindle_sync+0xd4>
 801cec6:	e005      	b.n	801ced4 <spindle_sync+0xe0>
                    gc_spindle_off();
 801cec8:	f7e8 ff68 	bl	8005d9c <gc_spindle_off>
                    system_raise_alarm(Alarm_Spindle);
 801cecc:	200e      	movs	r0, #14
 801cece:	f004 fff9 	bl	8021ec4 <system_raise_alarm>
                    break;
 801ced2:	e012      	b.n	801cefa <spindle_sync+0x106>
            while(!(at_speed = spindle->get_state(spindle).at_speed)) {
 801ced4:	68fb      	ldr	r3, [r7, #12]
 801ced6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ced8:	68f8      	ldr	r0, [r7, #12]
 801ceda:	4798      	blx	r3
 801cedc:	4603      	mov	r3, r0
 801cede:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801cee2:	b2db      	uxtb	r3, r3
 801cee4:	2b00      	cmp	r3, #0
 801cee6:	bf14      	ite	ne
 801cee8:	2301      	movne	r3, #1
 801ceea:	2300      	moveq	r3, #0
 801ceec:	75bb      	strb	r3, [r7, #22]
 801ceee:	7dbb      	ldrb	r3, [r7, #22]
 801cef0:	f083 0301 	eor.w	r3, r3, #1
 801cef4:	b2db      	uxtb	r3, r3
 801cef6:	2b00      	cmp	r3, #0
 801cef8:	d1c9      	bne.n	801ce8e <spindle_sync+0x9a>
                }
            }
        }

        ok &= at_speed;
 801cefa:	7dfa      	ldrb	r2, [r7, #23]
 801cefc:	7dbb      	ldrb	r3, [r7, #22]
 801cefe:	4013      	ands	r3, r2
 801cf00:	2b00      	cmp	r3, #0
 801cf02:	bf14      	ite	ne
 801cf04:	2301      	movne	r3, #1
 801cf06:	2300      	moveq	r3, #0
 801cf08:	75fb      	strb	r3, [r7, #23]
    }

    return ok;
 801cf0a:	7dfb      	ldrb	r3, [r7, #23]
}
 801cf0c:	4618      	mov	r0, r3
 801cf0e:	3718      	adds	r7, #24
 801cf10:	46bd      	mov	sp, r7
 801cf12:	bd80      	pop	{r7, pc}
 801cf14:	2000147c 	.word	0x2000147c
 801cf18:	3e4ccccd 	.word	0x3e4ccccd
 801cf1c:	20000d3c 	.word	0x20000d3c

0801cf20 <spindle_restore>:
\param state a \ref spindle_state_t structure.
\param rpm the spindle RPM to set.
\returns \a true if successful, \a false if the current controller state is \ref ABORTED.
*/
bool spindle_restore (spindle_ptrs_t *spindle, spindle_state_t state, float rpm)
{
 801cf20:	b5b0      	push	{r4, r5, r7, lr}
 801cf22:	b086      	sub	sp, #24
 801cf24:	af00      	add	r7, sp, #0
 801cf26:	60f8      	str	r0, [r7, #12]
 801cf28:	7239      	strb	r1, [r7, #8]
 801cf2a:	607a      	str	r2, [r7, #4]
    bool ok = true;
 801cf2c:	2301      	movs	r3, #1
 801cf2e:	75fb      	strb	r3, [r7, #23]

    if(spindle->cap.laser) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 801cf30:	68fb      	ldr	r3, [r7, #12]
 801cf32:	7a9b      	ldrb	r3, [r3, #10]
 801cf34:	f003 0308 	and.w	r3, r3, #8
 801cf38:	b2db      	uxtb	r3, r3
 801cf3a:	2b00      	cmp	r3, #0
 801cf3c:	d005      	beq.n	801cf4a <spindle_restore+0x2a>
        sys.step_control.update_spindle_rpm = On;
 801cf3e:	4a3b      	ldr	r2, [pc, #236]	; (801d02c <spindle_restore+0x10c>)
 801cf40:	7e13      	ldrb	r3, [r2, #24]
 801cf42:	f043 0308 	orr.w	r3, r3, #8
 801cf46:	7613      	strb	r3, [r2, #24]
 801cf48:	e06a      	b.n	801d020 <spindle_restore+0x100>
    else { // TODO: add check for current spindle state matches restore state?
        spindle_set_state(spindle, state, rpm);
 801cf4a:	687a      	ldr	r2, [r7, #4]
 801cf4c:	7a39      	ldrb	r1, [r7, #8]
 801cf4e:	68f8      	ldr	r0, [r7, #12]
 801cf50:	f7ff ff40 	bl	801cdd4 <spindle_set_state>
        if(state.on) {
 801cf54:	7a3b      	ldrb	r3, [r7, #8]
 801cf56:	f003 0301 	and.w	r3, r3, #1
 801cf5a:	b2db      	uxtb	r3, r3
 801cf5c:	2b00      	cmp	r3, #0
 801cf5e:	d05f      	beq.n	801d020 <spindle_restore+0x100>
            if((ok = !spindle->cap.at_speed))
 801cf60:	68fb      	ldr	r3, [r7, #12]
 801cf62:	7a9b      	ldrb	r3, [r3, #10]
 801cf64:	f003 0304 	and.w	r3, r3, #4
 801cf68:	b2db      	uxtb	r3, r3
 801cf6a:	2b00      	cmp	r3, #0
 801cf6c:	bf0c      	ite	eq
 801cf6e:	2301      	moveq	r3, #1
 801cf70:	2300      	movne	r3, #0
 801cf72:	75fb      	strb	r3, [r7, #23]
 801cf74:	7dfb      	ldrb	r3, [r7, #23]
 801cf76:	2b00      	cmp	r3, #0
 801cf78:	d007      	beq.n	801cf8a <spindle_restore+0x6a>
                delay_sec(settings.safety_door.spindle_on_delay, DelayMode_SysSuspend);
 801cf7a:	4b2d      	ldr	r3, [pc, #180]	; (801d030 <spindle_restore+0x110>)
 801cf7c:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 801cf80:	2101      	movs	r1, #1
 801cf82:	4618      	mov	r0, r3
 801cf84:	f7f3 fbfe 	bl	8010784 <delay_sec>
 801cf88:	e04a      	b.n	801d020 <spindle_restore+0x100>
            else if((ok == (settings.spindle.at_speed_tolerance <= 0.0f))) {
 801cf8a:	7dfc      	ldrb	r4, [r7, #23]
 801cf8c:	4b28      	ldr	r3, [pc, #160]	; (801d030 <spindle_restore+0x110>)
 801cf8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801cf92:	2201      	movs	r2, #1
 801cf94:	4615      	mov	r5, r2
 801cf96:	f04f 0100 	mov.w	r1, #0
 801cf9a:	4618      	mov	r0, r3
 801cf9c:	f7e4 f8b2 	bl	8001104 <__aeabi_fcmple>
 801cfa0:	4603      	mov	r3, r0
 801cfa2:	2b00      	cmp	r3, #0
 801cfa4:	d101      	bne.n	801cfaa <spindle_restore+0x8a>
 801cfa6:	2300      	movs	r3, #0
 801cfa8:	461d      	mov	r5, r3
 801cfaa:	b2eb      	uxtb	r3, r5
 801cfac:	429c      	cmp	r4, r3
 801cfae:	d137      	bne.n	801d020 <spindle_restore+0x100>
                float delay = 0.0f;
 801cfb0:	f04f 0300 	mov.w	r3, #0
 801cfb4:	613b      	str	r3, [r7, #16]
                while(!(ok = spindle->get_state(spindle).at_speed)) {
 801cfb6:	e020      	b.n	801cffa <spindle_restore+0xda>
                    delay_sec(0.1f, DelayMode_SysSuspend);
 801cfb8:	2101      	movs	r1, #1
 801cfba:	481e      	ldr	r0, [pc, #120]	; (801d034 <spindle_restore+0x114>)
 801cfbc:	f7f3 fbe2 	bl	8010784 <delay_sec>
                    delay += 0.1f;
 801cfc0:	491c      	ldr	r1, [pc, #112]	; (801d034 <spindle_restore+0x114>)
 801cfc2:	6938      	ldr	r0, [r7, #16]
 801cfc4:	f7e3 fdee 	bl	8000ba4 <__addsf3>
 801cfc8:	4603      	mov	r3, r0
 801cfca:	613b      	str	r3, [r7, #16]
                    if(ABORTED)
 801cfcc:	4b17      	ldr	r3, [pc, #92]	; (801d02c <spindle_restore+0x10c>)
 801cfce:	781b      	ldrb	r3, [r3, #0]
 801cfd0:	2b00      	cmp	r3, #0
 801cfd2:	d125      	bne.n	801d020 <spindle_restore+0x100>
 801cfd4:	4b15      	ldr	r3, [pc, #84]	; (801d02c <spindle_restore+0x10c>)
 801cfd6:	785b      	ldrb	r3, [r3, #1]
 801cfd8:	2b00      	cmp	r3, #0
 801cfda:	d121      	bne.n	801d020 <spindle_restore+0x100>
                        break;
                    if(delay >= settings.safety_door.spindle_on_delay) {
 801cfdc:	4b14      	ldr	r3, [pc, #80]	; (801d030 <spindle_restore+0x110>)
 801cfde:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 801cfe2:	4619      	mov	r1, r3
 801cfe4:	6938      	ldr	r0, [r7, #16]
 801cfe6:	f7e4 f897 	bl	8001118 <__aeabi_fcmpge>
 801cfea:	4603      	mov	r3, r0
 801cfec:	2b00      	cmp	r3, #0
 801cfee:	d100      	bne.n	801cff2 <spindle_restore+0xd2>
 801cff0:	e003      	b.n	801cffa <spindle_restore+0xda>
                        system_raise_alarm(Alarm_Spindle);
 801cff2:	200e      	movs	r0, #14
 801cff4:	f004 ff66 	bl	8021ec4 <system_raise_alarm>
                        break;
 801cff8:	e012      	b.n	801d020 <spindle_restore+0x100>
                while(!(ok = spindle->get_state(spindle).at_speed)) {
 801cffa:	68fb      	ldr	r3, [r7, #12]
 801cffc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801cffe:	68f8      	ldr	r0, [r7, #12]
 801d000:	4798      	blx	r3
 801d002:	4603      	mov	r3, r0
 801d004:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801d008:	b2db      	uxtb	r3, r3
 801d00a:	2b00      	cmp	r3, #0
 801d00c:	bf14      	ite	ne
 801d00e:	2301      	movne	r3, #1
 801d010:	2300      	moveq	r3, #0
 801d012:	75fb      	strb	r3, [r7, #23]
 801d014:	7dfb      	ldrb	r3, [r7, #23]
 801d016:	f083 0301 	eor.w	r3, r3, #1
 801d01a:	b2db      	uxtb	r3, r3
 801d01c:	2b00      	cmp	r3, #0
 801d01e:	d1cb      	bne.n	801cfb8 <spindle_restore+0x98>
                }
            }
        }
    }

    return ok;
 801d020:	7dfb      	ldrb	r3, [r7, #23]
}
 801d022:	4618      	mov	r0, r3
 801d024:	3718      	adds	r7, #24
 801d026:	46bd      	mov	sp, r7
 801d028:	bdb0      	pop	{r4, r5, r7, pc}
 801d02a:	bf00      	nop
 801d02c:	20000d3c 	.word	0x20000d3c
 801d030:	2000147c 	.word	0x2000147c
 801d034:	3dcccccd 	.word	0x3dcccccd

0801d038 <spindle_set_rpm>:
\param rpm the programmed RPM.
\param override_pct override value in percent.
\returns the calulated RPM.
*/
float spindle_set_rpm (spindle_ptrs_t *spindle, float rpm, override_t override_pct)
{
 801d038:	b580      	push	{r7, lr}
 801d03a:	b084      	sub	sp, #16
 801d03c:	af00      	add	r7, sp, #0
 801d03e:	60f8      	str	r0, [r7, #12]
 801d040:	60b9      	str	r1, [r7, #8]
 801d042:	607a      	str	r2, [r7, #4]
    if(override_pct != 100)
 801d044:	687b      	ldr	r3, [r7, #4]
 801d046:	2b64      	cmp	r3, #100	; 0x64
 801d048:	d00e      	beq.n	801d068 <spindle_set_rpm+0x30>
        rpm *= 0.01f * (float)override_pct; // Scale RPM by override value.
 801d04a:	6878      	ldr	r0, [r7, #4]
 801d04c:	f7e3 fe5a 	bl	8000d04 <__aeabi_ui2f>
 801d050:	4603      	mov	r3, r0
 801d052:	491e      	ldr	r1, [pc, #120]	; (801d0cc <spindle_set_rpm+0x94>)
 801d054:	4618      	mov	r0, r3
 801d056:	f7e3 fead 	bl	8000db4 <__aeabi_fmul>
 801d05a:	4603      	mov	r3, r0
 801d05c:	4619      	mov	r1, r3
 801d05e:	68b8      	ldr	r0, [r7, #8]
 801d060:	f7e3 fea8 	bl	8000db4 <__aeabi_fmul>
 801d064:	4603      	mov	r3, r0
 801d066:	60bb      	str	r3, [r7, #8]

    // Apply RPM limits
    if (rpm <= 0.0f) // TODO: remove this test?
 801d068:	f04f 0100 	mov.w	r1, #0
 801d06c:	68b8      	ldr	r0, [r7, #8]
 801d06e:	f7e4 f849 	bl	8001104 <__aeabi_fcmple>
 801d072:	4603      	mov	r3, r0
 801d074:	2b00      	cmp	r3, #0
 801d076:	d003      	beq.n	801d080 <spindle_set_rpm+0x48>
        rpm = 0.0f;
 801d078:	f04f 0300 	mov.w	r3, #0
 801d07c:	60bb      	str	r3, [r7, #8]
 801d07e:	e018      	b.n	801d0b2 <spindle_set_rpm+0x7a>
    else if (rpm > spindle->rpm_max)
 801d080:	68fb      	ldr	r3, [r7, #12]
 801d082:	699b      	ldr	r3, [r3, #24]
 801d084:	4619      	mov	r1, r3
 801d086:	68b8      	ldr	r0, [r7, #8]
 801d088:	f7e4 f850 	bl	800112c <__aeabi_fcmpgt>
 801d08c:	4603      	mov	r3, r0
 801d08e:	2b00      	cmp	r3, #0
 801d090:	d003      	beq.n	801d09a <spindle_set_rpm+0x62>
        rpm = spindle->rpm_max;
 801d092:	68fb      	ldr	r3, [r7, #12]
 801d094:	699b      	ldr	r3, [r3, #24]
 801d096:	60bb      	str	r3, [r7, #8]
 801d098:	e00b      	b.n	801d0b2 <spindle_set_rpm+0x7a>
    else if (rpm < spindle->rpm_min)
 801d09a:	68fb      	ldr	r3, [r7, #12]
 801d09c:	695b      	ldr	r3, [r3, #20]
 801d09e:	4619      	mov	r1, r3
 801d0a0:	68b8      	ldr	r0, [r7, #8]
 801d0a2:	f7e4 f825 	bl	80010f0 <__aeabi_fcmplt>
 801d0a6:	4603      	mov	r3, r0
 801d0a8:	2b00      	cmp	r3, #0
 801d0aa:	d002      	beq.n	801d0b2 <spindle_set_rpm+0x7a>
        rpm = spindle->rpm_min;
 801d0ac:	68fb      	ldr	r3, [r7, #12]
 801d0ae:	695b      	ldr	r3, [r3, #20]
 801d0b0:	60bb      	str	r3, [r7, #8]

    spindle->param->rpm_overridden = rpm;
 801d0b2:	68fb      	ldr	r3, [r7, #12]
 801d0b4:	685b      	ldr	r3, [r3, #4]
 801d0b6:	68ba      	ldr	r2, [r7, #8]
 801d0b8:	605a      	str	r2, [r3, #4]
    spindle->param->override_pct = override_pct;
 801d0ba:	68fb      	ldr	r3, [r7, #12]
 801d0bc:	685b      	ldr	r3, [r3, #4]
 801d0be:	687a      	ldr	r2, [r7, #4]
 801d0c0:	60da      	str	r2, [r3, #12]

    return rpm;
 801d0c2:	68bb      	ldr	r3, [r7, #8]
}
 801d0c4:	4618      	mov	r0, r3
 801d0c6:	3710      	adds	r7, #16
 801d0c8:	46bd      	mov	sp, r7
 801d0ca:	bd80      	pop	{r7, pc}
 801d0cc:	3c23d70a 	.word	0x3c23d70a

0801d0d0 <spindle_all_off>:

/*! \brief Turn off all enabled spindles.
*/
void spindle_all_off (void)
{
 801d0d0:	b580      	push	{r7, lr}
 801d0d2:	b082      	sub	sp, #8
 801d0d4:	af00      	add	r7, sp, #0
    spindle_ptrs_t *spindle;
    uint_fast8_t spindle_num = N_SYS_SPINDLE;
 801d0d6:	2301      	movs	r3, #1
 801d0d8:	607b      	str	r3, [r7, #4]

    do {
        if((spindle = spindle_get(--spindle_num))) {
 801d0da:	687b      	ldr	r3, [r7, #4]
 801d0dc:	3b01      	subs	r3, #1
 801d0de:	607b      	str	r3, [r7, #4]
 801d0e0:	687b      	ldr	r3, [r7, #4]
 801d0e2:	b25b      	sxtb	r3, r3
 801d0e4:	4618      	mov	r0, r3
 801d0e6:	f7ff fd09 	bl	801cafc <spindle_get>
 801d0ea:	6038      	str	r0, [r7, #0]
 801d0ec:	683b      	ldr	r3, [r7, #0]
 801d0ee:	2b00      	cmp	r3, #0
 801d0f0:	d014      	beq.n	801d11c <spindle_all_off+0x4c>
            spindle->param->rpm = spindle->param->rpm_overridden = 0.0f;
 801d0f2:	683b      	ldr	r3, [r7, #0]
 801d0f4:	685b      	ldr	r3, [r3, #4]
 801d0f6:	f04f 0200 	mov.w	r2, #0
 801d0fa:	605a      	str	r2, [r3, #4]
 801d0fc:	683a      	ldr	r2, [r7, #0]
 801d0fe:	6852      	ldr	r2, [r2, #4]
 801d100:	685b      	ldr	r3, [r3, #4]
 801d102:	6013      	str	r3, [r2, #0]
            spindle->param->state.value = 0;
 801d104:	683b      	ldr	r3, [r7, #0]
 801d106:	685b      	ldr	r3, [r3, #4]
 801d108:	2200      	movs	r2, #0
 801d10a:	721a      	strb	r2, [r3, #8]
#ifdef GRBL_ESP32
            spindle->esp32_off(spindle);
#else
            spindle->set_state(spindle, (spindle_state_t){0}, 0.0f);
 801d10c:	683b      	ldr	r3, [r7, #0]
 801d10e:	6a1b      	ldr	r3, [r3, #32]
 801d110:	2200      	movs	r2, #0
 801d112:	4611      	mov	r1, r2
 801d114:	f04f 0200 	mov.w	r2, #0
 801d118:	6838      	ldr	r0, [r7, #0]
 801d11a:	4798      	blx	r3
#endif
        }
    } while(spindle_num);
 801d11c:	687b      	ldr	r3, [r7, #4]
 801d11e:	2b00      	cmp	r3, #0
 801d120:	d1db      	bne.n	801d0da <spindle_all_off+0xa>

    system_add_rt_report(Report_Spindle);
 801d122:	2010      	movs	r0, #16
 801d124:	f004 ff3a 	bl	8021f9c <system_add_rt_report>
}
 801d128:	bf00      	nop
 801d12a:	3708      	adds	r7, #8
 801d12c:	46bd      	mov	sp, r7
 801d12e:	bd80      	pop	{r7, pc}

0801d130 <spindle_is_on>:

/*! \brief Check if any of the enabled spindles is running.
\returns \a true if a spindle is running, \a false otherwise.
*/
bool spindle_is_on (void)
{
 801d130:	b580      	push	{r7, lr}
 801d132:	b084      	sub	sp, #16
 801d134:	af00      	add	r7, sp, #0
    bool on = false;
 801d136:	2300      	movs	r3, #0
 801d138:	73fb      	strb	r3, [r7, #15]

    spindle_ptrs_t *spindle;
    uint_fast8_t spindle_num = N_SYS_SPINDLE;
 801d13a:	2301      	movs	r3, #1
 801d13c:	60bb      	str	r3, [r7, #8]
    do {
        if((spindle = spindle_get(--spindle_num)))
 801d13e:	68bb      	ldr	r3, [r7, #8]
 801d140:	3b01      	subs	r3, #1
 801d142:	60bb      	str	r3, [r7, #8]
 801d144:	68bb      	ldr	r3, [r7, #8]
 801d146:	b25b      	sxtb	r3, r3
 801d148:	4618      	mov	r0, r3
 801d14a:	f7ff fcd7 	bl	801cafc <spindle_get>
 801d14e:	6078      	str	r0, [r7, #4]
 801d150:	687b      	ldr	r3, [r7, #4]
 801d152:	2b00      	cmp	r3, #0
 801d154:	d00c      	beq.n	801d170 <spindle_is_on+0x40>
            on = spindle->get_state(spindle).on;
 801d156:	687b      	ldr	r3, [r7, #4]
 801d158:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d15a:	6878      	ldr	r0, [r7, #4]
 801d15c:	4798      	blx	r3
 801d15e:	4603      	mov	r3, r0
 801d160:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801d164:	b2db      	uxtb	r3, r3
 801d166:	2b00      	cmp	r3, #0
 801d168:	bf14      	ite	ne
 801d16a:	2301      	movne	r3, #1
 801d16c:	2300      	moveq	r3, #0
 801d16e:	73fb      	strb	r3, [r7, #15]
    } while(spindle_num && !on);
 801d170:	68bb      	ldr	r3, [r7, #8]
 801d172:	2b00      	cmp	r3, #0
 801d174:	d005      	beq.n	801d182 <spindle_is_on+0x52>
 801d176:	7bfb      	ldrb	r3, [r7, #15]
 801d178:	f083 0301 	eor.w	r3, r3, #1
 801d17c:	b2db      	uxtb	r3, r3
 801d17e:	2b00      	cmp	r3, #0
 801d180:	d1dd      	bne.n	801d13e <spindle_is_on+0xe>

    return on;
 801d182:	7bfb      	ldrb	r3, [r7, #15]
}
 801d184:	4618      	mov	r0, r3
 801d186:	3710      	adds	r7, #16
 801d188:	46bd      	mov	sp, r7
 801d18a:	bd80      	pop	{r7, pc}

0801d18c <invert_pwm>:
\param pwm_data pointer t a \a spindle_pwm_t structure.
\param pwm_value non inverted PWM value.
\returns the inverted PWM value to use.
*/
static inline uint_fast16_t invert_pwm (spindle_pwm_t *pwm_data, uint_fast16_t pwm_value)
{
 801d18c:	b480      	push	{r7}
 801d18e:	b083      	sub	sp, #12
 801d190:	af00      	add	r7, sp, #0
 801d192:	6078      	str	r0, [r7, #4]
 801d194:	6039      	str	r1, [r7, #0]
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 801d196:	687b      	ldr	r3, [r7, #4]
 801d198:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d19c:	2b00      	cmp	r3, #0
 801d19e:	d005      	beq.n	801d1ac <invert_pwm+0x20>
 801d1a0:	687b      	ldr	r3, [r7, #4]
 801d1a2:	689a      	ldr	r2, [r3, #8]
 801d1a4:	683b      	ldr	r3, [r7, #0]
 801d1a6:	1ad3      	subs	r3, r2, r3
 801d1a8:	3b01      	subs	r3, #1
 801d1aa:	e000      	b.n	801d1ae <invert_pwm+0x22>
 801d1ac:	683b      	ldr	r3, [r7, #0]
}
 801d1ae:	4618      	mov	r0, r3
 801d1b0:	370c      	adds	r7, #12
 801d1b2:	46bd      	mov	sp, r7
 801d1b4:	bc80      	pop	{r7}
 801d1b6:	4770      	bx	lr

0801d1b8 <spindle_compute_pwm_value>:

__NOTE:__ \a spindle_precompute_pwm_values() must be called to precompute values before this function is called.
Typically this is done by the spindle initialization code.
*/
static uint_fast16_t spindle_compute_pwm_value (spindle_pwm_t *pwm_data, float rpm, bool pid_limit)
{
 801d1b8:	b580      	push	{r7, lr}
 801d1ba:	b086      	sub	sp, #24
 801d1bc:	af00      	add	r7, sp, #0
 801d1be:	60f8      	str	r0, [r7, #12]
 801d1c0:	60b9      	str	r1, [r7, #8]
 801d1c2:	4613      	mov	r3, r2
 801d1c4:	71fb      	strb	r3, [r7, #7]
    uint_fast16_t pwm_value;

    if(rpm > pwm_data->rpm_min) {
 801d1c6:	68fb      	ldr	r3, [r7, #12]
 801d1c8:	699b      	ldr	r3, [r3, #24]
 801d1ca:	4619      	mov	r1, r3
 801d1cc:	68b8      	ldr	r0, [r7, #8]
 801d1ce:	f7e3 ffad 	bl	800112c <__aeabi_fcmpgt>
 801d1d2:	4603      	mov	r3, r0
 801d1d4:	2b00      	cmp	r3, #0
 801d1d6:	d03e      	beq.n	801d256 <spindle_compute_pwm_value+0x9e>
                }
            } while(idx);
        } else
      #endif
        // Compute intermediate PWM value with linear spindle speed model.
        pwm_value = (uint_fast16_t)floorf((rpm - pwm_data->rpm_min) * pwm_data->pwm_gradient) + pwm_data->min_value;
 801d1d8:	68fb      	ldr	r3, [r7, #12]
 801d1da:	699b      	ldr	r3, [r3, #24]
 801d1dc:	4619      	mov	r1, r3
 801d1de:	68b8      	ldr	r0, [r7, #8]
 801d1e0:	f7e3 fcde 	bl	8000ba0 <__aeabi_fsub>
 801d1e4:	4603      	mov	r3, r0
 801d1e6:	461a      	mov	r2, r3
 801d1e8:	68fb      	ldr	r3, [r7, #12]
 801d1ea:	69db      	ldr	r3, [r3, #28]
 801d1ec:	4619      	mov	r1, r3
 801d1ee:	4610      	mov	r0, r2
 801d1f0:	f7e3 fde0 	bl	8000db4 <__aeabi_fmul>
 801d1f4:	4603      	mov	r3, r0
 801d1f6:	4618      	mov	r0, r3
 801d1f8:	f007 fd98 	bl	8024d2c <floorf>
 801d1fc:	4603      	mov	r3, r0
 801d1fe:	4618      	mov	r0, r3
 801d200:	f7e3 ffda 	bl	80011b8 <__aeabi_f2uiz>
 801d204:	4602      	mov	r2, r0
 801d206:	68fb      	ldr	r3, [r7, #12]
 801d208:	691b      	ldr	r3, [r3, #16]
 801d20a:	4413      	add	r3, r2
 801d20c:	617b      	str	r3, [r7, #20]

        if(pwm_value >= (pid_limit ? pwm_data->period : pwm_data->max_value))
 801d20e:	79fb      	ldrb	r3, [r7, #7]
 801d210:	2b00      	cmp	r3, #0
 801d212:	d002      	beq.n	801d21a <spindle_compute_pwm_value+0x62>
 801d214:	68fb      	ldr	r3, [r7, #12]
 801d216:	689b      	ldr	r3, [r3, #8]
 801d218:	e001      	b.n	801d21e <spindle_compute_pwm_value+0x66>
 801d21a:	68fb      	ldr	r3, [r7, #12]
 801d21c:	695b      	ldr	r3, [r3, #20]
 801d21e:	697a      	ldr	r2, [r7, #20]
 801d220:	4293      	cmp	r3, r2
 801d222:	d80a      	bhi.n	801d23a <spindle_compute_pwm_value+0x82>
            pwm_value = pid_limit ? pwm_data->period - 1 : pwm_data->max_value;
 801d224:	79fb      	ldrb	r3, [r7, #7]
 801d226:	2b00      	cmp	r3, #0
 801d228:	d003      	beq.n	801d232 <spindle_compute_pwm_value+0x7a>
 801d22a:	68fb      	ldr	r3, [r7, #12]
 801d22c:	689b      	ldr	r3, [r3, #8]
 801d22e:	3b01      	subs	r3, #1
 801d230:	e001      	b.n	801d236 <spindle_compute_pwm_value+0x7e>
 801d232:	68fb      	ldr	r3, [r7, #12]
 801d234:	695b      	ldr	r3, [r3, #20]
 801d236:	617b      	str	r3, [r7, #20]
 801d238:	e007      	b.n	801d24a <spindle_compute_pwm_value+0x92>
        else if(pwm_value < pwm_data->min_value)
 801d23a:	68fb      	ldr	r3, [r7, #12]
 801d23c:	691b      	ldr	r3, [r3, #16]
 801d23e:	697a      	ldr	r2, [r7, #20]
 801d240:	429a      	cmp	r2, r3
 801d242:	d202      	bcs.n	801d24a <spindle_compute_pwm_value+0x92>
            pwm_value = pwm_data->min_value;
 801d244:	68fb      	ldr	r3, [r7, #12]
 801d246:	691b      	ldr	r3, [r3, #16]
 801d248:	617b      	str	r3, [r7, #20]

        pwm_value = invert_pwm(pwm_data, pwm_value);
 801d24a:	6979      	ldr	r1, [r7, #20]
 801d24c:	68f8      	ldr	r0, [r7, #12]
 801d24e:	f7ff ff9d 	bl	801d18c <invert_pwm>
 801d252:	6178      	str	r0, [r7, #20]
 801d254:	e012      	b.n	801d27c <spindle_compute_pwm_value+0xc4>
    } else
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);
 801d256:	f04f 0100 	mov.w	r1, #0
 801d25a:	68b8      	ldr	r0, [r7, #8]
 801d25c:	f7e3 ff3e 	bl	80010dc <__aeabi_fcmpeq>
 801d260:	4603      	mov	r3, r0
 801d262:	2b00      	cmp	r3, #0
 801d264:	d002      	beq.n	801d26c <spindle_compute_pwm_value+0xb4>
 801d266:	68fb      	ldr	r3, [r7, #12]
 801d268:	68db      	ldr	r3, [r3, #12]
 801d26a:	e006      	b.n	801d27a <spindle_compute_pwm_value+0xc2>
 801d26c:	68fb      	ldr	r3, [r7, #12]
 801d26e:	691b      	ldr	r3, [r3, #16]
 801d270:	4619      	mov	r1, r3
 801d272:	68f8      	ldr	r0, [r7, #12]
 801d274:	f7ff ff8a 	bl	801d18c <invert_pwm>
 801d278:	4603      	mov	r3, r0
 801d27a:	617b      	str	r3, [r7, #20]

    return pwm_value;
 801d27c:	697b      	ldr	r3, [r7, #20]
}
 801d27e:	4618      	mov	r0, r3
 801d280:	3718      	adds	r7, #24
 801d282:	46bd      	mov	sp, r7
 801d284:	bd80      	pop	{r7, pc}

0801d286 <compute_dummy_pwm_value>:
\param rpm spindle RPM.
\param pid_limit boolean, \a true if PID based spindle sync is used, \a false otherwise.
\returns the PWM value to use.
*/
static uint_fast16_t compute_dummy_pwm_value (spindle_pwm_t *pwm_data, float rpm, bool pid_limit)
{
 801d286:	b480      	push	{r7}
 801d288:	b085      	sub	sp, #20
 801d28a:	af00      	add	r7, sp, #0
 801d28c:	60f8      	str	r0, [r7, #12]
 801d28e:	60b9      	str	r1, [r7, #8]
 801d290:	4613      	mov	r3, r2
 801d292:	71fb      	strb	r3, [r7, #7]
    return pwm_data->off_value;
 801d294:	68fb      	ldr	r3, [r7, #12]
 801d296:	68db      	ldr	r3, [r3, #12]
}
 801d298:	4618      	mov	r0, r3
 801d29a:	3714      	adds	r7, #20
 801d29c:	46bd      	mov	sp, r7
 801d29e:	bc80      	pop	{r7}
 801d2a0:	4770      	bx	lr
	...

0801d2a4 <spindle_precompute_pwm_values>:
\param pwm_data pointer to a \a spindle_pwm_t structure, to hold the precomputed values.
\param clock_hz timer clock frequency used for PWM generation.
\returns \a true if successful, \a false if no PWM range possible - driver should then revert to simple on/off spindle control.
*/
bool spindle_precompute_pwm_values (spindle_ptrs_t *spindle, spindle_pwm_t *pwm_data, spindle_settings_t *settings, uint32_t clock_hz)
{
 801d2a4:	b590      	push	{r4, r7, lr}
 801d2a6:	b085      	sub	sp, #20
 801d2a8:	af00      	add	r7, sp, #0
 801d2aa:	60f8      	str	r0, [r7, #12]
 801d2ac:	60b9      	str	r1, [r7, #8]
 801d2ae:	607a      	str	r2, [r7, #4]
 801d2b0:	603b      	str	r3, [r7, #0]
    pwm_data->settings = settings;
 801d2b2:	68bb      	ldr	r3, [r7, #8]
 801d2b4:	687a      	ldr	r2, [r7, #4]
 801d2b6:	605a      	str	r2, [r3, #4]
    spindle->rpm_min = pwm_data->rpm_min = settings->rpm_min;
 801d2b8:	687b      	ldr	r3, [r7, #4]
 801d2ba:	685a      	ldr	r2, [r3, #4]
 801d2bc:	68bb      	ldr	r3, [r7, #8]
 801d2be:	619a      	str	r2, [r3, #24]
 801d2c0:	68bb      	ldr	r3, [r7, #8]
 801d2c2:	699a      	ldr	r2, [r3, #24]
 801d2c4:	68fb      	ldr	r3, [r7, #12]
 801d2c6:	615a      	str	r2, [r3, #20]
    spindle->rpm_max = settings->rpm_max;
 801d2c8:	687b      	ldr	r3, [r7, #4]
 801d2ca:	681a      	ldr	r2, [r3, #0]
 801d2cc:	68fb      	ldr	r3, [r7, #12]
 801d2ce:	619a      	str	r2, [r3, #24]
    spindle->cap.rpm_range_locked = On;
 801d2d0:	68fa      	ldr	r2, [r7, #12]
 801d2d2:	7a93      	ldrb	r3, [r2, #10]
 801d2d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801d2d8:	7293      	strb	r3, [r2, #10]

    if((spindle->cap.variable = !settings->flags.pwm_disable && spindle->rpm_max > spindle->rpm_min)) {
 801d2da:	687b      	ldr	r3, [r7, #4]
 801d2dc:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801d2e0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801d2e4:	b2db      	uxtb	r3, r3
 801d2e6:	2b00      	cmp	r3, #0
 801d2e8:	d10c      	bne.n	801d304 <spindle_precompute_pwm_values+0x60>
 801d2ea:	68fb      	ldr	r3, [r7, #12]
 801d2ec:	699a      	ldr	r2, [r3, #24]
 801d2ee:	68fb      	ldr	r3, [r7, #12]
 801d2f0:	695b      	ldr	r3, [r3, #20]
 801d2f2:	4619      	mov	r1, r3
 801d2f4:	4610      	mov	r0, r2
 801d2f6:	f7e3 ff19 	bl	800112c <__aeabi_fcmpgt>
 801d2fa:	4603      	mov	r3, r0
 801d2fc:	2b00      	cmp	r3, #0
 801d2fe:	d001      	beq.n	801d304 <spindle_precompute_pwm_values+0x60>
 801d300:	2301      	movs	r3, #1
 801d302:	e000      	b.n	801d306 <spindle_precompute_pwm_values+0x62>
 801d304:	2300      	movs	r3, #0
 801d306:	f003 0301 	and.w	r3, r3, #1
 801d30a:	b2d9      	uxtb	r1, r3
 801d30c:	68fa      	ldr	r2, [r7, #12]
 801d30e:	7a93      	ldrb	r3, [r2, #10]
 801d310:	f361 0300 	bfi	r3, r1, #0, #1
 801d314:	7293      	strb	r3, [r2, #10]
 801d316:	68fb      	ldr	r3, [r7, #12]
 801d318:	7a9b      	ldrb	r3, [r3, #10]
 801d31a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801d31e:	b2db      	uxtb	r3, r3
 801d320:	2b00      	cmp	r3, #0
 801d322:	f000 80aa 	beq.w	801d47a <spindle_precompute_pwm_values+0x1d6>
        pwm_data->f_clock = clock_hz;
 801d326:	68bb      	ldr	r3, [r7, #8]
 801d328:	683a      	ldr	r2, [r7, #0]
 801d32a:	601a      	str	r2, [r3, #0]
        pwm_data->period = (uint_fast16_t)((float)clock_hz / settings->pwm_freq);
 801d32c:	6838      	ldr	r0, [r7, #0]
 801d32e:	f7e3 fce9 	bl	8000d04 <__aeabi_ui2f>
 801d332:	4602      	mov	r2, r0
 801d334:	687b      	ldr	r3, [r7, #4]
 801d336:	689b      	ldr	r3, [r3, #8]
 801d338:	4619      	mov	r1, r3
 801d33a:	4610      	mov	r0, r2
 801d33c:	f7e3 fdee 	bl	8000f1c <__aeabi_fdiv>
 801d340:	4603      	mov	r3, r0
 801d342:	4618      	mov	r0, r3
 801d344:	f7e3 ff38 	bl	80011b8 <__aeabi_f2uiz>
 801d348:	4602      	mov	r2, r0
 801d34a:	68bb      	ldr	r3, [r7, #8]
 801d34c:	609a      	str	r2, [r3, #8]
        if(settings->pwm_off_value == 0.0f)
 801d34e:	687b      	ldr	r3, [r7, #4]
 801d350:	691b      	ldr	r3, [r3, #16]
 801d352:	f04f 0100 	mov.w	r1, #0
 801d356:	4618      	mov	r0, r3
 801d358:	f7e3 fec0 	bl	80010dc <__aeabi_fcmpeq>
 801d35c:	4603      	mov	r3, r0
 801d35e:	2b00      	cmp	r3, #0
 801d360:	d00b      	beq.n	801d37a <spindle_precompute_pwm_values+0xd6>
            pwm_data->off_value = pwm_data->invert_pwm ? pwm_data->period : 0;
 801d362:	68bb      	ldr	r3, [r7, #8]
 801d364:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d368:	2b00      	cmp	r3, #0
 801d36a:	d002      	beq.n	801d372 <spindle_precompute_pwm_values+0xce>
 801d36c:	68bb      	ldr	r3, [r7, #8]
 801d36e:	689b      	ldr	r3, [r3, #8]
 801d370:	e000      	b.n	801d374 <spindle_precompute_pwm_values+0xd0>
 801d372:	2300      	movs	r3, #0
 801d374:	68ba      	ldr	r2, [r7, #8]
 801d376:	60d3      	str	r3, [r2, #12]
 801d378:	e01c      	b.n	801d3b4 <spindle_precompute_pwm_values+0x110>
        else
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings->pwm_off_value / 100.0f));
 801d37a:	68bb      	ldr	r3, [r7, #8]
 801d37c:	689b      	ldr	r3, [r3, #8]
 801d37e:	4618      	mov	r0, r3
 801d380:	f7e3 fcc0 	bl	8000d04 <__aeabi_ui2f>
 801d384:	4602      	mov	r2, r0
 801d386:	687b      	ldr	r3, [r7, #4]
 801d388:	691b      	ldr	r3, [r3, #16]
 801d38a:	4619      	mov	r1, r3
 801d38c:	4610      	mov	r0, r2
 801d38e:	f7e3 fd11 	bl	8000db4 <__aeabi_fmul>
 801d392:	4603      	mov	r3, r0
 801d394:	4946      	ldr	r1, [pc, #280]	; (801d4b0 <spindle_precompute_pwm_values+0x20c>)
 801d396:	4618      	mov	r0, r3
 801d398:	f7e3 fdc0 	bl	8000f1c <__aeabi_fdiv>
 801d39c:	4603      	mov	r3, r0
 801d39e:	4618      	mov	r0, r3
 801d3a0:	f7e3 ff0a 	bl	80011b8 <__aeabi_f2uiz>
 801d3a4:	4603      	mov	r3, r0
 801d3a6:	4619      	mov	r1, r3
 801d3a8:	68b8      	ldr	r0, [r7, #8]
 801d3aa:	f7ff feef 	bl	801d18c <invert_pwm>
 801d3ae:	4602      	mov	r2, r0
 801d3b0:	68bb      	ldr	r3, [r7, #8]
 801d3b2:	60da      	str	r2, [r3, #12]
        pwm_data->min_value = (uint_fast16_t)(pwm_data->period * settings->pwm_min_value / 100.0f);
 801d3b4:	68bb      	ldr	r3, [r7, #8]
 801d3b6:	689b      	ldr	r3, [r3, #8]
 801d3b8:	4618      	mov	r0, r3
 801d3ba:	f7e3 fca3 	bl	8000d04 <__aeabi_ui2f>
 801d3be:	4602      	mov	r2, r0
 801d3c0:	687b      	ldr	r3, [r7, #4]
 801d3c2:	695b      	ldr	r3, [r3, #20]
 801d3c4:	4619      	mov	r1, r3
 801d3c6:	4610      	mov	r0, r2
 801d3c8:	f7e3 fcf4 	bl	8000db4 <__aeabi_fmul>
 801d3cc:	4603      	mov	r3, r0
 801d3ce:	4938      	ldr	r1, [pc, #224]	; (801d4b0 <spindle_precompute_pwm_values+0x20c>)
 801d3d0:	4618      	mov	r0, r3
 801d3d2:	f7e3 fda3 	bl	8000f1c <__aeabi_fdiv>
 801d3d6:	4603      	mov	r3, r0
 801d3d8:	4618      	mov	r0, r3
 801d3da:	f7e3 feed 	bl	80011b8 <__aeabi_f2uiz>
 801d3de:	4602      	mov	r2, r0
 801d3e0:	68bb      	ldr	r3, [r7, #8]
 801d3e2:	611a      	str	r2, [r3, #16]
        pwm_data->max_value = (uint_fast16_t)(pwm_data->period * settings->pwm_max_value / 100.0f) + pwm_data->offset;
 801d3e4:	68bb      	ldr	r3, [r7, #8]
 801d3e6:	689b      	ldr	r3, [r3, #8]
 801d3e8:	4618      	mov	r0, r3
 801d3ea:	f7e3 fc8b 	bl	8000d04 <__aeabi_ui2f>
 801d3ee:	4602      	mov	r2, r0
 801d3f0:	687b      	ldr	r3, [r7, #4]
 801d3f2:	699b      	ldr	r3, [r3, #24]
 801d3f4:	4619      	mov	r1, r3
 801d3f6:	4610      	mov	r0, r2
 801d3f8:	f7e3 fcdc 	bl	8000db4 <__aeabi_fmul>
 801d3fc:	4603      	mov	r3, r0
 801d3fe:	492c      	ldr	r1, [pc, #176]	; (801d4b0 <spindle_precompute_pwm_values+0x20c>)
 801d400:	4618      	mov	r0, r3
 801d402:	f7e3 fd8b 	bl	8000f1c <__aeabi_fdiv>
 801d406:	4603      	mov	r3, r0
 801d408:	4618      	mov	r0, r3
 801d40a:	f7e3 fed5 	bl	80011b8 <__aeabi_f2uiz>
 801d40e:	4602      	mov	r2, r0
 801d410:	68bb      	ldr	r3, [r7, #8]
 801d412:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801d414:	441a      	add	r2, r3
 801d416:	68bb      	ldr	r3, [r7, #8]
 801d418:	615a      	str	r2, [r3, #20]
        pwm_data->pwm_gradient = (float)(pwm_data->max_value - pwm_data->min_value) / (spindle->rpm_max - spindle->rpm_min);
 801d41a:	68bb      	ldr	r3, [r7, #8]
 801d41c:	695a      	ldr	r2, [r3, #20]
 801d41e:	68bb      	ldr	r3, [r7, #8]
 801d420:	691b      	ldr	r3, [r3, #16]
 801d422:	1ad3      	subs	r3, r2, r3
 801d424:	4618      	mov	r0, r3
 801d426:	f7e3 fc6d 	bl	8000d04 <__aeabi_ui2f>
 801d42a:	4604      	mov	r4, r0
 801d42c:	68fb      	ldr	r3, [r7, #12]
 801d42e:	699a      	ldr	r2, [r3, #24]
 801d430:	68fb      	ldr	r3, [r7, #12]
 801d432:	695b      	ldr	r3, [r3, #20]
 801d434:	4619      	mov	r1, r3
 801d436:	4610      	mov	r0, r2
 801d438:	f7e3 fbb2 	bl	8000ba0 <__aeabi_fsub>
 801d43c:	4603      	mov	r3, r0
 801d43e:	4619      	mov	r1, r3
 801d440:	4620      	mov	r0, r4
 801d442:	f7e3 fd6b 	bl	8000f1c <__aeabi_fdiv>
 801d446:	4603      	mov	r3, r0
 801d448:	461a      	mov	r2, r3
 801d44a:	68bb      	ldr	r3, [r7, #8]
 801d44c:	61da      	str	r2, [r3, #28]
        pwm_data->always_on = settings->pwm_off_value != 0.0f;
 801d44e:	687b      	ldr	r3, [r7, #4]
 801d450:	691b      	ldr	r3, [r3, #16]
 801d452:	2201      	movs	r2, #1
 801d454:	4614      	mov	r4, r2
 801d456:	f04f 0100 	mov.w	r1, #0
 801d45a:	4618      	mov	r0, r3
 801d45c:	f7e3 fe3e 	bl	80010dc <__aeabi_fcmpeq>
 801d460:	4603      	mov	r3, r0
 801d462:	2b00      	cmp	r3, #0
 801d464:	d001      	beq.n	801d46a <spindle_precompute_pwm_values+0x1c6>
 801d466:	2300      	movs	r3, #0
 801d468:	461c      	mov	r4, r3
 801d46a:	b2e2      	uxtb	r2, r4
 801d46c:	68bb      	ldr	r3, [r7, #8]
 801d46e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
        pwm_data->compute_value = spindle_compute_pwm_value;
 801d472:	68bb      	ldr	r3, [r7, #8]
 801d474:	4a0f      	ldr	r2, [pc, #60]	; (801d4b4 <spindle_precompute_pwm_values+0x210>)
 801d476:	65da      	str	r2, [r3, #92]	; 0x5c
 801d478:	e009      	b.n	801d48e <spindle_precompute_pwm_values+0x1ea>
    } else {
        pwm_data->off_value = 0;
 801d47a:	68bb      	ldr	r3, [r7, #8]
 801d47c:	2200      	movs	r2, #0
 801d47e:	60da      	str	r2, [r3, #12]
        pwm_data->always_on = false;
 801d480:	68bb      	ldr	r3, [r7, #8]
 801d482:	2200      	movs	r2, #0
 801d484:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
        pwm_data->compute_value = compute_dummy_pwm_value;
 801d488:	68bb      	ldr	r3, [r7, #8]
 801d48a:	4a0b      	ldr	r2, [pc, #44]	; (801d4b8 <spindle_precompute_pwm_values+0x214>)
 801d48c:	65da      	str	r2, [r3, #92]	; 0x5c
    }

    spindle->context = pwm_data;
 801d48e:	68fb      	ldr	r3, [r7, #12]
 801d490:	68ba      	ldr	r2, [r7, #8]
 801d492:	60da      	str	r2, [r3, #12]
    }

    spindle->cap.pwm_linearization = pwm_data->n_pieces > 0;
#endif

    return spindle->cap.variable;
 801d494:	68fb      	ldr	r3, [r7, #12]
 801d496:	7a9b      	ldrb	r3, [r3, #10]
 801d498:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801d49c:	b2db      	uxtb	r3, r3
 801d49e:	2b00      	cmp	r3, #0
 801d4a0:	bf14      	ite	ne
 801d4a2:	2301      	movne	r3, #1
 801d4a4:	2300      	moveq	r3, #0
 801d4a6:	b2db      	uxtb	r3, r3
}
 801d4a8:	4618      	mov	r0, r3
 801d4aa:	3714      	adds	r7, #20
 801d4ac:	46bd      	mov	sp, r7
 801d4ae:	bd90      	pop	{r4, r7, pc}
 801d4b0:	42c80000 	.word	0x42c80000
 801d4b4:	0801d1b9 	.word	0x0801d1b9
 801d4b8:	0801d287 	.word	0x0801d287

0801d4bc <state_spindle_restore>:

// Declare and initialize parking local variables
static parking_data_t park = {0};

static void state_spindle_restore (spindle_t *spindle)
{
 801d4bc:	b580      	push	{r7, lr}
 801d4be:	b082      	sub	sp, #8
 801d4c0:	af00      	add	r7, sp, #0
 801d4c2:	6078      	str	r0, [r7, #4]
    if(spindle->hal)
 801d4c4:	687b      	ldr	r3, [r7, #4]
 801d4c6:	68db      	ldr	r3, [r3, #12]
 801d4c8:	2b00      	cmp	r3, #0
 801d4ca:	d007      	beq.n	801d4dc <state_spindle_restore+0x20>
        spindle_restore(spindle->hal, spindle->state, spindle->rpm);
 801d4cc:	687b      	ldr	r3, [r7, #4]
 801d4ce:	68d8      	ldr	r0, [r3, #12]
 801d4d0:	687b      	ldr	r3, [r7, #4]
 801d4d2:	681a      	ldr	r2, [r3, #0]
 801d4d4:	687b      	ldr	r3, [r7, #4]
 801d4d6:	7919      	ldrb	r1, [r3, #4]
 801d4d8:	f7ff fd22 	bl	801cf20 <spindle_restore>
}
 801d4dc:	bf00      	nop
 801d4de:	3708      	adds	r7, #8
 801d4e0:	46bd      	mov	sp, r7
 801d4e2:	bd80      	pop	{r7, pc}

0801d4e4 <state_spindle_set_state>:

static void state_spindle_set_state (spindle_t *spindle)
{
 801d4e4:	b580      	push	{r7, lr}
 801d4e6:	b082      	sub	sp, #8
 801d4e8:	af00      	add	r7, sp, #0
 801d4ea:	6078      	str	r0, [r7, #4]
    if(spindle->hal)
 801d4ec:	687b      	ldr	r3, [r7, #4]
 801d4ee:	68db      	ldr	r3, [r3, #12]
 801d4f0:	2b00      	cmp	r3, #0
 801d4f2:	d007      	beq.n	801d504 <state_spindle_set_state+0x20>
        spindle_set_state(spindle->hal, spindle->state, spindle->rpm);
 801d4f4:	687b      	ldr	r3, [r7, #4]
 801d4f6:	68d8      	ldr	r0, [r3, #12]
 801d4f8:	687b      	ldr	r3, [r7, #4]
 801d4fa:	681a      	ldr	r2, [r3, #0]
 801d4fc:	687b      	ldr	r3, [r7, #4]
 801d4fe:	7919      	ldrb	r1, [r3, #4]
 801d500:	f7ff fc68 	bl	801cdd4 <spindle_set_state>
}
 801d504:	bf00      	nop
 801d506:	3708      	adds	r7, #8
 801d508:	46bd      	mov	sp, r7
 801d50a:	bd80      	pop	{r7, pc}

0801d50c <state_restore_conditions>:

static void state_restore_conditions (restore_condition_t *condition)
{
 801d50c:	b590      	push	{r4, r7, lr}
 801d50e:	b085      	sub	sp, #20
 801d510:	af00      	add	r7, sp, #0
 801d512:	6078      	str	r0, [r7, #4]
    if (!settings.parking.flags.enabled || !park.flags.restart) {
 801d514:	4b23      	ldr	r3, [pc, #140]	; (801d5a4 <state_restore_conditions+0x98>)
 801d516:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801d51a:	f003 0301 	and.w	r3, r3, #1
 801d51e:	b2db      	uxtb	r3, r3
 801d520:	2b00      	cmp	r3, #0
 801d522:	d006      	beq.n	801d532 <state_restore_conditions+0x26>
 801d524:	4b20      	ldr	r3, [pc, #128]	; (801d5a8 <state_restore_conditions+0x9c>)
 801d526:	7f1b      	ldrb	r3, [r3, #28]
 801d528:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801d52c:	b2db      	uxtb	r3, r3
 801d52e:	2b00      	cmp	r3, #0
 801d530:	d134      	bne.n	801d59c <state_restore_conditions+0x90>

        spindle_num_t spindle_num = N_SYS_SPINDLE;
 801d532:	2301      	movs	r3, #1
 801d534:	73fb      	strb	r3, [r7, #15]

        park.flags.restoring = On; //
 801d536:	4a1c      	ldr	r2, [pc, #112]	; (801d5a8 <state_restore_conditions+0x9c>)
 801d538:	7f13      	ldrb	r3, [r2, #28]
 801d53a:	f043 0308 	orr.w	r3, r3, #8
 801d53e:	7713      	strb	r3, [r2, #28]

        do {
            state_spindle_restore(&condition->spindle[--spindle_num]);
 801d540:	7bfb      	ldrb	r3, [r7, #15]
 801d542:	3b01      	subs	r3, #1
 801d544:	b2db      	uxtb	r3, r3
 801d546:	73fb      	strb	r3, [r7, #15]
 801d548:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d54c:	011b      	lsls	r3, r3, #4
 801d54e:	687a      	ldr	r2, [r7, #4]
 801d550:	4413      	add	r3, r2
 801d552:	3304      	adds	r3, #4
 801d554:	4618      	mov	r0, r3
 801d556:	f7ff ffb1 	bl	801d4bc <state_spindle_restore>
        } while(spindle_num);
 801d55a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801d55e:	2b00      	cmp	r3, #0
 801d560:	d1ee      	bne.n	801d540 <state_restore_conditions+0x34>

        // Block if safety door re-opened during prior restore actions.
        if (gc_state.modal.coolant.value != hal.coolant.get_state().value) {
 801d562:	4b12      	ldr	r3, [pc, #72]	; (801d5ac <state_restore_conditions+0xa0>)
 801d564:	7e5c      	ldrb	r4, [r3, #25]
 801d566:	4b12      	ldr	r3, [pc, #72]	; (801d5b0 <state_restore_conditions+0xa4>)
 801d568:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801d56a:	4798      	blx	r3
 801d56c:	4603      	mov	r3, r0
 801d56e:	b2db      	uxtb	r3, r3
 801d570:	429c      	cmp	r4, r3
 801d572:	d00a      	beq.n	801d58a <state_restore_conditions+0x7e>
            // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this signal.
            coolant_set_state(condition->coolant);
 801d574:	687b      	ldr	r3, [r7, #4]
 801d576:	7818      	ldrb	r0, [r3, #0]
 801d578:	f7e8 f870 	bl	800565c <coolant_set_state>
            delay_sec(settings.safety_door.coolant_on_delay, DelayMode_SysSuspend);
 801d57c:	4b09      	ldr	r3, [pc, #36]	; (801d5a4 <state_restore_conditions+0x98>)
 801d57e:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801d582:	2101      	movs	r1, #1
 801d584:	4618      	mov	r0, r3
 801d586:	f7f3 f8fd 	bl	8010784 <delay_sec>
        }

        park.flags.restoring = Off;
 801d58a:	4a07      	ldr	r2, [pc, #28]	; (801d5a8 <state_restore_conditions+0x9c>)
 801d58c:	7f13      	ldrb	r3, [r2, #28]
 801d58e:	f36f 03c3 	bfc	r3, #3, #1
 801d592:	7713      	strb	r3, [r2, #28]

        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801d594:	4b07      	ldr	r3, [pc, #28]	; (801d5b4 <state_restore_conditions+0xa8>)
 801d596:	2200      	movs	r2, #0
 801d598:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    }
}
 801d59c:	bf00      	nop
 801d59e:	3714      	adds	r7, #20
 801d5a0:	46bd      	mov	sp, r7
 801d5a2:	bd90      	pop	{r4, r7, pc}
 801d5a4:	2000147c 	.word	0x2000147c
 801d5a8:	200017c8 	.word	0x200017c8
 801d5ac:	20000bb0 	.word	0x20000bb0
 801d5b0:	20000ed0 	.word	0x20000ed0
 801d5b4:	20000d3c 	.word	0x20000d3c

0801d5b8 <enter_sleep>:

static void enter_sleep (void)
{
 801d5b8:	b580      	push	{r7, lr}
 801d5ba:	af00      	add	r7, sp, #0
    st_go_idle();
 801d5bc:	f001 fa7e 	bl	801eabc <st_go_idle>
    spindle_all_off();
 801d5c0:	f7ff fd86 	bl	801d0d0 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 801d5c4:	4b06      	ldr	r3, [pc, #24]	; (801d5e0 <enter_sleep+0x28>)
 801d5c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801d5c8:	2200      	movs	r2, #0
 801d5ca:	4610      	mov	r0, r2
 801d5cc:	4798      	blx	r3
    grbl.report.feedback_message(Message_SleepMode);
 801d5ce:	4b05      	ldr	r3, [pc, #20]	; (801d5e4 <enter_sleep+0x2c>)
 801d5d0:	68db      	ldr	r3, [r3, #12]
 801d5d2:	200b      	movs	r0, #11
 801d5d4:	4798      	blx	r3
    stateHandler = state_noop;
 801d5d6:	4b04      	ldr	r3, [pc, #16]	; (801d5e8 <enter_sleep+0x30>)
 801d5d8:	4a04      	ldr	r2, [pc, #16]	; (801d5ec <enter_sleep+0x34>)
 801d5da:	601a      	str	r2, [r3, #0]
}
 801d5dc:	bf00      	nop
 801d5de:	bd80      	pop	{r7, pc}
 801d5e0:	20000ed0 	.word	0x20000ed0
 801d5e4:	20000dd4 	.word	0x20000dd4
 801d5e8:	20000394 	.word	0x20000394
 801d5ec:	0801ddc9 	.word	0x0801ddc9

0801d5f0 <initiate_hold>:

static bool initiate_hold (uint_fast16_t new_state)
{
 801d5f0:	b590      	push	{r4, r7, lr}
 801d5f2:	b087      	sub	sp, #28
 801d5f4:	af00      	add	r7, sp, #0
 801d5f6:	6078      	str	r0, [r7, #4]
    spindle_ptrs_t *spindle;
    spindle_num_t spindle_num = N_SYS_SPINDLE;
 801d5f8:	2301      	movs	r3, #1
 801d5fa:	75fb      	strb	r3, [r7, #23]

    if (settings.parking.flags.enabled) {
 801d5fc:	4b87      	ldr	r3, [pc, #540]	; (801d81c <initiate_hold+0x22c>)
 801d5fe:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801d602:	f003 0301 	and.w	r3, r3, #1
 801d606:	b2db      	uxtb	r3, r3
 801d608:	2b00      	cmp	r3, #0
 801d60a:	d013      	beq.n	801d634 <initiate_hold+0x44>
        plan_data_init(&park.plan_data);
 801d60c:	4884      	ldr	r0, [pc, #528]	; (801d820 <initiate_hold+0x230>)
 801d60e:	f7f4 fecd 	bl	80123ac <plan_data_init>
        park.plan_data.condition.system_motion = On;
 801d612:	4a84      	ldr	r2, [pc, #528]	; (801d824 <initiate_hold+0x234>)
 801d614:	f892 3038 	ldrb.w	r3, [r2, #56]	; 0x38
 801d618:	f043 0302 	orr.w	r3, r3, #2
 801d61c:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
        park.plan_data.condition.no_feed_override = On;
 801d620:	4a80      	ldr	r2, [pc, #512]	; (801d824 <initiate_hold+0x234>)
 801d622:	f892 3038 	ldrb.w	r3, [r2, #56]	; 0x38
 801d626:	f043 0310 	orr.w	r3, r3, #16
 801d62a:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
        park.plan_data.line_number = PARKING_MOTION_LINE_NUMBER;
 801d62e:	4b7d      	ldr	r3, [pc, #500]	; (801d824 <initiate_hold+0x234>)
 801d630:	2200      	movs	r2, #0
 801d632:	641a      	str	r2, [r3, #64]	; 0x40
    }

    plan_block_t *block = plan_get_current_block();
 801d634:	f7f4 f952 	bl	80118dc <plan_get_current_block>
 801d638:	6138      	str	r0, [r7, #16]

    restore_condition.spindle_num = 0;
 801d63a:	4b7b      	ldr	r3, [pc, #492]	; (801d828 <initiate_hold+0x238>)
 801d63c:	2200      	movs	r2, #0
 801d63e:	705a      	strb	r2, [r3, #1]

    do {
        if((spindle = spindle_get(--spindle_num))) {
 801d640:	7dfb      	ldrb	r3, [r7, #23]
 801d642:	3b01      	subs	r3, #1
 801d644:	b2db      	uxtb	r3, r3
 801d646:	75fb      	strb	r3, [r7, #23]
 801d648:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d64c:	4618      	mov	r0, r3
 801d64e:	f7ff fa55 	bl	801cafc <spindle_get>
 801d652:	60f8      	str	r0, [r7, #12]
 801d654:	68fb      	ldr	r3, [r7, #12]
 801d656:	2b00      	cmp	r3, #0
 801d658:	d068      	beq.n	801d72c <initiate_hold+0x13c>
            if(block && block->spindle.hal == spindle) {
 801d65a:	693b      	ldr	r3, [r7, #16]
 801d65c:	2b00      	cmp	r3, #0
 801d65e:	d024      	beq.n	801d6aa <initiate_hold+0xba>
 801d660:	693b      	ldr	r3, [r7, #16]
 801d662:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801d664:	68fa      	ldr	r2, [r7, #12]
 801d666:	429a      	cmp	r2, r3
 801d668:	d11f      	bne.n	801d6aa <initiate_hold+0xba>
                restore_condition.spindle_num = spindle_num;
 801d66a:	4a6f      	ldr	r2, [pc, #444]	; (801d828 <initiate_hold+0x238>)
 801d66c:	7dfb      	ldrb	r3, [r7, #23]
 801d66e:	7053      	strb	r3, [r2, #1]
                restore_condition.spindle[spindle_num].hal = block->spindle.hal;
 801d670:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d674:	693a      	ldr	r2, [r7, #16]
 801d676:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801d678:	496b      	ldr	r1, [pc, #428]	; (801d828 <initiate_hold+0x238>)
 801d67a:	011b      	lsls	r3, r3, #4
 801d67c:	440b      	add	r3, r1
 801d67e:	3310      	adds	r3, #16
 801d680:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].rpm = block->spindle.rpm;
 801d682:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d686:	693a      	ldr	r2, [r7, #16]
 801d688:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 801d68a:	4967      	ldr	r1, [pc, #412]	; (801d828 <initiate_hold+0x238>)
 801d68c:	011b      	lsls	r3, r3, #4
 801d68e:	440b      	add	r3, r1
 801d690:	3304      	adds	r3, #4
 801d692:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].state = block->spindle.state;
 801d694:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d698:	4a63      	ldr	r2, [pc, #396]	; (801d828 <initiate_hold+0x238>)
 801d69a:	011b      	lsls	r3, r3, #4
 801d69c:	4413      	add	r3, r2
 801d69e:	3308      	adds	r3, #8
 801d6a0:	693a      	ldr	r2, [r7, #16]
 801d6a2:	f892 2040 	ldrb.w	r2, [r2, #64]	; 0x40
 801d6a6:	701a      	strb	r2, [r3, #0]
 801d6a8:	e048      	b.n	801d73c <initiate_hold+0x14c>
            } else if(gc_state.spindle.hal == spindle) {
 801d6aa:	4b60      	ldr	r3, [pc, #384]	; (801d82c <initiate_hold+0x23c>)
 801d6ac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801d6ae:	68fa      	ldr	r2, [r7, #12]
 801d6b0:	429a      	cmp	r2, r3
 801d6b2:	d11e      	bne.n	801d6f2 <initiate_hold+0x102>
                restore_condition.spindle_num = spindle_num;
 801d6b4:	4a5c      	ldr	r2, [pc, #368]	; (801d828 <initiate_hold+0x238>)
 801d6b6:	7dfb      	ldrb	r3, [r7, #23]
 801d6b8:	7053      	strb	r3, [r2, #1]
                restore_condition.spindle[spindle_num].hal = gc_state.spindle.hal;
 801d6ba:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d6be:	4a5b      	ldr	r2, [pc, #364]	; (801d82c <initiate_hold+0x23c>)
 801d6c0:	6d12      	ldr	r2, [r2, #80]	; 0x50
 801d6c2:	4959      	ldr	r1, [pc, #356]	; (801d828 <initiate_hold+0x238>)
 801d6c4:	011b      	lsls	r3, r3, #4
 801d6c6:	440b      	add	r3, r1
 801d6c8:	3310      	adds	r3, #16
 801d6ca:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].rpm = gc_state.spindle.rpm;
 801d6cc:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d6d0:	4a56      	ldr	r2, [pc, #344]	; (801d82c <initiate_hold+0x23c>)
 801d6d2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 801d6d4:	4954      	ldr	r1, [pc, #336]	; (801d828 <initiate_hold+0x238>)
 801d6d6:	011b      	lsls	r3, r3, #4
 801d6d8:	440b      	add	r3, r1
 801d6da:	3304      	adds	r3, #4
 801d6dc:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].state = gc_state.modal.spindle.state;
 801d6de:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d6e2:	4a51      	ldr	r2, [pc, #324]	; (801d828 <initiate_hold+0x238>)
 801d6e4:	011b      	lsls	r3, r3, #4
 801d6e6:	4413      	add	r3, r2
 801d6e8:	3308      	adds	r3, #8
 801d6ea:	4a50      	ldr	r2, [pc, #320]	; (801d82c <initiate_hold+0x23c>)
 801d6ec:	7e92      	ldrb	r2, [r2, #26]
 801d6ee:	701a      	strb	r2, [r3, #0]
 801d6f0:	e024      	b.n	801d73c <initiate_hold+0x14c>
            } else {
                restore_condition.spindle[spindle_num].hal = spindle;
 801d6f2:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d6f6:	4a4c      	ldr	r2, [pc, #304]	; (801d828 <initiate_hold+0x238>)
 801d6f8:	011b      	lsls	r3, r3, #4
 801d6fa:	4413      	add	r3, r2
 801d6fc:	3310      	adds	r3, #16
 801d6fe:	68fa      	ldr	r2, [r7, #12]
 801d700:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].rpm = spindle->param->rpm;
 801d702:	68fb      	ldr	r3, [r7, #12]
 801d704:	685a      	ldr	r2, [r3, #4]
 801d706:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d70a:	6812      	ldr	r2, [r2, #0]
 801d70c:	4946      	ldr	r1, [pc, #280]	; (801d828 <initiate_hold+0x238>)
 801d70e:	011b      	lsls	r3, r3, #4
 801d710:	440b      	add	r3, r1
 801d712:	3304      	adds	r3, #4
 801d714:	601a      	str	r2, [r3, #0]
                restore_condition.spindle[spindle_num].state = spindle->param->state;
 801d716:	68fb      	ldr	r3, [r7, #12]
 801d718:	685a      	ldr	r2, [r3, #4]
 801d71a:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d71e:	4942      	ldr	r1, [pc, #264]	; (801d828 <initiate_hold+0x238>)
 801d720:	011b      	lsls	r3, r3, #4
 801d722:	440b      	add	r3, r1
 801d724:	3308      	adds	r3, #8
 801d726:	7a12      	ldrb	r2, [r2, #8]
 801d728:	701a      	strb	r2, [r3, #0]
 801d72a:	e007      	b.n	801d73c <initiate_hold+0x14c>
            }
        } else
            restore_condition.spindle[spindle_num].hal = NULL;
 801d72c:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d730:	4a3d      	ldr	r2, [pc, #244]	; (801d828 <initiate_hold+0x238>)
 801d732:	011b      	lsls	r3, r3, #4
 801d734:	4413      	add	r3, r2
 801d736:	3310      	adds	r3, #16
 801d738:	2200      	movs	r2, #0
 801d73a:	601a      	str	r2, [r3, #0]
    } while(spindle_num);
 801d73c:	f997 3017 	ldrsb.w	r3, [r7, #23]
 801d740:	2b00      	cmp	r3, #0
 801d742:	f47f af7d 	bne.w	801d640 <initiate_hold+0x50>

    if (block)
 801d746:	693b      	ldr	r3, [r7, #16]
 801d748:	2b00      	cmp	r3, #0
 801d74a:	d004      	beq.n	801d756 <initiate_hold+0x166>
        restore_condition.coolant.mask = block->condition.coolant.mask;
 801d74c:	693b      	ldr	r3, [r7, #16]
 801d74e:	7d9a      	ldrb	r2, [r3, #22]
 801d750:	4b35      	ldr	r3, [pc, #212]	; (801d828 <initiate_hold+0x238>)
 801d752:	701a      	strb	r2, [r3, #0]
 801d754:	e00a      	b.n	801d76c <initiate_hold+0x17c>
    else
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant.get_state().mask;
 801d756:	4b35      	ldr	r3, [pc, #212]	; (801d82c <initiate_hold+0x23c>)
 801d758:	7e5c      	ldrb	r4, [r3, #25]
 801d75a:	4b35      	ldr	r3, [pc, #212]	; (801d830 <initiate_hold+0x240>)
 801d75c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801d75e:	4798      	blx	r3
 801d760:	4603      	mov	r3, r0
 801d762:	b2db      	uxtb	r3, r3
 801d764:	4323      	orrs	r3, r4
 801d766:	b2da      	uxtb	r2, r3
 801d768:	4b2f      	ldr	r3, [pc, #188]	; (801d828 <initiate_hold+0x238>)
 801d76a:	701a      	strb	r2, [r3, #0]

    if (restore_condition.spindle[restore_condition.spindle_num].hal->cap.laser && settings.flags.disable_laser_during_hold)
 801d76c:	4b2e      	ldr	r3, [pc, #184]	; (801d828 <initiate_hold+0x238>)
 801d76e:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801d772:	4a2d      	ldr	r2, [pc, #180]	; (801d828 <initiate_hold+0x238>)
 801d774:	011b      	lsls	r3, r3, #4
 801d776:	4413      	add	r3, r2
 801d778:	3310      	adds	r3, #16
 801d77a:	681b      	ldr	r3, [r3, #0]
 801d77c:	7a9b      	ldrb	r3, [r3, #10]
 801d77e:	f003 0308 	and.w	r3, r3, #8
 801d782:	b2db      	uxtb	r3, r3
 801d784:	2b00      	cmp	r3, #0
 801d786:	d00a      	beq.n	801d79e <initiate_hold+0x1ae>
 801d788:	4b24      	ldr	r3, [pc, #144]	; (801d81c <initiate_hold+0x22c>)
 801d78a:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801d78e:	f003 0310 	and.w	r3, r3, #16
 801d792:	b2db      	uxtb	r3, r3
 801d794:	2b00      	cmp	r3, #0
 801d796:	d002      	beq.n	801d79e <initiate_hold+0x1ae>
        enqueue_spindle_override(CMD_OVERRIDE_SPINDLE_STOP);
 801d798:	209e      	movs	r0, #158	; 0x9e
 801d79a:	f7f3 fdc3 	bl	8011324 <enqueue_spindle_override>

    if (sys_state & (STATE_CYCLE|STATE_JOG)) {
 801d79e:	4b25      	ldr	r3, [pc, #148]	; (801d834 <initiate_hold+0x244>)
 801d7a0:	681b      	ldr	r3, [r3, #0]
 801d7a2:	f003 0328 	and.w	r3, r3, #40	; 0x28
 801d7a6:	2b00      	cmp	r3, #0
 801d7a8:	d009      	beq.n	801d7be <initiate_hold+0x1ce>
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 801d7aa:	f001 fceb 	bl	801f184 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 801d7ae:	4a22      	ldr	r2, [pc, #136]	; (801d838 <initiate_hold+0x248>)
 801d7b0:	7e13      	ldrb	r3, [r2, #24]
 801d7b2:	f043 0302 	orr.w	r3, r3, #2
 801d7b6:	7613      	strb	r3, [r2, #24]
        stateHandler = state_await_hold;
 801d7b8:	4b20      	ldr	r3, [pc, #128]	; (801d83c <initiate_hold+0x24c>)
 801d7ba:	4a21      	ldr	r2, [pc, #132]	; (801d840 <initiate_hold+0x250>)
 801d7bc:	601a      	str	r2, [r3, #0]
    }

    if (new_state == STATE_HOLD)
 801d7be:	687b      	ldr	r3, [r7, #4]
 801d7c0:	2b10      	cmp	r3, #16
 801d7c2:	d104      	bne.n	801d7ce <initiate_hold+0x1de>
        sys.holding_state = Hold_Pending;
 801d7c4:	4b1c      	ldr	r3, [pc, #112]	; (801d838 <initiate_hold+0x248>)
 801d7c6:	2202      	movs	r2, #2
 801d7c8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 801d7cc:	e006      	b.n	801d7dc <initiate_hold+0x1ec>
    else {
        sys.parking_state = Parking_Retracting;
 801d7ce:	4b1a      	ldr	r3, [pc, #104]	; (801d838 <initiate_hold+0x248>)
 801d7d0:	2202      	movs	r2, #2
 801d7d2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        park.flags.value = 0;
 801d7d6:	4b13      	ldr	r3, [pc, #76]	; (801d824 <initiate_hold+0x234>)
 801d7d8:	2200      	movs	r2, #0
 801d7da:	771a      	strb	r2, [r3, #28]
    }

    sys.suspend = !sys.flags.soft_limit;
 801d7dc:	4b16      	ldr	r3, [pc, #88]	; (801d838 <initiate_hold+0x248>)
 801d7de:	7d9b      	ldrb	r3, [r3, #22]
 801d7e0:	f003 0304 	and.w	r3, r3, #4
 801d7e4:	b2db      	uxtb	r3, r3
 801d7e6:	2b00      	cmp	r3, #0
 801d7e8:	bf0c      	ite	eq
 801d7ea:	2301      	moveq	r3, #1
 801d7ec:	2300      	movne	r3, #0
 801d7ee:	b2da      	uxtb	r2, r3
 801d7f0:	4b11      	ldr	r3, [pc, #68]	; (801d838 <initiate_hold+0x248>)
 801d7f2:	709a      	strb	r2, [r3, #2]
    pending_state = sys_state == STATE_JOG ? new_state : STATE_IDLE;
 801d7f4:	4b0f      	ldr	r3, [pc, #60]	; (801d834 <initiate_hold+0x244>)
 801d7f6:	681b      	ldr	r3, [r3, #0]
 801d7f8:	2b20      	cmp	r3, #32
 801d7fa:	d101      	bne.n	801d800 <initiate_hold+0x210>
 801d7fc:	687b      	ldr	r3, [r7, #4]
 801d7fe:	e000      	b.n	801d802 <initiate_hold+0x212>
 801d800:	2300      	movs	r3, #0
 801d802:	4a10      	ldr	r2, [pc, #64]	; (801d844 <initiate_hold+0x254>)
 801d804:	6013      	str	r3, [r2, #0]

    return sys_state == STATE_CYCLE;
 801d806:	4b0b      	ldr	r3, [pc, #44]	; (801d834 <initiate_hold+0x244>)
 801d808:	681b      	ldr	r3, [r3, #0]
 801d80a:	2b08      	cmp	r3, #8
 801d80c:	bf0c      	ite	eq
 801d80e:	2301      	moveq	r3, #1
 801d810:	2300      	movne	r3, #0
 801d812:	b2db      	uxtb	r3, r3
}
 801d814:	4618      	mov	r0, r3
 801d816:	371c      	adds	r7, #28
 801d818:	46bd      	mov	sp, r7
 801d81a:	bd90      	pop	{r4, r7, pc}
 801d81c:	2000147c 	.word	0x2000147c
 801d820:	200017e8 	.word	0x200017e8
 801d824:	200017c8 	.word	0x200017c8
 801d828:	200017ac 	.word	0x200017ac
 801d82c:	20000bb0 	.word	0x20000bb0
 801d830:	20000ed0 	.word	0x20000ed0
 801d834:	200017c4 	.word	0x200017c4
 801d838:	20000d3c 	.word	0x20000d3c
 801d83c:	20000394 	.word	0x20000394
 801d840:	0801dfed 	.word	0x0801dfed
 801d844:	200017c0 	.word	0x200017c0

0801d848 <state_door_reopened>:

bool state_door_reopened (void)
{
 801d848:	b480      	push	{r7}
 801d84a:	af00      	add	r7, sp, #0
    return settings.parking.flags.enabled && park.flags.restart;
 801d84c:	4b0c      	ldr	r3, [pc, #48]	; (801d880 <state_door_reopened+0x38>)
 801d84e:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801d852:	f003 0301 	and.w	r3, r3, #1
 801d856:	b2db      	uxtb	r3, r3
 801d858:	2b00      	cmp	r3, #0
 801d85a:	d008      	beq.n	801d86e <state_door_reopened+0x26>
 801d85c:	4b09      	ldr	r3, [pc, #36]	; (801d884 <state_door_reopened+0x3c>)
 801d85e:	7f1b      	ldrb	r3, [r3, #28]
 801d860:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801d864:	b2db      	uxtb	r3, r3
 801d866:	2b00      	cmp	r3, #0
 801d868:	d001      	beq.n	801d86e <state_door_reopened+0x26>
 801d86a:	2301      	movs	r3, #1
 801d86c:	e000      	b.n	801d870 <state_door_reopened+0x28>
 801d86e:	2300      	movs	r3, #0
 801d870:	f003 0301 	and.w	r3, r3, #1
 801d874:	b2db      	uxtb	r3, r3
}
 801d876:	4618      	mov	r0, r3
 801d878:	46bd      	mov	sp, r7
 801d87a:	bc80      	pop	{r7}
 801d87c:	4770      	bx	lr
 801d87e:	bf00      	nop
 801d880:	2000147c 	.word	0x2000147c
 801d884:	200017c8 	.word	0x200017c8

0801d888 <state_update>:

void state_update (rt_exec_t rt_exec)
{
 801d888:	b580      	push	{r7, lr}
 801d88a:	b082      	sub	sp, #8
 801d88c:	af00      	add	r7, sp, #0
 801d88e:	6078      	str	r0, [r7, #4]
    if((rt_exec & EXEC_SAFETY_DOOR) && sys_state != STATE_SAFETY_DOOR)
 801d890:	687b      	ldr	r3, [r7, #4]
 801d892:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801d896:	2b00      	cmp	r3, #0
 801d898:	d006      	beq.n	801d8a8 <state_update+0x20>
 801d89a:	4b07      	ldr	r3, [pc, #28]	; (801d8b8 <state_update+0x30>)
 801d89c:	681b      	ldr	r3, [r3, #0]
 801d89e:	2b40      	cmp	r3, #64	; 0x40
 801d8a0:	d002      	beq.n	801d8a8 <state_update+0x20>
        state_set(STATE_SAFETY_DOOR);
 801d8a2:	2040      	movs	r0, #64	; 0x40
 801d8a4:	f000 f816 	bl	801d8d4 <state_set>

    stateHandler(rt_exec);
 801d8a8:	4b04      	ldr	r3, [pc, #16]	; (801d8bc <state_update+0x34>)
 801d8aa:	681b      	ldr	r3, [r3, #0]
 801d8ac:	6878      	ldr	r0, [r7, #4]
 801d8ae:	4798      	blx	r3
}
 801d8b0:	bf00      	nop
 801d8b2:	3708      	adds	r7, #8
 801d8b4:	46bd      	mov	sp, r7
 801d8b6:	bd80      	pop	{r7, pc}
 801d8b8:	200017c4 	.word	0x200017c4
 801d8bc:	20000394 	.word	0x20000394

0801d8c0 <state_get>:

ISR_CODE sys_state_t ISR_FUNC(state_get)(void)
{
 801d8c0:	b480      	push	{r7}
 801d8c2:	af00      	add	r7, sp, #0
    return sys_state;
 801d8c4:	4b02      	ldr	r3, [pc, #8]	; (801d8d0 <state_get+0x10>)
 801d8c6:	681b      	ldr	r3, [r3, #0]
}
 801d8c8:	4618      	mov	r0, r3
 801d8ca:	46bd      	mov	sp, r7
 801d8cc:	bc80      	pop	{r7}
 801d8ce:	4770      	bx	lr
 801d8d0:	200017c4 	.word	0x200017c4

0801d8d4 <state_set>:

    return substate;
}

void state_set (sys_state_t new_state)
{
 801d8d4:	b580      	push	{r7, lr}
 801d8d6:	b086      	sub	sp, #24
 801d8d8:	af00      	add	r7, sp, #0
 801d8da:	6078      	str	r0, [r7, #4]
    if(new_state != sys_state) {
 801d8dc:	4ba2      	ldr	r3, [pc, #648]	; (801db68 <state_set+0x294>)
 801d8de:	681b      	ldr	r3, [r3, #0]
 801d8e0:	687a      	ldr	r2, [r7, #4]
 801d8e2:	429a      	cmp	r2, r3
 801d8e4:	f000 81b4 	beq.w	801dc50 <state_set+0x37c>

        sys_state_t org_state = sys_state;
 801d8e8:	4b9f      	ldr	r3, [pc, #636]	; (801db68 <state_set+0x294>)
 801d8ea:	681b      	ldr	r3, [r3, #0]
 801d8ec:	617b      	str	r3, [r7, #20]

        switch(new_state) {    // Set up new state and handler
 801d8ee:	687b      	ldr	r3, [r7, #4]
 801d8f0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801d8f4:	f000 80f4 	beq.w	801dae0 <state_set+0x20c>
 801d8f8:	687b      	ldr	r3, [r7, #4]
 801d8fa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801d8fe:	f200 818b 	bhi.w	801dc18 <state_set+0x344>
 801d902:	687b      	ldr	r3, [r7, #4]
 801d904:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801d908:	f000 8177 	beq.w	801dbfa <state_set+0x326>
 801d90c:	687b      	ldr	r3, [r7, #4]
 801d90e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801d912:	f200 8181 	bhi.w	801dc18 <state_set+0x344>
 801d916:	687b      	ldr	r3, [r7, #4]
 801d918:	2b80      	cmp	r3, #128	; 0x80
 801d91a:	f000 8146 	beq.w	801dbaa <state_set+0x2d6>
 801d91e:	687b      	ldr	r3, [r7, #4]
 801d920:	2b80      	cmp	r3, #128	; 0x80
 801d922:	f200 8179 	bhi.w	801dc18 <state_set+0x344>
 801d926:	687b      	ldr	r3, [r7, #4]
 801d928:	2b20      	cmp	r3, #32
 801d92a:	d849      	bhi.n	801d9c0 <state_set+0xec>
 801d92c:	687b      	ldr	r3, [r7, #4]
 801d92e:	2b20      	cmp	r3, #32
 801d930:	f200 8172 	bhi.w	801dc18 <state_set+0x344>
 801d934:	a201      	add	r2, pc, #4	; (adr r2, 801d93c <state_set+0x68>)
 801d936:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d93a:	bf00      	nop
 801d93c:	0801d9cb 	.word	0x0801d9cb
 801d940:	0801dbfb 	.word	0x0801dbfb
 801d944:	0801dbfb 	.word	0x0801dbfb
 801d948:	0801dc19 	.word	0x0801dc19
 801d94c:	0801dbfb 	.word	0x0801dbfb
 801d950:	0801dc19 	.word	0x0801dc19
 801d954:	0801dc19 	.word	0x0801dc19
 801d958:	0801dc19 	.word	0x0801dc19
 801d95c:	0801da03 	.word	0x0801da03
 801d960:	0801dc19 	.word	0x0801dc19
 801d964:	0801dc19 	.word	0x0801dc19
 801d968:	0801dc19 	.word	0x0801dc19
 801d96c:	0801dc19 	.word	0x0801dc19
 801d970:	0801dc19 	.word	0x0801dc19
 801d974:	0801dc19 	.word	0x0801dc19
 801d978:	0801dc19 	.word	0x0801dc19
 801d97c:	0801daef 	.word	0x0801daef
 801d980:	0801dc19 	.word	0x0801dc19
 801d984:	0801dc19 	.word	0x0801dc19
 801d988:	0801dc19 	.word	0x0801dc19
 801d98c:	0801dc19 	.word	0x0801dc19
 801d990:	0801dc19 	.word	0x0801dc19
 801d994:	0801dc19 	.word	0x0801dc19
 801d998:	0801dc19 	.word	0x0801dc19
 801d99c:	0801dc19 	.word	0x0801dc19
 801d9a0:	0801dc19 	.word	0x0801dc19
 801d9a4:	0801dc19 	.word	0x0801dc19
 801d9a8:	0801dc19 	.word	0x0801dc19
 801d9ac:	0801dc19 	.word	0x0801dc19
 801d9b0:	0801dc19 	.word	0x0801dc19
 801d9b4:	0801dc19 	.word	0x0801dc19
 801d9b8:	0801dc19 	.word	0x0801dc19
 801d9bc:	0801dac1 	.word	0x0801dac1
 801d9c0:	687b      	ldr	r3, [r7, #4]
 801d9c2:	2b40      	cmp	r3, #64	; 0x40
 801d9c4:	f000 80e6 	beq.w	801db94 <state_set+0x2c0>
 801d9c8:	e126      	b.n	801dc18 <state_set+0x344>

            case STATE_IDLE:
                sys.suspend = false;        // Break suspend state.
 801d9ca:	4b68      	ldr	r3, [pc, #416]	; (801db6c <state_set+0x298>)
 801d9cc:	2200      	movs	r2, #0
 801d9ce:	709a      	strb	r2, [r3, #2]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 801d9d0:	4b66      	ldr	r3, [pc, #408]	; (801db6c <state_set+0x298>)
 801d9d2:	2200      	movs	r2, #0
 801d9d4:	761a      	strb	r2, [r3, #24]
                sys.parking_state = Parking_DoorClosed;
 801d9d6:	4b65      	ldr	r3, [pc, #404]	; (801db6c <state_set+0x298>)
 801d9d8:	2200      	movs	r2, #0
 801d9da:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                sys.holding_state = Hold_NotHolding;
 801d9de:	4b63      	ldr	r3, [pc, #396]	; (801db6c <state_set+0x298>)
 801d9e0:	2200      	movs	r2, #0
 801d9e2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
                sys_state = pending_state = new_state;
 801d9e6:	4a62      	ldr	r2, [pc, #392]	; (801db70 <state_set+0x29c>)
 801d9e8:	687b      	ldr	r3, [r7, #4]
 801d9ea:	6013      	str	r3, [r2, #0]
 801d9ec:	4b60      	ldr	r3, [pc, #384]	; (801db70 <state_set+0x29c>)
 801d9ee:	681b      	ldr	r3, [r3, #0]
 801d9f0:	4a5d      	ldr	r2, [pc, #372]	; (801db68 <state_set+0x294>)
 801d9f2:	6013      	str	r3, [r2, #0]
                park.flags.value = 0;
 801d9f4:	4b5f      	ldr	r3, [pc, #380]	; (801db74 <state_set+0x2a0>)
 801d9f6:	2200      	movs	r2, #0
 801d9f8:	771a      	strb	r2, [r3, #28]
                stateHandler = state_idle;
 801d9fa:	4b5f      	ldr	r3, [pc, #380]	; (801db78 <state_set+0x2a4>)
 801d9fc:	4a5f      	ldr	r2, [pc, #380]	; (801db7c <state_set+0x2a8>)
 801d9fe:	601a      	str	r2, [r3, #0]
                break;
 801da00:	e10a      	b.n	801dc18 <state_set+0x344>

            case STATE_CYCLE:
                if (sys_state == STATE_IDLE) {
 801da02:	4b59      	ldr	r3, [pc, #356]	; (801db68 <state_set+0x294>)
 801da04:	681b      	ldr	r3, [r3, #0]
 801da06:	2b00      	cmp	r3, #0
 801da08:	f040 8101 	bne.w	801dc0e <state_set+0x33a>
                    // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
                    plan_block_t *block;
                    if ((block = plan_get_current_block())) {
 801da0c:	f7f3 ff66 	bl	80118dc <plan_get_current_block>
 801da10:	6138      	str	r0, [r7, #16]
 801da12:	693b      	ldr	r3, [r7, #16]
 801da14:	2b00      	cmp	r3, #0
 801da16:	f000 80fa 	beq.w	801dc0e <state_set+0x33a>
                        sys_state = new_state;
 801da1a:	4a53      	ldr	r2, [pc, #332]	; (801db68 <state_set+0x294>)
 801da1c:	687b      	ldr	r3, [r7, #4]
 801da1e:	6013      	str	r3, [r2, #0]
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 801da20:	4b52      	ldr	r3, [pc, #328]	; (801db6c <state_set+0x298>)
 801da22:	2200      	movs	r2, #0
 801da24:	719a      	strb	r2, [r3, #6]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 801da26:	f001 fc5b 	bl	801f2e0 <st_prep_buffer>
                        if (block->spindle.state.synchronized) {
 801da2a:	693b      	ldr	r3, [r7, #16]
 801da2c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801da30:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801da34:	b2db      	uxtb	r3, r3
 801da36:	2b00      	cmp	r3, #0
 801da38:	d03c      	beq.n	801dab4 <state_set+0x1e0>

                            uint32_t ms = hal.get_elapsed_ticks();
 801da3a:	4b51      	ldr	r3, [pc, #324]	; (801db80 <state_set+0x2ac>)
 801da3c:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801da40:	4798      	blx	r3
 801da42:	60f8      	str	r0, [r7, #12]

                            if (block->spindle.hal->reset_data)
 801da44:	693b      	ldr	r3, [r7, #16]
 801da46:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801da48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801da4a:	2b00      	cmp	r3, #0
 801da4c:	d003      	beq.n	801da56 <state_set+0x182>
                                block->spindle.hal->reset_data();
 801da4e:	693b      	ldr	r3, [r7, #16]
 801da50:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801da52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801da54:	4798      	blx	r3

                            uint32_t index = block->spindle.hal->get_data(SpindleData_Counters)->index_count + 2;
 801da56:	693b      	ldr	r3, [r7, #16]
 801da58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801da5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801da5c:	2000      	movs	r0, #0
 801da5e:	4798      	blx	r3
 801da60:	4603      	mov	r3, r0
 801da62:	695b      	ldr	r3, [r3, #20]
 801da64:	3302      	adds	r3, #2
 801da66:	60bb      	str	r3, [r7, #8]

                            while(index != block->spindle.hal->get_data(SpindleData_Counters)->index_count) {
 801da68:	e01a      	b.n	801daa0 <state_set+0x1cc>

                                if(hal.get_elapsed_ticks() - ms > 5000) {
 801da6a:	4b45      	ldr	r3, [pc, #276]	; (801db80 <state_set+0x2ac>)
 801da6c:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 801da70:	4798      	blx	r3
 801da72:	4602      	mov	r2, r0
 801da74:	68fb      	ldr	r3, [r7, #12]
 801da76:	1ad3      	subs	r3, r2, r3
 801da78:	f241 3288 	movw	r2, #5000	; 0x1388
 801da7c:	4293      	cmp	r3, r2
 801da7e:	d903      	bls.n	801da88 <state_set+0x1b4>
                                    system_raise_alarm(Alarm_Spindle);
 801da80:	200e      	movs	r0, #14
 801da82:	f004 fa1f 	bl	8021ec4 <system_raise_alarm>
                                    return;
 801da86:	e0e3      	b.n	801dc50 <state_set+0x37c>
                                }

                                if(sys.rt_exec_state & (EXEC_RESET|EXEC_STOP)) {
 801da88:	4b38      	ldr	r3, [pc, #224]	; (801db6c <state_set+0x298>)
 801da8a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801da8c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801da90:	2b00      	cmp	r3, #0
 801da92:	d005      	beq.n	801daa0 <state_set+0x1cc>
                                    system_set_exec_state_flag(EXEC_RESET);
 801da94:	4b3a      	ldr	r3, [pc, #232]	; (801db80 <state_set+0x2ac>)
 801da96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801da98:	2120      	movs	r1, #32
 801da9a:	483a      	ldr	r0, [pc, #232]	; (801db84 <state_set+0x2b0>)
 801da9c:	4798      	blx	r3
                                    return;
 801da9e:	e0d7      	b.n	801dc50 <state_set+0x37c>
                            while(index != block->spindle.hal->get_data(SpindleData_Counters)->index_count) {
 801daa0:	693b      	ldr	r3, [r7, #16]
 801daa2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801daa4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801daa6:	2000      	movs	r0, #0
 801daa8:	4798      	blx	r3
 801daaa:	4603      	mov	r3, r0
 801daac:	695b      	ldr	r3, [r3, #20]
 801daae:	68ba      	ldr	r2, [r7, #8]
 801dab0:	429a      	cmp	r2, r3
 801dab2:	d1da      	bne.n	801da6a <state_set+0x196>
                                }
                                // TODO: allow real time reporting?
                            }

                        }
                        st_wake_up();
 801dab4:	f000 ffee 	bl	801ea94 <st_wake_up>
                        stateHandler = state_cycle;
 801dab8:	4b2f      	ldr	r3, [pc, #188]	; (801db78 <state_set+0x2a4>)
 801daba:	4a33      	ldr	r2, [pc, #204]	; (801db88 <state_set+0x2b4>)
 801dabc:	601a      	str	r2, [r3, #0]
                    }
                }
                break;
 801dabe:	e0a6      	b.n	801dc0e <state_set+0x33a>

            case STATE_JOG:
                if (sys_state == STATE_TOOL_CHANGE)
 801dac0:	4b29      	ldr	r3, [pc, #164]	; (801db68 <state_set+0x294>)
 801dac2:	681b      	ldr	r3, [r3, #0]
 801dac4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801dac8:	d103      	bne.n	801dad2 <state_set+0x1fe>
                    pending_state = STATE_TOOL_CHANGE;
 801daca:	4b29      	ldr	r3, [pc, #164]	; (801db70 <state_set+0x29c>)
 801dacc:	f44f 7200 	mov.w	r2, #512	; 0x200
 801dad0:	601a      	str	r2, [r3, #0]
                sys_state = new_state;
 801dad2:	4a25      	ldr	r2, [pc, #148]	; (801db68 <state_set+0x294>)
 801dad4:	687b      	ldr	r3, [r7, #4]
 801dad6:	6013      	str	r3, [r2, #0]
                stateHandler = state_cycle;
 801dad8:	4b27      	ldr	r3, [pc, #156]	; (801db78 <state_set+0x2a4>)
 801dada:	4a2b      	ldr	r2, [pc, #172]	; (801db88 <state_set+0x2b4>)
 801dadc:	601a      	str	r2, [r3, #0]
                break;
 801dade:	e09b      	b.n	801dc18 <state_set+0x344>

            case STATE_TOOL_CHANGE:
                sys_state = new_state;
 801dae0:	4a21      	ldr	r2, [pc, #132]	; (801db68 <state_set+0x294>)
 801dae2:	687b      	ldr	r3, [r7, #4]
 801dae4:	6013      	str	r3, [r2, #0]
                stateHandler = state_await_toolchanged;
 801dae6:	4b24      	ldr	r3, [pc, #144]	; (801db78 <state_set+0x2a4>)
 801dae8:	4a28      	ldr	r2, [pc, #160]	; (801db8c <state_set+0x2b8>)
 801daea:	601a      	str	r2, [r3, #0]
                break;
 801daec:	e094      	b.n	801dc18 <state_set+0x344>

            case STATE_HOLD:
                if (sys.override.control.sync && sys.override.control.feed_hold_disable)
 801daee:	4b1f      	ldr	r3, [pc, #124]	; (801db6c <state_set+0x298>)
 801daf0:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801daf4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801daf8:	b2db      	uxtb	r3, r3
 801dafa:	2b00      	cmp	r3, #0
 801dafc:	d00c      	beq.n	801db18 <state_set+0x244>
 801dafe:	4b1b      	ldr	r3, [pc, #108]	; (801db6c <state_set+0x298>)
 801db00:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801db04:	f003 0302 	and.w	r3, r3, #2
 801db08:	b2db      	uxtb	r3, r3
 801db0a:	2b00      	cmp	r3, #0
 801db0c:	d004      	beq.n	801db18 <state_set+0x244>
                    sys.flags.feed_hold_pending = On;
 801db0e:	4a17      	ldr	r2, [pc, #92]	; (801db6c <state_set+0x298>)
 801db10:	7d93      	ldrb	r3, [r2, #22]
 801db12:	f043 0320 	orr.w	r3, r3, #32
 801db16:	7593      	strb	r3, [r2, #22]
                if (!((sys_state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 801db18:	4b13      	ldr	r3, [pc, #76]	; (801db68 <state_set+0x294>)
 801db1a:	681b      	ldr	r3, [r3, #0]
 801db1c:	f003 0320 	and.w	r3, r3, #32
 801db20:	2b00      	cmp	r3, #0
 801db22:	d176      	bne.n	801dc12 <state_set+0x33e>
 801db24:	4b11      	ldr	r3, [pc, #68]	; (801db6c <state_set+0x298>)
 801db26:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801db2a:	f003 0302 	and.w	r3, r3, #2
 801db2e:	b2db      	uxtb	r3, r3
 801db30:	2b00      	cmp	r3, #0
 801db32:	d16e      	bne.n	801dc12 <state_set+0x33e>
                    if (!initiate_hold(new_state)) {
 801db34:	6878      	ldr	r0, [r7, #4]
 801db36:	f7ff fd5b 	bl	801d5f0 <initiate_hold>
 801db3a:	4603      	mov	r3, r0
 801db3c:	f083 0301 	eor.w	r3, r3, #1
 801db40:	b2db      	uxtb	r3, r3
 801db42:	2b00      	cmp	r3, #0
 801db44:	d006      	beq.n	801db54 <state_set+0x280>
                        sys.holding_state = Hold_Complete;
 801db46:	4b09      	ldr	r3, [pc, #36]	; (801db6c <state_set+0x298>)
 801db48:	2201      	movs	r2, #1
 801db4a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
                        stateHandler = state_await_resume;
 801db4e:	4b0a      	ldr	r3, [pc, #40]	; (801db78 <state_set+0x2a4>)
 801db50:	4a0f      	ldr	r2, [pc, #60]	; (801db90 <state_set+0x2bc>)
 801db52:	601a      	str	r2, [r3, #0]
                    }
                    sys_state = new_state;
 801db54:	4a04      	ldr	r2, [pc, #16]	; (801db68 <state_set+0x294>)
 801db56:	687b      	ldr	r3, [r7, #4]
 801db58:	6013      	str	r3, [r2, #0]
                    sys.flags.feed_hold_pending = Off;
 801db5a:	4a04      	ldr	r2, [pc, #16]	; (801db6c <state_set+0x298>)
 801db5c:	7d93      	ldrb	r3, [r2, #22]
 801db5e:	f36f 1345 	bfc	r3, #5, #1
 801db62:	7593      	strb	r3, [r2, #22]
                }
                break;
 801db64:	e055      	b.n	801dc12 <state_set+0x33e>
 801db66:	bf00      	nop
 801db68:	200017c4 	.word	0x200017c4
 801db6c:	20000d3c 	.word	0x20000d3c
 801db70:	200017c0 	.word	0x200017c0
 801db74:	200017c8 	.word	0x200017c8
 801db78:	20000394 	.word	0x20000394
 801db7c:	0801dddd 	.word	0x0801dddd
 801db80:	20000ed0 	.word	0x20000ed0
 801db84:	20000d84 	.word	0x20000d84
 801db88:	0801de3d 	.word	0x0801de3d
 801db8c:	0801ded5 	.word	0x0801ded5
 801db90:	0801e35d 	.word	0x0801e35d

            case STATE_SAFETY_DOOR:
                if ((sys_state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE)))
 801db94:	4b30      	ldr	r3, [pc, #192]	; (801dc58 <state_set+0x384>)
 801db96:	681a      	ldr	r2, [r3, #0]
 801db98:	f240 1383 	movw	r3, #387	; 0x183
 801db9c:	4013      	ands	r3, r2
 801db9e:	2b00      	cmp	r3, #0
 801dba0:	d155      	bne.n	801dc4e <state_set+0x37a>
                    return;
                grbl.report.feedback_message(Message_SafetyDoorAjar);
 801dba2:	4b2e      	ldr	r3, [pc, #184]	; (801dc5c <state_set+0x388>)
 801dba4:	68db      	ldr	r3, [r3, #12]
 801dba6:	2006      	movs	r0, #6
 801dba8:	4798      	blx	r3
                // no break
            case STATE_SLEEP:
                sys.parking_state = Parking_Retracting;
 801dbaa:	4b2d      	ldr	r3, [pc, #180]	; (801dc60 <state_set+0x38c>)
 801dbac:	2202      	movs	r2, #2
 801dbae:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                if (!initiate_hold(new_state)) {
 801dbb2:	6878      	ldr	r0, [r7, #4]
 801dbb4:	f7ff fd1c 	bl	801d5f0 <initiate_hold>
 801dbb8:	4603      	mov	r3, r0
 801dbba:	f083 0301 	eor.w	r3, r3, #1
 801dbbe:	b2db      	uxtb	r3, r3
 801dbc0:	2b00      	cmp	r3, #0
 801dbc2:	d00b      	beq.n	801dbdc <state_set+0x308>
                    if (pending_state != new_state) {
 801dbc4:	4b27      	ldr	r3, [pc, #156]	; (801dc64 <state_set+0x390>)
 801dbc6:	681b      	ldr	r3, [r3, #0]
 801dbc8:	687a      	ldr	r2, [r7, #4]
 801dbca:	429a      	cmp	r2, r3
 801dbcc:	d009      	beq.n	801dbe2 <state_set+0x30e>
                        sys_state = new_state;
 801dbce:	4a22      	ldr	r2, [pc, #136]	; (801dc58 <state_set+0x384>)
 801dbd0:	687b      	ldr	r3, [r7, #4]
 801dbd2:	6013      	str	r3, [r2, #0]
                        state_await_hold(EXEC_CYCLE_COMPLETE); // "Simulate" a cycle stop
 801dbd4:	2004      	movs	r0, #4
 801dbd6:	f000 fa09 	bl	801dfec <state_await_hold>
 801dbda:	e002      	b.n	801dbe2 <state_set+0x30e>
                    }
                } else
                    sys_state = new_state;
 801dbdc:	4a1e      	ldr	r2, [pc, #120]	; (801dc58 <state_set+0x384>)
 801dbde:	687b      	ldr	r3, [r7, #4]
 801dbe0:	6013      	str	r3, [r2, #0]
                if(sys_state == STATE_SLEEP && stateHandler != state_await_waypoint_retract)
 801dbe2:	4b1d      	ldr	r3, [pc, #116]	; (801dc58 <state_set+0x384>)
 801dbe4:	681b      	ldr	r3, [r3, #0]
 801dbe6:	2b80      	cmp	r3, #128	; 0x80
 801dbe8:	d115      	bne.n	801dc16 <state_set+0x342>
 801dbea:	4b1f      	ldr	r3, [pc, #124]	; (801dc68 <state_set+0x394>)
 801dbec:	681b      	ldr	r3, [r3, #0]
 801dbee:	4a1f      	ldr	r2, [pc, #124]	; (801dc6c <state_set+0x398>)
 801dbf0:	4293      	cmp	r3, r2
 801dbf2:	d010      	beq.n	801dc16 <state_set+0x342>
                    enter_sleep();
 801dbf4:	f7ff fce0 	bl	801d5b8 <enter_sleep>
                break;
 801dbf8:	e00d      	b.n	801dc16 <state_set+0x342>

            case STATE_ALARM:
            case STATE_ESTOP:
            case STATE_HOMING:
            case STATE_CHECK_MODE:
                sys_state = new_state;
 801dbfa:	4a17      	ldr	r2, [pc, #92]	; (801dc58 <state_set+0x384>)
 801dbfc:	687b      	ldr	r3, [r7, #4]
 801dbfe:	6013      	str	r3, [r2, #0]
                sys.suspend = false;
 801dc00:	4b17      	ldr	r3, [pc, #92]	; (801dc60 <state_set+0x38c>)
 801dc02:	2200      	movs	r2, #0
 801dc04:	709a      	strb	r2, [r3, #2]
                stateHandler = state_noop;
 801dc06:	4b18      	ldr	r3, [pc, #96]	; (801dc68 <state_set+0x394>)
 801dc08:	4a19      	ldr	r2, [pc, #100]	; (801dc70 <state_set+0x39c>)
 801dc0a:	601a      	str	r2, [r3, #0]
                break;
 801dc0c:	e004      	b.n	801dc18 <state_set+0x344>
                break;
 801dc0e:	bf00      	nop
 801dc10:	e002      	b.n	801dc18 <state_set+0x344>
                break;
 801dc12:	bf00      	nop
 801dc14:	e000      	b.n	801dc18 <state_set+0x344>
                break;
 801dc16:	bf00      	nop
        }

        if(!(sys_state & (STATE_ALARM|STATE_ESTOP)))
 801dc18:	4b0f      	ldr	r3, [pc, #60]	; (801dc58 <state_set+0x384>)
 801dc1a:	681a      	ldr	r2, [r3, #0]
 801dc1c:	f240 1301 	movw	r3, #257	; 0x101
 801dc20:	4013      	ands	r3, r2
 801dc22:	2b00      	cmp	r3, #0
 801dc24:	d103      	bne.n	801dc2e <state_set+0x35a>
            sys.alarm = Alarm_None;
 801dc26:	4b0e      	ldr	r3, [pc, #56]	; (801dc60 <state_set+0x38c>)
 801dc28:	2200      	movs	r2, #0
 801dc2a:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

        if(sys_state != org_state && grbl.on_state_change)
 801dc2e:	4b0a      	ldr	r3, [pc, #40]	; (801dc58 <state_set+0x384>)
 801dc30:	681b      	ldr	r3, [r3, #0]
 801dc32:	697a      	ldr	r2, [r7, #20]
 801dc34:	429a      	cmp	r2, r3
 801dc36:	d00b      	beq.n	801dc50 <state_set+0x37c>
 801dc38:	4b08      	ldr	r3, [pc, #32]	; (801dc5c <state_set+0x388>)
 801dc3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801dc3c:	2b00      	cmp	r3, #0
 801dc3e:	d007      	beq.n	801dc50 <state_set+0x37c>
            grbl.on_state_change(sys_state);
 801dc40:	4b06      	ldr	r3, [pc, #24]	; (801dc5c <state_set+0x388>)
 801dc42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801dc44:	4a04      	ldr	r2, [pc, #16]	; (801dc58 <state_set+0x384>)
 801dc46:	6812      	ldr	r2, [r2, #0]
 801dc48:	4610      	mov	r0, r2
 801dc4a:	4798      	blx	r3
 801dc4c:	e000      	b.n	801dc50 <state_set+0x37c>
                    return;
 801dc4e:	bf00      	nop
    }
}
 801dc50:	3718      	adds	r7, #24
 801dc52:	46bd      	mov	sp, r7
 801dc54:	bd80      	pop	{r7, pc}
 801dc56:	bf00      	nop
 801dc58:	200017c4 	.word	0x200017c4
 801dc5c:	20000dd4 	.word	0x20000dd4
 801dc60:	20000d3c 	.word	0x20000d3c
 801dc64:	200017c0 	.word	0x200017c0
 801dc68:	20000394 	.word	0x20000394
 801dc6c:	0801e755 	.word	0x0801e755
 801dc70:	0801ddc9 	.word	0x0801ddc9

0801dc74 <state_suspend_manager>:

// Suspend manager. Controls spindle overrides in hold states.
void state_suspend_manager (void)
{
 801dc74:	b580      	push	{r7, lr}
 801dc76:	af00      	add	r7, sp, #0
    if (stateHandler != state_await_resume || !gc_state.modal.spindle.state.on)
 801dc78:	4b4d      	ldr	r3, [pc, #308]	; (801ddb0 <state_suspend_manager+0x13c>)
 801dc7a:	681b      	ldr	r3, [r3, #0]
 801dc7c:	4a4d      	ldr	r2, [pc, #308]	; (801ddb4 <state_suspend_manager+0x140>)
 801dc7e:	4293      	cmp	r3, r2
 801dc80:	f040 8093 	bne.w	801ddaa <state_suspend_manager+0x136>
 801dc84:	4b4c      	ldr	r3, [pc, #304]	; (801ddb8 <state_suspend_manager+0x144>)
 801dc86:	7e9b      	ldrb	r3, [r3, #26]
 801dc88:	f003 0301 	and.w	r3, r3, #1
 801dc8c:	b2db      	uxtb	r3, r3
 801dc8e:	2b00      	cmp	r3, #0
 801dc90:	f000 808b 	beq.w	801ddaa <state_suspend_manager+0x136>
        return;

    if (sys.override.spindle_stop.value) {
 801dc94:	4b49      	ldr	r3, [pc, #292]	; (801ddbc <state_suspend_manager+0x148>)
 801dc96:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801dc9a:	2b00      	cmp	r3, #0
 801dc9c:	d060      	beq.n	801dd60 <state_suspend_manager+0xec>

        // Handles beginning of spindle stop
        if (sys.override.spindle_stop.initiate) {
 801dc9e:	4b47      	ldr	r3, [pc, #284]	; (801ddbc <state_suspend_manager+0x148>)
 801dca0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801dca4:	f003 0302 	and.w	r3, r3, #2
 801dca8:	b2db      	uxtb	r3, r3
 801dcaa:	2b00      	cmp	r3, #0
 801dcac:	d021      	beq.n	801dcf2 <state_suspend_manager+0x7e>
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801dcae:	4b43      	ldr	r3, [pc, #268]	; (801ddbc <state_suspend_manager+0x148>)
 801dcb0:	2200      	movs	r2, #0
 801dcb2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
            spindle_set_state(restore_condition.spindle[restore_condition.spindle_num].hal, (spindle_state_t){0}, 0.0f); // De-energize
 801dcb6:	4b42      	ldr	r3, [pc, #264]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dcb8:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801dcbc:	4a40      	ldr	r2, [pc, #256]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dcbe:	011b      	lsls	r3, r3, #4
 801dcc0:	4413      	add	r3, r2
 801dcc2:	3310      	adds	r3, #16
 801dcc4:	681b      	ldr	r3, [r3, #0]
 801dcc6:	2200      	movs	r2, #0
 801dcc8:	4611      	mov	r1, r2
 801dcca:	f04f 0200 	mov.w	r2, #0
 801dcce:	4618      	mov	r0, r3
 801dcd0:	f7ff f880 	bl	801cdd4 <spindle_set_state>
            sys.override.spindle_stop.enabled = On; // Set stop override state to enabled, if de-energized.
 801dcd4:	4a39      	ldr	r2, [pc, #228]	; (801ddbc <state_suspend_manager+0x148>)
 801dcd6:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801dcda:	f043 0301 	orr.w	r3, r3, #1
 801dcde:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
            if(grbl.on_override_changed)
 801dce2:	4b38      	ldr	r3, [pc, #224]	; (801ddc4 <state_suspend_manager+0x150>)
 801dce4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801dce6:	2b00      	cmp	r3, #0
 801dce8:	d003      	beq.n	801dcf2 <state_suspend_manager+0x7e>
                grbl.on_override_changed(OverrideChanged_SpindleState);
 801dcea:	4b36      	ldr	r3, [pc, #216]	; (801ddc4 <state_suspend_manager+0x150>)
 801dcec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801dcee:	2000      	movs	r0, #0
 801dcf0:	4798      	blx	r3
        }

        // Handles restoring of spindle state
        if (sys.override.spindle_stop.restore) {
 801dcf2:	4b32      	ldr	r3, [pc, #200]	; (801ddbc <state_suspend_manager+0x148>)
 801dcf4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801dcf8:	f003 0304 	and.w	r3, r3, #4
 801dcfc:	b2db      	uxtb	r3, r3
 801dcfe:	2b00      	cmp	r3, #0
 801dd00:	d054      	beq.n	801ddac <state_suspend_manager+0x138>
            grbl.report.feedback_message(Message_SpindleRestore);
 801dd02:	4b30      	ldr	r3, [pc, #192]	; (801ddc4 <state_suspend_manager+0x150>)
 801dd04:	68db      	ldr	r3, [r3, #12]
 801dd06:	200a      	movs	r0, #10
 801dd08:	4798      	blx	r3
            if (restore_condition.spindle[restore_condition.spindle_num].hal->cap.laser) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 801dd0a:	4b2d      	ldr	r3, [pc, #180]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd0c:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801dd10:	4a2b      	ldr	r2, [pc, #172]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd12:	011b      	lsls	r3, r3, #4
 801dd14:	4413      	add	r3, r2
 801dd16:	3310      	adds	r3, #16
 801dd18:	681b      	ldr	r3, [r3, #0]
 801dd1a:	7a9b      	ldrb	r3, [r3, #10]
 801dd1c:	f003 0308 	and.w	r3, r3, #8
 801dd20:	b2db      	uxtb	r3, r3
 801dd22:	2b00      	cmp	r3, #0
 801dd24:	d005      	beq.n	801dd32 <state_suspend_manager+0xbe>
                sys.step_control.update_spindle_rpm = On;
 801dd26:	4a25      	ldr	r2, [pc, #148]	; (801ddbc <state_suspend_manager+0x148>)
 801dd28:	7e13      	ldrb	r3, [r2, #24]
 801dd2a:	f043 0308 	orr.w	r3, r3, #8
 801dd2e:	7613      	strb	r3, [r2, #24]
 801dd30:	e009      	b.n	801dd46 <state_suspend_manager+0xd2>
            else
                state_spindle_set_state(&restore_condition.spindle[restore_condition.spindle_num]);
 801dd32:	4b23      	ldr	r3, [pc, #140]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd34:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801dd38:	011b      	lsls	r3, r3, #4
 801dd3a:	4a21      	ldr	r2, [pc, #132]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd3c:	4413      	add	r3, r2
 801dd3e:	3304      	adds	r3, #4
 801dd40:	4618      	mov	r0, r3
 801dd42:	f7ff fbcf 	bl	801d4e4 <state_spindle_set_state>
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801dd46:	4b1d      	ldr	r3, [pc, #116]	; (801ddbc <state_suspend_manager+0x148>)
 801dd48:	2200      	movs	r2, #0
 801dd4a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
            if(grbl.on_override_changed)
 801dd4e:	4b1d      	ldr	r3, [pc, #116]	; (801ddc4 <state_suspend_manager+0x150>)
 801dd50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801dd52:	2b00      	cmp	r3, #0
 801dd54:	d02a      	beq.n	801ddac <state_suspend_manager+0x138>
                grbl.on_override_changed(OverrideChanged_SpindleState);
 801dd56:	4b1b      	ldr	r3, [pc, #108]	; (801ddc4 <state_suspend_manager+0x150>)
 801dd58:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801dd5a:	2000      	movs	r0, #0
 801dd5c:	4798      	blx	r3
 801dd5e:	e025      	b.n	801ddac <state_suspend_manager+0x138>
        }

    } else if (sys.step_control.update_spindle_rpm && restore_condition.spindle[0].hal->get_state(restore_condition.spindle[0].hal).on) {
 801dd60:	4b16      	ldr	r3, [pc, #88]	; (801ddbc <state_suspend_manager+0x148>)
 801dd62:	7e1b      	ldrb	r3, [r3, #24]
 801dd64:	f003 0308 	and.w	r3, r3, #8
 801dd68:	b2db      	uxtb	r3, r3
 801dd6a:	2b00      	cmp	r3, #0
 801dd6c:	d01e      	beq.n	801ddac <state_suspend_manager+0x138>
 801dd6e:	4b14      	ldr	r3, [pc, #80]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd70:	691b      	ldr	r3, [r3, #16]
 801dd72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801dd74:	4a12      	ldr	r2, [pc, #72]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd76:	6912      	ldr	r2, [r2, #16]
 801dd78:	4610      	mov	r0, r2
 801dd7a:	4798      	blx	r3
 801dd7c:	4603      	mov	r3, r0
 801dd7e:	b2db      	uxtb	r3, r3
 801dd80:	f003 0301 	and.w	r3, r3, #1
 801dd84:	b2db      	uxtb	r3, r3
 801dd86:	2b00      	cmp	r3, #0
 801dd88:	d010      	beq.n	801ddac <state_suspend_manager+0x138>
        // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
        state_spindle_set_state(&restore_condition.spindle[restore_condition.spindle_num]);
 801dd8a:	4b0d      	ldr	r3, [pc, #52]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd8c:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801dd90:	011b      	lsls	r3, r3, #4
 801dd92:	4a0b      	ldr	r2, [pc, #44]	; (801ddc0 <state_suspend_manager+0x14c>)
 801dd94:	4413      	add	r3, r2
 801dd96:	3304      	adds	r3, #4
 801dd98:	4618      	mov	r0, r3
 801dd9a:	f7ff fba3 	bl	801d4e4 <state_spindle_set_state>
        sys.step_control.update_spindle_rpm = Off;
 801dd9e:	4a07      	ldr	r2, [pc, #28]	; (801ddbc <state_suspend_manager+0x148>)
 801dda0:	7e13      	ldrb	r3, [r2, #24]
 801dda2:	f36f 03c3 	bfc	r3, #3, #1
 801dda6:	7613      	strb	r3, [r2, #24]
 801dda8:	e000      	b.n	801ddac <state_suspend_manager+0x138>
        return;
 801ddaa:	bf00      	nop
    }
}
 801ddac:	bd80      	pop	{r7, pc}
 801ddae:	bf00      	nop
 801ddb0:	20000394 	.word	0x20000394
 801ddb4:	0801e35d 	.word	0x0801e35d
 801ddb8:	20000bb0 	.word	0x20000bb0
 801ddbc:	20000d3c 	.word	0x20000d3c
 801ddc0:	200017ac 	.word	0x200017ac
 801ddc4:	20000dd4 	.word	0x20000dd4

0801ddc8 <state_noop>:
// **************

/*! /brief No operation handler.
 */
static void state_noop (uint_fast16_t rt_exec)
{
 801ddc8:	b480      	push	{r7}
 801ddca:	b083      	sub	sp, #12
 801ddcc:	af00      	add	r7, sp, #0
 801ddce:	6078      	str	r0, [r7, #4]
    // Do nothing - state change requests are handled elsewhere or ignored.
}
 801ddd0:	bf00      	nop
 801ddd2:	370c      	adds	r7, #12
 801ddd4:	46bd      	mov	sp, r7
 801ddd6:	bc80      	pop	{r7}
 801ddd8:	4770      	bx	lr
	...

0801dddc <state_idle>:

/*! /brief Waits for idle actions and executes them by switching to the appropriate sys_state.
 */
static void state_idle (uint_fast16_t rt_exec)
{
 801dddc:	b580      	push	{r7, lr}
 801ddde:	b082      	sub	sp, #8
 801dde0:	af00      	add	r7, sp, #0
 801dde2:	6078      	str	r0, [r7, #4]
    if ((rt_exec & EXEC_CYCLE_START))
 801dde4:	687b      	ldr	r3, [r7, #4]
 801dde6:	f003 0302 	and.w	r3, r3, #2
 801ddea:	2b00      	cmp	r3, #0
 801ddec:	d002      	beq.n	801ddf4 <state_idle+0x18>
        state_set(STATE_CYCLE);
 801ddee:	2008      	movs	r0, #8
 801ddf0:	f7ff fd70 	bl	801d8d4 <state_set>

    if (rt_exec & EXEC_FEED_HOLD)
 801ddf4:	687b      	ldr	r3, [r7, #4]
 801ddf6:	f003 0308 	and.w	r3, r3, #8
 801ddfa:	2b00      	cmp	r3, #0
 801ddfc:	d002      	beq.n	801de04 <state_idle+0x28>
        state_set(STATE_HOLD);
 801ddfe:	2010      	movs	r0, #16
 801de00:	f7ff fd68 	bl	801d8d4 <state_set>

    if ((rt_exec & EXEC_TOOL_CHANGE)) {
 801de04:	687b      	ldr	r3, [r7, #4]
 801de06:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801de0a:	2b00      	cmp	r3, #0
 801de0c:	d008      	beq.n	801de20 <state_idle+0x44>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 801de0e:	4b0a      	ldr	r3, [pc, #40]	; (801de38 <state_idle+0x5c>)
 801de10:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801de14:	2001      	movs	r0, #1
 801de16:	4798      	blx	r3
        state_set(STATE_TOOL_CHANGE);
 801de18:	f44f 7000 	mov.w	r0, #512	; 0x200
 801de1c:	f7ff fd5a 	bl	801d8d4 <state_set>
    }

    if (rt_exec & EXEC_SLEEP)
 801de20:	687b      	ldr	r3, [r7, #4]
 801de22:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801de26:	2b00      	cmp	r3, #0
 801de28:	d002      	beq.n	801de30 <state_idle+0x54>
        state_set(STATE_SLEEP);
 801de2a:	2080      	movs	r0, #128	; 0x80
 801de2c:	f7ff fd52 	bl	801d8d4 <state_set>
}
 801de30:	bf00      	nop
 801de32:	3708      	adds	r7, #8
 801de34:	46bd      	mov	sp, r7
 801de36:	bd80      	pop	{r7, pc}
 801de38:	20000ed0 	.word	0x20000ed0

0801de3c <state_cycle>:

/*! /brief Waits for cycle actions and executes them by switching to the appropriate sys_state.
 */
static void state_cycle (uint_fast16_t rt_exec)
{
 801de3c:	b580      	push	{r7, lr}
 801de3e:	b082      	sub	sp, #8
 801de40:	af00      	add	r7, sp, #0
 801de42:	6078      	str	r0, [r7, #4]
    if (rt_exec == EXEC_CYCLE_START)
 801de44:	687b      	ldr	r3, [r7, #4]
 801de46:	2b02      	cmp	r3, #2
 801de48:	d035      	beq.n	801deb6 <state_cycle+0x7a>
        return; // no need to perform other tests...

    if ((rt_exec & EXEC_TOOL_CHANGE))
 801de4a:	687b      	ldr	r3, [r7, #4]
 801de4c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801de50:	2b00      	cmp	r3, #0
 801de52:	d004      	beq.n	801de5e <state_cycle+0x22>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 801de54:	4b1a      	ldr	r3, [pc, #104]	; (801dec0 <state_cycle+0x84>)
 801de56:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801de5a:	2001      	movs	r0, #1
 801de5c:	4798      	blx	r3

    if (rt_exec & EXEC_CYCLE_COMPLETE)
 801de5e:	687b      	ldr	r3, [r7, #4]
 801de60:	f003 0304 	and.w	r3, r3, #4
 801de64:	2b00      	cmp	r3, #0
 801de66:	d00b      	beq.n	801de80 <state_cycle+0x44>
        state_set(gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE);
 801de68:	4b16      	ldr	r3, [pc, #88]	; (801dec4 <state_cycle+0x88>)
 801de6a:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801de6e:	2b00      	cmp	r3, #0
 801de70:	d002      	beq.n	801de78 <state_cycle+0x3c>
 801de72:	f44f 7300 	mov.w	r3, #512	; 0x200
 801de76:	e000      	b.n	801de7a <state_cycle+0x3e>
 801de78:	2300      	movs	r3, #0
 801de7a:	4618      	mov	r0, r3
 801de7c:	f7ff fd2a 	bl	801d8d4 <state_set>

    if (rt_exec & EXEC_MOTION_CANCEL) {
 801de80:	687b      	ldr	r3, [r7, #4]
 801de82:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801de86:	2b00      	cmp	r3, #0
 801de88:	d00c      	beq.n	801dea4 <state_cycle+0x68>
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 801de8a:	f001 f97b 	bl	801f184 <st_update_plan_block_parameters>
        sys.suspend = true;
 801de8e:	4b0e      	ldr	r3, [pc, #56]	; (801dec8 <state_cycle+0x8c>)
 801de90:	2201      	movs	r2, #1
 801de92:	709a      	strb	r2, [r3, #2]
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 801de94:	4a0c      	ldr	r2, [pc, #48]	; (801dec8 <state_cycle+0x8c>)
 801de96:	7e13      	ldrb	r3, [r2, #24]
 801de98:	f043 0302 	orr.w	r3, r3, #2
 801de9c:	7613      	strb	r3, [r2, #24]
        stateHandler = state_await_motion_cancel;
 801de9e:	4b0b      	ldr	r3, [pc, #44]	; (801decc <state_cycle+0x90>)
 801dea0:	4a0b      	ldr	r2, [pc, #44]	; (801ded0 <state_cycle+0x94>)
 801dea2:	601a      	str	r2, [r3, #0]
    }

    if ((rt_exec & EXEC_FEED_HOLD))
 801dea4:	687b      	ldr	r3, [r7, #4]
 801dea6:	f003 0308 	and.w	r3, r3, #8
 801deaa:	2b00      	cmp	r3, #0
 801deac:	d004      	beq.n	801deb8 <state_cycle+0x7c>
        state_set(STATE_HOLD);
 801deae:	2010      	movs	r0, #16
 801deb0:	f7ff fd10 	bl	801d8d4 <state_set>
 801deb4:	e000      	b.n	801deb8 <state_cycle+0x7c>
        return; // no need to perform other tests...
 801deb6:	bf00      	nop
}
 801deb8:	3708      	adds	r7, #8
 801deba:	46bd      	mov	sp, r7
 801debc:	bd80      	pop	{r7, pc}
 801debe:	bf00      	nop
 801dec0:	20000ed0 	.word	0x20000ed0
 801dec4:	20000bb0 	.word	0x20000bb0
 801dec8:	20000d3c 	.word	0x20000d3c
 801decc:	20000394 	.word	0x20000394
 801ded0:	0801df75 	.word	0x0801df75

0801ded4 <state_await_toolchanged>:

/*! /brief Waits for tool change cycle to end then restarts the cycle.
 */
static void state_await_toolchanged (uint_fast16_t rt_exec)
{
 801ded4:	b580      	push	{r7, lr}
 801ded6:	b082      	sub	sp, #8
 801ded8:	af00      	add	r7, sp, #0
 801deda:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_CYCLE_START) {
 801dedc:	687b      	ldr	r3, [r7, #4]
 801dede:	f003 0302 	and.w	r3, r3, #2
 801dee2:	2b00      	cmp	r3, #0
 801dee4:	d037      	beq.n	801df56 <state_await_toolchanged+0x82>
        if (!gc_state.tool_change) {
 801dee6:	4b1e      	ldr	r3, [pc, #120]	; (801df60 <state_await_toolchanged+0x8c>)
 801dee8:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801deec:	f083 0301 	eor.w	r3, r3, #1
 801def0:	b2db      	uxtb	r3, r3
 801def2:	2b00      	cmp	r3, #0
 801def4:	d019      	beq.n	801df2a <state_await_toolchanged+0x56>

            if (hal.stream.suspend_read)
 801def6:	4b1b      	ldr	r3, [pc, #108]	; (801df64 <state_await_toolchanged+0x90>)
 801def8:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801defc:	2b00      	cmp	r3, #0
 801defe:	d004      	beq.n	801df0a <state_await_toolchanged+0x36>
                hal.stream.suspend_read(false); // Tool change complete, restore "normal" stream input.
 801df00:	4b18      	ldr	r3, [pc, #96]	; (801df64 <state_await_toolchanged+0x90>)
 801df02:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 801df06:	2000      	movs	r0, #0
 801df08:	4798      	blx	r3

            if(grbl.on_tool_changed)
 801df0a:	4b17      	ldr	r3, [pc, #92]	; (801df68 <state_await_toolchanged+0x94>)
 801df0c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801df10:	2b00      	cmp	r3, #0
 801df12:	d007      	beq.n	801df24 <state_await_toolchanged+0x50>
                grbl.on_tool_changed(gc_state.tool);
 801df14:	4b14      	ldr	r3, [pc, #80]	; (801df68 <state_await_toolchanged+0x94>)
 801df16:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 801df1a:	4a11      	ldr	r2, [pc, #68]	; (801df60 <state_await_toolchanged+0x8c>)
 801df1c:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 801df20:	4610      	mov	r0, r2
 801df22:	4798      	blx	r3

            system_add_rt_report(Report_Tool);
 801df24:	2080      	movs	r0, #128	; 0x80
 801df26:	f004 f839 	bl	8021f9c <system_add_rt_report>
        }
        pending_state = gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE;
 801df2a:	4b0d      	ldr	r3, [pc, #52]	; (801df60 <state_await_toolchanged+0x8c>)
 801df2c:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801df30:	2b00      	cmp	r3, #0
 801df32:	d002      	beq.n	801df3a <state_await_toolchanged+0x66>
 801df34:	f44f 7300 	mov.w	r3, #512	; 0x200
 801df38:	e000      	b.n	801df3c <state_await_toolchanged+0x68>
 801df3a:	2300      	movs	r3, #0
 801df3c:	4a0b      	ldr	r2, [pc, #44]	; (801df6c <state_await_toolchanged+0x98>)
 801df3e:	6013      	str	r3, [r2, #0]
        state_set(STATE_IDLE);
 801df40:	2000      	movs	r0, #0
 801df42:	f7ff fcc7 	bl	801d8d4 <state_set>
        state_set(STATE_CYCLE);
 801df46:	2008      	movs	r0, #8
 801df48:	f7ff fcc4 	bl	801d8d4 <state_set>
        // Force a status report to let the sender know tool change is completed.
        system_set_exec_state_flag(EXEC_STATUS_REPORT);
 801df4c:	4b05      	ldr	r3, [pc, #20]	; (801df64 <state_await_toolchanged+0x90>)
 801df4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801df50:	2101      	movs	r1, #1
 801df52:	4807      	ldr	r0, [pc, #28]	; (801df70 <state_await_toolchanged+0x9c>)
 801df54:	4798      	blx	r3
    }
}
 801df56:	bf00      	nop
 801df58:	3708      	adds	r7, #8
 801df5a:	46bd      	mov	sp, r7
 801df5c:	bd80      	pop	{r7, pc}
 801df5e:	bf00      	nop
 801df60:	20000bb0 	.word	0x20000bb0
 801df64:	20000ed0 	.word	0x20000ed0
 801df68:	20000dd4 	.word	0x20000dd4
 801df6c:	200017c0 	.word	0x200017c0
 801df70:	20000d84 	.word	0x20000d84

0801df74 <state_await_motion_cancel>:

/*! /brief Waits for motion to end to complete then executes actions depending on the current sys_state.
 */
static void state_await_motion_cancel (uint_fast16_t rt_exec)
{
 801df74:	b580      	push	{r7, lr}
 801df76:	b082      	sub	sp, #8
 801df78:	af00      	add	r7, sp, #0
 801df7a:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801df7c:	687b      	ldr	r3, [r7, #4]
 801df7e:	f003 0304 	and.w	r3, r3, #4
 801df82:	2b00      	cmp	r3, #0
 801df84:	d021      	beq.n	801dfca <state_await_motion_cancel+0x56>
        if (sys_state == STATE_JOG) {
 801df86:	4b13      	ldr	r3, [pc, #76]	; (801dfd4 <state_await_motion_cancel+0x60>)
 801df88:	681b      	ldr	r3, [r3, #0]
 801df8a:	2b20      	cmp	r3, #32
 801df8c:	d10f      	bne.n	801dfae <state_await_motion_cancel+0x3a>
            sys.step_control.flags = 0;
 801df8e:	4b12      	ldr	r3, [pc, #72]	; (801dfd8 <state_await_motion_cancel+0x64>)
 801df90:	2200      	movs	r2, #0
 801df92:	761a      	strb	r2, [r3, #24]
            plan_reset();
 801df94:	f7f3 fbc4 	bl	8011720 <plan_reset>
            st_reset();
 801df98:	f001 f806 	bl	801efa8 <st_reset>
            sync_position();
 801df9c:	f7f4 f922 	bl	80121e4 <plan_sync_position>
 801dfa0:	490e      	ldr	r1, [pc, #56]	; (801dfdc <state_await_motion_cancel+0x68>)
 801dfa2:	480f      	ldr	r0, [pc, #60]	; (801dfe0 <state_await_motion_cancel+0x6c>)
 801dfa4:	f003 ff34 	bl	8021e10 <system_convert_array_steps_to_mpos>
            sys.suspend = false;
 801dfa8:	4b0b      	ldr	r3, [pc, #44]	; (801dfd8 <state_await_motion_cancel+0x64>)
 801dfaa:	2200      	movs	r2, #0
 801dfac:	709a      	strb	r2, [r3, #2]
        }
        state_set(pending_state);
 801dfae:	4b0d      	ldr	r3, [pc, #52]	; (801dfe4 <state_await_motion_cancel+0x70>)
 801dfb0:	681b      	ldr	r3, [r3, #0]
 801dfb2:	4618      	mov	r0, r3
 801dfb4:	f7ff fc8e 	bl	801d8d4 <state_set>
        if (gc_state.tool_change)
 801dfb8:	4b0b      	ldr	r3, [pc, #44]	; (801dfe8 <state_await_motion_cancel+0x74>)
 801dfba:	f893 3073 	ldrb.w	r3, [r3, #115]	; 0x73
 801dfbe:	2b00      	cmp	r3, #0
 801dfc0:	d003      	beq.n	801dfca <state_await_motion_cancel+0x56>
            state_set(STATE_TOOL_CHANGE);
 801dfc2:	f44f 7000 	mov.w	r0, #512	; 0x200
 801dfc6:	f7ff fc85 	bl	801d8d4 <state_set>
    }
}
 801dfca:	bf00      	nop
 801dfcc:	3708      	adds	r7, #8
 801dfce:	46bd      	mov	sp, r7
 801dfd0:	bd80      	pop	{r7, pc}
 801dfd2:	bf00      	nop
 801dfd4:	200017c4 	.word	0x200017c4
 801dfd8:	20000d3c 	.word	0x20000d3c
 801dfdc:	20000dc4 	.word	0x20000dc4
 801dfe0:	20000c0c 	.word	0x20000c0c
 801dfe4:	200017c0 	.word	0x200017c0
 801dfe8:	20000bb0 	.word	0x20000bb0

0801dfec <state_await_hold>:

/*! /brief Waits for feed hold to complete then executes actions depending on the current sys_state.
 */
static void state_await_hold (uint_fast16_t rt_exec)
{
 801dfec:	b590      	push	{r4, r7, lr}
 801dfee:	b085      	sub	sp, #20
 801dff0:	af00      	add	r7, sp, #0
 801dff2:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801dff4:	687b      	ldr	r3, [r7, #4]
 801dff6:	f003 0304 	and.w	r3, r3, #4
 801dffa:	2b00      	cmp	r3, #0
 801dffc:	f000 819d 	beq.w	801e33a <state_await_hold+0x34e>

        bool handler_changed = false;
 801e000:	2300      	movs	r3, #0
 801e002:	73fb      	strb	r3, [r7, #15]

        plan_cycle_reinitialize();
 801e004:	f7f4 f92c 	bl	8012260 <plan_cycle_reinitialize>
        sys.step_control.flags = 0;
 801e008:	4ba0      	ldr	r3, [pc, #640]	; (801e28c <state_await_hold+0x2a0>)
 801e00a:	2200      	movs	r2, #0
 801e00c:	761a      	strb	r2, [r3, #24]

        if (sys.alarm_pending) {
 801e00e:	4b9f      	ldr	r3, [pc, #636]	; (801e28c <state_await_hold+0x2a0>)
 801e010:	7d1b      	ldrb	r3, [r3, #20]
 801e012:	2b00      	cmp	r3, #0
 801e014:	d009      	beq.n	801e02a <state_await_hold+0x3e>
            system_set_exec_alarm(sys.alarm_pending);
 801e016:	4b9e      	ldr	r3, [pc, #632]	; (801e290 <state_await_hold+0x2a4>)
 801e018:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801e01a:	4a9c      	ldr	r2, [pc, #624]	; (801e28c <state_await_hold+0x2a0>)
 801e01c:	7d12      	ldrb	r2, [r2, #20]
 801e01e:	4611      	mov	r1, r2
 801e020:	489c      	ldr	r0, [pc, #624]	; (801e294 <state_await_hold+0x2a8>)
 801e022:	4798      	blx	r3
            sys.alarm_pending = Alarm_None;
 801e024:	4b99      	ldr	r3, [pc, #612]	; (801e28c <state_await_hold+0x2a0>)
 801e026:	2200      	movs	r2, #0
 801e028:	751a      	strb	r2, [r3, #20]
        }

        switch (sys_state) {
 801e02a:	4b9b      	ldr	r3, [pc, #620]	; (801e298 <state_await_hold+0x2ac>)
 801e02c:	681b      	ldr	r3, [r3, #0]
 801e02e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e032:	d008      	beq.n	801e046 <state_await_hold+0x5a>
 801e034:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e038:	f200 8166 	bhi.w	801e308 <state_await_hold+0x31c>
 801e03c:	2b40      	cmp	r3, #64	; 0x40
 801e03e:	d00a      	beq.n	801e056 <state_await_hold+0x6a>
 801e040:	2b80      	cmp	r3, #128	; 0x80
 801e042:	d008      	beq.n	801e056 <state_await_hold+0x6a>
                    sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
                }
                break;

            default:
                break;
 801e044:	e160      	b.n	801e308 <state_await_hold+0x31c>
                spindle_all_off(); // De-energize
 801e046:	f7ff f843 	bl	801d0d0 <spindle_all_off>
                hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e04a:	4b91      	ldr	r3, [pc, #580]	; (801e290 <state_await_hold+0x2a4>)
 801e04c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e04e:	2200      	movs	r2, #0
 801e050:	4610      	mov	r0, r2
 801e052:	4798      	blx	r3
                break;
 801e054:	e159      	b.n	801e30a <state_await_hold+0x31e>
                sys.override.spindle_stop.value = 0;
 801e056:	4b8d      	ldr	r3, [pc, #564]	; (801e28c <state_await_hold+0x2a0>)
 801e058:	2200      	movs	r2, #0
 801e05a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
                if (settings.parking.flags.enabled && !sys.override.control.parking_disable && settings.mode != Mode_Laser) {
 801e05e:	4b8f      	ldr	r3, [pc, #572]	; (801e29c <state_await_hold+0x2b0>)
 801e060:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e064:	f003 0301 	and.w	r3, r3, #1
 801e068:	b2db      	uxtb	r3, r3
 801e06a:	2b00      	cmp	r3, #0
 801e06c:	f000 8126 	beq.w	801e2bc <state_await_hold+0x2d0>
 801e070:	4b86      	ldr	r3, [pc, #536]	; (801e28c <state_await_hold+0x2a0>)
 801e072:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801e076:	f003 0308 	and.w	r3, r3, #8
 801e07a:	b2db      	uxtb	r3, r3
 801e07c:	2b00      	cmp	r3, #0
 801e07e:	f040 811d 	bne.w	801e2bc <state_await_hold+0x2d0>
 801e082:	4b86      	ldr	r3, [pc, #536]	; (801e29c <state_await_hold+0x2b0>)
 801e084:	7e1b      	ldrb	r3, [r3, #24]
 801e086:	2b01      	cmp	r3, #1
 801e088:	f000 8118 	beq.w	801e2bc <state_await_hold+0x2d0>
                    if (!park.flags.active) {
 801e08c:	4b84      	ldr	r3, [pc, #528]	; (801e2a0 <state_await_hold+0x2b4>)
 801e08e:	7f1b      	ldrb	r3, [r3, #28]
 801e090:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801e094:	b2db      	uxtb	r3, r3
 801e096:	2b00      	cmp	r3, #0
 801e098:	d108      	bne.n	801e0ac <state_await_hold+0xc0>
                        park.flags.active = On;
 801e09a:	4a81      	ldr	r2, [pc, #516]	; (801e2a0 <state_await_hold+0x2b4>)
 801e09c:	7f13      	ldrb	r3, [r2, #28]
 801e09e:	f043 0301 	orr.w	r3, r3, #1
 801e0a2:	7713      	strb	r3, [r2, #28]
                        system_convert_array_steps_to_mpos(park.restore_target, sys.position);
 801e0a4:	497f      	ldr	r1, [pc, #508]	; (801e2a4 <state_await_hold+0x2b8>)
 801e0a6:	4880      	ldr	r0, [pc, #512]	; (801e2a8 <state_await_hold+0x2bc>)
 801e0a8:	f003 feb2 	bl	8021e10 <system_convert_array_steps_to_mpos>
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.restore_target[settings.parking.axis] < settings.parking.target)) {
 801e0ac:	4b77      	ldr	r3, [pc, #476]	; (801e28c <state_await_hold+0x2a0>)
 801e0ae:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 801e0b2:	461a      	mov	r2, r3
 801e0b4:	4b79      	ldr	r3, [pc, #484]	; (801e29c <state_await_hold+0x2b0>)
 801e0b6:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e0ba:	fa22 f303 	lsr.w	r3, r2, r3
 801e0be:	f003 0301 	and.w	r3, r3, #1
 801e0c2:	2b00      	cmp	r3, #0
 801e0c4:	f000 80ba 	beq.w	801e23c <state_await_hold+0x250>
 801e0c8:	4b74      	ldr	r3, [pc, #464]	; (801e29c <state_await_hold+0x2b0>)
 801e0ca:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e0ce:	4a74      	ldr	r2, [pc, #464]	; (801e2a0 <state_await_hold+0x2b4>)
 801e0d0:	3302      	adds	r3, #2
 801e0d2:	009b      	lsls	r3, r3, #2
 801e0d4:	4413      	add	r3, r2
 801e0d6:	685b      	ldr	r3, [r3, #4]
 801e0d8:	4a70      	ldr	r2, [pc, #448]	; (801e29c <state_await_hold+0x2b0>)
 801e0da:	f8d2 212c 	ldr.w	r2, [r2, #300]	; 0x12c
 801e0de:	4611      	mov	r1, r2
 801e0e0:	4618      	mov	r0, r3
 801e0e2:	f7e3 f805 	bl	80010f0 <__aeabi_fcmplt>
 801e0e6:	4603      	mov	r3, r0
 801e0e8:	2b00      	cmp	r3, #0
 801e0ea:	f000 80a7 	beq.w	801e23c <state_await_hold+0x250>
                        handler_changed = true;
 801e0ee:	2301      	movs	r3, #1
 801e0f0:	73fb      	strb	r3, [r7, #15]
                        stateHandler = state_await_waypoint_retract;
 801e0f2:	4b6e      	ldr	r3, [pc, #440]	; (801e2ac <state_await_hold+0x2c0>)
 801e0f4:	4a6e      	ldr	r2, [pc, #440]	; (801e2b0 <state_await_hold+0x2c4>)
 801e0f6:	601a      	str	r2, [r3, #0]
                        if(park.flags.restart)
 801e0f8:	4b69      	ldr	r3, [pc, #420]	; (801e2a0 <state_await_hold+0x2b4>)
 801e0fa:	7f1b      	ldrb	r3, [r3, #28]
 801e0fc:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801e100:	b2db      	uxtb	r3, r3
 801e102:	2b00      	cmp	r3, #0
 801e104:	d004      	beq.n	801e110 <state_await_hold+0x124>
                            system_convert_array_steps_to_mpos(park.target, sys.position);
 801e106:	4967      	ldr	r1, [pc, #412]	; (801e2a4 <state_await_hold+0x2b8>)
 801e108:	4865      	ldr	r0, [pc, #404]	; (801e2a0 <state_await_hold+0x2b4>)
 801e10a:	f003 fe81 	bl	8021e10 <system_convert_array_steps_to_mpos>
 801e10e:	e02d      	b.n	801e16c <state_await_hold+0x180>
                            memcpy(park.target, park.restore_target, sizeof(park.target));
 801e110:	4a63      	ldr	r2, [pc, #396]	; (801e2a0 <state_await_hold+0x2b4>)
 801e112:	4b63      	ldr	r3, [pc, #396]	; (801e2a0 <state_await_hold+0x2b4>)
 801e114:	4614      	mov	r4, r2
 801e116:	330c      	adds	r3, #12
 801e118:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 801e11c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                            park.retract_waypoint = settings.parking.pullout_increment + park.target[settings.parking.axis];
 801e120:	4b5e      	ldr	r3, [pc, #376]	; (801e29c <state_await_hold+0x2b0>)
 801e122:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
 801e126:	4a5d      	ldr	r2, [pc, #372]	; (801e29c <state_await_hold+0x2b0>)
 801e128:	f892 2129 	ldrb.w	r2, [r2, #297]	; 0x129
 801e12c:	4611      	mov	r1, r2
 801e12e:	4a5c      	ldr	r2, [pc, #368]	; (801e2a0 <state_await_hold+0x2b4>)
 801e130:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 801e134:	4611      	mov	r1, r2
 801e136:	4618      	mov	r0, r3
 801e138:	f7e2 fd34 	bl	8000ba4 <__addsf3>
 801e13c:	4603      	mov	r3, r0
 801e13e:	461a      	mov	r2, r3
 801e140:	4b57      	ldr	r3, [pc, #348]	; (801e2a0 <state_await_hold+0x2b4>)
 801e142:	619a      	str	r2, [r3, #24]
                            park.retract_waypoint = min(park.retract_waypoint, settings.parking.target);
 801e144:	4b56      	ldr	r3, [pc, #344]	; (801e2a0 <state_await_hold+0x2b4>)
 801e146:	699b      	ldr	r3, [r3, #24]
 801e148:	4a54      	ldr	r2, [pc, #336]	; (801e29c <state_await_hold+0x2b0>)
 801e14a:	f8d2 212c 	ldr.w	r2, [r2, #300]	; 0x12c
 801e14e:	4611      	mov	r1, r2
 801e150:	4618      	mov	r0, r3
 801e152:	f7e2 ffcd 	bl	80010f0 <__aeabi_fcmplt>
 801e156:	4603      	mov	r3, r0
 801e158:	2b00      	cmp	r3, #0
 801e15a:	d002      	beq.n	801e162 <state_await_hold+0x176>
 801e15c:	4b50      	ldr	r3, [pc, #320]	; (801e2a0 <state_await_hold+0x2b4>)
 801e15e:	699b      	ldr	r3, [r3, #24]
 801e160:	e002      	b.n	801e168 <state_await_hold+0x17c>
 801e162:	4b4e      	ldr	r3, [pc, #312]	; (801e29c <state_await_hold+0x2b0>)
 801e164:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
 801e168:	4a4d      	ldr	r2, [pc, #308]	; (801e2a0 <state_await_hold+0x2b4>)
 801e16a:	6193      	str	r3, [r2, #24]
                        if ((await_motion = park.target[settings.parking.axis] < park.retract_waypoint)) {
 801e16c:	4b4b      	ldr	r3, [pc, #300]	; (801e29c <state_await_hold+0x2b0>)
 801e16e:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e172:	461a      	mov	r2, r3
 801e174:	4b4a      	ldr	r3, [pc, #296]	; (801e2a0 <state_await_hold+0x2b4>)
 801e176:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801e17a:	4a49      	ldr	r2, [pc, #292]	; (801e2a0 <state_await_hold+0x2b4>)
 801e17c:	6992      	ldr	r2, [r2, #24]
 801e17e:	2101      	movs	r1, #1
 801e180:	460c      	mov	r4, r1
 801e182:	4611      	mov	r1, r2
 801e184:	4618      	mov	r0, r3
 801e186:	f7e2 ffb3 	bl	80010f0 <__aeabi_fcmplt>
 801e18a:	4603      	mov	r3, r0
 801e18c:	2b00      	cmp	r3, #0
 801e18e:	d101      	bne.n	801e194 <state_await_hold+0x1a8>
 801e190:	2300      	movs	r3, #0
 801e192:	461c      	mov	r4, r3
 801e194:	73bc      	strb	r4, [r7, #14]
 801e196:	7bbb      	ldrb	r3, [r7, #14]
 801e198:	2b00      	cmp	r3, #0
 801e19a:	d037      	beq.n	801e20c <state_await_hold+0x220>
                            park.target[settings.parking.axis] = park.retract_waypoint;
 801e19c:	4b3f      	ldr	r3, [pc, #252]	; (801e29c <state_await_hold+0x2b0>)
 801e19e:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e1a2:	4619      	mov	r1, r3
 801e1a4:	4b3e      	ldr	r3, [pc, #248]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1a6:	699b      	ldr	r3, [r3, #24]
 801e1a8:	4a3d      	ldr	r2, [pc, #244]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1aa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 801e1ae:	4b3b      	ldr	r3, [pc, #236]	; (801e29c <state_await_hold+0x2b0>)
 801e1b0:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 801e1b4:	4a3a      	ldr	r2, [pc, #232]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1b6:	6213      	str	r3, [r2, #32]
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 801e1b8:	4a39      	ldr	r2, [pc, #228]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1ba:	4b3e      	ldr	r3, [pc, #248]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1bc:	781b      	ldrb	r3, [r3, #0]
 801e1be:	f882 303a 	strb.w	r3, [r2, #58]	; 0x3a
                            park.plan_data.spindle.state = restore_condition.spindle[restore_condition.spindle_num].state; // Retain spindle state
 801e1c2:	4b3c      	ldr	r3, [pc, #240]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1c4:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e1c8:	4a35      	ldr	r2, [pc, #212]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1ca:	493a      	ldr	r1, [pc, #232]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1cc:	011b      	lsls	r3, r3, #4
 801e1ce:	440b      	add	r3, r1
 801e1d0:	3308      	adds	r3, #8
 801e1d2:	781b      	ldrb	r3, [r3, #0]
 801e1d4:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
                            park.plan_data.spindle.hal = restore_condition.spindle[restore_condition.spindle_num].hal;
 801e1d8:	4b36      	ldr	r3, [pc, #216]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1da:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e1de:	4a35      	ldr	r2, [pc, #212]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1e0:	011b      	lsls	r3, r3, #4
 801e1e2:	4413      	add	r3, r2
 801e1e4:	3310      	adds	r3, #16
 801e1e6:	681b      	ldr	r3, [r3, #0]
 801e1e8:	4a2d      	ldr	r2, [pc, #180]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1ea:	6353      	str	r3, [r2, #52]	; 0x34
                            park.plan_data.spindle.rpm = restore_condition.spindle[restore_condition.spindle_num].rpm;
 801e1ec:	4b31      	ldr	r3, [pc, #196]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1ee:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e1f2:	4a30      	ldr	r2, [pc, #192]	; (801e2b4 <state_await_hold+0x2c8>)
 801e1f4:	011b      	lsls	r3, r3, #4
 801e1f6:	4413      	add	r3, r2
 801e1f8:	3304      	adds	r3, #4
 801e1fa:	681b      	ldr	r3, [r3, #0]
 801e1fc:	4a28      	ldr	r2, [pc, #160]	; (801e2a0 <state_await_hold+0x2b4>)
 801e1fe:	6293      	str	r3, [r2, #40]	; 0x28
                            await_motion = mc_parking_motion(park.target, &park.plan_data);
 801e200:	492d      	ldr	r1, [pc, #180]	; (801e2b8 <state_await_hold+0x2cc>)
 801e202:	4827      	ldr	r0, [pc, #156]	; (801e2a0 <state_await_hold+0x2b4>)
 801e204:	f7f1 fa2c 	bl	800f660 <mc_parking_motion>
 801e208:	4603      	mov	r3, r0
 801e20a:	73bb      	strb	r3, [r7, #14]
                        if(!park.flags.restart)
 801e20c:	4b24      	ldr	r3, [pc, #144]	; (801e2a0 <state_await_hold+0x2b4>)
 801e20e:	7f1b      	ldrb	r3, [r3, #28]
 801e210:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801e214:	b2db      	uxtb	r3, r3
 801e216:	2b00      	cmp	r3, #0
 801e218:	d105      	bne.n	801e226 <state_await_hold+0x23a>
                            park.flags.motion = await_motion;
 801e21a:	4a21      	ldr	r2, [pc, #132]	; (801e2a0 <state_await_hold+0x2b4>)
 801e21c:	7f13      	ldrb	r3, [r2, #28]
 801e21e:	7bb9      	ldrb	r1, [r7, #14]
 801e220:	f361 0341 	bfi	r3, r1, #1, #1
 801e224:	7713      	strb	r3, [r2, #28]
                        if (!await_motion)
 801e226:	7bbb      	ldrb	r3, [r7, #14]
 801e228:	f083 0301 	eor.w	r3, r3, #1
 801e22c:	b2db      	uxtb	r3, r3
 801e22e:	2b00      	cmp	r3, #0
 801e230:	d029      	beq.n	801e286 <state_await_hold+0x29a>
                            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step immediately.
 801e232:	4b1e      	ldr	r3, [pc, #120]	; (801e2ac <state_await_hold+0x2c0>)
 801e234:	681b      	ldr	r3, [r3, #0]
 801e236:	2004      	movs	r0, #4
 801e238:	4798      	blx	r3
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.restore_target[settings.parking.axis] < settings.parking.target)) {
 801e23a:	e024      	b.n	801e286 <state_await_hold+0x29a>
                        spindle_all_off(); // De-energize
 801e23c:	f7fe ff48 	bl	801d0d0 <spindle_all_off>
                        if (!settings.safety_door.flags.keep_coolant_on || sys_state == STATE_SLEEP)
 801e240:	4b16      	ldr	r3, [pc, #88]	; (801e29c <state_await_hold+0x2b0>)
 801e242:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801e246:	f003 0302 	and.w	r3, r3, #2
 801e24a:	b2db      	uxtb	r3, r3
 801e24c:	2b00      	cmp	r3, #0
 801e24e:	d003      	beq.n	801e258 <state_await_hold+0x26c>
 801e250:	4b11      	ldr	r3, [pc, #68]	; (801e298 <state_await_hold+0x2ac>)
 801e252:	681b      	ldr	r3, [r3, #0]
 801e254:	2b80      	cmp	r3, #128	; 0x80
 801e256:	d104      	bne.n	801e262 <state_await_hold+0x276>
                            hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e258:	4b0d      	ldr	r3, [pc, #52]	; (801e290 <state_await_hold+0x2a4>)
 801e25a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e25c:	2200      	movs	r2, #0
 801e25e:	4610      	mov	r0, r2
 801e260:	4798      	blx	r3
                        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e262:	4b0b      	ldr	r3, [pc, #44]	; (801e290 <state_await_hold+0x2a4>)
 801e264:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e266:	4798      	blx	r3
 801e268:	4603      	mov	r3, r0
 801e26a:	b2db      	uxtb	r3, r3
 801e26c:	f003 0308 	and.w	r3, r3, #8
 801e270:	b2db      	uxtb	r3, r3
 801e272:	2b00      	cmp	r3, #0
 801e274:	bf14      	ite	ne
 801e276:	2301      	movne	r3, #1
 801e278:	2300      	moveq	r3, #0
 801e27a:	b2db      	uxtb	r3, r3
 801e27c:	461a      	mov	r2, r3
 801e27e:	4b03      	ldr	r3, [pc, #12]	; (801e28c <state_await_hold+0x2a0>)
 801e280:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.restore_target[settings.parking.axis] < settings.parking.target)) {
 801e284:	e03f      	b.n	801e306 <state_await_hold+0x31a>
 801e286:	bf00      	nop
 801e288:	e03d      	b.n	801e306 <state_await_hold+0x31a>
 801e28a:	bf00      	nop
 801e28c:	20000d3c 	.word	0x20000d3c
 801e290:	20000ed0 	.word	0x20000ed0
 801e294:	20000d88 	.word	0x20000d88
 801e298:	200017c4 	.word	0x200017c4
 801e29c:	2000147c 	.word	0x2000147c
 801e2a0:	200017c8 	.word	0x200017c8
 801e2a4:	20000dc4 	.word	0x20000dc4
 801e2a8:	200017d4 	.word	0x200017d4
 801e2ac:	20000394 	.word	0x20000394
 801e2b0:	0801e755 	.word	0x0801e755
 801e2b4:	200017ac 	.word	0x200017ac
 801e2b8:	200017e8 	.word	0x200017e8
                    spindle_all_off(); // De-energize
 801e2bc:	f7fe ff08 	bl	801d0d0 <spindle_all_off>
                    if (!settings.safety_door.flags.keep_coolant_on || sys_state == STATE_SLEEP)
 801e2c0:	4b20      	ldr	r3, [pc, #128]	; (801e344 <state_await_hold+0x358>)
 801e2c2:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801e2c6:	f003 0302 	and.w	r3, r3, #2
 801e2ca:	b2db      	uxtb	r3, r3
 801e2cc:	2b00      	cmp	r3, #0
 801e2ce:	d003      	beq.n	801e2d8 <state_await_hold+0x2ec>
 801e2d0:	4b1d      	ldr	r3, [pc, #116]	; (801e348 <state_await_hold+0x35c>)
 801e2d2:	681b      	ldr	r3, [r3, #0]
 801e2d4:	2b80      	cmp	r3, #128	; 0x80
 801e2d6:	d104      	bne.n	801e2e2 <state_await_hold+0x2f6>
                        hal.coolant.set_state((coolant_state_t){0}); // De-energize
 801e2d8:	4b1c      	ldr	r3, [pc, #112]	; (801e34c <state_await_hold+0x360>)
 801e2da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e2dc:	2200      	movs	r2, #0
 801e2de:	4610      	mov	r0, r2
 801e2e0:	4798      	blx	r3
                    sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e2e2:	4b1a      	ldr	r3, [pc, #104]	; (801e34c <state_await_hold+0x360>)
 801e2e4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e2e6:	4798      	blx	r3
 801e2e8:	4603      	mov	r3, r0
 801e2ea:	b2db      	uxtb	r3, r3
 801e2ec:	f003 0308 	and.w	r3, r3, #8
 801e2f0:	b2db      	uxtb	r3, r3
 801e2f2:	2b00      	cmp	r3, #0
 801e2f4:	bf14      	ite	ne
 801e2f6:	2301      	movne	r3, #1
 801e2f8:	2300      	moveq	r3, #0
 801e2fa:	b2db      	uxtb	r3, r3
 801e2fc:	461a      	mov	r2, r3
 801e2fe:	4b14      	ldr	r3, [pc, #80]	; (801e350 <state_await_hold+0x364>)
 801e300:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
                break;
 801e304:	e001      	b.n	801e30a <state_await_hold+0x31e>
 801e306:	e000      	b.n	801e30a <state_await_hold+0x31e>
                break;
 801e308:	bf00      	nop
        }

        if (!handler_changed) {
 801e30a:	7bfb      	ldrb	r3, [r7, #15]
 801e30c:	f083 0301 	eor.w	r3, r3, #1
 801e310:	b2db      	uxtb	r3, r3
 801e312:	2b00      	cmp	r3, #0
 801e314:	d011      	beq.n	801e33a <state_await_hold+0x34e>
            if(sys.flags.soft_limit)
 801e316:	4b0e      	ldr	r3, [pc, #56]	; (801e350 <state_await_hold+0x364>)
 801e318:	7d9b      	ldrb	r3, [r3, #22]
 801e31a:	f003 0304 	and.w	r3, r3, #4
 801e31e:	b2db      	uxtb	r3, r3
 801e320:	2b00      	cmp	r3, #0
 801e322:	d003      	beq.n	801e32c <state_await_hold+0x340>
                state_set(STATE_IDLE);
 801e324:	2000      	movs	r0, #0
 801e326:	f7ff fad5 	bl	801d8d4 <state_set>
                sys.holding_state = Hold_Complete;
                stateHandler = state_await_resume;
            }
        }
    }
}
 801e32a:	e006      	b.n	801e33a <state_await_hold+0x34e>
                sys.holding_state = Hold_Complete;
 801e32c:	4b08      	ldr	r3, [pc, #32]	; (801e350 <state_await_hold+0x364>)
 801e32e:	2201      	movs	r2, #1
 801e330:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
                stateHandler = state_await_resume;
 801e334:	4b07      	ldr	r3, [pc, #28]	; (801e354 <state_await_hold+0x368>)
 801e336:	4a08      	ldr	r2, [pc, #32]	; (801e358 <state_await_hold+0x36c>)
 801e338:	601a      	str	r2, [r3, #0]
}
 801e33a:	bf00      	nop
 801e33c:	3714      	adds	r7, #20
 801e33e:	46bd      	mov	sp, r7
 801e340:	bd90      	pop	{r4, r7, pc}
 801e342:	bf00      	nop
 801e344:	2000147c 	.word	0x2000147c
 801e348:	200017c4 	.word	0x200017c4
 801e34c:	20000ed0 	.word	0x20000ed0
 801e350:	20000d3c 	.word	0x20000d3c
 801e354:	20000394 	.word	0x20000394
 801e358:	0801e35d 	.word	0x0801e35d

0801e35c <state_await_resume>:

/*! /brief Waits for action to execute when in feed hold state.
 */
static void state_await_resume (uint_fast16_t rt_exec)
{
 801e35c:	b590      	push	{r4, r7, lr}
 801e35e:	b089      	sub	sp, #36	; 0x24
 801e360:	af00      	add	r7, sp, #0
 801e362:	6078      	str	r0, [r7, #4]
    if ((rt_exec & EXEC_CYCLE_COMPLETE) && settings.parking.flags.enabled) {
 801e364:	687b      	ldr	r3, [r7, #4]
 801e366:	f003 0304 	and.w	r3, r3, #4
 801e36a:	2b00      	cmp	r3, #0
 801e36c:	d02d      	beq.n	801e3ca <state_await_resume+0x6e>
 801e36e:	4ba8      	ldr	r3, [pc, #672]	; (801e610 <state_await_resume+0x2b4>)
 801e370:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801e374:	f003 0301 	and.w	r3, r3, #1
 801e378:	b2db      	uxtb	r3, r3
 801e37a:	2b00      	cmp	r3, #0
 801e37c:	d025      	beq.n	801e3ca <state_await_resume+0x6e>
        if (sys.step_control.execute_sys_motion) {
 801e37e:	4ba5      	ldr	r3, [pc, #660]	; (801e614 <state_await_resume+0x2b8>)
 801e380:	7e1b      	ldrb	r3, [r3, #24]
 801e382:	f003 0304 	and.w	r3, r3, #4
 801e386:	b2db      	uxtb	r3, r3
 801e388:	2b00      	cmp	r3, #0
 801e38a:	d006      	beq.n	801e39a <state_await_resume+0x3e>
            sys.step_control.execute_sys_motion = Off;
 801e38c:	4aa1      	ldr	r2, [pc, #644]	; (801e614 <state_await_resume+0x2b8>)
 801e38e:	7e13      	ldrb	r3, [r2, #24]
 801e390:	f36f 0382 	bfc	r3, #2, #1
 801e394:	7613      	strb	r3, [r2, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e396:	f000 ff53 	bl	801f240 <st_parking_restore_buffer>
        }
        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e39a:	4b9f      	ldr	r3, [pc, #636]	; (801e618 <state_await_resume+0x2bc>)
 801e39c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e39e:	4798      	blx	r3
 801e3a0:	4603      	mov	r3, r0
 801e3a2:	b2db      	uxtb	r3, r3
 801e3a4:	f003 0308 	and.w	r3, r3, #8
 801e3a8:	b2db      	uxtb	r3, r3
 801e3aa:	2b00      	cmp	r3, #0
 801e3ac:	bf14      	ite	ne
 801e3ae:	2301      	movne	r3, #1
 801e3b0:	2300      	moveq	r3, #0
 801e3b2:	b2db      	uxtb	r3, r3
 801e3b4:	461a      	mov	r2, r3
 801e3b6:	4b97      	ldr	r3, [pc, #604]	; (801e614 <state_await_resume+0x2b8>)
 801e3b8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        if(sys_state == STATE_SLEEP) {
 801e3bc:	4b97      	ldr	r3, [pc, #604]	; (801e61c <state_await_resume+0x2c0>)
 801e3be:	681b      	ldr	r3, [r3, #0]
 801e3c0:	2b80      	cmp	r3, #128	; 0x80
 801e3c2:	d102      	bne.n	801e3ca <state_await_resume+0x6e>
            enter_sleep();
 801e3c4:	f7ff f8f8 	bl	801d5b8 <enter_sleep>
            return;
 801e3c8:	e15d      	b.n	801e686 <state_await_resume+0x32a>
        }
    }

    if (rt_exec & EXEC_SLEEP)
 801e3ca:	687b      	ldr	r3, [r7, #4]
 801e3cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801e3d0:	2b00      	cmp	r3, #0
 801e3d2:	d002      	beq.n	801e3da <state_await_resume+0x7e>
        state_set(STATE_SLEEP);
 801e3d4:	2080      	movs	r0, #128	; 0x80
 801e3d6:	f7ff fa7d 	bl	801d8d4 <state_set>

    if (rt_exec & EXEC_SAFETY_DOOR)
 801e3da:	687b      	ldr	r3, [r7, #4]
 801e3dc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801e3e0:	2b00      	cmp	r3, #0
 801e3e2:	d011      	beq.n	801e408 <state_await_resume+0xac>
        sys.parking_state = hal.control.get_state().safety_door_ajar ? Parking_DoorAjar : Parking_DoorClosed;
 801e3e4:	4b8c      	ldr	r3, [pc, #560]	; (801e618 <state_await_resume+0x2bc>)
 801e3e6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e3e8:	4798      	blx	r3
 801e3ea:	4603      	mov	r3, r0
 801e3ec:	b2db      	uxtb	r3, r3
 801e3ee:	f003 0308 	and.w	r3, r3, #8
 801e3f2:	b2db      	uxtb	r3, r3
 801e3f4:	2b00      	cmp	r3, #0
 801e3f6:	bf14      	ite	ne
 801e3f8:	2301      	movne	r3, #1
 801e3fa:	2300      	moveq	r3, #0
 801e3fc:	b2db      	uxtb	r3, r3
 801e3fe:	461a      	mov	r2, r3
 801e400:	4b84      	ldr	r3, [pc, #528]	; (801e614 <state_await_resume+0x2b8>)
 801e402:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 801e406:	e13e      	b.n	801e686 <state_await_resume+0x32a>

    else if (rt_exec & EXEC_CYCLE_START) {
 801e408:	687b      	ldr	r3, [r7, #4]
 801e40a:	f003 0302 	and.w	r3, r3, #2
 801e40e:	2b00      	cmp	r3, #0
 801e410:	f000 8126 	beq.w	801e660 <state_await_resume+0x304>

        if (sys_state == STATE_HOLD && !sys.override.spindle_stop.value)
 801e414:	4b81      	ldr	r3, [pc, #516]	; (801e61c <state_await_resume+0x2c0>)
 801e416:	681b      	ldr	r3, [r3, #0]
 801e418:	2b10      	cmp	r3, #16
 801e41a:	d10b      	bne.n	801e434 <state_await_resume+0xd8>
 801e41c:	4b7d      	ldr	r3, [pc, #500]	; (801e614 <state_await_resume+0x2b8>)
 801e41e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801e422:	2b00      	cmp	r3, #0
 801e424:	d106      	bne.n	801e434 <state_await_resume+0xd8>
            sys.override.spindle_stop.restore_cycle = On;
 801e426:	4a7b      	ldr	r2, [pc, #492]	; (801e614 <state_await_resume+0x2b8>)
 801e428:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801e42c:	f043 0308 	orr.w	r3, r3, #8
 801e430:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28

        switch (sys_state) {
 801e434:	4b79      	ldr	r3, [pc, #484]	; (801e61c <state_await_resume+0x2c0>)
 801e436:	681b      	ldr	r3, [r3, #0]
 801e438:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e43c:	f000 80e4 	beq.w	801e608 <state_await_resume+0x2ac>
 801e440:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801e444:	d869      	bhi.n	801e51a <state_await_resume+0x1be>
 801e446:	2b40      	cmp	r3, #64	; 0x40
 801e448:	d003      	beq.n	801e452 <state_await_resume+0xf6>
 801e44a:	2b80      	cmp	r3, #128	; 0x80
 801e44c:	f000 80de 	beq.w	801e60c <state_await_resume+0x2b0>
 801e450:	e063      	b.n	801e51a <state_await_resume+0x1be>

            case STATE_SLEEP:
                break;

            case STATE_SAFETY_DOOR:
                if (park.flags.restart || !hal.control.get_state().safety_door_ajar) {
 801e452:	4b73      	ldr	r3, [pc, #460]	; (801e620 <state_await_resume+0x2c4>)
 801e454:	7f1b      	ldrb	r3, [r3, #28]
 801e456:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801e45a:	b2db      	uxtb	r3, r3
 801e45c:	2b00      	cmp	r3, #0
 801e45e:	d10a      	bne.n	801e476 <state_await_resume+0x11a>
 801e460:	4b6d      	ldr	r3, [pc, #436]	; (801e618 <state_await_resume+0x2bc>)
 801e462:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e464:	4798      	blx	r3
 801e466:	4603      	mov	r3, r0
 801e468:	b2db      	uxtb	r3, r3
 801e46a:	f003 0308 	and.w	r3, r3, #8
 801e46e:	b2db      	uxtb	r3, r3
 801e470:	2b00      	cmp	r3, #0
 801e472:	f040 80e1 	bne.w	801e638 <state_await_resume+0x2dc>

                    bool await_motion = false;
 801e476:	2300      	movs	r3, #0
 801e478:	77fb      	strb	r3, [r7, #31]
                    stateHandler = state_restore;
 801e47a:	4b6a      	ldr	r3, [pc, #424]	; (801e624 <state_await_resume+0x2c8>)
 801e47c:	4a6a      	ldr	r2, [pc, #424]	; (801e628 <state_await_resume+0x2cc>)
 801e47e:	601a      	str	r2, [r3, #0]
                    sys.parking_state = Parking_Resuming;
 801e480:	4b64      	ldr	r3, [pc, #400]	; (801e614 <state_await_resume+0x2b8>)
 801e482:	2204      	movs	r2, #4
 801e484:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

                    // Resume door state when parking motion has retracted and door has been closed.
                    if (park.flags.motion) {
 801e488:	4b65      	ldr	r3, [pc, #404]	; (801e620 <state_await_resume+0x2c4>)
 801e48a:	7f1b      	ldrb	r3, [r3, #28]
 801e48c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801e490:	b2db      	uxtb	r3, r3
 801e492:	2b00      	cmp	r3, #0
 801e494:	d035      	beq.n	801e502 <state_await_resume+0x1a6>

                        park.flags.restart = Off;
 801e496:	4a62      	ldr	r2, [pc, #392]	; (801e620 <state_await_resume+0x2c4>)
 801e498:	7f13      	ldrb	r3, [r2, #28]
 801e49a:	f36f 0382 	bfc	r3, #2, #1
 801e49e:	7713      	strb	r3, [r2, #28]

                        // Execute fast restore motion to the pull-out position.
                        // Check to ensure the motion doesn't move below pull-out position.
                        if (park.restore_target[settings.parking.axis] <= settings.parking.target) {
 801e4a0:	4b5b      	ldr	r3, [pc, #364]	; (801e610 <state_await_resume+0x2b4>)
 801e4a2:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e4a6:	4a5e      	ldr	r2, [pc, #376]	; (801e620 <state_await_resume+0x2c4>)
 801e4a8:	3302      	adds	r3, #2
 801e4aa:	009b      	lsls	r3, r3, #2
 801e4ac:	4413      	add	r3, r2
 801e4ae:	685b      	ldr	r3, [r3, #4]
 801e4b0:	4a57      	ldr	r2, [pc, #348]	; (801e610 <state_await_resume+0x2b4>)
 801e4b2:	f8d2 212c 	ldr.w	r2, [r2, #300]	; 0x12c
 801e4b6:	4611      	mov	r1, r2
 801e4b8:	4618      	mov	r0, r3
 801e4ba:	f7e2 fe23 	bl	8001104 <__aeabi_fcmple>
 801e4be:	4603      	mov	r3, r0
 801e4c0:	2b00      	cmp	r3, #0
 801e4c2:	d01e      	beq.n	801e502 <state_await_resume+0x1a6>
                            float target[N_AXIS];
                            memcpy(target, park.restore_target, sizeof(target));
 801e4c4:	4a56      	ldr	r2, [pc, #344]	; (801e620 <state_await_resume+0x2c4>)
 801e4c6:	f107 0310 	add.w	r3, r7, #16
 801e4ca:	320c      	adds	r2, #12
 801e4cc:	ca07      	ldmia	r2, {r0, r1, r2}
 801e4ce:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                            target[settings.parking.axis] = park.retract_waypoint;
 801e4d2:	4b4f      	ldr	r3, [pc, #316]	; (801e610 <state_await_resume+0x2b4>)
 801e4d4:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e4d8:	4619      	mov	r1, r3
 801e4da:	4b51      	ldr	r3, [pc, #324]	; (801e620 <state_await_resume+0x2c4>)
 801e4dc:	699a      	ldr	r2, [r3, #24]
 801e4de:	008b      	lsls	r3, r1, #2
 801e4e0:	3320      	adds	r3, #32
 801e4e2:	443b      	add	r3, r7
 801e4e4:	f843 2c10 	str.w	r2, [r3, #-16]
                            park.plan_data.feed_rate = settings.parking.rate;
 801e4e8:	4b49      	ldr	r3, [pc, #292]	; (801e610 <state_await_resume+0x2b4>)
 801e4ea:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 801e4ee:	4a4c      	ldr	r2, [pc, #304]	; (801e620 <state_await_resume+0x2c4>)
 801e4f0:	6213      	str	r3, [r2, #32]
                            await_motion = mc_parking_motion(target, &park.plan_data);
 801e4f2:	f107 0310 	add.w	r3, r7, #16
 801e4f6:	494d      	ldr	r1, [pc, #308]	; (801e62c <state_await_resume+0x2d0>)
 801e4f8:	4618      	mov	r0, r3
 801e4fa:	f7f1 f8b1 	bl	800f660 <mc_parking_motion>
 801e4fe:	4603      	mov	r3, r0
 801e500:	77fb      	strb	r3, [r7, #31]
                        }
                    }

                    if (!await_motion) // No motion, proceed to next step immediately.
 801e502:	7ffb      	ldrb	r3, [r7, #31]
 801e504:	f083 0301 	eor.w	r3, r3, #1
 801e508:	b2db      	uxtb	r3, r3
 801e50a:	2b00      	cmp	r3, #0
 801e50c:	f000 8094 	beq.w	801e638 <state_await_resume+0x2dc>
                        stateHandler(EXEC_CYCLE_COMPLETE);
 801e510:	4b44      	ldr	r3, [pc, #272]	; (801e624 <state_await_resume+0x2c8>)
 801e512:	681b      	ldr	r3, [r3, #0]
 801e514:	2004      	movs	r0, #4
 801e516:	4798      	blx	r3
                }
                break;
 801e518:	e08e      	b.n	801e638 <state_await_resume+0x2dc>

            default:
                if (!settings.flags.restore_after_feed_hold) {
 801e51a:	4b3d      	ldr	r3, [pc, #244]	; (801e610 <state_await_resume+0x2b4>)
 801e51c:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 801e520:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801e524:	b2db      	uxtb	r3, r3
 801e526:	2b00      	cmp	r3, #0
 801e528:	d120      	bne.n	801e56c <state_await_resume+0x210>
                    if (!restore_condition.spindle[restore_condition.spindle_num].hal->get_state(restore_condition.spindle[restore_condition.spindle_num].hal).on)
 801e52a:	4b41      	ldr	r3, [pc, #260]	; (801e630 <state_await_resume+0x2d4>)
 801e52c:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e530:	4a3f      	ldr	r2, [pc, #252]	; (801e630 <state_await_resume+0x2d4>)
 801e532:	011b      	lsls	r3, r3, #4
 801e534:	4413      	add	r3, r2
 801e536:	3310      	adds	r3, #16
 801e538:	681b      	ldr	r3, [r3, #0]
 801e53a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801e53c:	4a3c      	ldr	r2, [pc, #240]	; (801e630 <state_await_resume+0x2d4>)
 801e53e:	f992 2001 	ldrsb.w	r2, [r2, #1]
 801e542:	493b      	ldr	r1, [pc, #236]	; (801e630 <state_await_resume+0x2d4>)
 801e544:	0112      	lsls	r2, r2, #4
 801e546:	440a      	add	r2, r1
 801e548:	3210      	adds	r2, #16
 801e54a:	6812      	ldr	r2, [r2, #0]
 801e54c:	4610      	mov	r0, r2
 801e54e:	4798      	blx	r3
 801e550:	4603      	mov	r3, r0
 801e552:	b2db      	uxtb	r3, r3
 801e554:	f003 0301 	and.w	r3, r3, #1
 801e558:	b2db      	uxtb	r3, r3
 801e55a:	2b00      	cmp	r3, #0
 801e55c:	d101      	bne.n	801e562 <state_await_resume+0x206>
                        gc_spindle_off();
 801e55e:	f7e7 fc1d 	bl	8005d9c <gc_spindle_off>
                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801e562:	4b2c      	ldr	r3, [pc, #176]	; (801e614 <state_await_resume+0x2b8>)
 801e564:	2200      	movs	r2, #0
 801e566:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states

                    grbl.report.feedback_message(Message_None);
                }
                break;
 801e56a:	e066      	b.n	801e63a <state_await_resume+0x2de>
                    if (restore_condition.spindle[restore_condition.spindle_num].state.on != restore_condition.spindle[restore_condition.spindle_num].hal->get_state(restore_condition.spindle[restore_condition.spindle_num].hal).on) {
 801e56c:	4b30      	ldr	r3, [pc, #192]	; (801e630 <state_await_resume+0x2d4>)
 801e56e:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e572:	4a2f      	ldr	r2, [pc, #188]	; (801e630 <state_await_resume+0x2d4>)
 801e574:	011b      	lsls	r3, r3, #4
 801e576:	4413      	add	r3, r2
 801e578:	7a1b      	ldrb	r3, [r3, #8]
 801e57a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801e57e:	b2dc      	uxtb	r4, r3
 801e580:	4b2b      	ldr	r3, [pc, #172]	; (801e630 <state_await_resume+0x2d4>)
 801e582:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e586:	4a2a      	ldr	r2, [pc, #168]	; (801e630 <state_await_resume+0x2d4>)
 801e588:	011b      	lsls	r3, r3, #4
 801e58a:	4413      	add	r3, r2
 801e58c:	3310      	adds	r3, #16
 801e58e:	681b      	ldr	r3, [r3, #0]
 801e590:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801e592:	4a27      	ldr	r2, [pc, #156]	; (801e630 <state_await_resume+0x2d4>)
 801e594:	f992 2001 	ldrsb.w	r2, [r2, #1]
 801e598:	4925      	ldr	r1, [pc, #148]	; (801e630 <state_await_resume+0x2d4>)
 801e59a:	0112      	lsls	r2, r2, #4
 801e59c:	440a      	add	r2, r1
 801e59e:	3210      	adds	r2, #16
 801e5a0:	6812      	ldr	r2, [r2, #0]
 801e5a2:	4610      	mov	r0, r2
 801e5a4:	4798      	blx	r3
 801e5a6:	4603      	mov	r3, r0
 801e5a8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801e5ac:	b2db      	uxtb	r3, r3
 801e5ae:	429c      	cmp	r4, r3
 801e5b0:	d00d      	beq.n	801e5ce <state_await_resume+0x272>
                        grbl.report.feedback_message(Message_SpindleRestore);
 801e5b2:	4b20      	ldr	r3, [pc, #128]	; (801e634 <state_await_resume+0x2d8>)
 801e5b4:	68db      	ldr	r3, [r3, #12]
 801e5b6:	200a      	movs	r0, #10
 801e5b8:	4798      	blx	r3
                        state_spindle_restore(&restore_condition.spindle[restore_condition.spindle_num]);
 801e5ba:	4b1d      	ldr	r3, [pc, #116]	; (801e630 <state_await_resume+0x2d4>)
 801e5bc:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e5c0:	011b      	lsls	r3, r3, #4
 801e5c2:	4a1b      	ldr	r2, [pc, #108]	; (801e630 <state_await_resume+0x2d4>)
 801e5c4:	4413      	add	r3, r2
 801e5c6:	3304      	adds	r3, #4
 801e5c8:	4618      	mov	r0, r3
 801e5ca:	f7fe ff77 	bl	801d4bc <state_spindle_restore>
                    if (restore_condition.coolant.value != hal.coolant.get_state().value) {
 801e5ce:	4b18      	ldr	r3, [pc, #96]	; (801e630 <state_await_resume+0x2d4>)
 801e5d0:	781c      	ldrb	r4, [r3, #0]
 801e5d2:	4b11      	ldr	r3, [pc, #68]	; (801e618 <state_await_resume+0x2bc>)
 801e5d4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801e5d6:	4798      	blx	r3
 801e5d8:	4603      	mov	r3, r0
 801e5da:	b2db      	uxtb	r3, r3
 801e5dc:	429c      	cmp	r4, r3
 801e5de:	d00a      	beq.n	801e5f6 <state_await_resume+0x29a>
                        coolant_set_state(restore_condition.coolant);
 801e5e0:	4b13      	ldr	r3, [pc, #76]	; (801e630 <state_await_resume+0x2d4>)
 801e5e2:	7818      	ldrb	r0, [r3, #0]
 801e5e4:	f7e7 f83a 	bl	800565c <coolant_set_state>
                        delay_sec(settings.safety_door.coolant_on_delay, DelayMode_SysSuspend);
 801e5e8:	4b09      	ldr	r3, [pc, #36]	; (801e610 <state_await_resume+0x2b4>)
 801e5ea:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 801e5ee:	2101      	movs	r1, #1
 801e5f0:	4618      	mov	r0, r3
 801e5f2:	f7f2 f8c7 	bl	8010784 <delay_sec>
                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 801e5f6:	4b07      	ldr	r3, [pc, #28]	; (801e614 <state_await_resume+0x2b8>)
 801e5f8:	2200      	movs	r2, #0
 801e5fa:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
                    grbl.report.feedback_message(Message_None);
 801e5fe:	4b0d      	ldr	r3, [pc, #52]	; (801e634 <state_await_resume+0x2d8>)
 801e600:	68db      	ldr	r3, [r3, #12]
 801e602:	2000      	movs	r0, #0
 801e604:	4798      	blx	r3
                break;
 801e606:	e018      	b.n	801e63a <state_await_resume+0x2de>
                break;
 801e608:	bf00      	nop
 801e60a:	e016      	b.n	801e63a <state_await_resume+0x2de>
                break;
 801e60c:	bf00      	nop
 801e60e:	e014      	b.n	801e63a <state_await_resume+0x2de>
 801e610:	2000147c 	.word	0x2000147c
 801e614:	20000d3c 	.word	0x20000d3c
 801e618:	20000ed0 	.word	0x20000ed0
 801e61c:	200017c4 	.word	0x200017c4
 801e620:	200017c8 	.word	0x200017c8
 801e624:	20000394 	.word	0x20000394
 801e628:	0801e87d 	.word	0x0801e87d
 801e62c:	200017e8 	.word	0x200017e8
 801e630:	200017ac 	.word	0x200017ac
 801e634:	20000dd4 	.word	0x20000dd4
                break;
 801e638:	bf00      	nop
        }

        // Restart cycle
        if (!(sys_state & (STATE_SLEEP|STATE_SAFETY_DOOR))) {
 801e63a:	4b14      	ldr	r3, [pc, #80]	; (801e68c <state_await_resume+0x330>)
 801e63c:	681b      	ldr	r3, [r3, #0]
 801e63e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801e642:	2b00      	cmp	r3, #0
 801e644:	d11f      	bne.n	801e686 <state_await_resume+0x32a>
            step_control_t step_control = sys.step_control;
 801e646:	4b12      	ldr	r3, [pc, #72]	; (801e690 <state_await_resume+0x334>)
 801e648:	7e1b      	ldrb	r3, [r3, #24]
 801e64a:	733b      	strb	r3, [r7, #12]
            state_set(STATE_IDLE);
 801e64c:	2000      	movs	r0, #0
 801e64e:	f7ff f941 	bl	801d8d4 <state_set>
            sys.step_control = step_control;
 801e652:	4a0f      	ldr	r2, [pc, #60]	; (801e690 <state_await_resume+0x334>)
 801e654:	7b3b      	ldrb	r3, [r7, #12]
 801e656:	7613      	strb	r3, [r2, #24]
            state_set(STATE_CYCLE);
 801e658:	2008      	movs	r0, #8
 801e65a:	f7ff f93b 	bl	801d8d4 <state_set>
 801e65e:	e012      	b.n	801e686 <state_await_resume+0x32a>
        }

    } else if ((rt_exec & EXEC_DOOR_CLOSED) && !hal.control.get_state().safety_door_ajar)
 801e660:	687b      	ldr	r3, [r7, #4]
 801e662:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801e666:	2b00      	cmp	r3, #0
 801e668:	d00d      	beq.n	801e686 <state_await_resume+0x32a>
 801e66a:	4b0a      	ldr	r3, [pc, #40]	; (801e694 <state_await_resume+0x338>)
 801e66c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801e66e:	4798      	blx	r3
 801e670:	4603      	mov	r3, r0
 801e672:	b2db      	uxtb	r3, r3
 801e674:	f003 0308 	and.w	r3, r3, #8
 801e678:	b2db      	uxtb	r3, r3
 801e67a:	2b00      	cmp	r3, #0
 801e67c:	d103      	bne.n	801e686 <state_await_resume+0x32a>
        sys.parking_state = Parking_DoorClosed;
 801e67e:	4b04      	ldr	r3, [pc, #16]	; (801e690 <state_await_resume+0x334>)
 801e680:	2200      	movs	r2, #0
 801e682:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
}
 801e686:	3724      	adds	r7, #36	; 0x24
 801e688:	46bd      	mov	sp, r7
 801e68a:	bd90      	pop	{r4, r7, pc}
 801e68c:	200017c4 	.word	0x200017c4
 801e690:	20000d3c 	.word	0x20000d3c
 801e694:	20000ed0 	.word	0x20000ed0

0801e698 <state_await_restart_retract>:

/*! /brief Waits until plunge motion abort is completed then calls state_await_hold() to restart retraction.
state_await_hold() is set to handle the cycle complete event.
 */
static void state_await_restart_retract (uint_fast16_t rt_exec)
{
 801e698:	b580      	push	{r7, lr}
 801e69a:	b082      	sub	sp, #8
 801e69c:	af00      	add	r7, sp, #0
 801e69e:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e6a0:	687b      	ldr	r3, [r7, #4]
 801e6a2:	f003 0304 	and.w	r3, r3, #4
 801e6a6:	2b00      	cmp	r3, #0
 801e6a8:	d014      	beq.n	801e6d4 <state_await_restart_retract+0x3c>

        if (sys.step_control.execute_sys_motion) {
 801e6aa:	4b0c      	ldr	r3, [pc, #48]	; (801e6dc <state_await_restart_retract+0x44>)
 801e6ac:	7e1b      	ldrb	r3, [r3, #24]
 801e6ae:	f003 0304 	and.w	r3, r3, #4
 801e6b2:	b2db      	uxtb	r3, r3
 801e6b4:	2b00      	cmp	r3, #0
 801e6b6:	d006      	beq.n	801e6c6 <state_await_restart_retract+0x2e>
            sys.step_control.execute_sys_motion = Off;
 801e6b8:	4a08      	ldr	r2, [pc, #32]	; (801e6dc <state_await_restart_retract+0x44>)
 801e6ba:	7e13      	ldrb	r3, [r2, #24]
 801e6bc:	f36f 0382 	bfc	r3, #2, #1
 801e6c0:	7613      	strb	r3, [r2, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e6c2:	f000 fdbd 	bl	801f240 <st_parking_restore_buffer>
        }

        stateHandler = state_await_hold;
 801e6c6:	4b06      	ldr	r3, [pc, #24]	; (801e6e0 <state_await_restart_retract+0x48>)
 801e6c8:	4a06      	ldr	r2, [pc, #24]	; (801e6e4 <state_await_restart_retract+0x4c>)
 801e6ca:	601a      	str	r2, [r3, #0]
        stateHandler(EXEC_CYCLE_COMPLETE);
 801e6cc:	4b04      	ldr	r3, [pc, #16]	; (801e6e0 <state_await_restart_retract+0x48>)
 801e6ce:	681b      	ldr	r3, [r3, #0]
 801e6d0:	2004      	movs	r0, #4
 801e6d2:	4798      	blx	r3
    }
}
 801e6d4:	bf00      	nop
 801e6d6:	3708      	adds	r7, #8
 801e6d8:	46bd      	mov	sp, r7
 801e6da:	bd80      	pop	{r7, pc}
 801e6dc:	20000d3c 	.word	0x20000d3c
 801e6e0:	20000394 	.word	0x20000394
 801e6e4:	0801dfed 	.word	0x0801dfed

0801e6e8 <restart_retract>:

/*! /brief Sets up a feed hold to abort plunge motion.
state_await_restart_retract() is set to handle the cycle complete event.
 */
static void restart_retract (void)
{
 801e6e8:	b580      	push	{r7, lr}
 801e6ea:	af00      	add	r7, sp, #0
    grbl.report.feedback_message(Message_SafetyDoorAjar);
 801e6ec:	4b14      	ldr	r3, [pc, #80]	; (801e740 <restart_retract+0x58>)
 801e6ee:	68db      	ldr	r3, [r3, #12]
 801e6f0:	2006      	movs	r0, #6
 801e6f2:	4798      	blx	r3

    stateHandler = state_await_restart_retract;
 801e6f4:	4b13      	ldr	r3, [pc, #76]	; (801e744 <restart_retract+0x5c>)
 801e6f6:	4a14      	ldr	r2, [pc, #80]	; (801e748 <restart_retract+0x60>)
 801e6f8:	601a      	str	r2, [r3, #0]

    park.flags.restart = On;
 801e6fa:	4a14      	ldr	r2, [pc, #80]	; (801e74c <restart_retract+0x64>)
 801e6fc:	7f13      	ldrb	r3, [r2, #28]
 801e6fe:	f043 0304 	orr.w	r3, r3, #4
 801e702:	7713      	strb	r3, [r2, #28]
    sys.parking_state = Parking_Retracting;
 801e704:	4b12      	ldr	r3, [pc, #72]	; (801e750 <restart_retract+0x68>)
 801e706:	2202      	movs	r2, #2
 801e708:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if (sys.step_control.execute_sys_motion) {
 801e70c:	4b10      	ldr	r3, [pc, #64]	; (801e750 <restart_retract+0x68>)
 801e70e:	7e1b      	ldrb	r3, [r3, #24]
 801e710:	f003 0304 	and.w	r3, r3, #4
 801e714:	b2db      	uxtb	r3, r3
 801e716:	2b00      	cmp	r3, #0
 801e718:	d00c      	beq.n	801e734 <restart_retract+0x4c>
        st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 801e71a:	f000 fd33 	bl	801f184 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On;
 801e71e:	4a0c      	ldr	r2, [pc, #48]	; (801e750 <restart_retract+0x68>)
 801e720:	7e13      	ldrb	r3, [r2, #24]
 801e722:	f043 0302 	orr.w	r3, r3, #2
 801e726:	7613      	strb	r3, [r2, #24]
        sys.step_control.execute_sys_motion = On;
 801e728:	4a09      	ldr	r2, [pc, #36]	; (801e750 <restart_retract+0x68>)
 801e72a:	7e13      	ldrb	r3, [r2, #24]
 801e72c:	f043 0304 	orr.w	r3, r3, #4
 801e730:	7613      	strb	r3, [r2, #24]
    } else // else NO_MOTION is active.
        stateHandler(EXEC_CYCLE_COMPLETE);
}
 801e732:	e003      	b.n	801e73c <restart_retract+0x54>
        stateHandler(EXEC_CYCLE_COMPLETE);
 801e734:	4b03      	ldr	r3, [pc, #12]	; (801e744 <restart_retract+0x5c>)
 801e736:	681b      	ldr	r3, [r3, #0]
 801e738:	2004      	movs	r0, #4
 801e73a:	4798      	blx	r3
}
 801e73c:	bf00      	nop
 801e73e:	bd80      	pop	{r7, pc}
 801e740:	20000dd4 	.word	0x20000dd4
 801e744:	20000394 	.word	0x20000394
 801e748:	0801e699 	.word	0x0801e699
 801e74c:	200017c8 	.word	0x200017c8
 801e750:	20000d3c 	.word	0x20000d3c

0801e754 <state_await_waypoint_retract>:

/*! /brief Waits until slow plunge motion is completed then deenergize spindle and coolant and execute fast retract motion.
state_await_resume() is set to handle the cycle complete event.
 */
static void state_await_waypoint_retract (uint_fast16_t rt_exec)
{
 801e754:	b580      	push	{r7, lr}
 801e756:	b086      	sub	sp, #24
 801e758:	af00      	add	r7, sp, #0
 801e75a:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e75c:	687b      	ldr	r3, [r7, #4]
 801e75e:	f003 0304 	and.w	r3, r3, #4
 801e762:	2b00      	cmp	r3, #0
 801e764:	d078      	beq.n	801e858 <state_await_waypoint_retract+0x104>

        bool await_motion = false;
 801e766:	2300      	movs	r3, #0
 801e768:	75fb      	strb	r3, [r7, #23]

        if (sys.step_control.execute_sys_motion) {
 801e76a:	4b3d      	ldr	r3, [pc, #244]	; (801e860 <state_await_waypoint_retract+0x10c>)
 801e76c:	7e1b      	ldrb	r3, [r3, #24]
 801e76e:	f003 0304 	and.w	r3, r3, #4
 801e772:	b2db      	uxtb	r3, r3
 801e774:	2b00      	cmp	r3, #0
 801e776:	d006      	beq.n	801e786 <state_await_waypoint_retract+0x32>
            sys.step_control.execute_sys_motion = Off;
 801e778:	4a39      	ldr	r2, [pc, #228]	; (801e860 <state_await_waypoint_retract+0x10c>)
 801e77a:	7e13      	ldrb	r3, [r2, #24]
 801e77c:	f36f 0382 	bfc	r3, #2, #1
 801e780:	7613      	strb	r3, [r2, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e782:	f000 fd5d 	bl	801f240 <st_parking_restore_buffer>
        }

        // NOTE: Clear accessory state after retract and after an aborted restore motion.
        park.plan_data.spindle.state.value = 0;
 801e786:	4b37      	ldr	r3, [pc, #220]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e788:	2200      	movs	r2, #0
 801e78a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        park.plan_data.spindle.rpm = 0.0f;
 801e78e:	4b35      	ldr	r3, [pc, #212]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e790:	f04f 0200 	mov.w	r2, #0
 801e794:	629a      	str	r2, [r3, #40]	; 0x28
        park.plan_data.spindle.hal->set_state(park.plan_data.spindle.hal, park.plan_data.spindle.state, 0.0f); // De-energize
 801e796:	4b33      	ldr	r3, [pc, #204]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e798:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801e79a:	6a1b      	ldr	r3, [r3, #32]
 801e79c:	4a31      	ldr	r2, [pc, #196]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e79e:	6b50      	ldr	r0, [r2, #52]	; 0x34
 801e7a0:	4930      	ldr	r1, [pc, #192]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e7a2:	f04f 0200 	mov.w	r2, #0
 801e7a6:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
 801e7aa:	4798      	blx	r3

        if (!settings.safety_door.flags.keep_coolant_on) {
 801e7ac:	4b2e      	ldr	r3, [pc, #184]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e7ae:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801e7b2:	f003 0302 	and.w	r3, r3, #2
 801e7b6:	b2db      	uxtb	r3, r3
 801e7b8:	2b00      	cmp	r3, #0
 801e7ba:	d109      	bne.n	801e7d0 <state_await_waypoint_retract+0x7c>
            park.plan_data.condition.coolant.value = 0;
 801e7bc:	4b29      	ldr	r3, [pc, #164]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e7be:	2200      	movs	r2, #0
 801e7c0:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
            hal.coolant.set_state(park.plan_data.condition.coolant); // De-energize
 801e7c4:	4b29      	ldr	r3, [pc, #164]	; (801e86c <state_await_waypoint_retract+0x118>)
 801e7c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801e7c8:	4a26      	ldr	r2, [pc, #152]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e7ca:	f892 003a 	ldrb.w	r0, [r2, #58]	; 0x3a
 801e7ce:	4798      	blx	r3
        }

        stateHandler = state_await_resume;
 801e7d0:	4b27      	ldr	r3, [pc, #156]	; (801e870 <state_await_waypoint_retract+0x11c>)
 801e7d2:	4a28      	ldr	r2, [pc, #160]	; (801e874 <state_await_waypoint_retract+0x120>)
 801e7d4:	601a      	str	r2, [r3, #0]

        // Execute fast parking retract motion to parking target location.
        if (park.flags.motion && park.target[settings.parking.axis] < settings.parking.target) {
 801e7d6:	4b23      	ldr	r3, [pc, #140]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e7d8:	7f1b      	ldrb	r3, [r3, #28]
 801e7da:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801e7de:	b2db      	uxtb	r3, r3
 801e7e0:	2b00      	cmp	r3, #0
 801e7e2:	d02f      	beq.n	801e844 <state_await_waypoint_retract+0xf0>
 801e7e4:	4b20      	ldr	r3, [pc, #128]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e7e6:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e7ea:	461a      	mov	r2, r3
 801e7ec:	4b1d      	ldr	r3, [pc, #116]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e7ee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801e7f2:	4a1d      	ldr	r2, [pc, #116]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e7f4:	f8d2 212c 	ldr.w	r2, [r2, #300]	; 0x12c
 801e7f8:	4611      	mov	r1, r2
 801e7fa:	4618      	mov	r0, r3
 801e7fc:	f7e2 fc78 	bl	80010f0 <__aeabi_fcmplt>
 801e800:	4603      	mov	r3, r0
 801e802:	2b00      	cmp	r3, #0
 801e804:	d01e      	beq.n	801e844 <state_await_waypoint_retract+0xf0>
            float target[N_AXIS];
            memcpy(target, park.target, sizeof(target));
 801e806:	4a17      	ldr	r2, [pc, #92]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e808:	f107 0308 	add.w	r3, r7, #8
 801e80c:	ca07      	ldmia	r2, {r0, r1, r2}
 801e80e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            target[settings.parking.axis] = settings.parking.target;
 801e812:	4b15      	ldr	r3, [pc, #84]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e814:	f893 3129 	ldrb.w	r3, [r3, #297]	; 0x129
 801e818:	4619      	mov	r1, r3
 801e81a:	4b13      	ldr	r3, [pc, #76]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e81c:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
 801e820:	008b      	lsls	r3, r1, #2
 801e822:	3318      	adds	r3, #24
 801e824:	443b      	add	r3, r7
 801e826:	f843 2c10 	str.w	r2, [r3, #-16]
            park.plan_data.feed_rate = settings.parking.rate;
 801e82a:	4b0f      	ldr	r3, [pc, #60]	; (801e868 <state_await_waypoint_retract+0x114>)
 801e82c:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 801e830:	4a0c      	ldr	r2, [pc, #48]	; (801e864 <state_await_waypoint_retract+0x110>)
 801e832:	6213      	str	r3, [r2, #32]
            await_motion = mc_parking_motion(target, &park.plan_data);
 801e834:	f107 0308 	add.w	r3, r7, #8
 801e838:	490f      	ldr	r1, [pc, #60]	; (801e878 <state_await_waypoint_retract+0x124>)
 801e83a:	4618      	mov	r0, r3
 801e83c:	f7f0 ff10 	bl	800f660 <mc_parking_motion>
 801e840:	4603      	mov	r3, r0
 801e842:	75fb      	strb	r3, [r7, #23]
        }

        if (!await_motion)
 801e844:	7dfb      	ldrb	r3, [r7, #23]
 801e846:	f083 0301 	eor.w	r3, r3, #1
 801e84a:	b2db      	uxtb	r3, r3
 801e84c:	2b00      	cmp	r3, #0
 801e84e:	d003      	beq.n	801e858 <state_await_waypoint_retract+0x104>
            stateHandler(EXEC_CYCLE_COMPLETE);
 801e850:	4b07      	ldr	r3, [pc, #28]	; (801e870 <state_await_waypoint_retract+0x11c>)
 801e852:	681b      	ldr	r3, [r3, #0]
 801e854:	2004      	movs	r0, #4
 801e856:	4798      	blx	r3
    }
}
 801e858:	bf00      	nop
 801e85a:	3718      	adds	r7, #24
 801e85c:	46bd      	mov	sp, r7
 801e85e:	bd80      	pop	{r7, pc}
 801e860:	20000d3c 	.word	0x20000d3c
 801e864:	200017c8 	.word	0x200017c8
 801e868:	2000147c 	.word	0x2000147c
 801e86c:	20000ed0 	.word	0x20000ed0
 801e870:	20000394 	.word	0x20000394
 801e874:	0801e35d 	.word	0x0801e35d
 801e878:	200017e8 	.word	0x200017e8

0801e87c <state_restore>:
/*! /brief Waits until fast plunge motion is completed then restore spindle and coolant and execute slow plunge motion.
state_await_resumed() is set to handle the cycle complete event.
Note: A safety door event during restoration or motion will halt it and restart the retract sequence.
 */
static void state_restore (uint_fast16_t rt_exec)
{
 801e87c:	b580      	push	{r7, lr}
 801e87e:	b084      	sub	sp, #16
 801e880:	af00      	add	r7, sp, #0
 801e882:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_SAFETY_DOOR) {
 801e884:	687b      	ldr	r3, [r7, #4]
 801e886:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801e88a:	2b00      	cmp	r3, #0
 801e88c:	d00f      	beq.n	801e8ae <state_restore+0x32>
        if(park.flags.restoring)
 801e88e:	4b3b      	ldr	r3, [pc, #236]	; (801e97c <state_restore+0x100>)
 801e890:	7f1b      	ldrb	r3, [r3, #28]
 801e892:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801e896:	b2db      	uxtb	r3, r3
 801e898:	2b00      	cmp	r3, #0
 801e89a:	d005      	beq.n	801e8a8 <state_restore+0x2c>
            park.flags.restart = On;
 801e89c:	4a37      	ldr	r2, [pc, #220]	; (801e97c <state_restore+0x100>)
 801e89e:	7f13      	ldrb	r3, [r2, #28]
 801e8a0:	f043 0304 	orr.w	r3, r3, #4
 801e8a4:	7713      	strb	r3, [r2, #28]
 801e8a6:	e066      	b.n	801e976 <state_restore+0xfa>
        else
            restart_retract();
 801e8a8:	f7ff ff1e 	bl	801e6e8 <restart_retract>
 801e8ac:	e063      	b.n	801e976 <state_restore+0xfa>
    }

    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e8ae:	687b      	ldr	r3, [r7, #4]
 801e8b0:	f003 0304 	and.w	r3, r3, #4
 801e8b4:	2b00      	cmp	r3, #0
 801e8b6:	d05e      	beq.n	801e976 <state_restore+0xfa>

        bool await_motion = false;
 801e8b8:	2300      	movs	r3, #0
 801e8ba:	73fb      	strb	r3, [r7, #15]

        if (sys.step_control.execute_sys_motion) {
 801e8bc:	4b30      	ldr	r3, [pc, #192]	; (801e980 <state_restore+0x104>)
 801e8be:	7e1b      	ldrb	r3, [r3, #24]
 801e8c0:	f003 0304 	and.w	r3, r3, #4
 801e8c4:	b2db      	uxtb	r3, r3
 801e8c6:	2b00      	cmp	r3, #0
 801e8c8:	d006      	beq.n	801e8d8 <state_restore+0x5c>
            sys.step_control.execute_sys_motion = Off;
 801e8ca:	4a2d      	ldr	r2, [pc, #180]	; (801e980 <state_restore+0x104>)
 801e8cc:	7e13      	ldrb	r3, [r2, #24]
 801e8ce:	f36f 0382 	bfc	r3, #2, #1
 801e8d2:	7613      	strb	r3, [r2, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e8d4:	f000 fcb4 	bl	801f240 <st_parking_restore_buffer>
        }

        park.flags.restart = Off;
 801e8d8:	4a28      	ldr	r2, [pc, #160]	; (801e97c <state_restore+0x100>)
 801e8da:	7f13      	ldrb	r3, [r2, #28]
 801e8dc:	f36f 0382 	bfc	r3, #2, #1
 801e8e0:	7713      	strb	r3, [r2, #28]
        stateHandler = state_await_resumed;
 801e8e2:	4b28      	ldr	r3, [pc, #160]	; (801e984 <state_restore+0x108>)
 801e8e4:	4a28      	ldr	r2, [pc, #160]	; (801e988 <state_restore+0x10c>)
 801e8e6:	601a      	str	r2, [r3, #0]

        // Restart spindle and coolant, delay to power-up.
        state_restore_conditions(&restore_condition);
 801e8e8:	4828      	ldr	r0, [pc, #160]	; (801e98c <state_restore+0x110>)
 801e8ea:	f7fe fe0f 	bl	801d50c <state_restore_conditions>

        if(park.flags.restart) {
 801e8ee:	4b23      	ldr	r3, [pc, #140]	; (801e97c <state_restore+0x100>)
 801e8f0:	7f1b      	ldrb	r3, [r3, #28]
 801e8f2:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801e8f6:	b2db      	uxtb	r3, r3
 801e8f8:	2b00      	cmp	r3, #0
 801e8fa:	d002      	beq.n	801e902 <state_restore+0x86>
            // Restart flag was set by a safety door event during
            // conditions restore so restart retract.
            restart_retract();
 801e8fc:	f7ff fef4 	bl	801e6e8 <restart_retract>
            return;
 801e900:	e039      	b.n	801e976 <state_restore+0xfa>
        }

        if (park.flags.motion) {
 801e902:	4b1e      	ldr	r3, [pc, #120]	; (801e97c <state_restore+0x100>)
 801e904:	7f1b      	ldrb	r3, [r3, #28]
 801e906:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801e90a:	b2db      	uxtb	r3, r3
 801e90c:	2b00      	cmp	r3, #0
 801e90e:	d028      	beq.n	801e962 <state_restore+0xe6>

            sys.parking_state = Parking_Resuming;
 801e910:	4b1b      	ldr	r3, [pc, #108]	; (801e980 <state_restore+0x104>)
 801e912:	2204      	movs	r2, #4
 801e914:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
            // Execute slow plunge motion from pull-out position to resume position.

            // Regardless if the retract parking motion was a valid/safe motion or not, the
            // restore parking motion should logically be valid, either by returning to the
            // original position through valid machine space or by not moving at all.
            park.plan_data.feed_rate = settings.parking.pullout_rate;
 801e918:	4b1d      	ldr	r3, [pc, #116]	; (801e990 <state_restore+0x114>)
 801e91a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 801e91e:	4a17      	ldr	r2, [pc, #92]	; (801e97c <state_restore+0x100>)
 801e920:	6213      	str	r3, [r2, #32]
            park.plan_data.condition.coolant = restore_condition.coolant;
 801e922:	4a16      	ldr	r2, [pc, #88]	; (801e97c <state_restore+0x100>)
 801e924:	4b19      	ldr	r3, [pc, #100]	; (801e98c <state_restore+0x110>)
 801e926:	781b      	ldrb	r3, [r3, #0]
 801e928:	f882 303a 	strb.w	r3, [r2, #58]	; 0x3a
            park.plan_data.spindle.state = restore_condition.spindle[restore_condition.spindle_num].state;
 801e92c:	4b17      	ldr	r3, [pc, #92]	; (801e98c <state_restore+0x110>)
 801e92e:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e932:	4a12      	ldr	r2, [pc, #72]	; (801e97c <state_restore+0x100>)
 801e934:	4915      	ldr	r1, [pc, #84]	; (801e98c <state_restore+0x110>)
 801e936:	011b      	lsls	r3, r3, #4
 801e938:	440b      	add	r3, r1
 801e93a:	3308      	adds	r3, #8
 801e93c:	781b      	ldrb	r3, [r3, #0]
 801e93e:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
            park.plan_data.spindle.rpm = restore_condition.spindle[restore_condition.spindle_num].rpm;
 801e942:	4b12      	ldr	r3, [pc, #72]	; (801e98c <state_restore+0x110>)
 801e944:	f993 3001 	ldrsb.w	r3, [r3, #1]
 801e948:	4a10      	ldr	r2, [pc, #64]	; (801e98c <state_restore+0x110>)
 801e94a:	011b      	lsls	r3, r3, #4
 801e94c:	4413      	add	r3, r2
 801e94e:	3304      	adds	r3, #4
 801e950:	681b      	ldr	r3, [r3, #0]
 801e952:	4a0a      	ldr	r2, [pc, #40]	; (801e97c <state_restore+0x100>)
 801e954:	6293      	str	r3, [r2, #40]	; 0x28
            await_motion = mc_parking_motion(park.restore_target, &park.plan_data);
 801e956:	490f      	ldr	r1, [pc, #60]	; (801e994 <state_restore+0x118>)
 801e958:	480f      	ldr	r0, [pc, #60]	; (801e998 <state_restore+0x11c>)
 801e95a:	f7f0 fe81 	bl	800f660 <mc_parking_motion>
 801e95e:	4603      	mov	r3, r0
 801e960:	73fb      	strb	r3, [r7, #15]
        }

        if (!await_motion)
 801e962:	7bfb      	ldrb	r3, [r7, #15]
 801e964:	f083 0301 	eor.w	r3, r3, #1
 801e968:	b2db      	uxtb	r3, r3
 801e96a:	2b00      	cmp	r3, #0
 801e96c:	d003      	beq.n	801e976 <state_restore+0xfa>
            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step immediately.
 801e96e:	4b05      	ldr	r3, [pc, #20]	; (801e984 <state_restore+0x108>)
 801e970:	681b      	ldr	r3, [r3, #0]
 801e972:	2004      	movs	r0, #4
 801e974:	4798      	blx	r3
    }
}
 801e976:	3710      	adds	r7, #16
 801e978:	46bd      	mov	sp, r7
 801e97a:	bd80      	pop	{r7, pc}
 801e97c:	200017c8 	.word	0x200017c8
 801e980:	20000d3c 	.word	0x20000d3c
 801e984:	20000394 	.word	0x20000394
 801e988:	0801e99d 	.word	0x0801e99d
 801e98c:	200017ac 	.word	0x200017ac
 801e990:	2000147c 	.word	0x2000147c
 801e994:	200017e8 	.word	0x200017e8
 801e998:	200017d4 	.word	0x200017d4

0801e99c <state_await_resumed>:

/*! /brief Waits until slow plunge motion is complete then restart the cycle.
Note: A safety door event during the motion will halt it and restart the retract sequence.
 */
static void state_await_resumed (uint_fast16_t rt_exec)
{
 801e99c:	b580      	push	{r7, lr}
 801e99e:	b082      	sub	sp, #8
 801e9a0:	af00      	add	r7, sp, #0
 801e9a2:	6078      	str	r0, [r7, #4]
    if (rt_exec & EXEC_SAFETY_DOOR)
 801e9a4:	687b      	ldr	r3, [r7, #4]
 801e9a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801e9aa:	2b00      	cmp	r3, #0
 801e9ac:	d002      	beq.n	801e9b4 <state_await_resumed+0x18>
        restart_retract();
 801e9ae:	f7ff fe9b 	bl	801e6e8 <restart_retract>
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
        }
        state_set(STATE_IDLE);
        state_set(STATE_CYCLE);
    }
}
 801e9b2:	e01d      	b.n	801e9f0 <state_await_resumed+0x54>
    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 801e9b4:	687b      	ldr	r3, [r7, #4]
 801e9b6:	f003 0304 	and.w	r3, r3, #4
 801e9ba:	2b00      	cmp	r3, #0
 801e9bc:	d018      	beq.n	801e9f0 <state_await_resumed+0x54>
        sys.parking_state = Parking_DoorClosed;
 801e9be:	4b0e      	ldr	r3, [pc, #56]	; (801e9f8 <state_await_resumed+0x5c>)
 801e9c0:	2200      	movs	r2, #0
 801e9c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        park.flags.value = 0;
 801e9c6:	4b0d      	ldr	r3, [pc, #52]	; (801e9fc <state_await_resumed+0x60>)
 801e9c8:	2200      	movs	r2, #0
 801e9ca:	771a      	strb	r2, [r3, #28]
        if (sys.step_control.execute_sys_motion) {
 801e9cc:	4b0a      	ldr	r3, [pc, #40]	; (801e9f8 <state_await_resumed+0x5c>)
 801e9ce:	7e1b      	ldrb	r3, [r3, #24]
 801e9d0:	f003 0304 	and.w	r3, r3, #4
 801e9d4:	b2db      	uxtb	r3, r3
 801e9d6:	2b00      	cmp	r3, #0
 801e9d8:	d004      	beq.n	801e9e4 <state_await_resumed+0x48>
            sys.step_control.flags = 0;
 801e9da:	4b07      	ldr	r3, [pc, #28]	; (801e9f8 <state_await_resumed+0x5c>)
 801e9dc:	2200      	movs	r2, #0
 801e9de:	761a      	strb	r2, [r3, #24]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 801e9e0:	f000 fc2e 	bl	801f240 <st_parking_restore_buffer>
        state_set(STATE_IDLE);
 801e9e4:	2000      	movs	r0, #0
 801e9e6:	f7fe ff75 	bl	801d8d4 <state_set>
        state_set(STATE_CYCLE);
 801e9ea:	2008      	movs	r0, #8
 801e9ec:	f7fe ff72 	bl	801d8d4 <state_set>
}
 801e9f0:	bf00      	nop
 801e9f2:	3708      	adds	r7, #8
 801e9f4:	46bd      	mov	sp, r7
 801e9f6:	bd80      	pop	{r7, pc}
 801e9f8:	20000d3c 	.word	0x20000d3c
 801e9fc:	200017c8 	.word	0x200017c8

0801ea00 <output_message>:

//

// Output message in sync with motion, called by foreground process.
static void output_message (sys_state_t state)
{
 801ea00:	b580      	push	{r7, lr}
 801ea02:	b082      	sub	sp, #8
 801ea04:	af00      	add	r7, sp, #0
 801ea06:	6078      	str	r0, [r7, #4]
    if(message) {
 801ea08:	4b13      	ldr	r3, [pc, #76]	; (801ea58 <output_message+0x58>)
 801ea0a:	681b      	ldr	r3, [r3, #0]
 801ea0c:	2b00      	cmp	r3, #0
 801ea0e:	d01e      	beq.n	801ea4e <output_message+0x4e>

        if(grbl.on_gcode_message)
 801ea10:	4b12      	ldr	r3, [pc, #72]	; (801ea5c <output_message+0x5c>)
 801ea12:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801ea16:	2b00      	cmp	r3, #0
 801ea18:	d006      	beq.n	801ea28 <output_message+0x28>
            grbl.on_gcode_message(message);
 801ea1a:	4b10      	ldr	r3, [pc, #64]	; (801ea5c <output_message+0x5c>)
 801ea1c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801ea20:	4a0d      	ldr	r2, [pc, #52]	; (801ea58 <output_message+0x58>)
 801ea22:	6812      	ldr	r2, [r2, #0]
 801ea24:	4610      	mov	r0, r2
 801ea26:	4798      	blx	r3

        if(*message)
 801ea28:	4b0b      	ldr	r3, [pc, #44]	; (801ea58 <output_message+0x58>)
 801ea2a:	681b      	ldr	r3, [r3, #0]
 801ea2c:	781b      	ldrb	r3, [r3, #0]
 801ea2e:	2b00      	cmp	r3, #0
 801ea30:	d005      	beq.n	801ea3e <output_message+0x3e>
            report_message(message, Message_Plain);
 801ea32:	4b09      	ldr	r3, [pc, #36]	; (801ea58 <output_message+0x58>)
 801ea34:	681b      	ldr	r3, [r3, #0]
 801ea36:	2100      	movs	r1, #0
 801ea38:	4618      	mov	r0, r3
 801ea3a:	f7f5 fd5d 	bl	80144f8 <report_message>

        free(message);
 801ea3e:	4b06      	ldr	r3, [pc, #24]	; (801ea58 <output_message+0x58>)
 801ea40:	681b      	ldr	r3, [r3, #0]
 801ea42:	4618      	mov	r0, r3
 801ea44:	f004 fd40 	bl	80234c8 <free>
        message = NULL;
 801ea48:	4b03      	ldr	r3, [pc, #12]	; (801ea58 <output_message+0x58>)
 801ea4a:	2200      	movs	r2, #0
 801ea4c:	601a      	str	r2, [r3, #0]
    }
}
 801ea4e:	bf00      	nop
 801ea50:	3708      	adds	r7, #8
 801ea52:	46bd      	mov	sp, r7
 801ea54:	bd80      	pop	{r7, pc}
 801ea56:	bf00      	nop
 801ea58:	20001c50 	.word	0x20001c50
 801ea5c:	20000dd4 	.word	0x20000dd4

0801ea60 <st_deenergize>:

// Callback from delay to deenergize steppers after movement, might been cancelled
void st_deenergize (void)
{
 801ea60:	b580      	push	{r7, lr}
 801ea62:	af00      	add	r7, sp, #0
    if(sys.steppers_deenergize) {
 801ea64:	4b08      	ldr	r3, [pc, #32]	; (801ea88 <st_deenergize+0x28>)
 801ea66:	799b      	ldrb	r3, [r3, #6]
 801ea68:	b2db      	uxtb	r3, r3
 801ea6a:	2b00      	cmp	r3, #0
 801ea6c:	d009      	beq.n	801ea82 <st_deenergize+0x22>
        hal.stepper.enable(settings.steppers.deenergize);
 801ea6e:	4b07      	ldr	r3, [pc, #28]	; (801ea8c <st_deenergize+0x2c>)
 801ea70:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801ea74:	4a06      	ldr	r2, [pc, #24]	; (801ea90 <st_deenergize+0x30>)
 801ea76:	f892 00ec 	ldrb.w	r0, [r2, #236]	; 0xec
 801ea7a:	4798      	blx	r3
        sys.steppers_deenergize = false;
 801ea7c:	4b02      	ldr	r3, [pc, #8]	; (801ea88 <st_deenergize+0x28>)
 801ea7e:	2200      	movs	r2, #0
 801ea80:	719a      	strb	r2, [r3, #6]
    }
}
 801ea82:	bf00      	nop
 801ea84:	bd80      	pop	{r7, pc}
 801ea86:	bf00      	nop
 801ea88:	20000d3c 	.word	0x20000d3c
 801ea8c:	20000ed0 	.word	0x20000ed0
 801ea90:	2000147c 	.word	0x2000147c

0801ea94 <st_wake_up>:

// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up (void)
{
 801ea94:	b580      	push	{r7, lr}
 801ea96:	af00      	add	r7, sp, #0
    if(sys.steppers_deenergize) {
 801ea98:	4b06      	ldr	r3, [pc, #24]	; (801eab4 <st_wake_up+0x20>)
 801ea9a:	799b      	ldrb	r3, [r3, #6]
 801ea9c:	b2db      	uxtb	r3, r3
 801ea9e:	2b00      	cmp	r3, #0
 801eaa0:	d002      	beq.n	801eaa8 <st_wake_up+0x14>
        sys.steppers_deenergize = false;
 801eaa2:	4b04      	ldr	r3, [pc, #16]	; (801eab4 <st_wake_up+0x20>)
 801eaa4:	2200      	movs	r2, #0
 801eaa6:	719a      	strb	r2, [r3, #6]

    // Initialize stepper data to ensure first ISR call does not step and
    // cancel any pending steppers deenergize
    //st.exec_block = NULL;

    hal.stepper.wake_up();
 801eaa8:	4b03      	ldr	r3, [pc, #12]	; (801eab8 <st_wake_up+0x24>)
 801eaaa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801eaae:	4798      	blx	r3
}
 801eab0:	bf00      	nop
 801eab2:	bd80      	pop	{r7, pc}
 801eab4:	20000d3c 	.word	0x20000d3c
 801eab8:	20000ed0 	.word	0x20000ed0

0801eabc <st_go_idle>:

// Stepper shutdown
ISR_CODE void ISR_FUNC(st_go_idle)(void)
{
 801eabc:	b580      	push	{r7, lr}
 801eabe:	b082      	sub	sp, #8
 801eac0:	af00      	add	r7, sp, #0
    // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.

    sys_state_t state = state_get();
 801eac2:	f7fe fefd 	bl	801d8c0 <state_get>
 801eac6:	6078      	str	r0, [r7, #4]

    hal.stepper.go_idle(false);
 801eac8:	4b1e      	ldr	r3, [pc, #120]	; (801eb44 <st_go_idle+0x88>)
 801eaca:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801eace:	2000      	movs	r0, #0
 801ead0:	4798      	blx	r3

    // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    if (((settings.steppers.idle_lock_time != 255) || sys.rt_exec_alarm || state == STATE_SLEEP) && state != STATE_HOMING) {
 801ead2:	4b1d      	ldr	r3, [pc, #116]	; (801eb48 <st_go_idle+0x8c>)
 801ead4:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
 801ead8:	2bff      	cmp	r3, #255	; 0xff
 801eada:	d106      	bne.n	801eaea <st_go_idle+0x2e>
 801eadc:	4b1b      	ldr	r3, [pc, #108]	; (801eb4c <st_go_idle+0x90>)
 801eade:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801eae0:	2b00      	cmp	r3, #0
 801eae2:	d102      	bne.n	801eaea <st_go_idle+0x2e>
 801eae4:	687b      	ldr	r3, [r7, #4]
 801eae6:	2b80      	cmp	r3, #128	; 0x80
 801eae8:	d118      	bne.n	801eb1c <st_go_idle+0x60>
 801eaea:	687b      	ldr	r3, [r7, #4]
 801eaec:	2b04      	cmp	r3, #4
 801eaee:	d015      	beq.n	801eb1c <st_go_idle+0x60>
        if(state == STATE_SLEEP)
 801eaf0:	687b      	ldr	r3, [r7, #4]
 801eaf2:	2b80      	cmp	r3, #128	; 0x80
 801eaf4:	d106      	bne.n	801eb04 <st_go_idle+0x48>
            hal.stepper.enable((axes_signals_t){0});
 801eaf6:	4b13      	ldr	r3, [pc, #76]	; (801eb44 <st_go_idle+0x88>)
 801eaf8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801eafc:	2200      	movs	r2, #0
 801eafe:	4610      	mov	r0, r2
 801eb00:	4798      	blx	r3
        if(state == STATE_SLEEP)
 801eb02:	e01b      	b.n	801eb3c <st_go_idle+0x80>
        else {
            // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
            // stop and not drift from residual inertial forces at the end of the last movement.
            sys.steppers_deenergize = true;
 801eb04:	4b11      	ldr	r3, [pc, #68]	; (801eb4c <st_go_idle+0x90>)
 801eb06:	2201      	movs	r2, #1
 801eb08:	719a      	strb	r2, [r3, #6]
            hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 801eb0a:	4b0e      	ldr	r3, [pc, #56]	; (801eb44 <st_go_idle+0x88>)
 801eb0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801eb0e:	4a0e      	ldr	r2, [pc, #56]	; (801eb48 <st_go_idle+0x8c>)
 801eb10:	f8b2 20f8 	ldrh.w	r2, [r2, #248]	; 0xf8
 801eb14:	490e      	ldr	r1, [pc, #56]	; (801eb50 <st_go_idle+0x94>)
 801eb16:	4610      	mov	r0, r2
 801eb18:	4798      	blx	r3
        if(state == STATE_SLEEP)
 801eb1a:	e00f      	b.n	801eb3c <st_go_idle+0x80>
        }
    } else
        hal.stepper.enable(settings.steppers.idle_lock_time == 255 ? (axes_signals_t){AXES_BITMASK} : settings.steppers.deenergize);
 801eb1c:	4b09      	ldr	r3, [pc, #36]	; (801eb44 <st_go_idle+0x88>)
 801eb1e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801eb22:	4a09      	ldr	r2, [pc, #36]	; (801eb48 <st_go_idle+0x8c>)
 801eb24:	f8b2 20f8 	ldrh.w	r2, [r2, #248]	; 0xf8
 801eb28:	2aff      	cmp	r2, #255	; 0xff
 801eb2a:	d101      	bne.n	801eb30 <st_go_idle+0x74>
 801eb2c:	2207      	movs	r2, #7
 801eb2e:	e002      	b.n	801eb36 <st_go_idle+0x7a>
 801eb30:	4a05      	ldr	r2, [pc, #20]	; (801eb48 <st_go_idle+0x8c>)
 801eb32:	f892 20ec 	ldrb.w	r2, [r2, #236]	; 0xec
 801eb36:	4610      	mov	r0, r2
 801eb38:	4798      	blx	r3
}
 801eb3a:	bf00      	nop
 801eb3c:	bf00      	nop
 801eb3e:	3708      	adds	r7, #8
 801eb40:	46bd      	mov	sp, r7
 801eb42:	bd80      	pop	{r7, pc}
 801eb44:	20000ed0 	.word	0x20000ed0
 801eb48:	2000147c 	.word	0x2000147c
 801eb4c:	20000d3c 	.word	0x20000d3c
 801eb50:	0801ea61 	.word	0x0801ea61

0801eb54 <stepper_driver_interrupt_handler>:
*/

//! \cond

ISR_CODE void ISR_FUNC(stepper_driver_interrupt_handler)(void)
{
 801eb54:	b5f0      	push	{r4, r5, r6, r7, lr}
 801eb56:	b083      	sub	sp, #12
 801eb58:	af00      	add	r7, sp, #0
#if ENABLE_BACKLASH_COMPENSATION
    static bool backlash_motion;
#endif

    // Start a step pulse when there is a block to execute.
    if(st.exec_block) {
 801eb5a:	4b87      	ldr	r3, [pc, #540]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801eb5e:	2b00      	cmp	r3, #0
 801eb60:	d012      	beq.n	801eb88 <stepper_driver_interrupt_handler+0x34>

        hal.stepper.pulse_start(&st);
 801eb62:	4b86      	ldr	r3, [pc, #536]	; (801ed7c <stepper_driver_interrupt_handler+0x228>)
 801eb64:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 801eb68:	4883      	ldr	r0, [pc, #524]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb6a:	4798      	blx	r3

        st.new_block = st.dir_change = false;
 801eb6c:	4b82      	ldr	r3, [pc, #520]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb6e:	2200      	movs	r2, #0
 801eb70:	735a      	strb	r2, [r3, #13]
 801eb72:	4b81      	ldr	r3, [pc, #516]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb74:	7b5a      	ldrb	r2, [r3, #13]
 801eb76:	4b80      	ldr	r3, [pc, #512]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb78:	731a      	strb	r2, [r3, #12]

        if (st.step_count == 0) // Segment is complete. Discard current segment.
 801eb7a:	4b7f      	ldr	r3, [pc, #508]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb7c:	6a1b      	ldr	r3, [r3, #32]
 801eb7e:	2b00      	cmp	r3, #0
 801eb80:	d102      	bne.n	801eb88 <stepper_driver_interrupt_handler+0x34>
            st.exec_segment = NULL;
 801eb82:	4b7d      	ldr	r3, [pc, #500]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb84:	2200      	movs	r2, #0
 801eb86:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    // If there is no step segment, attempt to pop one from the stepper buffer
    if (st.exec_segment == NULL) {
 801eb88:	4b7b      	ldr	r3, [pc, #492]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eb8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801eb8c:	2b00      	cmp	r3, #0
 801eb8e:	f040 8139 	bne.w	801ee04 <stepper_driver_interrupt_handler+0x2b0>
        // Anything in the buffer? If so, load and initialize next step segment.
        if (segment_buffer_tail != segment_buffer_head) {
 801eb92:	4b7b      	ldr	r3, [pc, #492]	; (801ed80 <stepper_driver_interrupt_handler+0x22c>)
 801eb94:	681a      	ldr	r2, [r3, #0]
 801eb96:	4b7b      	ldr	r3, [pc, #492]	; (801ed84 <stepper_driver_interrupt_handler+0x230>)
 801eb98:	681b      	ldr	r3, [r3, #0]
 801eb9a:	429a      	cmp	r2, r3
 801eb9c:	f000 810b 	beq.w	801edb6 <stepper_driver_interrupt_handler+0x262>

            // Initialize new step segment and load number of steps to execute
            st.exec_segment = (segment_t *)segment_buffer_tail;
 801eba0:	4b77      	ldr	r3, [pc, #476]	; (801ed80 <stepper_driver_interrupt_handler+0x22c>)
 801eba2:	681b      	ldr	r3, [r3, #0]
 801eba4:	4a74      	ldr	r2, [pc, #464]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801eba6:	62d3      	str	r3, [r2, #44]	; 0x2c

            // Initialize step segment timing per step and load number of steps to execute.
            hal.stepper.cycles_per_tick(st.exec_segment->cycles_per_tick);
 801eba8:	4b74      	ldr	r3, [pc, #464]	; (801ed7c <stepper_driver_interrupt_handler+0x228>)
 801ebaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801ebae:	4a72      	ldr	r2, [pc, #456]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebb0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801ebb2:	68d2      	ldr	r2, [r2, #12]
 801ebb4:	4610      	mov	r0, r2
 801ebb6:	4798      	blx	r3
            st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 801ebb8:	4b6f      	ldr	r3, [pc, #444]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ebbc:	699b      	ldr	r3, [r3, #24]
 801ebbe:	4a6e      	ldr	r2, [pc, #440]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebc0:	6213      	str	r3, [r2, #32]

            // If the new segment starts a new planner block, initialize stepper variables and counters.
            if (st.exec_block != st.exec_segment->exec_block) {
 801ebc2:	4b6d      	ldr	r3, [pc, #436]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebc4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801ebc6:	4b6c      	ldr	r3, [pc, #432]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ebca:	689b      	ldr	r3, [r3, #8]
 801ebcc:	429a      	cmp	r2, r3
 801ebce:	f000 80a2 	beq.w	801ed16 <stepper_driver_interrupt_handler+0x1c2>

                if((st.dir_change = st.exec_block == NULL || st.dir_outbits.value != st.exec_segment->exec_block->direction_bits.value))
 801ebd2:	4b69      	ldr	r3, [pc, #420]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebd4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ebd6:	2b00      	cmp	r3, #0
 801ebd8:	d007      	beq.n	801ebea <stepper_driver_interrupt_handler+0x96>
 801ebda:	4b67      	ldr	r3, [pc, #412]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebdc:	7bda      	ldrb	r2, [r3, #15]
 801ebde:	4b66      	ldr	r3, [pc, #408]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebe0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ebe2:	689b      	ldr	r3, [r3, #8]
 801ebe4:	7e1b      	ldrb	r3, [r3, #24]
 801ebe6:	429a      	cmp	r2, r3
 801ebe8:	d001      	beq.n	801ebee <stepper_driver_interrupt_handler+0x9a>
 801ebea:	2301      	movs	r3, #1
 801ebec:	e000      	b.n	801ebf0 <stepper_driver_interrupt_handler+0x9c>
 801ebee:	2300      	movs	r3, #0
 801ebf0:	f003 0301 	and.w	r3, r3, #1
 801ebf4:	b2da      	uxtb	r2, r3
 801ebf6:	4b60      	ldr	r3, [pc, #384]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebf8:	735a      	strb	r2, [r3, #13]
 801ebfa:	4b5f      	ldr	r3, [pc, #380]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ebfc:	7b5b      	ldrb	r3, [r3, #13]
 801ebfe:	2b00      	cmp	r3, #0
 801ec00:	d005      	beq.n	801ec0e <stepper_driver_interrupt_handler+0xba>
                    st.dir_outbits = st.exec_segment->exec_block->direction_bits;
 801ec02:	4b5d      	ldr	r3, [pc, #372]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ec06:	689b      	ldr	r3, [r3, #8]
 801ec08:	4a5b      	ldr	r2, [pc, #364]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec0a:	7e1b      	ldrb	r3, [r3, #24]
 801ec0c:	73d3      	strb	r3, [r2, #15]
                st.exec_block = st.exec_segment->exec_block;
 801ec0e:	4b5a      	ldr	r3, [pc, #360]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec10:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ec12:	689b      	ldr	r3, [r3, #8]
 801ec14:	4a58      	ldr	r2, [pc, #352]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec16:	6293      	str	r3, [r2, #40]	; 0x28
                st.step_event_count = st.exec_block->step_event_count;
 801ec18:	4b57      	ldr	r3, [pc, #348]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ec1c:	695b      	ldr	r3, [r3, #20]
 801ec1e:	4a56      	ldr	r2, [pc, #344]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec20:	6253      	str	r3, [r2, #36]	; 0x24
                st.new_block = true;
 801ec22:	4b55      	ldr	r3, [pc, #340]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec24:	2201      	movs	r2, #1
 801ec26:	731a      	strb	r2, [r3, #12]
#if ENABLE_BACKLASH_COMPENSATION
                backlash_motion = st.exec_block->backlash_motion;
#endif

                if(st.exec_block->overrides.sync)
 801ec28:	4b53      	ldr	r3, [pc, #332]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec2a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ec2c:	7e5b      	ldrb	r3, [r3, #25]
 801ec2e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801ec32:	b2db      	uxtb	r3, r3
 801ec34:	2b00      	cmp	r3, #0
 801ec36:	d040      	beq.n	801ecba <stepper_driver_interrupt_handler+0x166>
                    sys.override.control = st.exec_block->overrides;
 801ec38:	4b4f      	ldr	r3, [pc, #316]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ec3c:	4a52      	ldr	r2, [pc, #328]	; (801ed88 <stepper_driver_interrupt_handler+0x234>)
 801ec3e:	7e5b      	ldrb	r3, [r3, #25]
 801ec40:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29

                // Execute output commands to be synchronized with motion
                while(st.exec_block->output_commands) {
 801ec44:	e039      	b.n	801ecba <stepper_driver_interrupt_handler+0x166>
                    output_command_t *cmd = st.exec_block->output_commands;
 801ec46:	4b4c      	ldr	r3, [pc, #304]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ec48:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ec4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ec4c:	607b      	str	r3, [r7, #4]
                    cmd->is_executed = true;
 801ec4e:	687b      	ldr	r3, [r7, #4]
 801ec50:	2201      	movs	r2, #1
 801ec52:	705a      	strb	r2, [r3, #1]
                    if(cmd->is_digital)
 801ec54:	687b      	ldr	r3, [r7, #4]
 801ec56:	781b      	ldrb	r3, [r3, #0]
 801ec58:	2b00      	cmp	r3, #0
 801ec5a:	d01b      	beq.n	801ec94 <stepper_driver_interrupt_handler+0x140>
                        hal.port.digital_out(cmd->port, cmd->value != 0.0f);
 801ec5c:	4b47      	ldr	r3, [pc, #284]	; (801ed7c <stepper_driver_interrupt_handler+0x228>)
 801ec5e:	f8d3 4118 	ldr.w	r4, [r3, #280]	; 0x118
 801ec62:	687b      	ldr	r3, [r7, #4]
 801ec64:	789d      	ldrb	r5, [r3, #2]
 801ec66:	687b      	ldr	r3, [r7, #4]
 801ec68:	685b      	ldr	r3, [r3, #4]
 801ec6a:	4618      	mov	r0, r3
 801ec6c:	f7e2 f84e 	bl	8000d0c <__aeabi_i2f>
 801ec70:	4603      	mov	r3, r0
 801ec72:	2201      	movs	r2, #1
 801ec74:	4616      	mov	r6, r2
 801ec76:	f04f 0100 	mov.w	r1, #0
 801ec7a:	4618      	mov	r0, r3
 801ec7c:	f7e2 fa2e 	bl	80010dc <__aeabi_fcmpeq>
 801ec80:	4603      	mov	r3, r0
 801ec82:	2b00      	cmp	r3, #0
 801ec84:	d001      	beq.n	801ec8a <stepper_driver_interrupt_handler+0x136>
 801ec86:	2300      	movs	r3, #0
 801ec88:	461e      	mov	r6, r3
 801ec8a:	b2f3      	uxtb	r3, r6
 801ec8c:	4619      	mov	r1, r3
 801ec8e:	4628      	mov	r0, r5
 801ec90:	47a0      	blx	r4
 801ec92:	e00d      	b.n	801ecb0 <stepper_driver_interrupt_handler+0x15c>
                    else
                        hal.port.analog_out(cmd->port, cmd->value);
 801ec94:	4b39      	ldr	r3, [pc, #228]	; (801ed7c <stepper_driver_interrupt_handler+0x228>)
 801ec96:	f8d3 411c 	ldr.w	r4, [r3, #284]	; 0x11c
 801ec9a:	687b      	ldr	r3, [r7, #4]
 801ec9c:	789d      	ldrb	r5, [r3, #2]
 801ec9e:	687b      	ldr	r3, [r7, #4]
 801eca0:	685b      	ldr	r3, [r3, #4]
 801eca2:	4618      	mov	r0, r3
 801eca4:	f7e2 f832 	bl	8000d0c <__aeabi_i2f>
 801eca8:	4603      	mov	r3, r0
 801ecaa:	4619      	mov	r1, r3
 801ecac:	4628      	mov	r0, r5
 801ecae:	47a0      	blx	r4
                    st.exec_block->output_commands = cmd->next;
 801ecb0:	4b31      	ldr	r3, [pc, #196]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecb4:	687a      	ldr	r2, [r7, #4]
 801ecb6:	6892      	ldr	r2, [r2, #8]
 801ecb8:	62da      	str	r2, [r3, #44]	; 0x2c
                while(st.exec_block->output_commands) {
 801ecba:	4b2f      	ldr	r3, [pc, #188]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecbc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ecc0:	2b00      	cmp	r3, #0
 801ecc2:	d1c0      	bne.n	801ec46 <stepper_driver_interrupt_handler+0xf2>
                }

                // Enqueue any message to be printed (by foreground process)
                if(st.exec_block->message) {
 801ecc4:	4b2c      	ldr	r3, [pc, #176]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecc8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecca:	2b00      	cmp	r3, #0
 801eccc:	d016      	beq.n	801ecfc <stepper_driver_interrupt_handler+0x1a8>
                    if(message == NULL) {
 801ecce:	4b2f      	ldr	r3, [pc, #188]	; (801ed8c <stepper_driver_interrupt_handler+0x238>)
 801ecd0:	681b      	ldr	r3, [r3, #0]
 801ecd2:	2b00      	cmp	r3, #0
 801ecd4:	d108      	bne.n	801ece8 <stepper_driver_interrupt_handler+0x194>
                        message = st.exec_block->message;
 801ecd6:	4b28      	ldr	r3, [pc, #160]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecd8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecdc:	4a2b      	ldr	r2, [pc, #172]	; (801ed8c <stepper_driver_interrupt_handler+0x238>)
 801ecde:	6013      	str	r3, [r2, #0]
                        protocol_enqueue_rt_command(output_message);
 801ece0:	482b      	ldr	r0, [pc, #172]	; (801ed90 <stepper_driver_interrupt_handler+0x23c>)
 801ece2:	f7f5 f883 	bl	8013dec <protocol_enqueue_rt_command>
 801ece6:	e005      	b.n	801ecf4 <stepper_driver_interrupt_handler+0x1a0>
                    } else
                        free(st.exec_block->message); //
 801ece8:	4b23      	ldr	r3, [pc, #140]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecee:	4618      	mov	r0, r3
 801ecf0:	f004 fbea 	bl	80234c8 <free>
                    st.exec_block->message = NULL;
 801ecf4:	4b20      	ldr	r3, [pc, #128]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecf6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ecf8:	2200      	movs	r2, #0
 801ecfa:	629a      	str	r2, [r3, #40]	; 0x28
                  = st.counter_u
                #endif
                #ifdef V_AXIS
                  = st.counter_v
                #endif
                  = st.step_event_count >> 1;
 801ecfc:	4b1e      	ldr	r3, [pc, #120]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ecfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ed00:	085b      	lsrs	r3, r3, #1
 801ed02:	4a1d      	ldr	r2, [pc, #116]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed04:	6093      	str	r3, [r2, #8]
                st.counter_x = st.counter_y = st.counter_z
 801ed06:	4b1c      	ldr	r3, [pc, #112]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed08:	689b      	ldr	r3, [r3, #8]
 801ed0a:	4a1b      	ldr	r2, [pc, #108]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed0c:	6053      	str	r3, [r2, #4]
 801ed0e:	4b1a      	ldr	r3, [pc, #104]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed10:	685b      	ldr	r3, [r3, #4]
 801ed12:	4a19      	ldr	r2, [pc, #100]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed14:	6013      	str	r3, [r2, #0]
              #endif
            }

          #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
            // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
            st.amass_level = st.exec_segment->amass_level;
 801ed16:	4b18      	ldr	r3, [pc, #96]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ed1c:	4a16      	ldr	r2, [pc, #88]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed1e:	61d3      	str	r3, [r2, #28]
            st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.amass_level;
 801ed20:	4b15      	ldr	r3, [pc, #84]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ed24:	689a      	ldr	r2, [r3, #8]
 801ed26:	4b14      	ldr	r3, [pc, #80]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed28:	69db      	ldr	r3, [r3, #28]
 801ed2a:	fa22 f303 	lsr.w	r3, r2, r3
 801ed2e:	4a12      	ldr	r2, [pc, #72]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed30:	6113      	str	r3, [r2, #16]
            st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.amass_level;
 801ed32:	4b11      	ldr	r3, [pc, #68]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ed36:	68da      	ldr	r2, [r3, #12]
 801ed38:	4b0f      	ldr	r3, [pc, #60]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed3a:	69db      	ldr	r3, [r3, #28]
 801ed3c:	fa22 f303 	lsr.w	r3, r2, r3
 801ed40:	4a0d      	ldr	r2, [pc, #52]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed42:	6153      	str	r3, [r2, #20]
            st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.amass_level;
 801ed44:	4b0c      	ldr	r3, [pc, #48]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ed48:	691a      	ldr	r2, [r3, #16]
 801ed4a:	4b0b      	ldr	r3, [pc, #44]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed4c:	69db      	ldr	r3, [r3, #28]
 801ed4e:	fa22 f303 	lsr.w	r3, r2, r3
 801ed52:	4a09      	ldr	r2, [pc, #36]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed54:	6193      	str	r3, [r2, #24]
           #ifdef V_AXIS
            st.steps[V_AXIS] = st.exec_block->steps[V_AXIS] >> st.amass_level;
           #endif
         #endif

            if(st.exec_segment->update_pwm)
 801ed56:	4b08      	ldr	r3, [pc, #32]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed5c:	2b00      	cmp	r3, #0
 801ed5e:	d019      	beq.n	801ed94 <stepper_driver_interrupt_handler+0x240>
                st.exec_segment->update_pwm(st.exec_block->spindle, st.exec_segment->spindle_pwm);
 801ed60:	4b05      	ldr	r3, [pc, #20]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed66:	4a04      	ldr	r2, [pc, #16]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed68:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801ed6a:	6b50      	ldr	r0, [r2, #52]	; 0x34
 801ed6c:	4a02      	ldr	r2, [pc, #8]	; (801ed78 <stepper_driver_interrupt_handler+0x224>)
 801ed6e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801ed70:	69d2      	ldr	r2, [r2, #28]
 801ed72:	4611      	mov	r1, r2
 801ed74:	4798      	blx	r3
 801ed76:	e045      	b.n	801ee04 <stepper_driver_interrupt_handler+0x2b0>
 801ed78:	20001c14 	.word	0x20001c14
 801ed7c:	20000ed0 	.word	0x20000ed0
 801ed80:	20001c5c 	.word	0x20001c5c
 801ed84:	20001c60 	.word	0x20001c60
 801ed88:	20000d3c 	.word	0x20000d3c
 801ed8c:	20001c50 	.word	0x20001c50
 801ed90:	0801ea01 	.word	0x0801ea01
            else if(st.exec_segment->update_rpm)
 801ed94:	4b7f      	ldr	r3, [pc, #508]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ed96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ed98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801ed9a:	2b00      	cmp	r3, #0
 801ed9c:	d032      	beq.n	801ee04 <stepper_driver_interrupt_handler+0x2b0>
                st.exec_segment->update_rpm(st.exec_block->spindle, st.exec_segment->spindle_rpm);
 801ed9e:	4b7d      	ldr	r3, [pc, #500]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eda0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801eda2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801eda4:	4a7b      	ldr	r2, [pc, #492]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eda6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801eda8:	6b50      	ldr	r0, [r2, #52]	; 0x34
 801edaa:	4a7a      	ldr	r2, [pc, #488]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801edac:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801edae:	6a12      	ldr	r2, [r2, #32]
 801edb0:	4611      	mov	r1, r2
 801edb2:	4798      	blx	r3
 801edb4:	e026      	b.n	801ee04 <stepper_driver_interrupt_handler+0x2b0>
        } else {
            // Segment buffer empty. Shutdown.
            st_go_idle();
 801edb6:	f7ff fe81 	bl	801eabc <st_go_idle>

            // Ensure pwm is set properly upon completion of rate-controlled motion.
            if (st.exec_block->dynamic_rpm && st.exec_block->spindle->cap.laser)
 801edba:	4b76      	ldr	r3, [pc, #472]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801edbc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801edbe:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801edc2:	2b00      	cmp	r3, #0
 801edc4:	d015      	beq.n	801edf2 <stepper_driver_interrupt_handler+0x29e>
 801edc6:	4b73      	ldr	r3, [pc, #460]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801edc8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801edca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801edcc:	7a9b      	ldrb	r3, [r3, #10]
 801edce:	f003 0308 	and.w	r3, r3, #8
 801edd2:	b2db      	uxtb	r3, r3
 801edd4:	2b00      	cmp	r3, #0
 801edd6:	d00c      	beq.n	801edf2 <stepper_driver_interrupt_handler+0x29e>
                st.exec_block->spindle->update_pwm(st.exec_block->spindle, st.exec_block->spindle->pwm_off_value);
 801edd8:	4b6e      	ldr	r3, [pc, #440]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801edda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801eddc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801edde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ede0:	4a6c      	ldr	r2, [pc, #432]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ede2:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801ede4:	6b50      	ldr	r0, [r2, #52]	; 0x34
 801ede6:	4a6b      	ldr	r2, [pc, #428]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ede8:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801edea:	6b52      	ldr	r2, [r2, #52]	; 0x34
 801edec:	6912      	ldr	r2, [r2, #16]
 801edee:	4611      	mov	r1, r2
 801edf0:	4798      	blx	r3

            st.exec_block = NULL;
 801edf2:	4b68      	ldr	r3, [pc, #416]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801edf4:	2200      	movs	r2, #0
 801edf6:	629a      	str	r2, [r3, #40]	; 0x28
            system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle complete
 801edf8:	4b67      	ldr	r3, [pc, #412]	; (801ef98 <stepper_driver_interrupt_handler+0x444>)
 801edfa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801edfc:	2104      	movs	r1, #4
 801edfe:	4867      	ldr	r0, [pc, #412]	; (801ef9c <stepper_driver_interrupt_handler+0x448>)
 801ee00:	4798      	blx	r3
 801ee02:	e0c3      	b.n	801ef8c <stepper_driver_interrupt_handler+0x438>
    }

    // Check probing state.
    // Monitors probe pin state and records the system position when detected.
    // NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
    if (sys.probing_state == Probing_Active && hal.probe.get_state().triggered) {
 801ee04:	4b66      	ldr	r3, [pc, #408]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee06:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801ee0a:	b2db      	uxtb	r3, r3
 801ee0c:	2b01      	cmp	r3, #1
 801ee0e:	d11b      	bne.n	801ee48 <stepper_driver_interrupt_handler+0x2f4>
 801ee10:	4b61      	ldr	r3, [pc, #388]	; (801ef98 <stepper_driver_interrupt_handler+0x444>)
 801ee12:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 801ee16:	4798      	blx	r3
 801ee18:	4603      	mov	r3, r0
 801ee1a:	b2db      	uxtb	r3, r3
 801ee1c:	f003 0301 	and.w	r3, r3, #1
 801ee20:	b2db      	uxtb	r3, r3
 801ee22:	2b00      	cmp	r3, #0
 801ee24:	d010      	beq.n	801ee48 <stepper_driver_interrupt_handler+0x2f4>

        sys.probing_state = Probing_Off;
 801ee26:	4b5e      	ldr	r3, [pc, #376]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee28:	2200      	movs	r2, #0
 801ee2a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
        memcpy(sys.probe_position, sys.position, sizeof(sys.position));
 801ee2e:	4b5c      	ldr	r3, [pc, #368]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee30:	4a5b      	ldr	r2, [pc, #364]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee32:	3338      	adds	r3, #56	; 0x38
 801ee34:	3288      	adds	r2, #136	; 0x88
 801ee36:	ca07      	ldmia	r2, {r0, r1, r2}
 801ee38:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        bit_true(sys.rt_exec_state, EXEC_MOTION_CANCEL);
 801ee3c:	4b58      	ldr	r3, [pc, #352]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ee40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801ee44:	4a56      	ldr	r2, [pc, #344]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee46:	6493      	str	r3, [r2, #72]	; 0x48
            segment_next_head = segment_next_head->next;
        }
#endif
    }

    register axes_signals_t step_outbits = (axes_signals_t){0};
 801ee48:	2300      	movs	r3, #0
 801ee4a:	703b      	strb	r3, [r7, #0]

    // Execute step displacement profile by Bresenham line algorithm

    st.counter_x += st.steps[X_AXIS];
 801ee4c:	4b51      	ldr	r3, [pc, #324]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee4e:	681a      	ldr	r2, [r3, #0]
 801ee50:	4b50      	ldr	r3, [pc, #320]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee52:	691b      	ldr	r3, [r3, #16]
 801ee54:	4413      	add	r3, r2
 801ee56:	4a4f      	ldr	r2, [pc, #316]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee58:	6013      	str	r3, [r2, #0]
    if (st.counter_x > st.step_event_count) {
 801ee5a:	4b4e      	ldr	r3, [pc, #312]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee5c:	681a      	ldr	r2, [r3, #0]
 801ee5e:	4b4d      	ldr	r3, [pc, #308]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ee62:	429a      	cmp	r2, r3
 801ee64:	d91c      	bls.n	801eea0 <stepper_driver_interrupt_handler+0x34c>
        step_outbits.x = On;
 801ee66:	783b      	ldrb	r3, [r7, #0]
 801ee68:	f043 0301 	orr.w	r3, r3, #1
 801ee6c:	703b      	strb	r3, [r7, #0]
        st.counter_x -= st.step_event_count;
 801ee6e:	4b49      	ldr	r3, [pc, #292]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee70:	681a      	ldr	r2, [r3, #0]
 801ee72:	4b48      	ldr	r3, [pc, #288]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ee76:	1ad3      	subs	r3, r2, r3
 801ee78:	4a46      	ldr	r2, [pc, #280]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee7a:	6013      	str	r3, [r2, #0]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[X_AXIS] = sys.position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 801ee7c:	4b48      	ldr	r3, [pc, #288]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee7e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801ee82:	4a44      	ldr	r2, [pc, #272]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ee84:	7bd2      	ldrb	r2, [r2, #15]
 801ee86:	f002 0201 	and.w	r2, r2, #1
 801ee8a:	b2d2      	uxtb	r2, r2
 801ee8c:	2a00      	cmp	r2, #0
 801ee8e:	d002      	beq.n	801ee96 <stepper_driver_interrupt_handler+0x342>
 801ee90:	f04f 32ff 	mov.w	r2, #4294967295
 801ee94:	e000      	b.n	801ee98 <stepper_driver_interrupt_handler+0x344>
 801ee96:	2201      	movs	r2, #1
 801ee98:	4413      	add	r3, r2
 801ee9a:	4a41      	ldr	r2, [pc, #260]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ee9c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }

    st.counter_y += st.steps[Y_AXIS];
 801eea0:	4b3c      	ldr	r3, [pc, #240]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eea2:	685a      	ldr	r2, [r3, #4]
 801eea4:	4b3b      	ldr	r3, [pc, #236]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eea6:	695b      	ldr	r3, [r3, #20]
 801eea8:	4413      	add	r3, r2
 801eeaa:	4a3a      	ldr	r2, [pc, #232]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eeac:	6053      	str	r3, [r2, #4]
    if (st.counter_y > st.step_event_count) {
 801eeae:	4b39      	ldr	r3, [pc, #228]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eeb0:	685a      	ldr	r2, [r3, #4]
 801eeb2:	4b38      	ldr	r3, [pc, #224]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eeb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801eeb6:	429a      	cmp	r2, r3
 801eeb8:	d91c      	bls.n	801eef4 <stepper_driver_interrupt_handler+0x3a0>
        step_outbits.y = On;
 801eeba:	783b      	ldrb	r3, [r7, #0]
 801eebc:	f043 0302 	orr.w	r3, r3, #2
 801eec0:	703b      	strb	r3, [r7, #0]
        st.counter_y -= st.step_event_count;
 801eec2:	4b34      	ldr	r3, [pc, #208]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eec4:	685a      	ldr	r2, [r3, #4]
 801eec6:	4b33      	ldr	r3, [pc, #204]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eec8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801eeca:	1ad3      	subs	r3, r2, r3
 801eecc:	4a31      	ldr	r2, [pc, #196]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eece:	6053      	str	r3, [r2, #4]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[Y_AXIS] = sys.position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 801eed0:	4b33      	ldr	r3, [pc, #204]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801eed2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 801eed6:	4a2f      	ldr	r2, [pc, #188]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eed8:	7bd2      	ldrb	r2, [r2, #15]
 801eeda:	f002 0202 	and.w	r2, r2, #2
 801eede:	b2d2      	uxtb	r2, r2
 801eee0:	2a00      	cmp	r2, #0
 801eee2:	d002      	beq.n	801eeea <stepper_driver_interrupt_handler+0x396>
 801eee4:	f04f 32ff 	mov.w	r2, #4294967295
 801eee8:	e000      	b.n	801eeec <stepper_driver_interrupt_handler+0x398>
 801eeea:	2201      	movs	r2, #1
 801eeec:	4413      	add	r3, r2
 801eeee:	4a2c      	ldr	r2, [pc, #176]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801eef0:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    }

    st.counter_z += st.steps[Z_AXIS];
 801eef4:	4b27      	ldr	r3, [pc, #156]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eef6:	689a      	ldr	r2, [r3, #8]
 801eef8:	4b26      	ldr	r3, [pc, #152]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801eefa:	699b      	ldr	r3, [r3, #24]
 801eefc:	4413      	add	r3, r2
 801eefe:	4a25      	ldr	r2, [pc, #148]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef00:	6093      	str	r3, [r2, #8]
    if (st.counter_z > st.step_event_count) {
 801ef02:	4b24      	ldr	r3, [pc, #144]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef04:	689a      	ldr	r2, [r3, #8]
 801ef06:	4b23      	ldr	r3, [pc, #140]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ef0a:	429a      	cmp	r2, r3
 801ef0c:	d91c      	bls.n	801ef48 <stepper_driver_interrupt_handler+0x3f4>
        step_outbits.z = On;
 801ef0e:	783b      	ldrb	r3, [r7, #0]
 801ef10:	f043 0304 	orr.w	r3, r3, #4
 801ef14:	703b      	strb	r3, [r7, #0]
        st.counter_z -= st.step_event_count;
 801ef16:	4b1f      	ldr	r3, [pc, #124]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef18:	689a      	ldr	r2, [r3, #8]
 801ef1a:	4b1e      	ldr	r3, [pc, #120]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ef1e:	1ad3      	subs	r3, r2, r3
 801ef20:	4a1c      	ldr	r2, [pc, #112]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef22:	6093      	str	r3, [r2, #8]
#if ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys.position[Z_AXIS] = sys.position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 801ef24:	4b1e      	ldr	r3, [pc, #120]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ef26:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801ef2a:	4a1a      	ldr	r2, [pc, #104]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef2c:	7bd2      	ldrb	r2, [r2, #15]
 801ef2e:	f002 0204 	and.w	r2, r2, #4
 801ef32:	b2d2      	uxtb	r2, r2
 801ef34:	2a00      	cmp	r2, #0
 801ef36:	d002      	beq.n	801ef3e <stepper_driver_interrupt_handler+0x3ea>
 801ef38:	f04f 32ff 	mov.w	r2, #4294967295
 801ef3c:	e000      	b.n	801ef40 <stepper_driver_interrupt_handler+0x3ec>
 801ef3e:	2201      	movs	r2, #1
 801ef40:	4413      	add	r3, r2
 801ef42:	4a17      	ldr	r2, [pc, #92]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ef44:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif
            sys.position[V_AXIS] = sys.position[V_AXIS] + (st.dir_outbits.v ? -1 : 1);
    }
  #endif

    st.step_outbits.value = step_outbits.value;
 801ef48:	783a      	ldrb	r2, [r7, #0]
 801ef4a:	4b12      	ldr	r3, [pc, #72]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef4c:	739a      	strb	r2, [r3, #14]

    // During a homing cycle, lock out and prevent desired axes from moving.
    if (state_get() == STATE_HOMING)
 801ef4e:	f7fe fcb7 	bl	801d8c0 <state_get>
 801ef52:	4603      	mov	r3, r0
 801ef54:	2b04      	cmp	r3, #4
 801ef56:	d107      	bne.n	801ef68 <stepper_driver_interrupt_handler+0x414>
        st.step_outbits.value &= sys.homing_axis_lock.mask;
 801ef58:	4b0e      	ldr	r3, [pc, #56]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef5a:	7b9a      	ldrb	r2, [r3, #14]
 801ef5c:	4b10      	ldr	r3, [pc, #64]	; (801efa0 <stepper_driver_interrupt_handler+0x44c>)
 801ef5e:	7e5b      	ldrb	r3, [r3, #25]
 801ef60:	4013      	ands	r3, r2
 801ef62:	b2da      	uxtb	r2, r3
 801ef64:	4b0b      	ldr	r3, [pc, #44]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef66:	739a      	strb	r2, [r3, #14]

    if (st.step_count == 0 || --st.step_count == 0) {
 801ef68:	4b0a      	ldr	r3, [pc, #40]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef6a:	6a1b      	ldr	r3, [r3, #32]
 801ef6c:	2b00      	cmp	r3, #0
 801ef6e:	d008      	beq.n	801ef82 <stepper_driver_interrupt_handler+0x42e>
 801ef70:	4b08      	ldr	r3, [pc, #32]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef72:	6a1b      	ldr	r3, [r3, #32]
 801ef74:	3b01      	subs	r3, #1
 801ef76:	4a07      	ldr	r2, [pc, #28]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef78:	6213      	str	r3, [r2, #32]
 801ef7a:	4b06      	ldr	r3, [pc, #24]	; (801ef94 <stepper_driver_interrupt_handler+0x440>)
 801ef7c:	6a1b      	ldr	r3, [r3, #32]
 801ef7e:	2b00      	cmp	r3, #0
 801ef80:	d104      	bne.n	801ef8c <stepper_driver_interrupt_handler+0x438>
        // Segment is complete. Advance segment tail pointer.
        segment_buffer_tail = segment_buffer_tail->next;
 801ef82:	4b08      	ldr	r3, [pc, #32]	; (801efa4 <stepper_driver_interrupt_handler+0x450>)
 801ef84:	681b      	ldr	r3, [r3, #0]
 801ef86:	685b      	ldr	r3, [r3, #4]
 801ef88:	4a06      	ldr	r2, [pc, #24]	; (801efa4 <stepper_driver_interrupt_handler+0x450>)
 801ef8a:	6013      	str	r3, [r2, #0]
    }
}
 801ef8c:	370c      	adds	r7, #12
 801ef8e:	46bd      	mov	sp, r7
 801ef90:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ef92:	bf00      	nop
 801ef94:	20001c14 	.word	0x20001c14
 801ef98:	20000ed0 	.word	0x20000ed0
 801ef9c:	20000d84 	.word	0x20000d84
 801efa0:	20000d3c 	.word	0x20000d3c
 801efa4:	20001c5c 	.word	0x20001c5c

0801efa8 <st_reset>:

//! \endcond

// Reset and clear stepper subsystem variables
void st_reset (void)
{
 801efa8:	b580      	push	{r7, lr}
 801efaa:	b082      	sub	sp, #8
 801efac:	af00      	add	r7, sp, #0
    if(hal.probe.configure)
 801efae:	4b5f      	ldr	r3, [pc, #380]	; (801f12c <st_reset+0x184>)
 801efb0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801efb4:	2b00      	cmp	r3, #0
 801efb6:	d005      	beq.n	801efc4 <st_reset+0x1c>
        hal.probe.configure(false, false);
 801efb8:	4b5c      	ldr	r3, [pc, #368]	; (801f12c <st_reset+0x184>)
 801efba:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 801efbe:	2100      	movs	r1, #0
 801efc0:	2000      	movs	r0, #0
 801efc2:	4798      	blx	r3

    if(message) {
 801efc4:	4b5a      	ldr	r3, [pc, #360]	; (801f130 <st_reset+0x188>)
 801efc6:	681b      	ldr	r3, [r3, #0]
 801efc8:	2b00      	cmp	r3, #0
 801efca:	d007      	beq.n	801efdc <st_reset+0x34>
        free(message);
 801efcc:	4b58      	ldr	r3, [pc, #352]	; (801f130 <st_reset+0x188>)
 801efce:	681b      	ldr	r3, [r3, #0]
 801efd0:	4618      	mov	r0, r3
 801efd2:	f004 fa79 	bl	80234c8 <free>
        message = NULL;
 801efd6:	4b56      	ldr	r3, [pc, #344]	; (801f130 <st_reset+0x188>)
 801efd8:	2200      	movs	r2, #0
 801efda:	601a      	str	r2, [r3, #0]
    }

    // Initialize stepper driver idle state, clear step and direction port pins.
    st_go_idle();
 801efdc:	f7ff fd6e 	bl	801eabc <st_go_idle>
   // hal.stepper.go_idle(true);

    // NOTE: buffer indices starts from 1 for simpler driver coding!

    // Set up stepper block ringbuffer as circular linked list and add id
    uint_fast8_t idx, idx_max = (sizeof(st_block_buffer) / sizeof(st_block_t)) - 1;
 801efe0:	2308      	movs	r3, #8
 801efe2:	603b      	str	r3, [r7, #0]
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801efe4:	2300      	movs	r3, #0
 801efe6:	607b      	str	r3, [r7, #4]
 801efe8:	e023      	b.n	801f032 <st_reset+0x8a>
        st_block_buffer[idx].next = &st_block_buffer[idx == idx_max ? 0 : idx + 1];
 801efea:	687a      	ldr	r2, [r7, #4]
 801efec:	683b      	ldr	r3, [r7, #0]
 801efee:	429a      	cmp	r2, r3
 801eff0:	d002      	beq.n	801eff8 <st_reset+0x50>
 801eff2:	687b      	ldr	r3, [r7, #4]
 801eff4:	1c5a      	adds	r2, r3, #1
 801eff6:	e000      	b.n	801effa <st_reset+0x52>
 801eff8:	2200      	movs	r2, #0
 801effa:	4613      	mov	r3, r2
 801effc:	00db      	lsls	r3, r3, #3
 801effe:	1a9b      	subs	r3, r3, r2
 801f000:	00db      	lsls	r3, r3, #3
 801f002:	4a4c      	ldr	r2, [pc, #304]	; (801f134 <st_reset+0x18c>)
 801f004:	1899      	adds	r1, r3, r2
 801f006:	484b      	ldr	r0, [pc, #300]	; (801f134 <st_reset+0x18c>)
 801f008:	687a      	ldr	r2, [r7, #4]
 801f00a:	4613      	mov	r3, r2
 801f00c:	00db      	lsls	r3, r3, #3
 801f00e:	1a9b      	subs	r3, r3, r2
 801f010:	00db      	lsls	r3, r3, #3
 801f012:	4403      	add	r3, r0
 801f014:	3304      	adds	r3, #4
 801f016:	6019      	str	r1, [r3, #0]
        st_block_buffer[idx].id = idx + 1;
 801f018:	687b      	ldr	r3, [r7, #4]
 801f01a:	1c59      	adds	r1, r3, #1
 801f01c:	4845      	ldr	r0, [pc, #276]	; (801f134 <st_reset+0x18c>)
 801f01e:	687a      	ldr	r2, [r7, #4]
 801f020:	4613      	mov	r3, r2
 801f022:	00db      	lsls	r3, r3, #3
 801f024:	1a9b      	subs	r3, r3, r2
 801f026:	00db      	lsls	r3, r3, #3
 801f028:	4403      	add	r3, r0
 801f02a:	6019      	str	r1, [r3, #0]
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f02c:	687b      	ldr	r3, [r7, #4]
 801f02e:	3301      	adds	r3, #1
 801f030:	607b      	str	r3, [r7, #4]
 801f032:	687a      	ldr	r2, [r7, #4]
 801f034:	683b      	ldr	r3, [r7, #0]
 801f036:	429a      	cmp	r2, r3
 801f038:	d9d7      	bls.n	801efea <st_reset+0x42>
    }

    // Set up segments ringbuffer as circular linked list, add id and clear AMASS level
    idx_max = (sizeof(segment_buffer) / sizeof(segment_t)) - 1;
 801f03a:	2309      	movs	r3, #9
 801f03c:	603b      	str	r3, [r7, #0]
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f03e:	2300      	movs	r3, #0
 801f040:	607b      	str	r3, [r7, #4]
 801f042:	e029      	b.n	801f098 <st_reset+0xf0>
        segment_buffer[idx].next = &segment_buffer[idx == idx_max ? 0 : idx + 1];
 801f044:	687a      	ldr	r2, [r7, #4]
 801f046:	683b      	ldr	r3, [r7, #0]
 801f048:	429a      	cmp	r2, r3
 801f04a:	d002      	beq.n	801f052 <st_reset+0xaa>
 801f04c:	687b      	ldr	r3, [r7, #4]
 801f04e:	3301      	adds	r3, #1
 801f050:	e000      	b.n	801f054 <st_reset+0xac>
 801f052:	2300      	movs	r3, #0
 801f054:	2234      	movs	r2, #52	; 0x34
 801f056:	fb02 f303 	mul.w	r3, r2, r3
 801f05a:	4a37      	ldr	r2, [pc, #220]	; (801f138 <st_reset+0x190>)
 801f05c:	441a      	add	r2, r3
 801f05e:	4936      	ldr	r1, [pc, #216]	; (801f138 <st_reset+0x190>)
 801f060:	687b      	ldr	r3, [r7, #4]
 801f062:	2034      	movs	r0, #52	; 0x34
 801f064:	fb00 f303 	mul.w	r3, r0, r3
 801f068:	440b      	add	r3, r1
 801f06a:	3304      	adds	r3, #4
 801f06c:	601a      	str	r2, [r3, #0]
        segment_buffer[idx].id = idx + 1;
 801f06e:	687b      	ldr	r3, [r7, #4]
 801f070:	1c5a      	adds	r2, r3, #1
 801f072:	4931      	ldr	r1, [pc, #196]	; (801f138 <st_reset+0x190>)
 801f074:	687b      	ldr	r3, [r7, #4]
 801f076:	2034      	movs	r0, #52	; 0x34
 801f078:	fb00 f303 	mul.w	r3, r0, r3
 801f07c:	440b      	add	r3, r1
 801f07e:	601a      	str	r2, [r3, #0]
        segment_buffer[idx].amass_level = 0;
 801f080:	4a2d      	ldr	r2, [pc, #180]	; (801f138 <st_reset+0x190>)
 801f082:	687b      	ldr	r3, [r7, #4]
 801f084:	2134      	movs	r1, #52	; 0x34
 801f086:	fb01 f303 	mul.w	r3, r1, r3
 801f08a:	4413      	add	r3, r2
 801f08c:	3328      	adds	r3, #40	; 0x28
 801f08e:	2200      	movs	r2, #0
 801f090:	601a      	str	r2, [r3, #0]
    for(idx = 0 ; idx <= idx_max ; idx++) {
 801f092:	687b      	ldr	r3, [r7, #4]
 801f094:	3301      	adds	r3, #1
 801f096:	607b      	str	r3, [r7, #4]
 801f098:	687a      	ldr	r2, [r7, #4]
 801f09a:	683b      	ldr	r3, [r7, #0]
 801f09c:	429a      	cmp	r2, r3
 801f09e:	d9d1      	bls.n	801f044 <st_reset+0x9c>
    }

    st_prep_block = &st_block_buffer[0];
 801f0a0:	4b26      	ldr	r3, [pc, #152]	; (801f13c <st_reset+0x194>)
 801f0a2:	4a24      	ldr	r2, [pc, #144]	; (801f134 <st_reset+0x18c>)
 801f0a4:	601a      	str	r2, [r3, #0]

    // Initialize stepper algorithm variables.
    pl_block = NULL;  // Planner block pointer used by segment buffer
 801f0a6:	4b26      	ldr	r3, [pc, #152]	; (801f140 <st_reset+0x198>)
 801f0a8:	2200      	movs	r2, #0
 801f0aa:	601a      	str	r2, [r3, #0]
    segment_buffer_tail = segment_buffer_head = &segment_buffer[0]; // empty = tail
 801f0ac:	4b25      	ldr	r3, [pc, #148]	; (801f144 <st_reset+0x19c>)
 801f0ae:	4a22      	ldr	r2, [pc, #136]	; (801f138 <st_reset+0x190>)
 801f0b0:	601a      	str	r2, [r3, #0]
 801f0b2:	4b25      	ldr	r3, [pc, #148]	; (801f148 <st_reset+0x1a0>)
 801f0b4:	4a20      	ldr	r2, [pc, #128]	; (801f138 <st_reset+0x190>)
 801f0b6:	601a      	str	r2, [r3, #0]
    segment_next_head = segment_buffer_head->next;
 801f0b8:	4b22      	ldr	r3, [pc, #136]	; (801f144 <st_reset+0x19c>)
 801f0ba:	681b      	ldr	r3, [r3, #0]
 801f0bc:	685b      	ldr	r3, [r3, #4]
 801f0be:	4a23      	ldr	r2, [pc, #140]	; (801f14c <st_reset+0x1a4>)
 801f0c0:	6013      	str	r3, [r2, #0]

    memset(&prep, 0, sizeof(st_prep_t));
 801f0c2:	2254      	movs	r2, #84	; 0x54
 801f0c4:	2100      	movs	r1, #0
 801f0c6:	4822      	ldr	r0, [pc, #136]	; (801f150 <st_reset+0x1a8>)
 801f0c8:	f004 fda5 	bl	8023c16 <memset>
    memset(&st, 0, sizeof(stepper_t));
 801f0cc:	2230      	movs	r2, #48	; 0x30
 801f0ce:	2100      	movs	r1, #0
 801f0d0:	4820      	ldr	r0, [pc, #128]	; (801f154 <st_reset+0x1ac>)
 801f0d2:	f004 fda0 	bl	8023c16 <memset>

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    // TODO: move to driver?
    // AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
    // Defined as step timer frequency / Cutoff frequency in Hz
    amass.level_1 = hal.f_step_timer / 8000;
 801f0d6:	4b15      	ldr	r3, [pc, #84]	; (801f12c <st_reset+0x184>)
 801f0d8:	69db      	ldr	r3, [r3, #28]
 801f0da:	4a1f      	ldr	r2, [pc, #124]	; (801f158 <st_reset+0x1b0>)
 801f0dc:	fba2 2303 	umull	r2, r3, r2, r3
 801f0e0:	0a5b      	lsrs	r3, r3, #9
 801f0e2:	4a1e      	ldr	r2, [pc, #120]	; (801f15c <st_reset+0x1b4>)
 801f0e4:	6013      	str	r3, [r2, #0]
    amass.level_2 = hal.f_step_timer / 4000;
 801f0e6:	4b11      	ldr	r3, [pc, #68]	; (801f12c <st_reset+0x184>)
 801f0e8:	69db      	ldr	r3, [r3, #28]
 801f0ea:	4a1b      	ldr	r2, [pc, #108]	; (801f158 <st_reset+0x1b0>)
 801f0ec:	fba2 2303 	umull	r2, r3, r2, r3
 801f0f0:	0a1b      	lsrs	r3, r3, #8
 801f0f2:	4a1a      	ldr	r2, [pc, #104]	; (801f15c <st_reset+0x1b4>)
 801f0f4:	6053      	str	r3, [r2, #4]
    amass.level_3 = hal.f_step_timer / 2000;
 801f0f6:	4b0d      	ldr	r3, [pc, #52]	; (801f12c <st_reset+0x184>)
 801f0f8:	69db      	ldr	r3, [r3, #28]
 801f0fa:	4a17      	ldr	r2, [pc, #92]	; (801f158 <st_reset+0x1b0>)
 801f0fc:	fba2 2303 	umull	r2, r3, r2, r3
 801f100:	09db      	lsrs	r3, r3, #7
 801f102:	4a16      	ldr	r2, [pc, #88]	; (801f15c <st_reset+0x1b4>)
 801f104:	6093      	str	r3, [r2, #8]
#endif

    cycles_per_min = (float)hal.f_step_timer * 60.0f;
 801f106:	4b09      	ldr	r3, [pc, #36]	; (801f12c <st_reset+0x184>)
 801f108:	69db      	ldr	r3, [r3, #28]
 801f10a:	4618      	mov	r0, r3
 801f10c:	f7e1 fdfa 	bl	8000d04 <__aeabi_ui2f>
 801f110:	4603      	mov	r3, r0
 801f112:	4913      	ldr	r1, [pc, #76]	; (801f160 <st_reset+0x1b8>)
 801f114:	4618      	mov	r0, r3
 801f116:	f7e1 fe4d 	bl	8000db4 <__aeabi_fmul>
 801f11a:	4603      	mov	r3, r0
 801f11c:	461a      	mov	r2, r3
 801f11e:	4b11      	ldr	r3, [pc, #68]	; (801f164 <st_reset+0x1bc>)
 801f120:	601a      	str	r2, [r3, #0]
}
 801f122:	bf00      	nop
 801f124:	3708      	adds	r7, #8
 801f126:	46bd      	mov	sp, r7
 801f128:	bd80      	pop	{r7, pc}
 801f12a:	bf00      	nop
 801f12c:	20000ed0 	.word	0x20000ed0
 801f130:	20001c50 	.word	0x20001c50
 801f134:	20001814 	.word	0x20001814
 801f138:	20001a0c 	.word	0x20001a0c
 801f13c:	20001c6c 	.word	0x20001c6c
 801f140:	20001c68 	.word	0x20001c68
 801f144:	20001c60 	.word	0x20001c60
 801f148:	20001c5c 	.word	0x20001c5c
 801f14c:	20001c64 	.word	0x20001c64
 801f150:	20001ca8 	.word	0x20001ca8
 801f154:	20001c14 	.word	0x20001c14
 801f158:	10624dd3 	.word	0x10624dd3
 801f15c:	20001c44 	.word	0x20001c44
 801f160:	42700000 	.word	0x42700000
 801f164:	20001c58 	.word	0x20001c58

0801f168 <st_rpm_changed>:

// Called by spindle_set_state() to inform about RPM changes.
// Used by st_prep_buffer() to determine if spindle needs update when dynamic RPM is called for.
void st_rpm_changed (float rpm)
{
 801f168:	b480      	push	{r7}
 801f16a:	b083      	sub	sp, #12
 801f16c:	af00      	add	r7, sp, #0
 801f16e:	6078      	str	r0, [r7, #4]
    prep.current_spindle_rpm = rpm;
 801f170:	4a03      	ldr	r2, [pc, #12]	; (801f180 <st_rpm_changed+0x18>)
 801f172:	687b      	ldr	r3, [r7, #4]
 801f174:	6513      	str	r3, [r2, #80]	; 0x50
}
 801f176:	bf00      	nop
 801f178:	370c      	adds	r7, #12
 801f17a:	46bd      	mov	sp, r7
 801f17c:	bc80      	pop	{r7}
 801f17e:	4770      	bx	lr
 801f180:	20001ca8 	.word	0x20001ca8

0801f184 <st_update_plan_block_parameters>:

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters (void)
{
 801f184:	b598      	push	{r3, r4, r7, lr}
 801f186:	af00      	add	r7, sp, #0
    if (pl_block != NULL) { // Ignore if at start of a new block.
 801f188:	4b0c      	ldr	r3, [pc, #48]	; (801f1bc <st_update_plan_block_parameters+0x38>)
 801f18a:	681b      	ldr	r3, [r3, #0]
 801f18c:	2b00      	cmp	r3, #0
 801f18e:	d013      	beq.n	801f1b8 <st_update_plan_block_parameters+0x34>
        prep.recalculate.velocity_profile = On;
 801f190:	4a0b      	ldr	r2, [pc, #44]	; (801f1c0 <st_update_plan_block_parameters+0x3c>)
 801f192:	7813      	ldrb	r3, [r2, #0]
 801f194:	f043 0301 	orr.w	r3, r3, #1
 801f198:	7013      	strb	r3, [r2, #0]
        pl_block->entry_speed_sqr = prep.current_speed * prep.current_speed; // Update entry speed.
 801f19a:	4b09      	ldr	r3, [pc, #36]	; (801f1c0 <st_update_plan_block_parameters+0x3c>)
 801f19c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801f19e:	4a08      	ldr	r2, [pc, #32]	; (801f1c0 <st_update_plan_block_parameters+0x3c>)
 801f1a0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801f1a2:	4906      	ldr	r1, [pc, #24]	; (801f1bc <st_update_plan_block_parameters+0x38>)
 801f1a4:	680c      	ldr	r4, [r1, #0]
 801f1a6:	4611      	mov	r1, r2
 801f1a8:	4618      	mov	r0, r3
 801f1aa:	f7e1 fe03 	bl	8000db4 <__aeabi_fmul>
 801f1ae:	4603      	mov	r3, r0
 801f1b0:	61e3      	str	r3, [r4, #28]
        pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 801f1b2:	4b02      	ldr	r3, [pc, #8]	; (801f1bc <st_update_plan_block_parameters+0x38>)
 801f1b4:	2200      	movs	r2, #0
 801f1b6:	601a      	str	r2, [r3, #0]
    }
}
 801f1b8:	bf00      	nop
 801f1ba:	bd98      	pop	{r3, r4, r7, pc}
 801f1bc:	20001c68 	.word	0x20001c68
 801f1c0:	20001ca8 	.word	0x20001ca8

0801f1c4 <st_parking_setup_buffer>:

// Changes the run state of the step segment buffer to execute the special parking motion.
void st_parking_setup_buffer (void)
{
 801f1c4:	b580      	push	{r7, lr}
 801f1c6:	af00      	add	r7, sp, #0
    // Store step execution data of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block && !prep.recalculate.parking) {
 801f1c8:	4b19      	ldr	r3, [pc, #100]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f1ca:	781b      	ldrb	r3, [r3, #0]
 801f1cc:	f003 0302 	and.w	r3, r3, #2
 801f1d0:	b2db      	uxtb	r3, r3
 801f1d2:	2b00      	cmp	r3, #0
 801f1d4:	d01d      	beq.n	801f212 <st_parking_setup_buffer+0x4e>
 801f1d6:	4b16      	ldr	r3, [pc, #88]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f1d8:	781b      	ldrb	r3, [r3, #0]
 801f1da:	f003 0304 	and.w	r3, r3, #4
 801f1de:	b2db      	uxtb	r3, r3
 801f1e0:	2b00      	cmp	r3, #0
 801f1e2:	d116      	bne.n	801f212 <st_parking_setup_buffer+0x4e>
        prep.last_st_block = st_prep_block;
 801f1e4:	4b13      	ldr	r3, [pc, #76]	; (801f234 <st_parking_setup_buffer+0x70>)
 801f1e6:	681b      	ldr	r3, [r3, #0]
 801f1e8:	4a11      	ldr	r2, [pc, #68]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f1ea:	6153      	str	r3, [r2, #20]
        memcpy(&st_hold_block, st_prep_block, sizeof(st_block_t));
 801f1ec:	4b11      	ldr	r3, [pc, #68]	; (801f234 <st_parking_setup_buffer+0x70>)
 801f1ee:	681b      	ldr	r3, [r3, #0]
 801f1f0:	2238      	movs	r2, #56	; 0x38
 801f1f2:	4619      	mov	r1, r3
 801f1f4:	4810      	ldr	r0, [pc, #64]	; (801f238 <st_parking_setup_buffer+0x74>)
 801f1f6:	f004 fe6a 	bl	8023ece <memcpy>
        prep.last_steps_remaining = prep.steps_remaining;
 801f1fa:	4b0d      	ldr	r3, [pc, #52]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f1fc:	689b      	ldr	r3, [r3, #8]
 801f1fe:	4a0c      	ldr	r2, [pc, #48]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f200:	6193      	str	r3, [r2, #24]
        prep.last_dt_remainder = prep.dt_remainder;
 801f202:	4b0b      	ldr	r3, [pc, #44]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f204:	685b      	ldr	r3, [r3, #4]
 801f206:	4a0a      	ldr	r2, [pc, #40]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f208:	6213      	str	r3, [r2, #32]
        prep.last_steps_per_mm = prep.steps_per_mm;
 801f20a:	4b09      	ldr	r3, [pc, #36]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f20c:	68db      	ldr	r3, [r3, #12]
 801f20e:	4a08      	ldr	r2, [pc, #32]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f210:	61d3      	str	r3, [r2, #28]
    }
    // Set flags to execute a parking motion
    prep.recalculate.parking = On;
 801f212:	4a07      	ldr	r2, [pc, #28]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f214:	7813      	ldrb	r3, [r2, #0]
 801f216:	f043 0304 	orr.w	r3, r3, #4
 801f21a:	7013      	strb	r3, [r2, #0]
    prep.recalculate.velocity_profile = Off;
 801f21c:	4a04      	ldr	r2, [pc, #16]	; (801f230 <st_parking_setup_buffer+0x6c>)
 801f21e:	7813      	ldrb	r3, [r2, #0]
 801f220:	f36f 0300 	bfc	r3, #0, #1
 801f224:	7013      	strb	r3, [r2, #0]
    pl_block = NULL; // Always reset parking motion to reload new block.
 801f226:	4b05      	ldr	r3, [pc, #20]	; (801f23c <st_parking_setup_buffer+0x78>)
 801f228:	2200      	movs	r2, #0
 801f22a:	601a      	str	r2, [r3, #0]
}
 801f22c:	bf00      	nop
 801f22e:	bd80      	pop	{r7, pc}
 801f230:	20001ca8 	.word	0x20001ca8
 801f234:	20001c6c 	.word	0x20001c6c
 801f238:	20001c70 	.word	0x20001c70
 801f23c:	20001c68 	.word	0x20001c68

0801f240 <st_parking_restore_buffer>:


// Restores the step segment buffer to the normal run state after a parking motion.
void st_parking_restore_buffer (void)
{
 801f240:	b580      	push	{r7, lr}
 801f242:	af00      	add	r7, sp, #0
    // Restore step execution data and flags of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block) {
 801f244:	4b21      	ldr	r3, [pc, #132]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f246:	781b      	ldrb	r3, [r3, #0]
 801f248:	f003 0302 	and.w	r3, r3, #2
 801f24c:	b2db      	uxtb	r3, r3
 801f24e:	2b00      	cmp	r3, #0
 801f250:	d033      	beq.n	801f2ba <st_parking_restore_buffer+0x7a>
        memcpy(prep.last_st_block, &st_hold_block, sizeof(st_block_t));
 801f252:	4b1e      	ldr	r3, [pc, #120]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f254:	695b      	ldr	r3, [r3, #20]
 801f256:	2238      	movs	r2, #56	; 0x38
 801f258:	491d      	ldr	r1, [pc, #116]	; (801f2d0 <st_parking_restore_buffer+0x90>)
 801f25a:	4618      	mov	r0, r3
 801f25c:	f004 fe37 	bl	8023ece <memcpy>
        st_prep_block = prep.last_st_block;
 801f260:	4b1a      	ldr	r3, [pc, #104]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f262:	695b      	ldr	r3, [r3, #20]
 801f264:	4a1b      	ldr	r2, [pc, #108]	; (801f2d4 <st_parking_restore_buffer+0x94>)
 801f266:	6013      	str	r3, [r2, #0]
        prep.steps_remaining = prep.last_steps_remaining;
 801f268:	4b18      	ldr	r3, [pc, #96]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f26a:	699b      	ldr	r3, [r3, #24]
 801f26c:	4a17      	ldr	r2, [pc, #92]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f26e:	6093      	str	r3, [r2, #8]
        prep.dt_remainder = prep.last_dt_remainder;
 801f270:	4b16      	ldr	r3, [pc, #88]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f272:	6a1b      	ldr	r3, [r3, #32]
 801f274:	4a15      	ldr	r2, [pc, #84]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f276:	6053      	str	r3, [r2, #4]
        prep.steps_per_mm = prep.last_steps_per_mm;
 801f278:	4b14      	ldr	r3, [pc, #80]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f27a:	69db      	ldr	r3, [r3, #28]
 801f27c:	4a13      	ldr	r2, [pc, #76]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f27e:	60d3      	str	r3, [r2, #12]
        prep.recalculate.flags = 0;
 801f280:	4b12      	ldr	r3, [pc, #72]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f282:	2200      	movs	r2, #0
 801f284:	701a      	strb	r2, [r3, #0]
        prep.recalculate.hold_partial_block = prep.recalculate.velocity_profile = On;
 801f286:	4a11      	ldr	r2, [pc, #68]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f288:	7813      	ldrb	r3, [r2, #0]
 801f28a:	f043 0301 	orr.w	r3, r3, #1
 801f28e:	7013      	strb	r3, [r2, #0]
 801f290:	4b0e      	ldr	r3, [pc, #56]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f292:	781b      	ldrb	r3, [r3, #0]
 801f294:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801f298:	b2d9      	uxtb	r1, r3
 801f29a:	4a0c      	ldr	r2, [pc, #48]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f29c:	7813      	ldrb	r3, [r2, #0]
 801f29e:	f361 0341 	bfi	r3, r1, #1, #1
 801f2a2:	7013      	strb	r3, [r2, #0]
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
 801f2a4:	4b09      	ldr	r3, [pc, #36]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f2a6:	68db      	ldr	r3, [r3, #12]
 801f2a8:	4619      	mov	r1, r3
 801f2aa:	480b      	ldr	r0, [pc, #44]	; (801f2d8 <st_parking_restore_buffer+0x98>)
 801f2ac:	f7e1 fe36 	bl	8000f1c <__aeabi_fdiv>
 801f2b0:	4603      	mov	r3, r0
 801f2b2:	461a      	mov	r2, r3
 801f2b4:	4b05      	ldr	r3, [pc, #20]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f2b6:	611a      	str	r2, [r3, #16]
 801f2b8:	e002      	b.n	801f2c0 <st_parking_restore_buffer+0x80>
    } else
        prep.recalculate.flags = 0;
 801f2ba:	4b04      	ldr	r3, [pc, #16]	; (801f2cc <st_parking_restore_buffer+0x8c>)
 801f2bc:	2200      	movs	r2, #0
 801f2be:	701a      	strb	r2, [r3, #0]

    pl_block = NULL; // Set to reload next block.
 801f2c0:	4b06      	ldr	r3, [pc, #24]	; (801f2dc <st_parking_restore_buffer+0x9c>)
 801f2c2:	2200      	movs	r2, #0
 801f2c4:	601a      	str	r2, [r3, #0]
}
 801f2c6:	bf00      	nop
 801f2c8:	bd80      	pop	{r7, pc}
 801f2ca:	bf00      	nop
 801f2cc:	20001ca8 	.word	0x20001ca8
 801f2d0:	20001c70 	.word	0x20001c70
 801f2d4:	20001c6c 	.word	0x20001c6c
 801f2d8:	3fa00000 	.word	0x3fa00000
 801f2dc:	20001c68 	.word	0x20001c68

0801f2e0 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer (void)
{
 801f2e0:	b5b0      	push	{r4, r5, r7, lr}
 801f2e2:	b096      	sub	sp, #88	; 0x58
 801f2e4:	af00      	add	r7, sp, #0
    // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    if (sys.step_control.end_motion)
 801f2e6:	4b7e      	ldr	r3, [pc, #504]	; (801f4e0 <st_prep_buffer+0x200>)
 801f2e8:	7e1b      	ldrb	r3, [r3, #24]
 801f2ea:	f003 0301 	and.w	r3, r3, #1
 801f2ee:	b2db      	uxtb	r3, r3
 801f2f0:	2b00      	cmp	r3, #0
 801f2f2:	f040 86e9 	bne.w	80200c8 <st_prep_buffer+0xde8>
        return;

    while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 801f2f6:	f000 bedf 	b.w	80200b8 <st_prep_buffer+0xdd8>

        // Determine if we need to load a new planner block or if the block needs to be recomputed.
        if (pl_block == NULL) {
 801f2fa:	4b7a      	ldr	r3, [pc, #488]	; (801f4e4 <st_prep_buffer+0x204>)
 801f2fc:	681b      	ldr	r3, [r3, #0]
 801f2fe:	2b00      	cmp	r3, #0
 801f300:	f040 82f1 	bne.w	801f8e6 <st_prep_buffer+0x606>

            // Query planner for a queued block

            pl_block = sys.step_control.execute_sys_motion ? plan_get_system_motion_block() : plan_get_current_block();
 801f304:	4b76      	ldr	r3, [pc, #472]	; (801f4e0 <st_prep_buffer+0x200>)
 801f306:	7e1b      	ldrb	r3, [r3, #24]
 801f308:	f003 0304 	and.w	r3, r3, #4
 801f30c:	b2db      	uxtb	r3, r3
 801f30e:	2b00      	cmp	r3, #0
 801f310:	d003      	beq.n	801f31a <st_prep_buffer+0x3a>
 801f312:	f7f2 fad9 	bl	80118c8 <plan_get_system_motion_block>
 801f316:	4603      	mov	r3, r0
 801f318:	e002      	b.n	801f320 <st_prep_buffer+0x40>
 801f31a:	f7f2 fadf 	bl	80118dc <plan_get_current_block>
 801f31e:	4603      	mov	r3, r0
 801f320:	4a70      	ldr	r2, [pc, #448]	; (801f4e4 <st_prep_buffer+0x204>)
 801f322:	6013      	str	r3, [r2, #0]

            if (pl_block == NULL)
 801f324:	4b6f      	ldr	r3, [pc, #444]	; (801f4e4 <st_prep_buffer+0x204>)
 801f326:	681b      	ldr	r3, [r3, #0]
 801f328:	2b00      	cmp	r3, #0
 801f32a:	f000 86cf 	beq.w	80200cc <st_prep_buffer+0xdec>
                return; // No planner blocks. Exit.

            // Check if we need to only recompute the velocity profile or load a new block.
            if (prep.recalculate.velocity_profile) {
 801f32e:	4b6e      	ldr	r3, [pc, #440]	; (801f4e8 <st_prep_buffer+0x208>)
 801f330:	781b      	ldrb	r3, [r3, #0]
 801f332:	f003 0301 	and.w	r3, r3, #1
 801f336:	b2db      	uxtb	r3, r3
 801f338:	2b00      	cmp	r3, #0
 801f33a:	d01c      	beq.n	801f376 <st_prep_buffer+0x96>
                if(settings.parking.flags.enabled) {
 801f33c:	4b6b      	ldr	r3, [pc, #428]	; (801f4ec <st_prep_buffer+0x20c>)
 801f33e:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801f342:	f003 0301 	and.w	r3, r3, #1
 801f346:	b2db      	uxtb	r3, r3
 801f348:	2b00      	cmp	r3, #0
 801f34a:	d010      	beq.n	801f36e <st_prep_buffer+0x8e>
                    if (prep.recalculate.parking)
 801f34c:	4b66      	ldr	r3, [pc, #408]	; (801f4e8 <st_prep_buffer+0x208>)
 801f34e:	781b      	ldrb	r3, [r3, #0]
 801f350:	f003 0304 	and.w	r3, r3, #4
 801f354:	b2db      	uxtb	r3, r3
 801f356:	2b00      	cmp	r3, #0
 801f358:	d005      	beq.n	801f366 <st_prep_buffer+0x86>
                        prep.recalculate.velocity_profile = Off;
 801f35a:	4a63      	ldr	r2, [pc, #396]	; (801f4e8 <st_prep_buffer+0x208>)
 801f35c:	7813      	ldrb	r3, [r2, #0]
 801f35e:	f36f 0300 	bfc	r3, #0, #1
 801f362:	7013      	strb	r3, [r2, #0]
 801f364:	e108      	b.n	801f578 <st_prep_buffer+0x298>
                    else
                        prep.recalculate.flags = 0;
 801f366:	4b60      	ldr	r3, [pc, #384]	; (801f4e8 <st_prep_buffer+0x208>)
 801f368:	2200      	movs	r2, #0
 801f36a:	701a      	strb	r2, [r3, #0]
 801f36c:	e104      	b.n	801f578 <st_prep_buffer+0x298>
                } else
                    prep.recalculate.flags = 0;
 801f36e:	4b5e      	ldr	r3, [pc, #376]	; (801f4e8 <st_prep_buffer+0x208>)
 801f370:	2200      	movs	r2, #0
 801f372:	701a      	strb	r2, [r3, #0]
 801f374:	e100      	b.n	801f578 <st_prep_buffer+0x298>

                // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
                // when the segment buffer completes the planner block, it may be discarded when the
                // segment buffer finishes the prepped block, but the stepper ISR is still executing it.

                st_prep_block = st_prep_block->next;
 801f376:	4b5e      	ldr	r3, [pc, #376]	; (801f4f0 <st_prep_buffer+0x210>)
 801f378:	681b      	ldr	r3, [r3, #0]
 801f37a:	685b      	ldr	r3, [r3, #4]
 801f37c:	4a5c      	ldr	r2, [pc, #368]	; (801f4f0 <st_prep_buffer+0x210>)
 801f37e:	6013      	str	r3, [r2, #0]

                uint_fast8_t idx = N_AXIS;
 801f380:	2303      	movs	r3, #3
 801f382:	657b      	str	r3, [r7, #84]	; 0x54
              #else
                // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
                // level, such that we never divide beyond the original data anywhere in the algorithm.
                // If the original data is divided, we can lose a step from integer roundoff.
                do {
                    idx--;
 801f384:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801f386:	3b01      	subs	r3, #1
 801f388:	657b      	str	r3, [r7, #84]	; 0x54
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 801f38a:	4b56      	ldr	r3, [pc, #344]	; (801f4e4 <st_prep_buffer+0x204>)
 801f38c:	681b      	ldr	r3, [r3, #0]
 801f38e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801f390:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801f394:	4b56      	ldr	r3, [pc, #344]	; (801f4f0 <st_prep_buffer+0x210>)
 801f396:	681b      	ldr	r3, [r3, #0]
 801f398:	00d1      	lsls	r1, r2, #3
 801f39a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801f39c:	3202      	adds	r2, #2
 801f39e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                } while(idx);
 801f3a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801f3a4:	2b00      	cmp	r3, #0
 801f3a6:	d1ed      	bne.n	801f384 <st_prep_buffer+0xa4>
                st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 801f3a8:	4b4e      	ldr	r3, [pc, #312]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3aa:	681b      	ldr	r3, [r3, #0]
 801f3ac:	68da      	ldr	r2, [r3, #12]
 801f3ae:	4b50      	ldr	r3, [pc, #320]	; (801f4f0 <st_prep_buffer+0x210>)
 801f3b0:	681b      	ldr	r3, [r3, #0]
 801f3b2:	00d2      	lsls	r2, r2, #3
 801f3b4:	615a      	str	r2, [r3, #20]
              #endif

                st_prep_block->direction_bits = pl_block->direction_bits;
 801f3b6:	4b4b      	ldr	r3, [pc, #300]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3b8:	681a      	ldr	r2, [r3, #0]
 801f3ba:	4b4d      	ldr	r3, [pc, #308]	; (801f4f0 <st_prep_buffer+0x210>)
 801f3bc:	681b      	ldr	r3, [r3, #0]
 801f3be:	7c12      	ldrb	r2, [r2, #16]
 801f3c0:	761a      	strb	r2, [r3, #24]
                st_prep_block->programmed_rate = pl_block->programmed_rate;
 801f3c2:	4b48      	ldr	r3, [pc, #288]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3c4:	681a      	ldr	r2, [r3, #0]
 801f3c6:	4b4a      	ldr	r3, [pc, #296]	; (801f4f0 <st_prep_buffer+0x210>)
 801f3c8:	681b      	ldr	r3, [r3, #0]
 801f3ca:	6b52      	ldr	r2, [r2, #52]	; 0x34
 801f3cc:	625a      	str	r2, [r3, #36]	; 0x24
//                st_prep_block->r = pl_block->programmed_rate;
                st_prep_block->millimeters = pl_block->millimeters;
 801f3ce:	4b45      	ldr	r3, [pc, #276]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3d0:	681a      	ldr	r2, [r3, #0]
 801f3d2:	4b47      	ldr	r3, [pc, #284]	; (801f4f0 <st_prep_buffer+0x210>)
 801f3d4:	681b      	ldr	r3, [r3, #0]
 801f3d6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 801f3d8:	621a      	str	r2, [r3, #32]
                st_prep_block->steps_per_mm = (float)pl_block->step_event_count / pl_block->millimeters;
 801f3da:	4b42      	ldr	r3, [pc, #264]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3dc:	681b      	ldr	r3, [r3, #0]
 801f3de:	68db      	ldr	r3, [r3, #12]
 801f3e0:	4618      	mov	r0, r3
 801f3e2:	f7e1 fc8f 	bl	8000d04 <__aeabi_ui2f>
 801f3e6:	4602      	mov	r2, r0
 801f3e8:	4b3e      	ldr	r3, [pc, #248]	; (801f4e4 <st_prep_buffer+0x204>)
 801f3ea:	681b      	ldr	r3, [r3, #0]
 801f3ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f3ee:	4940      	ldr	r1, [pc, #256]	; (801f4f0 <st_prep_buffer+0x210>)
 801f3f0:	680c      	ldr	r4, [r1, #0]
 801f3f2:	4619      	mov	r1, r3
 801f3f4:	4610      	mov	r0, r2
 801f3f6:	f7e1 fd91 	bl	8000f1c <__aeabi_fdiv>
 801f3fa:	4603      	mov	r3, r0
 801f3fc:	61e3      	str	r3, [r4, #28]
                st_prep_block->spindle = pl_block->spindle.hal;
 801f3fe:	4b39      	ldr	r3, [pc, #228]	; (801f4e4 <st_prep_buffer+0x204>)
 801f400:	681a      	ldr	r2, [r3, #0]
 801f402:	4b3b      	ldr	r3, [pc, #236]	; (801f4f0 <st_prep_buffer+0x210>)
 801f404:	681b      	ldr	r3, [r3, #0]
 801f406:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801f408:	635a      	str	r2, [r3, #52]	; 0x34
                st_prep_block->output_commands = pl_block->output_commands;
 801f40a:	4b36      	ldr	r3, [pc, #216]	; (801f4e4 <st_prep_buffer+0x204>)
 801f40c:	681a      	ldr	r2, [r3, #0]
 801f40e:	4b38      	ldr	r3, [pc, #224]	; (801f4f0 <st_prep_buffer+0x210>)
 801f410:	681b      	ldr	r3, [r3, #0]
 801f412:	6d12      	ldr	r2, [r2, #80]	; 0x50
 801f414:	62da      	str	r2, [r3, #44]	; 0x2c
                st_prep_block->overrides = pl_block->overrides;
 801f416:	4b33      	ldr	r3, [pc, #204]	; (801f4e4 <st_prep_buffer+0x204>)
 801f418:	681a      	ldr	r2, [r3, #0]
 801f41a:	4b35      	ldr	r3, [pc, #212]	; (801f4f0 <st_prep_buffer+0x210>)
 801f41c:	681b      	ldr	r3, [r3, #0]
 801f41e:	7c52      	ldrb	r2, [r2, #17]
 801f420:	765a      	strb	r2, [r3, #25]
                st_prep_block->backlash_motion = pl_block->condition.backlash_motion;
 801f422:	4b30      	ldr	r3, [pc, #192]	; (801f4e4 <st_prep_buffer+0x204>)
 801f424:	681b      	ldr	r3, [r3, #0]
 801f426:	7d1b      	ldrb	r3, [r3, #20]
 801f428:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801f42c:	b2db      	uxtb	r3, r3
 801f42e:	461a      	mov	r2, r3
 801f430:	4b2f      	ldr	r3, [pc, #188]	; (801f4f0 <st_prep_buffer+0x210>)
 801f432:	681b      	ldr	r3, [r3, #0]
 801f434:	2a00      	cmp	r2, #0
 801f436:	bf14      	ite	ne
 801f438:	2201      	movne	r2, #1
 801f43a:	2200      	moveq	r2, #0
 801f43c:	b2d2      	uxtb	r2, r2
 801f43e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
                st_prep_block->message = pl_block->message;
 801f442:	4b28      	ldr	r3, [pc, #160]	; (801f4e4 <st_prep_buffer+0x204>)
 801f444:	681a      	ldr	r2, [r3, #0]
 801f446:	4b2a      	ldr	r3, [pc, #168]	; (801f4f0 <st_prep_buffer+0x210>)
 801f448:	681b      	ldr	r3, [r3, #0]
 801f44a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 801f44c:	629a      	str	r2, [r3, #40]	; 0x28
                pl_block->message= NULL;
 801f44e:	4b25      	ldr	r3, [pc, #148]	; (801f4e4 <st_prep_buffer+0x204>)
 801f450:	681b      	ldr	r3, [r3, #0]
 801f452:	2200      	movs	r2, #0
 801f454:	64da      	str	r2, [r3, #76]	; 0x4c

                // Initialize segment buffer data for generating the segments.
                prep.steps_per_mm = st_prep_block->steps_per_mm;
 801f456:	4b26      	ldr	r3, [pc, #152]	; (801f4f0 <st_prep_buffer+0x210>)
 801f458:	681b      	ldr	r3, [r3, #0]
 801f45a:	69db      	ldr	r3, [r3, #28]
 801f45c:	4a22      	ldr	r2, [pc, #136]	; (801f4e8 <st_prep_buffer+0x208>)
 801f45e:	60d3      	str	r3, [r2, #12]
                prep.steps_remaining = pl_block->step_event_count;
 801f460:	4b20      	ldr	r3, [pc, #128]	; (801f4e4 <st_prep_buffer+0x204>)
 801f462:	681b      	ldr	r3, [r3, #0]
 801f464:	68db      	ldr	r3, [r3, #12]
 801f466:	4a20      	ldr	r2, [pc, #128]	; (801f4e8 <st_prep_buffer+0x208>)
 801f468:	6093      	str	r3, [r2, #8]
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 801f46a:	4b1f      	ldr	r3, [pc, #124]	; (801f4e8 <st_prep_buffer+0x208>)
 801f46c:	68db      	ldr	r3, [r3, #12]
 801f46e:	4619      	mov	r1, r3
 801f470:	4820      	ldr	r0, [pc, #128]	; (801f4f4 <st_prep_buffer+0x214>)
 801f472:	f7e1 fd53 	bl	8000f1c <__aeabi_fdiv>
 801f476:	4603      	mov	r3, r0
 801f478:	461a      	mov	r2, r3
 801f47a:	4b1b      	ldr	r3, [pc, #108]	; (801f4e8 <st_prep_buffer+0x208>)
 801f47c:	611a      	str	r2, [r3, #16]
                prep.dt_remainder = prep.target_position = 0.0f; // Reset for new segment block
 801f47e:	4b1a      	ldr	r3, [pc, #104]	; (801f4e8 <st_prep_buffer+0x208>)
 801f480:	f04f 0200 	mov.w	r2, #0
 801f484:	645a      	str	r2, [r3, #68]	; 0x44
 801f486:	4b18      	ldr	r3, [pc, #96]	; (801f4e8 <st_prep_buffer+0x208>)
 801f488:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801f48a:	4a17      	ldr	r2, [pc, #92]	; (801f4e8 <st_prep_buffer+0x208>)
 801f48c:	6053      	str	r3, [r2, #4]
#ifdef KINEMATICS_API
                prep.rate_multiplier = pl_block->rate_multiplier;
 801f48e:	4b15      	ldr	r3, [pc, #84]	; (801f4e4 <st_prep_buffer+0x204>)
 801f490:	681b      	ldr	r3, [r3, #0]
 801f492:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801f494:	4a14      	ldr	r2, [pc, #80]	; (801f4e8 <st_prep_buffer+0x208>)
 801f496:	6393      	str	r3, [r2, #56]	; 0x38
#endif
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 801f498:	4b11      	ldr	r3, [pc, #68]	; (801f4e0 <st_prep_buffer+0x200>)
 801f49a:	7e1b      	ldrb	r3, [r3, #24]
 801f49c:	f003 0302 	and.w	r3, r3, #2
 801f4a0:	b2db      	uxtb	r3, r3
 801f4a2:	2b00      	cmp	r3, #0
 801f4a4:	d106      	bne.n	801f4b4 <st_prep_buffer+0x1d4>
 801f4a6:	4b10      	ldr	r3, [pc, #64]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4a8:	781b      	ldrb	r3, [r3, #0]
 801f4aa:	f003 0308 	and.w	r3, r3, #8
 801f4ae:	b2db      	uxtb	r3, r3
 801f4b0:	2b00      	cmp	r3, #0
 801f4b2:	d021      	beq.n	801f4f8 <st_prep_buffer+0x218>
                    // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
                    prep.current_speed = prep.exit_speed;
 801f4b4:	4b0c      	ldr	r3, [pc, #48]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f4b8:	4a0b      	ldr	r2, [pc, #44]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4ba:	62d3      	str	r3, [r2, #44]	; 0x2c
                    pl_block->entry_speed_sqr = prep.exit_speed * prep.exit_speed;
 801f4bc:	4b0a      	ldr	r3, [pc, #40]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4be:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f4c0:	4a09      	ldr	r2, [pc, #36]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4c2:	6b52      	ldr	r2, [r2, #52]	; 0x34
 801f4c4:	4907      	ldr	r1, [pc, #28]	; (801f4e4 <st_prep_buffer+0x204>)
 801f4c6:	680c      	ldr	r4, [r1, #0]
 801f4c8:	4611      	mov	r1, r2
 801f4ca:	4618      	mov	r0, r3
 801f4cc:	f7e1 fc72 	bl	8000db4 <__aeabi_fmul>
 801f4d0:	4603      	mov	r3, r0
 801f4d2:	61e3      	str	r3, [r4, #28]
                    prep.recalculate.decel_override = Off;
 801f4d4:	4a04      	ldr	r2, [pc, #16]	; (801f4e8 <st_prep_buffer+0x208>)
 801f4d6:	7813      	ldrb	r3, [r2, #0]
 801f4d8:	f36f 03c3 	bfc	r3, #3, #1
 801f4dc:	7013      	strb	r3, [r2, #0]
 801f4de:	e014      	b.n	801f50a <st_prep_buffer+0x22a>
 801f4e0:	20000d3c 	.word	0x20000d3c
 801f4e4:	20001c68 	.word	0x20001c68
 801f4e8:	20001ca8 	.word	0x20001ca8
 801f4ec:	2000147c 	.word	0x2000147c
 801f4f0:	20001c6c 	.word	0x20001c6c
 801f4f4:	3fa00000 	.word	0x3fa00000
                } else
                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 801f4f8:	4b58      	ldr	r3, [pc, #352]	; (801f65c <st_prep_buffer+0x37c>)
 801f4fa:	681b      	ldr	r3, [r3, #0]
 801f4fc:	69db      	ldr	r3, [r3, #28]
 801f4fe:	4618      	mov	r0, r3
 801f500:	f005 fa7d 	bl	80249fe <sqrtf>
 801f504:	4603      	mov	r3, r0
 801f506:	4a56      	ldr	r2, [pc, #344]	; (801f660 <st_prep_buffer+0x380>)
 801f508:	62d3      	str	r3, [r2, #44]	; 0x2c

                // Setup laser mode variables. RPM rate adjusted motions will always complete a motion with the
                // spindle off.
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted)) {
 801f50a:	4b54      	ldr	r3, [pc, #336]	; (801f65c <st_prep_buffer+0x37c>)
 801f50c:	681b      	ldr	r3, [r3, #0]
 801f50e:	7d1b      	ldrb	r3, [r3, #20]
 801f510:	f3c3 1380 	ubfx	r3, r3, #6, #1
 801f514:	b2db      	uxtb	r3, r3
 801f516:	461a      	mov	r2, r3
 801f518:	4b52      	ldr	r3, [pc, #328]	; (801f664 <st_prep_buffer+0x384>)
 801f51a:	681b      	ldr	r3, [r3, #0]
 801f51c:	2a00      	cmp	r2, #0
 801f51e:	bf14      	ite	ne
 801f520:	2201      	movne	r2, #1
 801f522:	2200      	moveq	r2, #0
 801f524:	b2d2      	uxtb	r2, r2
 801f526:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
 801f52a:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801f52e:	2b00      	cmp	r3, #0
 801f530:	d016      	beq.n	801f560 <st_prep_buffer+0x280>
                    // Pre-compute inverse programmed rate to speed up RPM updating per step segment.
                    prep.inv_feedrate = pl_block->condition.is_laser_ppi_mode ? 1.0f : 1.0f / pl_block->programmed_rate;
 801f532:	4b4a      	ldr	r3, [pc, #296]	; (801f65c <st_prep_buffer+0x37c>)
 801f534:	681b      	ldr	r3, [r3, #0]
 801f536:	7d1b      	ldrb	r3, [r3, #20]
 801f538:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801f53c:	b2db      	uxtb	r3, r3
 801f53e:	2b00      	cmp	r3, #0
 801f540:	d109      	bne.n	801f556 <st_prep_buffer+0x276>
 801f542:	4b46      	ldr	r3, [pc, #280]	; (801f65c <st_prep_buffer+0x37c>)
 801f544:	681b      	ldr	r3, [r3, #0]
 801f546:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f548:	4619      	mov	r1, r3
 801f54a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 801f54e:	f7e1 fce5 	bl	8000f1c <__aeabi_fdiv>
 801f552:	4603      	mov	r3, r0
 801f554:	e001      	b.n	801f55a <st_prep_buffer+0x27a>
 801f556:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 801f55a:	4a41      	ldr	r2, [pc, #260]	; (801f660 <st_prep_buffer+0x380>)
 801f55c:	64d3      	str	r3, [r2, #76]	; 0x4c
 801f55e:	e00b      	b.n	801f578 <st_prep_buffer+0x298>
                } else
                    st_prep_block->dynamic_rpm = !!pl_block->spindle.css;
 801f560:	4b3e      	ldr	r3, [pc, #248]	; (801f65c <st_prep_buffer+0x37c>)
 801f562:	681b      	ldr	r3, [r3, #0]
 801f564:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801f566:	4b3f      	ldr	r3, [pc, #252]	; (801f664 <st_prep_buffer+0x384>)
 801f568:	681b      	ldr	r3, [r3, #0]
 801f56a:	2a00      	cmp	r2, #0
 801f56c:	bf14      	ite	ne
 801f56e:	2201      	movne	r2, #1
 801f570:	2200      	moveq	r2, #0
 801f572:	b2d2      	uxtb	r2, r2
 801f574:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
             Compute the velocity profile of a new planner block based on its entry and exit
             speeds, or recompute the profile of a partially-completed planner block if the
             planner has updated it. For a commanded forced-deceleration, such as from a feed
             hold, override the planner velocities and decelerate to the target exit speed.
            */
            prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 801f578:	4b39      	ldr	r3, [pc, #228]	; (801f660 <st_prep_buffer+0x380>)
 801f57a:	f04f 0200 	mov.w	r2, #0
 801f57e:	629a      	str	r2, [r3, #40]	; 0x28
            float inv_2_accel = 0.5f / pl_block->acceleration;
 801f580:	4b36      	ldr	r3, [pc, #216]	; (801f65c <st_prep_buffer+0x37c>)
 801f582:	681b      	ldr	r3, [r3, #0]
 801f584:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f586:	4619      	mov	r1, r3
 801f588:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
 801f58c:	f7e1 fcc6 	bl	8000f1c <__aeabi_fdiv>
 801f590:	4603      	mov	r3, r0
 801f592:	633b      	str	r3, [r7, #48]	; 0x30

            if (sys.step_control.execute_hold) { // [Forced Deceleration to Zero Velocity]
 801f594:	4b34      	ldr	r3, [pc, #208]	; (801f668 <st_prep_buffer+0x388>)
 801f596:	7e1b      	ldrb	r3, [r3, #24]
 801f598:	f003 0302 	and.w	r3, r3, #2
 801f59c:	b2db      	uxtb	r3, r3
 801f59e:	2b00      	cmp	r3, #0
 801f5a0:	d044      	beq.n	801f62c <st_prep_buffer+0x34c>
                // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
                // the planner block profile, enforcing a deceleration to zero speed.
                prep.ramp_type = Ramp_Decel;
 801f5a2:	4b2f      	ldr	r3, [pc, #188]	; (801f660 <st_prep_buffer+0x380>)
 801f5a4:	2202      	movs	r2, #2
 801f5a6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                // Compute decelerate distance relative to end of block.
                float decel_dist = pl_block->millimeters - inv_2_accel * pl_block->entry_speed_sqr;
 801f5aa:	4b2c      	ldr	r3, [pc, #176]	; (801f65c <st_prep_buffer+0x37c>)
 801f5ac:	681b      	ldr	r3, [r3, #0]
 801f5ae:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 801f5b0:	4b2a      	ldr	r3, [pc, #168]	; (801f65c <st_prep_buffer+0x37c>)
 801f5b2:	681b      	ldr	r3, [r3, #0]
 801f5b4:	69db      	ldr	r3, [r3, #28]
 801f5b6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f5b8:	4618      	mov	r0, r3
 801f5ba:	f7e1 fbfb 	bl	8000db4 <__aeabi_fmul>
 801f5be:	4603      	mov	r3, r0
 801f5c0:	4619      	mov	r1, r3
 801f5c2:	4620      	mov	r0, r4
 801f5c4:	f7e1 faec 	bl	8000ba0 <__aeabi_fsub>
 801f5c8:	4603      	mov	r3, r0
 801f5ca:	623b      	str	r3, [r7, #32]
                if (decel_dist < 0.0f) {
 801f5cc:	f04f 0100 	mov.w	r1, #0
 801f5d0:	6a38      	ldr	r0, [r7, #32]
 801f5d2:	f7e1 fd8d 	bl	80010f0 <__aeabi_fcmplt>
 801f5d6:	4603      	mov	r3, r0
 801f5d8:	2b00      	cmp	r3, #0
 801f5da:	d01f      	beq.n	801f61c <st_prep_buffer+0x33c>
                    // Deceleration through entire planner block. End of feed hold is not in this block.
                    prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 801f5dc:	4b1f      	ldr	r3, [pc, #124]	; (801f65c <st_prep_buffer+0x37c>)
 801f5de:	681b      	ldr	r3, [r3, #0]
 801f5e0:	69dc      	ldr	r4, [r3, #28]
 801f5e2:	4b1e      	ldr	r3, [pc, #120]	; (801f65c <st_prep_buffer+0x37c>)
 801f5e4:	681b      	ldr	r3, [r3, #0]
 801f5e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f5e8:	4619      	mov	r1, r3
 801f5ea:	4618      	mov	r0, r3
 801f5ec:	f7e1 fada 	bl	8000ba4 <__addsf3>
 801f5f0:	4603      	mov	r3, r0
 801f5f2:	461a      	mov	r2, r3
 801f5f4:	4b19      	ldr	r3, [pc, #100]	; (801f65c <st_prep_buffer+0x37c>)
 801f5f6:	681b      	ldr	r3, [r3, #0]
 801f5f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f5fa:	4619      	mov	r1, r3
 801f5fc:	4610      	mov	r0, r2
 801f5fe:	f7e1 fbd9 	bl	8000db4 <__aeabi_fmul>
 801f602:	4603      	mov	r3, r0
 801f604:	4619      	mov	r1, r3
 801f606:	4620      	mov	r0, r4
 801f608:	f7e1 faca 	bl	8000ba0 <__aeabi_fsub>
 801f60c:	4603      	mov	r3, r0
 801f60e:	4618      	mov	r0, r3
 801f610:	f005 f9f5 	bl	80249fe <sqrtf>
 801f614:	4603      	mov	r3, r0
 801f616:	4a12      	ldr	r2, [pc, #72]	; (801f660 <st_prep_buffer+0x380>)
 801f618:	6353      	str	r3, [r2, #52]	; 0x34
 801f61a:	e149      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                } else {
                    prep.mm_complete = decel_dist; // End of feed hold.
 801f61c:	4a10      	ldr	r2, [pc, #64]	; (801f660 <st_prep_buffer+0x380>)
 801f61e:	6a3b      	ldr	r3, [r7, #32]
 801f620:	6293      	str	r3, [r2, #40]	; 0x28
                    prep.exit_speed = 0.0f;
 801f622:	4b0f      	ldr	r3, [pc, #60]	; (801f660 <st_prep_buffer+0x380>)
 801f624:	f04f 0200 	mov.w	r2, #0
 801f628:	635a      	str	r2, [r3, #52]	; 0x34
 801f62a:	e141      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                }
            } else { // [Normal Operation]
                // Compute or recompute velocity profile parameters of the prepped planner block.
                prep.ramp_type = Ramp_Accel; // Initialize as acceleration ramp.
 801f62c:	4b0c      	ldr	r3, [pc, #48]	; (801f660 <st_prep_buffer+0x380>)
 801f62e:	2200      	movs	r2, #0
 801f630:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                prep.accelerate_until = pl_block->millimeters;
 801f634:	4b09      	ldr	r3, [pc, #36]	; (801f65c <st_prep_buffer+0x37c>)
 801f636:	681b      	ldr	r3, [r3, #0]
 801f638:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f63a:	4a09      	ldr	r2, [pc, #36]	; (801f660 <st_prep_buffer+0x380>)
 801f63c:	63d3      	str	r3, [r2, #60]	; 0x3c

                float exit_speed_sqr;
                if (sys.step_control.execute_sys_motion)
 801f63e:	4b0a      	ldr	r3, [pc, #40]	; (801f668 <st_prep_buffer+0x388>)
 801f640:	7e1b      	ldrb	r3, [r3, #24]
 801f642:	f003 0304 	and.w	r3, r3, #4
 801f646:	b2db      	uxtb	r3, r3
 801f648:	2b00      	cmp	r3, #0
 801f64a:	d00f      	beq.n	801f66c <st_prep_buffer+0x38c>
                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
 801f64c:	f04f 0300 	mov.w	r3, #0
 801f650:	653b      	str	r3, [r7, #80]	; 0x50
 801f652:	4a03      	ldr	r2, [pc, #12]	; (801f660 <st_prep_buffer+0x380>)
 801f654:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801f656:	6353      	str	r3, [r2, #52]	; 0x34
 801f658:	e011      	b.n	801f67e <st_prep_buffer+0x39e>
 801f65a:	bf00      	nop
 801f65c:	20001c68 	.word	0x20001c68
 801f660:	20001ca8 	.word	0x20001ca8
 801f664:	20001c6c 	.word	0x20001c6c
 801f668:	20000d3c 	.word	0x20000d3c
                else {
                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 801f66c:	f7f2 f94a 	bl	8011904 <plan_get_exec_block_exit_speed_sqr>
 801f670:	6538      	str	r0, [r7, #80]	; 0x50
                    prep.exit_speed = sqrtf(exit_speed_sqr);
 801f672:	6d38      	ldr	r0, [r7, #80]	; 0x50
 801f674:	f005 f9c3 	bl	80249fe <sqrtf>
 801f678:	4603      	mov	r3, r0
 801f67a:	4a87      	ldr	r2, [pc, #540]	; (801f898 <st_prep_buffer+0x5b8>)
 801f67c:	6353      	str	r3, [r2, #52]	; 0x34
                }

                float nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 801f67e:	4b87      	ldr	r3, [pc, #540]	; (801f89c <st_prep_buffer+0x5bc>)
 801f680:	681b      	ldr	r3, [r3, #0]
 801f682:	4618      	mov	r0, r3
 801f684:	f7f2 f96c 	bl	8011960 <plan_compute_profile_nominal_speed>
 801f688:	62f8      	str	r0, [r7, #44]	; 0x2c
                float nominal_speed_sqr = nominal_speed * nominal_speed;
 801f68a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801f68c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801f68e:	f7e1 fb91 	bl	8000db4 <__aeabi_fmul>
 801f692:	4603      	mov	r3, r0
 801f694:	62bb      	str	r3, [r7, #40]	; 0x28
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 801f696:	4b81      	ldr	r3, [pc, #516]	; (801f89c <st_prep_buffer+0x5bc>)
 801f698:	681b      	ldr	r3, [r3, #0]
 801f69a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 801f69c:	4b7f      	ldr	r3, [pc, #508]	; (801f89c <st_prep_buffer+0x5bc>)
 801f69e:	681b      	ldr	r3, [r3, #0]
 801f6a0:	69db      	ldr	r3, [r3, #28]
 801f6a2:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801f6a4:	4618      	mov	r0, r3
 801f6a6:	f7e1 fa7b 	bl	8000ba0 <__aeabi_fsub>
 801f6aa:	4603      	mov	r3, r0
 801f6ac:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f6ae:	4618      	mov	r0, r3
 801f6b0:	f7e1 fb80 	bl	8000db4 <__aeabi_fmul>
 801f6b4:	4603      	mov	r3, r0
 801f6b6:	4619      	mov	r1, r3
 801f6b8:	4620      	mov	r0, r4
 801f6ba:	f7e1 fa73 	bl	8000ba4 <__addsf3>
 801f6be:	4603      	mov	r3, r0
 801f6c0:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 801f6c4:	4618      	mov	r0, r3
 801f6c6:	f7e1 fb75 	bl	8000db4 <__aeabi_fmul>
 801f6ca:	4603      	mov	r3, r0
 801f6cc:	627b      	str	r3, [r7, #36]	; 0x24

                prep.target_feed = nominal_speed;
 801f6ce:	4a72      	ldr	r2, [pc, #456]	; (801f898 <st_prep_buffer+0x5b8>)
 801f6d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f6d2:	6493      	str	r3, [r2, #72]	; 0x48

                if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 801f6d4:	4b71      	ldr	r3, [pc, #452]	; (801f89c <st_prep_buffer+0x5bc>)
 801f6d6:	681b      	ldr	r3, [r3, #0]
 801f6d8:	69db      	ldr	r3, [r3, #28]
 801f6da:	4619      	mov	r1, r3
 801f6dc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801f6de:	f7e1 fd07 	bl	80010f0 <__aeabi_fcmplt>
 801f6e2:	4603      	mov	r3, r0
 801f6e4:	2b00      	cmp	r3, #0
 801f6e6:	d05f      	beq.n	801f7a8 <st_prep_buffer+0x4c8>

                    prep.accelerate_until = pl_block->millimeters - inv_2_accel * (pl_block->entry_speed_sqr - nominal_speed_sqr);
 801f6e8:	4b6c      	ldr	r3, [pc, #432]	; (801f89c <st_prep_buffer+0x5bc>)
 801f6ea:	681b      	ldr	r3, [r3, #0]
 801f6ec:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 801f6ee:	4b6b      	ldr	r3, [pc, #428]	; (801f89c <st_prep_buffer+0x5bc>)
 801f6f0:	681b      	ldr	r3, [r3, #0]
 801f6f2:	69db      	ldr	r3, [r3, #28]
 801f6f4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801f6f6:	4618      	mov	r0, r3
 801f6f8:	f7e1 fa52 	bl	8000ba0 <__aeabi_fsub>
 801f6fc:	4603      	mov	r3, r0
 801f6fe:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f700:	4618      	mov	r0, r3
 801f702:	f7e1 fb57 	bl	8000db4 <__aeabi_fmul>
 801f706:	4603      	mov	r3, r0
 801f708:	4619      	mov	r1, r3
 801f70a:	4620      	mov	r0, r4
 801f70c:	f7e1 fa48 	bl	8000ba0 <__aeabi_fsub>
 801f710:	4603      	mov	r3, r0
 801f712:	461a      	mov	r2, r3
 801f714:	4b60      	ldr	r3, [pc, #384]	; (801f898 <st_prep_buffer+0x5b8>)
 801f716:	63da      	str	r2, [r3, #60]	; 0x3c

                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 801f718:	4b5f      	ldr	r3, [pc, #380]	; (801f898 <st_prep_buffer+0x5b8>)
 801f71a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801f71c:	f04f 0100 	mov.w	r1, #0
 801f720:	4618      	mov	r0, r3
 801f722:	f7e1 fcef 	bl	8001104 <__aeabi_fcmple>
 801f726:	4603      	mov	r3, r0
 801f728:	2b00      	cmp	r3, #0
 801f72a:	d028      	beq.n	801f77e <st_prep_buffer+0x49e>
                        prep.ramp_type = Ramp_Decel;
 801f72c:	4b5a      	ldr	r3, [pc, #360]	; (801f898 <st_prep_buffer+0x5b8>)
 801f72e:	2202      	movs	r2, #2
 801f730:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                        // prep.decelerate_after = pl_block->millimeters;
                        // prep.maximum_speed = prep.current_speed;

                        // Compute override block exit speed since it doesn't match the planner exit speed.
                        prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 801f734:	4b59      	ldr	r3, [pc, #356]	; (801f89c <st_prep_buffer+0x5bc>)
 801f736:	681b      	ldr	r3, [r3, #0]
 801f738:	69dc      	ldr	r4, [r3, #28]
 801f73a:	4b58      	ldr	r3, [pc, #352]	; (801f89c <st_prep_buffer+0x5bc>)
 801f73c:	681b      	ldr	r3, [r3, #0]
 801f73e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f740:	4619      	mov	r1, r3
 801f742:	4618      	mov	r0, r3
 801f744:	f7e1 fa2e 	bl	8000ba4 <__addsf3>
 801f748:	4603      	mov	r3, r0
 801f74a:	461a      	mov	r2, r3
 801f74c:	4b53      	ldr	r3, [pc, #332]	; (801f89c <st_prep_buffer+0x5bc>)
 801f74e:	681b      	ldr	r3, [r3, #0]
 801f750:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f752:	4619      	mov	r1, r3
 801f754:	4610      	mov	r0, r2
 801f756:	f7e1 fb2d 	bl	8000db4 <__aeabi_fmul>
 801f75a:	4603      	mov	r3, r0
 801f75c:	4619      	mov	r1, r3
 801f75e:	4620      	mov	r0, r4
 801f760:	f7e1 fa1e 	bl	8000ba0 <__aeabi_fsub>
 801f764:	4603      	mov	r3, r0
 801f766:	4618      	mov	r0, r3
 801f768:	f005 f949 	bl	80249fe <sqrtf>
 801f76c:	4603      	mov	r3, r0
 801f76e:	4a4a      	ldr	r2, [pc, #296]	; (801f898 <st_prep_buffer+0x5b8>)
 801f770:	6353      	str	r3, [r2, #52]	; 0x34
                        prep.recalculate.decel_override = On; // Flag to load next block as deceleration override.
 801f772:	4a49      	ldr	r2, [pc, #292]	; (801f898 <st_prep_buffer+0x5b8>)
 801f774:	7813      	ldrb	r3, [r2, #0]
 801f776:	f043 0308 	orr.w	r3, r3, #8
 801f77a:	7013      	strb	r3, [r2, #0]
 801f77c:	e098      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                        // Can be tricky since entry speed will be current speed, as in feed holds.
                        // Also, look into near-zero speed handling issues with this.

                    } else {
                        // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
 801f77e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801f780:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801f782:	f7e1 fa0d 	bl	8000ba0 <__aeabi_fsub>
 801f786:	4603      	mov	r3, r0
 801f788:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f78a:	4618      	mov	r0, r3
 801f78c:	f7e1 fb12 	bl	8000db4 <__aeabi_fmul>
 801f790:	4603      	mov	r3, r0
 801f792:	461a      	mov	r2, r3
 801f794:	4b40      	ldr	r3, [pc, #256]	; (801f898 <st_prep_buffer+0x5b8>)
 801f796:	641a      	str	r2, [r3, #64]	; 0x40
                        prep.maximum_speed = nominal_speed;
 801f798:	4a3f      	ldr	r2, [pc, #252]	; (801f898 <st_prep_buffer+0x5b8>)
 801f79a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f79c:	6313      	str	r3, [r2, #48]	; 0x30
                        prep.ramp_type = Ramp_DecelOverride;
 801f79e:	4b3e      	ldr	r3, [pc, #248]	; (801f898 <st_prep_buffer+0x5b8>)
 801f7a0:	2203      	movs	r2, #3
 801f7a2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f7a6:	e083      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                    }
                } else if (intersect_distance > 0.0f) {
 801f7a8:	f04f 0100 	mov.w	r1, #0
 801f7ac:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801f7ae:	f7e1 fcbd 	bl	800112c <__aeabi_fcmpgt>
 801f7b2:	4603      	mov	r3, r0
 801f7b4:	2b00      	cmp	r3, #0
 801f7b6:	d073      	beq.n	801f8a0 <st_prep_buffer+0x5c0>
                    if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 801f7b8:	4b38      	ldr	r3, [pc, #224]	; (801f89c <st_prep_buffer+0x5bc>)
 801f7ba:	681b      	ldr	r3, [r3, #0]
 801f7bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f7be:	4619      	mov	r1, r3
 801f7c0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801f7c2:	f7e1 fc95 	bl	80010f0 <__aeabi_fcmplt>
 801f7c6:	4603      	mov	r3, r0
 801f7c8:	2b00      	cmp	r3, #0
 801f7ca:	d05f      	beq.n	801f88c <st_prep_buffer+0x5ac>
                        // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr);
 801f7cc:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801f7ce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801f7d0:	f7e1 f9e6 	bl	8000ba0 <__aeabi_fsub>
 801f7d4:	4603      	mov	r3, r0
 801f7d6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f7d8:	4618      	mov	r0, r3
 801f7da:	f7e1 faeb 	bl	8000db4 <__aeabi_fmul>
 801f7de:	4603      	mov	r3, r0
 801f7e0:	461a      	mov	r2, r3
 801f7e2:	4b2d      	ldr	r3, [pc, #180]	; (801f898 <st_prep_buffer+0x5b8>)
 801f7e4:	641a      	str	r2, [r3, #64]	; 0x40
                        if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 801f7e6:	4b2c      	ldr	r3, [pc, #176]	; (801f898 <st_prep_buffer+0x5b8>)
 801f7e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801f7ea:	4619      	mov	r1, r3
 801f7ec:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801f7ee:	f7e1 fc9d 	bl	800112c <__aeabi_fcmpgt>
 801f7f2:	4603      	mov	r3, r0
 801f7f4:	2b00      	cmp	r3, #0
 801f7f6:	d029      	beq.n	801f84c <st_prep_buffer+0x56c>
                            prep.maximum_speed = nominal_speed;
 801f7f8:	4a27      	ldr	r2, [pc, #156]	; (801f898 <st_prep_buffer+0x5b8>)
 801f7fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801f7fc:	6313      	str	r3, [r2, #48]	; 0x30
                            if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 801f7fe:	4b27      	ldr	r3, [pc, #156]	; (801f89c <st_prep_buffer+0x5bc>)
 801f800:	681b      	ldr	r3, [r3, #0]
 801f802:	69db      	ldr	r3, [r3, #28]
 801f804:	4619      	mov	r1, r3
 801f806:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801f808:	f7e1 fc68 	bl	80010dc <__aeabi_fcmpeq>
 801f80c:	4603      	mov	r3, r0
 801f80e:	2b00      	cmp	r3, #0
 801f810:	d004      	beq.n	801f81c <st_prep_buffer+0x53c>
                                // Cruise-deceleration or cruise-only type.
                                prep.ramp_type = Ramp_Cruise;
 801f812:	4b21      	ldr	r3, [pc, #132]	; (801f898 <st_prep_buffer+0x5b8>)
 801f814:	2201      	movs	r2, #1
 801f816:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f81a:	e049      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                            } else {
                                // Full-trapezoid or acceleration-cruise types
                                prep.accelerate_until -= inv_2_accel * (nominal_speed_sqr - pl_block->entry_speed_sqr);
 801f81c:	4b1e      	ldr	r3, [pc, #120]	; (801f898 <st_prep_buffer+0x5b8>)
 801f81e:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 801f820:	4b1e      	ldr	r3, [pc, #120]	; (801f89c <st_prep_buffer+0x5bc>)
 801f822:	681b      	ldr	r3, [r3, #0]
 801f824:	69db      	ldr	r3, [r3, #28]
 801f826:	4619      	mov	r1, r3
 801f828:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801f82a:	f7e1 f9b9 	bl	8000ba0 <__aeabi_fsub>
 801f82e:	4603      	mov	r3, r0
 801f830:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f832:	4618      	mov	r0, r3
 801f834:	f7e1 fabe 	bl	8000db4 <__aeabi_fmul>
 801f838:	4603      	mov	r3, r0
 801f83a:	4619      	mov	r1, r3
 801f83c:	4620      	mov	r0, r4
 801f83e:	f7e1 f9af 	bl	8000ba0 <__aeabi_fsub>
 801f842:	4603      	mov	r3, r0
 801f844:	461a      	mov	r2, r3
 801f846:	4b14      	ldr	r3, [pc, #80]	; (801f898 <st_prep_buffer+0x5b8>)
 801f848:	63da      	str	r2, [r3, #60]	; 0x3c
 801f84a:	e031      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                            }
                        } else { // Triangle type
                            prep.accelerate_until = prep.decelerate_after = intersect_distance;
 801f84c:	4a12      	ldr	r2, [pc, #72]	; (801f898 <st_prep_buffer+0x5b8>)
 801f84e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f850:	6413      	str	r3, [r2, #64]	; 0x40
 801f852:	4b11      	ldr	r3, [pc, #68]	; (801f898 <st_prep_buffer+0x5b8>)
 801f854:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801f856:	4a10      	ldr	r2, [pc, #64]	; (801f898 <st_prep_buffer+0x5b8>)
 801f858:	63d3      	str	r3, [r2, #60]	; 0x3c
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 801f85a:	4b10      	ldr	r3, [pc, #64]	; (801f89c <st_prep_buffer+0x5bc>)
 801f85c:	681b      	ldr	r3, [r3, #0]
 801f85e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f860:	4619      	mov	r1, r3
 801f862:	4618      	mov	r0, r3
 801f864:	f7e1 f99e 	bl	8000ba4 <__addsf3>
 801f868:	4603      	mov	r3, r0
 801f86a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801f86c:	4618      	mov	r0, r3
 801f86e:	f7e1 faa1 	bl	8000db4 <__aeabi_fmul>
 801f872:	4603      	mov	r3, r0
 801f874:	6d39      	ldr	r1, [r7, #80]	; 0x50
 801f876:	4618      	mov	r0, r3
 801f878:	f7e1 f994 	bl	8000ba4 <__addsf3>
 801f87c:	4603      	mov	r3, r0
 801f87e:	4618      	mov	r0, r3
 801f880:	f005 f8bd 	bl	80249fe <sqrtf>
 801f884:	4603      	mov	r3, r0
 801f886:	4a04      	ldr	r2, [pc, #16]	; (801f898 <st_prep_buffer+0x5b8>)
 801f888:	6313      	str	r3, [r2, #48]	; 0x30
 801f88a:	e011      	b.n	801f8b0 <st_prep_buffer+0x5d0>
                        }
                    } else { // Deceleration-only type
                        prep.ramp_type = Ramp_Decel;
 801f88c:	4b02      	ldr	r3, [pc, #8]	; (801f898 <st_prep_buffer+0x5b8>)
 801f88e:	2202      	movs	r2, #2
 801f890:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801f894:	e00c      	b.n	801f8b0 <st_prep_buffer+0x5d0>
 801f896:	bf00      	nop
 801f898:	20001ca8 	.word	0x20001ca8
 801f89c:	20001c68 	.word	0x20001c68
                        // prep.decelerate_after = pl_block->millimeters;
                        // prep.maximum_speed = prep.current_speed;
                    }
                } else { // Acceleration-only type
                    prep.accelerate_until = 0.0f;
 801f8a0:	4b97      	ldr	r3, [pc, #604]	; (801fb00 <st_prep_buffer+0x820>)
 801f8a2:	f04f 0200 	mov.w	r2, #0
 801f8a6:	63da      	str	r2, [r3, #60]	; 0x3c
                    // prep.decelerate_after = 0.0f;
                    prep.maximum_speed = prep.exit_speed;
 801f8a8:	4b95      	ldr	r3, [pc, #596]	; (801fb00 <st_prep_buffer+0x820>)
 801f8aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f8ac:	4a94      	ldr	r2, [pc, #592]	; (801fb00 <st_prep_buffer+0x820>)
 801f8ae:	6313      	str	r3, [r2, #48]	; 0x30
                }
            }

            if(state_get() != STATE_HOMING)
 801f8b0:	f7fe f806 	bl	801d8c0 <state_get>
 801f8b4:	4603      	mov	r3, r0
 801f8b6:	2b04      	cmp	r3, #4
 801f8b8:	d012      	beq.n	801f8e0 <st_prep_buffer+0x600>
                sys.step_control.update_spindle_rpm |= pl_block->spindle.hal->cap.laser; // Force update whenever updating block in laser mode.
 801f8ba:	4b92      	ldr	r3, [pc, #584]	; (801fb04 <st_prep_buffer+0x824>)
 801f8bc:	7e1b      	ldrb	r3, [r3, #24]
 801f8be:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801f8c2:	b2da      	uxtb	r2, r3
 801f8c4:	4b90      	ldr	r3, [pc, #576]	; (801fb08 <st_prep_buffer+0x828>)
 801f8c6:	681b      	ldr	r3, [r3, #0]
 801f8c8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801f8ca:	7a9b      	ldrb	r3, [r3, #10]
 801f8cc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801f8d0:	b2db      	uxtb	r3, r3
 801f8d2:	4313      	orrs	r3, r2
 801f8d4:	b2d9      	uxtb	r1, r3
 801f8d6:	4a8b      	ldr	r2, [pc, #556]	; (801fb04 <st_prep_buffer+0x824>)
 801f8d8:	7e13      	ldrb	r3, [r2, #24]
 801f8da:	f361 03c3 	bfi	r3, r1, #3, #1
 801f8de:	7613      	strb	r3, [r2, #24]

            probe_asserted = false;
 801f8e0:	4b8a      	ldr	r3, [pc, #552]	; (801fb0c <st_prep_buffer+0x82c>)
 801f8e2:	2200      	movs	r2, #0
 801f8e4:	701a      	strb	r2, [r3, #0]
        }

        // Block adding new segments after probe is asserted until deceleration is started.
        if(probe_asserted)
 801f8e6:	4b89      	ldr	r3, [pc, #548]	; (801fb0c <st_prep_buffer+0x82c>)
 801f8e8:	781b      	ldrb	r3, [r3, #0]
 801f8ea:	b2db      	uxtb	r3, r3
 801f8ec:	2b00      	cmp	r3, #0
 801f8ee:	f040 83ef 	bne.w	80200d0 <st_prep_buffer+0xdf0>
            return;

        // Initialize new segment
        segment_t *prep_segment = segment_buffer_head;
 801f8f2:	4b87      	ldr	r3, [pc, #540]	; (801fb10 <st_prep_buffer+0x830>)
 801f8f4:	681b      	ldr	r3, [r3, #0]
 801f8f6:	61fb      	str	r3, [r7, #28]

        // Set new segment to point to the current segment data block.
        prep_segment->exec_block = st_prep_block;
 801f8f8:	4b86      	ldr	r3, [pc, #536]	; (801fb14 <st_prep_buffer+0x834>)
 801f8fa:	681a      	ldr	r2, [r3, #0]
 801f8fc:	69fb      	ldr	r3, [r7, #28]
 801f8fe:	609a      	str	r2, [r3, #8]
        prep_segment->update_rpm = NULL;
 801f900:	69fb      	ldr	r3, [r7, #28]
 801f902:	2200      	movs	r2, #0
 801f904:	631a      	str	r2, [r3, #48]	; 0x30
        prep_segment->update_pwm = NULL;
 801f906:	69fb      	ldr	r3, [r7, #28]
 801f908:	2200      	movs	r2, #0
 801f90a:	62da      	str	r2, [r3, #44]	; 0x2c
          acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
          may range from zero to the length of the block. Velocity profiles can end either at
          the end of planner block (typical) or mid-block at the end of a forced deceleration,
          such as from a feed hold.
        */
        float dt_max = DT_SEGMENT; // Maximum segment time
 801f90c:	4b82      	ldr	r3, [pc, #520]	; (801fb18 <st_prep_buffer+0x838>)
 801f90e:	64fb      	str	r3, [r7, #76]	; 0x4c
        float dt = 0.0f; // Initialize segment time
 801f910:	f04f 0300 	mov.w	r3, #0
 801f914:	64bb      	str	r3, [r7, #72]	; 0x48
        float time_var = dt_max; // Time worker variable
 801f916:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801f918:	647b      	str	r3, [r7, #68]	; 0x44
        float mm_var; // mm - Distance worker variable
        float speed_var; // Speed worker variable
        float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
 801f91a:	4b7b      	ldr	r3, [pc, #492]	; (801fb08 <st_prep_buffer+0x828>)
 801f91c:	681b      	ldr	r3, [r3, #0]
 801f91e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f920:	643b      	str	r3, [r7, #64]	; 0x40
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 801f922:	4b77      	ldr	r3, [pc, #476]	; (801fb00 <st_prep_buffer+0x820>)
 801f924:	691b      	ldr	r3, [r3, #16]
 801f926:	4619      	mov	r1, r3
 801f928:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801f92a:	f7e1 f939 	bl	8000ba0 <__aeabi_fsub>
 801f92e:	4603      	mov	r3, r0
 801f930:	63fb      	str	r3, [r7, #60]	; 0x3c

        if (minimum_mm < 0.0f)
 801f932:	f04f 0100 	mov.w	r1, #0
 801f936:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801f938:	f7e1 fbda 	bl	80010f0 <__aeabi_fcmplt>
 801f93c:	4603      	mov	r3, r0
 801f93e:	2b00      	cmp	r3, #0
 801f940:	d002      	beq.n	801f948 <st_prep_buffer+0x668>
            minimum_mm = 0.0f;
 801f942:	f04f 0300 	mov.w	r3, #0
 801f946:	63fb      	str	r3, [r7, #60]	; 0x3c

        do {

            switch (prep.ramp_type) {
 801f948:	4b6d      	ldr	r3, [pc, #436]	; (801fb00 <st_prep_buffer+0x820>)
 801f94a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801f94e:	2b03      	cmp	r3, #3
 801f950:	d008      	beq.n	801f964 <st_prep_buffer+0x684>
 801f952:	2b03      	cmp	r3, #3
 801f954:	f300 8113 	bgt.w	801fb7e <st_prep_buffer+0x89e>
 801f958:	2b00      	cmp	r3, #0
 801f95a:	d068      	beq.n	801fa2e <st_prep_buffer+0x74e>
 801f95c:	2b01      	cmp	r3, #1
 801f95e:	f000 80dd 	beq.w	801fb1c <st_prep_buffer+0x83c>
 801f962:	e10c      	b.n	801fb7e <st_prep_buffer+0x89e>

                case Ramp_DecelOverride:
                    speed_var = pl_block->acceleration * time_var;
 801f964:	4b68      	ldr	r3, [pc, #416]	; (801fb08 <st_prep_buffer+0x828>)
 801f966:	681b      	ldr	r3, [r3, #0]
 801f968:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f96a:	4619      	mov	r1, r3
 801f96c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801f96e:	f7e1 fa21 	bl	8000db4 <__aeabi_fmul>
 801f972:	4603      	mov	r3, r0
 801f974:	61bb      	str	r3, [r7, #24]
                    if ((prep.current_speed - prep.maximum_speed) <= speed_var) {
 801f976:	4b62      	ldr	r3, [pc, #392]	; (801fb00 <st_prep_buffer+0x820>)
 801f978:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801f97a:	4a61      	ldr	r2, [pc, #388]	; (801fb00 <st_prep_buffer+0x820>)
 801f97c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 801f97e:	4611      	mov	r1, r2
 801f980:	4618      	mov	r0, r3
 801f982:	f7e1 f90d 	bl	8000ba0 <__aeabi_fsub>
 801f986:	4603      	mov	r3, r0
 801f988:	4619      	mov	r1, r3
 801f98a:	69b8      	ldr	r0, [r7, #24]
 801f98c:	f7e1 fbc4 	bl	8001118 <__aeabi_fcmpge>
 801f990:	4603      	mov	r3, r0
 801f992:	2b00      	cmp	r3, #0
 801f994:	d028      	beq.n	801f9e8 <st_prep_buffer+0x708>
                        // Cruise or cruise-deceleration types only for deceleration override.
                        mm_remaining = prep.accelerate_until;
 801f996:	4b5a      	ldr	r3, [pc, #360]	; (801fb00 <st_prep_buffer+0x820>)
 801f998:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801f99a:	643b      	str	r3, [r7, #64]	; 0x40
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801f99c:	4b5a      	ldr	r3, [pc, #360]	; (801fb08 <st_prep_buffer+0x828>)
 801f99e:	681b      	ldr	r3, [r3, #0]
 801f9a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f9a2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801f9a4:	4618      	mov	r0, r3
 801f9a6:	f7e1 f8fb 	bl	8000ba0 <__aeabi_fsub>
 801f9aa:	4603      	mov	r3, r0
 801f9ac:	4619      	mov	r1, r3
 801f9ae:	4618      	mov	r0, r3
 801f9b0:	f7e1 f8f8 	bl	8000ba4 <__addsf3>
 801f9b4:	4603      	mov	r3, r0
 801f9b6:	461c      	mov	r4, r3
 801f9b8:	4b51      	ldr	r3, [pc, #324]	; (801fb00 <st_prep_buffer+0x820>)
 801f9ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801f9bc:	4a50      	ldr	r2, [pc, #320]	; (801fb00 <st_prep_buffer+0x820>)
 801f9be:	6b12      	ldr	r2, [r2, #48]	; 0x30
 801f9c0:	4611      	mov	r1, r2
 801f9c2:	4618      	mov	r0, r3
 801f9c4:	f7e1 f8ee 	bl	8000ba4 <__addsf3>
 801f9c8:	4603      	mov	r3, r0
 801f9ca:	4619      	mov	r1, r3
 801f9cc:	4620      	mov	r0, r4
 801f9ce:	f7e1 faa5 	bl	8000f1c <__aeabi_fdiv>
 801f9d2:	4603      	mov	r3, r0
 801f9d4:	647b      	str	r3, [r7, #68]	; 0x44
                        prep.ramp_type = Ramp_Cruise;
 801f9d6:	4b4a      	ldr	r3, [pc, #296]	; (801fb00 <st_prep_buffer+0x820>)
 801f9d8:	2201      	movs	r2, #1
 801f9da:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                        prep.current_speed = prep.maximum_speed;
 801f9de:	4b48      	ldr	r3, [pc, #288]	; (801fb00 <st_prep_buffer+0x820>)
 801f9e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f9e2:	4a47      	ldr	r2, [pc, #284]	; (801fb00 <st_prep_buffer+0x820>)
 801f9e4:	62d3      	str	r3, [r2, #44]	; 0x2c
                    } else {// Mid-deceleration override ramp.
                        mm_remaining -= time_var * (prep.current_speed - 0.5f * speed_var);
                        prep.current_speed -= speed_var;
                    }
                    break;
 801f9e6:	e12d      	b.n	801fc44 <st_prep_buffer+0x964>
                        mm_remaining -= time_var * (prep.current_speed - 0.5f * speed_var);
 801f9e8:	4b45      	ldr	r3, [pc, #276]	; (801fb00 <st_prep_buffer+0x820>)
 801f9ea:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 801f9ec:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 801f9f0:	69b8      	ldr	r0, [r7, #24]
 801f9f2:	f7e1 f9df 	bl	8000db4 <__aeabi_fmul>
 801f9f6:	4603      	mov	r3, r0
 801f9f8:	4619      	mov	r1, r3
 801f9fa:	4620      	mov	r0, r4
 801f9fc:	f7e1 f8d0 	bl	8000ba0 <__aeabi_fsub>
 801fa00:	4603      	mov	r3, r0
 801fa02:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801fa04:	4618      	mov	r0, r3
 801fa06:	f7e1 f9d5 	bl	8000db4 <__aeabi_fmul>
 801fa0a:	4603      	mov	r3, r0
 801fa0c:	4619      	mov	r1, r3
 801fa0e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fa10:	f7e1 f8c6 	bl	8000ba0 <__aeabi_fsub>
 801fa14:	4603      	mov	r3, r0
 801fa16:	643b      	str	r3, [r7, #64]	; 0x40
                        prep.current_speed -= speed_var;
 801fa18:	4b39      	ldr	r3, [pc, #228]	; (801fb00 <st_prep_buffer+0x820>)
 801fa1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801fa1c:	69b9      	ldr	r1, [r7, #24]
 801fa1e:	4618      	mov	r0, r3
 801fa20:	f7e1 f8be 	bl	8000ba0 <__aeabi_fsub>
 801fa24:	4603      	mov	r3, r0
 801fa26:	461a      	mov	r2, r3
 801fa28:	4b35      	ldr	r3, [pc, #212]	; (801fb00 <st_prep_buffer+0x820>)
 801fa2a:	62da      	str	r2, [r3, #44]	; 0x2c
                    break;
 801fa2c:	e10a      	b.n	801fc44 <st_prep_buffer+0x964>

                case Ramp_Accel:
                    // NOTE: Acceleration ramp only computes during first do-while loop.
                    speed_var = pl_block->acceleration * time_var;
 801fa2e:	4b36      	ldr	r3, [pc, #216]	; (801fb08 <st_prep_buffer+0x828>)
 801fa30:	681b      	ldr	r3, [r3, #0]
 801fa32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801fa34:	4619      	mov	r1, r3
 801fa36:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801fa38:	f7e1 f9bc 	bl	8000db4 <__aeabi_fmul>
 801fa3c:	4603      	mov	r3, r0
 801fa3e:	61bb      	str	r3, [r7, #24]
                    mm_remaining -= time_var * (prep.current_speed + 0.5f * speed_var);
 801fa40:	4b2f      	ldr	r3, [pc, #188]	; (801fb00 <st_prep_buffer+0x820>)
 801fa42:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 801fa44:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 801fa48:	69b8      	ldr	r0, [r7, #24]
 801fa4a:	f7e1 f9b3 	bl	8000db4 <__aeabi_fmul>
 801fa4e:	4603      	mov	r3, r0
 801fa50:	4619      	mov	r1, r3
 801fa52:	4620      	mov	r0, r4
 801fa54:	f7e1 f8a6 	bl	8000ba4 <__addsf3>
 801fa58:	4603      	mov	r3, r0
 801fa5a:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801fa5c:	4618      	mov	r0, r3
 801fa5e:	f7e1 f9a9 	bl	8000db4 <__aeabi_fmul>
 801fa62:	4603      	mov	r3, r0
 801fa64:	4619      	mov	r1, r3
 801fa66:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fa68:	f7e1 f89a 	bl	8000ba0 <__aeabi_fsub>
 801fa6c:	4603      	mov	r3, r0
 801fa6e:	643b      	str	r3, [r7, #64]	; 0x40
                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 801fa70:	4b23      	ldr	r3, [pc, #140]	; (801fb00 <st_prep_buffer+0x820>)
 801fa72:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801fa74:	4619      	mov	r1, r3
 801fa76:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fa78:	f7e1 fb3a 	bl	80010f0 <__aeabi_fcmplt>
 801fa7c:	4603      	mov	r3, r0
 801fa7e:	2b00      	cmp	r3, #0
 801fa80:	d033      	beq.n	801faea <st_prep_buffer+0x80a>
                        // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
                        mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 801fa82:	4b1f      	ldr	r3, [pc, #124]	; (801fb00 <st_prep_buffer+0x820>)
 801fa84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801fa86:	643b      	str	r3, [r7, #64]	; 0x40
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801fa88:	4b1f      	ldr	r3, [pc, #124]	; (801fb08 <st_prep_buffer+0x828>)
 801fa8a:	681b      	ldr	r3, [r3, #0]
 801fa8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fa8e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 801fa90:	4618      	mov	r0, r3
 801fa92:	f7e1 f885 	bl	8000ba0 <__aeabi_fsub>
 801fa96:	4603      	mov	r3, r0
 801fa98:	4619      	mov	r1, r3
 801fa9a:	4618      	mov	r0, r3
 801fa9c:	f7e1 f882 	bl	8000ba4 <__addsf3>
 801faa0:	4603      	mov	r3, r0
 801faa2:	461c      	mov	r4, r3
 801faa4:	4b16      	ldr	r3, [pc, #88]	; (801fb00 <st_prep_buffer+0x820>)
 801faa6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801faa8:	4a15      	ldr	r2, [pc, #84]	; (801fb00 <st_prep_buffer+0x820>)
 801faaa:	6b12      	ldr	r2, [r2, #48]	; 0x30
 801faac:	4611      	mov	r1, r2
 801faae:	4618      	mov	r0, r3
 801fab0:	f7e1 f878 	bl	8000ba4 <__addsf3>
 801fab4:	4603      	mov	r3, r0
 801fab6:	4619      	mov	r1, r3
 801fab8:	4620      	mov	r0, r4
 801faba:	f7e1 fa2f 	bl	8000f1c <__aeabi_fdiv>
 801fabe:	4603      	mov	r3, r0
 801fac0:	647b      	str	r3, [r7, #68]	; 0x44
                        prep.ramp_type = mm_remaining == prep.decelerate_after ? Ramp_Decel : Ramp_Cruise;
 801fac2:	4b0f      	ldr	r3, [pc, #60]	; (801fb00 <st_prep_buffer+0x820>)
 801fac4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801fac6:	4619      	mov	r1, r3
 801fac8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801faca:	f7e1 fb07 	bl	80010dc <__aeabi_fcmpeq>
 801face:	4603      	mov	r3, r0
 801fad0:	2b00      	cmp	r3, #0
 801fad2:	d001      	beq.n	801fad8 <st_prep_buffer+0x7f8>
 801fad4:	2202      	movs	r2, #2
 801fad6:	e000      	b.n	801fada <st_prep_buffer+0x7fa>
 801fad8:	2201      	movs	r2, #1
 801fada:	4b09      	ldr	r3, [pc, #36]	; (801fb00 <st_prep_buffer+0x820>)
 801fadc:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                        prep.current_speed = prep.maximum_speed;
 801fae0:	4b07      	ldr	r3, [pc, #28]	; (801fb00 <st_prep_buffer+0x820>)
 801fae2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801fae4:	4a06      	ldr	r2, [pc, #24]	; (801fb00 <st_prep_buffer+0x820>)
 801fae6:	62d3      	str	r3, [r2, #44]	; 0x2c
                    } else // Acceleration only.
                        prep.current_speed += speed_var;
                    break;
 801fae8:	e0ac      	b.n	801fc44 <st_prep_buffer+0x964>
                        prep.current_speed += speed_var;
 801faea:	4b05      	ldr	r3, [pc, #20]	; (801fb00 <st_prep_buffer+0x820>)
 801faec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801faee:	69b9      	ldr	r1, [r7, #24]
 801faf0:	4618      	mov	r0, r3
 801faf2:	f7e1 f857 	bl	8000ba4 <__addsf3>
 801faf6:	4603      	mov	r3, r0
 801faf8:	461a      	mov	r2, r3
 801fafa:	4b01      	ldr	r3, [pc, #4]	; (801fb00 <st_prep_buffer+0x820>)
 801fafc:	62da      	str	r2, [r3, #44]	; 0x2c
                    break;
 801fafe:	e0a1      	b.n	801fc44 <st_prep_buffer+0x964>
 801fb00:	20001ca8 	.word	0x20001ca8
 801fb04:	20000d3c 	.word	0x20000d3c
 801fb08:	20001c68 	.word	0x20001c68
 801fb0c:	20001c54 	.word	0x20001c54
 801fb10:	20001c60 	.word	0x20001c60
 801fb14:	20001c6c 	.word	0x20001c6c
 801fb18:	392ec33e 	.word	0x392ec33e

                case Ramp_Cruise:
                    // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
                    // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
                    //   prevent this, simply enforce a minimum speed threshold in the planner.
                    mm_var = mm_remaining - prep.maximum_speed * time_var;
 801fb1c:	4b8c      	ldr	r3, [pc, #560]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801fb20:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801fb22:	4618      	mov	r0, r3
 801fb24:	f7e1 f946 	bl	8000db4 <__aeabi_fmul>
 801fb28:	4603      	mov	r3, r0
 801fb2a:	4619      	mov	r1, r3
 801fb2c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fb2e:	f7e1 f837 	bl	8000ba0 <__aeabi_fsub>
 801fb32:	4603      	mov	r3, r0
 801fb34:	617b      	str	r3, [r7, #20]
                    if (mm_var < prep.decelerate_after) { // End of cruise.
 801fb36:	4b86      	ldr	r3, [pc, #536]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801fb3a:	4619      	mov	r1, r3
 801fb3c:	6978      	ldr	r0, [r7, #20]
 801fb3e:	f7e1 fad7 	bl	80010f0 <__aeabi_fcmplt>
 801fb42:	4603      	mov	r3, r0
 801fb44:	2b00      	cmp	r3, #0
 801fb46:	d017      	beq.n	801fb78 <st_prep_buffer+0x898>
                        // Cruise-deceleration junction or end of block.
                        time_var = (mm_remaining - prep.decelerate_after) / prep.maximum_speed;
 801fb48:	4b81      	ldr	r3, [pc, #516]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801fb4c:	4619      	mov	r1, r3
 801fb4e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fb50:	f7e1 f826 	bl	8000ba0 <__aeabi_fsub>
 801fb54:	4603      	mov	r3, r0
 801fb56:	461a      	mov	r2, r3
 801fb58:	4b7d      	ldr	r3, [pc, #500]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801fb5c:	4619      	mov	r1, r3
 801fb5e:	4610      	mov	r0, r2
 801fb60:	f7e1 f9dc 	bl	8000f1c <__aeabi_fdiv>
 801fb64:	4603      	mov	r3, r0
 801fb66:	647b      	str	r3, [r7, #68]	; 0x44
                        mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
 801fb68:	4b79      	ldr	r3, [pc, #484]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb6a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801fb6c:	643b      	str	r3, [r7, #64]	; 0x40
                        prep.ramp_type = Ramp_Decel;
 801fb6e:	4b78      	ldr	r3, [pc, #480]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb70:	2202      	movs	r2, #2
 801fb72:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
                    } else // Cruising only.
                        mm_remaining = mm_var;
                    break;
 801fb76:	e065      	b.n	801fc44 <st_prep_buffer+0x964>
                        mm_remaining = mm_var;
 801fb78:	697b      	ldr	r3, [r7, #20]
 801fb7a:	643b      	str	r3, [r7, #64]	; 0x40
                    break;
 801fb7c:	e062      	b.n	801fc44 <st_prep_buffer+0x964>

                default: // case Ramp_Decel:
                    // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
                    speed_var = pl_block->acceleration * time_var; // Used as delta speed (mm/min)
 801fb7e:	4b75      	ldr	r3, [pc, #468]	; (801fd54 <st_prep_buffer+0xa74>)
 801fb80:	681b      	ldr	r3, [r3, #0]
 801fb82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801fb84:	4619      	mov	r1, r3
 801fb86:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801fb88:	f7e1 f914 	bl	8000db4 <__aeabi_fmul>
 801fb8c:	4603      	mov	r3, r0
 801fb8e:	61bb      	str	r3, [r7, #24]
                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 801fb90:	4b6f      	ldr	r3, [pc, #444]	; (801fd50 <st_prep_buffer+0xa70>)
 801fb92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801fb94:	4619      	mov	r1, r3
 801fb96:	69b8      	ldr	r0, [r7, #24]
 801fb98:	f7e1 faaa 	bl	80010f0 <__aeabi_fcmplt>
 801fb9c:	4603      	mov	r3, r0
 801fb9e:	2b00      	cmp	r3, #0
 801fba0:	d02d      	beq.n	801fbfe <st_prep_buffer+0x91e>
                        // Compute distance from end of segment to end of block.
                        mm_var = mm_remaining - time_var * (prep.current_speed - 0.5f * speed_var); // (mm)
 801fba2:	4b6b      	ldr	r3, [pc, #428]	; (801fd50 <st_prep_buffer+0xa70>)
 801fba4:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 801fba6:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 801fbaa:	69b8      	ldr	r0, [r7, #24]
 801fbac:	f7e1 f902 	bl	8000db4 <__aeabi_fmul>
 801fbb0:	4603      	mov	r3, r0
 801fbb2:	4619      	mov	r1, r3
 801fbb4:	4620      	mov	r0, r4
 801fbb6:	f7e0 fff3 	bl	8000ba0 <__aeabi_fsub>
 801fbba:	4603      	mov	r3, r0
 801fbbc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801fbbe:	4618      	mov	r0, r3
 801fbc0:	f7e1 f8f8 	bl	8000db4 <__aeabi_fmul>
 801fbc4:	4603      	mov	r3, r0
 801fbc6:	4619      	mov	r1, r3
 801fbc8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fbca:	f7e0 ffe9 	bl	8000ba0 <__aeabi_fsub>
 801fbce:	4603      	mov	r3, r0
 801fbd0:	617b      	str	r3, [r7, #20]
                        if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 801fbd2:	4b5f      	ldr	r3, [pc, #380]	; (801fd50 <st_prep_buffer+0xa70>)
 801fbd4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fbd6:	4619      	mov	r1, r3
 801fbd8:	6978      	ldr	r0, [r7, #20]
 801fbda:	f7e1 faa7 	bl	800112c <__aeabi_fcmpgt>
 801fbde:	4603      	mov	r3, r0
 801fbe0:	2b00      	cmp	r3, #0
 801fbe2:	d00c      	beq.n	801fbfe <st_prep_buffer+0x91e>
                            mm_remaining = mm_var;
 801fbe4:	697b      	ldr	r3, [r7, #20]
 801fbe6:	643b      	str	r3, [r7, #64]	; 0x40
                            prep.current_speed -= speed_var;
 801fbe8:	4b59      	ldr	r3, [pc, #356]	; (801fd50 <st_prep_buffer+0xa70>)
 801fbea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801fbec:	69b9      	ldr	r1, [r7, #24]
 801fbee:	4618      	mov	r0, r3
 801fbf0:	f7e0 ffd6 	bl	8000ba0 <__aeabi_fsub>
 801fbf4:	4603      	mov	r3, r0
 801fbf6:	461a      	mov	r2, r3
 801fbf8:	4b55      	ldr	r3, [pc, #340]	; (801fd50 <st_prep_buffer+0xa70>)
 801fbfa:	62da      	str	r2, [r3, #44]	; 0x2c
                            break; // Segment complete. Exit switch-case statement. Continue do-while loop.
 801fbfc:	e022      	b.n	801fc44 <st_prep_buffer+0x964>
                        }
                    }
                    // Otherwise, at end of block or end of forced-deceleration.
                    time_var = 2.0f * (mm_remaining - prep.mm_complete) / (prep.current_speed + prep.exit_speed);
 801fbfe:	4b54      	ldr	r3, [pc, #336]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fc02:	4619      	mov	r1, r3
 801fc04:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fc06:	f7e0 ffcb 	bl	8000ba0 <__aeabi_fsub>
 801fc0a:	4603      	mov	r3, r0
 801fc0c:	4619      	mov	r1, r3
 801fc0e:	4618      	mov	r0, r3
 801fc10:	f7e0 ffc8 	bl	8000ba4 <__addsf3>
 801fc14:	4603      	mov	r3, r0
 801fc16:	461c      	mov	r4, r3
 801fc18:	4b4d      	ldr	r3, [pc, #308]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801fc1c:	4a4c      	ldr	r2, [pc, #304]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc1e:	6b52      	ldr	r2, [r2, #52]	; 0x34
 801fc20:	4611      	mov	r1, r2
 801fc22:	4618      	mov	r0, r3
 801fc24:	f7e0 ffbe 	bl	8000ba4 <__addsf3>
 801fc28:	4603      	mov	r3, r0
 801fc2a:	4619      	mov	r1, r3
 801fc2c:	4620      	mov	r0, r4
 801fc2e:	f7e1 f975 	bl	8000f1c <__aeabi_fdiv>
 801fc32:	4603      	mov	r3, r0
 801fc34:	647b      	str	r3, [r7, #68]	; 0x44
                    mm_remaining = prep.mm_complete;
 801fc36:	4b46      	ldr	r3, [pc, #280]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fc3a:	643b      	str	r3, [r7, #64]	; 0x40
                    prep.current_speed = prep.exit_speed;
 801fc3c:	4b44      	ldr	r3, [pc, #272]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801fc40:	4a43      	ldr	r2, [pc, #268]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc42:	62d3      	str	r3, [r2, #44]	; 0x2c
            }

            dt += time_var; // Add computed ramp time to total segment time.
 801fc44:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801fc46:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801fc48:	f7e0 ffac 	bl	8000ba4 <__addsf3>
 801fc4c:	4603      	mov	r3, r0
 801fc4e:	64bb      	str	r3, [r7, #72]	; 0x48

            if (dt < dt_max)
 801fc50:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801fc52:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801fc54:	f7e1 fa4c 	bl	80010f0 <__aeabi_fcmplt>
 801fc58:	4603      	mov	r3, r0
 801fc5a:	2b00      	cmp	r3, #0
 801fc5c:	d006      	beq.n	801fc6c <st_prep_buffer+0x98c>
                time_var = dt_max - dt;// **Incomplete** At ramp junction.
 801fc5e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801fc60:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801fc62:	f7e0 ff9d 	bl	8000ba0 <__aeabi_fsub>
 801fc66:	4603      	mov	r3, r0
 801fc68:	647b      	str	r3, [r7, #68]	; 0x44
 801fc6a:	e013      	b.n	801fc94 <st_prep_buffer+0x9b4>
            else {
                if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 801fc6c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801fc6e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fc70:	f7e1 fa5c 	bl	800112c <__aeabi_fcmpgt>
 801fc74:	4603      	mov	r3, r0
 801fc76:	2b00      	cmp	r3, #0
 801fc78:	d100      	bne.n	801fc7c <st_prep_buffer+0x99c>
                    // Increase segment time to ensure at least one step in segment. Override and loop
                    // through distance calculations until minimum_mm or mm_complete.
                    dt_max += DT_SEGMENT;
                    time_var = dt_max - dt;
                } else
                    break; // **Complete** Exit loop. Segment execution time maxed.
 801fc7a:	e015      	b.n	801fca8 <st_prep_buffer+0x9c8>
                    dt_max += DT_SEGMENT;
 801fc7c:	4936      	ldr	r1, [pc, #216]	; (801fd58 <st_prep_buffer+0xa78>)
 801fc7e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801fc80:	f7e0 ff90 	bl	8000ba4 <__addsf3>
 801fc84:	4603      	mov	r3, r0
 801fc86:	64fb      	str	r3, [r7, #76]	; 0x4c
                    time_var = dt_max - dt;
 801fc88:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801fc8a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801fc8c:	f7e0 ff88 	bl	8000ba0 <__aeabi_fsub>
 801fc90:	4603      	mov	r3, r0
 801fc92:	647b      	str	r3, [r7, #68]	; 0x44
            }

        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 801fc94:	4b2e      	ldr	r3, [pc, #184]	; (801fd50 <st_prep_buffer+0xa70>)
 801fc96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fc98:	4619      	mov	r1, r3
 801fc9a:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fc9c:	f7e1 fa46 	bl	800112c <__aeabi_fcmpgt>
 801fca0:	4603      	mov	r3, r0
 801fca2:	2b00      	cmp	r3, #0
 801fca4:	f47f ae50 	bne.w	801f948 <st_prep_buffer+0x668>

        /* -----------------------------------------------------------------------------------
           Compute spindle spindle speed for step segment
        */

        if (sys.step_control.update_spindle_rpm || st_prep_block->dynamic_rpm) {
 801fca8:	4b2c      	ldr	r3, [pc, #176]	; (801fd5c <st_prep_buffer+0xa7c>)
 801fcaa:	7e1b      	ldrb	r3, [r3, #24]
 801fcac:	f003 0308 	and.w	r3, r3, #8
 801fcb0:	b2db      	uxtb	r3, r3
 801fcb2:	2b00      	cmp	r3, #0
 801fcb4:	d106      	bne.n	801fcc4 <st_prep_buffer+0x9e4>
 801fcb6:	4b2a      	ldr	r3, [pc, #168]	; (801fd60 <st_prep_buffer+0xa80>)
 801fcb8:	681b      	ldr	r3, [r3, #0]
 801fcba:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 801fcbe:	2b00      	cmp	r3, #0
 801fcc0:	f000 80c6 	beq.w	801fe50 <st_prep_buffer+0xb70>

            float rpm;

            if (pl_block->spindle.state.on) {
 801fcc4:	4b23      	ldr	r3, [pc, #140]	; (801fd54 <st_prep_buffer+0xa74>)
 801fcc6:	681b      	ldr	r3, [r3, #0]
 801fcc8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801fccc:	f003 0301 	and.w	r3, r3, #1
 801fcd0:	b2db      	uxtb	r3, r3
 801fcd2:	2b00      	cmp	r3, #0
 801fcd4:	d07b      	beq.n	801fdce <st_prep_buffer+0xaee>
                if(pl_block->spindle.css) {
 801fcd6:	4b1f      	ldr	r3, [pc, #124]	; (801fd54 <st_prep_buffer+0xa74>)
 801fcd8:	681b      	ldr	r3, [r3, #0]
 801fcda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801fcdc:	2b00      	cmp	r3, #0
 801fcde:	d041      	beq.n	801fd64 <st_prep_buffer+0xa84>
                    float npos = (float)(pl_block->step_event_count - prep.steps_remaining) / (float)pl_block->step_event_count;
 801fce0:	4b1c      	ldr	r3, [pc, #112]	; (801fd54 <st_prep_buffer+0xa74>)
 801fce2:	681b      	ldr	r3, [r3, #0]
 801fce4:	68da      	ldr	r2, [r3, #12]
 801fce6:	4b1a      	ldr	r3, [pc, #104]	; (801fd50 <st_prep_buffer+0xa70>)
 801fce8:	689b      	ldr	r3, [r3, #8]
 801fcea:	1ad3      	subs	r3, r2, r3
 801fcec:	4618      	mov	r0, r3
 801fcee:	f7e1 f809 	bl	8000d04 <__aeabi_ui2f>
 801fcf2:	4604      	mov	r4, r0
 801fcf4:	4b17      	ldr	r3, [pc, #92]	; (801fd54 <st_prep_buffer+0xa74>)
 801fcf6:	681b      	ldr	r3, [r3, #0]
 801fcf8:	68db      	ldr	r3, [r3, #12]
 801fcfa:	4618      	mov	r0, r3
 801fcfc:	f7e1 f802 	bl	8000d04 <__aeabi_ui2f>
 801fd00:	4603      	mov	r3, r0
 801fd02:	4619      	mov	r1, r3
 801fd04:	4620      	mov	r0, r4
 801fd06:	f7e1 f909 	bl	8000f1c <__aeabi_fdiv>
 801fd0a:	4603      	mov	r3, r0
 801fd0c:	613b      	str	r3, [r7, #16]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fd0e:	4b11      	ldr	r3, [pc, #68]	; (801fd54 <st_prep_buffer+0xa74>)
 801fd10:	681b      	ldr	r3, [r3, #0]
 801fd12:	6c9c      	ldr	r4, [r3, #72]	; 0x48
                                           pl_block->spindle.rpm + pl_block->spindle.css->delta_rpm * npos,
 801fd14:	4b0f      	ldr	r3, [pc, #60]	; (801fd54 <st_prep_buffer+0xa74>)
 801fd16:	681b      	ldr	r3, [r3, #0]
 801fd18:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 801fd1a:	4b0e      	ldr	r3, [pc, #56]	; (801fd54 <st_prep_buffer+0xa74>)
 801fd1c:	681b      	ldr	r3, [r3, #0]
 801fd1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801fd20:	689b      	ldr	r3, [r3, #8]
 801fd22:	6939      	ldr	r1, [r7, #16]
 801fd24:	4618      	mov	r0, r3
 801fd26:	f7e1 f845 	bl	8000db4 <__aeabi_fmul>
 801fd2a:	4603      	mov	r3, r0
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fd2c:	4619      	mov	r1, r3
 801fd2e:	4628      	mov	r0, r5
 801fd30:	f7e0 ff38 	bl	8000ba4 <__addsf3>
 801fd34:	4603      	mov	r3, r0
 801fd36:	4619      	mov	r1, r3
                                            pl_block->spindle.hal->param->override_pct);
 801fd38:	4b06      	ldr	r3, [pc, #24]	; (801fd54 <st_prep_buffer+0xa74>)
 801fd3a:	681b      	ldr	r3, [r3, #0]
 801fd3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fd3e:	685b      	ldr	r3, [r3, #4]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fd40:	68db      	ldr	r3, [r3, #12]
 801fd42:	461a      	mov	r2, r3
 801fd44:	4620      	mov	r0, r4
 801fd46:	f7fd f977 	bl	801d038 <spindle_set_rpm>
 801fd4a:	63b8      	str	r0, [r7, #56]	; 0x38
 801fd4c:	e048      	b.n	801fde0 <st_prep_buffer+0xb00>
 801fd4e:	bf00      	nop
 801fd50:	20001ca8 	.word	0x20001ca8
 801fd54:	20001c68 	.word	0x20001c68
 801fd58:	392ec33e 	.word	0x392ec33e
 801fd5c:	20000d3c 	.word	0x20000d3c
 801fd60:	20001c6c 	.word	0x20001c6c
                } else {
                    // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.
                    // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE)
                    // but this would be instantaneous only and during a motion. May not matter at all.
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fd64:	4b93      	ldr	r3, [pc, #588]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fd66:	681b      	ldr	r3, [r3, #0]
 801fd68:	6c9c      	ldr	r4, [r3, #72]	; 0x48
                                           pl_block->condition.is_rpm_rate_adjusted && !pl_block->condition.is_laser_ppi_mode
 801fd6a:	4b92      	ldr	r3, [pc, #584]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fd6c:	681b      	ldr	r3, [r3, #0]
 801fd6e:	7d1b      	ldrb	r3, [r3, #20]
 801fd70:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801fd74:	b2db      	uxtb	r3, r3
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fd76:	2b00      	cmp	r3, #0
 801fd78:	d01b      	beq.n	801fdb2 <st_prep_buffer+0xad2>
                                           pl_block->condition.is_rpm_rate_adjusted && !pl_block->condition.is_laser_ppi_mode
 801fd7a:	4b8e      	ldr	r3, [pc, #568]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fd7c:	681b      	ldr	r3, [r3, #0]
 801fd7e:	7d1b      	ldrb	r3, [r3, #20]
 801fd80:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801fd84:	b2db      	uxtb	r3, r3
 801fd86:	2b00      	cmp	r3, #0
 801fd88:	d113      	bne.n	801fdb2 <st_prep_buffer+0xad2>
                                            ? pl_block->spindle.rpm * prep.current_speed * prep.inv_feedrate
 801fd8a:	4b8a      	ldr	r3, [pc, #552]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fd8c:	681b      	ldr	r3, [r3, #0]
 801fd8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801fd90:	4a89      	ldr	r2, [pc, #548]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fd92:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 801fd94:	4611      	mov	r1, r2
 801fd96:	4618      	mov	r0, r3
 801fd98:	f7e1 f80c 	bl	8000db4 <__aeabi_fmul>
 801fd9c:	4603      	mov	r3, r0
 801fd9e:	461a      	mov	r2, r3
 801fda0:	4b85      	ldr	r3, [pc, #532]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fda2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fda4:	4619      	mov	r1, r3
 801fda6:	4610      	mov	r0, r2
 801fda8:	f7e1 f804 	bl	8000db4 <__aeabi_fmul>
 801fdac:	4603      	mov	r3, r0
 801fdae:	4619      	mov	r1, r3
 801fdb0:	e002      	b.n	801fdb8 <st_prep_buffer+0xad8>
                                            : pl_block->spindle.rpm, pl_block->spindle.hal->param->override_pct);
 801fdb2:	4b80      	ldr	r3, [pc, #512]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fdb4:	681b      	ldr	r3, [r3, #0]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fdb6:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
                                            : pl_block->spindle.rpm, pl_block->spindle.hal->param->override_pct);
 801fdb8:	4b7e      	ldr	r3, [pc, #504]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fdba:	681b      	ldr	r3, [r3, #0]
 801fdbc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fdbe:	685b      	ldr	r3, [r3, #4]
                    rpm = spindle_set_rpm(pl_block->spindle.hal,
 801fdc0:	68db      	ldr	r3, [r3, #12]
 801fdc2:	461a      	mov	r2, r3
 801fdc4:	4620      	mov	r0, r4
 801fdc6:	f7fd f937 	bl	801d038 <spindle_set_rpm>
 801fdca:	63b8      	str	r0, [r7, #56]	; 0x38
 801fdcc:	e008      	b.n	801fde0 <st_prep_buffer+0xb00>
                }
            } else
                pl_block->spindle.hal->param->rpm = rpm = 0.0f;
 801fdce:	f04f 0300 	mov.w	r3, #0
 801fdd2:	63bb      	str	r3, [r7, #56]	; 0x38
 801fdd4:	4b77      	ldr	r3, [pc, #476]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fdd6:	681b      	ldr	r3, [r3, #0]
 801fdd8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fdda:	685b      	ldr	r3, [r3, #4]
 801fddc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801fdde:	601a      	str	r2, [r3, #0]

            if(rpm != prep.current_spindle_rpm) {
 801fde0:	4b75      	ldr	r3, [pc, #468]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fde2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801fde4:	4619      	mov	r1, r3
 801fde6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 801fde8:	f7e1 f978 	bl	80010dc <__aeabi_fcmpeq>
 801fdec:	4603      	mov	r3, r0
 801fdee:	2b00      	cmp	r3, #0
 801fdf0:	d12e      	bne.n	801fe50 <st_prep_buffer+0xb70>
                if(pl_block->spindle.hal->get_pwm != NULL) {
 801fdf2:	4b70      	ldr	r3, [pc, #448]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fdf4:	681b      	ldr	r3, [r3, #0]
 801fdf6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fdf8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fdfa:	2b00      	cmp	r3, #0
 801fdfc:	d016      	beq.n	801fe2c <st_prep_buffer+0xb4c>
                    prep.current_spindle_rpm = rpm;
 801fdfe:	4a6e      	ldr	r2, [pc, #440]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fe00:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fe02:	6513      	str	r3, [r2, #80]	; 0x50
                    prep_segment->update_pwm = pl_block->spindle.hal->update_pwm;
 801fe04:	4b6b      	ldr	r3, [pc, #428]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fe06:	681b      	ldr	r3, [r3, #0]
 801fe08:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fe0a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801fe0c:	69fb      	ldr	r3, [r7, #28]
 801fe0e:	62da      	str	r2, [r3, #44]	; 0x2c
                    prep_segment->spindle_pwm = pl_block->spindle.hal->get_pwm(pl_block->spindle.hal, rpm);
 801fe10:	4b68      	ldr	r3, [pc, #416]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fe12:	681b      	ldr	r3, [r3, #0]
 801fe14:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fe16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801fe18:	4a66      	ldr	r2, [pc, #408]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fe1a:	6812      	ldr	r2, [r2, #0]
 801fe1c:	6c92      	ldr	r2, [r2, #72]	; 0x48
 801fe1e:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 801fe20:	4610      	mov	r0, r2
 801fe22:	4798      	blx	r3
 801fe24:	4602      	mov	r2, r0
 801fe26:	69fb      	ldr	r3, [r7, #28]
 801fe28:	61da      	str	r2, [r3, #28]
 801fe2a:	e00c      	b.n	801fe46 <st_prep_buffer+0xb66>
                } else {
                    prep_segment->update_rpm = pl_block->spindle.hal->update_rpm;
 801fe2c:	4b61      	ldr	r3, [pc, #388]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801fe2e:	681b      	ldr	r3, [r3, #0]
 801fe30:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801fe32:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801fe34:	69fb      	ldr	r3, [r7, #28]
 801fe36:	631a      	str	r2, [r3, #48]	; 0x30
                    prep.current_spindle_rpm = prep_segment->spindle_rpm = rpm;
 801fe38:	69fb      	ldr	r3, [r7, #28]
 801fe3a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801fe3c:	621a      	str	r2, [r3, #32]
 801fe3e:	69fb      	ldr	r3, [r7, #28]
 801fe40:	6a1b      	ldr	r3, [r3, #32]
 801fe42:	4a5d      	ldr	r2, [pc, #372]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fe44:	6513      	str	r3, [r2, #80]	; 0x50
                }
                sys.step_control.update_spindle_rpm = Off;
 801fe46:	4a5d      	ldr	r2, [pc, #372]	; (801ffbc <st_prep_buffer+0xcdc>)
 801fe48:	7e13      	ldrb	r3, [r2, #24]
 801fe4a:	f36f 03c3 	bfc	r3, #3, #1
 801fe4e:	7613      	strb	r3, [r2, #24]
           However, since floats have only 7.2 significant digits, long moves with extremely
           high step counts can exceed the precision of floats, which can lead to lost steps.
           Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
           supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
        */
        float step_dist_remaining = prep.steps_per_mm * mm_remaining; // Convert mm_remaining to steps
 801fe50:	4b59      	ldr	r3, [pc, #356]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fe52:	68db      	ldr	r3, [r3, #12]
 801fe54:	4619      	mov	r1, r3
 801fe56:	6c38      	ldr	r0, [r7, #64]	; 0x40
 801fe58:	f7e0 ffac 	bl	8000db4 <__aeabi_fmul>
 801fe5c:	4603      	mov	r3, r0
 801fe5e:	60fb      	str	r3, [r7, #12]
        uint32_t n_steps_remaining = (uint32_t)ceilf(step_dist_remaining); // Round-up current steps remaining
 801fe60:	68f8      	ldr	r0, [r7, #12]
 801fe62:	f004 ff23 	bl	8024cac <ceilf>
 801fe66:	4603      	mov	r3, r0
 801fe68:	4618      	mov	r0, r3
 801fe6a:	f7e1 f9a5 	bl	80011b8 <__aeabi_f2uiz>
 801fe6e:	4603      	mov	r3, r0
 801fe70:	60bb      	str	r3, [r7, #8]

        prep_segment->n_step = (uint_fast16_t)(prep.steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 801fe72:	4b51      	ldr	r3, [pc, #324]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fe74:	689a      	ldr	r2, [r3, #8]
 801fe76:	68bb      	ldr	r3, [r7, #8]
 801fe78:	1ad2      	subs	r2, r2, r3
 801fe7a:	69fb      	ldr	r3, [r7, #28]
 801fe7c:	619a      	str	r2, [r3, #24]

        // Bail if we are at the end of a feed hold and don't have a step to execute.
        if (prep_segment->n_step == 0 && sys.step_control.execute_hold) {
 801fe7e:	69fb      	ldr	r3, [r7, #28]
 801fe80:	699b      	ldr	r3, [r3, #24]
 801fe82:	2b00      	cmp	r3, #0
 801fe84:	d122      	bne.n	801fecc <st_prep_buffer+0xbec>
 801fe86:	4b4d      	ldr	r3, [pc, #308]	; (801ffbc <st_prep_buffer+0xcdc>)
 801fe88:	7e1b      	ldrb	r3, [r3, #24]
 801fe8a:	f003 0302 	and.w	r3, r3, #2
 801fe8e:	b2db      	uxtb	r3, r3
 801fe90:	2b00      	cmp	r3, #0
 801fe92:	d01b      	beq.n	801fecc <st_prep_buffer+0xbec>
            // Less than one step to decelerate to zero speed, but already very close. AMASS
            // requires full steps to execute. So, just bail.
            sys.step_control.end_motion = On;
 801fe94:	4a49      	ldr	r2, [pc, #292]	; (801ffbc <st_prep_buffer+0xcdc>)
 801fe96:	7e13      	ldrb	r3, [r2, #24]
 801fe98:	f043 0301 	orr.w	r3, r3, #1
 801fe9c:	7613      	strb	r3, [r2, #24]
            if (settings.parking.flags.enabled && !prep.recalculate.parking)
 801fe9e:	4b48      	ldr	r3, [pc, #288]	; (801ffc0 <st_prep_buffer+0xce0>)
 801fea0:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 801fea4:	f003 0301 	and.w	r3, r3, #1
 801fea8:	b2db      	uxtb	r3, r3
 801feaa:	2b00      	cmp	r3, #0
 801feac:	f000 8112 	beq.w	80200d4 <st_prep_buffer+0xdf4>
 801feb0:	4b41      	ldr	r3, [pc, #260]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801feb2:	781b      	ldrb	r3, [r3, #0]
 801feb4:	f003 0304 	and.w	r3, r3, #4
 801feb8:	b2db      	uxtb	r3, r3
 801feba:	2b00      	cmp	r3, #0
 801febc:	f040 810a 	bne.w	80200d4 <st_prep_buffer+0xdf4>
                prep.recalculate.hold_partial_block = On;
 801fec0:	4a3d      	ldr	r2, [pc, #244]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fec2:	7813      	ldrb	r3, [r2, #0]
 801fec4:	f043 0302 	orr.w	r3, r3, #2
 801fec8:	7013      	strb	r3, [r2, #0]
            return; // Segment not generated, but current step data still retained.
 801feca:	e103      	b.n	80200d4 <st_prep_buffer+0xdf4>
        // compensate, we track the time to execute the previous segment's partial step and simply
        // apply it with the partial step distance to the current segment, so that it minutely
        // adjusts the whole segment rate to keep step output exact. These rate adjustments are
        // typically very small and do not adversely effect performance, but ensures that Grbl
        // outputs the exact acceleration and velocity profiles as computed by the planner.
        dt += prep.dt_remainder; // Apply previous segment partial step execute time
 801fecc:	4b3a      	ldr	r3, [pc, #232]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fece:	685b      	ldr	r3, [r3, #4]
 801fed0:	4619      	mov	r1, r3
 801fed2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801fed4:	f7e0 fe66 	bl	8000ba4 <__addsf3>
 801fed8:	4603      	mov	r3, r0
 801feda:	64bb      	str	r3, [r7, #72]	; 0x48
        float inv_rate = dt / ((float)prep.steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 801fedc:	4b36      	ldr	r3, [pc, #216]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801fede:	689b      	ldr	r3, [r3, #8]
 801fee0:	4618      	mov	r0, r3
 801fee2:	f7e0 ff0f 	bl	8000d04 <__aeabi_ui2f>
 801fee6:	4603      	mov	r3, r0
 801fee8:	68f9      	ldr	r1, [r7, #12]
 801feea:	4618      	mov	r0, r3
 801feec:	f7e0 fe58 	bl	8000ba0 <__aeabi_fsub>
 801fef0:	4603      	mov	r3, r0
 801fef2:	4619      	mov	r1, r3
 801fef4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801fef6:	f7e1 f811 	bl	8000f1c <__aeabi_fdiv>
 801fefa:	4603      	mov	r3, r0
 801fefc:	607b      	str	r3, [r7, #4]

        // Compute timer ticks per step for the prepped segment.
        uint32_t cycles = (uint32_t)ceilf(cycles_per_min * inv_rate); // (cycles/step)
 801fefe:	4b31      	ldr	r3, [pc, #196]	; (801ffc4 <st_prep_buffer+0xce4>)
 801ff00:	681b      	ldr	r3, [r3, #0]
 801ff02:	6879      	ldr	r1, [r7, #4]
 801ff04:	4618      	mov	r0, r3
 801ff06:	f7e0 ff55 	bl	8000db4 <__aeabi_fmul>
 801ff0a:	4603      	mov	r3, r0
 801ff0c:	4618      	mov	r0, r3
 801ff0e:	f004 fecd 	bl	8024cac <ceilf>
 801ff12:	4603      	mov	r3, r0
 801ff14:	4618      	mov	r0, r3
 801ff16:	f7e1 f94f 	bl	80011b8 <__aeabi_f2uiz>
 801ff1a:	4603      	mov	r3, r0
 801ff1c:	637b      	str	r3, [r7, #52]	; 0x34

        // Record end position of segment relative to block if spindle synchronized motion
        if((prep_segment->spindle_sync = pl_block->spindle.state.synchronized)) {
 801ff1e:	4b25      	ldr	r3, [pc, #148]	; (801ffb4 <st_prep_buffer+0xcd4>)
 801ff20:	681b      	ldr	r3, [r3, #0]
 801ff22:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801ff26:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 801ff2a:	b2db      	uxtb	r3, r3
 801ff2c:	2b00      	cmp	r3, #0
 801ff2e:	bf14      	ite	ne
 801ff30:	2301      	movne	r3, #1
 801ff32:	2300      	moveq	r3, #0
 801ff34:	b2da      	uxtb	r2, r3
 801ff36:	69fb      	ldr	r3, [r7, #28]
 801ff38:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 801ff3c:	69fb      	ldr	r3, [r7, #28]
 801ff3e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801ff42:	2b00      	cmp	r3, #0
 801ff44:	d01f      	beq.n	801ff86 <st_prep_buffer+0xca6>
            prep.target_position += dt * prep.target_feed;
 801ff46:	4b1c      	ldr	r3, [pc, #112]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801ff48:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 801ff4a:	4b1b      	ldr	r3, [pc, #108]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801ff4c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ff4e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801ff50:	4618      	mov	r0, r3
 801ff52:	f7e0 ff2f 	bl	8000db4 <__aeabi_fmul>
 801ff56:	4603      	mov	r3, r0
 801ff58:	4619      	mov	r1, r3
 801ff5a:	4620      	mov	r0, r4
 801ff5c:	f7e0 fe22 	bl	8000ba4 <__addsf3>
 801ff60:	4603      	mov	r3, r0
 801ff62:	461a      	mov	r2, r3
 801ff64:	4b14      	ldr	r3, [pc, #80]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801ff66:	645a      	str	r2, [r3, #68]	; 0x44
            prep_segment->cruising = prep.ramp_type == Ramp_Cruise;
 801ff68:	4b13      	ldr	r3, [pc, #76]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801ff6a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801ff6e:	2b01      	cmp	r3, #1
 801ff70:	bf0c      	ite	eq
 801ff72:	2301      	moveq	r3, #1
 801ff74:	2300      	movne	r3, #0
 801ff76:	b2da      	uxtb	r2, r3
 801ff78:	69fb      	ldr	r3, [r7, #28]
 801ff7a:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
            prep_segment->target_position = prep.target_position; //st_prep_block->millimeters - pl_block->millimeters;
 801ff7e:	4b0e      	ldr	r3, [pc, #56]	; (801ffb8 <st_prep_buffer+0xcd8>)
 801ff80:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801ff82:	69fb      	ldr	r3, [r7, #28]
 801ff84:	615a      	str	r2, [r3, #20]
        }

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // Compute step timing and multi-axis smoothing level.
        // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
        if (cycles < amass.level_1)
 801ff86:	4b10      	ldr	r3, [pc, #64]	; (801ffc8 <st_prep_buffer+0xce8>)
 801ff88:	681b      	ldr	r3, [r3, #0]
 801ff8a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801ff8c:	429a      	cmp	r2, r3
 801ff8e:	d203      	bcs.n	801ff98 <st_prep_buffer+0xcb8>
            prep_segment->amass_level = 0;
 801ff90:	69fb      	ldr	r3, [r7, #28]
 801ff92:	2200      	movs	r2, #0
 801ff94:	629a      	str	r2, [r3, #40]	; 0x28
 801ff96:	e029      	b.n	801ffec <st_prep_buffer+0xd0c>
        else {
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 801ff98:	4b0b      	ldr	r3, [pc, #44]	; (801ffc8 <st_prep_buffer+0xce8>)
 801ff9a:	685b      	ldr	r3, [r3, #4]
 801ff9c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801ff9e:	429a      	cmp	r2, r3
 801ffa0:	d314      	bcc.n	801ffcc <st_prep_buffer+0xcec>
 801ffa2:	4b09      	ldr	r3, [pc, #36]	; (801ffc8 <st_prep_buffer+0xce8>)
 801ffa4:	689b      	ldr	r3, [r3, #8]
 801ffa6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801ffa8:	429a      	cmp	r2, r3
 801ffaa:	d201      	bcs.n	801ffb0 <st_prep_buffer+0xcd0>
 801ffac:	2302      	movs	r3, #2
 801ffae:	e00e      	b.n	801ffce <st_prep_buffer+0xcee>
 801ffb0:	2303      	movs	r3, #3
 801ffb2:	e00c      	b.n	801ffce <st_prep_buffer+0xcee>
 801ffb4:	20001c68 	.word	0x20001c68
 801ffb8:	20001ca8 	.word	0x20001ca8
 801ffbc:	20000d3c 	.word	0x20000d3c
 801ffc0:	2000147c 	.word	0x2000147c
 801ffc4:	20001c58 	.word	0x20001c58
 801ffc8:	20001c44 	.word	0x20001c44
 801ffcc:	2301      	movs	r3, #1
 801ffce:	69fa      	ldr	r2, [r7, #28]
 801ffd0:	6293      	str	r3, [r2, #40]	; 0x28
            cycles >>= prep_segment->amass_level;
 801ffd2:	69fb      	ldr	r3, [r7, #28]
 801ffd4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ffd6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801ffd8:	fa22 f303 	lsr.w	r3, r2, r3
 801ffdc:	637b      	str	r3, [r7, #52]	; 0x34
            prep_segment->n_step <<= prep_segment->amass_level;
 801ffde:	69fb      	ldr	r3, [r7, #28]
 801ffe0:	699a      	ldr	r2, [r3, #24]
 801ffe2:	69fb      	ldr	r3, [r7, #28]
 801ffe4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801ffe6:	409a      	lsls	r2, r3
 801ffe8:	69fb      	ldr	r3, [r7, #28]
 801ffea:	619a      	str	r2, [r3, #24]
        }
      #endif

        prep_segment->cycles_per_tick = cycles;
 801ffec:	69fb      	ldr	r3, [r7, #28]
 801ffee:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801fff0:	60da      	str	r2, [r3, #12]
        prep_segment->current_rate = prep.current_speed;
 801fff2:	4b3b      	ldr	r3, [pc, #236]	; (80200e0 <st_prep_buffer+0xe00>)
 801fff4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801fff6:	69fb      	ldr	r3, [r7, #28]
 801fff8:	611a      	str	r2, [r3, #16]

        // Segment complete! Increment segment pointers, so stepper ISR can immediately execute it.
        segment_buffer_head = segment_next_head;
 801fffa:	4b3a      	ldr	r3, [pc, #232]	; (80200e4 <st_prep_buffer+0xe04>)
 801fffc:	681b      	ldr	r3, [r3, #0]
 801fffe:	4a3a      	ldr	r2, [pc, #232]	; (80200e8 <st_prep_buffer+0xe08>)
 8020000:	6013      	str	r3, [r2, #0]
        segment_next_head = segment_next_head->next;
 8020002:	4b38      	ldr	r3, [pc, #224]	; (80200e4 <st_prep_buffer+0xe04>)
 8020004:	681b      	ldr	r3, [r3, #0]
 8020006:	685b      	ldr	r3, [r3, #4]
 8020008:	4a36      	ldr	r2, [pc, #216]	; (80200e4 <st_prep_buffer+0xe04>)
 802000a:	6013      	str	r3, [r2, #0]

        // Update the appropriate planner and segment data.
        pl_block->millimeters = mm_remaining;
 802000c:	4b37      	ldr	r3, [pc, #220]	; (80200ec <st_prep_buffer+0xe0c>)
 802000e:	681b      	ldr	r3, [r3, #0]
 8020010:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8020012:	629a      	str	r2, [r3, #40]	; 0x28
        prep.steps_remaining = n_steps_remaining;
 8020014:	4a32      	ldr	r2, [pc, #200]	; (80200e0 <st_prep_buffer+0xe00>)
 8020016:	68bb      	ldr	r3, [r7, #8]
 8020018:	6093      	str	r3, [r2, #8]
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 802001a:	68b8      	ldr	r0, [r7, #8]
 802001c:	f7e0 fe72 	bl	8000d04 <__aeabi_ui2f>
 8020020:	4603      	mov	r3, r0
 8020022:	68f9      	ldr	r1, [r7, #12]
 8020024:	4618      	mov	r0, r3
 8020026:	f7e0 fdbb 	bl	8000ba0 <__aeabi_fsub>
 802002a:	4603      	mov	r3, r0
 802002c:	6879      	ldr	r1, [r7, #4]
 802002e:	4618      	mov	r0, r3
 8020030:	f7e0 fec0 	bl	8000db4 <__aeabi_fmul>
 8020034:	4603      	mov	r3, r0
 8020036:	461a      	mov	r2, r3
 8020038:	4b29      	ldr	r3, [pc, #164]	; (80200e0 <st_prep_buffer+0xe00>)
 802003a:	605a      	str	r2, [r3, #4]

        // Check for exit conditions and flag to load next planner block.
        if (mm_remaining <= prep.mm_complete) {
 802003c:	4b28      	ldr	r3, [pc, #160]	; (80200e0 <st_prep_buffer+0xe00>)
 802003e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8020040:	4619      	mov	r1, r3
 8020042:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8020044:	f7e1 f85e 	bl	8001104 <__aeabi_fcmple>
 8020048:	4603      	mov	r3, r0
 802004a:	2b00      	cmp	r3, #0
 802004c:	d100      	bne.n	8020050 <st_prep_buffer+0xd70>
 802004e:	e033      	b.n	80200b8 <st_prep_buffer+0xdd8>

            // End of planner block or forced-termination. No more distance to be executed.
            if (mm_remaining > 0.0f) { // At end of forced-termination.
 8020050:	f04f 0100 	mov.w	r1, #0
 8020054:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8020056:	f7e1 f869 	bl	800112c <__aeabi_fcmpgt>
 802005a:	4603      	mov	r3, r0
 802005c:	2b00      	cmp	r3, #0
 802005e:	d019      	beq.n	8020094 <st_prep_buffer+0xdb4>
                // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
                // the segment queue, where realtime protocol will set new state upon receiving the
                // cycle stop flag from the ISR. Prep_segment is blocked until then.
                sys.step_control.end_motion = On;
 8020060:	4a23      	ldr	r2, [pc, #140]	; (80200f0 <st_prep_buffer+0xe10>)
 8020062:	7e13      	ldrb	r3, [r2, #24]
 8020064:	f043 0301 	orr.w	r3, r3, #1
 8020068:	7613      	strb	r3, [r2, #24]
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
 802006a:	4b22      	ldr	r3, [pc, #136]	; (80200f4 <st_prep_buffer+0xe14>)
 802006c:	f893 3128 	ldrb.w	r3, [r3, #296]	; 0x128
 8020070:	f003 0301 	and.w	r3, r3, #1
 8020074:	b2db      	uxtb	r3, r3
 8020076:	2b00      	cmp	r3, #0
 8020078:	d02e      	beq.n	80200d8 <st_prep_buffer+0xdf8>
 802007a:	4b19      	ldr	r3, [pc, #100]	; (80200e0 <st_prep_buffer+0xe00>)
 802007c:	781b      	ldrb	r3, [r3, #0]
 802007e:	f003 0304 	and.w	r3, r3, #4
 8020082:	b2db      	uxtb	r3, r3
 8020084:	2b00      	cmp	r3, #0
 8020086:	d127      	bne.n	80200d8 <st_prep_buffer+0xdf8>
                    prep.recalculate.hold_partial_block = On;
 8020088:	4a15      	ldr	r2, [pc, #84]	; (80200e0 <st_prep_buffer+0xe00>)
 802008a:	7813      	ldrb	r3, [r2, #0]
 802008c:	f043 0302 	orr.w	r3, r3, #2
 8020090:	7013      	strb	r3, [r2, #0]
                return; // Bail!
 8020092:	e021      	b.n	80200d8 <st_prep_buffer+0xdf8>
            } else { // End of planner block
                // The planner block is complete. All steps are set to be executed in the segment buffer.
                if (sys.step_control.execute_sys_motion) {
 8020094:	4b16      	ldr	r3, [pc, #88]	; (80200f0 <st_prep_buffer+0xe10>)
 8020096:	7e1b      	ldrb	r3, [r3, #24]
 8020098:	f003 0304 	and.w	r3, r3, #4
 802009c:	b2db      	uxtb	r3, r3
 802009e:	2b00      	cmp	r3, #0
 80200a0:	d005      	beq.n	80200ae <st_prep_buffer+0xdce>
                    sys.step_control.end_motion = On;
 80200a2:	4a13      	ldr	r2, [pc, #76]	; (80200f0 <st_prep_buffer+0xe10>)
 80200a4:	7e13      	ldrb	r3, [r2, #24]
 80200a6:	f043 0301 	orr.w	r3, r3, #1
 80200aa:	7613      	strb	r3, [r2, #24]
                    return;
 80200ac:	e015      	b.n	80200da <st_prep_buffer+0xdfa>
                }
                pl_block = NULL; // Set pointer to indicate check and load next planner block.
 80200ae:	4b0f      	ldr	r3, [pc, #60]	; (80200ec <st_prep_buffer+0xe0c>)
 80200b0:	2200      	movs	r2, #0
 80200b2:	601a      	str	r2, [r3, #0]
                plan_discard_current_block();
 80200b4:	f7f1 fbe2 	bl	801187c <plan_discard_current_block>
    while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 80200b8:	4b0f      	ldr	r3, [pc, #60]	; (80200f8 <st_prep_buffer+0xe18>)
 80200ba:	681a      	ldr	r2, [r3, #0]
 80200bc:	4b09      	ldr	r3, [pc, #36]	; (80200e4 <st_prep_buffer+0xe04>)
 80200be:	681b      	ldr	r3, [r3, #0]
 80200c0:	429a      	cmp	r2, r3
 80200c2:	f47f a91a 	bne.w	801f2fa <st_prep_buffer+0x1a>
 80200c6:	e008      	b.n	80200da <st_prep_buffer+0xdfa>
        return;
 80200c8:	bf00      	nop
 80200ca:	e006      	b.n	80200da <st_prep_buffer+0xdfa>
                return; // No planner blocks. Exit.
 80200cc:	bf00      	nop
 80200ce:	e004      	b.n	80200da <st_prep_buffer+0xdfa>
            return;
 80200d0:	bf00      	nop
 80200d2:	e002      	b.n	80200da <st_prep_buffer+0xdfa>
            return; // Segment not generated, but current step data still retained.
 80200d4:	bf00      	nop
 80200d6:	e000      	b.n	80200da <st_prep_buffer+0xdfa>
                return; // Bail!
 80200d8:	bf00      	nop
            }
        }
    }
}
 80200da:	3758      	adds	r7, #88	; 0x58
 80200dc:	46bd      	mov	sp, r7
 80200de:	bdb0      	pop	{r4, r5, r7, pc}
 80200e0:	20001ca8 	.word	0x20001ca8
 80200e4:	20001c64 	.word	0x20001c64
 80200e8:	20001c60 	.word	0x20001c60
 80200ec:	20001c68 	.word	0x20001c68
 80200f0:	20000d3c 	.word	0x20000d3c
 80200f4:	2000147c 	.word	0x2000147c
 80200f8:	20001c5c 	.word	0x20001c5c

080200fc <st_get_realtime_rate>:
// Called by realtime status reporting to fetch the current speed being executed. This value
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate (void)
{
 80200fc:	b580      	push	{r7, lr}
 80200fe:	af00      	add	r7, sp, #0
    return state_get() & (STATE_CYCLE|STATE_HOMING|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 8020100:	f7fd fbde 	bl	801d8c0 <state_get>
 8020104:	4603      	mov	r3, r0
 8020106:	f003 037c 	and.w	r3, r3, #124	; 0x7c
#ifdef KINEMATICS_API
            ? prep.current_speed * prep.rate_multiplier
#else
            ? prep.current_speed
#endif
            : 0.0f;
 802010a:	2b00      	cmp	r3, #0
 802010c:	d009      	beq.n	8020122 <st_get_realtime_rate+0x26>
            ? prep.current_speed * prep.rate_multiplier
 802010e:	4b07      	ldr	r3, [pc, #28]	; (802012c <st_get_realtime_rate+0x30>)
 8020110:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8020112:	4a06      	ldr	r2, [pc, #24]	; (802012c <st_get_realtime_rate+0x30>)
 8020114:	6b92      	ldr	r2, [r2, #56]	; 0x38
            : 0.0f;
 8020116:	4611      	mov	r1, r2
 8020118:	4618      	mov	r0, r3
 802011a:	f7e0 fe4b 	bl	8000db4 <__aeabi_fmul>
 802011e:	4603      	mov	r3, r0
 8020120:	e001      	b.n	8020126 <st_get_realtime_rate+0x2a>
 8020122:	f04f 0300 	mov.w	r3, #0
}
 8020126:	4618      	mov	r0, r3
 8020128:	bd80      	pop	{r7, pc}
 802012a:	bf00      	nop
 802012c:	20001ca8 	.word	0x20001ca8

08020130 <stream_tx_blocking>:
    return claimed;
}

// called from stream drivers while tx is blocking, returns false to terminate
bool stream_tx_blocking (void)
{
 8020130:	b598      	push	{r3, r4, r7, lr}
 8020132:	af00      	add	r7, sp, #0
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.

    grbl.on_execute_realtime(state_get());
 8020134:	4b08      	ldr	r3, [pc, #32]	; (8020158 <stream_tx_blocking+0x28>)
 8020136:	6c9c      	ldr	r4, [r3, #72]	; 0x48
 8020138:	f7fd fbc2 	bl	801d8c0 <state_get>
 802013c:	4603      	mov	r3, r0
 802013e:	4618      	mov	r0, r3
 8020140:	47a0      	blx	r4

    return !(sys.rt_exec_state & EXEC_RESET);
 8020142:	4b06      	ldr	r3, [pc, #24]	; (802015c <stream_tx_blocking+0x2c>)
 8020144:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8020146:	f003 0320 	and.w	r3, r3, #32
 802014a:	2b00      	cmp	r3, #0
 802014c:	bf0c      	ite	eq
 802014e:	2301      	moveq	r3, #1
 8020150:	2300      	movne	r3, #0
 8020152:	b2db      	uxtb	r3, r3
}
 8020154:	4618      	mov	r0, r3
 8020156:	bd98      	pop	{r3, r4, r7, pc}
 8020158:	20000dd4 	.word	0x20000dd4
 802015c:	20000d3c 	.word	0x20000d3c

08020160 <stream_get_null>:

// "dummy" version of serialGetC
int16_t stream_get_null (void)
{
 8020160:	b480      	push	{r7}
 8020162:	af00      	add	r7, sp, #0
    return SERIAL_NO_DATA;
 8020164:	f04f 33ff 	mov.w	r3, #4294967295
}
 8020168:	4618      	mov	r0, r3
 802016a:	46bd      	mov	sp, r7
 802016c:	bc80      	pop	{r7}
 802016e:	4770      	bx	lr

08020170 <await_toolchange_ack>:

ISR_CODE static bool ISR_FUNC(await_toolchange_ack)(char c)
{
 8020170:	b580      	push	{r7, lr}
 8020172:	b082      	sub	sp, #8
 8020174:	af00      	add	r7, sp, #0
 8020176:	4603      	mov	r3, r0
 8020178:	71fb      	strb	r3, [r7, #7]
    if(c == CMD_TOOL_ACK && !stream.rxbuffer->backup) {
 802017a:	79fb      	ldrb	r3, [r7, #7]
 802017c:	2ba3      	cmp	r3, #163	; 0xa3
 802017e:	d132      	bne.n	80201e6 <await_toolchange_ack+0x76>
 8020180:	4b1f      	ldr	r3, [pc, #124]	; (8020200 <await_toolchange_ack+0x90>)
 8020182:	689b      	ldr	r3, [r3, #8]
 8020184:	7a9b      	ldrb	r3, [r3, #10]
 8020186:	f083 0301 	eor.w	r3, r3, #1
 802018a:	b2db      	uxtb	r3, r3
 802018c:	2b00      	cmp	r3, #0
 802018e:	d02a      	beq.n	80201e6 <await_toolchange_ack+0x76>
        memcpy(&rxbackup, stream.rxbuffer, sizeof(stream_rx_buffer_t));
 8020190:	4b1b      	ldr	r3, [pc, #108]	; (8020200 <await_toolchange_ack+0x90>)
 8020192:	689b      	ldr	r3, [r3, #8]
 8020194:	f240 420c 	movw	r2, #1036	; 0x40c
 8020198:	4619      	mov	r1, r3
 802019a:	481a      	ldr	r0, [pc, #104]	; (8020204 <await_toolchange_ack+0x94>)
 802019c:	f003 fe97 	bl	8023ece <memcpy>
        stream.rxbuffer->backup = true;
 80201a0:	4b17      	ldr	r3, [pc, #92]	; (8020200 <await_toolchange_ack+0x90>)
 80201a2:	689b      	ldr	r3, [r3, #8]
 80201a4:	2201      	movs	r2, #1
 80201a6:	729a      	strb	r2, [r3, #10]
        stream.rxbuffer->tail = stream.rxbuffer->head;
 80201a8:	4b15      	ldr	r3, [pc, #84]	; (8020200 <await_toolchange_ack+0x90>)
 80201aa:	689a      	ldr	r2, [r3, #8]
 80201ac:	4b14      	ldr	r3, [pc, #80]	; (8020200 <await_toolchange_ack+0x90>)
 80201ae:	689b      	ldr	r3, [r3, #8]
 80201b0:	6812      	ldr	r2, [r2, #0]
 80201b2:	605a      	str	r2, [r3, #4]
        hal.stream.read = stream.read; // restore normal input
 80201b4:	4b12      	ldr	r3, [pc, #72]	; (8020200 <await_toolchange_ack+0x90>)
 80201b6:	685b      	ldr	r3, [r3, #4]
 80201b8:	4a13      	ldr	r2, [pc, #76]	; (8020208 <await_toolchange_ack+0x98>)
 80201ba:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
        hal.stream.set_enqueue_rt_handler(stream.enqueue_realtime_command);
 80201be:	4b12      	ldr	r3, [pc, #72]	; (8020208 <await_toolchange_ack+0x98>)
 80201c0:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80201c4:	4a0e      	ldr	r2, [pc, #56]	; (8020200 <await_toolchange_ack+0x90>)
 80201c6:	6812      	ldr	r2, [r2, #0]
 80201c8:	4610      	mov	r0, r2
 80201ca:	4798      	blx	r3
        stream.enqueue_realtime_command = NULL;
 80201cc:	4b0c      	ldr	r3, [pc, #48]	; (8020200 <await_toolchange_ack+0x90>)
 80201ce:	2200      	movs	r2, #0
 80201d0:	601a      	str	r2, [r3, #0]
        if(grbl.on_toolchange_ack)
 80201d2:	4b0e      	ldr	r3, [pc, #56]	; (802020c <await_toolchange_ack+0x9c>)
 80201d4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80201d8:	2b00      	cmp	r3, #0
 80201da:	d00b      	beq.n	80201f4 <await_toolchange_ack+0x84>
            grbl.on_toolchange_ack();
 80201dc:	4b0b      	ldr	r3, [pc, #44]	; (802020c <await_toolchange_ack+0x9c>)
 80201de:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80201e2:	4798      	blx	r3
        if(grbl.on_toolchange_ack)
 80201e4:	e006      	b.n	80201f4 <await_toolchange_ack+0x84>
    } else
        return stream.enqueue_realtime_command(c);
 80201e6:	4b06      	ldr	r3, [pc, #24]	; (8020200 <await_toolchange_ack+0x90>)
 80201e8:	681b      	ldr	r3, [r3, #0]
 80201ea:	79fa      	ldrb	r2, [r7, #7]
 80201ec:	4610      	mov	r0, r2
 80201ee:	4798      	blx	r3
 80201f0:	4603      	mov	r3, r0
 80201f2:	e000      	b.n	80201f6 <await_toolchange_ack+0x86>

    return true;
 80201f4:	2301      	movs	r3, #1
}
 80201f6:	4618      	mov	r0, r3
 80201f8:	3708      	adds	r7, #8
 80201fa:	46bd      	mov	sp, r7
 80201fc:	bd80      	pop	{r7, pc}
 80201fe:	bf00      	nop
 8020200:	20002108 	.word	0x20002108
 8020204:	20001cfc 	.word	0x20001cfc
 8020208:	20000ed0 	.word	0x20000ed0
 802020c:	20000dd4 	.word	0x20000dd4

08020210 <stream_rx_suspend>:

bool stream_rx_suspend (stream_rx_buffer_t *rxbuffer, bool suspend)
{
 8020210:	b580      	push	{r7, lr}
 8020212:	b082      	sub	sp, #8
 8020214:	af00      	add	r7, sp, #0
 8020216:	6078      	str	r0, [r7, #4]
 8020218:	460b      	mov	r3, r1
 802021a:	70fb      	strb	r3, [r7, #3]
    if(suspend) {
 802021c:	78fb      	ldrb	r3, [r7, #3]
 802021e:	2b00      	cmp	r3, #0
 8020220:	d018      	beq.n	8020254 <stream_rx_suspend+0x44>
        if(stream.rxbuffer == NULL) {
 8020222:	4b25      	ldr	r3, [pc, #148]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020224:	689b      	ldr	r3, [r3, #8]
 8020226:	2b00      	cmp	r3, #0
 8020228:	d138      	bne.n	802029c <stream_rx_suspend+0x8c>
            stream.rxbuffer = rxbuffer;
 802022a:	4a23      	ldr	r2, [pc, #140]	; (80202b8 <stream_rx_suspend+0xa8>)
 802022c:	687b      	ldr	r3, [r7, #4]
 802022e:	6093      	str	r3, [r2, #8]
            stream.read = hal.stream.read;
 8020230:	4b22      	ldr	r3, [pc, #136]	; (80202bc <stream_rx_suspend+0xac>)
 8020232:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8020236:	4a20      	ldr	r2, [pc, #128]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020238:	6053      	str	r3, [r2, #4]
            stream.enqueue_realtime_command = hal.stream.set_enqueue_rt_handler(await_toolchange_ack);
 802023a:	4b20      	ldr	r3, [pc, #128]	; (80202bc <stream_rx_suspend+0xac>)
 802023c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8020240:	481f      	ldr	r0, [pc, #124]	; (80202c0 <stream_rx_suspend+0xb0>)
 8020242:	4798      	blx	r3
 8020244:	4603      	mov	r3, r0
 8020246:	4a1c      	ldr	r2, [pc, #112]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020248:	6013      	str	r3, [r2, #0]
            hal.stream.read = stream_get_null;
 802024a:	4b1c      	ldr	r3, [pc, #112]	; (80202bc <stream_rx_suspend+0xac>)
 802024c:	4a1d      	ldr	r2, [pc, #116]	; (80202c4 <stream_rx_suspend+0xb4>)
 802024e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
 8020252:	e023      	b.n	802029c <stream_rx_suspend+0x8c>
        }
    } else if(stream.rxbuffer) {
 8020254:	4b18      	ldr	r3, [pc, #96]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020256:	689b      	ldr	r3, [r3, #8]
 8020258:	2b00      	cmp	r3, #0
 802025a:	d01f      	beq.n	802029c <stream_rx_suspend+0x8c>
        if(rxbuffer->backup)
 802025c:	687b      	ldr	r3, [r7, #4]
 802025e:	7a9b      	ldrb	r3, [r3, #10]
 8020260:	2b00      	cmp	r3, #0
 8020262:	d005      	beq.n	8020270 <stream_rx_suspend+0x60>
            memcpy(rxbuffer, &rxbackup, sizeof(stream_rx_buffer_t));
 8020264:	f240 420c 	movw	r2, #1036	; 0x40c
 8020268:	4917      	ldr	r1, [pc, #92]	; (80202c8 <stream_rx_suspend+0xb8>)
 802026a:	6878      	ldr	r0, [r7, #4]
 802026c:	f003 fe2f 	bl	8023ece <memcpy>
        if(stream.enqueue_realtime_command) {
 8020270:	4b11      	ldr	r3, [pc, #68]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020272:	681b      	ldr	r3, [r3, #0]
 8020274:	2b00      	cmp	r3, #0
 8020276:	d00e      	beq.n	8020296 <stream_rx_suspend+0x86>
            hal.stream.read = stream.read; // restore normal input
 8020278:	4b0f      	ldr	r3, [pc, #60]	; (80202b8 <stream_rx_suspend+0xa8>)
 802027a:	685b      	ldr	r3, [r3, #4]
 802027c:	4a0f      	ldr	r2, [pc, #60]	; (80202bc <stream_rx_suspend+0xac>)
 802027e:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
            hal.stream.set_enqueue_rt_handler(stream.enqueue_realtime_command);
 8020282:	4b0e      	ldr	r3, [pc, #56]	; (80202bc <stream_rx_suspend+0xac>)
 8020284:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8020288:	4a0b      	ldr	r2, [pc, #44]	; (80202b8 <stream_rx_suspend+0xa8>)
 802028a:	6812      	ldr	r2, [r2, #0]
 802028c:	4610      	mov	r0, r2
 802028e:	4798      	blx	r3
            stream.enqueue_realtime_command = NULL;
 8020290:	4b09      	ldr	r3, [pc, #36]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020292:	2200      	movs	r2, #0
 8020294:	601a      	str	r2, [r3, #0]
        }
        stream.rxbuffer = NULL;
 8020296:	4b08      	ldr	r3, [pc, #32]	; (80202b8 <stream_rx_suspend+0xa8>)
 8020298:	2200      	movs	r2, #0
 802029a:	609a      	str	r2, [r3, #8]
    }

    return rxbuffer->tail != rxbuffer->head;
 802029c:	687b      	ldr	r3, [r7, #4]
 802029e:	685a      	ldr	r2, [r3, #4]
 80202a0:	687b      	ldr	r3, [r7, #4]
 80202a2:	681b      	ldr	r3, [r3, #0]
 80202a4:	429a      	cmp	r2, r3
 80202a6:	bf14      	ite	ne
 80202a8:	2301      	movne	r3, #1
 80202aa:	2300      	moveq	r3, #0
 80202ac:	b2db      	uxtb	r3, r3
}
 80202ae:	4618      	mov	r0, r3
 80202b0:	3708      	adds	r7, #8
 80202b2:	46bd      	mov	sp, r7
 80202b4:	bd80      	pop	{r7, pc}
 80202b6:	bf00      	nop
 80202b8:	20002108 	.word	0x20002108
 80202bc:	20000ed0 	.word	0x20000ed0
 80202c0:	08020171 	.word	0x08020171
 80202c4:	08020161 	.word	0x08020161
 80202c8:	20001cfc 	.word	0x20001cfc

080202cc <stream_enqueue_realtime_command>:
{
    return false;
}

ISR_CODE bool ISR_FUNC(stream_enqueue_realtime_command)(char c)
{
 80202cc:	b580      	push	{r7, lr}
 80202ce:	b084      	sub	sp, #16
 80202d0:	af00      	add	r7, sp, #0
 80202d2:	4603      	mov	r3, r0
 80202d4:	71fb      	strb	r3, [r7, #7]
	bool drop = hal.stream.enqueue_rt_command ? hal.stream.enqueue_rt_command(c) : protocol_enqueue_realtime_command(c);
 80202d6:	4b1c      	ldr	r3, [pc, #112]	; (8020348 <stream_enqueue_realtime_command+0x7c>)
 80202d8:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80202dc:	2b00      	cmp	r3, #0
 80202de:	d00c      	beq.n	80202fa <stream_enqueue_realtime_command+0x2e>
 80202e0:	4b19      	ldr	r3, [pc, #100]	; (8020348 <stream_enqueue_realtime_command+0x7c>)
 80202e2:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 80202e6:	79fa      	ldrb	r2, [r7, #7]
 80202e8:	4610      	mov	r0, r2
 80202ea:	4798      	blx	r3
 80202ec:	4603      	mov	r3, r0
 80202ee:	2b00      	cmp	r3, #0
 80202f0:	bf14      	ite	ne
 80202f2:	2301      	movne	r3, #1
 80202f4:	2300      	moveq	r3, #0
 80202f6:	b2db      	uxtb	r3, r3
 80202f8:	e009      	b.n	802030e <stream_enqueue_realtime_command+0x42>
 80202fa:	79fb      	ldrb	r3, [r7, #7]
 80202fc:	4618      	mov	r0, r3
 80202fe:	f7f3 fa0b 	bl	8013718 <protocol_enqueue_realtime_command>
 8020302:	4603      	mov	r3, r0
 8020304:	2b00      	cmp	r3, #0
 8020306:	bf14      	ite	ne
 8020308:	2301      	movne	r3, #1
 802030a:	2300      	moveq	r3, #0
 802030c:	b2db      	uxtb	r3, r3
 802030e:	73fb      	strb	r3, [r7, #15]

    if(drop && (c == CMD_CYCLE_START || c == CMD_CYCLE_START_LEGACY))
 8020310:	7bfb      	ldrb	r3, [r7, #15]
 8020312:	2b00      	cmp	r3, #0
 8020314:	d012      	beq.n	802033c <stream_enqueue_realtime_command+0x70>
 8020316:	79fb      	ldrb	r3, [r7, #7]
 8020318:	2b81      	cmp	r3, #129	; 0x81
 802031a:	d002      	beq.n	8020322 <stream_enqueue_realtime_command+0x56>
 802031c:	79fb      	ldrb	r3, [r7, #7]
 802031e:	2b7e      	cmp	r3, #126	; 0x7e
 8020320:	d10c      	bne.n	802033c <stream_enqueue_realtime_command+0x70>
        sys.report.cycle_start = settings.status_report.pin_state;
 8020322:	4b0a      	ldr	r3, [pc, #40]	; (802034c <stream_enqueue_realtime_command+0x80>)
 8020324:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8020328:	f3c3 1300 	ubfx	r3, r3, #4, #1
 802032c:	b2d9      	uxtb	r1, r3
 802032e:	4a08      	ldr	r2, [pc, #32]	; (8020350 <stream_enqueue_realtime_command+0x84>)
 8020330:	f892 3033 	ldrb.w	r3, [r2, #51]	; 0x33
 8020334:	f361 1386 	bfi	r3, r1, #6, #1
 8020338:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33

    return drop;
 802033c:	7bfb      	ldrb	r3, [r7, #15]
}
 802033e:	4618      	mov	r0, r3
 8020340:	3710      	adds	r7, #16
 8020342:	46bd      	mov	sp, r7
 8020344:	bd80      	pop	{r7, pc}
 8020346:	bf00      	nop
 8020348:	20000ed0 	.word	0x20000ed0
 802034c:	2000147c 	.word	0x2000147c
 8020350:	20000d3c 	.word	0x20000d3c

08020354 <is_connected>:

static bool is_connected (void)
{
 8020354:	b480      	push	{r7}
 8020356:	af00      	add	r7, sp, #0
    return true;
 8020358:	2301      	movs	r3, #1
}
 802035a:	4618      	mov	r0, r3
 802035c:	46bd      	mov	sp, r7
 802035e:	bc80      	pop	{r7}
 8020360:	4770      	bx	lr

08020362 <is_not_connected>:

static bool is_not_connected (void)
{
 8020362:	b480      	push	{r7}
 8020364:	af00      	add	r7, sp, #0
    return false;
 8020366:	2300      	movs	r3, #0
}
 8020368:	4618      	mov	r0, r3
 802036a:	46bd      	mov	sp, r7
 802036c:	bc80      	pop	{r7}
 802036e:	4770      	bx	lr

08020370 <connection_is_up>:

static bool connection_is_up (io_stream_t *stream)
{
 8020370:	b580      	push	{r7, lr}
 8020372:	b084      	sub	sp, #16
 8020374:	af00      	add	r7, sp, #0
 8020376:	6078      	str	r0, [r7, #4]
    if(stream->is_connected)
 8020378:	687b      	ldr	r3, [r7, #4]
 802037a:	685b      	ldr	r3, [r3, #4]
 802037c:	2b00      	cmp	r3, #0
 802037e:	d004      	beq.n	802038a <connection_is_up+0x1a>
        return stream->is_connected();
 8020380:	687b      	ldr	r3, [r7, #4]
 8020382:	685b      	ldr	r3, [r3, #4]
 8020384:	4798      	blx	r3
 8020386:	4603      	mov	r3, r0
 8020388:	e035      	b.n	80203f6 <connection_is_up+0x86>

    stream_connection_t *connection = connections;
 802038a:	4b1d      	ldr	r3, [pc, #116]	; (8020400 <connection_is_up+0x90>)
 802038c:	681b      	ldr	r3, [r3, #0]
 802038e:	60fb      	str	r3, [r7, #12]

    while(connection) {
 8020390:	e02d      	b.n	80203ee <connection_is_up+0x7e>
        if(connection->stream->type == stream->type &&
 8020392:	68fb      	ldr	r3, [r7, #12]
 8020394:	681b      	ldr	r3, [r3, #0]
 8020396:	781a      	ldrb	r2, [r3, #0]
 8020398:	687b      	ldr	r3, [r7, #4]
 802039a:	781b      	ldrb	r3, [r3, #0]
 802039c:	429a      	cmp	r2, r3
 802039e:	d123      	bne.n	80203e8 <connection_is_up+0x78>
            connection->stream->instance == stream->instance &&
 80203a0:	68fb      	ldr	r3, [r7, #12]
 80203a2:	681b      	ldr	r3, [r3, #0]
 80203a4:	785a      	ldrb	r2, [r3, #1]
 80203a6:	687b      	ldr	r3, [r7, #4]
 80203a8:	785b      	ldrb	r3, [r3, #1]
        if(connection->stream->type == stream->type &&
 80203aa:	429a      	cmp	r2, r3
 80203ac:	d11c      	bne.n	80203e8 <connection_is_up+0x78>
             connection->stream->state.is_usb == stream->state.is_usb) {
 80203ae:	68fb      	ldr	r3, [r7, #12]
 80203b0:	681b      	ldr	r3, [r3, #0]
 80203b2:	789b      	ldrb	r3, [r3, #2]
 80203b4:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80203b8:	b2da      	uxtb	r2, r3
 80203ba:	687b      	ldr	r3, [r7, #4]
 80203bc:	789b      	ldrb	r3, [r3, #2]
 80203be:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80203c2:	b2db      	uxtb	r3, r3
            connection->stream->instance == stream->instance &&
 80203c4:	429a      	cmp	r2, r3
 80203c6:	d10f      	bne.n	80203e8 <connection_is_up+0x78>

            if(connection->stream->state.is_usb)
 80203c8:	68fb      	ldr	r3, [r7, #12]
 80203ca:	681b      	ldr	r3, [r3, #0]
 80203cc:	789b      	ldrb	r3, [r3, #2]
 80203ce:	f003 0304 	and.w	r3, r3, #4
 80203d2:	b2db      	uxtb	r3, r3
 80203d4:	2b00      	cmp	r3, #0
 80203d6:	d002      	beq.n	80203de <connection_is_up+0x6e>
                connection->is_up = is_not_connected;
 80203d8:	68fb      	ldr	r3, [r7, #12]
 80203da:	4a0a      	ldr	r2, [pc, #40]	; (8020404 <connection_is_up+0x94>)
 80203dc:	605a      	str	r2, [r3, #4]

            return connection->is_up();
 80203de:	68fb      	ldr	r3, [r7, #12]
 80203e0:	685b      	ldr	r3, [r3, #4]
 80203e2:	4798      	blx	r3
 80203e4:	4603      	mov	r3, r0
 80203e6:	e006      	b.n	80203f6 <connection_is_up+0x86>
        }
        connection = connection->next;
 80203e8:	68fb      	ldr	r3, [r7, #12]
 80203ea:	68db      	ldr	r3, [r3, #12]
 80203ec:	60fb      	str	r3, [r7, #12]
    while(connection) {
 80203ee:	68fb      	ldr	r3, [r7, #12]
 80203f0:	2b00      	cmp	r3, #0
 80203f2:	d1ce      	bne.n	8020392 <connection_is_up+0x22>
    }

    return false;
 80203f4:	2300      	movs	r3, #0
}
 80203f6:	4618      	mov	r0, r3
 80203f8:	3710      	adds	r7, #16
 80203fa:	46bd      	mov	sp, r7
 80203fc:	bd80      	pop	{r7, pc}
 80203fe:	bf00      	nop
 8020400:	20000398 	.word	0x20000398
 8020404:	08020363 	.word	0x08020363

08020408 <stream_write_all>:

static void stream_write_all (const char *s)
{
 8020408:	b580      	push	{r7, lr}
 802040a:	b084      	sub	sp, #16
 802040c:	af00      	add	r7, sp, #0
 802040e:	6078      	str	r0, [r7, #4]
    stream_connection_t *connection = connections;
 8020410:	4b0c      	ldr	r3, [pc, #48]	; (8020444 <stream_write_all+0x3c>)
 8020412:	681b      	ldr	r3, [r3, #0]
 8020414:	60fb      	str	r3, [r7, #12]

    while(connection) {
 8020416:	e00d      	b.n	8020434 <stream_write_all+0x2c>
        if(connection->is_up())
 8020418:	68fb      	ldr	r3, [r7, #12]
 802041a:	685b      	ldr	r3, [r3, #4]
 802041c:	4798      	blx	r3
 802041e:	4603      	mov	r3, r0
 8020420:	2b00      	cmp	r3, #0
 8020422:	d004      	beq.n	802042e <stream_write_all+0x26>
            connection->stream->write(s);
 8020424:	68fb      	ldr	r3, [r7, #12]
 8020426:	681b      	ldr	r3, [r3, #0]
 8020428:	68db      	ldr	r3, [r3, #12]
 802042a:	6878      	ldr	r0, [r7, #4]
 802042c:	4798      	blx	r3
        connection = connection->next;
 802042e:	68fb      	ldr	r3, [r7, #12]
 8020430:	68db      	ldr	r3, [r3, #12]
 8020432:	60fb      	str	r3, [r7, #12]
    while(connection) {
 8020434:	68fb      	ldr	r3, [r7, #12]
 8020436:	2b00      	cmp	r3, #0
 8020438:	d1ee      	bne.n	8020418 <stream_write_all+0x10>
    }
}
 802043a:	bf00      	nop
 802043c:	bf00      	nop
 802043e:	3710      	adds	r7, #16
 8020440:	46bd      	mov	sp, r7
 8020442:	bd80      	pop	{r7, pc}
 8020444:	20000398 	.word	0x20000398

08020448 <add_connection>:

static stream_connection_t *add_connection (const io_stream_t *stream)
{
 8020448:	b580      	push	{r7, lr}
 802044a:	b084      	sub	sp, #16
 802044c:	af00      	add	r7, sp, #0
 802044e:	6078      	str	r0, [r7, #4]
    stream_connection_t *connection, *last = connections;
 8020450:	4b26      	ldr	r3, [pc, #152]	; (80204ec <add_connection+0xa4>)
 8020452:	681b      	ldr	r3, [r3, #0]
 8020454:	60bb      	str	r3, [r7, #8]

    if(base.stream == NULL) {
 8020456:	4b26      	ldr	r3, [pc, #152]	; (80204f0 <add_connection+0xa8>)
 8020458:	681b      	ldr	r3, [r3, #0]
 802045a:	2b00      	cmp	r3, #0
 802045c:	d105      	bne.n	802046a <add_connection+0x22>
        base.stream = stream;
 802045e:	4a24      	ldr	r2, [pc, #144]	; (80204f0 <add_connection+0xa8>)
 8020460:	687b      	ldr	r3, [r7, #4]
 8020462:	6013      	str	r3, [r2, #0]
        connection = &base;
 8020464:	4b22      	ldr	r3, [pc, #136]	; (80204f0 <add_connection+0xa8>)
 8020466:	60fb      	str	r3, [r7, #12]
 8020468:	e022      	b.n	80204b0 <add_connection+0x68>
    } else if((connection = malloc(sizeof(stream_connection_t)))) {
 802046a:	2010      	movs	r0, #16
 802046c:	f003 f824 	bl	80234b8 <malloc>
 8020470:	4603      	mov	r3, r0
 8020472:	60fb      	str	r3, [r7, #12]
 8020474:	68fb      	ldr	r3, [r7, #12]
 8020476:	2b00      	cmp	r3, #0
 8020478:	d01a      	beq.n	80204b0 <add_connection+0x68>
        connection->stream = stream;
 802047a:	68fb      	ldr	r3, [r7, #12]
 802047c:	687a      	ldr	r2, [r7, #4]
 802047e:	601a      	str	r2, [r3, #0]
        connection->next = NULL;
 8020480:	68fb      	ldr	r3, [r7, #12]
 8020482:	2200      	movs	r2, #0
 8020484:	60da      	str	r2, [r3, #12]
        while(last->next) {
 8020486:	e00c      	b.n	80204a2 <add_connection+0x5a>
            last = last->next;
 8020488:	68bb      	ldr	r3, [r7, #8]
 802048a:	68db      	ldr	r3, [r3, #12]
 802048c:	60bb      	str	r3, [r7, #8]
            if(last->stream == stream) {
 802048e:	68bb      	ldr	r3, [r7, #8]
 8020490:	681b      	ldr	r3, [r3, #0]
 8020492:	687a      	ldr	r2, [r7, #4]
 8020494:	429a      	cmp	r2, r3
 8020496:	d104      	bne.n	80204a2 <add_connection+0x5a>
                free(connection);
 8020498:	68f8      	ldr	r0, [r7, #12]
 802049a:	f003 f815 	bl	80234c8 <free>
                return NULL;
 802049e:	2300      	movs	r3, #0
 80204a0:	e01f      	b.n	80204e2 <add_connection+0x9a>
        while(last->next) {
 80204a2:	68bb      	ldr	r3, [r7, #8]
 80204a4:	68db      	ldr	r3, [r3, #12]
 80204a6:	2b00      	cmp	r3, #0
 80204a8:	d1ee      	bne.n	8020488 <add_connection+0x40>
            }
        }
        last->next = connection;
 80204aa:	68bb      	ldr	r3, [r7, #8]
 80204ac:	68fa      	ldr	r2, [r7, #12]
 80204ae:	60da      	str	r2, [r3, #12]
    }

    connection->is_up = stream->is_connected ?
 80204b0:	687b      	ldr	r3, [r7, #4]
 80204b2:	685b      	ldr	r3, [r3, #4]
                         stream->is_connected :
 80204b4:	2b00      	cmp	r3, #0
 80204b6:	d002      	beq.n	80204be <add_connection+0x76>
 80204b8:	687b      	ldr	r3, [r7, #4]
 80204ba:	685b      	ldr	r3, [r3, #4]
 80204bc:	e00e      	b.n	80204dc <add_connection+0x94>
                          (stream->state.is_usb && base.stream != stream ? is_not_connected : is_connected);
 80204be:	687b      	ldr	r3, [r7, #4]
 80204c0:	789b      	ldrb	r3, [r3, #2]
 80204c2:	f003 0304 	and.w	r3, r3, #4
 80204c6:	b2db      	uxtb	r3, r3
 80204c8:	2b00      	cmp	r3, #0
 80204ca:	d006      	beq.n	80204da <add_connection+0x92>
 80204cc:	4b08      	ldr	r3, [pc, #32]	; (80204f0 <add_connection+0xa8>)
 80204ce:	681b      	ldr	r3, [r3, #0]
 80204d0:	687a      	ldr	r2, [r7, #4]
 80204d2:	429a      	cmp	r2, r3
 80204d4:	d001      	beq.n	80204da <add_connection+0x92>
 80204d6:	4b07      	ldr	r3, [pc, #28]	; (80204f4 <add_connection+0xac>)
 80204d8:	e000      	b.n	80204dc <add_connection+0x94>
 80204da:	4b07      	ldr	r3, [pc, #28]	; (80204f8 <add_connection+0xb0>)
    connection->is_up = stream->is_connected ?
 80204dc:	68fa      	ldr	r2, [r7, #12]
 80204de:	6053      	str	r3, [r2, #4]

    return connection;
 80204e0:	68fb      	ldr	r3, [r7, #12]
}
 80204e2:	4618      	mov	r0, r3
 80204e4:	3710      	adds	r7, #16
 80204e6:	46bd      	mov	sp, r7
 80204e8:	bd80      	pop	{r7, pc}
 80204ea:	bf00      	nop
 80204ec:	20000398 	.word	0x20000398
 80204f0:	20002114 	.word	0x20002114
 80204f4:	08020363 	.word	0x08020363
 80204f8:	08020355 	.word	0x08020355

080204fc <stream_select>:

static bool stream_select (const io_stream_t *stream, bool add)
{
 80204fc:	b580      	push	{r7, lr}
 80204fe:	b086      	sub	sp, #24
 8020500:	af00      	add	r7, sp, #0
 8020502:	6078      	str	r0, [r7, #4]
 8020504:	460b      	mov	r3, r1
 8020506:	70fb      	strb	r3, [r7, #3]
    static const io_stream_t *active_stream = NULL;

    if(stream == base.stream) {
 8020508:	4b76      	ldr	r3, [pc, #472]	; (80206e4 <stream_select+0x1e8>)
 802050a:	681b      	ldr	r3, [r3, #0]
 802050c:	687a      	ldr	r2, [r7, #4]
 802050e:	429a      	cmp	r2, r3
 8020510:	d110      	bne.n	8020534 <stream_select+0x38>
        base.is_up = add ? (stream->is_connected ? stream->is_connected : is_connected) : is_not_connected;
 8020512:	78fb      	ldrb	r3, [r7, #3]
 8020514:	2b00      	cmp	r3, #0
 8020516:	d008      	beq.n	802052a <stream_select+0x2e>
 8020518:	687b      	ldr	r3, [r7, #4]
 802051a:	685b      	ldr	r3, [r3, #4]
 802051c:	2b00      	cmp	r3, #0
 802051e:	d002      	beq.n	8020526 <stream_select+0x2a>
 8020520:	687b      	ldr	r3, [r7, #4]
 8020522:	685b      	ldr	r3, [r3, #4]
 8020524:	e002      	b.n	802052c <stream_select+0x30>
 8020526:	4b70      	ldr	r3, [pc, #448]	; (80206e8 <stream_select+0x1ec>)
 8020528:	e000      	b.n	802052c <stream_select+0x30>
 802052a:	4b70      	ldr	r3, [pc, #448]	; (80206ec <stream_select+0x1f0>)
 802052c:	4a6d      	ldr	r2, [pc, #436]	; (80206e4 <stream_select+0x1e8>)
 802052e:	6053      	str	r3, [r2, #4]
        return true;
 8020530:	2301      	movs	r3, #1
 8020532:	e135      	b.n	80207a0 <stream_select+0x2a4>
    }

    if(add) {
 8020534:	78fb      	ldrb	r3, [r7, #3]
 8020536:	2b00      	cmp	r3, #0
 8020538:	d007      	beq.n	802054a <stream_select+0x4e>

        if(add_connection(stream) == NULL)
 802053a:	6878      	ldr	r0, [r7, #4]
 802053c:	f7ff ff84 	bl	8020448 <add_connection>
 8020540:	4603      	mov	r3, r0
 8020542:	2b00      	cmp	r3, #0
 8020544:	d124      	bne.n	8020590 <stream_select+0x94>
            return false;
 8020546:	2300      	movs	r3, #0
 8020548:	e12a      	b.n	80207a0 <stream_select+0x2a4>

    } else { // disconnect

        stream_connection_t *prev, *last = connections;
 802054a:	4b69      	ldr	r3, [pc, #420]	; (80206f0 <stream_select+0x1f4>)
 802054c:	681b      	ldr	r3, [r3, #0]
 802054e:	617b      	str	r3, [r7, #20]

        while(last->next) {
 8020550:	e01a      	b.n	8020588 <stream_select+0x8c>
            prev = last;
 8020552:	697b      	ldr	r3, [r7, #20]
 8020554:	613b      	str	r3, [r7, #16]
            last = last->next;
 8020556:	697b      	ldr	r3, [r7, #20]
 8020558:	68db      	ldr	r3, [r3, #12]
 802055a:	617b      	str	r3, [r7, #20]
            if(last->stream == stream) {
 802055c:	697b      	ldr	r3, [r7, #20]
 802055e:	681b      	ldr	r3, [r3, #0]
 8020560:	687a      	ldr	r2, [r7, #4]
 8020562:	429a      	cmp	r2, r3
 8020564:	d110      	bne.n	8020588 <stream_select+0x8c>
                prev->next = last->next;
 8020566:	697b      	ldr	r3, [r7, #20]
 8020568:	68da      	ldr	r2, [r3, #12]
 802056a:	693b      	ldr	r3, [r7, #16]
 802056c:	60da      	str	r2, [r3, #12]
                free(last);
 802056e:	6978      	ldr	r0, [r7, #20]
 8020570:	f002 ffaa 	bl	80234c8 <free>
                if(prev->next)
 8020574:	693b      	ldr	r3, [r7, #16]
 8020576:	68db      	ldr	r3, [r3, #12]
 8020578:	2b00      	cmp	r3, #0
 802057a:	d001      	beq.n	8020580 <stream_select+0x84>
                    return false;
 802057c:	2300      	movs	r3, #0
 802057e:	e10f      	b.n	80207a0 <stream_select+0x2a4>
                else {
                    stream = prev->stream;
 8020580:	693b      	ldr	r3, [r7, #16]
 8020582:	681b      	ldr	r3, [r3, #0]
 8020584:	607b      	str	r3, [r7, #4]
                    break;
 8020586:	e003      	b.n	8020590 <stream_select+0x94>
        while(last->next) {
 8020588:	697b      	ldr	r3, [r7, #20]
 802058a:	68db      	ldr	r3, [r3, #12]
 802058c:	2b00      	cmp	r3, #0
 802058e:	d1e0      	bne.n	8020552 <stream_select+0x56>
                }
            }
        }
    }

    bool webui_connected = hal.stream.state.webui_connected;
 8020590:	4b58      	ldr	r3, [pc, #352]	; (80206f4 <stream_select+0x1f8>)
 8020592:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 8020596:	f3c3 0340 	ubfx	r3, r3, #1, #1
 802059a:	b2db      	uxtb	r3, r3
 802059c:	2b00      	cmp	r3, #0
 802059e:	bf14      	ite	ne
 80205a0:	2301      	movne	r3, #1
 80205a2:	2300      	moveq	r3, #0
 80205a4:	73fb      	strb	r3, [r7, #15]

    switch(stream->type) {
 80205a6:	687b      	ldr	r3, [r7, #4]
 80205a8:	781b      	ldrb	r3, [r3, #0]
 80205aa:	2b04      	cmp	r3, #4
 80205ac:	d87e      	bhi.n	80206ac <stream_select+0x1b0>
 80205ae:	a201      	add	r2, pc, #4	; (adr r2, 80205b4 <stream_select+0xb8>)
 80205b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80205b4:	080205c9 	.word	0x080205c9
 80205b8:	080206ad 	.word	0x080206ad
 80205bc:	08020677 	.word	0x08020677
 80205c0:	080205fb 	.word	0x080205fb
 80205c4:	08020631 	.word	0x08020631

        case StreamType_Serial:
            if(active_stream && active_stream->type != StreamType_Serial && connection_is_up((io_stream_t *)stream)) {
 80205c8:	4b4b      	ldr	r3, [pc, #300]	; (80206f8 <stream_select+0x1fc>)
 80205ca:	681b      	ldr	r3, [r3, #0]
 80205cc:	2b00      	cmp	r3, #0
 80205ce:	d06f      	beq.n	80206b0 <stream_select+0x1b4>
 80205d0:	4b49      	ldr	r3, [pc, #292]	; (80206f8 <stream_select+0x1fc>)
 80205d2:	681b      	ldr	r3, [r3, #0]
 80205d4:	781b      	ldrb	r3, [r3, #0]
 80205d6:	2b00      	cmp	r3, #0
 80205d8:	d06a      	beq.n	80206b0 <stream_select+0x1b4>
 80205da:	6878      	ldr	r0, [r7, #4]
 80205dc:	f7ff fec8 	bl	8020370 <connection_is_up>
 80205e0:	4603      	mov	r3, r0
 80205e2:	2b00      	cmp	r3, #0
 80205e4:	d064      	beq.n	80206b0 <stream_select+0x1b4>
                hal.stream.write = stream->write;
 80205e6:	687b      	ldr	r3, [r7, #4]
 80205e8:	68db      	ldr	r3, [r3, #12]
 80205ea:	4a42      	ldr	r2, [pc, #264]	; (80206f4 <stream_select+0x1f8>)
 80205ec:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
                report_message("SERIAL STREAM ACTIVE", Message_Plain);
 80205f0:	2100      	movs	r1, #0
 80205f2:	4842      	ldr	r0, [pc, #264]	; (80206fc <stream_select+0x200>)
 80205f4:	f7f3 ff80 	bl	80144f8 <report_message>
            }
            break;
 80205f8:	e05a      	b.n	80206b0 <stream_select+0x1b4>

        case StreamType_Telnet:
            if(connection_is_up(&hal.stream))
 80205fa:	4841      	ldr	r0, [pc, #260]	; (8020700 <stream_select+0x204>)
 80205fc:	f7ff feb8 	bl	8020370 <connection_is_up>
 8020600:	4603      	mov	r3, r0
 8020602:	2b00      	cmp	r3, #0
 8020604:	d003      	beq.n	802060e <stream_select+0x112>
                report_message("TELNET STREAM ACTIVE", Message_Plain);
 8020606:	2100      	movs	r1, #0
 8020608:	483e      	ldr	r0, [pc, #248]	; (8020704 <stream_select+0x208>)
 802060a:	f7f3 ff75 	bl	80144f8 <report_message>
            if(add && sys.driver_started) {
 802060e:	78fb      	ldrb	r3, [r7, #3]
 8020610:	2b00      	cmp	r3, #0
 8020612:	d04f      	beq.n	80206b4 <stream_select+0x1b8>
 8020614:	4b3c      	ldr	r3, [pc, #240]	; (8020708 <stream_select+0x20c>)
 8020616:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 802061a:	2b00      	cmp	r3, #0
 802061c:	d04a      	beq.n	80206b4 <stream_select+0x1b8>
                hal.stream.write_all = stream->write;
 802061e:	687b      	ldr	r3, [r7, #4]
 8020620:	68db      	ldr	r3, [r3, #12]
 8020622:	4a34      	ldr	r2, [pc, #208]	; (80206f4 <stream_select+0x1f8>)
 8020624:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
                grbl.report.init_message();
 8020628:	4b38      	ldr	r3, [pc, #224]	; (802070c <stream_select+0x210>)
 802062a:	681b      	ldr	r3, [r3, #0]
 802062c:	4798      	blx	r3
            }
            break;
 802062e:	e041      	b.n	80206b4 <stream_select+0x1b8>

        case StreamType_WebSocket:
            if(connection_is_up(&hal.stream))
 8020630:	4833      	ldr	r0, [pc, #204]	; (8020700 <stream_select+0x204>)
 8020632:	f7ff fe9d 	bl	8020370 <connection_is_up>
 8020636:	4603      	mov	r3, r0
 8020638:	2b00      	cmp	r3, #0
 802063a:	d003      	beq.n	8020644 <stream_select+0x148>
                report_message("WEBSOCKET STREAM ACTIVE", Message_Plain);
 802063c:	2100      	movs	r1, #0
 802063e:	4834      	ldr	r0, [pc, #208]	; (8020710 <stream_select+0x214>)
 8020640:	f7f3 ff5a 	bl	80144f8 <report_message>
            if(add && sys.driver_started && !hal.stream.state.webui_connected) {
 8020644:	78fb      	ldrb	r3, [r7, #3]
 8020646:	2b00      	cmp	r3, #0
 8020648:	d036      	beq.n	80206b8 <stream_select+0x1bc>
 802064a:	4b2f      	ldr	r3, [pc, #188]	; (8020708 <stream_select+0x20c>)
 802064c:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8020650:	2b00      	cmp	r3, #0
 8020652:	d031      	beq.n	80206b8 <stream_select+0x1bc>
 8020654:	4b27      	ldr	r3, [pc, #156]	; (80206f4 <stream_select+0x1f8>)
 8020656:	f893 30aa 	ldrb.w	r3, [r3, #170]	; 0xaa
 802065a:	f003 0302 	and.w	r3, r3, #2
 802065e:	b2db      	uxtb	r3, r3
 8020660:	2b00      	cmp	r3, #0
 8020662:	d129      	bne.n	80206b8 <stream_select+0x1bc>
                hal.stream.write_all = stream->write;
 8020664:	687b      	ldr	r3, [r7, #4]
 8020666:	68db      	ldr	r3, [r3, #12]
 8020668:	4a22      	ldr	r2, [pc, #136]	; (80206f4 <stream_select+0x1f8>)
 802066a:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
                grbl.report.init_message();
 802066e:	4b27      	ldr	r3, [pc, #156]	; (802070c <stream_select+0x210>)
 8020670:	681b      	ldr	r3, [r3, #0]
 8020672:	4798      	blx	r3
            }
            break;
 8020674:	e020      	b.n	80206b8 <stream_select+0x1bc>

        case StreamType_Bluetooth:
            if(connection_is_up(&hal.stream))
 8020676:	4822      	ldr	r0, [pc, #136]	; (8020700 <stream_select+0x204>)
 8020678:	f7ff fe7a 	bl	8020370 <connection_is_up>
 802067c:	4603      	mov	r3, r0
 802067e:	2b00      	cmp	r3, #0
 8020680:	d003      	beq.n	802068a <stream_select+0x18e>
                report_message("BLUETOOTH STREAM ACTIVE", Message_Plain);
 8020682:	2100      	movs	r1, #0
 8020684:	4823      	ldr	r0, [pc, #140]	; (8020714 <stream_select+0x218>)
 8020686:	f7f3 ff37 	bl	80144f8 <report_message>
            if(add && sys.driver_started) {
 802068a:	78fb      	ldrb	r3, [r7, #3]
 802068c:	2b00      	cmp	r3, #0
 802068e:	d015      	beq.n	80206bc <stream_select+0x1c0>
 8020690:	4b1d      	ldr	r3, [pc, #116]	; (8020708 <stream_select+0x20c>)
 8020692:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8020696:	2b00      	cmp	r3, #0
 8020698:	d010      	beq.n	80206bc <stream_select+0x1c0>
                hal.stream.write_all = stream->write;
 802069a:	687b      	ldr	r3, [r7, #4]
 802069c:	68db      	ldr	r3, [r3, #12]
 802069e:	4a15      	ldr	r2, [pc, #84]	; (80206f4 <stream_select+0x1f8>)
 80206a0:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
                grbl.report.init_message();
 80206a4:	4b19      	ldr	r3, [pc, #100]	; (802070c <stream_select+0x210>)
 80206a6:	681b      	ldr	r3, [r3, #0]
 80206a8:	4798      	blx	r3
            }
            break;
 80206aa:	e007      	b.n	80206bc <stream_select+0x1c0>

        default:
            break;
 80206ac:	bf00      	nop
 80206ae:	e006      	b.n	80206be <stream_select+0x1c2>
            break;
 80206b0:	bf00      	nop
 80206b2:	e004      	b.n	80206be <stream_select+0x1c2>
            break;
 80206b4:	bf00      	nop
 80206b6:	e002      	b.n	80206be <stream_select+0x1c2>
            break;
 80206b8:	bf00      	nop
 80206ba:	e000      	b.n	80206be <stream_select+0x1c2>
            break;
 80206bc:	bf00      	nop
    }

    memcpy(&hal.stream, stream, sizeof(io_stream_t));
 80206be:	224c      	movs	r2, #76	; 0x4c
 80206c0:	6879      	ldr	r1, [r7, #4]
 80206c2:	480f      	ldr	r0, [pc, #60]	; (8020700 <stream_select+0x204>)
 80206c4:	f003 fc03 	bl	8023ece <memcpy>

    if(!hal.stream.write_all)
 80206c8:	4b0a      	ldr	r3, [pc, #40]	; (80206f4 <stream_select+0x1f8>)
 80206ca:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80206ce:	2b00      	cmp	r3, #0
 80206d0:	d126      	bne.n	8020720 <stream_select+0x224>
        hal.stream.write_all = base.next != NULL ? stream_write_all : hal.stream.write;
 80206d2:	4b04      	ldr	r3, [pc, #16]	; (80206e4 <stream_select+0x1e8>)
 80206d4:	68db      	ldr	r3, [r3, #12]
 80206d6:	2b00      	cmp	r3, #0
 80206d8:	d11e      	bne.n	8020718 <stream_select+0x21c>
 80206da:	4b06      	ldr	r3, [pc, #24]	; (80206f4 <stream_select+0x1f8>)
 80206dc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80206e0:	e01b      	b.n	802071a <stream_select+0x21e>
 80206e2:	bf00      	nop
 80206e4:	20002114 	.word	0x20002114
 80206e8:	08020355 	.word	0x08020355
 80206ec:	08020363 	.word	0x08020363
 80206f0:	20000398 	.word	0x20000398
 80206f4:	20000ed0 	.word	0x20000ed0
 80206f8:	20002138 	.word	0x20002138
 80206fc:	0802f5c0 	.word	0x0802f5c0
 8020700:	20000f78 	.word	0x20000f78
 8020704:	0802f5d8 	.word	0x0802f5d8
 8020708:	20000d3c 	.word	0x20000d3c
 802070c:	20000dd4 	.word	0x20000dd4
 8020710:	0802f5f0 	.word	0x0802f5f0
 8020714:	0802f608 	.word	0x0802f608
 8020718:	4b23      	ldr	r3, [pc, #140]	; (80207a8 <stream_select+0x2ac>)
 802071a:	4a24      	ldr	r2, [pc, #144]	; (80207ac <stream_select+0x2b0>)
 802071c:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8

    if(stream == base.stream && base.is_up == is_not_connected)
 8020720:	4b23      	ldr	r3, [pc, #140]	; (80207b0 <stream_select+0x2b4>)
 8020722:	681b      	ldr	r3, [r3, #0]
 8020724:	687a      	ldr	r2, [r7, #4]
 8020726:	429a      	cmp	r2, r3
 8020728:	d107      	bne.n	802073a <stream_select+0x23e>
 802072a:	4b21      	ldr	r3, [pc, #132]	; (80207b0 <stream_select+0x2b4>)
 802072c:	685b      	ldr	r3, [r3, #4]
 802072e:	4a21      	ldr	r2, [pc, #132]	; (80207b4 <stream_select+0x2b8>)
 8020730:	4293      	cmp	r3, r2
 8020732:	d102      	bne.n	802073a <stream_select+0x23e>
        base.is_up = is_connected;
 8020734:	4b1e      	ldr	r3, [pc, #120]	; (80207b0 <stream_select+0x2b4>)
 8020736:	4a20      	ldr	r2, [pc, #128]	; (80207b8 <stream_select+0x2bc>)
 8020738:	605a      	str	r2, [r3, #4]

    if(stream->type == StreamType_WebSocket && !stream->state.webui_connected)
 802073a:	687b      	ldr	r3, [r7, #4]
 802073c:	781b      	ldrb	r3, [r3, #0]
 802073e:	2b04      	cmp	r3, #4
 8020740:	d10e      	bne.n	8020760 <stream_select+0x264>
 8020742:	687b      	ldr	r3, [r7, #4]
 8020744:	789b      	ldrb	r3, [r3, #2]
 8020746:	f003 0302 	and.w	r3, r3, #2
 802074a:	b2db      	uxtb	r3, r3
 802074c:	2b00      	cmp	r3, #0
 802074e:	d107      	bne.n	8020760 <stream_select+0x264>
        hal.stream.state.webui_connected = webui_connected;
 8020750:	4a16      	ldr	r2, [pc, #88]	; (80207ac <stream_select+0x2b0>)
 8020752:	f892 30aa 	ldrb.w	r3, [r2, #170]	; 0xaa
 8020756:	7bf9      	ldrb	r1, [r7, #15]
 8020758:	f361 0341 	bfi	r3, r1, #1, #1
 802075c:	f882 30aa 	strb.w	r3, [r2, #170]	; 0xaa

    hal.stream.set_enqueue_rt_handler(protocol_enqueue_realtime_command);
 8020760:	4b12      	ldr	r3, [pc, #72]	; (80207ac <stream_select+0x2b0>)
 8020762:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8020766:	4815      	ldr	r0, [pc, #84]	; (80207bc <stream_select+0x2c0>)
 8020768:	4798      	blx	r3

    if(hal.stream.disable_rx)
 802076a:	4b10      	ldr	r3, [pc, #64]	; (80207ac <stream_select+0x2b0>)
 802076c:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8020770:	2b00      	cmp	r3, #0
 8020772:	d004      	beq.n	802077e <stream_select+0x282>
        hal.stream.disable_rx(false);
 8020774:	4b0d      	ldr	r3, [pc, #52]	; (80207ac <stream_select+0x2b0>)
 8020776:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 802077a:	2000      	movs	r0, #0
 802077c:	4798      	blx	r3

    if(grbl.on_stream_changed)
 802077e:	4b10      	ldr	r3, [pc, #64]	; (80207c0 <stream_select+0x2c4>)
 8020780:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8020784:	2b00      	cmp	r3, #0
 8020786:	d007      	beq.n	8020798 <stream_select+0x29c>
        grbl.on_stream_changed(hal.stream.type);
 8020788:	4b0d      	ldr	r3, [pc, #52]	; (80207c0 <stream_select+0x2c4>)
 802078a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802078e:	4a07      	ldr	r2, [pc, #28]	; (80207ac <stream_select+0x2b0>)
 8020790:	f892 20a8 	ldrb.w	r2, [r2, #168]	; 0xa8
 8020794:	4610      	mov	r0, r2
 8020796:	4798      	blx	r3

    active_stream = stream;
 8020798:	4a0a      	ldr	r2, [pc, #40]	; (80207c4 <stream_select+0x2c8>)
 802079a:	687b      	ldr	r3, [r7, #4]
 802079c:	6013      	str	r3, [r2, #0]

    return true;
 802079e:	2301      	movs	r3, #1
}
 80207a0:	4618      	mov	r0, r3
 80207a2:	3718      	adds	r7, #24
 80207a4:	46bd      	mov	sp, r7
 80207a6:	bd80      	pop	{r7, pc}
 80207a8:	08020409 	.word	0x08020409
 80207ac:	20000ed0 	.word	0x20000ed0
 80207b0:	20002114 	.word	0x20002114
 80207b4:	08020363 	.word	0x08020363
 80207b8:	08020355 	.word	0x08020355
 80207bc:	08013719 	.word	0x08013719
 80207c0:	20000dd4 	.word	0x20000dd4
 80207c4:	20002138 	.word	0x20002138

080207c8 <stream_connect>:

    return flags;
}

bool stream_connect (const io_stream_t *stream)
{
 80207c8:	b580      	push	{r7, lr}
 80207ca:	b084      	sub	sp, #16
 80207cc:	af00      	add	r7, sp, #0
 80207ce:	6078      	str	r0, [r7, #4]
    bool ok;

    if((ok = stream_select(stream, true)) && stream->type == StreamType_Serial && !stream->state.is_usb && hal.periph_port.set_pin_description) {
 80207d0:	2101      	movs	r1, #1
 80207d2:	6878      	ldr	r0, [r7, #4]
 80207d4:	f7ff fe92 	bl	80204fc <stream_select>
 80207d8:	4603      	mov	r3, r0
 80207da:	73fb      	strb	r3, [r7, #15]
 80207dc:	7bfb      	ldrb	r3, [r7, #15]
 80207de:	2b00      	cmp	r3, #0
 80207e0:	d023      	beq.n	802082a <stream_connect+0x62>
 80207e2:	687b      	ldr	r3, [r7, #4]
 80207e4:	781b      	ldrb	r3, [r3, #0]
 80207e6:	2b00      	cmp	r3, #0
 80207e8:	d11f      	bne.n	802082a <stream_connect+0x62>
 80207ea:	687b      	ldr	r3, [r7, #4]
 80207ec:	789b      	ldrb	r3, [r3, #2]
 80207ee:	f003 0304 	and.w	r3, r3, #4
 80207f2:	b2db      	uxtb	r3, r3
 80207f4:	2b00      	cmp	r3, #0
 80207f6:	d118      	bne.n	802082a <stream_connect+0x62>
 80207f8:	4b0e      	ldr	r3, [pc, #56]	; (8020834 <stream_connect+0x6c>)
 80207fa:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 80207fe:	2b00      	cmp	r3, #0
 8020800:	d013      	beq.n	802082a <stream_connect+0x62>
        hal.periph_port.set_pin_description(Input_RX, (pin_group_t)(PinGroup_UART + stream->instance), "Primary UART");
 8020802:	4b0c      	ldr	r3, [pc, #48]	; (8020834 <stream_connect+0x6c>)
 8020804:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 8020808:	687a      	ldr	r2, [r7, #4]
 802080a:	7852      	ldrb	r2, [r2, #1]
 802080c:	3211      	adds	r2, #17
 802080e:	4611      	mov	r1, r2
 8020810:	4a09      	ldr	r2, [pc, #36]	; (8020838 <stream_connect+0x70>)
 8020812:	2029      	movs	r0, #41	; 0x29
 8020814:	4798      	blx	r3
        hal.periph_port.set_pin_description(Output_TX, (pin_group_t)(PinGroup_UART + stream->instance), "Primary UART");
 8020816:	4b07      	ldr	r3, [pc, #28]	; (8020834 <stream_connect+0x6c>)
 8020818:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
 802081c:	687a      	ldr	r2, [r7, #4]
 802081e:	7852      	ldrb	r2, [r2, #1]
 8020820:	3211      	adds	r2, #17
 8020822:	4611      	mov	r1, r2
 8020824:	4a04      	ldr	r2, [pc, #16]	; (8020838 <stream_connect+0x70>)
 8020826:	2075      	movs	r0, #117	; 0x75
 8020828:	4798      	blx	r3
    }

    return ok;
 802082a:	7bfb      	ldrb	r3, [r7, #15]
}
 802082c:	4618      	mov	r0, r3
 802082e:	3710      	adds	r7, #16
 8020830:	46bd      	mov	sp, r7
 8020832:	bd80      	pop	{r7, pc}
 8020834:	20000ed0 	.word	0x20000ed0
 8020838:	0802f620 	.word	0x0802f620

0802083c <stream_mpg_enable>:

    return connection != NULL;
}

bool stream_mpg_enable (bool on)
{
 802083c:	b590      	push	{r4, r7, lr}
 802083e:	b085      	sub	sp, #20
 8020840:	af00      	add	r7, sp, #0
 8020842:	4603      	mov	r3, r0
 8020844:	71fb      	strb	r3, [r7, #7]
    static io_stream_t org_stream = {
        .type = StreamType_Redirected
    };

    if(mpg.stream == NULL)
 8020846:	4b5d      	ldr	r3, [pc, #372]	; (80209bc <stream_mpg_enable+0x180>)
 8020848:	681b      	ldr	r3, [r3, #0]
 802084a:	2b00      	cmp	r3, #0
 802084c:	d101      	bne.n	8020852 <stream_mpg_enable+0x16>
        return false;
 802084e:	2300      	movs	r3, #0
 8020850:	e0af      	b.n	80209b2 <stream_mpg_enable+0x176>

    sys_state_t state = state_get();
 8020852:	f7fd f835 	bl	801d8c0 <state_get>
 8020856:	60f8      	str	r0, [r7, #12]

    // Deny entering MPG mode if busy
    if(on == sys.mpg_mode || (on && (gc_state.file_run || !(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP)))))) {
 8020858:	4b59      	ldr	r3, [pc, #356]	; (80209c0 <stream_mpg_enable+0x184>)
 802085a:	f893 307f 	ldrb.w	r3, [r3, #127]	; 0x7f
 802085e:	79fa      	ldrb	r2, [r7, #7]
 8020860:	429a      	cmp	r2, r3
 8020862:	d010      	beq.n	8020886 <stream_mpg_enable+0x4a>
 8020864:	79fb      	ldrb	r3, [r7, #7]
 8020866:	2b00      	cmp	r3, #0
 8020868:	d012      	beq.n	8020890 <stream_mpg_enable+0x54>
 802086a:	4b56      	ldr	r3, [pc, #344]	; (80209c4 <stream_mpg_enable+0x188>)
 802086c:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8020870:	2b00      	cmp	r3, #0
 8020872:	d108      	bne.n	8020886 <stream_mpg_enable+0x4a>
 8020874:	68fb      	ldr	r3, [r7, #12]
 8020876:	2b00      	cmp	r3, #0
 8020878:	d00a      	beq.n	8020890 <stream_mpg_enable+0x54>
 802087a:	68fa      	ldr	r2, [r7, #12]
 802087c:	f240 1301 	movw	r3, #257	; 0x101
 8020880:	4013      	ands	r3, r2
 8020882:	2b00      	cmp	r3, #0
 8020884:	d104      	bne.n	8020890 <stream_mpg_enable+0x54>
        protocol_enqueue_realtime_command(CMD_STATUS_REPORT_ALL);
 8020886:	2087      	movs	r0, #135	; 0x87
 8020888:	f7f2 ff46 	bl	8013718 <protocol_enqueue_realtime_command>
        return false;
 802088c:	2300      	movs	r3, #0
 802088e:	e090      	b.n	80209b2 <stream_mpg_enable+0x176>
    }

    if(on) {
 8020890:	79fb      	ldrb	r3, [r7, #7]
 8020892:	2b00      	cmp	r3, #0
 8020894:	d04e      	beq.n	8020934 <stream_mpg_enable+0xf8>
        if(org_stream.type == StreamType_Redirected) {
 8020896:	4b4c      	ldr	r3, [pc, #304]	; (80209c8 <stream_mpg_enable+0x18c>)
 8020898:	781b      	ldrb	r3, [r3, #0]
 802089a:	2b06      	cmp	r3, #6
 802089c:	d174      	bne.n	8020988 <stream_mpg_enable+0x14c>
            memcpy(&org_stream, &hal.stream, sizeof(io_stream_t));
 802089e:	4a4a      	ldr	r2, [pc, #296]	; (80209c8 <stream_mpg_enable+0x18c>)
 80208a0:	4b4a      	ldr	r3, [pc, #296]	; (80209cc <stream_mpg_enable+0x190>)
 80208a2:	4610      	mov	r0, r2
 80208a4:	33a8      	adds	r3, #168	; 0xa8
 80208a6:	224c      	movs	r2, #76	; 0x4c
 80208a8:	4619      	mov	r1, r3
 80208aa:	f003 fb10 	bl	8023ece <memcpy>
            if(hal.stream.disable_rx)
 80208ae:	4b47      	ldr	r3, [pc, #284]	; (80209cc <stream_mpg_enable+0x190>)
 80208b0:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 80208b4:	2b00      	cmp	r3, #0
 80208b6:	d004      	beq.n	80208c2 <stream_mpg_enable+0x86>
                hal.stream.disable_rx(true);
 80208b8:	4b44      	ldr	r3, [pc, #272]	; (80209cc <stream_mpg_enable+0x190>)
 80208ba:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 80208be:	2001      	movs	r0, #1
 80208c0:	4798      	blx	r3
            mpg.stream->disable_rx(false);
 80208c2:	4b3e      	ldr	r3, [pc, #248]	; (80209bc <stream_mpg_enable+0x180>)
 80208c4:	681b      	ldr	r3, [r3, #0]
 80208c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80208c8:	2000      	movs	r0, #0
 80208ca:	4798      	blx	r3
            mpg.stream->set_enqueue_rt_handler(org_stream.set_enqueue_rt_handler(NULL));
 80208cc:	4b3b      	ldr	r3, [pc, #236]	; (80209bc <stream_mpg_enable+0x180>)
 80208ce:	681b      	ldr	r3, [r3, #0]
 80208d0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 80208d2:	4b3d      	ldr	r3, [pc, #244]	; (80209c8 <stream_mpg_enable+0x18c>)
 80208d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80208d6:	2000      	movs	r0, #0
 80208d8:	4798      	blx	r3
 80208da:	4603      	mov	r3, r0
 80208dc:	4618      	mov	r0, r3
 80208de:	47a0      	blx	r4
            hal.stream.type = StreamType_MPG;
 80208e0:	4b3a      	ldr	r3, [pc, #232]	; (80209cc <stream_mpg_enable+0x190>)
 80208e2:	2201      	movs	r2, #1
 80208e4:	f883 20a8 	strb.w	r2, [r3, #168]	; 0xa8
            hal.stream.read = mpg.stream->read;
 80208e8:	4b34      	ldr	r3, [pc, #208]	; (80209bc <stream_mpg_enable+0x180>)
 80208ea:	681b      	ldr	r3, [r3, #0]
 80208ec:	69db      	ldr	r3, [r3, #28]
 80208ee:	4a37      	ldr	r2, [pc, #220]	; (80209cc <stream_mpg_enable+0x190>)
 80208f0:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
            if(mpg.flags.is_mpg_tx)
 80208f4:	4b31      	ldr	r3, [pc, #196]	; (80209bc <stream_mpg_enable+0x180>)
 80208f6:	7a1b      	ldrb	r3, [r3, #8]
 80208f8:	f003 0302 	and.w	r3, r3, #2
 80208fc:	b2db      	uxtb	r3, r3
 80208fe:	2b00      	cmp	r3, #0
 8020900:	d005      	beq.n	802090e <stream_mpg_enable+0xd2>
                hal.stream.write = mpg.stream->write;
 8020902:	4b2e      	ldr	r3, [pc, #184]	; (80209bc <stream_mpg_enable+0x180>)
 8020904:	681b      	ldr	r3, [r3, #0]
 8020906:	68db      	ldr	r3, [r3, #12]
 8020908:	4a30      	ldr	r2, [pc, #192]	; (80209cc <stream_mpg_enable+0x190>)
 802090a:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
            hal.stream.get_rx_buffer_free = mpg.stream->get_rx_buffer_free;
 802090e:	4b2b      	ldr	r3, [pc, #172]	; (80209bc <stream_mpg_enable+0x180>)
 8020910:	681b      	ldr	r3, [r3, #0]
 8020912:	689b      	ldr	r3, [r3, #8]
 8020914:	4a2d      	ldr	r2, [pc, #180]	; (80209cc <stream_mpg_enable+0x190>)
 8020916:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
            hal.stream.cancel_read_buffer = mpg.stream->cancel_read_buffer;
 802091a:	4b28      	ldr	r3, [pc, #160]	; (80209bc <stream_mpg_enable+0x180>)
 802091c:	681b      	ldr	r3, [r3, #0]
 802091e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020920:	4a2a      	ldr	r2, [pc, #168]	; (80209cc <stream_mpg_enable+0x190>)
 8020922:	f8c2 30cc 	str.w	r3, [r2, #204]	; 0xcc
            hal.stream.reset_read_buffer = mpg.stream->reset_read_buffer;
 8020926:	4b25      	ldr	r3, [pc, #148]	; (80209bc <stream_mpg_enable+0x180>)
 8020928:	681b      	ldr	r3, [r3, #0]
 802092a:	6a1b      	ldr	r3, [r3, #32]
 802092c:	4a27      	ldr	r2, [pc, #156]	; (80209cc <stream_mpg_enable+0x190>)
 802092e:	f8c2 30c8 	str.w	r3, [r2, #200]	; 0xc8
 8020932:	e029      	b.n	8020988 <stream_mpg_enable+0x14c>
        }
    } else if(org_stream.type != StreamType_Redirected) {
 8020934:	4b24      	ldr	r3, [pc, #144]	; (80209c8 <stream_mpg_enable+0x18c>)
 8020936:	781b      	ldrb	r3, [r3, #0]
 8020938:	2b06      	cmp	r3, #6
 802093a:	d025      	beq.n	8020988 <stream_mpg_enable+0x14c>
        if(mpg_write_char)
 802093c:	4b24      	ldr	r3, [pc, #144]	; (80209d0 <stream_mpg_enable+0x194>)
 802093e:	681b      	ldr	r3, [r3, #0]
 8020940:	2b00      	cmp	r3, #0
 8020942:	d007      	beq.n	8020954 <stream_mpg_enable+0x118>
            mpg.stream->set_enqueue_rt_handler(mpg_write_char);
 8020944:	4b1d      	ldr	r3, [pc, #116]	; (80209bc <stream_mpg_enable+0x180>)
 8020946:	681b      	ldr	r3, [r3, #0]
 8020948:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802094a:	4a21      	ldr	r2, [pc, #132]	; (80209d0 <stream_mpg_enable+0x194>)
 802094c:	6812      	ldr	r2, [r2, #0]
 802094e:	4610      	mov	r0, r2
 8020950:	4798      	blx	r3
 8020952:	e004      	b.n	802095e <stream_mpg_enable+0x122>
        else
            mpg.stream->disable_rx(true);
 8020954:	4b19      	ldr	r3, [pc, #100]	; (80209bc <stream_mpg_enable+0x180>)
 8020956:	681b      	ldr	r3, [r3, #0]
 8020958:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802095a:	2001      	movs	r0, #1
 802095c:	4798      	blx	r3
        memcpy(&hal.stream, &org_stream, sizeof(io_stream_t));
 802095e:	4b1b      	ldr	r3, [pc, #108]	; (80209cc <stream_mpg_enable+0x190>)
 8020960:	4a19      	ldr	r2, [pc, #100]	; (80209c8 <stream_mpg_enable+0x18c>)
 8020962:	33a8      	adds	r3, #168	; 0xa8
 8020964:	4611      	mov	r1, r2
 8020966:	224c      	movs	r2, #76	; 0x4c
 8020968:	4618      	mov	r0, r3
 802096a:	f003 fab0 	bl	8023ece <memcpy>
        org_stream.type = StreamType_Redirected;
 802096e:	4b16      	ldr	r3, [pc, #88]	; (80209c8 <stream_mpg_enable+0x18c>)
 8020970:	2206      	movs	r2, #6
 8020972:	701a      	strb	r2, [r3, #0]
        if(hal.stream.disable_rx)
 8020974:	4b15      	ldr	r3, [pc, #84]	; (80209cc <stream_mpg_enable+0x190>)
 8020976:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 802097a:	2b00      	cmp	r3, #0
 802097c:	d004      	beq.n	8020988 <stream_mpg_enable+0x14c>
            hal.stream.disable_rx(false);
 802097e:	4b13      	ldr	r3, [pc, #76]	; (80209cc <stream_mpg_enable+0x190>)
 8020980:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8020984:	2000      	movs	r0, #0
 8020986:	4798      	blx	r3
    }

    hal.stream.reset_read_buffer();
 8020988:	4b10      	ldr	r3, [pc, #64]	; (80209cc <stream_mpg_enable+0x190>)
 802098a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 802098e:	4798      	blx	r3

    sys.mpg_mode = on;
 8020990:	4a0b      	ldr	r2, [pc, #44]	; (80209c0 <stream_mpg_enable+0x184>)
 8020992:	79fb      	ldrb	r3, [r7, #7]
 8020994:	f882 307f 	strb.w	r3, [r2, #127]	; 0x7f
    system_add_rt_report(Report_MPGMode);
 8020998:	2001      	movs	r0, #1
 802099a:	f001 faff 	bl	8021f9c <system_add_rt_report>

    // Force a realtime status report, all reports when MPG mode active
    protocol_enqueue_realtime_command(on ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 802099e:	79fb      	ldrb	r3, [r7, #7]
 80209a0:	2b00      	cmp	r3, #0
 80209a2:	d001      	beq.n	80209a8 <stream_mpg_enable+0x16c>
 80209a4:	2387      	movs	r3, #135	; 0x87
 80209a6:	e000      	b.n	80209aa <stream_mpg_enable+0x16e>
 80209a8:	2380      	movs	r3, #128	; 0x80
 80209aa:	4618      	mov	r0, r3
 80209ac:	f7f2 feb4 	bl	8013718 <protocol_enqueue_realtime_command>

    return true;
 80209b0:	2301      	movs	r3, #1
}
 80209b2:	4618      	mov	r0, r3
 80209b4:	3714      	adds	r7, #20
 80209b6:	46bd      	mov	sp, r7
 80209b8:	bd90      	pop	{r4, r7, pc}
 80209ba:	bf00      	nop
 80209bc:	20002124 	.word	0x20002124
 80209c0:	20000d3c 	.word	0x20000d3c
 80209c4:	20000bb0 	.word	0x20000bb0
 80209c8:	2000039c 	.word	0x2000039c
 80209cc:	20000ed0 	.word	0x20000ed0
 80209d0:	20002134 	.word	0x20002134

080209d4 <hypot_f>:
\param x length
\param y height
\returns length of hypotenuse
 */
inline static float hypot_f (float x, float y)
{
 80209d4:	b590      	push	{r4, r7, lr}
 80209d6:	b083      	sub	sp, #12
 80209d8:	af00      	add	r7, sp, #0
 80209da:	6078      	str	r0, [r7, #4]
 80209dc:	6039      	str	r1, [r7, #0]
    return sqrtf(x * x + y * y);
 80209de:	6879      	ldr	r1, [r7, #4]
 80209e0:	6878      	ldr	r0, [r7, #4]
 80209e2:	f7e0 f9e7 	bl	8000db4 <__aeabi_fmul>
 80209e6:	4603      	mov	r3, r0
 80209e8:	461c      	mov	r4, r3
 80209ea:	6839      	ldr	r1, [r7, #0]
 80209ec:	6838      	ldr	r0, [r7, #0]
 80209ee:	f7e0 f9e1 	bl	8000db4 <__aeabi_fmul>
 80209f2:	4603      	mov	r3, r0
 80209f4:	4619      	mov	r1, r3
 80209f6:	4620      	mov	r0, r4
 80209f8:	f7e0 f8d4 	bl	8000ba4 <__addsf3>
 80209fc:	4603      	mov	r3, r0
 80209fe:	4618      	mov	r0, r3
 8020a00:	f003 fffd 	bl	80249fe <sqrtf>
 8020a04:	4603      	mov	r3, r0
}
 8020a06:	4618      	mov	r0, r3
 8020a08:	370c      	adds	r7, #12
 8020a0a:	46bd      	mov	sp, r7
 8020a0c:	bd90      	pop	{r4, r7, pc}
	...

08020a10 <control_interrupt_handler>:
its ready. This works exactly like the character-based realtime commands when picked off
directly from the incoming data stream.
\param signals a \a control_signals_t union holding status of the signals.
*/
ISR_CODE void ISR_FUNC(control_interrupt_handler)(control_signals_t signals)
{
 8020a10:	b580      	push	{r7, lr}
 8020a12:	b084      	sub	sp, #16
 8020a14:	af00      	add	r7, sp, #0
 8020a16:	80b8      	strh	r0, [r7, #4]
    if(signals.deasserted)
 8020a18:	797b      	ldrb	r3, [r7, #5]
 8020a1a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8020a1e:	b2db      	uxtb	r3, r3
 8020a20:	2b00      	cmp	r3, #0
 8020a22:	f040 80c7 	bne.w	8020bb4 <control_interrupt_handler+0x1a4>
        return; // for now...

    if (signals.value) {
 8020a26:	88bb      	ldrh	r3, [r7, #4]
 8020a28:	2b00      	cmp	r3, #0
 8020a2a:	f000 80c4 	beq.w	8020bb6 <control_interrupt_handler+0x1a6>

        sys.last_event.control.value = signals.value;
 8020a2e:	88ba      	ldrh	r2, [r7, #4]
 8020a30:	4b62      	ldr	r3, [pc, #392]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020a32:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80

        if ((signals.reset || signals.e_stop || signals.motor_fault) && state_get() != STATE_ESTOP)
 8020a36:	793b      	ldrb	r3, [r7, #4]
 8020a38:	f003 0301 	and.w	r3, r3, #1
 8020a3c:	b2db      	uxtb	r3, r3
 8020a3e:	2b00      	cmp	r3, #0
 8020a40:	d10b      	bne.n	8020a5a <control_interrupt_handler+0x4a>
 8020a42:	793b      	ldrb	r3, [r7, #4]
 8020a44:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8020a48:	b2db      	uxtb	r3, r3
 8020a4a:	2b00      	cmp	r3, #0
 8020a4c:	d105      	bne.n	8020a5a <control_interrupt_handler+0x4a>
 8020a4e:	797b      	ldrb	r3, [r7, #5]
 8020a50:	f003 0301 	and.w	r3, r3, #1
 8020a54:	b2db      	uxtb	r3, r3
 8020a56:	2b00      	cmp	r3, #0
 8020a58:	d008      	beq.n	8020a6c <control_interrupt_handler+0x5c>
 8020a5a:	f7fc ff31 	bl	801d8c0 <state_get>
 8020a5e:	4603      	mov	r3, r0
 8020a60:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8020a64:	d002      	beq.n	8020a6c <control_interrupt_handler+0x5c>
            mc_reset();
 8020a66:	f7ee fe3f 	bl	800f6e8 <mc_reset>
 8020a6a:	e0a4      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
        else {
#ifndef NO_SAFETY_DOOR_SUPPORT
            if (signals.safety_door_ajar && hal.signals_cap.safety_door_ajar) {
 8020a6c:	793b      	ldrb	r3, [r7, #4]
 8020a6e:	f003 0308 	and.w	r3, r3, #8
 8020a72:	b2db      	uxtb	r3, r3
 8020a74:	2b00      	cmp	r3, #0
 8020a76:	d02a      	beq.n	8020ace <control_interrupt_handler+0xbe>
 8020a78:	4b51      	ldr	r3, [pc, #324]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020a7a:	f893 31ac 	ldrb.w	r3, [r3, #428]	; 0x1ac
 8020a7e:	f003 0308 	and.w	r3, r3, #8
 8020a82:	b2db      	uxtb	r3, r3
 8020a84:	2b00      	cmp	r3, #0
 8020a86:	d022      	beq.n	8020ace <control_interrupt_handler+0xbe>
                if(settings.safety_door.flags.ignore_when_idle) {
 8020a88:	4b4e      	ldr	r3, [pc, #312]	; (8020bc4 <control_interrupt_handler+0x1b4>)
 8020a8a:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 8020a8e:	f003 0301 	and.w	r3, r3, #1
 8020a92:	b2db      	uxtb	r3, r3
 8020a94:	2b00      	cmp	r3, #0
 8020a96:	d015      	beq.n	8020ac4 <control_interrupt_handler+0xb4>
                    // Only stop the spindle (laser off) when idle or jogging,
                    // this to allow positioning the controlled point (spindle) when door is open.
                    // NOTE: at least for lasers there should be an external interlock blocking laser power.
                    if(state_get() != STATE_IDLE && state_get() != STATE_JOG)
 8020a98:	f7fc ff12 	bl	801d8c0 <state_get>
 8020a9c:	4603      	mov	r3, r0
 8020a9e:	2b00      	cmp	r3, #0
 8020aa0:	d009      	beq.n	8020ab6 <control_interrupt_handler+0xa6>
 8020aa2:	f7fc ff0d 	bl	801d8c0 <state_get>
 8020aa6:	4603      	mov	r3, r0
 8020aa8:	2b20      	cmp	r3, #32
 8020aaa:	d004      	beq.n	8020ab6 <control_interrupt_handler+0xa6>
                        system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8020aac:	4b44      	ldr	r3, [pc, #272]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020aae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020ab0:	2140      	movs	r1, #64	; 0x40
 8020ab2:	4845      	ldr	r0, [pc, #276]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020ab4:	4798      	blx	r3
                    if(settings.mode == Mode_Laser) // Turn off spindle immediately (laser) when in laser mode
 8020ab6:	4b43      	ldr	r3, [pc, #268]	; (8020bc4 <control_interrupt_handler+0x1b4>)
 8020ab8:	7e1b      	ldrb	r3, [r3, #24]
 8020aba:	2b01      	cmp	r3, #1
 8020abc:	d107      	bne.n	8020ace <control_interrupt_handler+0xbe>
                        spindle_all_off();
 8020abe:	f7fc fb07 	bl	801d0d0 <spindle_all_off>
 8020ac2:	e004      	b.n	8020ace <control_interrupt_handler+0xbe>
                } else
                    system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 8020ac4:	4b3e      	ldr	r3, [pc, #248]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020ac6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020ac8:	2140      	movs	r1, #64	; 0x40
 8020aca:	483f      	ldr	r0, [pc, #252]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020acc:	4798      	blx	r3
            }
#endif

            if(signals.probe_overtravel) {
 8020ace:	797b      	ldrb	r3, [r7, #5]
 8020ad0:	f003 0320 	and.w	r3, r3, #32
 8020ad4:	b2db      	uxtb	r3, r3
 8020ad6:	2b00      	cmp	r3, #0
 8020ad8:	d00a      	beq.n	8020af0 <control_interrupt_handler+0xe0>
                limit_signals_t overtravel = { .min.z = On};
 8020ada:	2300      	movs	r3, #0
 8020adc:	60fb      	str	r3, [r7, #12]
 8020ade:	7b3b      	ldrb	r3, [r7, #12]
 8020ae0:	f043 0304 	orr.w	r3, r3, #4
 8020ae4:	733b      	strb	r3, [r7, #12]
                hal.limits.interrupt_callback(overtravel);
 8020ae6:	4b36      	ldr	r3, [pc, #216]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020ae8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8020aea:	68f8      	ldr	r0, [r7, #12]
 8020aec:	4798      	blx	r3
 8020aee:	e062      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
                // TODO: add message?
            } else if (signals.probe_triggered) {
 8020af0:	797b      	ldrb	r3, [r7, #5]
 8020af2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8020af6:	b2db      	uxtb	r3, r3
 8020af8:	2b00      	cmp	r3, #0
 8020afa:	d01c      	beq.n	8020b36 <control_interrupt_handler+0x126>
                if(sys.probing_state == Probing_Off && (state_get() & (STATE_CYCLE|STATE_JOG))) {
 8020afc:	4b2f      	ldr	r3, [pc, #188]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020afe:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8020b02:	b2db      	uxtb	r3, r3
 8020b04:	2b00      	cmp	r3, #0
 8020b06:	d10f      	bne.n	8020b28 <control_interrupt_handler+0x118>
 8020b08:	f7fc feda 	bl	801d8c0 <state_get>
 8020b0c:	4603      	mov	r3, r0
 8020b0e:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8020b12:	2b00      	cmp	r3, #0
 8020b14:	d008      	beq.n	8020b28 <control_interrupt_handler+0x118>
                    system_set_exec_state_flag(EXEC_STOP);
 8020b16:	4b2a      	ldr	r3, [pc, #168]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020b18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020b1a:	2110      	movs	r1, #16
 8020b1c:	482a      	ldr	r0, [pc, #168]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020b1e:	4798      	blx	r3
                    sys.alarm_pending = Alarm_ProbeProtect;
 8020b20:	4b26      	ldr	r3, [pc, #152]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020b22:	220d      	movs	r2, #13
 8020b24:	751a      	strb	r2, [r3, #20]
 8020b26:	e046      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
                } else
                    hal.probe.configure(false, false);
 8020b28:	4b25      	ldr	r3, [pc, #148]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020b2a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8020b2e:	2100      	movs	r1, #0
 8020b30:	2000      	movs	r0, #0
 8020b32:	4798      	blx	r3
 8020b34:	e03f      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
            } else if (signals.probe_disconnected) {
 8020b36:	793b      	ldrb	r3, [r7, #4]
 8020b38:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8020b3c:	b2db      	uxtb	r3, r3
 8020b3e:	2b00      	cmp	r3, #0
 8020b40:	d013      	beq.n	8020b6a <control_interrupt_handler+0x15a>
                if(sys.probing_state == Probing_Active && state_get() == STATE_CYCLE) {
 8020b42:	4b1e      	ldr	r3, [pc, #120]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020b44:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8020b48:	b2db      	uxtb	r3, r3
 8020b4a:	2b01      	cmp	r3, #1
 8020b4c:	d133      	bne.n	8020bb6 <control_interrupt_handler+0x1a6>
 8020b4e:	f7fc feb7 	bl	801d8c0 <state_get>
 8020b52:	4603      	mov	r3, r0
 8020b54:	2b08      	cmp	r3, #8
 8020b56:	d12e      	bne.n	8020bb6 <control_interrupt_handler+0x1a6>
                    system_set_exec_state_flag(EXEC_FEED_HOLD);
 8020b58:	4b19      	ldr	r3, [pc, #100]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020b5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020b5c:	2108      	movs	r1, #8
 8020b5e:	481a      	ldr	r0, [pc, #104]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020b60:	4798      	blx	r3
                    sys.alarm_pending = Alarm_ProbeProtect;
 8020b62:	4b16      	ldr	r3, [pc, #88]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020b64:	220d      	movs	r2, #13
 8020b66:	751a      	strb	r2, [r3, #20]
 8020b68:	e025      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
                }
            } else if (signals.feed_hold)
 8020b6a:	793b      	ldrb	r3, [r7, #4]
 8020b6c:	f003 0302 	and.w	r3, r3, #2
 8020b70:	b2db      	uxtb	r3, r3
 8020b72:	2b00      	cmp	r3, #0
 8020b74:	d005      	beq.n	8020b82 <control_interrupt_handler+0x172>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 8020b76:	4b12      	ldr	r3, [pc, #72]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020b78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020b7a:	2108      	movs	r1, #8
 8020b7c:	4812      	ldr	r0, [pc, #72]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020b7e:	4798      	blx	r3
 8020b80:	e019      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
            else if (signals.cycle_start) {
 8020b82:	793b      	ldrb	r3, [r7, #4]
 8020b84:	f003 0304 	and.w	r3, r3, #4
 8020b88:	b2db      	uxtb	r3, r3
 8020b8a:	2b00      	cmp	r3, #0
 8020b8c:	d013      	beq.n	8020bb6 <control_interrupt_handler+0x1a6>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 8020b8e:	4b0c      	ldr	r3, [pc, #48]	; (8020bc0 <control_interrupt_handler+0x1b0>)
 8020b90:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020b92:	2102      	movs	r1, #2
 8020b94:	480c      	ldr	r0, [pc, #48]	; (8020bc8 <control_interrupt_handler+0x1b8>)
 8020b96:	4798      	blx	r3
                sys.report.cycle_start = settings.status_report.pin_state;
 8020b98:	4b0a      	ldr	r3, [pc, #40]	; (8020bc4 <control_interrupt_handler+0x1b4>)
 8020b9a:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8020b9e:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8020ba2:	b2d9      	uxtb	r1, r3
 8020ba4:	4a05      	ldr	r2, [pc, #20]	; (8020bbc <control_interrupt_handler+0x1ac>)
 8020ba6:	f892 3033 	ldrb.w	r3, [r2, #51]	; 0x33
 8020baa:	f361 1386 	bfi	r3, r1, #6, #1
 8020bae:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
 8020bb2:	e000      	b.n	8020bb6 <control_interrupt_handler+0x1a6>
        return; // for now...
 8020bb4:	bf00      	nop
            }
        }
    }
}
 8020bb6:	3710      	adds	r7, #16
 8020bb8:	46bd      	mov	sp, r7
 8020bba:	bd80      	pop	{r7, pc}
 8020bbc:	20000d3c 	.word	0x20000d3c
 8020bc0:	20000ed0 	.word	0x20000ed0
 8020bc4:	2000147c 	.word	0x2000147c
 8020bc8:	20000d84 	.word	0x20000d84

08020bcc <system_execute_startup>:


/*! \brief Executes user startup scripts, if stored.
*/
void system_execute_startup (void)
{
 8020bcc:	b580      	push	{r7, lr}
 8020bce:	b094      	sub	sp, #80	; 0x50
 8020bd0:	af00      	add	r7, sp, #0
    if(hal.nvs.type != NVS_None) {
 8020bd2:	4b19      	ldr	r3, [pc, #100]	; (8020c38 <system_execute_startup+0x6c>)
 8020bd4:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 8020bd8:	2b00      	cmp	r3, #0
 8020bda:	d029      	beq.n	8020c30 <system_execute_startup+0x64>

        char line[sizeof(stored_line_t)];
        uint_fast8_t n;

        for (n = 0; n < N_STARTUP_LINE; n++) {
 8020bdc:	2300      	movs	r3, #0
 8020bde:	64fb      	str	r3, [r7, #76]	; 0x4c
 8020be0:	e023      	b.n	8020c2a <system_execute_startup+0x5e>
            if (!settings_read_startup_line(n, line))
 8020be2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020be4:	b2db      	uxtb	r3, r3
 8020be6:	1d3a      	adds	r2, r7, #4
 8020be8:	4611      	mov	r1, r2
 8020bea:	4618      	mov	r0, r3
 8020bec:	f7f9 ffa6 	bl	801ab3c <settings_read_startup_line>
 8020bf0:	4603      	mov	r3, r0
 8020bf2:	f083 0301 	eor.w	r3, r3, #1
 8020bf6:	b2db      	uxtb	r3, r3
 8020bf8:	2b00      	cmp	r3, #0
 8020bfa:	d005      	beq.n	8020c08 <system_execute_startup+0x3c>
                report_execute_startup_message(line, Status_SettingReadFail);
 8020bfc:	1d3b      	adds	r3, r7, #4
 8020bfe:	2107      	movs	r1, #7
 8020c00:	4618      	mov	r0, r3
 8020c02:	f7f4 fd1b 	bl	801563c <report_execute_startup_message>
 8020c06:	e00d      	b.n	8020c24 <system_execute_startup+0x58>
            else if (*line != '\0')
 8020c08:	793b      	ldrb	r3, [r7, #4]
 8020c0a:	2b00      	cmp	r3, #0
 8020c0c:	d00a      	beq.n	8020c24 <system_execute_startup+0x58>
                report_execute_startup_message(line, gc_execute_block(line));
 8020c0e:	1d3b      	adds	r3, r7, #4
 8020c10:	4618      	mov	r0, r3
 8020c12:	f7e5 fb03 	bl	800621c <gc_execute_block>
 8020c16:	4603      	mov	r3, r0
 8020c18:	461a      	mov	r2, r3
 8020c1a:	1d3b      	adds	r3, r7, #4
 8020c1c:	4611      	mov	r1, r2
 8020c1e:	4618      	mov	r0, r3
 8020c20:	f7f4 fd0c 	bl	801563c <report_execute_startup_message>
        for (n = 0; n < N_STARTUP_LINE; n++) {
 8020c24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020c26:	3301      	adds	r3, #1
 8020c28:	64fb      	str	r3, [r7, #76]	; 0x4c
 8020c2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020c2c:	2b01      	cmp	r3, #1
 8020c2e:	d9d8      	bls.n	8020be2 <system_execute_startup+0x16>
        }
    }
}
 8020c30:	bf00      	nop
 8020c32:	3750      	adds	r7, #80	; 0x50
 8020c34:	46bd      	mov	sp, r7
 8020c36:	bd80      	pop	{r7, pc}
 8020c38:	20000ed0 	.word	0x20000ed0

08020c3c <read_int>:

static status_code_t read_int (char *s, int32_t *value)
{
 8020c3c:	b590      	push	{r4, r7, lr}
 8020c3e:	b085      	sub	sp, #20
 8020c40:	af00      	add	r7, sp, #0
 8020c42:	6078      	str	r0, [r7, #4]
 8020c44:	6039      	str	r1, [r7, #0]
    uint_fast8_t counter = 0;
 8020c46:	2300      	movs	r3, #0
 8020c48:	60fb      	str	r3, [r7, #12]
    float parameter;
    if(!read_float(s, &counter, &parameter))
 8020c4a:	f107 0208 	add.w	r2, r7, #8
 8020c4e:	f107 030c 	add.w	r3, r7, #12
 8020c52:	4619      	mov	r1, r3
 8020c54:	6878      	ldr	r0, [r7, #4]
 8020c56:	f7ef fcad 	bl	80105b4 <read_float>
 8020c5a:	4603      	mov	r3, r0
 8020c5c:	f083 0301 	eor.w	r3, r3, #1
 8020c60:	b2db      	uxtb	r3, r3
 8020c62:	2b00      	cmp	r3, #0
 8020c64:	d001      	beq.n	8020c6a <read_int+0x2e>
        return Status_BadNumberFormat;
 8020c66:	2302      	movs	r3, #2
 8020c68:	e01c      	b.n	8020ca4 <read_int+0x68>

    if(parameter - truncf(parameter) != 0.0f)
 8020c6a:	68bc      	ldr	r4, [r7, #8]
 8020c6c:	68bb      	ldr	r3, [r7, #8]
 8020c6e:	4618      	mov	r0, r3
 8020c70:	f004 f8c0 	bl	8024df4 <truncf>
 8020c74:	4603      	mov	r3, r0
 8020c76:	4619      	mov	r1, r3
 8020c78:	4620      	mov	r0, r4
 8020c7a:	f7df ff91 	bl	8000ba0 <__aeabi_fsub>
 8020c7e:	4603      	mov	r3, r0
 8020c80:	f04f 0100 	mov.w	r1, #0
 8020c84:	4618      	mov	r0, r3
 8020c86:	f7e0 fa29 	bl	80010dc <__aeabi_fcmpeq>
 8020c8a:	4603      	mov	r3, r0
 8020c8c:	2b00      	cmp	r3, #0
 8020c8e:	d101      	bne.n	8020c94 <read_int+0x58>
        return Status_InvalidStatement;
 8020c90:	2303      	movs	r3, #3
 8020c92:	e007      	b.n	8020ca4 <read_int+0x68>

    *value = (int32_t)parameter;
 8020c94:	68bb      	ldr	r3, [r7, #8]
 8020c96:	4618      	mov	r0, r3
 8020c98:	f7e0 fa68 	bl	800116c <__aeabi_f2iz>
 8020c9c:	4602      	mov	r2, r0
 8020c9e:	683b      	ldr	r3, [r7, #0]
 8020ca0:	601a      	str	r2, [r3, #0]

    return Status_OK;
 8020ca2:	2300      	movs	r3, #0
}
 8020ca4:	4618      	mov	r0, r3
 8020ca6:	3714      	adds	r7, #20
 8020ca8:	46bd      	mov	sp, r7
 8020caa:	bd90      	pop	{r4, r7, pc}

08020cac <spindle_reset_data>:
// System commands
//

// Reset spindle encoder data
static status_code_t spindle_reset_data (sys_state_t state, char *args)
{
 8020cac:	b580      	push	{r7, lr}
 8020cae:	b084      	sub	sp, #16
 8020cb0:	af00      	add	r7, sp, #0
 8020cb2:	6078      	str	r0, [r7, #4]
 8020cb4:	6039      	str	r1, [r7, #0]
    spindle_ptrs_t *spindle = gc_spindle_get();
 8020cb6:	f7e5 f897 	bl	8005de8 <gc_spindle_get>
 8020cba:	60f8      	str	r0, [r7, #12]

    if(spindle->reset_data)
 8020cbc:	68fb      	ldr	r3, [r7, #12]
 8020cbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020cc0:	2b00      	cmp	r3, #0
 8020cc2:	d002      	beq.n	8020cca <spindle_reset_data+0x1e>
        spindle->reset_data();
 8020cc4:	68fb      	ldr	r3, [r7, #12]
 8020cc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020cc8:	4798      	blx	r3

    return spindle->reset_data ? Status_OK : Status_InvalidStatement;
 8020cca:	68fb      	ldr	r3, [r7, #12]
 8020ccc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8020cce:	2b00      	cmp	r3, #0
 8020cd0:	d001      	beq.n	8020cd6 <spindle_reset_data+0x2a>
 8020cd2:	2300      	movs	r3, #0
 8020cd4:	e000      	b.n	8020cd8 <spindle_reset_data+0x2c>
 8020cd6:	2303      	movs	r3, #3
}
 8020cd8:	4618      	mov	r0, r3
 8020cda:	3710      	adds	r7, #16
 8020cdc:	46bd      	mov	sp, r7
 8020cde:	bd80      	pop	{r7, pc}

08020ce0 <jog>:

static status_code_t jog (sys_state_t state, char *args)
{
 8020ce0:	b580      	push	{r7, lr}
 8020ce2:	b082      	sub	sp, #8
 8020ce4:	af00      	add	r7, sp, #0
 8020ce6:	6078      	str	r0, [r7, #4]
 8020ce8:	6039      	str	r1, [r7, #0]
    if(!(state == STATE_IDLE || (state & (STATE_JOG|STATE_TOOL_CHANGE))))
 8020cea:	687b      	ldr	r3, [r7, #4]
 8020cec:	2b00      	cmp	r3, #0
 8020cee:	d006      	beq.n	8020cfe <jog+0x1e>
 8020cf0:	687b      	ldr	r3, [r7, #4]
 8020cf2:	f403 7308 	and.w	r3, r3, #544	; 0x220
 8020cf6:	2b00      	cmp	r3, #0
 8020cf8:	d101      	bne.n	8020cfe <jog+0x1e>
         return Status_IdleError;
 8020cfa:	2308      	movs	r3, #8
 8020cfc:	e014      	b.n	8020d28 <jog+0x48>

    if(args != NULL) {
 8020cfe:	683b      	ldr	r3, [r7, #0]
 8020d00:	2b00      	cmp	r3, #0
 8020d02:	d008      	beq.n	8020d16 <jog+0x36>
        *(--args) = '=';
 8020d04:	683b      	ldr	r3, [r7, #0]
 8020d06:	3b01      	subs	r3, #1
 8020d08:	603b      	str	r3, [r7, #0]
 8020d0a:	683b      	ldr	r3, [r7, #0]
 8020d0c:	223d      	movs	r2, #61	; 0x3d
 8020d0e:	701a      	strb	r2, [r3, #0]
        args -= 2;
 8020d10:	683b      	ldr	r3, [r7, #0]
 8020d12:	3b02      	subs	r3, #2
 8020d14:	603b      	str	r3, [r7, #0]
    }

    return args == NULL ? Status_InvalidStatement : gc_execute_block(args); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 8020d16:	683b      	ldr	r3, [r7, #0]
 8020d18:	2b00      	cmp	r3, #0
 8020d1a:	d004      	beq.n	8020d26 <jog+0x46>
 8020d1c:	6838      	ldr	r0, [r7, #0]
 8020d1e:	f7e5 fa7d 	bl	800621c <gc_execute_block>
 8020d22:	4603      	mov	r3, r0
 8020d24:	e000      	b.n	8020d28 <jog+0x48>
 8020d26:	2303      	movs	r3, #3
}
 8020d28:	4618      	mov	r0, r3
 8020d2a:	3708      	adds	r7, #8
 8020d2c:	46bd      	mov	sp, r7
 8020d2e:	bd80      	pop	{r7, pc}

08020d30 <enumerate_alarms>:

static status_code_t enumerate_alarms (sys_state_t state, char *args)
{
 8020d30:	b580      	push	{r7, lr}
 8020d32:	b082      	sub	sp, #8
 8020d34:	af00      	add	r7, sp, #0
 8020d36:	6078      	str	r0, [r7, #4]
 8020d38:	6039      	str	r1, [r7, #0]
    return report_alarm_details(false);
 8020d3a:	2000      	movs	r0, #0
 8020d3c:	f7f7 f862 	bl	8017e04 <report_alarm_details>
 8020d40:	4603      	mov	r3, r0
}
 8020d42:	4618      	mov	r0, r3
 8020d44:	3708      	adds	r7, #8
 8020d46:	46bd      	mov	sp, r7
 8020d48:	bd80      	pop	{r7, pc}

08020d4a <enumerate_alarms_grblformatted>:

static status_code_t enumerate_alarms_grblformatted (sys_state_t state, char *args)
{
 8020d4a:	b580      	push	{r7, lr}
 8020d4c:	b082      	sub	sp, #8
 8020d4e:	af00      	add	r7, sp, #0
 8020d50:	6078      	str	r0, [r7, #4]
 8020d52:	6039      	str	r1, [r7, #0]
    return report_alarm_details(true);
 8020d54:	2001      	movs	r0, #1
 8020d56:	f7f7 f855 	bl	8017e04 <report_alarm_details>
 8020d5a:	4603      	mov	r3, r0
}
 8020d5c:	4618      	mov	r0, r3
 8020d5e:	3708      	adds	r7, #8
 8020d60:	46bd      	mov	sp, r7
 8020d62:	bd80      	pop	{r7, pc}

08020d64 <enumerate_errors>:

static status_code_t enumerate_errors (sys_state_t state, char *args)
{
 8020d64:	b580      	push	{r7, lr}
 8020d66:	b082      	sub	sp, #8
 8020d68:	af00      	add	r7, sp, #0
 8020d6a:	6078      	str	r0, [r7, #4]
 8020d6c:	6039      	str	r1, [r7, #0]
    return report_error_details(false);
 8020d6e:	2000      	movs	r0, #0
 8020d70:	f7f7 f952 	bl	8018018 <report_error_details>
 8020d74:	4603      	mov	r3, r0
}
 8020d76:	4618      	mov	r0, r3
 8020d78:	3708      	adds	r7, #8
 8020d7a:	46bd      	mov	sp, r7
 8020d7c:	bd80      	pop	{r7, pc}

08020d7e <enumerate_errors_grblformatted>:

static status_code_t enumerate_errors_grblformatted (sys_state_t state, char *args)
{
 8020d7e:	b580      	push	{r7, lr}
 8020d80:	b082      	sub	sp, #8
 8020d82:	af00      	add	r7, sp, #0
 8020d84:	6078      	str	r0, [r7, #4]
 8020d86:	6039      	str	r1, [r7, #0]
    return report_error_details(true);
 8020d88:	2001      	movs	r0, #1
 8020d8a:	f7f7 f945 	bl	8018018 <report_error_details>
 8020d8e:	4603      	mov	r3, r0
}
 8020d90:	4618      	mov	r0, r3
 8020d92:	3708      	adds	r7, #8
 8020d94:	46bd      	mov	sp, r7
 8020d96:	bd80      	pop	{r7, pc}

08020d98 <enumerate_groups>:

static status_code_t enumerate_groups (sys_state_t state, char *args)
{
 8020d98:	b580      	push	{r7, lr}
 8020d9a:	b082      	sub	sp, #8
 8020d9c:	af00      	add	r7, sp, #0
 8020d9e:	6078      	str	r0, [r7, #4]
 8020da0:	6039      	str	r1, [r7, #0]
    return report_setting_group_details(true, NULL);
 8020da2:	2100      	movs	r1, #0
 8020da4:	2001      	movs	r0, #1
 8020da6:	f7f7 fa6f 	bl	8018288 <report_setting_group_details>
 8020daa:	4603      	mov	r3, r0
}
 8020dac:	4618      	mov	r0, r3
 8020dae:	3708      	adds	r7, #8
 8020db0:	46bd      	mov	sp, r7
 8020db2:	bd80      	pop	{r7, pc}

08020db4 <enumerate_settings>:

static status_code_t enumerate_settings (sys_state_t state, char *args)
{
 8020db4:	b580      	push	{r7, lr}
 8020db6:	b082      	sub	sp, #8
 8020db8:	af00      	add	r7, sp, #0
 8020dba:	6078      	str	r0, [r7, #4]
 8020dbc:	6039      	str	r1, [r7, #0]
    return report_settings_details(SettingsFormat_MachineReadable, Setting_SettingsAll, Group_All);
 8020dbe:	2200      	movs	r2, #0
 8020dc0:	f240 21e5 	movw	r1, #741	; 0x2e5
 8020dc4:	2000      	movs	r0, #0
 8020dc6:	f7f6 fefd 	bl	8017bc4 <report_settings_details>
 8020dca:	4603      	mov	r3, r0
}
 8020dcc:	4618      	mov	r0, r3
 8020dce:	3708      	adds	r7, #8
 8020dd0:	46bd      	mov	sp, r7
 8020dd2:	bd80      	pop	{r7, pc}

08020dd4 <enumerate_settings_grblformatted>:

static status_code_t enumerate_settings_grblformatted (sys_state_t state, char *args)
{
 8020dd4:	b580      	push	{r7, lr}
 8020dd6:	b082      	sub	sp, #8
 8020dd8:	af00      	add	r7, sp, #0
 8020dda:	6078      	str	r0, [r7, #4]
 8020ddc:	6039      	str	r1, [r7, #0]
    return report_settings_details(SettingsFormat_Grbl, Setting_SettingsAll, Group_All);
 8020dde:	2200      	movs	r2, #0
 8020de0:	f240 21e5 	movw	r1, #741	; 0x2e5
 8020de4:	2002      	movs	r0, #2
 8020de6:	f7f6 feed 	bl	8017bc4 <report_settings_details>
 8020dea:	4603      	mov	r3, r0
}
 8020dec:	4618      	mov	r0, r3
 8020dee:	3708      	adds	r7, #8
 8020df0:	46bd      	mov	sp, r7
 8020df2:	bd80      	pop	{r7, pc}

08020df4 <enumerate_settings_halformatted>:

static status_code_t enumerate_settings_halformatted (sys_state_t state, char *args)
{
 8020df4:	b580      	push	{r7, lr}
 8020df6:	b082      	sub	sp, #8
 8020df8:	af00      	add	r7, sp, #0
 8020dfa:	6078      	str	r0, [r7, #4]
 8020dfc:	6039      	str	r1, [r7, #0]
    return report_settings_details(SettingsFormat_grblHAL, Setting_SettingsAll, Group_All);
 8020dfe:	2200      	movs	r2, #0
 8020e00:	f240 21e5 	movw	r1, #741	; 0x2e5
 8020e04:	2003      	movs	r0, #3
 8020e06:	f7f6 fedd 	bl	8017bc4 <report_settings_details>
 8020e0a:	4603      	mov	r3, r0
}
 8020e0c:	4618      	mov	r0, r3
 8020e0e:	3708      	adds	r7, #8
 8020e10:	46bd      	mov	sp, r7
 8020e12:	bd80      	pop	{r7, pc}

08020e14 <enumerate_all>:

static status_code_t enumerate_all (sys_state_t state, char *args)
{
 8020e14:	b580      	push	{r7, lr}
 8020e16:	b082      	sub	sp, #8
 8020e18:	af00      	add	r7, sp, #0
 8020e1a:	6078      	str	r0, [r7, #4]
 8020e1c:	6039      	str	r1, [r7, #0]
    report_alarm_details(false);
 8020e1e:	2000      	movs	r0, #0
 8020e20:	f7f6 fff0 	bl	8017e04 <report_alarm_details>
    report_error_details(false);
 8020e24:	2000      	movs	r0, #0
 8020e26:	f7f7 f8f7 	bl	8018018 <report_error_details>
    report_setting_group_details(true, NULL);
 8020e2a:	2100      	movs	r1, #0
 8020e2c:	2001      	movs	r0, #1
 8020e2e:	f7f7 fa2b 	bl	8018288 <report_setting_group_details>
    return report_settings_details(SettingsFormat_MachineReadable, Setting_SettingsAll, Group_All);
 8020e32:	2200      	movs	r2, #0
 8020e34:	f240 21e5 	movw	r1, #741	; 0x2e5
 8020e38:	2000      	movs	r0, #0
 8020e3a:	f7f6 fec3 	bl	8017bc4 <report_settings_details>
 8020e3e:	4603      	mov	r3, r0
}
 8020e40:	4618      	mov	r0, r3
 8020e42:	3708      	adds	r7, #8
 8020e44:	46bd      	mov	sp, r7
 8020e46:	bd80      	pop	{r7, pc}

08020e48 <enumerate_pins>:

static status_code_t enumerate_pins (sys_state_t state, char *args)
{
 8020e48:	b580      	push	{r7, lr}
 8020e4a:	b082      	sub	sp, #8
 8020e4c:	af00      	add	r7, sp, #0
 8020e4e:	6078      	str	r0, [r7, #4]
 8020e50:	6039      	str	r1, [r7, #0]
    return report_pins(state, args);
 8020e52:	6839      	ldr	r1, [r7, #0]
 8020e54:	6878      	ldr	r0, [r7, #4]
 8020e56:	f7f7 fc8d 	bl	8018774 <report_pins>
 8020e5a:	4603      	mov	r3, r0
}
 8020e5c:	4618      	mov	r0, r3
 8020e5e:	3708      	adds	r7, #8
 8020e60:	46bd      	mov	sp, r7
 8020e62:	bd80      	pop	{r7, pc}

08020e64 <output_settings>:

static status_code_t output_settings (sys_state_t state, char *args)
{
 8020e64:	b580      	push	{r7, lr}
 8020e66:	b084      	sub	sp, #16
 8020e68:	af00      	add	r7, sp, #0
 8020e6a:	6078      	str	r0, [r7, #4]
 8020e6c:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_OK;
 8020e6e:	2300      	movs	r3, #0
 8020e70:	73fb      	strb	r3, [r7, #15]

    if(args) {
 8020e72:	683b      	ldr	r3, [r7, #0]
 8020e74:	2b00      	cmp	r3, #0
 8020e76:	d017      	beq.n	8020ea8 <output_settings+0x44>
        int32_t id;
        retval = read_int(args, &id);
 8020e78:	f107 0308 	add.w	r3, r7, #8
 8020e7c:	4619      	mov	r1, r3
 8020e7e:	6838      	ldr	r0, [r7, #0]
 8020e80:	f7ff fedc 	bl	8020c3c <read_int>
 8020e84:	4603      	mov	r3, r0
 8020e86:	73fb      	strb	r3, [r7, #15]
        if(retval == Status_OK && id >= 0)
 8020e88:	7bfb      	ldrb	r3, [r7, #15]
 8020e8a:	2b00      	cmp	r3, #0
 8020e8c:	d118      	bne.n	8020ec0 <output_settings+0x5c>
 8020e8e:	68bb      	ldr	r3, [r7, #8]
 8020e90:	2b00      	cmp	r3, #0
 8020e92:	db15      	blt.n	8020ec0 <output_settings+0x5c>
            retval = report_settings_details(SettingsFormat_HumanReadable, (setting_id_t)id, Group_All);
 8020e94:	68bb      	ldr	r3, [r7, #8]
 8020e96:	b29b      	uxth	r3, r3
 8020e98:	2200      	movs	r2, #0
 8020e9a:	4619      	mov	r1, r3
 8020e9c:	2001      	movs	r0, #1
 8020e9e:	f7f6 fe91 	bl	8017bc4 <report_settings_details>
 8020ea2:	4603      	mov	r3, r0
 8020ea4:	73fb      	strb	r3, [r7, #15]
 8020ea6:	e00b      	b.n	8020ec0 <output_settings+0x5c>
    } else if (state & (STATE_CYCLE|STATE_HOLD))
 8020ea8:	687b      	ldr	r3, [r7, #4]
 8020eaa:	f003 0318 	and.w	r3, r3, #24
 8020eae:	2b00      	cmp	r3, #0
 8020eb0:	d002      	beq.n	8020eb8 <output_settings+0x54>
        retval = Status_IdleError; // Block during cycle. Takes too long to print.
 8020eb2:	2308      	movs	r3, #8
 8020eb4:	73fb      	strb	r3, [r7, #15]
 8020eb6:	e003      	b.n	8020ec0 <output_settings+0x5c>
    else
#if COMPATIBILITY_LEVEL <= 1
    report_grbl_settings(true, NULL);
 8020eb8:	2100      	movs	r1, #0
 8020eba:	2001      	movs	r0, #1
 8020ebc:	f7f3 fd88 	bl	80149d0 <report_grbl_settings>
#else
    report_grbl_settings(false, NULL);
#endif

    return retval;
 8020ec0:	7bfb      	ldrb	r3, [r7, #15]
}
 8020ec2:	4618      	mov	r0, r3
 8020ec4:	3710      	adds	r7, #16
 8020ec6:	46bd      	mov	sp, r7
 8020ec8:	bd80      	pop	{r7, pc}

08020eca <output_setting_description>:

#ifndef NO_SETTINGS_DESCRIPTIONS

static status_code_t output_setting_description (sys_state_t state, char *args)
{
 8020eca:	b580      	push	{r7, lr}
 8020ecc:	b084      	sub	sp, #16
 8020ece:	af00      	add	r7, sp, #0
 8020ed0:	6078      	str	r0, [r7, #4]
 8020ed2:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_BadNumberFormat;
 8020ed4:	2302      	movs	r3, #2
 8020ed6:	73fb      	strb	r3, [r7, #15]

    if(args) {
 8020ed8:	683b      	ldr	r3, [r7, #0]
 8020eda:	2b00      	cmp	r3, #0
 8020edc:	d015      	beq.n	8020f0a <output_setting_description+0x40>
        int32_t id;
        retval = read_int(args, &id);
 8020ede:	f107 0308 	add.w	r3, r7, #8
 8020ee2:	4619      	mov	r1, r3
 8020ee4:	6838      	ldr	r0, [r7, #0]
 8020ee6:	f7ff fea9 	bl	8020c3c <read_int>
 8020eea:	4603      	mov	r3, r0
 8020eec:	73fb      	strb	r3, [r7, #15]
        if(retval == Status_OK && id >= 0)
 8020eee:	7bfb      	ldrb	r3, [r7, #15]
 8020ef0:	2b00      	cmp	r3, #0
 8020ef2:	d10a      	bne.n	8020f0a <output_setting_description+0x40>
 8020ef4:	68bb      	ldr	r3, [r7, #8]
 8020ef6:	2b00      	cmp	r3, #0
 8020ef8:	db07      	blt.n	8020f0a <output_setting_description+0x40>
            retval = report_setting_description(SettingsFormat_MachineReadable, (setting_id_t)id);
 8020efa:	68bb      	ldr	r3, [r7, #8]
 8020efc:	b29b      	uxth	r3, r3
 8020efe:	4619      	mov	r1, r3
 8020f00:	2000      	movs	r0, #0
 8020f02:	f7f6 fe93 	bl	8017c2c <report_setting_description>
 8020f06:	4603      	mov	r3, r0
 8020f08:	73fb      	strb	r3, [r7, #15]
    }

    return retval;
 8020f0a:	7bfb      	ldrb	r3, [r7, #15]
}
 8020f0c:	4618      	mov	r0, r3
 8020f0e:	3710      	adds	r7, #16
 8020f10:	46bd      	mov	sp, r7
 8020f12:	bd80      	pop	{r7, pc}

08020f14 <output_all_settings>:

#endif

static status_code_t output_all_settings (sys_state_t state, char *args)
{
 8020f14:	b580      	push	{r7, lr}
 8020f16:	b084      	sub	sp, #16
 8020f18:	af00      	add	r7, sp, #0
 8020f1a:	6078      	str	r0, [r7, #4]
 8020f1c:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_OK;
 8020f1e:	2300      	movs	r3, #0
 8020f20:	73fb      	strb	r3, [r7, #15]

    if(args) {
 8020f22:	683b      	ldr	r3, [r7, #0]
 8020f24:	2b00      	cmp	r3, #0
 8020f26:	d017      	beq.n	8020f58 <output_all_settings+0x44>
        int32_t id;
        retval = read_int(args, &id);
 8020f28:	f107 0308 	add.w	r3, r7, #8
 8020f2c:	4619      	mov	r1, r3
 8020f2e:	6838      	ldr	r0, [r7, #0]
 8020f30:	f7ff fe84 	bl	8020c3c <read_int>
 8020f34:	4603      	mov	r3, r0
 8020f36:	73fb      	strb	r3, [r7, #15]
        if(retval == Status_OK && id >= 0)
 8020f38:	7bfb      	ldrb	r3, [r7, #15]
 8020f3a:	2b00      	cmp	r3, #0
 8020f3c:	d118      	bne.n	8020f70 <output_all_settings+0x5c>
 8020f3e:	68bb      	ldr	r3, [r7, #8]
 8020f40:	2b00      	cmp	r3, #0
 8020f42:	db15      	blt.n	8020f70 <output_all_settings+0x5c>
            retval = report_settings_details(SettingsFormat_HumanReadable, (setting_id_t)id, Group_All);
 8020f44:	68bb      	ldr	r3, [r7, #8]
 8020f46:	b29b      	uxth	r3, r3
 8020f48:	2200      	movs	r2, #0
 8020f4a:	4619      	mov	r1, r3
 8020f4c:	2001      	movs	r0, #1
 8020f4e:	f7f6 fe39 	bl	8017bc4 <report_settings_details>
 8020f52:	4603      	mov	r3, r0
 8020f54:	73fb      	strb	r3, [r7, #15]
 8020f56:	e00b      	b.n	8020f70 <output_all_settings+0x5c>
    } else if (state & (STATE_CYCLE|STATE_HOLD))
 8020f58:	687b      	ldr	r3, [r7, #4]
 8020f5a:	f003 0318 	and.w	r3, r3, #24
 8020f5e:	2b00      	cmp	r3, #0
 8020f60:	d002      	beq.n	8020f68 <output_all_settings+0x54>
        retval = Status_IdleError; // Block during cycle. Takes too long to print.
 8020f62:	2308      	movs	r3, #8
 8020f64:	73fb      	strb	r3, [r7, #15]
 8020f66:	e003      	b.n	8020f70 <output_all_settings+0x5c>
    else
        report_grbl_settings(true, NULL);
 8020f68:	2100      	movs	r1, #0
 8020f6a:	2001      	movs	r0, #1
 8020f6c:	f7f3 fd30 	bl	80149d0 <report_grbl_settings>

    return retval;
 8020f70:	7bfb      	ldrb	r3, [r7, #15]
}
 8020f72:	4618      	mov	r0, r3
 8020f74:	3710      	adds	r7, #16
 8020f76:	46bd      	mov	sp, r7
 8020f78:	bd80      	pop	{r7, pc}

08020f7a <output_parser_state>:

static status_code_t output_parser_state (sys_state_t state, char *args)
{
 8020f7a:	b580      	push	{r7, lr}
 8020f7c:	b082      	sub	sp, #8
 8020f7e:	af00      	add	r7, sp, #0
 8020f80:	6078      	str	r0, [r7, #4]
 8020f82:	6039      	str	r1, [r7, #0]
    report_gcode_modes();
 8020f84:	f7f4 f8a6 	bl	80150d4 <report_gcode_modes>
    system_add_rt_report(Report_Homed); // Report homed state on next realtime report
 8020f88:	2004      	movs	r0, #4
 8020f8a:	f001 f807 	bl	8021f9c <system_add_rt_report>

    return Status_OK;
 8020f8e:	2300      	movs	r3, #0
}
 8020f90:	4618      	mov	r0, r3
 8020f92:	3708      	adds	r7, #8
 8020f94:	46bd      	mov	sp, r7
 8020f96:	bd80      	pop	{r7, pc}

08020f98 <toggle_single_block>:

static status_code_t toggle_single_block (sys_state_t state, char *args)
{
 8020f98:	b580      	push	{r7, lr}
 8020f9a:	b082      	sub	sp, #8
 8020f9c:	af00      	add	r7, sp, #0
 8020f9e:	6078      	str	r0, [r7, #4]
 8020fa0:	6039      	str	r1, [r7, #0]
    sys.flags.single_block = !sys.flags.single_block;
 8020fa2:	4b0f      	ldr	r3, [pc, #60]	; (8020fe0 <toggle_single_block+0x48>)
 8020fa4:	7d9b      	ldrb	r3, [r3, #22]
 8020fa6:	b25b      	sxtb	r3, r3
 8020fa8:	43db      	mvns	r3, r3
 8020faa:	b2db      	uxtb	r3, r3
 8020fac:	09db      	lsrs	r3, r3, #7
 8020fae:	b2d9      	uxtb	r1, r3
 8020fb0:	4a0b      	ldr	r2, [pc, #44]	; (8020fe0 <toggle_single_block+0x48>)
 8020fb2:	7d93      	ldrb	r3, [r2, #22]
 8020fb4:	f361 13c7 	bfi	r3, r1, #7, #1
 8020fb8:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.single_block ? Message_Enabled : Message_Disabled);
 8020fba:	4b0a      	ldr	r3, [pc, #40]	; (8020fe4 <toggle_single_block+0x4c>)
 8020fbc:	68db      	ldr	r3, [r3, #12]
 8020fbe:	4a08      	ldr	r2, [pc, #32]	; (8020fe0 <toggle_single_block+0x48>)
 8020fc0:	7d92      	ldrb	r2, [r2, #22]
 8020fc2:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 8020fc6:	b2d2      	uxtb	r2, r2
 8020fc8:	2a00      	cmp	r2, #0
 8020fca:	d001      	beq.n	8020fd0 <toggle_single_block+0x38>
 8020fcc:	2204      	movs	r2, #4
 8020fce:	e000      	b.n	8020fd2 <toggle_single_block+0x3a>
 8020fd0:	2205      	movs	r2, #5
 8020fd2:	4610      	mov	r0, r2
 8020fd4:	4798      	blx	r3

    return Status_OK;
 8020fd6:	2300      	movs	r3, #0
}
 8020fd8:	4618      	mov	r0, r3
 8020fda:	3708      	adds	r7, #8
 8020fdc:	46bd      	mov	sp, r7
 8020fde:	bd80      	pop	{r7, pc}
 8020fe0:	20000d3c 	.word	0x20000d3c
 8020fe4:	20000dd4 	.word	0x20000dd4

08020fe8 <toggle_block_delete>:

static status_code_t toggle_block_delete (sys_state_t state, char *args)
{
 8020fe8:	b580      	push	{r7, lr}
 8020fea:	b082      	sub	sp, #8
 8020fec:	af00      	add	r7, sp, #0
 8020fee:	6078      	str	r0, [r7, #4]
 8020ff0:	6039      	str	r1, [r7, #0]
    sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 8020ff2:	4b11      	ldr	r3, [pc, #68]	; (8021038 <toggle_block_delete+0x50>)
 8020ff4:	7d9b      	ldrb	r3, [r3, #22]
 8020ff6:	f003 0310 	and.w	r3, r3, #16
 8020ffa:	b2db      	uxtb	r3, r3
 8020ffc:	2b00      	cmp	r3, #0
 8020ffe:	bf0c      	ite	eq
 8021000:	2301      	moveq	r3, #1
 8021002:	2300      	movne	r3, #0
 8021004:	b2d9      	uxtb	r1, r3
 8021006:	4a0c      	ldr	r2, [pc, #48]	; (8021038 <toggle_block_delete+0x50>)
 8021008:	7d93      	ldrb	r3, [r2, #22]
 802100a:	f361 1304 	bfi	r3, r1, #4, #1
 802100e:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 8021010:	4b0a      	ldr	r3, [pc, #40]	; (802103c <toggle_block_delete+0x54>)
 8021012:	68db      	ldr	r3, [r3, #12]
 8021014:	4a08      	ldr	r2, [pc, #32]	; (8021038 <toggle_block_delete+0x50>)
 8021016:	7d92      	ldrb	r2, [r2, #22]
 8021018:	f002 0210 	and.w	r2, r2, #16
 802101c:	b2d2      	uxtb	r2, r2
 802101e:	2a00      	cmp	r2, #0
 8021020:	d001      	beq.n	8021026 <toggle_block_delete+0x3e>
 8021022:	2204      	movs	r2, #4
 8021024:	e000      	b.n	8021028 <toggle_block_delete+0x40>
 8021026:	2205      	movs	r2, #5
 8021028:	4610      	mov	r0, r2
 802102a:	4798      	blx	r3

    return Status_OK;
 802102c:	2300      	movs	r3, #0
}
 802102e:	4618      	mov	r0, r3
 8021030:	3708      	adds	r7, #8
 8021032:	46bd      	mov	sp, r7
 8021034:	bd80      	pop	{r7, pc}
 8021036:	bf00      	nop
 8021038:	20000d3c 	.word	0x20000d3c
 802103c:	20000dd4 	.word	0x20000dd4

08021040 <toggle_optional_stop>:

static status_code_t toggle_optional_stop (sys_state_t state, char *args)
{
 8021040:	b580      	push	{r7, lr}
 8021042:	b082      	sub	sp, #8
 8021044:	af00      	add	r7, sp, #0
 8021046:	6078      	str	r0, [r7, #4]
 8021048:	6039      	str	r1, [r7, #0]
    sys.flags.optional_stop_disable = !sys.flags.optional_stop_disable;
 802104a:	4b11      	ldr	r3, [pc, #68]	; (8021090 <toggle_optional_stop+0x50>)
 802104c:	7d9b      	ldrb	r3, [r3, #22]
 802104e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8021052:	b2db      	uxtb	r3, r3
 8021054:	2b00      	cmp	r3, #0
 8021056:	bf0c      	ite	eq
 8021058:	2301      	moveq	r3, #1
 802105a:	2300      	movne	r3, #0
 802105c:	b2d9      	uxtb	r1, r3
 802105e:	4a0c      	ldr	r2, [pc, #48]	; (8021090 <toggle_optional_stop+0x50>)
 8021060:	7d93      	ldrb	r3, [r2, #22]
 8021062:	f361 1386 	bfi	r3, r1, #6, #1
 8021066:	7593      	strb	r3, [r2, #22]
    grbl.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 8021068:	4b0a      	ldr	r3, [pc, #40]	; (8021094 <toggle_optional_stop+0x54>)
 802106a:	68db      	ldr	r3, [r3, #12]
 802106c:	4a08      	ldr	r2, [pc, #32]	; (8021090 <toggle_optional_stop+0x50>)
 802106e:	7d92      	ldrb	r2, [r2, #22]
 8021070:	f002 0210 	and.w	r2, r2, #16
 8021074:	b2d2      	uxtb	r2, r2
 8021076:	2a00      	cmp	r2, #0
 8021078:	d001      	beq.n	802107e <toggle_optional_stop+0x3e>
 802107a:	2204      	movs	r2, #4
 802107c:	e000      	b.n	8021080 <toggle_optional_stop+0x40>
 802107e:	2205      	movs	r2, #5
 8021080:	4610      	mov	r0, r2
 8021082:	4798      	blx	r3

    return Status_OK;
 8021084:	2300      	movs	r3, #0
}
 8021086:	4618      	mov	r0, r3
 8021088:	3708      	adds	r7, #8
 802108a:	46bd      	mov	sp, r7
 802108c:	bd80      	pop	{r7, pc}
 802108e:	bf00      	nop
 8021090:	20000d3c 	.word	0x20000d3c
 8021094:	20000dd4 	.word	0x20000dd4

08021098 <check_mode>:

static status_code_t check_mode (sys_state_t state, char *args)
{
 8021098:	b580      	push	{r7, lr}
 802109a:	b082      	sub	sp, #8
 802109c:	af00      	add	r7, sp, #0
 802109e:	6078      	str	r0, [r7, #4]
 80210a0:	6039      	str	r1, [r7, #0]
    if (state == STATE_CHECK_MODE) {
 80210a2:	687b      	ldr	r3, [r7, #4]
 80210a4:	2b02      	cmp	r3, #2
 80210a6:	d106      	bne.n	80210b6 <check_mode+0x1e>
        // Perform reset when toggling off. Check g-code mode should only work if Grbl
        // is idle and ready, regardless of alarm locks. This is mainly to keep things
        // simple and consistent.
        mc_reset();
 80210a8:	f7ee fb1e 	bl	800f6e8 <mc_reset>
        grbl.report.feedback_message(Message_Disabled);
 80210ac:	4b0b      	ldr	r3, [pc, #44]	; (80210dc <check_mode+0x44>)
 80210ae:	68db      	ldr	r3, [r3, #12]
 80210b0:	2005      	movs	r0, #5
 80210b2:	4798      	blx	r3
 80210b4:	e00c      	b.n	80210d0 <check_mode+0x38>
    } else if (state == STATE_IDLE) { // Requires idle mode.
 80210b6:	687b      	ldr	r3, [r7, #4]
 80210b8:	2b00      	cmp	r3, #0
 80210ba:	d107      	bne.n	80210cc <check_mode+0x34>
        state_set(STATE_CHECK_MODE);
 80210bc:	2002      	movs	r0, #2
 80210be:	f7fc fc09 	bl	801d8d4 <state_set>
        grbl.report.feedback_message(Message_Enabled);
 80210c2:	4b06      	ldr	r3, [pc, #24]	; (80210dc <check_mode+0x44>)
 80210c4:	68db      	ldr	r3, [r3, #12]
 80210c6:	2004      	movs	r0, #4
 80210c8:	4798      	blx	r3
 80210ca:	e001      	b.n	80210d0 <check_mode+0x38>
    } else
        return Status_IdleError;
 80210cc:	2308      	movs	r3, #8
 80210ce:	e000      	b.n	80210d2 <check_mode+0x3a>

    return Status_OK;
 80210d0:	2300      	movs	r3, #0
}
 80210d2:	4618      	mov	r0, r3
 80210d4:	3708      	adds	r7, #8
 80210d6:	46bd      	mov	sp, r7
 80210d8:	bd80      	pop	{r7, pc}
 80210da:	bf00      	nop
 80210dc:	20000dd4 	.word	0x20000dd4

080210e0 <disable_lock>:

static status_code_t disable_lock (sys_state_t state, char *args)
{
 80210e0:	b580      	push	{r7, lr}
 80210e2:	b086      	sub	sp, #24
 80210e4:	af00      	add	r7, sp, #0
 80210e6:	6078      	str	r0, [r7, #4]
 80210e8:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_OK;
 80210ea:	2300      	movs	r3, #0
 80210ec:	75fb      	strb	r3, [r7, #23]

    if(state & (STATE_ALARM|STATE_ESTOP)) {
 80210ee:	687a      	ldr	r2, [r7, #4]
 80210f0:	f240 1301 	movw	r3, #257	; 0x101
 80210f4:	4013      	ands	r3, r2
 80210f6:	2b00      	cmp	r3, #0
 80210f8:	d055      	beq.n	80211a6 <disable_lock+0xc6>

        control_signals_t control_signals = hal.control.get_state();
 80210fa:	4b2d      	ldr	r3, [pc, #180]	; (80211b0 <disable_lock+0xd0>)
 80210fc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80210fe:	4798      	blx	r3
 8021100:	4603      	mov	r3, r0
 8021102:	81bb      	strh	r3, [r7, #12]

        // Block if self-test failed
        if(sys.alarm == Alarm_SelftestFailed)
 8021104:	4b2b      	ldr	r3, [pc, #172]	; (80211b4 <disable_lock+0xd4>)
 8021106:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 802110a:	2b10      	cmp	r3, #16
 802110c:	d102      	bne.n	8021114 <disable_lock+0x34>
            retval = Status_SelfTestFailed;
 802110e:	2331      	movs	r3, #49	; 0x31
 8021110:	75fb      	strb	r3, [r7, #23]
 8021112:	e048      	b.n	80211a6 <disable_lock+0xc6>
        // Block if e-stop is active.
        else if (control_signals.e_stop)
 8021114:	7b3b      	ldrb	r3, [r7, #12]
 8021116:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802111a:	b2db      	uxtb	r3, r3
 802111c:	2b00      	cmp	r3, #0
 802111e:	d002      	beq.n	8021126 <disable_lock+0x46>
            retval = Status_EStop;
 8021120:	2332      	movs	r3, #50	; 0x32
 8021122:	75fb      	strb	r3, [r7, #23]
 8021124:	e03f      	b.n	80211a6 <disable_lock+0xc6>
        // Block if safety door is ajar.
        else if (control_signals.safety_door_ajar)
 8021126:	7b3b      	ldrb	r3, [r7, #12]
 8021128:	f003 0308 	and.w	r3, r3, #8
 802112c:	b2db      	uxtb	r3, r3
 802112e:	2b00      	cmp	r3, #0
 8021130:	d002      	beq.n	8021138 <disable_lock+0x58>
            retval = Status_CheckDoor;
 8021132:	230d      	movs	r3, #13
 8021134:	75fb      	strb	r3, [r7, #23]
 8021136:	e036      	b.n	80211a6 <disable_lock+0xc6>
        // Block if safety reset is active.
        else if(control_signals.reset)
 8021138:	7b3b      	ldrb	r3, [r7, #12]
 802113a:	f003 0301 	and.w	r3, r3, #1
 802113e:	b2db      	uxtb	r3, r3
 8021140:	2b00      	cmp	r3, #0
 8021142:	d002      	beq.n	802114a <disable_lock+0x6a>
            retval = Status_Reset;
 8021144:	2312      	movs	r3, #18
 8021146:	75fb      	strb	r3, [r7, #23]
 8021148:	e02d      	b.n	80211a6 <disable_lock+0xc6>
        else if(settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && limit_signals_merge(hal.limits.get_state()).value)
 802114a:	4b1b      	ldr	r3, [pc, #108]	; (80211b8 <disable_lock+0xd8>)
 802114c:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8021150:	f003 0301 	and.w	r3, r3, #1
 8021154:	b2db      	uxtb	r3, r3
 8021156:	2b00      	cmp	r3, #0
 8021158:	d016      	beq.n	8021188 <disable_lock+0xa8>
 802115a:	4b17      	ldr	r3, [pc, #92]	; (80211b8 <disable_lock+0xd8>)
 802115c:	f893 3124 	ldrb.w	r3, [r3, #292]	; 0x124
 8021160:	f003 0304 	and.w	r3, r3, #4
 8021164:	b2db      	uxtb	r3, r3
 8021166:	2b00      	cmp	r3, #0
 8021168:	d00e      	beq.n	8021188 <disable_lock+0xa8>
 802116a:	4b11      	ldr	r3, [pc, #68]	; (80211b0 <disable_lock+0xd0>)
 802116c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802116e:	4798      	blx	r3
 8021170:	4603      	mov	r3, r0
 8021172:	613b      	str	r3, [r7, #16]
 8021174:	6938      	ldr	r0, [r7, #16]
 8021176:	f7ea feeb 	bl	800bf50 <limit_signals_merge>
 802117a:	4603      	mov	r3, r0
 802117c:	b2db      	uxtb	r3, r3
 802117e:	2b00      	cmp	r3, #0
 8021180:	d002      	beq.n	8021188 <disable_lock+0xa8>
            retval = Status_LimitsEngaged;
 8021182:	232d      	movs	r3, #45	; 0x2d
 8021184:	75fb      	strb	r3, [r7, #23]
 8021186:	e00e      	b.n	80211a6 <disable_lock+0xc6>
        else if(limits_homing_required())
 8021188:	f7eb fdce 	bl	800cd28 <limits_homing_required>
 802118c:	4603      	mov	r3, r0
 802118e:	2b00      	cmp	r3, #0
 8021190:	d002      	beq.n	8021198 <disable_lock+0xb8>
            retval = Status_HomingRequired;
 8021192:	232e      	movs	r3, #46	; 0x2e
 8021194:	75fb      	strb	r3, [r7, #23]
 8021196:	e006      	b.n	80211a6 <disable_lock+0xc6>
        else {
            grbl.report.feedback_message(Message_AlarmUnlock);
 8021198:	4b08      	ldr	r3, [pc, #32]	; (80211bc <disable_lock+0xdc>)
 802119a:	68db      	ldr	r3, [r3, #12]
 802119c:	2003      	movs	r0, #3
 802119e:	4798      	blx	r3
            state_set(STATE_IDLE);
 80211a0:	2000      	movs	r0, #0
 80211a2:	f7fc fb97 	bl	801d8d4 <state_set>
        }
        // Don't run startup script. Prevents stored moves in startup from causing accidents.
    } // Otherwise, no effect.

    return retval;
 80211a6:	7dfb      	ldrb	r3, [r7, #23]
}
 80211a8:	4618      	mov	r0, r3
 80211aa:	3718      	adds	r7, #24
 80211ac:	46bd      	mov	sp, r7
 80211ae:	bd80      	pop	{r7, pc}
 80211b0:	20000ed0 	.word	0x20000ed0
 80211b4:	20000d3c 	.word	0x20000d3c
 80211b8:	2000147c 	.word	0x2000147c
 80211bc:	20000dd4 	.word	0x20000dd4

080211c0 <output_help>:

static status_code_t output_help (sys_state_t state, char *args)
{
 80211c0:	b580      	push	{r7, lr}
 80211c2:	b082      	sub	sp, #8
 80211c4:	af00      	add	r7, sp, #0
 80211c6:	6078      	str	r0, [r7, #4]
 80211c8:	6039      	str	r1, [r7, #0]
    return report_help(args);
 80211ca:	6838      	ldr	r0, [r7, #0]
 80211cc:	f7f3 faaa 	bl	8014724 <report_help>
 80211d0:	4603      	mov	r3, r0
}
 80211d2:	4618      	mov	r0, r3
 80211d4:	3708      	adds	r7, #8
 80211d6:	46bd      	mov	sp, r7
 80211d8:	bd80      	pop	{r7, pc}

080211da <enumerate_spindles>:

static status_code_t enumerate_spindles (sys_state_t state, char *args)
{
 80211da:	b580      	push	{r7, lr}
 80211dc:	b082      	sub	sp, #8
 80211de:	af00      	add	r7, sp, #0
 80211e0:	6078      	str	r0, [r7, #4]
 80211e2:	6039      	str	r1, [r7, #0]
    return report_spindles(false);
 80211e4:	2000      	movs	r0, #0
 80211e6:	f7f7 fca3 	bl	8018b30 <report_spindles>
 80211ea:	4603      	mov	r3, r0
}
 80211ec:	4618      	mov	r0, r3
 80211ee:	3708      	adds	r7, #8
 80211f0:	46bd      	mov	sp, r7
 80211f2:	bd80      	pop	{r7, pc}

080211f4 <enumerate_spindles_mr>:

static status_code_t enumerate_spindles_mr (sys_state_t state, char *args)
{
 80211f4:	b580      	push	{r7, lr}
 80211f6:	b082      	sub	sp, #8
 80211f8:	af00      	add	r7, sp, #0
 80211fa:	6078      	str	r0, [r7, #4]
 80211fc:	6039      	str	r1, [r7, #0]
    return report_spindles(true);
 80211fe:	2001      	movs	r0, #1
 8021200:	f7f7 fc96 	bl	8018b30 <report_spindles>
 8021204:	4603      	mov	r3, r0
}
 8021206:	4618      	mov	r0, r3
 8021208:	3708      	adds	r7, #8
 802120a:	46bd      	mov	sp, r7
 802120c:	bd80      	pop	{r7, pc}
	...

08021210 <go_home>:

static status_code_t go_home (sys_state_t state, axes_signals_t axes)
{
 8021210:	b580      	push	{r7, lr}
 8021212:	b084      	sub	sp, #16
 8021214:	af00      	add	r7, sp, #0
 8021216:	6078      	str	r0, [r7, #4]
 8021218:	7039      	strb	r1, [r7, #0]
    if(axes.mask && !settings.homing.flags.single_axis_commands)
 802121a:	783b      	ldrb	r3, [r7, #0]
 802121c:	2b00      	cmp	r3, #0
 802121e:	d009      	beq.n	8021234 <go_home+0x24>
 8021220:	4b5a      	ldr	r3, [pc, #360]	; (802138c <go_home+0x17c>)
 8021222:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8021226:	f003 0302 	and.w	r3, r3, #2
 802122a:	b2db      	uxtb	r3, r3
 802122c:	2b00      	cmp	r3, #0
 802122e:	d101      	bne.n	8021234 <go_home+0x24>
        return Status_HomingDisabled;
 8021230:	2305      	movs	r3, #5
 8021232:	e0a6      	b.n	8021382 <go_home+0x172>

    if(!(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP))))
 8021234:	f7fc fb44 	bl	801d8c0 <state_get>
 8021238:	4603      	mov	r3, r0
 802123a:	2b00      	cmp	r3, #0
 802123c:	d009      	beq.n	8021252 <go_home+0x42>
 802123e:	f7fc fb3f 	bl	801d8c0 <state_get>
 8021242:	4602      	mov	r2, r0
 8021244:	f240 1301 	movw	r3, #257	; 0x101
 8021248:	4013      	ands	r3, r2
 802124a:	2b00      	cmp	r3, #0
 802124c:	d101      	bne.n	8021252 <go_home+0x42>
        return Status_IdleError;
 802124e:	2308      	movs	r3, #8
 8021250:	e097      	b.n	8021382 <go_home+0x172>

    status_code_t retval = Status_OK;
 8021252:	2300      	movs	r3, #0
 8021254:	73fb      	strb	r3, [r7, #15]

    control_signals_t control_signals = hal.control.get_state();
 8021256:	4b4e      	ldr	r3, [pc, #312]	; (8021390 <go_home+0x180>)
 8021258:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 802125a:	4798      	blx	r3
 802125c:	4603      	mov	r3, r0
 802125e:	81bb      	strh	r3, [r7, #12]

    // Block if self-test failed
    if(sys.alarm == Alarm_SelftestFailed)
 8021260:	4b4c      	ldr	r3, [pc, #304]	; (8021394 <go_home+0x184>)
 8021262:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8021266:	2b10      	cmp	r3, #16
 8021268:	d102      	bne.n	8021270 <go_home+0x60>
        retval = Status_SelfTestFailed;
 802126a:	2331      	movs	r3, #49	; 0x31
 802126c:	73fb      	strb	r3, [r7, #15]
 802126e:	e049      	b.n	8021304 <go_home+0xf4>
    // Block if e-stop is active.
    else if (control_signals.e_stop)
 8021270:	7b3b      	ldrb	r3, [r7, #12]
 8021272:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8021276:	b2db      	uxtb	r3, r3
 8021278:	2b00      	cmp	r3, #0
 802127a:	d002      	beq.n	8021282 <go_home+0x72>
        retval = Status_EStop;
 802127c:	2332      	movs	r3, #50	; 0x32
 802127e:	73fb      	strb	r3, [r7, #15]
 8021280:	e040      	b.n	8021304 <go_home+0xf4>
    else if(control_signals.motor_fault)
 8021282:	7b7b      	ldrb	r3, [r7, #13]
 8021284:	f003 0301 	and.w	r3, r3, #1
 8021288:	b2db      	uxtb	r3, r3
 802128a:	2b00      	cmp	r3, #0
 802128c:	d002      	beq.n	8021294 <go_home+0x84>
        retval = Status_MotorFault;
 802128e:	2333      	movs	r3, #51	; 0x33
 8021290:	73fb      	strb	r3, [r7, #15]
 8021292:	e037      	b.n	8021304 <go_home+0xf4>
    else if (!(settings.homing.flags.enabled && (sys.homing.mask || settings.homing.flags.single_axis_commands || settings.homing.flags.manual)))
 8021294:	4b3d      	ldr	r3, [pc, #244]	; (802138c <go_home+0x17c>)
 8021296:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 802129a:	f003 0301 	and.w	r3, r3, #1
 802129e:	b2db      	uxtb	r3, r3
 80212a0:	2b00      	cmp	r3, #0
 80212a2:	d013      	beq.n	80212cc <go_home+0xbc>
 80212a4:	4b3b      	ldr	r3, [pc, #236]	; (8021394 <go_home+0x184>)
 80212a6:	7e9b      	ldrb	r3, [r3, #26]
 80212a8:	2b00      	cmp	r3, #0
 80212aa:	d112      	bne.n	80212d2 <go_home+0xc2>
 80212ac:	4b37      	ldr	r3, [pc, #220]	; (802138c <go_home+0x17c>)
 80212ae:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 80212b2:	f003 0302 	and.w	r3, r3, #2
 80212b6:	b2db      	uxtb	r3, r3
 80212b8:	2b00      	cmp	r3, #0
 80212ba:	d10a      	bne.n	80212d2 <go_home+0xc2>
 80212bc:	4b33      	ldr	r3, [pc, #204]	; (802138c <go_home+0x17c>)
 80212be:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 80212c2:	f003 0310 	and.w	r3, r3, #16
 80212c6:	b2db      	uxtb	r3, r3
 80212c8:	2b00      	cmp	r3, #0
 80212ca:	d102      	bne.n	80212d2 <go_home+0xc2>
        retval = Status_HomingDisabled;
 80212cc:	2305      	movs	r3, #5
 80212ce:	73fb      	strb	r3, [r7, #15]
 80212d0:	e018      	b.n	8021304 <go_home+0xf4>
    // Block if safety door is ajar.
    else if (control_signals.safety_door_ajar && !settings.safety_door.flags.ignore_when_idle)
 80212d2:	7b3b      	ldrb	r3, [r7, #12]
 80212d4:	f003 0308 	and.w	r3, r3, #8
 80212d8:	b2db      	uxtb	r3, r3
 80212da:	2b00      	cmp	r3, #0
 80212dc:	d00a      	beq.n	80212f4 <go_home+0xe4>
 80212de:	4b2b      	ldr	r3, [pc, #172]	; (802138c <go_home+0x17c>)
 80212e0:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 80212e4:	f003 0301 	and.w	r3, r3, #1
 80212e8:	b2db      	uxtb	r3, r3
 80212ea:	2b00      	cmp	r3, #0
 80212ec:	d102      	bne.n	80212f4 <go_home+0xe4>
        retval = Status_CheckDoor;
 80212ee:	230d      	movs	r3, #13
 80212f0:	73fb      	strb	r3, [r7, #15]
 80212f2:	e007      	b.n	8021304 <go_home+0xf4>
    // Block if safety reset is active.
    else if(control_signals.reset)
 80212f4:	7b3b      	ldrb	r3, [r7, #12]
 80212f6:	f003 0301 	and.w	r3, r3, #1
 80212fa:	b2db      	uxtb	r3, r3
 80212fc:	2b00      	cmp	r3, #0
 80212fe:	d001      	beq.n	8021304 <go_home+0xf4>
        retval = Status_Reset;
 8021300:	2312      	movs	r3, #18
 8021302:	73fb      	strb	r3, [r7, #15]

    if(retval == Status_OK)
 8021304:	7bfb      	ldrb	r3, [r7, #15]
 8021306:	2b00      	cmp	r3, #0
 8021308:	d104      	bne.n	8021314 <go_home+0x104>
        retval = mc_homing_cycle(axes); // Home axes according to configuration
 802130a:	7838      	ldrb	r0, [r7, #0]
 802130c:	f7ed fe5c 	bl	800efc8 <mc_homing_cycle>
 8021310:	4603      	mov	r3, r0
 8021312:	73fb      	strb	r3, [r7, #15]

    if (retval == Status_OK && !sys.abort) {
 8021314:	7bfb      	ldrb	r3, [r7, #15]
 8021316:	2b00      	cmp	r3, #0
 8021318:	d12d      	bne.n	8021376 <go_home+0x166>
 802131a:	4b1e      	ldr	r3, [pc, #120]	; (8021394 <go_home+0x184>)
 802131c:	781b      	ldrb	r3, [r3, #0]
 802131e:	f083 0301 	eor.w	r3, r3, #1
 8021322:	b2db      	uxtb	r3, r3
 8021324:	2b00      	cmp	r3, #0
 8021326:	d026      	beq.n	8021376 <go_home+0x166>
        state_set(STATE_IDLE);  // Set to IDLE when complete.
 8021328:	2000      	movs	r0, #0
 802132a:	f7fc fad3 	bl	801d8d4 <state_set>
        st_go_idle();           // Set steppers to the settings idle state before returning.
 802132e:	f7fd fbc5 	bl	801eabc <st_go_idle>
        grbl.report.feedback_message(Message_None);
 8021332:	4b19      	ldr	r3, [pc, #100]	; (8021398 <go_home+0x188>)
 8021334:	68db      	ldr	r3, [r3, #12]
 8021336:	2000      	movs	r0, #0
 8021338:	4798      	blx	r3
        // Execute startup scripts after successful homing.
        if (sys.homing.mask && (sys.homing.mask & sys.homed.mask) == sys.homing.mask)
 802133a:	4b16      	ldr	r3, [pc, #88]	; (8021394 <go_home+0x184>)
 802133c:	7e9b      	ldrb	r3, [r3, #26]
 802133e:	2b00      	cmp	r3, #0
 8021340:	d00d      	beq.n	802135e <go_home+0x14e>
 8021342:	4b14      	ldr	r3, [pc, #80]	; (8021394 <go_home+0x184>)
 8021344:	7e9a      	ldrb	r2, [r3, #26]
 8021346:	4b13      	ldr	r3, [pc, #76]	; (8021394 <go_home+0x184>)
 8021348:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 802134c:	4013      	ands	r3, r2
 802134e:	b2da      	uxtb	r2, r3
 8021350:	4b10      	ldr	r3, [pc, #64]	; (8021394 <go_home+0x184>)
 8021352:	7e9b      	ldrb	r3, [r3, #26]
 8021354:	429a      	cmp	r2, r3
 8021356:	d102      	bne.n	802135e <go_home+0x14e>
            system_execute_startup();
 8021358:	f7ff fc38 	bl	8020bcc <system_execute_startup>
 802135c:	e00b      	b.n	8021376 <go_home+0x166>
        else if(limits_homing_required()) { // Keep alarm state active if homing is required and not all axes homed.
 802135e:	f7eb fce3 	bl	800cd28 <limits_homing_required>
 8021362:	4603      	mov	r3, r0
 8021364:	2b00      	cmp	r3, #0
 8021366:	d006      	beq.n	8021376 <go_home+0x166>
            sys.alarm = Alarm_HomingRequired;
 8021368:	4b0a      	ldr	r3, [pc, #40]	; (8021394 <go_home+0x184>)
 802136a:	220b      	movs	r2, #11
 802136c:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
            state_set(STATE_ALARM);
 8021370:	2001      	movs	r0, #1
 8021372:	f7fc faaf 	bl	801d8d4 <state_set>
        }
    }

    return retval == Status_Unhandled ? Status_OK : retval;
 8021376:	7bfb      	ldrb	r3, [r7, #15]
 8021378:	2b54      	cmp	r3, #84	; 0x54
 802137a:	d001      	beq.n	8021380 <go_home+0x170>
 802137c:	7bfb      	ldrb	r3, [r7, #15]
 802137e:	e000      	b.n	8021382 <go_home+0x172>
 8021380:	2300      	movs	r3, #0
}
 8021382:	4618      	mov	r0, r3
 8021384:	3710      	adds	r7, #16
 8021386:	46bd      	mov	sp, r7
 8021388:	bd80      	pop	{r7, pc}
 802138a:	bf00      	nop
 802138c:	2000147c 	.word	0x2000147c
 8021390:	20000ed0 	.word	0x20000ed0
 8021394:	20000d3c 	.word	0x20000d3c
 8021398:	20000dd4 	.word	0x20000dd4

0802139c <home>:

static status_code_t home (sys_state_t state, char *args)
{
 802139c:	b580      	push	{r7, lr}
 802139e:	b082      	sub	sp, #8
 80213a0:	af00      	add	r7, sp, #0
 80213a2:	6078      	str	r0, [r7, #4]
 80213a4:	6039      	str	r1, [r7, #0]
    return go_home(state, (axes_signals_t){0});
 80213a6:	2300      	movs	r3, #0
 80213a8:	4619      	mov	r1, r3
 80213aa:	6878      	ldr	r0, [r7, #4]
 80213ac:	f7ff ff30 	bl	8021210 <go_home>
 80213b0:	4603      	mov	r3, r0
}
 80213b2:	4618      	mov	r0, r3
 80213b4:	3708      	adds	r7, #8
 80213b6:	46bd      	mov	sp, r7
 80213b8:	bd80      	pop	{r7, pc}

080213ba <home_x>:

static status_code_t home_x (sys_state_t state, char *args)
{
 80213ba:	b580      	push	{r7, lr}
 80213bc:	b082      	sub	sp, #8
 80213be:	af00      	add	r7, sp, #0
 80213c0:	6078      	str	r0, [r7, #4]
 80213c2:	6039      	str	r1, [r7, #0]
    return go_home(state, (axes_signals_t){X_AXIS_BIT});
 80213c4:	2301      	movs	r3, #1
 80213c6:	4619      	mov	r1, r3
 80213c8:	6878      	ldr	r0, [r7, #4]
 80213ca:	f7ff ff21 	bl	8021210 <go_home>
 80213ce:	4603      	mov	r3, r0
}
 80213d0:	4618      	mov	r0, r3
 80213d2:	3708      	adds	r7, #8
 80213d4:	46bd      	mov	sp, r7
 80213d6:	bd80      	pop	{r7, pc}

080213d8 <home_y>:

static status_code_t home_y (sys_state_t state, char *args)
{
 80213d8:	b580      	push	{r7, lr}
 80213da:	b082      	sub	sp, #8
 80213dc:	af00      	add	r7, sp, #0
 80213de:	6078      	str	r0, [r7, #4]
 80213e0:	6039      	str	r1, [r7, #0]
    return go_home(state, (axes_signals_t){Y_AXIS_BIT});
 80213e2:	2302      	movs	r3, #2
 80213e4:	4619      	mov	r1, r3
 80213e6:	6878      	ldr	r0, [r7, #4]
 80213e8:	f7ff ff12 	bl	8021210 <go_home>
 80213ec:	4603      	mov	r3, r0
}
 80213ee:	4618      	mov	r0, r3
 80213f0:	3708      	adds	r7, #8
 80213f2:	46bd      	mov	sp, r7
 80213f4:	bd80      	pop	{r7, pc}

080213f6 <home_z>:

static status_code_t home_z (sys_state_t state, char *args)
{
 80213f6:	b580      	push	{r7, lr}
 80213f8:	b082      	sub	sp, #8
 80213fa:	af00      	add	r7, sp, #0
 80213fc:	6078      	str	r0, [r7, #4]
 80213fe:	6039      	str	r1, [r7, #0]
    return go_home(state, (axes_signals_t){Z_AXIS_BIT});
 8021400:	2304      	movs	r3, #4
 8021402:	4619      	mov	r1, r3
 8021404:	6878      	ldr	r0, [r7, #4]
 8021406:	f7ff ff03 	bl	8021210 <go_home>
 802140a:	4603      	mov	r3, r0
}
 802140c:	4618      	mov	r0, r3
 802140e:	3708      	adds	r7, #8
 8021410:	46bd      	mov	sp, r7
 8021412:	bd80      	pop	{r7, pc}

08021414 <enter_sleep>:
    return go_home(state, (axes_signals_t){V_AXIS_BIT});
}
#endif

static status_code_t enter_sleep (sys_state_t state, char *args)
{
 8021414:	b580      	push	{r7, lr}
 8021416:	b082      	sub	sp, #8
 8021418:	af00      	add	r7, sp, #0
 802141a:	6078      	str	r0, [r7, #4]
 802141c:	6039      	str	r1, [r7, #0]
    if(!settings.flags.sleep_enable)
 802141e:	4b0e      	ldr	r3, [pc, #56]	; (8021458 <enter_sleep+0x44>)
 8021420:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8021424:	f003 0308 	and.w	r3, r3, #8
 8021428:	b2db      	uxtb	r3, r3
 802142a:	2b00      	cmp	r3, #0
 802142c:	d101      	bne.n	8021432 <enter_sleep+0x1e>
        return Status_InvalidStatement;
 802142e:	2303      	movs	r3, #3
 8021430:	e00e      	b.n	8021450 <enter_sleep+0x3c>
    else if(!(state == STATE_IDLE || state == STATE_ALARM))
 8021432:	687b      	ldr	r3, [r7, #4]
 8021434:	2b00      	cmp	r3, #0
 8021436:	d004      	beq.n	8021442 <enter_sleep+0x2e>
 8021438:	687b      	ldr	r3, [r7, #4]
 802143a:	2b01      	cmp	r3, #1
 802143c:	d001      	beq.n	8021442 <enter_sleep+0x2e>
        return Status_IdleError;
 802143e:	2308      	movs	r3, #8
 8021440:	e006      	b.n	8021450 <enter_sleep+0x3c>
    else
        system_set_exec_state_flag(EXEC_SLEEP); // Set to execute enter_sleep mode immediately
 8021442:	4b06      	ldr	r3, [pc, #24]	; (802145c <enter_sleep+0x48>)
 8021444:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8021446:	f44f 7180 	mov.w	r1, #256	; 0x100
 802144a:	4805      	ldr	r0, [pc, #20]	; (8021460 <enter_sleep+0x4c>)
 802144c:	4798      	blx	r3

    return Status_OK;
 802144e:	2300      	movs	r3, #0
}
 8021450:	4618      	mov	r0, r3
 8021452:	3708      	adds	r7, #8
 8021454:	46bd      	mov	sp, r7
 8021456:	bd80      	pop	{r7, pc}
 8021458:	2000147c 	.word	0x2000147c
 802145c:	20000ed0 	.word	0x20000ed0
 8021460:	20000d84 	.word	0x20000d84

08021464 <set_tool_reference>:

static status_code_t set_tool_reference (sys_state_t state, char *args)
{
 8021464:	b580      	push	{r7, lr}
 8021466:	b084      	sub	sp, #16
 8021468:	af00      	add	r7, sp, #0
 802146a:	6078      	str	r0, [r7, #4]
 802146c:	6039      	str	r1, [r7, #0]
        sys.tlo_reference[TOOL_LENGTH_OFFSET_AXIS] = sys.probe_position[TOOL_LENGTH_OFFSET_AXIS]; // - gc_state.tool_length_offset[Z_AXIS]));
    } else
        sys.tlo_reference_set.mask = 0;
#else
    plane_t plane;
    gc_get_plane_data(&plane, gc_state.modal.plane_select);
 802146e:	4b19      	ldr	r3, [pc, #100]	; (80214d4 <set_tool_reference+0x70>)
 8021470:	799a      	ldrb	r2, [r3, #6]
 8021472:	f107 030c 	add.w	r3, r7, #12
 8021476:	4611      	mov	r1, r2
 8021478:	4618      	mov	r0, r3
 802147a:	f7e4 fb93 	bl	8005ba4 <gc_get_plane_data>
    if(sys.flags.probe_succeeded) {
 802147e:	4b16      	ldr	r3, [pc, #88]	; (80214d8 <set_tool_reference+0x74>)
 8021480:	7d9b      	ldrb	r3, [r3, #22]
 8021482:	f003 0302 	and.w	r3, r3, #2
 8021486:	b2db      	uxtb	r3, r3
 8021488:	2b00      	cmp	r3, #0
 802148a:	d016      	beq.n	80214ba <set_tool_reference+0x56>
        sys.tlo_reference_set.mask |= bit(plane.axis_linear);
 802148c:	4b12      	ldr	r3, [pc, #72]	; (80214d8 <set_tool_reference+0x74>)
 802148e:	79da      	ldrb	r2, [r3, #7]
 8021490:	7bbb      	ldrb	r3, [r7, #14]
 8021492:	4619      	mov	r1, r3
 8021494:	2301      	movs	r3, #1
 8021496:	408b      	lsls	r3, r1
 8021498:	b2db      	uxtb	r3, r3
 802149a:	4313      	orrs	r3, r2
 802149c:	b2da      	uxtb	r2, r3
 802149e:	4b0e      	ldr	r3, [pc, #56]	; (80214d8 <set_tool_reference+0x74>)
 80214a0:	71da      	strb	r2, [r3, #7]
        sys.tlo_reference[plane.axis_linear] = sys.probe_position[plane.axis_linear];
 80214a2:	7bbb      	ldrb	r3, [r7, #14]
 80214a4:	7bba      	ldrb	r2, [r7, #14]
 80214a6:	4610      	mov	r0, r2
 80214a8:	4a0b      	ldr	r2, [pc, #44]	; (80214d8 <set_tool_reference+0x74>)
 80214aa:	330e      	adds	r3, #14
 80214ac:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80214b0:	4909      	ldr	r1, [pc, #36]	; (80214d8 <set_tool_reference+0x74>)
 80214b2:	1c83      	adds	r3, r0, #2
 80214b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80214b8:	e002      	b.n	80214c0 <set_tool_reference+0x5c>
//                    - lroundf(gc_state.tool_length_offset[plane.axis_linear] * settings.axis[plane.axis_linear].steps_per_mm);
    } else
        sys.tlo_reference_set.mask = 0;
 80214ba:	4b07      	ldr	r3, [pc, #28]	; (80214d8 <set_tool_reference+0x74>)
 80214bc:	2200      	movs	r2, #0
 80214be:	71da      	strb	r2, [r3, #7]
#endif
    system_add_rt_report(Report_TLOReference);
 80214c0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80214c4:	f000 fd6a 	bl	8021f9c <system_add_rt_report>

    return Status_OK;
 80214c8:	2300      	movs	r3, #0
}
 80214ca:	4618      	mov	r0, r3
 80214cc:	3710      	adds	r7, #16
 80214ce:	46bd      	mov	sp, r7
 80214d0:	bd80      	pop	{r7, pc}
 80214d2:	bf00      	nop
 80214d4:	20000bb0 	.word	0x20000bb0
 80214d8:	20000d3c 	.word	0x20000d3c

080214dc <tool_probe_workpiece>:

static status_code_t tool_probe_workpiece (sys_state_t state, char *args)
{
 80214dc:	b580      	push	{r7, lr}
 80214de:	b082      	sub	sp, #8
 80214e0:	af00      	add	r7, sp, #0
 80214e2:	6078      	str	r0, [r7, #4]
 80214e4:	6039      	str	r1, [r7, #0]
    return tc_probe_workpiece();
 80214e6:	f001 fb57 	bl	8022b98 <tc_probe_workpiece>
 80214ea:	4603      	mov	r3, r0
}
 80214ec:	4618      	mov	r0, r3
 80214ee:	3708      	adds	r7, #8
 80214f0:	46bd      	mov	sp, r7
 80214f2:	bd80      	pop	{r7, pc}

080214f4 <output_ngc_parameters>:

static status_code_t output_ngc_parameters (sys_state_t state, char *args)
{
 80214f4:	b580      	push	{r7, lr}
 80214f6:	b084      	sub	sp, #16
 80214f8:	af00      	add	r7, sp, #0
 80214fa:	6078      	str	r0, [r7, #4]
 80214fc:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_OK;
 80214fe:	2300      	movs	r3, #0
 8021500:	73fb      	strb	r3, [r7, #15]

    if(args) {
 8021502:	683b      	ldr	r3, [r7, #0]
 8021504:	2b00      	cmp	r3, #0
 8021506:	d01b      	beq.n	8021540 <output_ngc_parameters+0x4c>
        int32_t id;
        retval = read_int(args, &id);
 8021508:	f107 0308 	add.w	r3, r7, #8
 802150c:	4619      	mov	r1, r3
 802150e:	6838      	ldr	r0, [r7, #0]
 8021510:	f7ff fb94 	bl	8020c3c <read_int>
 8021514:	4603      	mov	r3, r0
 8021516:	73fb      	strb	r3, [r7, #15]
        if(retval == Status_OK && id >= 0)
 8021518:	7bfb      	ldrb	r3, [r7, #15]
 802151a:	2b00      	cmp	r3, #0
 802151c:	d10a      	bne.n	8021534 <output_ngc_parameters+0x40>
 802151e:	68bb      	ldr	r3, [r7, #8]
 8021520:	2b00      	cmp	r3, #0
 8021522:	db07      	blt.n	8021534 <output_ngc_parameters+0x40>
            retval = report_ngc_parameter((ngc_param_id_t)id);
 8021524:	68bb      	ldr	r3, [r7, #8]
 8021526:	b29b      	uxth	r3, r3
 8021528:	4618      	mov	r0, r3
 802152a:	f7f3 fbc1 	bl	8014cb0 <report_ngc_parameter>
 802152e:	4603      	mov	r3, r0
 8021530:	73fb      	strb	r3, [r7, #15]
 8021532:	e007      	b.n	8021544 <output_ngc_parameters+0x50>
        else
            retval = report_named_ngc_parameter(args);
 8021534:	6838      	ldr	r0, [r7, #0]
 8021536:	f7f3 fc03 	bl	8014d40 <report_named_ngc_parameter>
 802153a:	4603      	mov	r3, r0
 802153c:	73fb      	strb	r3, [r7, #15]
 802153e:	e001      	b.n	8021544 <output_ngc_parameters+0x50>
    } else
        report_ngc_parameters();
 8021540:	f7f3 fc40 	bl	8014dc4 <report_ngc_parameters>

    return retval;
 8021544:	7bfb      	ldrb	r3, [r7, #15]
}
 8021546:	4618      	mov	r0, r3
 8021548:	3710      	adds	r7, #16
 802154a:	46bd      	mov	sp, r7
 802154c:	bd80      	pop	{r7, pc}

0802154e <build_info>:

static status_code_t build_info (sys_state_t state, char *args)
{
 802154e:	b580      	push	{r7, lr}
 8021550:	b094      	sub	sp, #80	; 0x50
 8021552:	af00      	add	r7, sp, #0
 8021554:	6078      	str	r0, [r7, #4]
 8021556:	6039      	str	r1, [r7, #0]
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE))))
 8021558:	687b      	ldr	r3, [r7, #4]
 802155a:	2b00      	cmp	r3, #0
 802155c:	d007      	beq.n	802156e <build_info+0x20>
 802155e:	687a      	ldr	r2, [r7, #4]
 8021560:	f240 1383 	movw	r3, #387	; 0x183
 8021564:	4013      	ands	r3, r2
 8021566:	2b00      	cmp	r3, #0
 8021568:	d101      	bne.n	802156e <build_info+0x20>
        return Status_IdleError;
 802156a:	2308      	movs	r3, #8
 802156c:	e01b      	b.n	80215a6 <build_info+0x58>

    if (args == NULL) {
 802156e:	683b      	ldr	r3, [r7, #0]
 8021570:	2b00      	cmp	r3, #0
 8021572:	d10b      	bne.n	802158c <build_info+0x3e>
        char info[sizeof(stored_line_t)];
        settings_read_build_info(info);
 8021574:	f107 0308 	add.w	r3, r7, #8
 8021578:	4618      	mov	r0, r3
 802157a:	f7f9 fa8b 	bl	801aa94 <settings_read_build_info>
        report_build_info(info, false);
 802157e:	f107 0308 	add.w	r3, r7, #8
 8021582:	2100      	movs	r1, #0
 8021584:	4618      	mov	r0, r3
 8021586:	f7f4 f87f 	bl	8015688 <report_build_info>
 802158a:	e00b      	b.n	80215a4 <build_info+0x56>
    }
  #if !DISABLE_BUILD_INFO_WRITE_COMMAND
    else if (strlen(args) < (sizeof(stored_line_t) - 1))
 802158c:	6838      	ldr	r0, [r7, #0]
 802158e:	f7de fe55 	bl	800023c <strlen>
 8021592:	4603      	mov	r3, r0
 8021594:	2b44      	cmp	r3, #68	; 0x44
 8021596:	d803      	bhi.n	80215a0 <build_info+0x52>
        settings_write_build_info(args);
 8021598:	6838      	ldr	r0, [r7, #0]
 802159a:	f7f9 fa63 	bl	801aa64 <settings_write_build_info>
 802159e:	e001      	b.n	80215a4 <build_info+0x56>
  #endif
    else
        return Status_InvalidStatement;
 80215a0:	2303      	movs	r3, #3
 80215a2:	e000      	b.n	80215a6 <build_info+0x58>

    return Status_OK;
 80215a4:	2300      	movs	r3, #0
}
 80215a6:	4618      	mov	r0, r3
 80215a8:	3750      	adds	r7, #80	; 0x50
 80215aa:	46bd      	mov	sp, r7
 80215ac:	bd80      	pop	{r7, pc}

080215ae <output_all_build_info>:

static status_code_t output_all_build_info (sys_state_t state, char *args)
{
 80215ae:	b580      	push	{r7, lr}
 80215b0:	b094      	sub	sp, #80	; 0x50
 80215b2:	af00      	add	r7, sp, #0
 80215b4:	6078      	str	r0, [r7, #4]
 80215b6:	6039      	str	r1, [r7, #0]
    char info[sizeof(stored_line_t)];

    settings_read_build_info(info);
 80215b8:	f107 0308 	add.w	r3, r7, #8
 80215bc:	4618      	mov	r0, r3
 80215be:	f7f9 fa69 	bl	801aa94 <settings_read_build_info>
    report_build_info(info, true);
 80215c2:	f107 0308 	add.w	r3, r7, #8
 80215c6:	2101      	movs	r1, #1
 80215c8:	4618      	mov	r0, r3
 80215ca:	f7f4 f85d 	bl	8015688 <report_build_info>

    return Status_OK;
 80215ce:	2300      	movs	r3, #0
}
 80215d0:	4618      	mov	r0, r3
 80215d2:	3750      	adds	r7, #80	; 0x50
 80215d4:	46bd      	mov	sp, r7
 80215d6:	bd80      	pop	{r7, pc}

080215d8 <settings_reset>:

static status_code_t settings_reset (sys_state_t state, char *args)
{
 80215d8:	b580      	push	{r7, lr}
 80215da:	b084      	sub	sp, #16
 80215dc:	af00      	add	r7, sp, #0
 80215de:	6078      	str	r0, [r7, #4]
 80215e0:	6039      	str	r1, [r7, #0]
    settings_restore_t restore = {0};
 80215e2:	2300      	movs	r3, #0
 80215e4:	733b      	strb	r3, [r7, #12]
    status_code_t retval = Status_OK;
 80215e6:	2300      	movs	r3, #0
 80215e8:	73fb      	strb	r3, [r7, #15]

    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP))))
 80215ea:	687b      	ldr	r3, [r7, #4]
 80215ec:	2b00      	cmp	r3, #0
 80215ee:	d008      	beq.n	8021602 <settings_reset+0x2a>
 80215f0:	687a      	ldr	r2, [r7, #4]
 80215f2:	f240 1301 	movw	r3, #257	; 0x101
 80215f6:	4013      	ands	r3, r2
 80215f8:	2b00      	cmp	r3, #0
 80215fa:	d102      	bne.n	8021602 <settings_reset+0x2a>
        retval = Status_IdleError;
 80215fc:	2308      	movs	r3, #8
 80215fe:	73fb      	strb	r3, [r7, #15]
 8021600:	e02e      	b.n	8021660 <settings_reset+0x88>

    else switch (*args) {
 8021602:	683b      	ldr	r3, [r7, #0]
 8021604:	781b      	ldrb	r3, [r3, #0]
 8021606:	3b23      	subs	r3, #35	; 0x23
 8021608:	2b07      	cmp	r3, #7
 802160a:	d826      	bhi.n	802165a <settings_reset+0x82>
 802160c:	a201      	add	r2, pc, #4	; (adr r2, 8021614 <settings_reset+0x3c>)
 802160e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021612:	bf00      	nop
 8021614:	0802163f 	.word	0x0802163f
 8021618:	08021635 	.word	0x08021635
 802161c:	0802165b 	.word	0x0802165b
 8021620:	08021651 	.word	0x08021651
 8021624:	0802165b 	.word	0x0802165b
 8021628:	0802165b 	.word	0x0802165b
 802162c:	0802165b 	.word	0x0802165b
 8021630:	08021649 	.word	0x08021649

      #if ENABLE_RESTORE_NVS_DEFAULT_SETTINGS
        case '$':
            restore.defaults = On;
 8021634:	7b3b      	ldrb	r3, [r7, #12]
 8021636:	f043 0301 	orr.w	r3, r3, #1
 802163a:	733b      	strb	r3, [r7, #12]
            break;
 802163c:	e010      	b.n	8021660 <settings_reset+0x88>
      #endif

      #if ENABLE_RESTORE_NVS_CLEAR_PARAMETERS
        case '#':
            restore.parameters = On;
 802163e:	7b3b      	ldrb	r3, [r7, #12]
 8021640:	f043 0302 	orr.w	r3, r3, #2
 8021644:	733b      	strb	r3, [r7, #12]
            break;
 8021646:	e00b      	b.n	8021660 <settings_reset+0x88>
      #endif

      #if ENABLE_RESTORE_NVS_WIPE_ALL
        case '*':
            restore.mask = settings_all.mask;
 8021648:	4b0f      	ldr	r3, [pc, #60]	; (8021688 <settings_reset+0xb0>)
 802164a:	781b      	ldrb	r3, [r3, #0]
 802164c:	733b      	strb	r3, [r7, #12]
            break;
 802164e:	e007      	b.n	8021660 <settings_reset+0x88>
      #endif

      #if ENABLE_RESTORE_NVS_DRIVER_PARAMETERS
        case '&':
            restore.driver_parameters = On;
 8021650:	7b3b      	ldrb	r3, [r7, #12]
 8021652:	f043 0310 	orr.w	r3, r3, #16
 8021656:	733b      	strb	r3, [r7, #12]
            break;
 8021658:	e002      	b.n	8021660 <settings_reset+0x88>
      #endif

        default:
            retval = Status_InvalidStatement;
 802165a:	2303      	movs	r3, #3
 802165c:	73fb      	strb	r3, [r7, #15]
            break;
 802165e:	bf00      	nop
    }

    if(retval == Status_OK && restore.mask) {
 8021660:	7bfb      	ldrb	r3, [r7, #15]
 8021662:	2b00      	cmp	r3, #0
 8021664:	d10b      	bne.n	802167e <settings_reset+0xa6>
 8021666:	7b3b      	ldrb	r3, [r7, #12]
 8021668:	2b00      	cmp	r3, #0
 802166a:	d008      	beq.n	802167e <settings_reset+0xa6>
        settings_restore(restore);
 802166c:	7b38      	ldrb	r0, [r7, #12]
 802166e:	f7f9 fb9b 	bl	801ada8 <settings_restore>
        grbl.report.feedback_message(Message_RestoreDefaults);
 8021672:	4b06      	ldr	r3, [pc, #24]	; (802168c <settings_reset+0xb4>)
 8021674:	68db      	ldr	r3, [r3, #12]
 8021676:	2009      	movs	r0, #9
 8021678:	4798      	blx	r3
        mc_reset(); // Force reset to ensure settings are initialized correctly.
 802167a:	f7ee f835 	bl	800f6e8 <mc_reset>
    }

    return retval;
 802167e:	7bfb      	ldrb	r3, [r7, #15]
}
 8021680:	4618      	mov	r0, r3
 8021682:	3710      	adds	r7, #16
 8021684:	46bd      	mov	sp, r7
 8021686:	bd80      	pop	{r7, pc}
 8021688:	08031468 	.word	0x08031468
 802168c:	20000dd4 	.word	0x20000dd4

08021690 <output_startup_lines>:

static status_code_t output_startup_lines (sys_state_t state, char *args)
{
 8021690:	b580      	push	{r7, lr}
 8021692:	b096      	sub	sp, #88	; 0x58
 8021694:	af00      	add	r7, sp, #0
 8021696:	6078      	str	r0, [r7, #4]
 8021698:	6039      	str	r1, [r7, #0]
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 802169a:	687b      	ldr	r3, [r7, #4]
 802169c:	2b00      	cmp	r3, #0
 802169e:	d007      	beq.n	80216b0 <output_startup_lines+0x20>
 80216a0:	687a      	ldr	r2, [r7, #4]
 80216a2:	f240 1303 	movw	r3, #259	; 0x103
 80216a6:	4013      	ands	r3, r2
 80216a8:	2b00      	cmp	r3, #0
 80216aa:	d101      	bne.n	80216b0 <output_startup_lines+0x20>
        return Status_IdleError;
 80216ac:	2308      	movs	r3, #8
 80216ae:	e024      	b.n	80216fa <output_startup_lines+0x6a>
    // Print startup lines

    uint_fast8_t counter;
    char line[sizeof(stored_line_t)];

    for (counter = 0; counter < N_STARTUP_LINE; counter++) {
 80216b0:	2300      	movs	r3, #0
 80216b2:	657b      	str	r3, [r7, #84]	; 0x54
 80216b4:	e01d      	b.n	80216f2 <output_startup_lines+0x62>
        if (!(settings_read_startup_line(counter, line)))
 80216b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80216b8:	b2db      	uxtb	r3, r3
 80216ba:	f107 020c 	add.w	r2, r7, #12
 80216be:	4611      	mov	r1, r2
 80216c0:	4618      	mov	r0, r3
 80216c2:	f7f9 fa3b 	bl	801ab3c <settings_read_startup_line>
 80216c6:	4603      	mov	r3, r0
 80216c8:	f083 0301 	eor.w	r3, r3, #1
 80216cc:	b2db      	uxtb	r3, r3
 80216ce:	2b00      	cmp	r3, #0
 80216d0:	d004      	beq.n	80216dc <output_startup_lines+0x4c>
            grbl.report.status_message(Status_SettingReadFail);
 80216d2:	4b0c      	ldr	r3, [pc, #48]	; (8021704 <output_startup_lines+0x74>)
 80216d4:	689b      	ldr	r3, [r3, #8]
 80216d6:	2007      	movs	r0, #7
 80216d8:	4798      	blx	r3
 80216da:	e007      	b.n	80216ec <output_startup_lines+0x5c>
        else
            report_startup_line(counter, line);
 80216dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80216de:	b2db      	uxtb	r3, r3
 80216e0:	f107 020c 	add.w	r2, r7, #12
 80216e4:	4611      	mov	r1, r2
 80216e6:	4618      	mov	r0, r3
 80216e8:	f7f3 ff7c 	bl	80155e4 <report_startup_line>
    for (counter = 0; counter < N_STARTUP_LINE; counter++) {
 80216ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80216ee:	3301      	adds	r3, #1
 80216f0:	657b      	str	r3, [r7, #84]	; 0x54
 80216f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80216f4:	2b01      	cmp	r3, #1
 80216f6:	d9de      	bls.n	80216b6 <output_startup_lines+0x26>
    }

    return Status_OK;
 80216f8:	2300      	movs	r3, #0
}
 80216fa:	4618      	mov	r0, r3
 80216fc:	3758      	adds	r7, #88	; 0x58
 80216fe:	46bd      	mov	sp, r7
 8021700:	bd80      	pop	{r7, pc}
 8021702:	bf00      	nop
 8021704:	20000dd4 	.word	0x20000dd4

08021708 <set_startup_line>:

static status_code_t set_startup_line (sys_state_t state, char *args, uint_fast8_t lnr)
{
 8021708:	b580      	push	{r7, lr}
 802170a:	b086      	sub	sp, #24
 802170c:	af00      	add	r7, sp, #0
 802170e:	60f8      	str	r0, [r7, #12]
 8021710:	60b9      	str	r1, [r7, #8]
 8021712:	607a      	str	r2, [r7, #4]
    // Store startup line [IDLE Only] Prevents motion during ALARM.
    if (!(state == STATE_IDLE || (state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 8021714:	68fb      	ldr	r3, [r7, #12]
 8021716:	2b00      	cmp	r3, #0
 8021718:	d007      	beq.n	802172a <set_startup_line+0x22>
 802171a:	68fa      	ldr	r2, [r7, #12]
 802171c:	f240 1303 	movw	r3, #259	; 0x103
 8021720:	4013      	ands	r3, r2
 8021722:	2b00      	cmp	r3, #0
 8021724:	d101      	bne.n	802172a <set_startup_line+0x22>
        return Status_IdleError;
 8021726:	2308      	movs	r3, #8
 8021728:	e023      	b.n	8021772 <set_startup_line+0x6a>

    if(args == NULL)
 802172a:	68bb      	ldr	r3, [r7, #8]
 802172c:	2b00      	cmp	r3, #0
 802172e:	d101      	bne.n	8021734 <set_startup_line+0x2c>
        return Status_InvalidStatement;
 8021730:	2303      	movs	r3, #3
 8021732:	e01e      	b.n	8021772 <set_startup_line+0x6a>

    status_code_t retval = Status_OK;
 8021734:	2300      	movs	r3, #0
 8021736:	75fb      	strb	r3, [r7, #23]

    args = gc_normalize_block(args, NULL);
 8021738:	2100      	movs	r1, #0
 802173a:	68b8      	ldr	r0, [r7, #8]
 802173c:	f7e4 fc7a 	bl	8006034 <gc_normalize_block>
 8021740:	60b8      	str	r0, [r7, #8]

    if(strlen(args) >= (sizeof(stored_line_t) - 1))
 8021742:	68b8      	ldr	r0, [r7, #8]
 8021744:	f7de fd7a 	bl	800023c <strlen>
 8021748:	4603      	mov	r3, r0
 802174a:	2b44      	cmp	r3, #68	; 0x44
 802174c:	d902      	bls.n	8021754 <set_startup_line+0x4c>
        retval = Status_Overflow;
 802174e:	230b      	movs	r3, #11
 8021750:	75fb      	strb	r3, [r7, #23]
 8021752:	e00d      	b.n	8021770 <set_startup_line+0x68>
    else if ((retval = gc_execute_block(args)) == Status_OK) // Execute gcode block to ensure block is valid.
 8021754:	68b8      	ldr	r0, [r7, #8]
 8021756:	f7e4 fd61 	bl	800621c <gc_execute_block>
 802175a:	4603      	mov	r3, r0
 802175c:	75fb      	strb	r3, [r7, #23]
 802175e:	7dfb      	ldrb	r3, [r7, #23]
 8021760:	2b00      	cmp	r3, #0
 8021762:	d105      	bne.n	8021770 <set_startup_line+0x68>
        settings_write_startup_line(lnr, args);
 8021764:	687b      	ldr	r3, [r7, #4]
 8021766:	b2db      	uxtb	r3, r3
 8021768:	68b9      	ldr	r1, [r7, #8]
 802176a:	4618      	mov	r0, r3
 802176c:	f7f9 f9b6 	bl	801aadc <settings_write_startup_line>

    return retval;
 8021770:	7dfb      	ldrb	r3, [r7, #23]
}
 8021772:	4618      	mov	r0, r3
 8021774:	3718      	adds	r7, #24
 8021776:	46bd      	mov	sp, r7
 8021778:	bd80      	pop	{r7, pc}

0802177a <set_startup_line0>:

static status_code_t set_startup_line0 (sys_state_t state, char *args)
{
 802177a:	b580      	push	{r7, lr}
 802177c:	b082      	sub	sp, #8
 802177e:	af00      	add	r7, sp, #0
 8021780:	6078      	str	r0, [r7, #4]
 8021782:	6039      	str	r1, [r7, #0]
    return set_startup_line(state, args, 0);
 8021784:	2200      	movs	r2, #0
 8021786:	6839      	ldr	r1, [r7, #0]
 8021788:	6878      	ldr	r0, [r7, #4]
 802178a:	f7ff ffbd 	bl	8021708 <set_startup_line>
 802178e:	4603      	mov	r3, r0
}
 8021790:	4618      	mov	r0, r3
 8021792:	3708      	adds	r7, #8
 8021794:	46bd      	mov	sp, r7
 8021796:	bd80      	pop	{r7, pc}

08021798 <set_startup_line1>:

static status_code_t set_startup_line1 (sys_state_t state, char *args)
{
 8021798:	b580      	push	{r7, lr}
 802179a:	b082      	sub	sp, #8
 802179c:	af00      	add	r7, sp, #0
 802179e:	6078      	str	r0, [r7, #4]
 80217a0:	6039      	str	r1, [r7, #0]
    return set_startup_line(state, args, 1);
 80217a2:	2201      	movs	r2, #1
 80217a4:	6839      	ldr	r1, [r7, #0]
 80217a6:	6878      	ldr	r0, [r7, #4]
 80217a8:	f7ff ffae 	bl	8021708 <set_startup_line>
 80217ac:	4603      	mov	r3, r0
}
 80217ae:	4618      	mov	r0, r3
 80217b0:	3708      	adds	r7, #8
 80217b2:	46bd      	mov	sp, r7
 80217b4:	bd80      	pop	{r7, pc}
	...

080217b8 <rtc_action>:

static status_code_t rtc_action (sys_state_t state, char *args)
{
 80217b8:	b580      	push	{r7, lr}
 80217ba:	b084      	sub	sp, #16
 80217bc:	af00      	add	r7, sp, #0
 80217be:	6078      	str	r0, [r7, #4]
 80217c0:	6039      	str	r1, [r7, #0]
    status_code_t retval = Status_OK;
 80217c2:	2300      	movs	r3, #0
 80217c4:	73fb      	strb	r3, [r7, #15]

    if(args) {
 80217c6:	683b      	ldr	r3, [r7, #0]
 80217c8:	2b00      	cmp	r3, #0
 80217ca:	d00f      	beq.n	80217ec <rtc_action+0x34>

        struct tm *time = get_datetime(args);
 80217cc:	6838      	ldr	r0, [r7, #0]
 80217ce:	f7ef f86f 	bl	80108b0 <get_datetime>
 80217d2:	60b8      	str	r0, [r7, #8]

        if(time)
 80217d4:	68bb      	ldr	r3, [r7, #8]
 80217d6:	2b00      	cmp	r3, #0
 80217d8:	d005      	beq.n	80217e6 <rtc_action+0x2e>
            hal.rtc.set_datetime(time);
 80217da:	4b09      	ldr	r3, [pc, #36]	; (8021800 <rtc_action+0x48>)
 80217dc:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 80217e0:	68b8      	ldr	r0, [r7, #8]
 80217e2:	4798      	blx	r3
 80217e4:	e006      	b.n	80217f4 <rtc_action+0x3c>
        else
            retval = Status_BadNumberFormat;
 80217e6:	2302      	movs	r3, #2
 80217e8:	73fb      	strb	r3, [r7, #15]
 80217ea:	e003      	b.n	80217f4 <rtc_action+0x3c>
    } else
        retval = report_time();
 80217ec:	f7f7 f800 	bl	80187f0 <report_time>
 80217f0:	4603      	mov	r3, r0
 80217f2:	73fb      	strb	r3, [r7, #15]

    return retval;
 80217f4:	7bfb      	ldrb	r3, [r7, #15]
}
 80217f6:	4618      	mov	r0, r3
 80217f8:	3710      	adds	r7, #16
 80217fa:	46bd      	mov	sp, r7
 80217fc:	bd80      	pop	{r7, pc}
 80217fe:	bf00      	nop
 8021800:	20000ed0 	.word	0x20000ed0

08021804 <system_command_help>:
    { "Q", output_memmap, { .noargs = On } },
#endif
};

void system_command_help (void)
{
 8021804:	b580      	push	{r7, lr}
 8021806:	b082      	sub	sp, #8
 8021808:	af00      	add	r7, sp, #0
    hal.stream.write("$I - output system information" ASCII_EOL);
 802180a:	4b88      	ldr	r3, [pc, #544]	; (8021a2c <system_command_help+0x228>)
 802180c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021810:	4887      	ldr	r0, [pc, #540]	; (8021a30 <system_command_help+0x22c>)
 8021812:	4798      	blx	r3
    hal.stream.write("$I+ - output extended system information" ASCII_EOL);
 8021814:	4b85      	ldr	r3, [pc, #532]	; (8021a2c <system_command_help+0x228>)
 8021816:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802181a:	4886      	ldr	r0, [pc, #536]	; (8021a34 <system_command_help+0x230>)
 802181c:	4798      	blx	r3
#if !DISABLE_BUILD_INFO_WRITE_COMMAND
    hal.stream.write("$I=<string> set build info string" ASCII_EOL);
 802181e:	4b83      	ldr	r3, [pc, #524]	; (8021a2c <system_command_help+0x228>)
 8021820:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021824:	4884      	ldr	r0, [pc, #528]	; (8021a38 <system_command_help+0x234>)
 8021826:	4798      	blx	r3
#endif
    hal.stream.write("$<n> - output setting <n> value" ASCII_EOL);
 8021828:	4b80      	ldr	r3, [pc, #512]	; (8021a2c <system_command_help+0x228>)
 802182a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802182e:	4883      	ldr	r0, [pc, #524]	; (8021a3c <system_command_help+0x238>)
 8021830:	4798      	blx	r3
    hal.stream.write("$<n>=<value> - assign <value> to settings <n>" ASCII_EOL);
 8021832:	4b7e      	ldr	r3, [pc, #504]	; (8021a2c <system_command_help+0x228>)
 8021834:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021838:	4881      	ldr	r0, [pc, #516]	; (8021a40 <system_command_help+0x23c>)
 802183a:	4798      	blx	r3
    hal.stream.write("$$ - output all setting values" ASCII_EOL);
 802183c:	4b7b      	ldr	r3, [pc, #492]	; (8021a2c <system_command_help+0x228>)
 802183e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021842:	4880      	ldr	r0, [pc, #512]	; (8021a44 <system_command_help+0x240>)
 8021844:	4798      	blx	r3
    hal.stream.write("$+ - output all setting values" ASCII_EOL);
 8021846:	4b79      	ldr	r3, [pc, #484]	; (8021a2c <system_command_help+0x228>)
 8021848:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802184c:	487e      	ldr	r0, [pc, #504]	; (8021a48 <system_command_help+0x244>)
 802184e:	4798      	blx	r3
    hal.stream.write("$$=<n> - output setting details for setting <n>" ASCII_EOL);
 8021850:	4b76      	ldr	r3, [pc, #472]	; (8021a2c <system_command_help+0x228>)
 8021852:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021856:	487d      	ldr	r0, [pc, #500]	; (8021a4c <system_command_help+0x248>)
 8021858:	4798      	blx	r3
    hal.stream.write("$# - output offsets, tool table, probing and home position" ASCII_EOL);
 802185a:	4b74      	ldr	r3, [pc, #464]	; (8021a2c <system_command_help+0x228>)
 802185c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021860:	487b      	ldr	r0, [pc, #492]	; (8021a50 <system_command_help+0x24c>)
 8021862:	4798      	blx	r3
    hal.stream.write("$#=<n> - output value for parameter <n>" ASCII_EOL);
 8021864:	4b71      	ldr	r3, [pc, #452]	; (8021a2c <system_command_help+0x228>)
 8021866:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802186a:	487a      	ldr	r0, [pc, #488]	; (8021a54 <system_command_help+0x250>)
 802186c:	4798      	blx	r3
    hal.stream.write("$G - output parser state" ASCII_EOL);
 802186e:	4b6f      	ldr	r3, [pc, #444]	; (8021a2c <system_command_help+0x228>)
 8021870:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021874:	4878      	ldr	r0, [pc, #480]	; (8021a58 <system_command_help+0x254>)
 8021876:	4798      	blx	r3
    hal.stream.write("$N - output startup lines" ASCII_EOL);
 8021878:	4b6c      	ldr	r3, [pc, #432]	; (8021a2c <system_command_help+0x228>)
 802187a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802187e:	4877      	ldr	r0, [pc, #476]	; (8021a5c <system_command_help+0x258>)
 8021880:	4798      	blx	r3
    if(settings.homing.flags.enabled)
 8021882:	4b77      	ldr	r3, [pc, #476]	; (8021a60 <system_command_help+0x25c>)
 8021884:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8021888:	f003 0301 	and.w	r3, r3, #1
 802188c:	b2db      	uxtb	r3, r3
 802188e:	2b00      	cmp	r3, #0
 8021890:	d004      	beq.n	802189c <system_command_help+0x98>
        hal.stream.write("$H - home configured axes" ASCII_EOL);
 8021892:	4b66      	ldr	r3, [pc, #408]	; (8021a2c <system_command_help+0x228>)
 8021894:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021898:	4872      	ldr	r0, [pc, #456]	; (8021a64 <system_command_help+0x260>)
 802189a:	4798      	blx	r3
    if(settings.homing.flags.single_axis_commands)
 802189c:	4b70      	ldr	r3, [pc, #448]	; (8021a60 <system_command_help+0x25c>)
 802189e:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 80218a2:	f003 0302 	and.w	r3, r3, #2
 80218a6:	b2db      	uxtb	r3, r3
 80218a8:	2b00      	cmp	r3, #0
 80218aa:	d004      	beq.n	80218b6 <system_command_help+0xb2>
        hal.stream.write("$H<axisletter> - home single axis" ASCII_EOL);
 80218ac:	4b5f      	ldr	r3, [pc, #380]	; (8021a2c <system_command_help+0x228>)
 80218ae:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218b2:	486d      	ldr	r0, [pc, #436]	; (8021a68 <system_command_help+0x264>)
 80218b4:	4798      	blx	r3
    hal.stream.write("$HSS - report homing switches status" ASCII_EOL);
 80218b6:	4b5d      	ldr	r3, [pc, #372]	; (8021a2c <system_command_help+0x228>)
 80218b8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218bc:	486b      	ldr	r0, [pc, #428]	; (8021a6c <system_command_help+0x268>)
 80218be:	4798      	blx	r3
    hal.stream.write("$X - unlock machine" ASCII_EOL);
 80218c0:	4b5a      	ldr	r3, [pc, #360]	; (8021a2c <system_command_help+0x228>)
 80218c2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218c6:	486a      	ldr	r0, [pc, #424]	; (8021a70 <system_command_help+0x26c>)
 80218c8:	4798      	blx	r3
    hal.stream.write("$SLP - enter sleep mode" ASCII_EOL);
 80218ca:	4b58      	ldr	r3, [pc, #352]	; (8021a2c <system_command_help+0x228>)
 80218cc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218d0:	4868      	ldr	r0, [pc, #416]	; (8021a74 <system_command_help+0x270>)
 80218d2:	4798      	blx	r3
    hal.stream.write("$HELP - output help topics" ASCII_EOL);
 80218d4:	4b55      	ldr	r3, [pc, #340]	; (8021a2c <system_command_help+0x228>)
 80218d6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218da:	4867      	ldr	r0, [pc, #412]	; (8021a78 <system_command_help+0x274>)
 80218dc:	4798      	blx	r3
    hal.stream.write("$HELP <topic> - output help for <topic>" ASCII_EOL);
 80218de:	4b53      	ldr	r3, [pc, #332]	; (8021a2c <system_command_help+0x228>)
 80218e0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218e4:	4865      	ldr	r0, [pc, #404]	; (8021a7c <system_command_help+0x278>)
 80218e6:	4798      	blx	r3
    hal.stream.write("$SPINDLES - enumerate spindles, human readable" ASCII_EOL);
 80218e8:	4b50      	ldr	r3, [pc, #320]	; (8021a2c <system_command_help+0x228>)
 80218ea:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218ee:	4864      	ldr	r0, [pc, #400]	; (8021a80 <system_command_help+0x27c>)
 80218f0:	4798      	blx	r3
    hal.stream.write("$SPINDLESH - enumerate spindles, machine readable" ASCII_EOL);
 80218f2:	4b4e      	ldr	r3, [pc, #312]	; (8021a2c <system_command_help+0x228>)
 80218f4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80218f8:	4862      	ldr	r0, [pc, #392]	; (8021a84 <system_command_help+0x280>)
 80218fa:	4798      	blx	r3
#if ENABLE_RESTORE_NVS_WIPE_ALL
    hal.stream.write("$RST=* - restore/reset all settings" ASCII_EOL);
 80218fc:	4b4b      	ldr	r3, [pc, #300]	; (8021a2c <system_command_help+0x228>)
 80218fe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021902:	4861      	ldr	r0, [pc, #388]	; (8021a88 <system_command_help+0x284>)
 8021904:	4798      	blx	r3
#endif
#if ENABLE_RESTORE_NVS_DEFAULT_SETTINGS
    hal.stream.write("$RST=$ - restore default settings" ASCII_EOL);
 8021906:	4b49      	ldr	r3, [pc, #292]	; (8021a2c <system_command_help+0x228>)
 8021908:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802190c:	485f      	ldr	r0, [pc, #380]	; (8021a8c <system_command_help+0x288>)
 802190e:	4798      	blx	r3
#endif
#if ENABLE_RESTORE_NVS_DRIVER_PARAMETERS
    if(settings_get_details()->next)
 8021910:	f7f7 fa04 	bl	8018d1c <settings_get_details>
 8021914:	4603      	mov	r3, r0
 8021916:	699b      	ldr	r3, [r3, #24]
 8021918:	2b00      	cmp	r3, #0
 802191a:	d004      	beq.n	8021926 <system_command_help+0x122>
        hal.stream.write("$RST=& - restore driver and plugin default settings" ASCII_EOL);
 802191c:	4b43      	ldr	r3, [pc, #268]	; (8021a2c <system_command_help+0x228>)
 802191e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021922:	485b      	ldr	r0, [pc, #364]	; (8021a90 <system_command_help+0x28c>)
 8021924:	4798      	blx	r3
#endif
#if ENABLE_RESTORE_NVS_CLEAR_PARAMETERS
    if(grbl.tool_table.n_tools)
 8021926:	4b5b      	ldr	r3, [pc, #364]	; (8021a94 <system_command_help+0x290>)
 8021928:	699b      	ldr	r3, [r3, #24]
 802192a:	2b00      	cmp	r3, #0
 802192c:	d005      	beq.n	802193a <system_command_help+0x136>
        hal.stream.write("$RST=# - reset offsets and tool data" ASCII_EOL);
 802192e:	4b3f      	ldr	r3, [pc, #252]	; (8021a2c <system_command_help+0x228>)
 8021930:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021934:	4858      	ldr	r0, [pc, #352]	; (8021a98 <system_command_help+0x294>)
 8021936:	4798      	blx	r3
 8021938:	e004      	b.n	8021944 <system_command_help+0x140>
    else
        hal.stream.write("$RST=# - reset offsets" ASCII_EOL);
 802193a:	4b3c      	ldr	r3, [pc, #240]	; (8021a2c <system_command_help+0x228>)
 802193c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021940:	4856      	ldr	r0, [pc, #344]	; (8021a9c <system_command_help+0x298>)
 8021942:	4798      	blx	r3
#endif
    spindle_ptrs_t *spindle = gc_spindle_get();
 8021944:	f7e4 fa50 	bl	8005de8 <gc_spindle_get>
 8021948:	6078      	str	r0, [r7, #4]
    if(spindle->reset_data)
 802194a:	687b      	ldr	r3, [r7, #4]
 802194c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802194e:	2b00      	cmp	r3, #0
 8021950:	d004      	beq.n	802195c <system_command_help+0x158>
        hal.stream.write("$SR - reset spindle encoder data" ASCII_EOL);
 8021952:	4b36      	ldr	r3, [pc, #216]	; (8021a2c <system_command_help+0x228>)
 8021954:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021958:	4851      	ldr	r0, [pc, #324]	; (8021aa0 <system_command_help+0x29c>)
 802195a:	4798      	blx	r3
    if(spindle->get_data)
 802195c:	687b      	ldr	r3, [r7, #4]
 802195e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8021960:	2b00      	cmp	r3, #0
 8021962:	d004      	beq.n	802196e <system_command_help+0x16a>
        hal.stream.write("$SD - output spindle encoder data" ASCII_EOL);
 8021964:	4b31      	ldr	r3, [pc, #196]	; (8021a2c <system_command_help+0x228>)
 8021966:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802196a:	484e      	ldr	r0, [pc, #312]	; (8021aa4 <system_command_help+0x2a0>)
 802196c:	4798      	blx	r3

    hal.stream.write("$TLR - set tool offset reference" ASCII_EOL);
 802196e:	4b2f      	ldr	r3, [pc, #188]	; (8021a2c <system_command_help+0x228>)
 8021970:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021974:	484c      	ldr	r0, [pc, #304]	; (8021aa8 <system_command_help+0x2a4>)
 8021976:	4798      	blx	r3
    hal.stream.write("$TPW - probe tool plate" ASCII_EOL);
 8021978:	4b2c      	ldr	r3, [pc, #176]	; (8021a2c <system_command_help+0x228>)
 802197a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802197e:	484b      	ldr	r0, [pc, #300]	; (8021aac <system_command_help+0x2a8>)
 8021980:	4798      	blx	r3
    hal.stream.write("$EA - enumerate alarms" ASCII_EOL);
 8021982:	4b2a      	ldr	r3, [pc, #168]	; (8021a2c <system_command_help+0x228>)
 8021984:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021988:	4849      	ldr	r0, [pc, #292]	; (8021ab0 <system_command_help+0x2ac>)
 802198a:	4798      	blx	r3
    hal.stream.write("$EAG - enumerate alarms, Grbl formatted" ASCII_EOL);
 802198c:	4b27      	ldr	r3, [pc, #156]	; (8021a2c <system_command_help+0x228>)
 802198e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021992:	4848      	ldr	r0, [pc, #288]	; (8021ab4 <system_command_help+0x2b0>)
 8021994:	4798      	blx	r3
    hal.stream.write("$EE - enumerate status codes" ASCII_EOL);
 8021996:	4b25      	ldr	r3, [pc, #148]	; (8021a2c <system_command_help+0x228>)
 8021998:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802199c:	4846      	ldr	r0, [pc, #280]	; (8021ab8 <system_command_help+0x2b4>)
 802199e:	4798      	blx	r3
    hal.stream.write("$EEG - enumerate status codes, Grbl formatted" ASCII_EOL);
 80219a0:	4b22      	ldr	r3, [pc, #136]	; (8021a2c <system_command_help+0x228>)
 80219a2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219a6:	4845      	ldr	r0, [pc, #276]	; (8021abc <system_command_help+0x2b8>)
 80219a8:	4798      	blx	r3
    hal.stream.write("$ES - enumerate settings" ASCII_EOL);
 80219aa:	4b20      	ldr	r3, [pc, #128]	; (8021a2c <system_command_help+0x228>)
 80219ac:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219b0:	4843      	ldr	r0, [pc, #268]	; (8021ac0 <system_command_help+0x2bc>)
 80219b2:	4798      	blx	r3
    hal.stream.write("$ESG - enumerate settings, Grbl formatted" ASCII_EOL);
 80219b4:	4b1d      	ldr	r3, [pc, #116]	; (8021a2c <system_command_help+0x228>)
 80219b6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219ba:	4842      	ldr	r0, [pc, #264]	; (8021ac4 <system_command_help+0x2c0>)
 80219bc:	4798      	blx	r3
    hal.stream.write("$ESH- enumerate settings, grblHAL formatted" ASCII_EOL);
 80219be:	4b1b      	ldr	r3, [pc, #108]	; (8021a2c <system_command_help+0x228>)
 80219c0:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219c4:	4840      	ldr	r0, [pc, #256]	; (8021ac8 <system_command_help+0x2c4>)
 80219c6:	4798      	blx	r3
    hal.stream.write("$E* - enumerate alarms, status codes and settings" ASCII_EOL);
 80219c8:	4b18      	ldr	r3, [pc, #96]	; (8021a2c <system_command_help+0x228>)
 80219ca:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219ce:	483f      	ldr	r0, [pc, #252]	; (8021acc <system_command_help+0x2c8>)
 80219d0:	4798      	blx	r3
    if(hal.enumerate_pins)
 80219d2:	4b16      	ldr	r3, [pc, #88]	; (8021a2c <system_command_help+0x228>)
 80219d4:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
 80219d8:	2b00      	cmp	r3, #0
 80219da:	d004      	beq.n	80219e6 <system_command_help+0x1e2>
        hal.stream.write("$PINS - enumerate pin bindings" ASCII_EOL);
 80219dc:	4b13      	ldr	r3, [pc, #76]	; (8021a2c <system_command_help+0x228>)
 80219de:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219e2:	483b      	ldr	r0, [pc, #236]	; (8021ad0 <system_command_help+0x2cc>)
 80219e4:	4798      	blx	r3
    hal.stream.write("$LEV - output last control signal events" ASCII_EOL);
 80219e6:	4b11      	ldr	r3, [pc, #68]	; (8021a2c <system_command_help+0x228>)
 80219e8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219ec:	4839      	ldr	r0, [pc, #228]	; (8021ad4 <system_command_help+0x2d0>)
 80219ee:	4798      	blx	r3
    hal.stream.write("$LIM - output current limit pins state" ASCII_EOL);
 80219f0:	4b0e      	ldr	r3, [pc, #56]	; (8021a2c <system_command_help+0x228>)
 80219f2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80219f6:	4838      	ldr	r0, [pc, #224]	; (8021ad8 <system_command_help+0x2d4>)
 80219f8:	4798      	blx	r3
    if(hal.rtc.get_datetime) {
 80219fa:	4b0c      	ldr	r3, [pc, #48]	; (8021a2c <system_command_help+0x228>)
 80219fc:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8021a00:	2b00      	cmp	r3, #0
 8021a02:	d009      	beq.n	8021a18 <system_command_help+0x214>
        hal.stream.write("$RTC - output current time" ASCII_EOL);
 8021a04:	4b09      	ldr	r3, [pc, #36]	; (8021a2c <system_command_help+0x228>)
 8021a06:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021a0a:	4834      	ldr	r0, [pc, #208]	; (8021adc <system_command_help+0x2d8>)
 8021a0c:	4798      	blx	r3
        hal.stream.write("$RTC=<ISO8601 datetime> - set current time" ASCII_EOL);
 8021a0e:	4b07      	ldr	r3, [pc, #28]	; (8021a2c <system_command_help+0x228>)
 8021a10:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021a14:	4832      	ldr	r0, [pc, #200]	; (8021ae0 <system_command_help+0x2dc>)
 8021a16:	4798      	blx	r3
    }
#ifndef NO_SETTINGS_DESCRIPTIONS
    hal.stream.write("$SED=<n> - output settings description for setting <n>" ASCII_EOL);
 8021a18:	4b04      	ldr	r3, [pc, #16]	; (8021a2c <system_command_help+0x228>)
 8021a1a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8021a1e:	4831      	ldr	r0, [pc, #196]	; (8021ae4 <system_command_help+0x2e0>)
 8021a20:	4798      	blx	r3
#endif
}
 8021a22:	bf00      	nop
 8021a24:	3708      	adds	r7, #8
 8021a26:	46bd      	mov	sp, r7
 8021a28:	bd80      	pop	{r7, pc}
 8021a2a:	bf00      	nop
 8021a2c:	20000ed0 	.word	0x20000ed0
 8021a30:	0802fca4 	.word	0x0802fca4
 8021a34:	0802fcc8 	.word	0x0802fcc8
 8021a38:	0802fcf4 	.word	0x0802fcf4
 8021a3c:	0802fd18 	.word	0x0802fd18
 8021a40:	0802fd3c 	.word	0x0802fd3c
 8021a44:	0802fd6c 	.word	0x0802fd6c
 8021a48:	0802fd90 	.word	0x0802fd90
 8021a4c:	0802fdb4 	.word	0x0802fdb4
 8021a50:	0802fde8 	.word	0x0802fde8
 8021a54:	0802fe28 	.word	0x0802fe28
 8021a58:	0802fe54 	.word	0x0802fe54
 8021a5c:	0802fe70 	.word	0x0802fe70
 8021a60:	2000147c 	.word	0x2000147c
 8021a64:	0802fe8c 	.word	0x0802fe8c
 8021a68:	0802fea8 	.word	0x0802fea8
 8021a6c:	0802fecc 	.word	0x0802fecc
 8021a70:	0802fef4 	.word	0x0802fef4
 8021a74:	0802ff0c 	.word	0x0802ff0c
 8021a78:	0802ff28 	.word	0x0802ff28
 8021a7c:	0802ff48 	.word	0x0802ff48
 8021a80:	0802ff74 	.word	0x0802ff74
 8021a84:	0802ffa8 	.word	0x0802ffa8
 8021a88:	0802ffdc 	.word	0x0802ffdc
 8021a8c:	08030004 	.word	0x08030004
 8021a90:	08030028 	.word	0x08030028
 8021a94:	20000dd4 	.word	0x20000dd4
 8021a98:	08030060 	.word	0x08030060
 8021a9c:	08030088 	.word	0x08030088
 8021aa0:	080300a4 	.word	0x080300a4
 8021aa4:	080300c8 	.word	0x080300c8
 8021aa8:	080300ec 	.word	0x080300ec
 8021aac:	08030110 	.word	0x08030110
 8021ab0:	0803012c 	.word	0x0803012c
 8021ab4:	08030148 	.word	0x08030148
 8021ab8:	08030174 	.word	0x08030174
 8021abc:	08030194 	.word	0x08030194
 8021ac0:	080301c4 	.word	0x080301c4
 8021ac4:	080301e0 	.word	0x080301e0
 8021ac8:	0803020c 	.word	0x0803020c
 8021acc:	0803023c 	.word	0x0803023c
 8021ad0:	08030270 	.word	0x08030270
 8021ad4:	08030294 	.word	0x08030294
 8021ad8:	080302c0 	.word	0x080302c0
 8021adc:	080302ec 	.word	0x080302ec
 8021ae0:	0803030c 	.word	0x0803030c
 8021ae4:	0803033c 	.word	0x0803033c

08021ae8 <system_execute_line>:

\param line pointer to the command string.
\returns \a status_code_t enum value; #Status_OK if successfully handled, another relevant status code if not.
*/
status_code_t system_execute_line (char *line)
{
 8021ae8:	b590      	push	{r4, r7, lr}
 8021aea:	b08f      	sub	sp, #60	; 0x3c
 8021aec:	af00      	add	r7, sp, #0
 8021aee:	6078      	str	r0, [r7, #4]
    if(line[1] == '\0') {
 8021af0:	687b      	ldr	r3, [r7, #4]
 8021af2:	3301      	adds	r3, #1
 8021af4:	781b      	ldrb	r3, [r3, #0]
 8021af6:	2b00      	cmp	r3, #0
 8021af8:	d104      	bne.n	8021b04 <system_execute_line+0x1c>
        grbl.report.help_message();
 8021afa:	4ba6      	ldr	r3, [pc, #664]	; (8021d94 <system_execute_line+0x2ac>)
 8021afc:	685b      	ldr	r3, [r3, #4]
 8021afe:	4798      	blx	r3
        return Status_OK;
 8021b00:	2300      	movs	r3, #0
 8021b02:	e162      	b.n	8021dca <system_execute_line+0x2e2>
    }

    sys_commands_t base = {
 8021b04:	232c      	movs	r3, #44	; 0x2c
 8021b06:	753b      	strb	r3, [r7, #20]
 8021b08:	4ba3      	ldr	r3, [pc, #652]	; (8021d98 <system_execute_line+0x2b0>)
 8021b0a:	61bb      	str	r3, [r7, #24]
        .n_commands = sizeof(sys_commands) / sizeof(sys_command_t),
        .commands = sys_commands,
        .on_get_commands = grbl.on_get_commands
 8021b0c:	4ba1      	ldr	r3, [pc, #644]	; (8021d94 <system_execute_line+0x2ac>)
 8021b0e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    sys_commands_t base = {
 8021b12:	61fb      	str	r3, [r7, #28]
    };

    status_code_t retval = Status_Unhandled;
 8021b14:	2354      	movs	r3, #84	; 0x54
 8021b16:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    char c, *s1, *s2;

    s1 = s2 = ++line;
 8021b1a:	687b      	ldr	r3, [r7, #4]
 8021b1c:	3301      	adds	r3, #1
 8021b1e:	607b      	str	r3, [r7, #4]
 8021b20:	687b      	ldr	r3, [r7, #4]
 8021b22:	62fb      	str	r3, [r7, #44]	; 0x2c
 8021b24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021b26:	633b      	str	r3, [r7, #48]	; 0x30

    c = *s1;
 8021b28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021b2a:	781b      	ldrb	r3, [r3, #0]
 8021b2c:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    while(c && c != '=') {
 8021b30:	e01e      	b.n	8021b70 <system_execute_line+0x88>
        if(c != ' ')
 8021b32:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b36:	2b20      	cmp	r3, #32
 8021b38:	d013      	beq.n	8021b62 <system_execute_line+0x7a>
            *s2++ = CAPS(c);
 8021b3a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b3e:	2b60      	cmp	r3, #96	; 0x60
 8021b40:	d909      	bls.n	8021b56 <system_execute_line+0x6e>
 8021b42:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b46:	2b7a      	cmp	r3, #122	; 0x7a
 8021b48:	d805      	bhi.n	8021b56 <system_execute_line+0x6e>
 8021b4a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b4e:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 8021b52:	b2da      	uxtb	r2, r3
 8021b54:	e001      	b.n	8021b5a <system_execute_line+0x72>
 8021b56:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8021b5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021b5c:	1c59      	adds	r1, r3, #1
 8021b5e:	62f9      	str	r1, [r7, #44]	; 0x2c
 8021b60:	701a      	strb	r2, [r3, #0]
        c = *++s1;
 8021b62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021b64:	3301      	adds	r3, #1
 8021b66:	633b      	str	r3, [r7, #48]	; 0x30
 8021b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021b6a:	781b      	ldrb	r3, [r3, #0]
 8021b6c:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    while(c && c != '=') {
 8021b70:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b74:	2b00      	cmp	r3, #0
 8021b76:	d00a      	beq.n	8021b8e <system_execute_line+0xa6>
 8021b78:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b7c:	2b3d      	cmp	r3, #61	; 0x3d
 8021b7e:	d1d8      	bne.n	8021b32 <system_execute_line+0x4a>
    }

    while((c = *s1++))
 8021b80:	e005      	b.n	8021b8e <system_execute_line+0xa6>
        *s2++ = c;
 8021b82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021b84:	1c5a      	adds	r2, r3, #1
 8021b86:	62fa      	str	r2, [r7, #44]	; 0x2c
 8021b88:	f897 2036 	ldrb.w	r2, [r7, #54]	; 0x36
 8021b8c:	701a      	strb	r2, [r3, #0]
    while((c = *s1++))
 8021b8e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021b90:	1c5a      	adds	r2, r3, #1
 8021b92:	633a      	str	r2, [r7, #48]	; 0x30
 8021b94:	781b      	ldrb	r3, [r3, #0]
 8021b96:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
 8021b9a:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 8021b9e:	2b00      	cmp	r3, #0
 8021ba0:	d1ef      	bne.n	8021b82 <system_execute_line+0x9a>

    *s2 = '\0';
 8021ba2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021ba4:	2200      	movs	r2, #0
 8021ba6:	701a      	strb	r2, [r3, #0]

    if(!strncmp(line, "HELP", 4))
 8021ba8:	2204      	movs	r2, #4
 8021baa:	497c      	ldr	r1, [pc, #496]	; (8021d9c <system_execute_line+0x2b4>)
 8021bac:	6878      	ldr	r0, [r7, #4]
 8021bae:	f002 f856 	bl	8023c5e <strncmp>
 8021bb2:	4603      	mov	r3, r0
 8021bb4:	2b00      	cmp	r3, #0
 8021bb6:	d106      	bne.n	8021bc6 <system_execute_line+0xde>
        return report_help(&line[4]);
 8021bb8:	687b      	ldr	r3, [r7, #4]
 8021bba:	3304      	adds	r3, #4
 8021bbc:	4618      	mov	r0, r3
 8021bbe:	f7f2 fdb1 	bl	8014724 <report_help>
 8021bc2:	4603      	mov	r3, r0
 8021bc4:	e101      	b.n	8021dca <system_execute_line+0x2e2>

    char *args = strchr(line, '=');
 8021bc6:	213d      	movs	r1, #61	; 0x3d
 8021bc8:	6878      	ldr	r0, [r7, #4]
 8021bca:	f002 f83b 	bl	8023c44 <strchr>
 8021bce:	62b8      	str	r0, [r7, #40]	; 0x28

    if(args)
 8021bd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021bd2:	2b00      	cmp	r3, #0
 8021bd4:	d004      	beq.n	8021be0 <system_execute_line+0xf8>
        *args++ = '\0';
 8021bd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021bd8:	1c5a      	adds	r2, r3, #1
 8021bda:	62ba      	str	r2, [r7, #40]	; 0x28
 8021bdc:	2200      	movs	r2, #0
 8021bde:	701a      	strb	r2, [r3, #0]

    uint_fast8_t idx;
    sys_commands_t *cmd = &base;
 8021be0:	f107 0314 	add.w	r3, r7, #20
 8021be4:	623b      	str	r3, [r7, #32]
    do {
        for(idx = 0; idx < cmd->n_commands; idx++) {
 8021be6:	2300      	movs	r3, #0
 8021be8:	627b      	str	r3, [r7, #36]	; 0x24
 8021bea:	e04f      	b.n	8021c8c <system_execute_line+0x1a4>
            if(!strcmp(line, cmd->commands[idx].command)) {
 8021bec:	6a3b      	ldr	r3, [r7, #32]
 8021bee:	6859      	ldr	r1, [r3, #4]
 8021bf0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021bf2:	4613      	mov	r3, r2
 8021bf4:	005b      	lsls	r3, r3, #1
 8021bf6:	4413      	add	r3, r2
 8021bf8:	009b      	lsls	r3, r3, #2
 8021bfa:	440b      	add	r3, r1
 8021bfc:	681b      	ldr	r3, [r3, #0]
 8021bfe:	4619      	mov	r1, r3
 8021c00:	6878      	ldr	r0, [r7, #4]
 8021c02:	f7de fb11 	bl	8000228 <strcmp>
 8021c06:	4603      	mov	r3, r0
 8021c08:	2b00      	cmp	r3, #0
 8021c0a:	d13c      	bne.n	8021c86 <system_execute_line+0x19e>
                if(sys.blocking_event && !cmd->commands[idx].flags.allow_blocking) {
 8021c0c:	4b64      	ldr	r3, [pc, #400]	; (8021da0 <system_execute_line+0x2b8>)
 8021c0e:	795b      	ldrb	r3, [r3, #5]
 8021c10:	2b00      	cmp	r3, #0
 8021c12:	d011      	beq.n	8021c38 <system_execute_line+0x150>
 8021c14:	6a3b      	ldr	r3, [r7, #32]
 8021c16:	6859      	ldr	r1, [r3, #4]
 8021c18:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021c1a:	4613      	mov	r3, r2
 8021c1c:	005b      	lsls	r3, r3, #1
 8021c1e:	4413      	add	r3, r2
 8021c20:	009b      	lsls	r3, r3, #2
 8021c22:	440b      	add	r3, r1
 8021c24:	7a1b      	ldrb	r3, [r3, #8]
 8021c26:	f003 0302 	and.w	r3, r3, #2
 8021c2a:	b2db      	uxtb	r3, r3
 8021c2c:	2b00      	cmp	r3, #0
 8021c2e:	d103      	bne.n	8021c38 <system_execute_line+0x150>
                    retval = Status_NotAllowedCriticalEvent;
 8021c30:	234f      	movs	r3, #79	; 0x4f
 8021c32:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
                    break;
 8021c36:	e031      	b.n	8021c9c <system_execute_line+0x1b4>
                } else if(!cmd->commands[idx].flags.noargs || args == NULL) {
 8021c38:	6a3b      	ldr	r3, [r7, #32]
 8021c3a:	6859      	ldr	r1, [r3, #4]
 8021c3c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021c3e:	4613      	mov	r3, r2
 8021c40:	005b      	lsls	r3, r3, #1
 8021c42:	4413      	add	r3, r2
 8021c44:	009b      	lsls	r3, r3, #2
 8021c46:	440b      	add	r3, r1
 8021c48:	7a1b      	ldrb	r3, [r3, #8]
 8021c4a:	f003 0301 	and.w	r3, r3, #1
 8021c4e:	b2db      	uxtb	r3, r3
 8021c50:	2b00      	cmp	r3, #0
 8021c52:	d002      	beq.n	8021c5a <system_execute_line+0x172>
 8021c54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021c56:	2b00      	cmp	r3, #0
 8021c58:	d115      	bne.n	8021c86 <system_execute_line+0x19e>
                    if((retval = cmd->commands[idx].execute(state_get(), args)) != Status_Unhandled)
 8021c5a:	6a3b      	ldr	r3, [r7, #32]
 8021c5c:	6859      	ldr	r1, [r3, #4]
 8021c5e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8021c60:	4613      	mov	r3, r2
 8021c62:	005b      	lsls	r3, r3, #1
 8021c64:	4413      	add	r3, r2
 8021c66:	009b      	lsls	r3, r3, #2
 8021c68:	440b      	add	r3, r1
 8021c6a:	685c      	ldr	r4, [r3, #4]
 8021c6c:	f7fb fe28 	bl	801d8c0 <state_get>
 8021c70:	4603      	mov	r3, r0
 8021c72:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8021c74:	4618      	mov	r0, r3
 8021c76:	47a0      	blx	r4
 8021c78:	4603      	mov	r3, r0
 8021c7a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8021c7e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8021c82:	2b54      	cmp	r3, #84	; 0x54
 8021c84:	d109      	bne.n	8021c9a <system_execute_line+0x1b2>
        for(idx = 0; idx < cmd->n_commands; idx++) {
 8021c86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021c88:	3301      	adds	r3, #1
 8021c8a:	627b      	str	r3, [r7, #36]	; 0x24
 8021c8c:	6a3b      	ldr	r3, [r7, #32]
 8021c8e:	781b      	ldrb	r3, [r3, #0]
 8021c90:	461a      	mov	r2, r3
 8021c92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021c94:	4293      	cmp	r3, r2
 8021c96:	d3a9      	bcc.n	8021bec <system_execute_line+0x104>
 8021c98:	e000      	b.n	8021c9c <system_execute_line+0x1b4>
                        break;
 8021c9a:	bf00      	nop
                }
            }
        }
        cmd = retval == Status_Unhandled && cmd->on_get_commands ? cmd->on_get_commands() : NULL;
 8021c9c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8021ca0:	2b54      	cmp	r3, #84	; 0x54
 8021ca2:	d108      	bne.n	8021cb6 <system_execute_line+0x1ce>
 8021ca4:	6a3b      	ldr	r3, [r7, #32]
 8021ca6:	689b      	ldr	r3, [r3, #8]
 8021ca8:	2b00      	cmp	r3, #0
 8021caa:	d004      	beq.n	8021cb6 <system_execute_line+0x1ce>
 8021cac:	6a3b      	ldr	r3, [r7, #32]
 8021cae:	689b      	ldr	r3, [r3, #8]
 8021cb0:	4798      	blx	r3
 8021cb2:	4603      	mov	r3, r0
 8021cb4:	e000      	b.n	8021cb8 <system_execute_line+0x1d0>
 8021cb6:	2300      	movs	r3, #0
 8021cb8:	623b      	str	r3, [r7, #32]
    } while(cmd);
 8021cba:	6a3b      	ldr	r3, [r7, #32]
 8021cbc:	2b00      	cmp	r3, #0
 8021cbe:	d192      	bne.n	8021be6 <system_execute_line+0xfe>

    // Let user code have a peek at system commands before check for global setting
    if(retval == Status_Unhandled && grbl.on_unknown_sys_command) {
 8021cc0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8021cc4:	2b54      	cmp	r3, #84	; 0x54
 8021cc6:	d121      	bne.n	8021d0c <system_execute_line+0x224>
 8021cc8:	4b32      	ldr	r3, [pc, #200]	; (8021d94 <system_execute_line+0x2ac>)
 8021cca:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8021cce:	2b00      	cmp	r3, #0
 8021cd0:	d01c      	beq.n	8021d0c <system_execute_line+0x224>
        if(args)
 8021cd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021cd4:	2b00      	cmp	r3, #0
 8021cd6:	d005      	beq.n	8021ce4 <system_execute_line+0x1fc>
            *(--args) = '=';
 8021cd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021cda:	3b01      	subs	r3, #1
 8021cdc:	62bb      	str	r3, [r7, #40]	; 0x28
 8021cde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021ce0:	223d      	movs	r2, #61	; 0x3d
 8021ce2:	701a      	strb	r2, [r3, #0]

        retval = grbl.on_unknown_sys_command(state_get(), line);
 8021ce4:	4b2b      	ldr	r3, [pc, #172]	; (8021d94 <system_execute_line+0x2ac>)
 8021ce6:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
 8021cea:	f7fb fde9 	bl	801d8c0 <state_get>
 8021cee:	4603      	mov	r3, r0
 8021cf0:	6879      	ldr	r1, [r7, #4]
 8021cf2:	4618      	mov	r0, r3
 8021cf4:	47a0      	blx	r4
 8021cf6:	4603      	mov	r3, r0
 8021cf8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

        if(args)
 8021cfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021cfe:	2b00      	cmp	r3, #0
 8021d00:	d004      	beq.n	8021d0c <system_execute_line+0x224>
            *args++ = '\0';
 8021d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021d04:	1c5a      	adds	r2, r3, #1
 8021d06:	62ba      	str	r2, [r7, #40]	; 0x28
 8021d08:	2200      	movs	r2, #0
 8021d0a:	701a      	strb	r2, [r3, #0]
    }

    if (retval == Status_Unhandled) {
 8021d0c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8021d10:	2b54      	cmp	r3, #84	; 0x54
 8021d12:	d158      	bne.n	8021dc6 <system_execute_line+0x2de>
        // Check for global setting, store if so
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8021d14:	f7fb fdd4 	bl	801d8c0 <state_get>
 8021d18:	4603      	mov	r3, r0
 8021d1a:	2b00      	cmp	r3, #0
 8021d1c:	d007      	beq.n	8021d2e <system_execute_line+0x246>
 8021d1e:	f7fb fdcf 	bl	801d8c0 <state_get>
 8021d22:	4602      	mov	r2, r0
 8021d24:	f240 1303 	movw	r3, #259	; 0x103
 8021d28:	4013      	ands	r3, r2
 8021d2a:	2b00      	cmp	r3, #0
 8021d2c:	d048      	beq.n	8021dc0 <system_execute_line+0x2d8>
            uint_fast8_t counter = 0;
 8021d2e:	2300      	movs	r3, #0
 8021d30:	613b      	str	r3, [r7, #16]
            float parameter;
            if(!read_float(line, &counter, &parameter))
 8021d32:	f107 020c 	add.w	r2, r7, #12
 8021d36:	f107 0310 	add.w	r3, r7, #16
 8021d3a:	4619      	mov	r1, r3
 8021d3c:	6878      	ldr	r0, [r7, #4]
 8021d3e:	f7ee fc39 	bl	80105b4 <read_float>
 8021d42:	4603      	mov	r3, r0
 8021d44:	f083 0301 	eor.w	r3, r3, #1
 8021d48:	b2db      	uxtb	r3, r3
 8021d4a:	2b00      	cmp	r3, #0
 8021d4c:	d003      	beq.n	8021d56 <system_execute_line+0x26e>
                retval = Status_BadNumberFormat;
 8021d4e:	2302      	movs	r3, #2
 8021d50:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8021d54:	e037      	b.n	8021dc6 <system_execute_line+0x2de>
            else if(!isintf(parameter))
 8021d56:	68fb      	ldr	r3, [r7, #12]
 8021d58:	4618      	mov	r0, r3
 8021d5a:	f7ee fcf1 	bl	8010740 <isintf>
 8021d5e:	4603      	mov	r3, r0
 8021d60:	f083 0301 	eor.w	r3, r3, #1
 8021d64:	b2db      	uxtb	r3, r3
 8021d66:	2b00      	cmp	r3, #0
 8021d68:	d003      	beq.n	8021d72 <system_execute_line+0x28a>
                retval = Status_InvalidStatement;
 8021d6a:	2303      	movs	r3, #3
 8021d6c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8021d70:	e029      	b.n	8021dc6 <system_execute_line+0x2de>
            else if(args)
 8021d72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8021d74:	2b00      	cmp	r3, #0
 8021d76:	d015      	beq.n	8021da4 <system_execute_line+0x2bc>
                retval = settings_store_setting((setting_id_t)parameter, args);
 8021d78:	68fb      	ldr	r3, [r7, #12]
 8021d7a:	4618      	mov	r0, r3
 8021d7c:	f7df fa1c 	bl	80011b8 <__aeabi_f2uiz>
 8021d80:	4603      	mov	r3, r0
 8021d82:	b29b      	uxth	r3, r3
 8021d84:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8021d86:	4618      	mov	r0, r3
 8021d88:	f7f9 fe7a 	bl	801ba80 <settings_store_setting>
 8021d8c:	4603      	mov	r3, r0
 8021d8e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8021d92:	e018      	b.n	8021dc6 <system_execute_line+0x2de>
 8021d94:	20000dd4 	.word	0x20000dd4
 8021d98:	08032bbc 	.word	0x08032bbc
 8021d9c:	0802fc20 	.word	0x0802fc20
 8021da0:	20000d3c 	.word	0x20000d3c
            else
                retval = report_grbl_setting((setting_id_t)parameter, NULL);
 8021da4:	68fb      	ldr	r3, [r7, #12]
 8021da6:	4618      	mov	r0, r3
 8021da8:	f7df fa06 	bl	80011b8 <__aeabi_f2uiz>
 8021dac:	4603      	mov	r3, r0
 8021dae:	b29b      	uxth	r3, r3
 8021db0:	2100      	movs	r1, #0
 8021db2:	4618      	mov	r0, r3
 8021db4:	f7f2 fdb2 	bl	801491c <report_grbl_setting>
 8021db8:	4603      	mov	r3, r0
 8021dba:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(state_get() == STATE_IDLE || (state_get() & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8021dbe:	e002      	b.n	8021dc6 <system_execute_line+0x2de>
        } else
            retval = Status_IdleError;
 8021dc0:	2308      	movs	r3, #8
 8021dc2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    }

    return retval;
 8021dc6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 8021dca:	4618      	mov	r0, r3
 8021dcc:	373c      	adds	r7, #60	; 0x3c
 8021dce:	46bd      	mov	sp, r7
 8021dd0:	bd90      	pop	{r4, r7, pc}
 8021dd2:	bf00      	nop

08021dd4 <system_flag_wco_change>:
If configured waits for the planner buffer to empty then fires the
grbl.on_wco_changed event and sets the #Report_WCO flag to add
the WCO report element to the next status report.
 */
void system_flag_wco_change (void)
{
 8021dd4:	b580      	push	{r7, lr}
 8021dd6:	af00      	add	r7, sp, #0
    if(!settings.status_report.sync_on_wco_change)
 8021dd8:	4b0b      	ldr	r3, [pc, #44]	; (8021e08 <system_flag_wco_change+0x34>)
 8021dda:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8021dde:	f003 0301 	and.w	r3, r3, #1
 8021de2:	b2db      	uxtb	r3, r3
 8021de4:	2b00      	cmp	r3, #0
 8021de6:	d101      	bne.n	8021dec <system_flag_wco_change+0x18>
        protocol_buffer_synchronize();
 8021de8:	f7f0 ff8a 	bl	8012d00 <protocol_buffer_synchronize>

    if(grbl.on_wco_changed)
 8021dec:	4b07      	ldr	r3, [pc, #28]	; (8021e0c <system_flag_wco_change+0x38>)
 8021dee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8021df0:	2b00      	cmp	r3, #0
 8021df2:	d002      	beq.n	8021dfa <system_flag_wco_change+0x26>
        grbl.on_wco_changed();
 8021df4:	4b05      	ldr	r3, [pc, #20]	; (8021e0c <system_flag_wco_change+0x38>)
 8021df6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8021df8:	4798      	blx	r3

    system_add_rt_report(Report_WCO);
 8021dfa:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021dfe:	f000 f8cd 	bl	8021f9c <system_add_rt_report>
}
 8021e02:	bf00      	nop
 8021e04:	bd80      	pop	{r7, pc}
 8021e06:	bf00      	nop
 8021e08:	2000147c 	.word	0x2000147c
 8021e0c:	20000dd4 	.word	0x20000dd4

08021e10 <system_convert_array_steps_to_mpos>:
          this function serves as a central place to compute the transformation.
\param position pointer to the target float array for the machine position.
\param steps pointer to the source step count array to transform.
 */
void system_convert_array_steps_to_mpos (float *position, int32_t *steps)
{
 8021e10:	b580      	push	{r7, lr}
 8021e12:	b082      	sub	sp, #8
 8021e14:	af00      	add	r7, sp, #0
 8021e16:	6078      	str	r0, [r7, #4]
 8021e18:	6039      	str	r1, [r7, #0]
#ifdef KINEMATICS_API
    kinematics.transform_steps_to_cartesian(position, steps);
 8021e1a:	4b04      	ldr	r3, [pc, #16]	; (8021e2c <system_convert_array_steps_to_mpos+0x1c>)
 8021e1c:	681b      	ldr	r3, [r3, #0]
 8021e1e:	6839      	ldr	r1, [r7, #0]
 8021e20:	6878      	ldr	r0, [r7, #4]
 8021e22:	4798      	blx	r3
    do {
        idx--;
        position[idx] = steps[idx] / settings.axis[idx].steps_per_mm;
    } while(idx);
#endif
}
 8021e24:	bf00      	nop
 8021e26:	3708      	adds	r7, #8
 8021e28:	46bd      	mov	sp, r7
 8021e2a:	bd80      	pop	{r7, pc}
 8021e2c:	20001088 	.word	0x20001088

08021e30 <system_xy_at_fixture>:
\param id a \a coord_system_id_t, typically #CoordinateSystem_G59_3.
\param tolerance as the allowed radius the current position has to be within.
\returns \a false if tolerance is 0 or position is outside the allowed radius, otherwise \a true.
*/
bool system_xy_at_fixture (coord_system_id_t id, float tolerance)
{
 8021e30:	b590      	push	{r4, r7, lr}
 8021e32:	b08b      	sub	sp, #44	; 0x2c
 8021e34:	af00      	add	r7, sp, #0
 8021e36:	4603      	mov	r3, r0
 8021e38:	6039      	str	r1, [r7, #0]
 8021e3a:	71fb      	strb	r3, [r7, #7]
    bool ok = false;
 8021e3c:	2300      	movs	r3, #0
 8021e3e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    coord_data_t target, position;

    if(tolerance > 0.0f && settings_read_coord_data(id, &target.values)) {
 8021e42:	f04f 0100 	mov.w	r1, #0
 8021e46:	6838      	ldr	r0, [r7, #0]
 8021e48:	f7df f970 	bl	800112c <__aeabi_fcmpgt>
 8021e4c:	4603      	mov	r3, r0
 8021e4e:	2b00      	cmp	r3, #0
 8021e50:	d030      	beq.n	8021eb4 <system_xy_at_fixture+0x84>
 8021e52:	f107 0218 	add.w	r2, r7, #24
 8021e56:	79fb      	ldrb	r3, [r7, #7]
 8021e58:	4611      	mov	r1, r2
 8021e5a:	4618      	mov	r0, r3
 8021e5c:	f7f8 fedc 	bl	801ac18 <settings_read_coord_data>
 8021e60:	4603      	mov	r3, r0
 8021e62:	2b00      	cmp	r3, #0
 8021e64:	d026      	beq.n	8021eb4 <system_xy_at_fixture+0x84>
        system_convert_array_steps_to_mpos(position.values, sys.position);
 8021e66:	f107 030c 	add.w	r3, r7, #12
 8021e6a:	4915      	ldr	r1, [pc, #84]	; (8021ec0 <system_xy_at_fixture+0x90>)
 8021e6c:	4618      	mov	r0, r3
 8021e6e:	f7ff ffcf 	bl	8021e10 <system_convert_array_steps_to_mpos>
        ok = hypot_f(position.x - target.x, position.y - target.y) <= tolerance;
 8021e72:	68fb      	ldr	r3, [r7, #12]
 8021e74:	69ba      	ldr	r2, [r7, #24]
 8021e76:	4611      	mov	r1, r2
 8021e78:	4618      	mov	r0, r3
 8021e7a:	f7de fe91 	bl	8000ba0 <__aeabi_fsub>
 8021e7e:	4603      	mov	r3, r0
 8021e80:	461c      	mov	r4, r3
 8021e82:	693b      	ldr	r3, [r7, #16]
 8021e84:	69fa      	ldr	r2, [r7, #28]
 8021e86:	4611      	mov	r1, r2
 8021e88:	4618      	mov	r0, r3
 8021e8a:	f7de fe89 	bl	8000ba0 <__aeabi_fsub>
 8021e8e:	4603      	mov	r3, r0
 8021e90:	4619      	mov	r1, r3
 8021e92:	4620      	mov	r0, r4
 8021e94:	f7fe fd9e 	bl	80209d4 <hypot_f>
 8021e98:	4603      	mov	r3, r0
 8021e9a:	2201      	movs	r2, #1
 8021e9c:	4614      	mov	r4, r2
 8021e9e:	4619      	mov	r1, r3
 8021ea0:	6838      	ldr	r0, [r7, #0]
 8021ea2:	f7df f939 	bl	8001118 <__aeabi_fcmpge>
 8021ea6:	4603      	mov	r3, r0
 8021ea8:	2b00      	cmp	r3, #0
 8021eaa:	d101      	bne.n	8021eb0 <system_xy_at_fixture+0x80>
 8021eac:	2300      	movs	r3, #0
 8021eae:	461c      	mov	r4, r3
 8021eb0:	f887 4027 	strb.w	r4, [r7, #39]	; 0x27
    }

    return ok;
 8021eb4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8021eb8:	4618      	mov	r0, r3
 8021eba:	372c      	adds	r7, #44	; 0x2c
 8021ebc:	46bd      	mov	sp, r7
 8021ebe:	bd90      	pop	{r4, r7, pc}
 8021ec0:	20000dc4 	.word	0x20000dc4

08021ec4 <system_raise_alarm>:

/*! \brief Raise and report a system alarm.
\param a #alarm_code_t enum representing the alarm code.
 */
void system_raise_alarm (alarm_code_t alarm)
{
 8021ec4:	b580      	push	{r7, lr}
 8021ec6:	b082      	sub	sp, #8
 8021ec8:	af00      	add	r7, sp, #0
 8021eca:	4603      	mov	r3, r0
 8021ecc:	71fb      	strb	r3, [r7, #7]
    if(state_get() == STATE_HOMING && !(sys.rt_exec_state & EXEC_RESET))
 8021ece:	f7fb fcf7 	bl	801d8c0 <state_get>
 8021ed2:	4603      	mov	r3, r0
 8021ed4:	2b04      	cmp	r3, #4
 8021ed6:	d10c      	bne.n	8021ef2 <system_raise_alarm+0x2e>
 8021ed8:	4b27      	ldr	r3, [pc, #156]	; (8021f78 <system_raise_alarm+0xb4>)
 8021eda:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8021edc:	f003 0320 	and.w	r3, r3, #32
 8021ee0:	2b00      	cmp	r3, #0
 8021ee2:	d106      	bne.n	8021ef2 <system_raise_alarm+0x2e>
        system_set_exec_alarm(alarm);
 8021ee4:	4b25      	ldr	r3, [pc, #148]	; (8021f7c <system_raise_alarm+0xb8>)
 8021ee6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8021ee8:	79fa      	ldrb	r2, [r7, #7]
 8021eea:	4611      	mov	r1, r2
 8021eec:	4824      	ldr	r0, [pc, #144]	; (8021f80 <system_raise_alarm+0xbc>)
 8021eee:	4798      	blx	r3
                                sys.alarm == Alarm_MotorFault;
        state_set(alarm == Alarm_EStop ? STATE_ESTOP : STATE_ALARM);
        if(sys.driver_started || sys.alarm == Alarm_SelftestFailed)
            grbl.report.alarm_message(alarm);
    }
}
 8021ef0:	e03e      	b.n	8021f70 <system_raise_alarm+0xac>
    else if(sys.alarm != alarm) {
 8021ef2:	4b21      	ldr	r3, [pc, #132]	; (8021f78 <system_raise_alarm+0xb4>)
 8021ef4:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8021ef8:	79fa      	ldrb	r2, [r7, #7]
 8021efa:	429a      	cmp	r2, r3
 8021efc:	d038      	beq.n	8021f70 <system_raise_alarm+0xac>
        sys.alarm = alarm;
 8021efe:	4a1e      	ldr	r2, [pc, #120]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f00:	79fb      	ldrb	r3, [r7, #7]
 8021f02:	f882 307c 	strb.w	r3, [r2, #124]	; 0x7c
        sys.blocking_event = sys.alarm == Alarm_HardLimit ||
 8021f06:	4b1c      	ldr	r3, [pc, #112]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f08:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
                               sys.alarm == Alarm_EStop ||
 8021f0c:	2b01      	cmp	r3, #1
 8021f0e:	d00e      	beq.n	8021f2e <system_raise_alarm+0x6a>
                              sys.alarm == Alarm_SoftLimit ||
 8021f10:	4b19      	ldr	r3, [pc, #100]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f12:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
        sys.blocking_event = sys.alarm == Alarm_HardLimit ||
 8021f16:	2b02      	cmp	r3, #2
 8021f18:	d009      	beq.n	8021f2e <system_raise_alarm+0x6a>
                               sys.alarm == Alarm_EStop ||
 8021f1a:	4b17      	ldr	r3, [pc, #92]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f1c:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
                              sys.alarm == Alarm_SoftLimit ||
 8021f20:	2b0a      	cmp	r3, #10
 8021f22:	d004      	beq.n	8021f2e <system_raise_alarm+0x6a>
                                sys.alarm == Alarm_MotorFault;
 8021f24:	4b14      	ldr	r3, [pc, #80]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f26:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
                               sys.alarm == Alarm_EStop ||
 8021f2a:	2b11      	cmp	r3, #17
 8021f2c:	d101      	bne.n	8021f32 <system_raise_alarm+0x6e>
 8021f2e:	2301      	movs	r3, #1
 8021f30:	e000      	b.n	8021f34 <system_raise_alarm+0x70>
 8021f32:	2300      	movs	r3, #0
 8021f34:	f003 0301 	and.w	r3, r3, #1
 8021f38:	b2da      	uxtb	r2, r3
        sys.blocking_event = sys.alarm == Alarm_HardLimit ||
 8021f3a:	4b0f      	ldr	r3, [pc, #60]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f3c:	715a      	strb	r2, [r3, #5]
        state_set(alarm == Alarm_EStop ? STATE_ESTOP : STATE_ALARM);
 8021f3e:	79fb      	ldrb	r3, [r7, #7]
 8021f40:	2b0a      	cmp	r3, #10
 8021f42:	d102      	bne.n	8021f4a <system_raise_alarm+0x86>
 8021f44:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021f48:	e000      	b.n	8021f4c <system_raise_alarm+0x88>
 8021f4a:	2301      	movs	r3, #1
 8021f4c:	4618      	mov	r0, r3
 8021f4e:	f7fb fcc1 	bl	801d8d4 <state_set>
        if(sys.driver_started || sys.alarm == Alarm_SelftestFailed)
 8021f52:	4b09      	ldr	r3, [pc, #36]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f54:	f893 307e 	ldrb.w	r3, [r3, #126]	; 0x7e
 8021f58:	2b00      	cmp	r3, #0
 8021f5a:	d104      	bne.n	8021f66 <system_raise_alarm+0xa2>
 8021f5c:	4b06      	ldr	r3, [pc, #24]	; (8021f78 <system_raise_alarm+0xb4>)
 8021f5e:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 8021f62:	2b10      	cmp	r3, #16
 8021f64:	d104      	bne.n	8021f70 <system_raise_alarm+0xac>
            grbl.report.alarm_message(alarm);
 8021f66:	4b07      	ldr	r3, [pc, #28]	; (8021f84 <system_raise_alarm+0xc0>)
 8021f68:	691b      	ldr	r3, [r3, #16]
 8021f6a:	79fa      	ldrb	r2, [r7, #7]
 8021f6c:	4610      	mov	r0, r2
 8021f6e:	4798      	blx	r3
}
 8021f70:	bf00      	nop
 8021f72:	3708      	adds	r7, #8
 8021f74:	46bd      	mov	sp, r7
 8021f76:	bd80      	pop	{r7, pc}
 8021f78:	20000d3c 	.word	0x20000d3c
 8021f7c:	20000ed0 	.word	0x20000ed0
 8021f80:	20000d88 	.word	0x20000d88
 8021f84:	20000dd4 	.word	0x20000dd4

08021f88 <system_get_rt_report_flags>:

/*! \brief Get the active realtime report addon flags for the next report.
\return a #report_tracking_flags_t union containing the flags.
 */
report_tracking_flags_t system_get_rt_report_flags (void)
{
 8021f88:	b480      	push	{r7}
 8021f8a:	af00      	add	r7, sp, #0
    return sys.report;
 8021f8c:	4b02      	ldr	r3, [pc, #8]	; (8021f98 <system_get_rt_report_flags+0x10>)
 8021f8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 8021f90:	4618      	mov	r0, r3
 8021f92:	46bd      	mov	sp, r7
 8021f94:	bc80      	pop	{r7}
 8021f96:	4770      	bx	lr
 8021f98:	20000d3c 	.word	0x20000d3c

08021f9c <system_add_rt_report>:

Fires the \ref grbl.on_rt_reports_added event.
\param report a #report_tracking_t enum containing the flag(s) to set or clear.
 */
void system_add_rt_report (report_tracking_t report)
{
 8021f9c:	b580      	push	{r7, lr}
 8021f9e:	b082      	sub	sp, #8
 8021fa0:	af00      	add	r7, sp, #0
 8021fa2:	6078      	str	r0, [r7, #4]
    if(report == Report_ClearAll)
 8021fa4:	687b      	ldr	r3, [r7, #4]
 8021fa6:	2b00      	cmp	r3, #0
 8021fa8:	d103      	bne.n	8021fb2 <system_add_rt_report+0x16>
        sys.report.value = 0;
 8021faa:	4b16      	ldr	r3, [pc, #88]	; (8022004 <system_add_rt_report+0x68>)
 8021fac:	2200      	movs	r2, #0
 8021fae:	631a      	str	r2, [r3, #48]	; 0x30
 8021fb0:	e016      	b.n	8021fe0 <system_add_rt_report+0x44>
    else if(report == Report_MPGMode)
 8021fb2:	687b      	ldr	r3, [r7, #4]
 8021fb4:	2b01      	cmp	r3, #1
 8021fb6:	d10d      	bne.n	8021fd4 <system_add_rt_report+0x38>
        sys.report.mpg_mode = hal.driver_cap.mpg_mode;
 8021fb8:	4b13      	ldr	r3, [pc, #76]	; (8022008 <system_add_rt_report+0x6c>)
 8021fba:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8021fbe:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8021fc2:	b2d9      	uxtb	r1, r3
 8021fc4:	4a0f      	ldr	r2, [pc, #60]	; (8022004 <system_add_rt_report+0x68>)
 8021fc6:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8021fca:	f361 0300 	bfi	r3, r1, #0, #1
 8021fce:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
 8021fd2:	e005      	b.n	8021fe0 <system_add_rt_report+0x44>
    else
        sys.report.value |= (uint32_t)report;
 8021fd4:	4b0b      	ldr	r3, [pc, #44]	; (8022004 <system_add_rt_report+0x68>)
 8021fd6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8021fd8:	687b      	ldr	r3, [r7, #4]
 8021fda:	4313      	orrs	r3, r2
 8021fdc:	4a09      	ldr	r2, [pc, #36]	; (8022004 <system_add_rt_report+0x68>)
 8021fde:	6313      	str	r3, [r2, #48]	; 0x30

    if(sys.report.value && grbl.on_rt_reports_added)
 8021fe0:	4b08      	ldr	r3, [pc, #32]	; (8022004 <system_add_rt_report+0x68>)
 8021fe2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021fe4:	2b00      	cmp	r3, #0
 8021fe6:	d008      	beq.n	8021ffa <system_add_rt_report+0x5e>
 8021fe8:	4b08      	ldr	r3, [pc, #32]	; (802200c <system_add_rt_report+0x70>)
 8021fea:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8021fec:	2b00      	cmp	r3, #0
 8021fee:	d004      	beq.n	8021ffa <system_add_rt_report+0x5e>
        grbl.on_rt_reports_added((report_tracking_flags_t)((uint32_t)report));
 8021ff0:	4b06      	ldr	r3, [pc, #24]	; (802200c <system_add_rt_report+0x70>)
 8021ff2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8021ff4:	687a      	ldr	r2, [r7, #4]
 8021ff6:	4610      	mov	r0, r2
 8021ff8:	4798      	blx	r3
}
 8021ffa:	bf00      	nop
 8021ffc:	3708      	adds	r7, #8
 8021ffe:	46bd      	mov	sp, r7
 8022000:	bd80      	pop	{r7, pc}
 8022002:	bf00      	nop
 8022004:	20000d3c 	.word	0x20000d3c
 8022008:	20000ed0 	.word	0x20000ed0
 802200c:	20000dd4 	.word	0x20000dd4

08022010 <on_probe_completed>:
static control_signals_callback_ptr control_interrupt_callback = NULL;

// Set tool offset on successful $TPW probe, prompt for retry on failure.
// Called via probe completed event.
static void on_probe_completed (void)
{
 8022010:	b580      	push	{r7, lr}
 8022012:	af00      	add	r7, sp, #0
    if(!sys.flags.probe_succeeded)
 8022014:	4b16      	ldr	r3, [pc, #88]	; (8022070 <on_probe_completed+0x60>)
 8022016:	7d9b      	ldrb	r3, [r3, #22]
 8022018:	f003 0302 	and.w	r3, r3, #2
 802201c:	b2db      	uxtb	r3, r3
 802201e:	2b00      	cmp	r3, #0
 8022020:	d104      	bne.n	802202c <on_probe_completed+0x1c>
        grbl.report.feedback_message(Message_ProbeFailedRetry);
 8022022:	4b14      	ldr	r3, [pc, #80]	; (8022074 <on_probe_completed+0x64>)
 8022024:	68db      	ldr	r3, [r3, #12]
 8022026:	2013      	movs	r0, #19
 8022028:	4798      	blx	r3
    else if(sys.tlo_reference_set.mask & bit(plane.axis_linear))
        gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear, sys.probe_position[plane.axis_linear] - sys.tlo_reference[plane.axis_linear]);
//    else error?
}
 802202a:	e01f      	b.n	802206c <on_probe_completed+0x5c>
    else if(sys.tlo_reference_set.mask & bit(plane.axis_linear))
 802202c:	4b10      	ldr	r3, [pc, #64]	; (8022070 <on_probe_completed+0x60>)
 802202e:	79db      	ldrb	r3, [r3, #7]
 8022030:	461a      	mov	r2, r3
 8022032:	4b11      	ldr	r3, [pc, #68]	; (8022078 <on_probe_completed+0x68>)
 8022034:	789b      	ldrb	r3, [r3, #2]
 8022036:	fa22 f303 	lsr.w	r3, r2, r3
 802203a:	f003 0301 	and.w	r3, r3, #1
 802203e:	2b00      	cmp	r3, #0
 8022040:	d014      	beq.n	802206c <on_probe_completed+0x5c>
        gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear, sys.probe_position[plane.axis_linear] - sys.tlo_reference[plane.axis_linear]);
 8022042:	4b0d      	ldr	r3, [pc, #52]	; (8022078 <on_probe_completed+0x68>)
 8022044:	789b      	ldrb	r3, [r3, #2]
 8022046:	4618      	mov	r0, r3
 8022048:	4b0b      	ldr	r3, [pc, #44]	; (8022078 <on_probe_completed+0x68>)
 802204a:	789b      	ldrb	r3, [r3, #2]
 802204c:	4a08      	ldr	r2, [pc, #32]	; (8022070 <on_probe_completed+0x60>)
 802204e:	330e      	adds	r3, #14
 8022050:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8022054:	4b08      	ldr	r3, [pc, #32]	; (8022078 <on_probe_completed+0x68>)
 8022056:	789b      	ldrb	r3, [r3, #2]
 8022058:	4905      	ldr	r1, [pc, #20]	; (8022070 <on_probe_completed+0x60>)
 802205a:	3302      	adds	r3, #2
 802205c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8022060:	1ad3      	subs	r3, r2, r3
 8022062:	461a      	mov	r2, r3
 8022064:	4601      	mov	r1, r0
 8022066:	2002      	movs	r0, #2
 8022068:	f7e3 fd02 	bl	8005a70 <gc_set_tool_offset>
}
 802206c:	bf00      	nop
 802206e:	bd80      	pop	{r7, pc}
 8022070:	20000d3c 	.word	0x20000d3c
 8022074:	20000dd4 	.word	0x20000dd4
 8022078:	20002160 	.word	0x20002160

0802207c <change_completed>:

// Restore HAL pointers on completion or reset.
static void change_completed (void)
{
 802207c:	b580      	push	{r7, lr}
 802207e:	af00      	add	r7, sp, #0
    if(enqueue_realtime_command) {
 8022080:	4b23      	ldr	r3, [pc, #140]	; (8022110 <change_completed+0x94>)
 8022082:	681b      	ldr	r3, [r3, #0]
 8022084:	2b00      	cmp	r3, #0
 8022086:	d014      	beq.n	80220b2 <change_completed+0x36>
        while(spin_lock);
 8022088:	bf00      	nop
 802208a:	4b22      	ldr	r3, [pc, #136]	; (8022114 <change_completed+0x98>)
 802208c:	681b      	ldr	r3, [r3, #0]
 802208e:	2b00      	cmp	r3, #0
 8022090:	d1fb      	bne.n	802208a <change_completed+0xe>
        hal.irq_disable();
 8022092:	4b21      	ldr	r3, [pc, #132]	; (8022118 <change_completed+0x9c>)
 8022094:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8022096:	4798      	blx	r3
        hal.stream.set_enqueue_rt_handler(enqueue_realtime_command);
 8022098:	4b1f      	ldr	r3, [pc, #124]	; (8022118 <change_completed+0x9c>)
 802209a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 802209e:	4a1c      	ldr	r2, [pc, #112]	; (8022110 <change_completed+0x94>)
 80220a0:	6812      	ldr	r2, [r2, #0]
 80220a2:	4610      	mov	r0, r2
 80220a4:	4798      	blx	r3
        enqueue_realtime_command = NULL;
 80220a6:	4b1a      	ldr	r3, [pc, #104]	; (8022110 <change_completed+0x94>)
 80220a8:	2200      	movs	r2, #0
 80220aa:	601a      	str	r2, [r3, #0]
        hal.irq_enable();
 80220ac:	4b1a      	ldr	r3, [pc, #104]	; (8022118 <change_completed+0x9c>)
 80220ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80220b0:	4798      	blx	r3
    }

    if(control_interrupt_callback) {
 80220b2:	4b1a      	ldr	r3, [pc, #104]	; (802211c <change_completed+0xa0>)
 80220b4:	681b      	ldr	r3, [r3, #0]
 80220b6:	2b00      	cmp	r3, #0
 80220b8:	d011      	beq.n	80220de <change_completed+0x62>
        while(spin_lock);
 80220ba:	bf00      	nop
 80220bc:	4b15      	ldr	r3, [pc, #84]	; (8022114 <change_completed+0x98>)
 80220be:	681b      	ldr	r3, [r3, #0]
 80220c0:	2b00      	cmp	r3, #0
 80220c2:	d1fb      	bne.n	80220bc <change_completed+0x40>
        hal.irq_disable();
 80220c4:	4b14      	ldr	r3, [pc, #80]	; (8022118 <change_completed+0x9c>)
 80220c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80220c8:	4798      	blx	r3
        hal.control.interrupt_callback = control_interrupt_callback;
 80220ca:	4b14      	ldr	r3, [pc, #80]	; (802211c <change_completed+0xa0>)
 80220cc:	681b      	ldr	r3, [r3, #0]
 80220ce:	4a12      	ldr	r2, [pc, #72]	; (8022118 <change_completed+0x9c>)
 80220d0:	66d3      	str	r3, [r2, #108]	; 0x6c
        control_interrupt_callback = NULL;
 80220d2:	4b12      	ldr	r3, [pc, #72]	; (802211c <change_completed+0xa0>)
 80220d4:	2200      	movs	r2, #0
 80220d6:	601a      	str	r2, [r3, #0]
        hal.irq_enable();
 80220d8:	4b0f      	ldr	r3, [pc, #60]	; (8022118 <change_completed+0x9c>)
 80220da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80220dc:	4798      	blx	r3
    }

    if(probe_fixture)
 80220de:	4b10      	ldr	r3, [pc, #64]	; (8022120 <change_completed+0xa4>)
 80220e0:	781b      	ldrb	r3, [r3, #0]
 80220e2:	2b00      	cmp	r3, #0
 80220e4:	d006      	beq.n	80220f4 <change_completed+0x78>
        grbl.on_probe_fixture(&current_tool, true, false);
 80220e6:	4b0f      	ldr	r3, [pc, #60]	; (8022124 <change_completed+0xa8>)
 80220e8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80220ec:	2200      	movs	r2, #0
 80220ee:	2101      	movs	r1, #1
 80220f0:	480d      	ldr	r0, [pc, #52]	; (8022128 <change_completed+0xac>)
 80220f2:	4798      	blx	r3

    grbl.on_probe_completed = NULL;
 80220f4:	4b0b      	ldr	r3, [pc, #44]	; (8022124 <change_completed+0xa8>)
 80220f6:	2200      	movs	r2, #0
 80220f8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    gc_state.tool_change = probe_fixture = false;
 80220fc:	4b08      	ldr	r3, [pc, #32]	; (8022120 <change_completed+0xa4>)
 80220fe:	2200      	movs	r2, #0
 8022100:	701a      	strb	r2, [r3, #0]
 8022102:	4b07      	ldr	r3, [pc, #28]	; (8022120 <change_completed+0xa4>)
 8022104:	781a      	ldrb	r2, [r3, #0]
 8022106:	4b09      	ldr	r3, [pc, #36]	; (802212c <change_completed+0xb0>)
 8022108:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
}
 802210c:	bf00      	nop
 802210e:	bd80      	pop	{r7, pc}
 8022110:	20002180 	.word	0x20002180
 8022114:	20002140 	.word	0x20002140
 8022118:	20000ed0 	.word	0x20000ed0
 802211c:	20002184 	.word	0x20002184
 8022120:	2000213d 	.word	0x2000213d
 8022124:	20000dd4 	.word	0x20000dd4
 8022128:	20002148 	.word	0x20002148
 802212c:	20000bb0 	.word	0x20000bb0

08022130 <reset>:


// Reset claimed HAL entry points and restore previous tool if needed on soft restart.
// Called from EXEC_RESET and EXEC_STOP handlers (via HAL).
static void reset (void)
{
 8022130:	b580      	push	{r7, lr}
 8022132:	af00      	add	r7, sp, #0
    if(next_tool) { //TODO: move to gc_xxx() function?
 8022134:	4b18      	ldr	r3, [pc, #96]	; (8022198 <reset+0x68>)
 8022136:	681b      	ldr	r3, [r3, #0]
 8022138:	2b00      	cmp	r3, #0
 802213a:	d026      	beq.n	802218a <reset+0x5a>
        // Restore previous tool if reset is during change
        if(current_tool.tool_id != next_tool->tool_id) {
 802213c:	4b17      	ldr	r3, [pc, #92]	; (802219c <reset+0x6c>)
 802213e:	691a      	ldr	r2, [r3, #16]
 8022140:	4b15      	ldr	r3, [pc, #84]	; (8022198 <reset+0x68>)
 8022142:	681b      	ldr	r3, [r3, #0]
 8022144:	691b      	ldr	r3, [r3, #16]
 8022146:	429a      	cmp	r2, r3
 8022148:	d016      	beq.n	8022178 <reset+0x48>
            if(grbl.tool_table.n_tools)
 802214a:	4b15      	ldr	r3, [pc, #84]	; (80221a0 <reset+0x70>)
 802214c:	699b      	ldr	r3, [r3, #24]
 802214e:	2b00      	cmp	r3, #0
 8022150:	d008      	beq.n	8022164 <reset+0x34>
                memcpy(gc_state.tool, &current_tool, sizeof(tool_data_t));
 8022152:	4b14      	ldr	r3, [pc, #80]	; (80221a4 <reset+0x74>)
 8022154:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8022158:	2214      	movs	r2, #20
 802215a:	4910      	ldr	r1, [pc, #64]	; (802219c <reset+0x6c>)
 802215c:	4618      	mov	r0, r3
 802215e:	f001 feb6 	bl	8023ece <memcpy>
 8022162:	e006      	b.n	8022172 <reset+0x42>
            else
                memcpy(next_tool, &current_tool, sizeof(tool_data_t));
 8022164:	4b0c      	ldr	r3, [pc, #48]	; (8022198 <reset+0x68>)
 8022166:	681b      	ldr	r3, [r3, #0]
 8022168:	2214      	movs	r2, #20
 802216a:	490c      	ldr	r1, [pc, #48]	; (802219c <reset+0x6c>)
 802216c:	4618      	mov	r0, r3
 802216e:	f001 feae 	bl	8023ece <memcpy>
            system_add_rt_report(Report_Tool);
 8022172:	2080      	movs	r0, #128	; 0x80
 8022174:	f7ff ff12 	bl	8021f9c <system_add_rt_report>
        }
        gc_state.tool_pending = gc_state.tool->tool_id;
 8022178:	4b0a      	ldr	r3, [pc, #40]	; (80221a4 <reset+0x74>)
 802217a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 802217e:	691b      	ldr	r3, [r3, #16]
 8022180:	4a08      	ldr	r2, [pc, #32]	; (80221a4 <reset+0x74>)
 8022182:	66d3      	str	r3, [r2, #108]	; 0x6c
        next_tool = NULL;
 8022184:	4b04      	ldr	r3, [pc, #16]	; (8022198 <reset+0x68>)
 8022186:	2200      	movs	r2, #0
 8022188:	601a      	str	r2, [r3, #0]
    }

    change_completed();
 802218a:	f7ff ff77 	bl	802207c <change_completed>
    driver_reset();
 802218e:	4b06      	ldr	r3, [pc, #24]	; (80221a8 <reset+0x78>)
 8022190:	681b      	ldr	r3, [r3, #0]
 8022192:	4798      	blx	r3
}
 8022194:	bf00      	nop
 8022196:	bd80      	pop	{r7, pc}
 8022198:	2000215c 	.word	0x2000215c
 802219c:	20002148 	.word	0x20002148
 80221a0:	20000dd4 	.word	0x20000dd4
 80221a4:	20000bb0 	.word	0x20000bb0
 80221a8:	2000217c 	.word	0x2000217c

080221ac <restore>:

// Restore coolant and spindle status, return controlled point to original position.
static bool restore (void)
{
 80221ac:	b590      	push	{r4, r7, lr}
 80221ae:	b08d      	sub	sp, #52	; 0x34
 80221b0:	af00      	add	r7, sp, #0
    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 80221b2:	1d3b      	adds	r3, r7, #4
 80221b4:	4618      	mov	r0, r3
 80221b6:	f7f0 f8f9 	bl	80123ac <plan_data_init>
    plan_data.condition.rapid_motion = On;
 80221ba:	7f3b      	ldrb	r3, [r7, #28]
 80221bc:	f043 0301 	orr.w	r3, r3, #1
 80221c0:	773b      	strb	r3, [r7, #28]

    target.values[plane.axis_linear] = tool_change_position;
 80221c2:	4b46      	ldr	r3, [pc, #280]	; (80222dc <restore+0x130>)
 80221c4:	789b      	ldrb	r3, [r3, #2]
 80221c6:	4619      	mov	r1, r3
 80221c8:	4b45      	ldr	r3, [pc, #276]	; (80222e0 <restore+0x134>)
 80221ca:	681b      	ldr	r3, [r3, #0]
 80221cc:	4a45      	ldr	r2, [pc, #276]	; (80222e4 <restore+0x138>)
 80221ce:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    mc_line(target.values, &plan_data);
 80221d2:	1d3b      	adds	r3, r7, #4
 80221d4:	4619      	mov	r1, r3
 80221d6:	4843      	ldr	r0, [pc, #268]	; (80222e4 <restore+0x138>)
 80221d8:	f7eb fc0e 	bl	800d9f8 <mc_line>

    if(!settings.flags.no_restore_position_after_M6) {
 80221dc:	4b42      	ldr	r3, [pc, #264]	; (80222e8 <restore+0x13c>)
 80221de:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 80221e2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80221e6:	b2db      	uxtb	r3, r3
 80221e8:	2b00      	cmp	r3, #0
 80221ea:	d111      	bne.n	8022210 <restore+0x64>
        memcpy(&target, &previous, sizeof(coord_data_t));
 80221ec:	4b3d      	ldr	r3, [pc, #244]	; (80222e4 <restore+0x138>)
 80221ee:	4a3f      	ldr	r2, [pc, #252]	; (80222ec <restore+0x140>)
 80221f0:	ca07      	ldmia	r2, {r0, r1, r2}
 80221f2:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        target.values[plane.axis_linear] = tool_change_position;
 80221f6:	4b39      	ldr	r3, [pc, #228]	; (80222dc <restore+0x130>)
 80221f8:	789b      	ldrb	r3, [r3, #2]
 80221fa:	4619      	mov	r1, r3
 80221fc:	4b38      	ldr	r3, [pc, #224]	; (80222e0 <restore+0x134>)
 80221fe:	681b      	ldr	r3, [r3, #0]
 8022200:	4a38      	ldr	r2, [pc, #224]	; (80222e4 <restore+0x138>)
 8022202:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        mc_line(target.values, &plan_data);
 8022206:	1d3b      	adds	r3, r7, #4
 8022208:	4619      	mov	r1, r3
 802220a:	4836      	ldr	r0, [pc, #216]	; (80222e4 <restore+0x138>)
 802220c:	f7eb fbf4 	bl	800d9f8 <mc_line>
    }

    if(protocol_buffer_synchronize()) {
 8022210:	f7f0 fd76 	bl	8012d00 <protocol_buffer_synchronize>
 8022214:	4603      	mov	r3, r0
 8022216:	2b00      	cmp	r3, #0
 8022218:	d036      	beq.n	8022288 <restore+0xdc>

        sync_position();
 802221a:	f7ef ffe3 	bl	80121e4 <plan_sync_position>
 802221e:	4934      	ldr	r1, [pc, #208]	; (80222f0 <restore+0x144>)
 8022220:	4834      	ldr	r0, [pc, #208]	; (80222f4 <restore+0x148>)
 8022222:	f7ff fdf5 	bl	8021e10 <system_convert_array_steps_to_mpos>

        coolant_sync(gc_state.modal.coolant);
 8022226:	4b34      	ldr	r3, [pc, #208]	; (80222f8 <restore+0x14c>)
 8022228:	7e58      	ldrb	r0, [r3, #25]
 802222a:	f7e3 fa39 	bl	80056a0 <coolant_sync>
        spindle_restore(plan_data.spindle.hal, gc_state.modal.spindle.state, gc_state.spindle.rpm);
 802222e:	69bb      	ldr	r3, [r7, #24]
 8022230:	4a31      	ldr	r2, [pc, #196]	; (80222f8 <restore+0x14c>)
 8022232:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8022234:	4930      	ldr	r1, [pc, #192]	; (80222f8 <restore+0x14c>)
 8022236:	7e89      	ldrb	r1, [r1, #26]
 8022238:	4618      	mov	r0, r3
 802223a:	f7fa fe71 	bl	801cf20 <spindle_restore>

        if(!settings.flags.no_restore_position_after_M6) {
 802223e:	4b2a      	ldr	r3, [pc, #168]	; (80222e8 <restore+0x13c>)
 8022240:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8022244:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8022248:	b2db      	uxtb	r3, r3
 802224a:	2b00      	cmp	r3, #0
 802224c:	d11c      	bne.n	8022288 <restore+0xdc>
            previous.values[plane.axis_linear] += gc_get_offset(plane.axis_linear);
 802224e:	4b23      	ldr	r3, [pc, #140]	; (80222dc <restore+0x130>)
 8022250:	789b      	ldrb	r3, [r3, #2]
 8022252:	4618      	mov	r0, r3
 8022254:	f7e3 fbc2 	bl	80059dc <gc_get_offset>
 8022258:	4602      	mov	r2, r0
 802225a:	4b20      	ldr	r3, [pc, #128]	; (80222dc <restore+0x130>)
 802225c:	789b      	ldrb	r3, [r3, #2]
 802225e:	4619      	mov	r1, r3
 8022260:	4b22      	ldr	r3, [pc, #136]	; (80222ec <restore+0x140>)
 8022262:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8022266:	491d      	ldr	r1, [pc, #116]	; (80222dc <restore+0x130>)
 8022268:	7889      	ldrb	r1, [r1, #2]
 802226a:	460c      	mov	r4, r1
 802226c:	4619      	mov	r1, r3
 802226e:	4610      	mov	r0, r2
 8022270:	f7de fc98 	bl	8000ba4 <__addsf3>
 8022274:	4603      	mov	r3, r0
 8022276:	461a      	mov	r2, r3
 8022278:	4b1c      	ldr	r3, [pc, #112]	; (80222ec <restore+0x140>)
 802227a:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
            mc_line(previous.values, &plan_data);
 802227e:	1d3b      	adds	r3, r7, #4
 8022280:	4619      	mov	r1, r3
 8022282:	481a      	ldr	r0, [pc, #104]	; (80222ec <restore+0x140>)
 8022284:	f7eb fbb8 	bl	800d9f8 <mc_line>
        }
    }

    if(protocol_buffer_synchronize()) {
 8022288:	f7f0 fd3a 	bl	8012d00 <protocol_buffer_synchronize>
 802228c:	4603      	mov	r3, r0
 802228e:	2b00      	cmp	r3, #0
 8022290:	d00c      	beq.n	80222ac <restore+0x100>
        sync_position();
 8022292:	f7ef ffa7 	bl	80121e4 <plan_sync_position>
 8022296:	4916      	ldr	r1, [pc, #88]	; (80222f0 <restore+0x144>)
 8022298:	4816      	ldr	r0, [pc, #88]	; (80222f4 <restore+0x148>)
 802229a:	f7ff fdb9 	bl	8021e10 <system_convert_array_steps_to_mpos>
        memcpy(&current_tool, next_tool, sizeof(tool_data_t));
 802229e:	4b17      	ldr	r3, [pc, #92]	; (80222fc <restore+0x150>)
 80222a0:	681b      	ldr	r3, [r3, #0]
 80222a2:	2214      	movs	r2, #20
 80222a4:	4619      	mov	r1, r3
 80222a6:	4816      	ldr	r0, [pc, #88]	; (8022300 <restore+0x154>)
 80222a8:	f001 fe11 	bl	8023ece <memcpy>
    }

    return !ABORTED;
 80222ac:	4b15      	ldr	r3, [pc, #84]	; (8022304 <restore+0x158>)
 80222ae:	781b      	ldrb	r3, [r3, #0]
 80222b0:	f083 0301 	eor.w	r3, r3, #1
 80222b4:	b2db      	uxtb	r3, r3
 80222b6:	2b00      	cmp	r3, #0
 80222b8:	d008      	beq.n	80222cc <restore+0x120>
 80222ba:	4b12      	ldr	r3, [pc, #72]	; (8022304 <restore+0x158>)
 80222bc:	785b      	ldrb	r3, [r3, #1]
 80222be:	f083 0301 	eor.w	r3, r3, #1
 80222c2:	b2db      	uxtb	r3, r3
 80222c4:	2b00      	cmp	r3, #0
 80222c6:	d001      	beq.n	80222cc <restore+0x120>
 80222c8:	2301      	movs	r3, #1
 80222ca:	e000      	b.n	80222ce <restore+0x122>
 80222cc:	2300      	movs	r3, #0
 80222ce:	f003 0301 	and.w	r3, r3, #1
 80222d2:	b2db      	uxtb	r3, r3
}
 80222d4:	4618      	mov	r0, r3
 80222d6:	3734      	adds	r7, #52	; 0x34
 80222d8:	46bd      	mov	sp, r7
 80222da:	bd90      	pop	{r4, r7, pc}
 80222dc:	20002160 	.word	0x20002160
 80222e0:	20002144 	.word	0x20002144
 80222e4:	20002164 	.word	0x20002164
 80222e8:	2000147c 	.word	0x2000147c
 80222ec:	20002170 	.word	0x20002170
 80222f0:	20000dc4 	.word	0x20000dc4
 80222f4:	20000c0c 	.word	0x20000c0c
 80222f8:	20000bb0 	.word	0x20000bb0
 80222fc:	2000215c 	.word	0x2000215c
 8022300:	20002148 	.word	0x20002148
 8022304:	20000d3c 	.word	0x20000d3c

08022308 <execute_warning>:

// Issue warning on cycle start event if touch off by $TPW is pending.
// Used in Manual and Manual_G59_3 modes ($341=1 or $341=2). Called from the foreground process.
static void execute_warning (sys_state_t state)
{
 8022308:	b580      	push	{r7, lr}
 802230a:	b082      	sub	sp, #8
 802230c:	af00      	add	r7, sp, #0
 802230e:	6078      	str	r0, [r7, #4]
    grbl.report.feedback_message(Message_ExecuteTPW);
 8022310:	4b03      	ldr	r3, [pc, #12]	; (8022320 <execute_warning+0x18>)
 8022312:	68db      	ldr	r3, [r3, #12]
 8022314:	2014      	movs	r0, #20
 8022316:	4798      	blx	r3
}
 8022318:	bf00      	nop
 802231a:	3708      	adds	r7, #8
 802231c:	46bd      	mov	sp, r7
 802231e:	bd80      	pop	{r7, pc}
 8022320:	20000dd4 	.word	0x20000dd4

08022324 <execute_restore>:

// Execute restore position after touch off (on cycle start event).
// Used in Manual and Manual_G59_3 modes ($341=1 or $341=2). Called from the foreground process.
static void execute_restore (sys_state_t state)
{
 8022324:	b580      	push	{r7, lr}
 8022326:	b084      	sub	sp, #16
 8022328:	af00      	add	r7, sp, #0
 802232a:	6078      	str	r0, [r7, #4]
    // Get current position.
    system_convert_array_steps_to_mpos(target.values, sys.position);
 802232c:	490c      	ldr	r1, [pc, #48]	; (8022360 <execute_restore+0x3c>)
 802232e:	480d      	ldr	r0, [pc, #52]	; (8022364 <execute_restore+0x40>)
 8022330:	f7ff fd6e 	bl	8021e10 <system_convert_array_steps_to_mpos>

    bool ok = restore();
 8022334:	f7ff ff3a 	bl	80221ac <restore>
 8022338:	4603      	mov	r3, r0
 802233a:	73fb      	strb	r3, [r7, #15]

    change_completed();
 802233c:	f7ff fe9e 	bl	802207c <change_completed>

    grbl.report.feedback_message(Message_None);
 8022340:	4b09      	ldr	r3, [pc, #36]	; (8022368 <execute_restore+0x44>)
 8022342:	68db      	ldr	r3, [r3, #12]
 8022344:	2000      	movs	r0, #0
 8022346:	4798      	blx	r3

    if(ok)
 8022348:	7bfb      	ldrb	r3, [r7, #15]
 802234a:	2b00      	cmp	r3, #0
 802234c:	d004      	beq.n	8022358 <execute_restore+0x34>
        system_set_exec_state_flag(EXEC_CYCLE_START);
 802234e:	4b07      	ldr	r3, [pc, #28]	; (802236c <execute_restore+0x48>)
 8022350:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8022352:	2102      	movs	r1, #2
 8022354:	4806      	ldr	r0, [pc, #24]	; (8022370 <execute_restore+0x4c>)
 8022356:	4798      	blx	r3
}
 8022358:	bf00      	nop
 802235a:	3710      	adds	r7, #16
 802235c:	46bd      	mov	sp, r7
 802235e:	bd80      	pop	{r7, pc}
 8022360:	20000dc4 	.word	0x20000dc4
 8022364:	20002164 	.word	0x20002164
 8022368:	20000dd4 	.word	0x20000dd4
 802236c:	20000ed0 	.word	0x20000ed0
 8022370:	20000d84 	.word	0x20000d84

08022374 <execute_probe>:

// Execute touch off on cycle start event from @ G59.3 position.
// Used in SemiAutomatic mode ($341=3) only. Called from the foreground process.
static void execute_probe (sys_state_t state)
{
 8022374:	b590      	push	{r4, r7, lr}
 8022376:	b093      	sub	sp, #76	; 0x4c
 8022378:	af00      	add	r7, sp, #0
 802237a:	6078      	str	r0, [r7, #4]
#if COMPATIBILITY_LEVEL <= 1
    bool ok;
    coord_data_t offset;
    plan_line_data_t plan_data;
    gc_parser_flags_t flags = {0};
 802237c:	2300      	movs	r3, #0
 802237e:	813b      	strh	r3, [r7, #8]

    if(probe_fixture)
 8022380:	4b9e      	ldr	r3, [pc, #632]	; (80225fc <execute_probe+0x288>)
 8022382:	781b      	ldrb	r3, [r3, #0]
 8022384:	2b00      	cmp	r3, #0
 8022386:	d007      	beq.n	8022398 <execute_probe+0x24>
        grbl.on_probe_fixture(next_tool, true, true);
 8022388:	4b9d      	ldr	r3, [pc, #628]	; (8022600 <execute_probe+0x28c>)
 802238a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802238e:	4a9d      	ldr	r2, [pc, #628]	; (8022604 <execute_probe+0x290>)
 8022390:	6810      	ldr	r0, [r2, #0]
 8022392:	2201      	movs	r2, #1
 8022394:	2101      	movs	r1, #1
 8022396:	4798      	blx	r3

    // G59.3 contains offsets to position of TLS.
    settings_read_coord_data(CoordinateSystem_G59_3, &offset.values);
 8022398:	f107 0338 	add.w	r3, r7, #56	; 0x38
 802239c:	4619      	mov	r1, r3
 802239e:	2008      	movs	r0, #8
 80223a0:	f7f8 fc3a 	bl	801ac18 <settings_read_coord_data>

    plan_data_init(&plan_data);
 80223a4:	f107 030c 	add.w	r3, r7, #12
 80223a8:	4618      	mov	r0, r3
 80223aa:	f7ef ffff 	bl	80123ac <plan_data_init>
    plan_data.condition.rapid_motion = On;
 80223ae:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 80223b2:	f043 0301 	orr.w	r3, r3, #1
 80223b6:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24

    target.values[plane.axis_0] = offset.values[plane.axis_0];
 80223ba:	4b93      	ldr	r3, [pc, #588]	; (8022608 <execute_probe+0x294>)
 80223bc:	781b      	ldrb	r3, [r3, #0]
 80223be:	461a      	mov	r2, r3
 80223c0:	4b91      	ldr	r3, [pc, #580]	; (8022608 <execute_probe+0x294>)
 80223c2:	781b      	ldrb	r3, [r3, #0]
 80223c4:	4619      	mov	r1, r3
 80223c6:	0093      	lsls	r3, r2, #2
 80223c8:	3348      	adds	r3, #72	; 0x48
 80223ca:	443b      	add	r3, r7
 80223cc:	f853 3c10 	ldr.w	r3, [r3, #-16]
 80223d0:	4a8e      	ldr	r2, [pc, #568]	; (802260c <execute_probe+0x298>)
 80223d2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    target.values[plane.axis_1] = offset.values[plane.axis_1];
 80223d6:	4b8c      	ldr	r3, [pc, #560]	; (8022608 <execute_probe+0x294>)
 80223d8:	785b      	ldrb	r3, [r3, #1]
 80223da:	461a      	mov	r2, r3
 80223dc:	4b8a      	ldr	r3, [pc, #552]	; (8022608 <execute_probe+0x294>)
 80223de:	785b      	ldrb	r3, [r3, #1]
 80223e0:	4619      	mov	r1, r3
 80223e2:	0093      	lsls	r3, r2, #2
 80223e4:	3348      	adds	r3, #72	; 0x48
 80223e6:	443b      	add	r3, r7
 80223e8:	f853 3c10 	ldr.w	r3, [r3, #-16]
 80223ec:	4a87      	ldr	r2, [pc, #540]	; (802260c <execute_probe+0x298>)
 80223ee:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

    if((ok = mc_line(target.values, &plan_data))) {
 80223f2:	f107 030c 	add.w	r3, r7, #12
 80223f6:	4619      	mov	r1, r3
 80223f8:	4884      	ldr	r0, [pc, #528]	; (802260c <execute_probe+0x298>)
 80223fa:	f7eb fafd 	bl	800d9f8 <mc_line>
 80223fe:	4603      	mov	r3, r0
 8022400:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 8022404:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8022408:	2b00      	cmp	r3, #0
 802240a:	f000 80e7 	beq.w	80225dc <execute_probe+0x268>

        target.values[plane.axis_linear] = offset.values[plane.axis_linear];
 802240e:	4b7e      	ldr	r3, [pc, #504]	; (8022608 <execute_probe+0x294>)
 8022410:	789b      	ldrb	r3, [r3, #2]
 8022412:	461a      	mov	r2, r3
 8022414:	4b7c      	ldr	r3, [pc, #496]	; (8022608 <execute_probe+0x294>)
 8022416:	789b      	ldrb	r3, [r3, #2]
 8022418:	4619      	mov	r1, r3
 802241a:	0093      	lsls	r3, r2, #2
 802241c:	3348      	adds	r3, #72	; 0x48
 802241e:	443b      	add	r3, r7
 8022420:	f853 3c10 	ldr.w	r3, [r3, #-16]
 8022424:	4a79      	ldr	r2, [pc, #484]	; (802260c <execute_probe+0x298>)
 8022426:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        ok = mc_line(target.values, &plan_data);
 802242a:	f107 030c 	add.w	r3, r7, #12
 802242e:	4619      	mov	r1, r3
 8022430:	4876      	ldr	r0, [pc, #472]	; (802260c <execute_probe+0x298>)
 8022432:	f7eb fae1 	bl	800d9f8 <mc_line>
 8022436:	4603      	mov	r3, r0
 8022438:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

        plan_data.feed_rate = settings.tool_change.seek_rate;
 802243c:	4b74      	ldr	r3, [pc, #464]	; (8022610 <execute_probe+0x29c>)
 802243e:	6a1b      	ldr	r3, [r3, #32]
 8022440:	60fb      	str	r3, [r7, #12]
        plan_data.condition.value = 0;
 8022442:	2300      	movs	r3, #0
 8022444:	627b      	str	r3, [r7, #36]	; 0x24
        plan_data.spindle.state.value = 0;
 8022446:	2300      	movs	r3, #0
 8022448:	763b      	strb	r3, [r7, #24]
        target.values[plane.axis_linear] -= settings.tool_change.probing_distance;
 802244a:	4b6f      	ldr	r3, [pc, #444]	; (8022608 <execute_probe+0x294>)
 802244c:	789b      	ldrb	r3, [r3, #2]
 802244e:	461a      	mov	r2, r3
 8022450:	4b6e      	ldr	r3, [pc, #440]	; (802260c <execute_probe+0x298>)
 8022452:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022456:	4a6e      	ldr	r2, [pc, #440]	; (8022610 <execute_probe+0x29c>)
 8022458:	6a92      	ldr	r2, [r2, #40]	; 0x28
 802245a:	496b      	ldr	r1, [pc, #428]	; (8022608 <execute_probe+0x294>)
 802245c:	7889      	ldrb	r1, [r1, #2]
 802245e:	460c      	mov	r4, r1
 8022460:	4611      	mov	r1, r2
 8022462:	4618      	mov	r0, r3
 8022464:	f7de fb9c 	bl	8000ba0 <__aeabi_fsub>
 8022468:	4603      	mov	r3, r0
 802246a:	461a      	mov	r2, r3
 802246c:	4b67      	ldr	r3, [pc, #412]	; (802260c <execute_probe+0x298>)
 802246e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]

        if((ok = ok && mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found))
 8022472:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8022476:	2b00      	cmp	r3, #0
 8022478:	d00b      	beq.n	8022492 <execute_probe+0x11e>
 802247a:	f107 030c 	add.w	r3, r7, #12
 802247e:	893a      	ldrh	r2, [r7, #8]
 8022480:	4619      	mov	r1, r3
 8022482:	4862      	ldr	r0, [pc, #392]	; (802260c <execute_probe+0x298>)
 8022484:	f7ec ff68 	bl	800f358 <mc_probe_cycle>
 8022488:	4603      	mov	r3, r0
 802248a:	2b01      	cmp	r3, #1
 802248c:	d101      	bne.n	8022492 <execute_probe+0x11e>
 802248e:	2301      	movs	r3, #1
 8022490:	e000      	b.n	8022494 <execute_probe+0x120>
 8022492:	2300      	movs	r3, #0
 8022494:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 8022498:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802249c:	f003 0301 	and.w	r3, r3, #1
 80224a0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 80224a4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80224a8:	2b00      	cmp	r3, #0
 80224aa:	d04a      	beq.n	8022542 <execute_probe+0x1ce>
        {
            system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 80224ac:	4959      	ldr	r1, [pc, #356]	; (8022614 <execute_probe+0x2a0>)
 80224ae:	4857      	ldr	r0, [pc, #348]	; (802260c <execute_probe+0x298>)
 80224b0:	f7ff fcae 	bl	8021e10 <system_convert_array_steps_to_mpos>

            // Retract a bit and perform slow probe.
            plan_data.feed_rate = settings.tool_change.pulloff_rate;
 80224b4:	4b56      	ldr	r3, [pc, #344]	; (8022610 <execute_probe+0x29c>)
 80224b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80224b8:	60fb      	str	r3, [r7, #12]
            target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE;
 80224ba:	4b53      	ldr	r3, [pc, #332]	; (8022608 <execute_probe+0x294>)
 80224bc:	789b      	ldrb	r3, [r3, #2]
 80224be:	461a      	mov	r2, r3
 80224c0:	4b52      	ldr	r3, [pc, #328]	; (802260c <execute_probe+0x298>)
 80224c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80224c6:	4a50      	ldr	r2, [pc, #320]	; (8022608 <execute_probe+0x294>)
 80224c8:	7892      	ldrb	r2, [r2, #2]
 80224ca:	4614      	mov	r4, r2
 80224cc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80224d0:	4618      	mov	r0, r3
 80224d2:	f7de fb67 	bl	8000ba4 <__addsf3>
 80224d6:	4603      	mov	r3, r0
 80224d8:	461a      	mov	r2, r3
 80224da:	4b4c      	ldr	r3, [pc, #304]	; (802260c <execute_probe+0x298>)
 80224dc:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
            if((ok = mc_line(target.values, &plan_data))) {
 80224e0:	f107 030c 	add.w	r3, r7, #12
 80224e4:	4619      	mov	r1, r3
 80224e6:	4849      	ldr	r0, [pc, #292]	; (802260c <execute_probe+0x298>)
 80224e8:	f7eb fa86 	bl	800d9f8 <mc_line>
 80224ec:	4603      	mov	r3, r0
 80224ee:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 80224f2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80224f6:	2b00      	cmp	r3, #0
 80224f8:	d023      	beq.n	8022542 <execute_probe+0x1ce>
                plan_data.feed_rate = settings.tool_change.feed_rate;
 80224fa:	4b45      	ldr	r3, [pc, #276]	; (8022610 <execute_probe+0x29c>)
 80224fc:	69db      	ldr	r3, [r3, #28]
 80224fe:	60fb      	str	r3, [r7, #12]
                target.values[plane.axis_linear] -= (TOOL_CHANGE_PROBE_RETRACT_DISTANCE + 2.0f);
 8022500:	4b41      	ldr	r3, [pc, #260]	; (8022608 <execute_probe+0x294>)
 8022502:	789b      	ldrb	r3, [r3, #2]
 8022504:	461a      	mov	r2, r3
 8022506:	4b41      	ldr	r3, [pc, #260]	; (802260c <execute_probe+0x298>)
 8022508:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802250c:	4a3e      	ldr	r2, [pc, #248]	; (8022608 <execute_probe+0x294>)
 802250e:	7892      	ldrb	r2, [r2, #2]
 8022510:	4614      	mov	r4, r2
 8022512:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 8022516:	4618      	mov	r0, r3
 8022518:	f7de fb42 	bl	8000ba0 <__aeabi_fsub>
 802251c:	4603      	mov	r3, r0
 802251e:	461a      	mov	r2, r3
 8022520:	4b3a      	ldr	r3, [pc, #232]	; (802260c <execute_probe+0x298>)
 8022522:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
                ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found;
 8022526:	f107 030c 	add.w	r3, r7, #12
 802252a:	893a      	ldrh	r2, [r7, #8]
 802252c:	4619      	mov	r1, r3
 802252e:	4837      	ldr	r0, [pc, #220]	; (802260c <execute_probe+0x298>)
 8022530:	f7ec ff12 	bl	800f358 <mc_probe_cycle>
 8022534:	4603      	mov	r3, r0
 8022536:	2b01      	cmp	r3, #1
 8022538:	bf0c      	ite	eq
 802253a:	2301      	moveq	r3, #1
 802253c:	2300      	movne	r3, #0
 802253e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            }
        }

        if(ok) {
 8022542:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8022546:	2b00      	cmp	r3, #0
 8022548:	d048      	beq.n	80225dc <execute_probe+0x268>
            if(!(sys.tlo_reference_set.mask & bit(plane.axis_linear))) {
 802254a:	4b33      	ldr	r3, [pc, #204]	; (8022618 <execute_probe+0x2a4>)
 802254c:	79db      	ldrb	r3, [r3, #7]
 802254e:	461a      	mov	r2, r3
 8022550:	4b2d      	ldr	r3, [pc, #180]	; (8022608 <execute_probe+0x294>)
 8022552:	789b      	ldrb	r3, [r3, #2]
 8022554:	fa22 f303 	lsr.w	r3, r2, r3
 8022558:	f003 0301 	and.w	r3, r3, #1
 802255c:	2b00      	cmp	r3, #0
 802255e:	d123      	bne.n	80225a8 <execute_probe+0x234>
                sys.tlo_reference[plane.axis_linear] = sys.probe_position[plane.axis_linear];
 8022560:	4b29      	ldr	r3, [pc, #164]	; (8022608 <execute_probe+0x294>)
 8022562:	789b      	ldrb	r3, [r3, #2]
 8022564:	4619      	mov	r1, r3
 8022566:	4b28      	ldr	r3, [pc, #160]	; (8022608 <execute_probe+0x294>)
 8022568:	789b      	ldrb	r3, [r3, #2]
 802256a:	4618      	mov	r0, r3
 802256c:	4a2a      	ldr	r2, [pc, #168]	; (8022618 <execute_probe+0x2a4>)
 802256e:	f101 030e 	add.w	r3, r1, #14
 8022572:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8022576:	4928      	ldr	r1, [pc, #160]	; (8022618 <execute_probe+0x2a4>)
 8022578:	1c83      	adds	r3, r0, #2
 802257a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                sys.tlo_reference_set.mask |= bit(plane.axis_linear);
 802257e:	4b26      	ldr	r3, [pc, #152]	; (8022618 <execute_probe+0x2a4>)
 8022580:	79da      	ldrb	r2, [r3, #7]
 8022582:	4b21      	ldr	r3, [pc, #132]	; (8022608 <execute_probe+0x294>)
 8022584:	789b      	ldrb	r3, [r3, #2]
 8022586:	4619      	mov	r1, r3
 8022588:	2301      	movs	r3, #1
 802258a:	408b      	lsls	r3, r1
 802258c:	b2db      	uxtb	r3, r3
 802258e:	4313      	orrs	r3, r2
 8022590:	b2da      	uxtb	r2, r3
 8022592:	4b21      	ldr	r3, [pc, #132]	; (8022618 <execute_probe+0x2a4>)
 8022594:	71da      	strb	r2, [r3, #7]
                system_add_rt_report(Report_TLOReference);
 8022596:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 802259a:	f7ff fcff 	bl	8021f9c <system_add_rt_report>
                grbl.report.feedback_message(Message_ReferenceTLOEstablished);
 802259e:	4b18      	ldr	r3, [pc, #96]	; (8022600 <execute_probe+0x28c>)
 80225a0:	68db      	ldr	r3, [r3, #12]
 80225a2:	200f      	movs	r0, #15
 80225a4:	4798      	blx	r3
 80225a6:	e014      	b.n	80225d2 <execute_probe+0x25e>
            } else
                gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear,
 80225a8:	4b17      	ldr	r3, [pc, #92]	; (8022608 <execute_probe+0x294>)
 80225aa:	789b      	ldrb	r3, [r3, #2]
 80225ac:	4618      	mov	r0, r3
                                    sys.probe_position[plane.axis_linear] - sys.tlo_reference[plane.axis_linear]);
 80225ae:	4b16      	ldr	r3, [pc, #88]	; (8022608 <execute_probe+0x294>)
 80225b0:	789b      	ldrb	r3, [r3, #2]
 80225b2:	4a19      	ldr	r2, [pc, #100]	; (8022618 <execute_probe+0x2a4>)
 80225b4:	330e      	adds	r3, #14
 80225b6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80225ba:	4b13      	ldr	r3, [pc, #76]	; (8022608 <execute_probe+0x294>)
 80225bc:	789b      	ldrb	r3, [r3, #2]
 80225be:	4916      	ldr	r1, [pc, #88]	; (8022618 <execute_probe+0x2a4>)
 80225c0:	3302      	adds	r3, #2
 80225c2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
                gc_set_tool_offset(ToolLengthOffset_EnableDynamic, plane.axis_linear,
 80225c6:	1ad3      	subs	r3, r2, r3
 80225c8:	461a      	mov	r2, r3
 80225ca:	4601      	mov	r1, r0
 80225cc:	2002      	movs	r0, #2
 80225ce:	f7e3 fa4f 	bl	8005a70 <gc_set_tool_offset>

            ok = restore();
 80225d2:	f7ff fdeb 	bl	80221ac <restore>
 80225d6:	4603      	mov	r3, r0
 80225d8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        }
    }

    change_completed();
 80225dc:	f7ff fd4e 	bl	802207c <change_completed>

    if(ok)
 80225e0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80225e4:	2b00      	cmp	r3, #0
 80225e6:	d004      	beq.n	80225f2 <execute_probe+0x27e>
        system_set_exec_state_flag(EXEC_CYCLE_START);
 80225e8:	4b0c      	ldr	r3, [pc, #48]	; (802261c <execute_probe+0x2a8>)
 80225ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80225ec:	2102      	movs	r1, #2
 80225ee:	480c      	ldr	r0, [pc, #48]	; (8022620 <execute_probe+0x2ac>)
 80225f0:	4798      	blx	r3
#endif
}
 80225f2:	bf00      	nop
 80225f4:	374c      	adds	r7, #76	; 0x4c
 80225f6:	46bd      	mov	sp, r7
 80225f8:	bd90      	pop	{r4, r7, pc}
 80225fa:	bf00      	nop
 80225fc:	2000213d 	.word	0x2000213d
 8022600:	20000dd4 	.word	0x20000dd4
 8022604:	2000215c 	.word	0x2000215c
 8022608:	20002160 	.word	0x20002160
 802260c:	20002164 	.word	0x20002164
 8022610:	2000147c 	.word	0x2000147c
 8022614:	20000d74 	.word	0x20000d74
 8022618:	20000d3c 	.word	0x20000d3c
 802261c:	20000ed0 	.word	0x20000ed0
 8022620:	20000d84 	.word	0x20000d84

08022624 <trap_control_cycle_start>:

// Trap cycle start commands and redirect to foreground process
// by adding the function to be called to the realtime execution queue.
ISR_CODE static void ISR_FUNC(trap_control_cycle_start)(control_signals_t signals)
{
 8022624:	b580      	push	{r7, lr}
 8022626:	b082      	sub	sp, #8
 8022628:	af00      	add	r7, sp, #0
 802262a:	80b8      	strh	r0, [r7, #4]
    spin_lock++;
 802262c:	4b1f      	ldr	r3, [pc, #124]	; (80226ac <trap_control_cycle_start+0x88>)
 802262e:	681b      	ldr	r3, [r3, #0]
 8022630:	3301      	adds	r3, #1
 8022632:	4a1e      	ldr	r2, [pc, #120]	; (80226ac <trap_control_cycle_start+0x88>)
 8022634:	6013      	str	r3, [r2, #0]

    if(signals.cycle_start) {
 8022636:	793b      	ldrb	r3, [r7, #4]
 8022638:	f003 0304 	and.w	r3, r3, #4
 802263c:	b2db      	uxtb	r3, r3
 802263e:	2b00      	cmp	r3, #0
 8022640:	d026      	beq.n	8022690 <trap_control_cycle_start+0x6c>
        if(!execute_posted) {
 8022642:	4b1b      	ldr	r3, [pc, #108]	; (80226b0 <trap_control_cycle_start+0x8c>)
 8022644:	781b      	ldrb	r3, [r3, #0]
 8022646:	b2db      	uxtb	r3, r3
 8022648:	f083 0301 	eor.w	r3, r3, #1
 802264c:	b2db      	uxtb	r3, r3
 802264e:	2b00      	cmp	r3, #0
 8022650:	d019      	beq.n	8022686 <trap_control_cycle_start+0x62>
            if(!block_cycle_start)
 8022652:	4b18      	ldr	r3, [pc, #96]	; (80226b4 <trap_control_cycle_start+0x90>)
 8022654:	781b      	ldrb	r3, [r3, #0]
 8022656:	f083 0301 	eor.w	r3, r3, #1
 802265a:	b2db      	uxtb	r3, r3
 802265c:	2b00      	cmp	r3, #0
 802265e:	d00f      	beq.n	8022680 <trap_control_cycle_start+0x5c>
                execute_posted = protocol_enqueue_rt_command(settings.tool_change.mode == ToolChange_SemiAutomatic ? execute_probe : execute_restore);
 8022660:	4b15      	ldr	r3, [pc, #84]	; (80226b8 <trap_control_cycle_start+0x94>)
 8022662:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022666:	2b03      	cmp	r3, #3
 8022668:	d101      	bne.n	802266e <trap_control_cycle_start+0x4a>
 802266a:	4b14      	ldr	r3, [pc, #80]	; (80226bc <trap_control_cycle_start+0x98>)
 802266c:	e000      	b.n	8022670 <trap_control_cycle_start+0x4c>
 802266e:	4b14      	ldr	r3, [pc, #80]	; (80226c0 <trap_control_cycle_start+0x9c>)
 8022670:	4618      	mov	r0, r3
 8022672:	f7f1 fbbb 	bl	8013dec <protocol_enqueue_rt_command>
 8022676:	4603      	mov	r3, r0
 8022678:	461a      	mov	r2, r3
 802267a:	4b0d      	ldr	r3, [pc, #52]	; (80226b0 <trap_control_cycle_start+0x8c>)
 802267c:	701a      	strb	r2, [r3, #0]
 802267e:	e002      	b.n	8022686 <trap_control_cycle_start+0x62>
            else
                protocol_enqueue_rt_command(execute_warning);
 8022680:	4810      	ldr	r0, [pc, #64]	; (80226c4 <trap_control_cycle_start+0xa0>)
 8022682:	f7f1 fbb3 	bl	8013dec <protocol_enqueue_rt_command>
        }
        signals.cycle_start = Off;
 8022686:	793b      	ldrb	r3, [r7, #4]
 8022688:	f36f 0382 	bfc	r3, #2, #1
 802268c:	713b      	strb	r3, [r7, #4]
 802268e:	e003      	b.n	8022698 <trap_control_cycle_start+0x74>
    } else
        control_interrupt_callback(signals);
 8022690:	4b0d      	ldr	r3, [pc, #52]	; (80226c8 <trap_control_cycle_start+0xa4>)
 8022692:	681b      	ldr	r3, [r3, #0]
 8022694:	88b8      	ldrh	r0, [r7, #4]
 8022696:	4798      	blx	r3

    spin_lock--;
 8022698:	4b04      	ldr	r3, [pc, #16]	; (80226ac <trap_control_cycle_start+0x88>)
 802269a:	681b      	ldr	r3, [r3, #0]
 802269c:	3b01      	subs	r3, #1
 802269e:	4a03      	ldr	r2, [pc, #12]	; (80226ac <trap_control_cycle_start+0x88>)
 80226a0:	6013      	str	r3, [r2, #0]
}
 80226a2:	bf00      	nop
 80226a4:	3708      	adds	r7, #8
 80226a6:	46bd      	mov	sp, r7
 80226a8:	bd80      	pop	{r7, pc}
 80226aa:	bf00      	nop
 80226ac:	20002140 	.word	0x20002140
 80226b0:	2000213e 	.word	0x2000213e
 80226b4:	2000213c 	.word	0x2000213c
 80226b8:	2000147c 	.word	0x2000147c
 80226bc:	08022375 	.word	0x08022375
 80226c0:	08022325 	.word	0x08022325
 80226c4:	08022309 	.word	0x08022309
 80226c8:	20002184 	.word	0x20002184

080226cc <trap_stream_cycle_start>:

ISR_CODE static bool ISR_FUNC(trap_stream_cycle_start)(char c)
{
 80226cc:	b580      	push	{r7, lr}
 80226ce:	b084      	sub	sp, #16
 80226d0:	af00      	add	r7, sp, #0
 80226d2:	4603      	mov	r3, r0
 80226d4:	71fb      	strb	r3, [r7, #7]
    bool drop = false;
 80226d6:	2300      	movs	r3, #0
 80226d8:	73fb      	strb	r3, [r7, #15]

    spin_lock++;
 80226da:	4b25      	ldr	r3, [pc, #148]	; (8022770 <trap_stream_cycle_start+0xa4>)
 80226dc:	681b      	ldr	r3, [r3, #0]
 80226de:	3301      	adds	r3, #1
 80226e0:	4a23      	ldr	r2, [pc, #140]	; (8022770 <trap_stream_cycle_start+0xa4>)
 80226e2:	6013      	str	r3, [r2, #0]

    if((drop = (c == CMD_CYCLE_START || c == CMD_CYCLE_START_LEGACY))) {
 80226e4:	79fb      	ldrb	r3, [r7, #7]
 80226e6:	2b81      	cmp	r3, #129	; 0x81
 80226e8:	d002      	beq.n	80226f0 <trap_stream_cycle_start+0x24>
 80226ea:	79fb      	ldrb	r3, [r7, #7]
 80226ec:	2b7e      	cmp	r3, #126	; 0x7e
 80226ee:	d101      	bne.n	80226f4 <trap_stream_cycle_start+0x28>
 80226f0:	2301      	movs	r3, #1
 80226f2:	e000      	b.n	80226f6 <trap_stream_cycle_start+0x2a>
 80226f4:	2300      	movs	r3, #0
 80226f6:	73fb      	strb	r3, [r7, #15]
 80226f8:	7bfb      	ldrb	r3, [r7, #15]
 80226fa:	f003 0301 	and.w	r3, r3, #1
 80226fe:	73fb      	strb	r3, [r7, #15]
 8022700:	7bfb      	ldrb	r3, [r7, #15]
 8022702:	2b00      	cmp	r3, #0
 8022704:	d022      	beq.n	802274c <trap_stream_cycle_start+0x80>
        if(!execute_posted) {
 8022706:	4b1b      	ldr	r3, [pc, #108]	; (8022774 <trap_stream_cycle_start+0xa8>)
 8022708:	781b      	ldrb	r3, [r3, #0]
 802270a:	b2db      	uxtb	r3, r3
 802270c:	f083 0301 	eor.w	r3, r3, #1
 8022710:	b2db      	uxtb	r3, r3
 8022712:	2b00      	cmp	r3, #0
 8022714:	d021      	beq.n	802275a <trap_stream_cycle_start+0x8e>
            if(!block_cycle_start)
 8022716:	4b18      	ldr	r3, [pc, #96]	; (8022778 <trap_stream_cycle_start+0xac>)
 8022718:	781b      	ldrb	r3, [r3, #0]
 802271a:	f083 0301 	eor.w	r3, r3, #1
 802271e:	b2db      	uxtb	r3, r3
 8022720:	2b00      	cmp	r3, #0
 8022722:	d00f      	beq.n	8022744 <trap_stream_cycle_start+0x78>
                execute_posted = protocol_enqueue_rt_command(settings.tool_change.mode == ToolChange_SemiAutomatic ? execute_probe : execute_restore);
 8022724:	4b15      	ldr	r3, [pc, #84]	; (802277c <trap_stream_cycle_start+0xb0>)
 8022726:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 802272a:	2b03      	cmp	r3, #3
 802272c:	d101      	bne.n	8022732 <trap_stream_cycle_start+0x66>
 802272e:	4b14      	ldr	r3, [pc, #80]	; (8022780 <trap_stream_cycle_start+0xb4>)
 8022730:	e000      	b.n	8022734 <trap_stream_cycle_start+0x68>
 8022732:	4b14      	ldr	r3, [pc, #80]	; (8022784 <trap_stream_cycle_start+0xb8>)
 8022734:	4618      	mov	r0, r3
 8022736:	f7f1 fb59 	bl	8013dec <protocol_enqueue_rt_command>
 802273a:	4603      	mov	r3, r0
 802273c:	461a      	mov	r2, r3
 802273e:	4b0d      	ldr	r3, [pc, #52]	; (8022774 <trap_stream_cycle_start+0xa8>)
 8022740:	701a      	strb	r2, [r3, #0]
 8022742:	e00a      	b.n	802275a <trap_stream_cycle_start+0x8e>
            else
                protocol_enqueue_rt_command(execute_warning);
 8022744:	4810      	ldr	r0, [pc, #64]	; (8022788 <trap_stream_cycle_start+0xbc>)
 8022746:	f7f1 fb51 	bl	8013dec <protocol_enqueue_rt_command>
 802274a:	e006      	b.n	802275a <trap_stream_cycle_start+0x8e>
        }
    } else
        drop = enqueue_realtime_command(c);
 802274c:	4b0f      	ldr	r3, [pc, #60]	; (802278c <trap_stream_cycle_start+0xc0>)
 802274e:	681b      	ldr	r3, [r3, #0]
 8022750:	79fa      	ldrb	r2, [r7, #7]
 8022752:	4610      	mov	r0, r2
 8022754:	4798      	blx	r3
 8022756:	4603      	mov	r3, r0
 8022758:	73fb      	strb	r3, [r7, #15]

    spin_lock--;
 802275a:	4b05      	ldr	r3, [pc, #20]	; (8022770 <trap_stream_cycle_start+0xa4>)
 802275c:	681b      	ldr	r3, [r3, #0]
 802275e:	3b01      	subs	r3, #1
 8022760:	4a03      	ldr	r2, [pc, #12]	; (8022770 <trap_stream_cycle_start+0xa4>)
 8022762:	6013      	str	r3, [r2, #0]

    return drop;
 8022764:	7bfb      	ldrb	r3, [r7, #15]
}
 8022766:	4618      	mov	r0, r3
 8022768:	3710      	adds	r7, #16
 802276a:	46bd      	mov	sp, r7
 802276c:	bd80      	pop	{r7, pc}
 802276e:	bf00      	nop
 8022770:	20002140 	.word	0x20002140
 8022774:	2000213e 	.word	0x2000213e
 8022778:	2000213c 	.word	0x2000213c
 802277c:	2000147c 	.word	0x2000147c
 8022780:	08022375 	.word	0x08022375
 8022784:	08022325 	.word	0x08022325
 8022788:	08022309 	.word	0x08022309
 802278c:	20002180 	.word	0x20002180

08022790 <on_toolchange_ack>:

// Trap cycle start command and control signal when tool change is acknowledged by sender.
ISR_CODE static void ISR_FUNC(on_toolchange_ack)(void)
{
 8022790:	b580      	push	{r7, lr}
 8022792:	af00      	add	r7, sp, #0
    control_interrupt_callback = hal.control.interrupt_callback;
 8022794:	4b08      	ldr	r3, [pc, #32]	; (80227b8 <on_toolchange_ack+0x28>)
 8022796:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8022798:	4a08      	ldr	r2, [pc, #32]	; (80227bc <on_toolchange_ack+0x2c>)
 802279a:	6013      	str	r3, [r2, #0]
    hal.control.interrupt_callback = trap_control_cycle_start;
 802279c:	4b06      	ldr	r3, [pc, #24]	; (80227b8 <on_toolchange_ack+0x28>)
 802279e:	4a08      	ldr	r2, [pc, #32]	; (80227c0 <on_toolchange_ack+0x30>)
 80227a0:	66da      	str	r2, [r3, #108]	; 0x6c
    enqueue_realtime_command = hal.stream.set_enqueue_rt_handler(trap_stream_cycle_start);
 80227a2:	4b05      	ldr	r3, [pc, #20]	; (80227b8 <on_toolchange_ack+0x28>)
 80227a4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 80227a8:	4806      	ldr	r0, [pc, #24]	; (80227c4 <on_toolchange_ack+0x34>)
 80227aa:	4798      	blx	r3
 80227ac:	4603      	mov	r3, r0
 80227ae:	4a06      	ldr	r2, [pc, #24]	; (80227c8 <on_toolchange_ack+0x38>)
 80227b0:	6013      	str	r3, [r2, #0]

}
 80227b2:	bf00      	nop
 80227b4:	bd80      	pop	{r7, pc}
 80227b6:	bf00      	nop
 80227b8:	20000ed0 	.word	0x20000ed0
 80227bc:	20002184 	.word	0x20002184
 80227c0:	08022625 	.word	0x08022625
 80227c4:	080226cd 	.word	0x080226cd
 80227c8:	20002180 	.word	0x20002180

080227cc <tool_select>:

// Set next and/or current tool. Called by gcode.c on on a Tn or M61 command (via HAL).
static void tool_select (tool_data_t *tool, bool next)
{
 80227cc:	b580      	push	{r7, lr}
 80227ce:	b082      	sub	sp, #8
 80227d0:	af00      	add	r7, sp, #0
 80227d2:	6078      	str	r0, [r7, #4]
 80227d4:	460b      	mov	r3, r1
 80227d6:	70fb      	strb	r3, [r7, #3]
    next_tool = tool;
 80227d8:	4a08      	ldr	r2, [pc, #32]	; (80227fc <tool_select+0x30>)
 80227da:	687b      	ldr	r3, [r7, #4]
 80227dc:	6013      	str	r3, [r2, #0]
    if(!next)
 80227de:	78fb      	ldrb	r3, [r7, #3]
 80227e0:	f083 0301 	eor.w	r3, r3, #1
 80227e4:	b2db      	uxtb	r3, r3
 80227e6:	2b00      	cmp	r3, #0
 80227e8:	d004      	beq.n	80227f4 <tool_select+0x28>
        memcpy(&current_tool, tool, sizeof(tool_data_t));
 80227ea:	2214      	movs	r2, #20
 80227ec:	6879      	ldr	r1, [r7, #4]
 80227ee:	4804      	ldr	r0, [pc, #16]	; (8022800 <tool_select+0x34>)
 80227f0:	f001 fb6d 	bl	8023ece <memcpy>
}
 80227f4:	bf00      	nop
 80227f6:	3708      	adds	r7, #8
 80227f8:	46bd      	mov	sp, r7
 80227fa:	bd80      	pop	{r7, pc}
 80227fc:	2000215c 	.word	0x2000215c
 8022800:	20002148 	.word	0x20002148

08022804 <tool_change>:

// Start a tool change sequence. Called by gcode.c on a M6 command (via HAL).
static status_code_t tool_change (parser_state_t *parser_state)
{
 8022804:	b590      	push	{r4, r7, lr}
 8022806:	b091      	sub	sp, #68	; 0x44
 8022808:	af00      	add	r7, sp, #0
 802280a:	6078      	str	r0, [r7, #4]
    if(next_tool == NULL)
 802280c:	4b83      	ldr	r3, [pc, #524]	; (8022a1c <tool_change+0x218>)
 802280e:	681b      	ldr	r3, [r3, #0]
 8022810:	2b00      	cmp	r3, #0
 8022812:	d101      	bne.n	8022818 <tool_change+0x14>
        return Status_GCodeToolError;
 8022814:	232f      	movs	r3, #47	; 0x2f
 8022816:	e0fd      	b.n	8022a14 <tool_change+0x210>

    if(current_tool.tool_id == next_tool->tool_id)
 8022818:	4b81      	ldr	r3, [pc, #516]	; (8022a20 <tool_change+0x21c>)
 802281a:	691a      	ldr	r2, [r3, #16]
 802281c:	4b7f      	ldr	r3, [pc, #508]	; (8022a1c <tool_change+0x218>)
 802281e:	681b      	ldr	r3, [r3, #0]
 8022820:	691b      	ldr	r3, [r3, #16]
 8022822:	429a      	cmp	r2, r3
 8022824:	d101      	bne.n	802282a <tool_change+0x26>
        return Status_OK;
 8022826:	2300      	movs	r3, #0
 8022828:	e0f4      	b.n	8022a14 <tool_change+0x210>
  #else
    plane.axis_0 = X_AXIS;
    plane.axis_1 = Y_AXIS;
  #endif
#else
    gc_get_plane_data(&plane, parser_state->modal.plane_select);
 802282a:	687b      	ldr	r3, [r7, #4]
 802282c:	799b      	ldrb	r3, [r3, #6]
 802282e:	4619      	mov	r1, r3
 8022830:	487c      	ldr	r0, [pc, #496]	; (8022a24 <tool_change+0x220>)
 8022832:	f7e3 f9b7 	bl	8005ba4 <gc_get_plane_data>
#endif

    uint8_t homed_req = settings.tool_change.mode == ToolChange_Manual ? bit(plane.axis_linear) : (X_AXIS_BIT|Y_AXIS_BIT|Z_AXIS_BIT);
 8022836:	4b7c      	ldr	r3, [pc, #496]	; (8022a28 <tool_change+0x224>)
 8022838:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 802283c:	2b01      	cmp	r3, #1
 802283e:	d106      	bne.n	802284e <tool_change+0x4a>
 8022840:	4b78      	ldr	r3, [pc, #480]	; (8022a24 <tool_change+0x220>)
 8022842:	789b      	ldrb	r3, [r3, #2]
 8022844:	461a      	mov	r2, r3
 8022846:	2301      	movs	r3, #1
 8022848:	4093      	lsls	r3, r2
 802284a:	b2db      	uxtb	r3, r3
 802284c:	e000      	b.n	8022850 <tool_change+0x4c>
 802284e:	2307      	movs	r3, #7
 8022850:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

    if((sys.homed.mask & homed_req) != homed_req)
 8022854:	4b75      	ldr	r3, [pc, #468]	; (8022a2c <tool_change+0x228>)
 8022856:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 802285a:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 802285e:	4013      	ands	r3, r2
 8022860:	b2db      	uxtb	r3, r3
 8022862:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 8022866:	429a      	cmp	r2, r3
 8022868:	d001      	beq.n	802286e <tool_change+0x6a>
        return Status_HomingRequired;
 802286a:	232e      	movs	r3, #46	; 0x2e
 802286c:	e0d2      	b.n	8022a14 <tool_change+0x210>

    if(settings.tool_change.mode != ToolChange_SemiAutomatic)
 802286e:	4b6e      	ldr	r3, [pc, #440]	; (8022a28 <tool_change+0x224>)
 8022870:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022874:	2b03      	cmp	r3, #3
 8022876:	d003      	beq.n	8022880 <tool_change+0x7c>
        grbl.on_probe_completed = on_probe_completed;
 8022878:	4b6d      	ldr	r3, [pc, #436]	; (8022a30 <tool_change+0x22c>)
 802287a:	4a6e      	ldr	r2, [pc, #440]	; (8022a34 <tool_change+0x230>)
 802287c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    block_cycle_start = settings.tool_change.mode != ToolChange_SemiAutomatic;
 8022880:	4b69      	ldr	r3, [pc, #420]	; (8022a28 <tool_change+0x224>)
 8022882:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022886:	2b03      	cmp	r3, #3
 8022888:	bf14      	ite	ne
 802288a:	2301      	movne	r3, #1
 802288c:	2300      	moveq	r3, #0
 802288e:	b2da      	uxtb	r2, r3
 8022890:	4b69      	ldr	r3, [pc, #420]	; (8022a38 <tool_change+0x234>)
 8022892:	701a      	strb	r2, [r3, #0]

    // Stop spindle and coolant.
    spindle_all_off();
 8022894:	f7fa fc1c 	bl	801d0d0 <spindle_all_off>
    hal.coolant.set_state((coolant_state_t){0});
 8022898:	4b68      	ldr	r3, [pc, #416]	; (8022a3c <tool_change+0x238>)
 802289a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802289c:	2200      	movs	r2, #0
 802289e:	4610      	mov	r0, r2
 80228a0:	4798      	blx	r3

    execute_posted = false;
 80228a2:	4b67      	ldr	r3, [pc, #412]	; (8022a40 <tool_change+0x23c>)
 80228a4:	2200      	movs	r2, #0
 80228a6:	701a      	strb	r2, [r3, #0]
    probe_fixture = grbl.on_probe_fixture != NULL &&
 80228a8:	4b61      	ldr	r3, [pc, #388]	; (8022a30 <tool_change+0x22c>)
 80228aa:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80228ae:	2b00      	cmp	r3, #0
 80228b0:	d010      	beq.n	80228d4 <tool_change+0xd0>
                     (settings.tool_change.mode == ToolChange_Manual ||
 80228b2:	4b5d      	ldr	r3, [pc, #372]	; (8022a28 <tool_change+0x224>)
 80228b4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    probe_fixture = grbl.on_probe_fixture != NULL &&
 80228b8:	2b01      	cmp	r3, #1
 80228ba:	d009      	beq.n	80228d0 <tool_change+0xcc>
                       settings.tool_change.mode == ToolChange_Manual_G59_3 ||
 80228bc:	4b5a      	ldr	r3, [pc, #360]	; (8022a28 <tool_change+0x224>)
 80228be:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
                     (settings.tool_change.mode == ToolChange_Manual ||
 80228c2:	2b02      	cmp	r3, #2
 80228c4:	d004      	beq.n	80228d0 <tool_change+0xcc>
                        settings.tool_change.mode == ToolChange_SemiAutomatic);
 80228c6:	4b58      	ldr	r3, [pc, #352]	; (8022a28 <tool_change+0x224>)
 80228c8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
                       settings.tool_change.mode == ToolChange_Manual_G59_3 ||
 80228cc:	2b03      	cmp	r3, #3
 80228ce:	d101      	bne.n	80228d4 <tool_change+0xd0>
    probe_fixture = grbl.on_probe_fixture != NULL &&
 80228d0:	2301      	movs	r3, #1
 80228d2:	e000      	b.n	80228d6 <tool_change+0xd2>
 80228d4:	2300      	movs	r3, #0
 80228d6:	f003 0301 	and.w	r3, r3, #1
 80228da:	b2da      	uxtb	r2, r3
 80228dc:	4b59      	ldr	r3, [pc, #356]	; (8022a44 <tool_change+0x240>)
 80228de:	701a      	strb	r2, [r3, #0]

    // Save current position.
    system_convert_array_steps_to_mpos(previous.values, sys.position);
 80228e0:	4959      	ldr	r1, [pc, #356]	; (8022a48 <tool_change+0x244>)
 80228e2:	485a      	ldr	r0, [pc, #360]	; (8022a4c <tool_change+0x248>)
 80228e4:	f7ff fa94 	bl	8021e10 <system_convert_array_steps_to_mpos>

    // Establish axis assignments.

    previous.values[plane.axis_linear] -= gc_get_offset(plane.axis_linear);
 80228e8:	4b4e      	ldr	r3, [pc, #312]	; (8022a24 <tool_change+0x220>)
 80228ea:	789b      	ldrb	r3, [r3, #2]
 80228ec:	4618      	mov	r0, r3
 80228ee:	f7e3 f875 	bl	80059dc <gc_get_offset>
 80228f2:	4602      	mov	r2, r0
 80228f4:	4b4b      	ldr	r3, [pc, #300]	; (8022a24 <tool_change+0x220>)
 80228f6:	789b      	ldrb	r3, [r3, #2]
 80228f8:	4619      	mov	r1, r3
 80228fa:	4b54      	ldr	r3, [pc, #336]	; (8022a4c <tool_change+0x248>)
 80228fc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8022900:	4948      	ldr	r1, [pc, #288]	; (8022a24 <tool_change+0x220>)
 8022902:	7889      	ldrb	r1, [r1, #2]
 8022904:	460c      	mov	r4, r1
 8022906:	4611      	mov	r1, r2
 8022908:	4618      	mov	r0, r3
 802290a:	f7de f949 	bl	8000ba0 <__aeabi_fsub>
 802290e:	4603      	mov	r3, r0
 8022910:	461a      	mov	r2, r3
 8022912:	4b4e      	ldr	r3, [pc, #312]	; (8022a4c <tool_change+0x248>)
 8022914:	f843 2024 	str.w	r2, [r3, r4, lsl #2]

    plan_line_data_t plan_data;

    plan_data_init(&plan_data);
 8022918:	f107 030c 	add.w	r3, r7, #12
 802291c:	4618      	mov	r0, r3
 802291e:	f7ef fd45 	bl	80123ac <plan_data_init>
    plan_data.condition.rapid_motion = On;
 8022922:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8022926:	f043 0301 	orr.w	r3, r3, #1
 802292a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    // TODO: add?
    //if(!settings.homing.flags.force_set_origin && bit_istrue(settings.homing.dir_mask.value, bit(plane.axis_linear)))
    //    tool_change_position = ?
    //else

    tool_change_position = sys.home_position[plane.axis_linear]; // - settings.homing.flags.force_set_origin ? LINEAR_AXIS_HOME_OFFSET : 0.0f;
 802292e:	4b3d      	ldr	r3, [pc, #244]	; (8022a24 <tool_change+0x220>)
 8022930:	789b      	ldrb	r3, [r3, #2]
 8022932:	4a3e      	ldr	r2, [pc, #248]	; (8022a2c <tool_change+0x228>)
 8022934:	3316      	adds	r3, #22
 8022936:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802293a:	4a45      	ldr	r2, [pc, #276]	; (8022a50 <tool_change+0x24c>)
 802293c:	6013      	str	r3, [r2, #0]

    // Rapid to home position of linear axis.
    memcpy(&target, &previous, sizeof(coord_data_t));
 802293e:	4b45      	ldr	r3, [pc, #276]	; (8022a54 <tool_change+0x250>)
 8022940:	4a42      	ldr	r2, [pc, #264]	; (8022a4c <tool_change+0x248>)
 8022942:	ca07      	ldmia	r2, {r0, r1, r2}
 8022944:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    target.values[plane.axis_linear] = tool_change_position;
 8022948:	4b36      	ldr	r3, [pc, #216]	; (8022a24 <tool_change+0x220>)
 802294a:	789b      	ldrb	r3, [r3, #2]
 802294c:	4619      	mov	r1, r3
 802294e:	4b40      	ldr	r3, [pc, #256]	; (8022a50 <tool_change+0x24c>)
 8022950:	681b      	ldr	r3, [r3, #0]
 8022952:	4a40      	ldr	r2, [pc, #256]	; (8022a54 <tool_change+0x250>)
 8022954:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    if(!mc_line(target.values, &plan_data))
 8022958:	f107 030c 	add.w	r3, r7, #12
 802295c:	4619      	mov	r1, r3
 802295e:	483d      	ldr	r0, [pc, #244]	; (8022a54 <tool_change+0x250>)
 8022960:	f7eb f84a 	bl	800d9f8 <mc_line>
 8022964:	4603      	mov	r3, r0
 8022966:	f083 0301 	eor.w	r3, r3, #1
 802296a:	b2db      	uxtb	r3, r3
 802296c:	2b00      	cmp	r3, #0
 802296e:	d001      	beq.n	8022974 <tool_change+0x170>
        return Status_Reset;
 8022970:	2312      	movs	r3, #18
 8022972:	e04f      	b.n	8022a14 <tool_change+0x210>

#if COMPATIBILITY_LEVEL <= 1
    if(settings.tool_change.mode == ToolChange_Manual_G59_3) {
 8022974:	4b2c      	ldr	r3, [pc, #176]	; (8022a28 <tool_change+0x224>)
 8022976:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 802297a:	2b02      	cmp	r3, #2
 802297c:	d135      	bne.n	80229ea <tool_change+0x1e6>

        // G59.3 contains offsets to tool change position.
        settings_read_coord_data(CoordinateSystem_G59_3, &target.values);
 802297e:	4935      	ldr	r1, [pc, #212]	; (8022a54 <tool_change+0x250>)
 8022980:	2008      	movs	r0, #8
 8022982:	f7f8 f949 	bl	801ac18 <settings_read_coord_data>

        float tmp_pos = target.values[plane.axis_linear];
 8022986:	4b27      	ldr	r3, [pc, #156]	; (8022a24 <tool_change+0x220>)
 8022988:	789b      	ldrb	r3, [r3, #2]
 802298a:	461a      	mov	r2, r3
 802298c:	4b31      	ldr	r3, [pc, #196]	; (8022a54 <tool_change+0x250>)
 802298e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022992:	63bb      	str	r3, [r7, #56]	; 0x38

        target.values[plane.axis_linear] = tool_change_position;
 8022994:	4b23      	ldr	r3, [pc, #140]	; (8022a24 <tool_change+0x220>)
 8022996:	789b      	ldrb	r3, [r3, #2]
 8022998:	4619      	mov	r1, r3
 802299a:	4b2d      	ldr	r3, [pc, #180]	; (8022a50 <tool_change+0x24c>)
 802299c:	681b      	ldr	r3, [r3, #0]
 802299e:	4a2d      	ldr	r2, [pc, #180]	; (8022a54 <tool_change+0x250>)
 80229a0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if(!mc_line(target.values, &plan_data))
 80229a4:	f107 030c 	add.w	r3, r7, #12
 80229a8:	4619      	mov	r1, r3
 80229aa:	482a      	ldr	r0, [pc, #168]	; (8022a54 <tool_change+0x250>)
 80229ac:	f7eb f824 	bl	800d9f8 <mc_line>
 80229b0:	4603      	mov	r3, r0
 80229b2:	f083 0301 	eor.w	r3, r3, #1
 80229b6:	b2db      	uxtb	r3, r3
 80229b8:	2b00      	cmp	r3, #0
 80229ba:	d001      	beq.n	80229c0 <tool_change+0x1bc>
            return Status_Reset;
 80229bc:	2312      	movs	r3, #18
 80229be:	e029      	b.n	8022a14 <tool_change+0x210>

        target.values[plane.axis_linear] = tmp_pos;
 80229c0:	4b18      	ldr	r3, [pc, #96]	; (8022a24 <tool_change+0x220>)
 80229c2:	789b      	ldrb	r3, [r3, #2]
 80229c4:	4619      	mov	r1, r3
 80229c6:	4a23      	ldr	r2, [pc, #140]	; (8022a54 <tool_change+0x250>)
 80229c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80229ca:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if(!mc_line(target.values, &plan_data))
 80229ce:	f107 030c 	add.w	r3, r7, #12
 80229d2:	4619      	mov	r1, r3
 80229d4:	481f      	ldr	r0, [pc, #124]	; (8022a54 <tool_change+0x250>)
 80229d6:	f7eb f80f 	bl	800d9f8 <mc_line>
 80229da:	4603      	mov	r3, r0
 80229dc:	f083 0301 	eor.w	r3, r3, #1
 80229e0:	b2db      	uxtb	r3, r3
 80229e2:	2b00      	cmp	r3, #0
 80229e4:	d001      	beq.n	80229ea <tool_change+0x1e6>
            return Status_Reset;
 80229e6:	2312      	movs	r3, #18
 80229e8:	e014      	b.n	8022a14 <tool_change+0x210>
    }
#endif

    protocol_buffer_synchronize();
 80229ea:	f7f0 f989 	bl	8012d00 <protocol_buffer_synchronize>
    sync_position();
 80229ee:	f7ef fbf9 	bl	80121e4 <plan_sync_position>
 80229f2:	4915      	ldr	r1, [pc, #84]	; (8022a48 <tool_change+0x244>)
 80229f4:	4818      	ldr	r0, [pc, #96]	; (8022a58 <tool_change+0x254>)
 80229f6:	f7ff fa0b 	bl	8021e10 <system_convert_array_steps_to_mpos>

    // Enter tool change mode, waits for cycle start to continue.
    parser_state->tool_change = true;
 80229fa:	687b      	ldr	r3, [r7, #4]
 80229fc:	2201      	movs	r2, #1
 80229fe:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
    system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 8022a02:	4b0e      	ldr	r3, [pc, #56]	; (8022a3c <tool_change+0x238>)
 8022a04:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8022a06:	f44f 7100 	mov.w	r1, #512	; 0x200
 8022a0a:	4814      	ldr	r0, [pc, #80]	; (8022a5c <tool_change+0x258>)
 8022a0c:	4798      	blx	r3
    protocol_execute_realtime();                    // Execute...
 8022a0e:	f7f0 f9a7 	bl	8012d60 <protocol_execute_realtime>

    return Status_OK;
 8022a12:	2300      	movs	r3, #0
}
 8022a14:	4618      	mov	r0, r3
 8022a16:	3744      	adds	r7, #68	; 0x44
 8022a18:	46bd      	mov	sp, r7
 8022a1a:	bd90      	pop	{r4, r7, pc}
 8022a1c:	2000215c 	.word	0x2000215c
 8022a20:	20002148 	.word	0x20002148
 8022a24:	20002160 	.word	0x20002160
 8022a28:	2000147c 	.word	0x2000147c
 8022a2c:	20000d3c 	.word	0x20000d3c
 8022a30:	20000dd4 	.word	0x20000dd4
 8022a34:	08022011 	.word	0x08022011
 8022a38:	2000213c 	.word	0x2000213c
 8022a3c:	20000ed0 	.word	0x20000ed0
 8022a40:	2000213e 	.word	0x2000213e
 8022a44:	2000213d 	.word	0x2000213d
 8022a48:	20000dc4 	.word	0x20000dc4
 8022a4c:	20002170 	.word	0x20002170
 8022a50:	20002144 	.word	0x20002144
 8022a54:	20002164 	.word	0x20002164
 8022a58:	20000c0c 	.word	0x20000c0c
 8022a5c:	20000d84 	.word	0x20000d84

08022a60 <tc_init>:

// Claim HAL tool change entry points and clear current tool offsets.
// TODO: change to survive a warm reset?
void tc_init (void)
{
 8022a60:	b580      	push	{r7, lr}
 8022a62:	af00      	add	r7, sp, #0
    if(hal.driver_cap.atc) // Do not override driver tool change implementation!
 8022a64:	4b28      	ldr	r3, [pc, #160]	; (8022b08 <tc_init+0xa8>)
 8022a66:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
 8022a6a:	f003 0304 	and.w	r3, r3, #4
 8022a6e:	b2db      	uxtb	r3, r3
 8022a70:	2b00      	cmp	r3, #0
 8022a72:	d145      	bne.n	8022b00 <tc_init+0xa0>
        return;

    if(!hal.stream.suspend_read) // Tool change requires support for suspending input stream.
 8022a74:	4b24      	ldr	r3, [pc, #144]	; (8022b08 <tc_init+0xa8>)
 8022a76:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8022a7a:	2b00      	cmp	r3, #0
 8022a7c:	d042      	beq.n	8022b04 <tc_init+0xa4>
        return;

    if(sys.tlo_reference_set.mask != 0) {
 8022a7e:	4b23      	ldr	r3, [pc, #140]	; (8022b0c <tc_init+0xac>)
 8022a80:	79db      	ldrb	r3, [r3, #7]
 8022a82:	2b00      	cmp	r3, #0
 8022a84:	d006      	beq.n	8022a94 <tc_init+0x34>
        sys.tlo_reference_set.mask = 0;
 8022a86:	4b21      	ldr	r3, [pc, #132]	; (8022b0c <tc_init+0xac>)
 8022a88:	2200      	movs	r2, #0
 8022a8a:	71da      	strb	r2, [r3, #7]
        system_add_rt_report(Report_TLOReference);
 8022a8c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8022a90:	f7ff fa84 	bl	8021f9c <system_add_rt_report>
    }

    gc_set_tool_offset(ToolLengthOffset_Cancel, 0, 0.0f);
 8022a94:	2200      	movs	r2, #0
 8022a96:	2100      	movs	r1, #0
 8022a98:	2000      	movs	r0, #0
 8022a9a:	f7e2 ffe9 	bl	8005a70 <gc_set_tool_offset>

    if(settings.tool_change.mode == ToolChange_Disabled || settings.tool_change.mode == ToolChange_Ignore) {
 8022a9e:	4b1c      	ldr	r3, [pc, #112]	; (8022b10 <tc_init+0xb0>)
 8022aa0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022aa4:	2b00      	cmp	r3, #0
 8022aa6:	d004      	beq.n	8022ab2 <tc_init+0x52>
 8022aa8:	4b19      	ldr	r3, [pc, #100]	; (8022b10 <tc_init+0xb0>)
 8022aaa:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022aae:	2b04      	cmp	r3, #4
 8022ab0:	d10c      	bne.n	8022acc <tc_init+0x6c>
        hal.tool.select = NULL;
 8022ab2:	4b15      	ldr	r3, [pc, #84]	; (8022b08 <tc_init+0xa8>)
 8022ab4:	2200      	movs	r2, #0
 8022ab6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        hal.tool.change = NULL;
 8022aba:	4b13      	ldr	r3, [pc, #76]	; (8022b08 <tc_init+0xa8>)
 8022abc:	2200      	movs	r2, #0
 8022abe:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        grbl.on_toolchange_ack = NULL;
 8022ac2:	4b14      	ldr	r3, [pc, #80]	; (8022b14 <tc_init+0xb4>)
 8022ac4:	2200      	movs	r2, #0
 8022ac6:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
 8022aca:	e01c      	b.n	8022b06 <tc_init+0xa6>
    } else {
        hal.tool.select = tool_select;
 8022acc:	4b0e      	ldr	r3, [pc, #56]	; (8022b08 <tc_init+0xa8>)
 8022ace:	4a12      	ldr	r2, [pc, #72]	; (8022b18 <tc_init+0xb8>)
 8022ad0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        hal.tool.change = tool_change;
 8022ad4:	4b0c      	ldr	r3, [pc, #48]	; (8022b08 <tc_init+0xa8>)
 8022ad6:	4a11      	ldr	r2, [pc, #68]	; (8022b1c <tc_init+0xbc>)
 8022ad8:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        grbl.on_toolchange_ack = on_toolchange_ack;
 8022adc:	4b0d      	ldr	r3, [pc, #52]	; (8022b14 <tc_init+0xb4>)
 8022ade:	4a10      	ldr	r2, [pc, #64]	; (8022b20 <tc_init+0xc0>)
 8022ae0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        if(driver_reset == NULL) {
 8022ae4:	4b0f      	ldr	r3, [pc, #60]	; (8022b24 <tc_init+0xc4>)
 8022ae6:	681b      	ldr	r3, [r3, #0]
 8022ae8:	2b00      	cmp	r3, #0
 8022aea:	d10c      	bne.n	8022b06 <tc_init+0xa6>
            driver_reset = hal.driver_reset;
 8022aec:	4b06      	ldr	r3, [pc, #24]	; (8022b08 <tc_init+0xa8>)
 8022aee:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8022af2:	4a0c      	ldr	r2, [pc, #48]	; (8022b24 <tc_init+0xc4>)
 8022af4:	6013      	str	r3, [r2, #0]
            hal.driver_reset = reset;
 8022af6:	4b04      	ldr	r3, [pc, #16]	; (8022b08 <tc_init+0xa8>)
 8022af8:	4a0b      	ldr	r2, [pc, #44]	; (8022b28 <tc_init+0xc8>)
 8022afa:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
 8022afe:	e002      	b.n	8022b06 <tc_init+0xa6>
        return;
 8022b00:	bf00      	nop
 8022b02:	e000      	b.n	8022b06 <tc_init+0xa6>
        return;
 8022b04:	bf00      	nop
        }
    }
}
 8022b06:	bd80      	pop	{r7, pc}
 8022b08:	20000ed0 	.word	0x20000ed0
 8022b0c:	20000d3c 	.word	0x20000d3c
 8022b10:	2000147c 	.word	0x2000147c
 8022b14:	20000dd4 	.word	0x20000dd4
 8022b18:	080227cd 	.word	0x080227cd
 8022b1c:	08022805 	.word	0x08022805
 8022b20:	08022791 	.word	0x08022791
 8022b24:	2000217c 	.word	0x2000217c
 8022b28:	08022131 	.word	0x08022131

08022b2c <tc_clear_tlo_reference>:

void tc_clear_tlo_reference (axes_signals_t homing_cycle)
{
 8022b2c:	b580      	push	{r7, lr}
 8022b2e:	b084      	sub	sp, #16
 8022b30:	af00      	add	r7, sp, #0
 8022b32:	7138      	strb	r0, [r7, #4]
    if(settings.tool_change.mode != ToolChange_Disabled) {
 8022b34:	4b15      	ldr	r3, [pc, #84]	; (8022b8c <tc_clear_tlo_reference+0x60>)
 8022b36:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022b3a:	2b00      	cmp	r3, #0
 8022b3c:	d021      	beq.n	8022b82 <tc_clear_tlo_reference+0x56>
        plane_t plane;

#if TOOL_LENGTH_OFFSET_AXIS >= 0
        plane.axis_linear = TOOL_LENGTH_OFFSET_AXIS;
#else
        gc_get_plane_data(&plane, gc_state.modal.plane_select);
 8022b3e:	4b14      	ldr	r3, [pc, #80]	; (8022b90 <tc_clear_tlo_reference+0x64>)
 8022b40:	799a      	ldrb	r2, [r3, #6]
 8022b42:	f107 030c 	add.w	r3, r7, #12
 8022b46:	4611      	mov	r1, r2
 8022b48:	4618      	mov	r0, r3
 8022b4a:	f7e3 f82b 	bl	8005ba4 <gc_get_plane_data>
#endif
        if(homing_cycle.mask & (settings.mode == Mode_Lathe ? (X_AXIS_BIT|Z_AXIS_BIT) : bit(plane.axis_linear))) {
 8022b4e:	793b      	ldrb	r3, [r7, #4]
 8022b50:	461a      	mov	r2, r3
 8022b52:	4b0e      	ldr	r3, [pc, #56]	; (8022b8c <tc_clear_tlo_reference+0x60>)
 8022b54:	7e1b      	ldrb	r3, [r3, #24]
 8022b56:	2b02      	cmp	r3, #2
 8022b58:	d004      	beq.n	8022b64 <tc_clear_tlo_reference+0x38>
 8022b5a:	7bbb      	ldrb	r3, [r7, #14]
 8022b5c:	4619      	mov	r1, r3
 8022b5e:	2301      	movs	r3, #1
 8022b60:	408b      	lsls	r3, r1
 8022b62:	e000      	b.n	8022b66 <tc_clear_tlo_reference+0x3a>
 8022b64:	2305      	movs	r3, #5
 8022b66:	4013      	ands	r3, r2
 8022b68:	2b00      	cmp	r3, #0
 8022b6a:	d00a      	beq.n	8022b82 <tc_clear_tlo_reference+0x56>
            if(sys.tlo_reference_set.mask != 0) {
 8022b6c:	4b09      	ldr	r3, [pc, #36]	; (8022b94 <tc_clear_tlo_reference+0x68>)
 8022b6e:	79db      	ldrb	r3, [r3, #7]
 8022b70:	2b00      	cmp	r3, #0
 8022b72:	d006      	beq.n	8022b82 <tc_clear_tlo_reference+0x56>
                sys.tlo_reference_set.mask = 0;  // Invalidate tool length offset reference
 8022b74:	4b07      	ldr	r3, [pc, #28]	; (8022b94 <tc_clear_tlo_reference+0x68>)
 8022b76:	2200      	movs	r2, #0
 8022b78:	71da      	strb	r2, [r3, #7]
                system_add_rt_report(Report_TLOReference);
 8022b7a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8022b7e:	f7ff fa0d 	bl	8021f9c <system_add_rt_report>
            }
        }
    }
}
 8022b82:	bf00      	nop
 8022b84:	3710      	adds	r7, #16
 8022b86:	46bd      	mov	sp, r7
 8022b88:	bd80      	pop	{r7, pc}
 8022b8a:	bf00      	nop
 8022b8c:	2000147c 	.word	0x2000147c
 8022b90:	20000bb0 	.word	0x20000bb0
 8022b94:	20000d3c 	.word	0x20000d3c

08022b98 <tc_probe_workpiece>:

// Perform a probe cycle: set tool length offset and restart job if successful.
// Note: tool length offset is set by the on_probe_completed event handler.
// Called by the $TPW system command.
status_code_t tc_probe_workpiece (void)
{
 8022b98:	b5b0      	push	{r4, r5, r7, lr}
 8022b9a:	b08c      	sub	sp, #48	; 0x30
 8022b9c:	af00      	add	r7, sp, #0
    if(!(settings.tool_change.mode == ToolChange_Manual || settings.tool_change.mode == ToolChange_Manual_G59_3) || enqueue_realtime_command == NULL)
 8022b9e:	4b85      	ldr	r3, [pc, #532]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022ba0:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022ba4:	2b01      	cmp	r3, #1
 8022ba6:	d004      	beq.n	8022bb2 <tc_probe_workpiece+0x1a>
 8022ba8:	4b82      	ldr	r3, [pc, #520]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022baa:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8022bae:	2b02      	cmp	r3, #2
 8022bb0:	d103      	bne.n	8022bba <tc_probe_workpiece+0x22>
 8022bb2:	4b81      	ldr	r3, [pc, #516]	; (8022db8 <tc_probe_workpiece+0x220>)
 8022bb4:	681b      	ldr	r3, [r3, #0]
 8022bb6:	2b00      	cmp	r3, #0
 8022bb8:	d101      	bne.n	8022bbe <tc_probe_workpiece+0x26>
        return Status_InvalidStatement;
 8022bba:	2303      	movs	r3, #3
 8022bbc:	e0f5      	b.n	8022daa <tc_probe_workpiece+0x212>

    // TODO: add check for reference offset set?

    bool ok;
    gc_parser_flags_t flags = {0};
 8022bbe:	2300      	movs	r3, #0
 8022bc0:	85bb      	strh	r3, [r7, #44]	; 0x2c
    plan_line_data_t plan_data;

#if COMPATIBILITY_LEVEL <= 1
    if(probe_fixture)
 8022bc2:	4b7e      	ldr	r3, [pc, #504]	; (8022dbc <tc_probe_workpiece+0x224>)
 8022bc4:	781b      	ldrb	r3, [r3, #0]
 8022bc6:	2b00      	cmp	r3, #0
 8022bc8:	d00d      	beq.n	8022be6 <tc_probe_workpiece+0x4e>
        grbl.on_probe_fixture(next_tool, system_xy_at_fixture(CoordinateSystem_G59_3, TOOLSETTER_RADIUS), true);
 8022bca:	4b7d      	ldr	r3, [pc, #500]	; (8022dc0 <tc_probe_workpiece+0x228>)
 8022bcc:	f8d3 4098 	ldr.w	r4, [r3, #152]	; 0x98
 8022bd0:	4b7c      	ldr	r3, [pc, #496]	; (8022dc4 <tc_probe_workpiece+0x22c>)
 8022bd2:	681d      	ldr	r5, [r3, #0]
 8022bd4:	497c      	ldr	r1, [pc, #496]	; (8022dc8 <tc_probe_workpiece+0x230>)
 8022bd6:	2008      	movs	r0, #8
 8022bd8:	f7ff f92a 	bl	8021e30 <system_xy_at_fixture>
 8022bdc:	4603      	mov	r3, r0
 8022bde:	2201      	movs	r2, #1
 8022be0:	4619      	mov	r1, r3
 8022be2:	4628      	mov	r0, r5
 8022be4:	47a0      	blx	r4
#endif

    // Get current position.
    system_convert_array_steps_to_mpos(target.values, sys.position);
 8022be6:	4979      	ldr	r1, [pc, #484]	; (8022dcc <tc_probe_workpiece+0x234>)
 8022be8:	4879      	ldr	r0, [pc, #484]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022bea:	f7ff f911 	bl	8021e10 <system_convert_array_steps_to_mpos>

    flags.probe_is_no_error = On;
 8022bee:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8022bf2:	f043 0310 	orr.w	r3, r3, #16
 8022bf6:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c

    plan_data_init(&plan_data);
 8022bfa:	463b      	mov	r3, r7
 8022bfc:	4618      	mov	r0, r3
 8022bfe:	f7ef fbd5 	bl	80123ac <plan_data_init>
    plan_data.feed_rate = settings.tool_change.seek_rate;
 8022c02:	4b6c      	ldr	r3, [pc, #432]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022c04:	6a1b      	ldr	r3, [r3, #32]
 8022c06:	603b      	str	r3, [r7, #0]

    target.values[plane.axis_linear] -= settings.tool_change.probing_distance;
 8022c08:	4b72      	ldr	r3, [pc, #456]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022c0a:	789b      	ldrb	r3, [r3, #2]
 8022c0c:	461a      	mov	r2, r3
 8022c0e:	4b70      	ldr	r3, [pc, #448]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022c14:	4a67      	ldr	r2, [pc, #412]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022c16:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8022c18:	496e      	ldr	r1, [pc, #440]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022c1a:	7889      	ldrb	r1, [r1, #2]
 8022c1c:	460c      	mov	r4, r1
 8022c1e:	4611      	mov	r1, r2
 8022c20:	4618      	mov	r0, r3
 8022c22:	f7dd ffbd 	bl	8000ba0 <__aeabi_fsub>
 8022c26:	4603      	mov	r3, r0
 8022c28:	461a      	mov	r2, r3
 8022c2a:	4b69      	ldr	r3, [pc, #420]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c2c:	f843 2024 	str.w	r2, [r3, r4, lsl #2]

    if((ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found))
 8022c30:	463b      	mov	r3, r7
 8022c32:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8022c34:	4619      	mov	r1, r3
 8022c36:	4866      	ldr	r0, [pc, #408]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c38:	f7ec fb8e 	bl	800f358 <mc_probe_cycle>
 8022c3c:	4603      	mov	r3, r0
 8022c3e:	2b01      	cmp	r3, #1
 8022c40:	bf0c      	ite	eq
 8022c42:	2301      	moveq	r3, #1
 8022c44:	2300      	movne	r3, #0
 8022c46:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8022c4a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8022c4e:	2b00      	cmp	r3, #0
 8022c50:	f000 8086 	beq.w	8022d60 <tc_probe_workpiece+0x1c8>
    {
        system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 8022c54:	4960      	ldr	r1, [pc, #384]	; (8022dd8 <tc_probe_workpiece+0x240>)
 8022c56:	485e      	ldr	r0, [pc, #376]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c58:	f7ff f8da 	bl	8021e10 <system_convert_array_steps_to_mpos>

        // Retract a bit and perform slow probe.
        plan_data.feed_rate = settings.tool_change.pulloff_rate;
 8022c5c:	4b55      	ldr	r3, [pc, #340]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022c5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022c60:	603b      	str	r3, [r7, #0]
        target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE;
 8022c62:	4b5c      	ldr	r3, [pc, #368]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022c64:	789b      	ldrb	r3, [r3, #2]
 8022c66:	461a      	mov	r2, r3
 8022c68:	4b59      	ldr	r3, [pc, #356]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022c6e:	4a59      	ldr	r2, [pc, #356]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022c70:	7892      	ldrb	r2, [r2, #2]
 8022c72:	4614      	mov	r4, r2
 8022c74:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8022c78:	4618      	mov	r0, r3
 8022c7a:	f7dd ff93 	bl	8000ba4 <__addsf3>
 8022c7e:	4603      	mov	r3, r0
 8022c80:	461a      	mov	r2, r3
 8022c82:	4b53      	ldr	r3, [pc, #332]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c84:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
        if((ok = mc_line(target.values, &plan_data))) {
 8022c88:	463b      	mov	r3, r7
 8022c8a:	4619      	mov	r1, r3
 8022c8c:	4850      	ldr	r0, [pc, #320]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022c8e:	f7ea feb3 	bl	800d9f8 <mc_line>
 8022c92:	4603      	mov	r3, r0
 8022c94:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8022c98:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8022c9c:	2b00      	cmp	r3, #0
 8022c9e:	d05f      	beq.n	8022d60 <tc_probe_workpiece+0x1c8>

            plan_data.feed_rate = settings.tool_change.feed_rate;
 8022ca0:	4b44      	ldr	r3, [pc, #272]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022ca2:	69db      	ldr	r3, [r3, #28]
 8022ca4:	603b      	str	r3, [r7, #0]
            target.values[plane.axis_linear] -= (TOOL_CHANGE_PROBE_RETRACT_DISTANCE + 2.0f);
 8022ca6:	4b4b      	ldr	r3, [pc, #300]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022ca8:	789b      	ldrb	r3, [r3, #2]
 8022caa:	461a      	mov	r2, r3
 8022cac:	4b48      	ldr	r3, [pc, #288]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022cae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022cb2:	4a48      	ldr	r2, [pc, #288]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022cb4:	7892      	ldrb	r2, [r2, #2]
 8022cb6:	4614      	mov	r4, r2
 8022cb8:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 8022cbc:	4618      	mov	r0, r3
 8022cbe:	f7dd ff6f 	bl	8000ba0 <__aeabi_fsub>
 8022cc2:	4603      	mov	r3, r0
 8022cc4:	461a      	mov	r2, r3
 8022cc6:	4b42      	ldr	r3, [pc, #264]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022cc8:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
            if((ok = mc_probe_cycle(target.values, &plan_data, flags) == GCProbe_Found)) {
 8022ccc:	463b      	mov	r3, r7
 8022cce:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8022cd0:	4619      	mov	r1, r3
 8022cd2:	483f      	ldr	r0, [pc, #252]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022cd4:	f7ec fb40 	bl	800f358 <mc_probe_cycle>
 8022cd8:	4603      	mov	r3, r0
 8022cda:	2b01      	cmp	r3, #1
 8022cdc:	bf0c      	ite	eq
 8022cde:	2301      	moveq	r3, #1
 8022ce0:	2300      	movne	r3, #0
 8022ce2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8022ce6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8022cea:	2b00      	cmp	r3, #0
 8022cec:	d038      	beq.n	8022d60 <tc_probe_workpiece+0x1c8>
                // Retract a bit again so that any touch plate can be removed
                system_convert_array_steps_to_mpos(target.values, sys.probe_position);
 8022cee:	493a      	ldr	r1, [pc, #232]	; (8022dd8 <tc_probe_workpiece+0x240>)
 8022cf0:	4837      	ldr	r0, [pc, #220]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022cf2:	f7ff f88d 	bl	8021e10 <system_convert_array_steps_to_mpos>
                plan_data.feed_rate = settings.tool_change.seek_rate;
 8022cf6:	4b2f      	ldr	r3, [pc, #188]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022cf8:	6a1b      	ldr	r3, [r3, #32]
 8022cfa:	603b      	str	r3, [r7, #0]
                target.values[plane.axis_linear] += TOOL_CHANGE_PROBE_RETRACT_DISTANCE * 2.0f;
 8022cfc:	4b35      	ldr	r3, [pc, #212]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022cfe:	789b      	ldrb	r3, [r3, #2]
 8022d00:	461a      	mov	r2, r3
 8022d02:	4b33      	ldr	r3, [pc, #204]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022d04:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022d08:	4a32      	ldr	r2, [pc, #200]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022d0a:	7892      	ldrb	r2, [r2, #2]
 8022d0c:	4614      	mov	r4, r2
 8022d0e:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 8022d12:	4618      	mov	r0, r3
 8022d14:	f7dd ff46 	bl	8000ba4 <__addsf3>
 8022d18:	4603      	mov	r3, r0
 8022d1a:	461a      	mov	r2, r3
 8022d1c:	4b2c      	ldr	r3, [pc, #176]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022d1e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
                if(target.values[plane.axis_linear] > tool_change_position)
 8022d22:	4b2c      	ldr	r3, [pc, #176]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022d24:	789b      	ldrb	r3, [r3, #2]
 8022d26:	461a      	mov	r2, r3
 8022d28:	4b29      	ldr	r3, [pc, #164]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022d2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8022d2e:	4a2b      	ldr	r2, [pc, #172]	; (8022ddc <tc_probe_workpiece+0x244>)
 8022d30:	6812      	ldr	r2, [r2, #0]
 8022d32:	4611      	mov	r1, r2
 8022d34:	4618      	mov	r0, r3
 8022d36:	f7de f9f9 	bl	800112c <__aeabi_fcmpgt>
 8022d3a:	4603      	mov	r3, r0
 8022d3c:	2b00      	cmp	r3, #0
 8022d3e:	d007      	beq.n	8022d50 <tc_probe_workpiece+0x1b8>
                    target.values[plane.axis_linear] = tool_change_position;
 8022d40:	4b24      	ldr	r3, [pc, #144]	; (8022dd4 <tc_probe_workpiece+0x23c>)
 8022d42:	789b      	ldrb	r3, [r3, #2]
 8022d44:	4619      	mov	r1, r3
 8022d46:	4b25      	ldr	r3, [pc, #148]	; (8022ddc <tc_probe_workpiece+0x244>)
 8022d48:	681b      	ldr	r3, [r3, #0]
 8022d4a:	4a21      	ldr	r2, [pc, #132]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022d4c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
                ok = mc_line(target.values, &plan_data);
 8022d50:	463b      	mov	r3, r7
 8022d52:	4619      	mov	r1, r3
 8022d54:	481e      	ldr	r0, [pc, #120]	; (8022dd0 <tc_probe_workpiece+0x238>)
 8022d56:	f7ea fe4f 	bl	800d9f8 <mc_line>
 8022d5a:	4603      	mov	r3, r0
 8022d5c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            }
        }
    }

    if(ok && protocol_buffer_synchronize()) {
 8022d60:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8022d64:	2b00      	cmp	r3, #0
 8022d66:	d019      	beq.n	8022d9c <tc_probe_workpiece+0x204>
 8022d68:	f7ef ffca 	bl	8012d00 <protocol_buffer_synchronize>
 8022d6c:	4603      	mov	r3, r0
 8022d6e:	2b00      	cmp	r3, #0
 8022d70:	d014      	beq.n	8022d9c <tc_probe_workpiece+0x204>
        sync_position();
 8022d72:	f7ef fa37 	bl	80121e4 <plan_sync_position>
 8022d76:	4915      	ldr	r1, [pc, #84]	; (8022dcc <tc_probe_workpiece+0x234>)
 8022d78:	4819      	ldr	r0, [pc, #100]	; (8022de0 <tc_probe_workpiece+0x248>)
 8022d7a:	f7ff f849 	bl	8021e10 <system_convert_array_steps_to_mpos>
        block_cycle_start = false;
 8022d7e:	4b19      	ldr	r3, [pc, #100]	; (8022de4 <tc_probe_workpiece+0x24c>)
 8022d80:	2200      	movs	r2, #0
 8022d82:	701a      	strb	r2, [r3, #0]
        grbl.report.feedback_message(settings.tool_change.mode == ToolChange_Manual_G59_3
 8022d84:	4b0e      	ldr	r3, [pc, #56]	; (8022dc0 <tc_probe_workpiece+0x228>)
 8022d86:	68db      	ldr	r3, [r3, #12]
 8022d88:	4a0a      	ldr	r2, [pc, #40]	; (8022db4 <tc_probe_workpiece+0x21c>)
 8022d8a:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8022d8e:	2a02      	cmp	r2, #2
 8022d90:	d101      	bne.n	8022d96 <tc_probe_workpiece+0x1fe>
 8022d92:	2211      	movs	r2, #17
 8022d94:	e000      	b.n	8022d98 <tc_probe_workpiece+0x200>
 8022d96:	2212      	movs	r2, #18
 8022d98:	4610      	mov	r0, r2
 8022d9a:	4798      	blx	r3
                                      ? Message_CycleStart2Continue
                                      : Message_TPCycleStart2Continue);
    }

    return ok ? Status_OK : Status_GCodeToolError;
 8022d9c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8022da0:	2b00      	cmp	r3, #0
 8022da2:	d001      	beq.n	8022da8 <tc_probe_workpiece+0x210>
 8022da4:	2300      	movs	r3, #0
 8022da6:	e000      	b.n	8022daa <tc_probe_workpiece+0x212>
 8022da8:	232f      	movs	r3, #47	; 0x2f
}
 8022daa:	4618      	mov	r0, r3
 8022dac:	3730      	adds	r7, #48	; 0x30
 8022dae:	46bd      	mov	sp, r7
 8022db0:	bdb0      	pop	{r4, r5, r7, pc}
 8022db2:	bf00      	nop
 8022db4:	2000147c 	.word	0x2000147c
 8022db8:	20002180 	.word	0x20002180
 8022dbc:	2000213d 	.word	0x2000213d
 8022dc0:	20000dd4 	.word	0x20000dd4
 8022dc4:	2000215c 	.word	0x2000215c
 8022dc8:	40a00000 	.word	0x40a00000
 8022dcc:	20000dc4 	.word	0x20000dc4
 8022dd0:	20002164 	.word	0x20002164
 8022dd4:	20002160 	.word	0x20002160
 8022dd8:	20000d74 	.word	0x20000d74
 8022ddc:	20002144 	.word	0x20002144
 8022de0:	20000c0c 	.word	0x20000c0c
 8022de4:	2000213c 	.word	0x2000213c

08022de8 <corexy_convert_to_a_motor_steps>:

static on_report_options_ptr on_report_options;

// Returns x or y-axis "steps" based on CoreXY motor steps.
inline static int32_t corexy_convert_to_a_motor_steps (int32_t *steps)
{
 8022de8:	b480      	push	{r7}
 8022dea:	b083      	sub	sp, #12
 8022dec:	af00      	add	r7, sp, #0
 8022dee:	6078      	str	r0, [r7, #4]
    return (steps[A_MOTOR] + steps[B_MOTOR]) >> 1;
 8022df0:	687b      	ldr	r3, [r7, #4]
 8022df2:	681a      	ldr	r2, [r3, #0]
 8022df4:	687b      	ldr	r3, [r7, #4]
 8022df6:	3304      	adds	r3, #4
 8022df8:	681b      	ldr	r3, [r3, #0]
 8022dfa:	4413      	add	r3, r2
 8022dfc:	105b      	asrs	r3, r3, #1
}
 8022dfe:	4618      	mov	r0, r3
 8022e00:	370c      	adds	r7, #12
 8022e02:	46bd      	mov	sp, r7
 8022e04:	bc80      	pop	{r7}
 8022e06:	4770      	bx	lr

08022e08 <corexy_convert_to_b_motor_steps>:

inline static int32_t corexy_convert_to_b_motor_steps (int32_t *steps)
{
 8022e08:	b480      	push	{r7}
 8022e0a:	b083      	sub	sp, #12
 8022e0c:	af00      	add	r7, sp, #0
 8022e0e:	6078      	str	r0, [r7, #4]
    return (steps[A_MOTOR] - steps[B_MOTOR]) >> 1;
 8022e10:	687b      	ldr	r3, [r7, #4]
 8022e12:	681a      	ldr	r2, [r3, #0]
 8022e14:	687b      	ldr	r3, [r7, #4]
 8022e16:	3304      	adds	r3, #4
 8022e18:	681b      	ldr	r3, [r3, #0]
 8022e1a:	1ad3      	subs	r3, r2, r3
 8022e1c:	105b      	asrs	r3, r3, #1
}
 8022e1e:	4618      	mov	r0, r3
 8022e20:	370c      	adds	r7, #12
 8022e22:	46bd      	mov	sp, r7
 8022e24:	bc80      	pop	{r7}
 8022e26:	4770      	bx	lr

08022e28 <corexy_convert_array_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
static float *corexy_convert_array_steps_to_mpos (float *position, int32_t *steps)
{
 8022e28:	b590      	push	{r4, r7, lr}
 8022e2a:	b085      	sub	sp, #20
 8022e2c:	af00      	add	r7, sp, #0
 8022e2e:	6078      	str	r0, [r7, #4]
 8022e30:	6039      	str	r1, [r7, #0]
    uint_fast8_t idx;

    position[X_AXIS] = corexy_convert_to_a_motor_steps(steps) / settings.axis[X_AXIS].steps_per_mm;
 8022e32:	6838      	ldr	r0, [r7, #0]
 8022e34:	f7ff ffd8 	bl	8022de8 <corexy_convert_to_a_motor_steps>
 8022e38:	4603      	mov	r3, r0
 8022e3a:	4618      	mov	r0, r3
 8022e3c:	f7dd ff66 	bl	8000d0c <__aeabi_i2f>
 8022e40:	4602      	mov	r2, r0
 8022e42:	4b20      	ldr	r3, [pc, #128]	; (8022ec4 <corexy_convert_array_steps_to_mpos+0x9c>)
 8022e44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022e46:	4619      	mov	r1, r3
 8022e48:	4610      	mov	r0, r2
 8022e4a:	f7de f867 	bl	8000f1c <__aeabi_fdiv>
 8022e4e:	4603      	mov	r3, r0
 8022e50:	461a      	mov	r2, r3
 8022e52:	687b      	ldr	r3, [r7, #4]
 8022e54:	601a      	str	r2, [r3, #0]
    position[Y_AXIS] = corexy_convert_to_b_motor_steps(steps) / settings.axis[Y_AXIS].steps_per_mm;
 8022e56:	6838      	ldr	r0, [r7, #0]
 8022e58:	f7ff ffd6 	bl	8022e08 <corexy_convert_to_b_motor_steps>
 8022e5c:	4603      	mov	r3, r0
 8022e5e:	4618      	mov	r0, r3
 8022e60:	f7dd ff54 	bl	8000d0c <__aeabi_i2f>
 8022e64:	4b17      	ldr	r3, [pc, #92]	; (8022ec4 <corexy_convert_array_steps_to_mpos+0x9c>)
 8022e66:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8022e68:	687b      	ldr	r3, [r7, #4]
 8022e6a:	1d1c      	adds	r4, r3, #4
 8022e6c:	4611      	mov	r1, r2
 8022e6e:	f7de f855 	bl	8000f1c <__aeabi_fdiv>
 8022e72:	4603      	mov	r3, r0
 8022e74:	6023      	str	r3, [r4, #0]

    for(idx = Z_AXIS; idx < N_AXIS; idx++)
 8022e76:	2302      	movs	r3, #2
 8022e78:	60fb      	str	r3, [r7, #12]
 8022e7a:	e01b      	b.n	8022eb4 <corexy_convert_array_steps_to_mpos+0x8c>
        position[idx] = steps[idx] / settings.axis[idx].steps_per_mm;
 8022e7c:	68fb      	ldr	r3, [r7, #12]
 8022e7e:	009b      	lsls	r3, r3, #2
 8022e80:	683a      	ldr	r2, [r7, #0]
 8022e82:	4413      	add	r3, r2
 8022e84:	681b      	ldr	r3, [r3, #0]
 8022e86:	4618      	mov	r0, r3
 8022e88:	f7dd ff40 	bl	8000d0c <__aeabi_i2f>
 8022e8c:	490d      	ldr	r1, [pc, #52]	; (8022ec4 <corexy_convert_array_steps_to_mpos+0x9c>)
 8022e8e:	68fa      	ldr	r2, [r7, #12]
 8022e90:	4613      	mov	r3, r2
 8022e92:	009b      	lsls	r3, r3, #2
 8022e94:	4413      	add	r3, r2
 8022e96:	009b      	lsls	r3, r3, #2
 8022e98:	440b      	add	r3, r1
 8022e9a:	3330      	adds	r3, #48	; 0x30
 8022e9c:	6819      	ldr	r1, [r3, #0]
 8022e9e:	68fb      	ldr	r3, [r7, #12]
 8022ea0:	009b      	lsls	r3, r3, #2
 8022ea2:	687a      	ldr	r2, [r7, #4]
 8022ea4:	18d4      	adds	r4, r2, r3
 8022ea6:	f7de f839 	bl	8000f1c <__aeabi_fdiv>
 8022eaa:	4603      	mov	r3, r0
 8022eac:	6023      	str	r3, [r4, #0]
    for(idx = Z_AXIS; idx < N_AXIS; idx++)
 8022eae:	68fb      	ldr	r3, [r7, #12]
 8022eb0:	3301      	adds	r3, #1
 8022eb2:	60fb      	str	r3, [r7, #12]
 8022eb4:	68fb      	ldr	r3, [r7, #12]
 8022eb6:	2b02      	cmp	r3, #2
 8022eb8:	d9e0      	bls.n	8022e7c <corexy_convert_array_steps_to_mpos+0x54>

    return position;
 8022eba:	687b      	ldr	r3, [r7, #4]
}
 8022ebc:	4618      	mov	r0, r3
 8022ebe:	3714      	adds	r7, #20
 8022ec0:	46bd      	mov	sp, r7
 8022ec2:	bd90      	pop	{r4, r7, pc}
 8022ec4:	2000147c 	.word	0x2000147c

08022ec8 <transform_from_cartesian>:

// Transform position from cartesian coordinate system to corexy coordinate system
static inline float *transform_from_cartesian (float *target, float *position)
{
 8022ec8:	b590      	push	{r4, r7, lr}
 8022eca:	b085      	sub	sp, #20
 8022ecc:	af00      	add	r7, sp, #0
 8022ece:	6078      	str	r0, [r7, #4]
 8022ed0:	6039      	str	r1, [r7, #0]
    uint_fast8_t idx;

    target[X_AXIS] = position[X_AXIS] + position[Y_AXIS];
 8022ed2:	683b      	ldr	r3, [r7, #0]
 8022ed4:	681a      	ldr	r2, [r3, #0]
 8022ed6:	683b      	ldr	r3, [r7, #0]
 8022ed8:	3304      	adds	r3, #4
 8022eda:	681b      	ldr	r3, [r3, #0]
 8022edc:	4619      	mov	r1, r3
 8022ede:	4610      	mov	r0, r2
 8022ee0:	f7dd fe60 	bl	8000ba4 <__addsf3>
 8022ee4:	4603      	mov	r3, r0
 8022ee6:	461a      	mov	r2, r3
 8022ee8:	687b      	ldr	r3, [r7, #4]
 8022eea:	601a      	str	r2, [r3, #0]
    target[Y_AXIS] = position[X_AXIS] - position[Y_AXIS];
 8022eec:	683b      	ldr	r3, [r7, #0]
 8022eee:	681a      	ldr	r2, [r3, #0]
 8022ef0:	683b      	ldr	r3, [r7, #0]
 8022ef2:	3304      	adds	r3, #4
 8022ef4:	6819      	ldr	r1, [r3, #0]
 8022ef6:	687b      	ldr	r3, [r7, #4]
 8022ef8:	1d1c      	adds	r4, r3, #4
 8022efa:	4610      	mov	r0, r2
 8022efc:	f7dd fe50 	bl	8000ba0 <__aeabi_fsub>
 8022f00:	4603      	mov	r3, r0
 8022f02:	6023      	str	r3, [r4, #0]

    for(idx = Z_AXIS; idx < N_AXIS; idx++)
 8022f04:	2302      	movs	r3, #2
 8022f06:	60fb      	str	r3, [r7, #12]
 8022f08:	e00c      	b.n	8022f24 <transform_from_cartesian+0x5c>
        target[idx] = position[idx];
 8022f0a:	68fb      	ldr	r3, [r7, #12]
 8022f0c:	009b      	lsls	r3, r3, #2
 8022f0e:	683a      	ldr	r2, [r7, #0]
 8022f10:	441a      	add	r2, r3
 8022f12:	68fb      	ldr	r3, [r7, #12]
 8022f14:	009b      	lsls	r3, r3, #2
 8022f16:	6879      	ldr	r1, [r7, #4]
 8022f18:	440b      	add	r3, r1
 8022f1a:	6812      	ldr	r2, [r2, #0]
 8022f1c:	601a      	str	r2, [r3, #0]
    for(idx = Z_AXIS; idx < N_AXIS; idx++)
 8022f1e:	68fb      	ldr	r3, [r7, #12]
 8022f20:	3301      	adds	r3, #1
 8022f22:	60fb      	str	r3, [r7, #12]
 8022f24:	68fb      	ldr	r3, [r7, #12]
 8022f26:	2b02      	cmp	r3, #2
 8022f28:	d9ef      	bls.n	8022f0a <transform_from_cartesian+0x42>

    return target;
 8022f2a:	687b      	ldr	r3, [r7, #4]
}
 8022f2c:	4618      	mov	r0, r3
 8022f2e:	3714      	adds	r7, #20
 8022f30:	46bd      	mov	sp, r7
 8022f32:	bd90      	pop	{r4, r7, pc}

08022f34 <corexy_limits_get_axis_mask>:

static uint_fast8_t corexy_limits_get_axis_mask (uint_fast8_t idx)
{
 8022f34:	b480      	push	{r7}
 8022f36:	b083      	sub	sp, #12
 8022f38:	af00      	add	r7, sp, #0
 8022f3a:	6078      	str	r0, [r7, #4]
    return ((idx == A_MOTOR) || (idx == B_MOTOR)) ? (bit(X_AXIS) | bit(Y_AXIS)) : bit(idx);
 8022f3c:	687b      	ldr	r3, [r7, #4]
 8022f3e:	2b00      	cmp	r3, #0
 8022f40:	d007      	beq.n	8022f52 <corexy_limits_get_axis_mask+0x1e>
 8022f42:	687b      	ldr	r3, [r7, #4]
 8022f44:	2b01      	cmp	r3, #1
 8022f46:	d004      	beq.n	8022f52 <corexy_limits_get_axis_mask+0x1e>
 8022f48:	2201      	movs	r2, #1
 8022f4a:	687b      	ldr	r3, [r7, #4]
 8022f4c:	fa02 f303 	lsl.w	r3, r2, r3
 8022f50:	e000      	b.n	8022f54 <corexy_limits_get_axis_mask+0x20>
 8022f52:	2303      	movs	r3, #3
}
 8022f54:	4618      	mov	r0, r3
 8022f56:	370c      	adds	r7, #12
 8022f58:	46bd      	mov	sp, r7
 8022f5a:	bc80      	pop	{r7}
 8022f5c:	4770      	bx	lr
	...

08022f60 <corexy_limits_set_target_pos>:


static void corexy_limits_set_target_pos (uint_fast8_t idx) // fn name?
{
 8022f60:	b580      	push	{r7, lr}
 8022f62:	b084      	sub	sp, #16
 8022f64:	af00      	add	r7, sp, #0
 8022f66:	6078      	str	r0, [r7, #4]
    int32_t axis_position;

    switch(idx) {
 8022f68:	687b      	ldr	r3, [r7, #4]
 8022f6a:	2b00      	cmp	r3, #0
 8022f6c:	d003      	beq.n	8022f76 <corexy_limits_set_target_pos+0x16>
 8022f6e:	687b      	ldr	r3, [r7, #4]
 8022f70:	2b01      	cmp	r3, #1
 8022f72:	d00e      	beq.n	8022f92 <corexy_limits_set_target_pos+0x32>
 8022f74:	e01b      	b.n	8022fae <corexy_limits_set_target_pos+0x4e>
        case X_AXIS:
            axis_position = corexy_convert_to_b_motor_steps(sys.position);
 8022f76:	4813      	ldr	r0, [pc, #76]	; (8022fc4 <corexy_limits_set_target_pos+0x64>)
 8022f78:	f7ff ff46 	bl	8022e08 <corexy_convert_to_b_motor_steps>
 8022f7c:	60f8      	str	r0, [r7, #12]
            sys.position[A_MOTOR] = axis_position;
 8022f7e:	4a12      	ldr	r2, [pc, #72]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022f80:	68fb      	ldr	r3, [r7, #12]
 8022f82:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
            sys.position[B_MOTOR] = -axis_position;
 8022f86:	68fb      	ldr	r3, [r7, #12]
 8022f88:	425b      	negs	r3, r3
 8022f8a:	4a0f      	ldr	r2, [pc, #60]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022f8c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
            break;
 8022f90:	e014      	b.n	8022fbc <corexy_limits_set_target_pos+0x5c>
        case Y_AXIS:
            sys.position[A_MOTOR] = sys.position[B_MOTOR] = corexy_convert_to_a_motor_steps(sys.position);
 8022f92:	480c      	ldr	r0, [pc, #48]	; (8022fc4 <corexy_limits_set_target_pos+0x64>)
 8022f94:	f7ff ff28 	bl	8022de8 <corexy_convert_to_a_motor_steps>
 8022f98:	4603      	mov	r3, r0
 8022f9a:	4a0b      	ldr	r2, [pc, #44]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022f9c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8022fa0:	4b09      	ldr	r3, [pc, #36]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022fa2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8022fa6:	4a08      	ldr	r2, [pc, #32]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022fa8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
            break;
 8022fac:	e006      	b.n	8022fbc <corexy_limits_set_target_pos+0x5c>
        default:
            sys.position[idx] = 0;
 8022fae:	4a06      	ldr	r2, [pc, #24]	; (8022fc8 <corexy_limits_set_target_pos+0x68>)
 8022fb0:	687b      	ldr	r3, [r7, #4]
 8022fb2:	3322      	adds	r3, #34	; 0x22
 8022fb4:	2100      	movs	r1, #0
 8022fb6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            break;
 8022fba:	bf00      	nop
    }
}
 8022fbc:	bf00      	nop
 8022fbe:	3710      	adds	r7, #16
 8022fc0:	46bd      	mov	sp, r7
 8022fc2:	bd80      	pop	{r7, pc}
 8022fc4:	20000dc4 	.word	0x20000dc4
 8022fc8:	20000d3c 	.word	0x20000d3c

08022fcc <corexy_limits_set_machine_positions>:


// Set machine positions for homed limit switches. Don't update non-homed axes.
// NOTE: settings.max_travel[] is stored as a negative value.
static void corexy_limits_set_machine_positions (axes_signals_t cycle)
{
 8022fcc:	b580      	push	{r7, lr}
 8022fce:	b086      	sub	sp, #24
 8022fd0:	af00      	add	r7, sp, #0
 8022fd2:	7138      	strb	r0, [r7, #4]
    uint_fast8_t idx = N_AXIS;
 8022fd4:	2303      	movs	r3, #3
 8022fd6:	617b      	str	r3, [r7, #20]

    if(settings.homing.flags.force_set_origin) {
 8022fd8:	4b68      	ldr	r3, [pc, #416]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 8022fda:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8022fde:	f003 0308 	and.w	r3, r3, #8
 8022fe2:	b2db      	uxtb	r3, r3
 8022fe4:	2b00      	cmp	r3, #0
 8022fe6:	d03e      	beq.n	8023066 <corexy_limits_set_machine_positions+0x9a>
        if (cycle.mask & bit(--idx)) do {
 8022fe8:	793b      	ldrb	r3, [r7, #4]
 8022fea:	461a      	mov	r2, r3
 8022fec:	697b      	ldr	r3, [r7, #20]
 8022fee:	3b01      	subs	r3, #1
 8022ff0:	617b      	str	r3, [r7, #20]
 8022ff2:	697b      	ldr	r3, [r7, #20]
 8022ff4:	fa22 f303 	lsr.w	r3, r2, r3
 8022ff8:	f003 0301 	and.w	r3, r3, #1
 8022ffc:	2b00      	cmp	r3, #0
 8022ffe:	f000 80b8 	beq.w	8023172 <corexy_limits_set_machine_positions+0x1a6>
            switch(--idx) {
 8023002:	697b      	ldr	r3, [r7, #20]
 8023004:	3b01      	subs	r3, #1
 8023006:	617b      	str	r3, [r7, #20]
 8023008:	697b      	ldr	r3, [r7, #20]
 802300a:	2b00      	cmp	r3, #0
 802300c:	d003      	beq.n	8023016 <corexy_limits_set_machine_positions+0x4a>
 802300e:	697b      	ldr	r3, [r7, #20]
 8023010:	2b01      	cmp	r3, #1
 8023012:	d00f      	beq.n	8023034 <corexy_limits_set_machine_positions+0x68>
 8023014:	e01c      	b.n	8023050 <corexy_limits_set_machine_positions+0x84>
                case X_AXIS:
                    sys.position[A_MOTOR] = corexy_convert_to_b_motor_steps(sys.position);
 8023016:	485a      	ldr	r0, [pc, #360]	; (8023180 <corexy_limits_set_machine_positions+0x1b4>)
 8023018:	f7ff fef6 	bl	8022e08 <corexy_convert_to_b_motor_steps>
 802301c:	4603      	mov	r3, r0
 802301e:	4a59      	ldr	r2, [pc, #356]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023020:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                    sys.position[B_MOTOR] = - sys.position[A_MOTOR];
 8023024:	4b57      	ldr	r3, [pc, #348]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023026:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 802302a:	425b      	negs	r3, r3
 802302c:	4a55      	ldr	r2, [pc, #340]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 802302e:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                    break;
 8023032:	e014      	b.n	802305e <corexy_limits_set_machine_positions+0x92>
                case Y_AXIS:
                    sys.position[A_MOTOR] = corexy_convert_to_a_motor_steps(sys.position);
 8023034:	4852      	ldr	r0, [pc, #328]	; (8023180 <corexy_limits_set_machine_positions+0x1b4>)
 8023036:	f7ff fed7 	bl	8022de8 <corexy_convert_to_a_motor_steps>
 802303a:	4603      	mov	r3, r0
 802303c:	4a51      	ldr	r2, [pc, #324]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 802303e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                    sys.position[B_MOTOR] = sys.position[A_MOTOR];
 8023042:	4b50      	ldr	r3, [pc, #320]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023044:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8023048:	4a4e      	ldr	r2, [pc, #312]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 802304a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                    break;
 802304e:	e006      	b.n	802305e <corexy_limits_set_machine_positions+0x92>
                default:
                    sys.position[idx] = 0;
 8023050:	4a4c      	ldr	r2, [pc, #304]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023052:	697b      	ldr	r3, [r7, #20]
 8023054:	3322      	adds	r3, #34	; 0x22
 8023056:	2100      	movs	r1, #0
 8023058:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    break;
 802305c:	bf00      	nop
            }
        } while (idx);
 802305e:	697b      	ldr	r3, [r7, #20]
 8023060:	2b00      	cmp	r3, #0
 8023062:	d1ce      	bne.n	8023002 <corexy_limits_set_machine_positions+0x36>
                     sys.position[idx] = set_axis_position;
                     break;
             }
         }
    } while(idx);
}
 8023064:	e085      	b.n	8023172 <corexy_limits_set_machine_positions+0x1a6>
         if (cycle.mask & bit(--idx)) {
 8023066:	793b      	ldrb	r3, [r7, #4]
 8023068:	461a      	mov	r2, r3
 802306a:	697b      	ldr	r3, [r7, #20]
 802306c:	3b01      	subs	r3, #1
 802306e:	617b      	str	r3, [r7, #20]
 8023070:	697b      	ldr	r3, [r7, #20]
 8023072:	fa22 f303 	lsr.w	r3, r2, r3
 8023076:	f003 0301 	and.w	r3, r3, #1
 802307a:	2b00      	cmp	r3, #0
 802307c:	d075      	beq.n	802316a <corexy_limits_set_machine_positions+0x19e>
             int32_t set_axis_position = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 802307e:	4b3f      	ldr	r3, [pc, #252]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 8023080:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
 8023084:	461a      	mov	r2, r3
 8023086:	697b      	ldr	r3, [r7, #20]
 8023088:	fa22 f303 	lsr.w	r3, r2, r3
 802308c:	f003 0301 	and.w	r3, r3, #1
                                          : lroundf(-settings.homing.pulloff * settings.axis[idx].steps_per_mm);
 8023090:	2b00      	cmp	r3, #0
 8023092:	d023      	beq.n	80230dc <corexy_limits_set_machine_positions+0x110>
                                          ? lroundf((settings.axis[idx].max_travel + settings.homing.pulloff) * settings.axis[idx].steps_per_mm)
 8023094:	4939      	ldr	r1, [pc, #228]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 8023096:	697a      	ldr	r2, [r7, #20]
 8023098:	4613      	mov	r3, r2
 802309a:	009b      	lsls	r3, r3, #2
 802309c:	4413      	add	r3, r2
 802309e:	009b      	lsls	r3, r3, #2
 80230a0:	440b      	add	r3, r1
 80230a2:	333c      	adds	r3, #60	; 0x3c
 80230a4:	681b      	ldr	r3, [r3, #0]
 80230a6:	4a35      	ldr	r2, [pc, #212]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 80230a8:	f8d2 210c 	ldr.w	r2, [r2, #268]	; 0x10c
 80230ac:	4611      	mov	r1, r2
 80230ae:	4618      	mov	r0, r3
 80230b0:	f7dd fd78 	bl	8000ba4 <__addsf3>
 80230b4:	4603      	mov	r3, r0
 80230b6:	4618      	mov	r0, r3
 80230b8:	4930      	ldr	r1, [pc, #192]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 80230ba:	697a      	ldr	r2, [r7, #20]
 80230bc:	4613      	mov	r3, r2
 80230be:	009b      	lsls	r3, r3, #2
 80230c0:	4413      	add	r3, r2
 80230c2:	009b      	lsls	r3, r3, #2
 80230c4:	440b      	add	r3, r1
 80230c6:	3330      	adds	r3, #48	; 0x30
 80230c8:	681b      	ldr	r3, [r3, #0]
 80230ca:	4619      	mov	r1, r3
 80230cc:	f7dd fe72 	bl	8000db4 <__aeabi_fmul>
 80230d0:	4603      	mov	r3, r0
 80230d2:	4618      	mov	r0, r3
 80230d4:	f001 fd4e 	bl	8024b74 <lroundf>
 80230d8:	4603      	mov	r3, r0
 80230da:	e015      	b.n	8023108 <corexy_limits_set_machine_positions+0x13c>
                                          : lroundf(-settings.homing.pulloff * settings.axis[idx].steps_per_mm);
 80230dc:	4b27      	ldr	r3, [pc, #156]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 80230de:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 80230e2:	f083 4000 	eor.w	r0, r3, #2147483648	; 0x80000000
 80230e6:	4925      	ldr	r1, [pc, #148]	; (802317c <corexy_limits_set_machine_positions+0x1b0>)
 80230e8:	697a      	ldr	r2, [r7, #20]
 80230ea:	4613      	mov	r3, r2
 80230ec:	009b      	lsls	r3, r3, #2
 80230ee:	4413      	add	r3, r2
 80230f0:	009b      	lsls	r3, r3, #2
 80230f2:	440b      	add	r3, r1
 80230f4:	3330      	adds	r3, #48	; 0x30
 80230f6:	681b      	ldr	r3, [r3, #0]
 80230f8:	4619      	mov	r1, r3
 80230fa:	f7dd fe5b 	bl	8000db4 <__aeabi_fmul>
 80230fe:	4603      	mov	r3, r0
 8023100:	4618      	mov	r0, r3
 8023102:	f001 fd37 	bl	8024b74 <lroundf>
 8023106:	4603      	mov	r3, r0
             int32_t set_axis_position = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 8023108:	613b      	str	r3, [r7, #16]
             switch(idx) {
 802310a:	697b      	ldr	r3, [r7, #20]
 802310c:	2b00      	cmp	r3, #0
 802310e:	d003      	beq.n	8023118 <corexy_limits_set_machine_positions+0x14c>
 8023110:	697b      	ldr	r3, [r7, #20]
 8023112:	2b01      	cmp	r3, #1
 8023114:	d011      	beq.n	802313a <corexy_limits_set_machine_positions+0x16e>
 8023116:	e021      	b.n	802315c <corexy_limits_set_machine_positions+0x190>
                     off_axis_position = corexy_convert_to_b_motor_steps(sys.position);
 8023118:	4819      	ldr	r0, [pc, #100]	; (8023180 <corexy_limits_set_machine_positions+0x1b4>)
 802311a:	f7ff fe75 	bl	8022e08 <corexy_convert_to_b_motor_steps>
 802311e:	60f8      	str	r0, [r7, #12]
                     sys.position[A_MOTOR] = set_axis_position + off_axis_position;
 8023120:	693a      	ldr	r2, [r7, #16]
 8023122:	68fb      	ldr	r3, [r7, #12]
 8023124:	4413      	add	r3, r2
 8023126:	4a17      	ldr	r2, [pc, #92]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023128:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                     sys.position[B_MOTOR] = set_axis_position - off_axis_position;
 802312c:	693a      	ldr	r2, [r7, #16]
 802312e:	68fb      	ldr	r3, [r7, #12]
 8023130:	1ad3      	subs	r3, r2, r3
 8023132:	4a14      	ldr	r2, [pc, #80]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023134:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                     break;
 8023138:	e017      	b.n	802316a <corexy_limits_set_machine_positions+0x19e>
                     off_axis_position = corexy_convert_to_a_motor_steps(sys.position);
 802313a:	4811      	ldr	r0, [pc, #68]	; (8023180 <corexy_limits_set_machine_positions+0x1b4>)
 802313c:	f7ff fe54 	bl	8022de8 <corexy_convert_to_a_motor_steps>
 8023140:	60f8      	str	r0, [r7, #12]
                     sys.position[A_MOTOR] = off_axis_position + set_axis_position;
 8023142:	68fa      	ldr	r2, [r7, #12]
 8023144:	693b      	ldr	r3, [r7, #16]
 8023146:	4413      	add	r3, r2
 8023148:	4a0e      	ldr	r2, [pc, #56]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 802314a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
                     sys.position[B_MOTOR] = off_axis_position - set_axis_position;
 802314e:	68fa      	ldr	r2, [r7, #12]
 8023150:	693b      	ldr	r3, [r7, #16]
 8023152:	1ad3      	subs	r3, r2, r3
 8023154:	4a0b      	ldr	r2, [pc, #44]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 8023156:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                     break;
 802315a:	e006      	b.n	802316a <corexy_limits_set_machine_positions+0x19e>
                     sys.position[idx] = set_axis_position;
 802315c:	4909      	ldr	r1, [pc, #36]	; (8023184 <corexy_limits_set_machine_positions+0x1b8>)
 802315e:	697b      	ldr	r3, [r7, #20]
 8023160:	3322      	adds	r3, #34	; 0x22
 8023162:	693a      	ldr	r2, [r7, #16]
 8023164:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                     break;
 8023168:	bf00      	nop
    } while(idx);
 802316a:	697b      	ldr	r3, [r7, #20]
 802316c:	2b00      	cmp	r3, #0
 802316e:	f47f af7a 	bne.w	8023066 <corexy_limits_set_machine_positions+0x9a>
}
 8023172:	bf00      	nop
 8023174:	3718      	adds	r7, #24
 8023176:	46bd      	mov	sp, r7
 8023178:	bd80      	pop	{r7, pc}
 802317a:	bf00      	nop
 802317c:	2000147c 	.word	0x2000147c
 8023180:	20000dc4 	.word	0x20000dc4
 8023184:	20000d3c 	.word	0x20000d3c

08023188 <get_distance>:

static inline float get_distance (float *p0, float *p1)
{
 8023188:	b590      	push	{r4, r7, lr}
 802318a:	b085      	sub	sp, #20
 802318c:	af00      	add	r7, sp, #0
 802318e:	6078      	str	r0, [r7, #4]
 8023190:	6039      	str	r1, [r7, #0]
    uint_fast8_t idx = N_AXIS;
 8023192:	2303      	movs	r3, #3
 8023194:	60fb      	str	r3, [r7, #12]
    float distance = 0.0f;
 8023196:	f04f 0300 	mov.w	r3, #0
 802319a:	60bb      	str	r3, [r7, #8]

    do {
        idx--;
 802319c:	68fb      	ldr	r3, [r7, #12]
 802319e:	3b01      	subs	r3, #1
 80231a0:	60fb      	str	r3, [r7, #12]
        distance += (p0[idx] - p1[idx]) * (p0[idx] - p1[idx]);
 80231a2:	68fb      	ldr	r3, [r7, #12]
 80231a4:	009b      	lsls	r3, r3, #2
 80231a6:	687a      	ldr	r2, [r7, #4]
 80231a8:	4413      	add	r3, r2
 80231aa:	6818      	ldr	r0, [r3, #0]
 80231ac:	68fb      	ldr	r3, [r7, #12]
 80231ae:	009b      	lsls	r3, r3, #2
 80231b0:	683a      	ldr	r2, [r7, #0]
 80231b2:	4413      	add	r3, r2
 80231b4:	681b      	ldr	r3, [r3, #0]
 80231b6:	4619      	mov	r1, r3
 80231b8:	f7dd fcf2 	bl	8000ba0 <__aeabi_fsub>
 80231bc:	4603      	mov	r3, r0
 80231be:	461c      	mov	r4, r3
 80231c0:	68fb      	ldr	r3, [r7, #12]
 80231c2:	009b      	lsls	r3, r3, #2
 80231c4:	687a      	ldr	r2, [r7, #4]
 80231c6:	4413      	add	r3, r2
 80231c8:	6818      	ldr	r0, [r3, #0]
 80231ca:	68fb      	ldr	r3, [r7, #12]
 80231cc:	009b      	lsls	r3, r3, #2
 80231ce:	683a      	ldr	r2, [r7, #0]
 80231d0:	4413      	add	r3, r2
 80231d2:	681b      	ldr	r3, [r3, #0]
 80231d4:	4619      	mov	r1, r3
 80231d6:	f7dd fce3 	bl	8000ba0 <__aeabi_fsub>
 80231da:	4603      	mov	r3, r0
 80231dc:	4619      	mov	r1, r3
 80231de:	4620      	mov	r0, r4
 80231e0:	f7dd fde8 	bl	8000db4 <__aeabi_fmul>
 80231e4:	4603      	mov	r3, r0
 80231e6:	4619      	mov	r1, r3
 80231e8:	68b8      	ldr	r0, [r7, #8]
 80231ea:	f7dd fcdb 	bl	8000ba4 <__addsf3>
 80231ee:	4603      	mov	r3, r0
 80231f0:	60bb      	str	r3, [r7, #8]
    } while(idx);
 80231f2:	68fb      	ldr	r3, [r7, #12]
 80231f4:	2b00      	cmp	r3, #0
 80231f6:	d1d1      	bne.n	802319c <get_distance+0x14>

    return sqrtf(distance);
 80231f8:	68b8      	ldr	r0, [r7, #8]
 80231fa:	f001 fc00 	bl	80249fe <sqrtf>
 80231fe:	4603      	mov	r3, r0
}
 8023200:	4618      	mov	r0, r3
 8023202:	3714      	adds	r7, #20
 8023204:	46bd      	mov	sp, r7
 8023206:	bd90      	pop	{r4, r7, pc}

08023208 <kinematics_segment_line>:

// called from mc_line() to segment lines if not overridden, default implementation for pass-through
static float *kinematics_segment_line (float *target, float *position, plan_line_data_t *pl_data, bool init)
{
 8023208:	b590      	push	{r4, r7, lr}
 802320a:	b089      	sub	sp, #36	; 0x24
 802320c:	af00      	add	r7, sp, #0
 802320e:	60f8      	str	r0, [r7, #12]
 8023210:	60b9      	str	r1, [r7, #8]
 8023212:	607a      	str	r2, [r7, #4]
 8023214:	70fb      	strb	r3, [r7, #3]
    static uint_fast8_t iterations;
    static float trsf[N_AXIS];

    if(init) {
 8023216:	78fb      	ldrb	r3, [r7, #3]
 8023218:	2b00      	cmp	r3, #0
 802321a:	d05f      	beq.n	80232dc <kinematics_segment_line+0xd4>

        iterations = 2;
 802321c:	4b36      	ldr	r3, [pc, #216]	; (80232f8 <kinematics_segment_line+0xf0>)
 802321e:	2202      	movs	r2, #2
 8023220:	601a      	str	r2, [r3, #0]

        transform_from_cartesian(trsf, target);
 8023222:	68f9      	ldr	r1, [r7, #12]
 8023224:	4835      	ldr	r0, [pc, #212]	; (80232fc <kinematics_segment_line+0xf4>)
 8023226:	f7ff fe4f 	bl	8022ec8 <transform_from_cartesian>

        if(!pl_data->condition.rapid_motion) {
 802322a:	687b      	ldr	r3, [r7, #4]
 802322c:	7e1b      	ldrb	r3, [r3, #24]
 802322e:	f003 0301 	and.w	r3, r3, #1
 8023232:	b2db      	uxtb	r3, r3
 8023234:	2b00      	cmp	r3, #0
 8023236:	d151      	bne.n	80232dc <kinematics_segment_line+0xd4>

            uint_fast8_t idx;
            float cpos[N_AXIS];

            cpos[X_AXIS] = (position[X_AXIS] + position[Y_AXIS]) * .5f;
 8023238:	68bb      	ldr	r3, [r7, #8]
 802323a:	681a      	ldr	r2, [r3, #0]
 802323c:	68bb      	ldr	r3, [r7, #8]
 802323e:	3304      	adds	r3, #4
 8023240:	681b      	ldr	r3, [r3, #0]
 8023242:	4619      	mov	r1, r3
 8023244:	4610      	mov	r0, r2
 8023246:	f7dd fcad 	bl	8000ba4 <__addsf3>
 802324a:	4603      	mov	r3, r0
 802324c:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8023250:	4618      	mov	r0, r3
 8023252:	f7dd fdaf 	bl	8000db4 <__aeabi_fmul>
 8023256:	4603      	mov	r3, r0
 8023258:	613b      	str	r3, [r7, #16]
            cpos[Y_AXIS] = (position[X_AXIS] - position[Y_AXIS]) * .5f;
 802325a:	68bb      	ldr	r3, [r7, #8]
 802325c:	681a      	ldr	r2, [r3, #0]
 802325e:	68bb      	ldr	r3, [r7, #8]
 8023260:	3304      	adds	r3, #4
 8023262:	681b      	ldr	r3, [r3, #0]
 8023264:	4619      	mov	r1, r3
 8023266:	4610      	mov	r0, r2
 8023268:	f7dd fc9a 	bl	8000ba0 <__aeabi_fsub>
 802326c:	4603      	mov	r3, r0
 802326e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8023272:	4618      	mov	r0, r3
 8023274:	f7dd fd9e 	bl	8000db4 <__aeabi_fmul>
 8023278:	4603      	mov	r3, r0
 802327a:	617b      	str	r3, [r7, #20]
            for(idx = Z_AXIS; idx < N_AXIS; idx++)
 802327c:	2302      	movs	r3, #2
 802327e:	61fb      	str	r3, [r7, #28]
 8023280:	e00d      	b.n	802329e <kinematics_segment_line+0x96>
                cpos[idx] = position[idx];
 8023282:	69fb      	ldr	r3, [r7, #28]
 8023284:	009b      	lsls	r3, r3, #2
 8023286:	68ba      	ldr	r2, [r7, #8]
 8023288:	4413      	add	r3, r2
 802328a:	681a      	ldr	r2, [r3, #0]
 802328c:	69fb      	ldr	r3, [r7, #28]
 802328e:	009b      	lsls	r3, r3, #2
 8023290:	3320      	adds	r3, #32
 8023292:	443b      	add	r3, r7
 8023294:	f843 2c10 	str.w	r2, [r3, #-16]
            for(idx = Z_AXIS; idx < N_AXIS; idx++)
 8023298:	69fb      	ldr	r3, [r7, #28]
 802329a:	3301      	adds	r3, #1
 802329c:	61fb      	str	r3, [r7, #28]
 802329e:	69fb      	ldr	r3, [r7, #28]
 80232a0:	2b02      	cmp	r3, #2
 80232a2:	d9ee      	bls.n	8023282 <kinematics_segment_line+0x7a>

            pl_data->feed_rate *= get_distance(trsf, position) / get_distance(target, cpos);
 80232a4:	68b9      	ldr	r1, [r7, #8]
 80232a6:	4815      	ldr	r0, [pc, #84]	; (80232fc <kinematics_segment_line+0xf4>)
 80232a8:	f7ff ff6e 	bl	8023188 <get_distance>
 80232ac:	4604      	mov	r4, r0
 80232ae:	f107 0310 	add.w	r3, r7, #16
 80232b2:	4619      	mov	r1, r3
 80232b4:	68f8      	ldr	r0, [r7, #12]
 80232b6:	f7ff ff67 	bl	8023188 <get_distance>
 80232ba:	4603      	mov	r3, r0
 80232bc:	4619      	mov	r1, r3
 80232be:	4620      	mov	r0, r4
 80232c0:	f7dd fe2c 	bl	8000f1c <__aeabi_fdiv>
 80232c4:	4603      	mov	r3, r0
 80232c6:	461a      	mov	r2, r3
 80232c8:	687b      	ldr	r3, [r7, #4]
 80232ca:	681b      	ldr	r3, [r3, #0]
 80232cc:	4619      	mov	r1, r3
 80232ce:	4610      	mov	r0, r2
 80232d0:	f7dd fd70 	bl	8000db4 <__aeabi_fmul>
 80232d4:	4603      	mov	r3, r0
 80232d6:	461a      	mov	r2, r3
 80232d8:	687b      	ldr	r3, [r7, #4]
 80232da:	601a      	str	r2, [r3, #0]
        }
    }

    return iterations-- == 0 ? NULL : trsf;
 80232dc:	4b06      	ldr	r3, [pc, #24]	; (80232f8 <kinematics_segment_line+0xf0>)
 80232de:	681b      	ldr	r3, [r3, #0]
 80232e0:	1e5a      	subs	r2, r3, #1
 80232e2:	4905      	ldr	r1, [pc, #20]	; (80232f8 <kinematics_segment_line+0xf0>)
 80232e4:	600a      	str	r2, [r1, #0]
 80232e6:	2b00      	cmp	r3, #0
 80232e8:	d001      	beq.n	80232ee <kinematics_segment_line+0xe6>
 80232ea:	4b04      	ldr	r3, [pc, #16]	; (80232fc <kinematics_segment_line+0xf4>)
 80232ec:	e000      	b.n	80232f0 <kinematics_segment_line+0xe8>
 80232ee:	2300      	movs	r3, #0
}
 80232f0:	4618      	mov	r0, r3
 80232f2:	3724      	adds	r7, #36	; 0x24
 80232f4:	46bd      	mov	sp, r7
 80232f6:	bd90      	pop	{r4, r7, pc}
 80232f8:	2000218c 	.word	0x2000218c
 80232fc:	20002190 	.word	0x20002190

08023300 <homing_cycle_validate>:

static bool homing_cycle_validate (axes_signals_t cycle)
{
 8023300:	b480      	push	{r7}
 8023302:	b083      	sub	sp, #12
 8023304:	af00      	add	r7, sp, #0
 8023306:	7138      	strb	r0, [r7, #4]
    return (cycle.mask & (X_AXIS_BIT|Y_AXIS_BIT)) == 0 || cycle.mask < 3;
 8023308:	793b      	ldrb	r3, [r7, #4]
 802330a:	f003 0303 	and.w	r3, r3, #3
 802330e:	2b00      	cmp	r3, #0
 8023310:	d002      	beq.n	8023318 <homing_cycle_validate+0x18>
 8023312:	793b      	ldrb	r3, [r7, #4]
 8023314:	2b02      	cmp	r3, #2
 8023316:	d801      	bhi.n	802331c <homing_cycle_validate+0x1c>
 8023318:	2301      	movs	r3, #1
 802331a:	e000      	b.n	802331e <homing_cycle_validate+0x1e>
 802331c:	2300      	movs	r3, #0
 802331e:	f003 0301 	and.w	r3, r3, #1
 8023322:	b2db      	uxtb	r3, r3
}
 8023324:	4618      	mov	r0, r3
 8023326:	370c      	adds	r7, #12
 8023328:	46bd      	mov	sp, r7
 802332a:	bc80      	pop	{r7}
 802332c:	4770      	bx	lr
	...

08023330 <homing_cycle_get_feedrate>:

static float homing_cycle_get_feedrate (axes_signals_t cycle, float feedrate, homing_mode_t mode)
{
 8023330:	b580      	push	{r7, lr}
 8023332:	b082      	sub	sp, #8
 8023334:	af00      	add	r7, sp, #0
 8023336:	7138      	strb	r0, [r7, #4]
 8023338:	6039      	str	r1, [r7, #0]
 802333a:	4613      	mov	r3, r2
 802333c:	71fb      	strb	r3, [r7, #7]
    return feedrate * sqrtf(2.0f);
 802333e:	4904      	ldr	r1, [pc, #16]	; (8023350 <homing_cycle_get_feedrate+0x20>)
 8023340:	6838      	ldr	r0, [r7, #0]
 8023342:	f7dd fd37 	bl	8000db4 <__aeabi_fmul>
 8023346:	4603      	mov	r3, r0
}
 8023348:	4618      	mov	r0, r3
 802334a:	3708      	adds	r7, #8
 802334c:	46bd      	mov	sp, r7
 802334e:	bd80      	pop	{r7, pc}
 8023350:	3fb504f3 	.word	0x3fb504f3

08023354 <report_options>:

static void report_options (bool newopt)
{
 8023354:	b580      	push	{r7, lr}
 8023356:	b082      	sub	sp, #8
 8023358:	af00      	add	r7, sp, #0
 802335a:	4603      	mov	r3, r0
 802335c:	71fb      	strb	r3, [r7, #7]
    on_report_options(newopt);
 802335e:	4b0a      	ldr	r3, [pc, #40]	; (8023388 <report_options+0x34>)
 8023360:	681b      	ldr	r3, [r3, #0]
 8023362:	79fa      	ldrb	r2, [r7, #7]
 8023364:	4610      	mov	r0, r2
 8023366:	4798      	blx	r3

    if(!newopt)
 8023368:	79fb      	ldrb	r3, [r7, #7]
 802336a:	f083 0301 	eor.w	r3, r3, #1
 802336e:	b2db      	uxtb	r3, r3
 8023370:	2b00      	cmp	r3, #0
 8023372:	d004      	beq.n	802337e <report_options+0x2a>
        hal.stream.write("[KINEMATICS:CoreXY v2.00]" ASCII_EOL);
 8023374:	4b05      	ldr	r3, [pc, #20]	; (802338c <report_options+0x38>)
 8023376:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 802337a:	4805      	ldr	r0, [pc, #20]	; (8023390 <report_options+0x3c>)
 802337c:	4798      	blx	r3
}
 802337e:	bf00      	nop
 8023380:	3708      	adds	r7, #8
 8023382:	46bd      	mov	sp, r7
 8023384:	bd80      	pop	{r7, pc}
 8023386:	bf00      	nop
 8023388:	20002188 	.word	0x20002188
 802338c:	20000ed0 	.word	0x20000ed0
 8023390:	08030924 	.word	0x08030924

08023394 <corexy_init>:

// Initialize API pointers for CoreXY kinematics
void corexy_init (void)
{
 8023394:	b480      	push	{r7}
 8023396:	af00      	add	r7, sp, #0
    kinematics.limits_set_target_pos = corexy_limits_set_target_pos;
 8023398:	4b11      	ldr	r3, [pc, #68]	; (80233e0 <corexy_init+0x4c>)
 802339a:	4a12      	ldr	r2, [pc, #72]	; (80233e4 <corexy_init+0x50>)
 802339c:	611a      	str	r2, [r3, #16]
    kinematics.limits_get_axis_mask = corexy_limits_get_axis_mask;
 802339e:	4b10      	ldr	r3, [pc, #64]	; (80233e0 <corexy_init+0x4c>)
 80233a0:	4a11      	ldr	r2, [pc, #68]	; (80233e8 <corexy_init+0x54>)
 80233a2:	60da      	str	r2, [r3, #12]
    kinematics.limits_set_machine_positions = corexy_limits_set_machine_positions;
 80233a4:	4b0e      	ldr	r3, [pc, #56]	; (80233e0 <corexy_init+0x4c>)
 80233a6:	4a11      	ldr	r2, [pc, #68]	; (80233ec <corexy_init+0x58>)
 80233a8:	615a      	str	r2, [r3, #20]
    kinematics.transform_from_cartesian = transform_from_cartesian;
 80233aa:	4b0d      	ldr	r3, [pc, #52]	; (80233e0 <corexy_init+0x4c>)
 80233ac:	4a10      	ldr	r2, [pc, #64]	; (80233f0 <corexy_init+0x5c>)
 80233ae:	605a      	str	r2, [r3, #4]
    kinematics.transform_steps_to_cartesian = corexy_convert_array_steps_to_mpos;
 80233b0:	4b0b      	ldr	r3, [pc, #44]	; (80233e0 <corexy_init+0x4c>)
 80233b2:	4a10      	ldr	r2, [pc, #64]	; (80233f4 <corexy_init+0x60>)
 80233b4:	601a      	str	r2, [r3, #0]
    kinematics.segment_line = kinematics_segment_line;
 80233b6:	4b0a      	ldr	r3, [pc, #40]	; (80233e0 <corexy_init+0x4c>)
 80233b8:	4a0f      	ldr	r2, [pc, #60]	; (80233f8 <corexy_init+0x64>)
 80233ba:	609a      	str	r2, [r3, #8]
    kinematics.homing_cycle_validate = homing_cycle_validate;
 80233bc:	4b08      	ldr	r3, [pc, #32]	; (80233e0 <corexy_init+0x4c>)
 80233be:	4a0f      	ldr	r2, [pc, #60]	; (80233fc <corexy_init+0x68>)
 80233c0:	619a      	str	r2, [r3, #24]
    kinematics.homing_cycle_get_feedrate = homing_cycle_get_feedrate;
 80233c2:	4b07      	ldr	r3, [pc, #28]	; (80233e0 <corexy_init+0x4c>)
 80233c4:	4a0e      	ldr	r2, [pc, #56]	; (8023400 <corexy_init+0x6c>)
 80233c6:	61da      	str	r2, [r3, #28]

    on_report_options = grbl.on_report_options;
 80233c8:	4b0e      	ldr	r3, [pc, #56]	; (8023404 <corexy_init+0x70>)
 80233ca:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80233cc:	4a0e      	ldr	r2, [pc, #56]	; (8023408 <corexy_init+0x74>)
 80233ce:	6013      	str	r3, [r2, #0]
    grbl.on_report_options = report_options;
 80233d0:	4b0c      	ldr	r3, [pc, #48]	; (8023404 <corexy_init+0x70>)
 80233d2:	4a0e      	ldr	r2, [pc, #56]	; (802340c <corexy_init+0x78>)
 80233d4:	655a      	str	r2, [r3, #84]	; 0x54
}
 80233d6:	bf00      	nop
 80233d8:	46bd      	mov	sp, r7
 80233da:	bc80      	pop	{r7}
 80233dc:	4770      	bx	lr
 80233de:	bf00      	nop
 80233e0:	20001088 	.word	0x20001088
 80233e4:	08022f61 	.word	0x08022f61
 80233e8:	08022f35 	.word	0x08022f35
 80233ec:	08022fcd 	.word	0x08022fcd
 80233f0:	08022ec9 	.word	0x08022ec9
 80233f4:	08022e29 	.word	0x08022e29
 80233f8:	08023209 	.word	0x08023209
 80233fc:	08023301 	.word	0x08023301
 8023400:	08023331 	.word	0x08023331
 8023404:	20000dd4 	.word	0x20000dd4
 8023408:	20002188 	.word	0x20002188
 802340c:	08023355 	.word	0x08023355

08023410 <__assert_func>:
 8023410:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8023412:	4614      	mov	r4, r2
 8023414:	461a      	mov	r2, r3
 8023416:	4b09      	ldr	r3, [pc, #36]	; (802343c <__assert_func+0x2c>)
 8023418:	4605      	mov	r5, r0
 802341a:	681b      	ldr	r3, [r3, #0]
 802341c:	68d8      	ldr	r0, [r3, #12]
 802341e:	b14c      	cbz	r4, 8023434 <__assert_func+0x24>
 8023420:	4b07      	ldr	r3, [pc, #28]	; (8023440 <__assert_func+0x30>)
 8023422:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8023426:	9100      	str	r1, [sp, #0]
 8023428:	462b      	mov	r3, r5
 802342a:	4906      	ldr	r1, [pc, #24]	; (8023444 <__assert_func+0x34>)
 802342c:	f000 fb70 	bl	8023b10 <fiprintf>
 8023430:	f000 fd5b 	bl	8023eea <abort>
 8023434:	4b04      	ldr	r3, [pc, #16]	; (8023448 <__assert_func+0x38>)
 8023436:	461c      	mov	r4, r3
 8023438:	e7f3      	b.n	8023422 <__assert_func+0x12>
 802343a:	bf00      	nop
 802343c:	20000440 	.word	0x20000440
 8023440:	08032dcc 	.word	0x08032dcc
 8023444:	08032dd9 	.word	0x08032dd9
 8023448:	08032e07 	.word	0x08032e07

0802344c <calloc>:
 802344c:	4b02      	ldr	r3, [pc, #8]	; (8023458 <calloc+0xc>)
 802344e:	460a      	mov	r2, r1
 8023450:	4601      	mov	r1, r0
 8023452:	6818      	ldr	r0, [r3, #0]
 8023454:	f000 b802 	b.w	802345c <_calloc_r>
 8023458:	20000440 	.word	0x20000440

0802345c <_calloc_r>:
 802345c:	b570      	push	{r4, r5, r6, lr}
 802345e:	fba1 5402 	umull	r5, r4, r1, r2
 8023462:	b934      	cbnz	r4, 8023472 <_calloc_r+0x16>
 8023464:	4629      	mov	r1, r5
 8023466:	f000 f857 	bl	8023518 <_malloc_r>
 802346a:	4606      	mov	r6, r0
 802346c:	b928      	cbnz	r0, 802347a <_calloc_r+0x1e>
 802346e:	4630      	mov	r0, r6
 8023470:	bd70      	pop	{r4, r5, r6, pc}
 8023472:	220c      	movs	r2, #12
 8023474:	2600      	movs	r6, #0
 8023476:	6002      	str	r2, [r0, #0]
 8023478:	e7f9      	b.n	802346e <_calloc_r+0x12>
 802347a:	462a      	mov	r2, r5
 802347c:	4621      	mov	r1, r4
 802347e:	f000 fbca 	bl	8023c16 <memset>
 8023482:	e7f4      	b.n	802346e <_calloc_r+0x12>

08023484 <__itoa>:
 8023484:	1e93      	subs	r3, r2, #2
 8023486:	2b22      	cmp	r3, #34	; 0x22
 8023488:	b510      	push	{r4, lr}
 802348a:	460c      	mov	r4, r1
 802348c:	d904      	bls.n	8023498 <__itoa+0x14>
 802348e:	2300      	movs	r3, #0
 8023490:	461c      	mov	r4, r3
 8023492:	700b      	strb	r3, [r1, #0]
 8023494:	4620      	mov	r0, r4
 8023496:	bd10      	pop	{r4, pc}
 8023498:	2a0a      	cmp	r2, #10
 802349a:	d109      	bne.n	80234b0 <__itoa+0x2c>
 802349c:	2800      	cmp	r0, #0
 802349e:	da07      	bge.n	80234b0 <__itoa+0x2c>
 80234a0:	232d      	movs	r3, #45	; 0x2d
 80234a2:	700b      	strb	r3, [r1, #0]
 80234a4:	2101      	movs	r1, #1
 80234a6:	4240      	negs	r0, r0
 80234a8:	4421      	add	r1, r4
 80234aa:	f000 f8c1 	bl	8023630 <__utoa>
 80234ae:	e7f1      	b.n	8023494 <__itoa+0x10>
 80234b0:	2100      	movs	r1, #0
 80234b2:	e7f9      	b.n	80234a8 <__itoa+0x24>

080234b4 <itoa>:
 80234b4:	f7ff bfe6 	b.w	8023484 <__itoa>

080234b8 <malloc>:
 80234b8:	4b02      	ldr	r3, [pc, #8]	; (80234c4 <malloc+0xc>)
 80234ba:	4601      	mov	r1, r0
 80234bc:	6818      	ldr	r0, [r3, #0]
 80234be:	f000 b82b 	b.w	8023518 <_malloc_r>
 80234c2:	bf00      	nop
 80234c4:	20000440 	.word	0x20000440

080234c8 <free>:
 80234c8:	4b02      	ldr	r3, [pc, #8]	; (80234d4 <free+0xc>)
 80234ca:	4601      	mov	r1, r0
 80234cc:	6818      	ldr	r0, [r3, #0]
 80234ce:	f000 bd13 	b.w	8023ef8 <_free_r>
 80234d2:	bf00      	nop
 80234d4:	20000440 	.word	0x20000440

080234d8 <sbrk_aligned>:
 80234d8:	b570      	push	{r4, r5, r6, lr}
 80234da:	4e0e      	ldr	r6, [pc, #56]	; (8023514 <sbrk_aligned+0x3c>)
 80234dc:	460c      	mov	r4, r1
 80234de:	6831      	ldr	r1, [r6, #0]
 80234e0:	4605      	mov	r5, r0
 80234e2:	b911      	cbnz	r1, 80234ea <sbrk_aligned+0x12>
 80234e4:	f000 fc9c 	bl	8023e20 <_sbrk_r>
 80234e8:	6030      	str	r0, [r6, #0]
 80234ea:	4621      	mov	r1, r4
 80234ec:	4628      	mov	r0, r5
 80234ee:	f000 fc97 	bl	8023e20 <_sbrk_r>
 80234f2:	1c43      	adds	r3, r0, #1
 80234f4:	d00a      	beq.n	802350c <sbrk_aligned+0x34>
 80234f6:	1cc4      	adds	r4, r0, #3
 80234f8:	f024 0403 	bic.w	r4, r4, #3
 80234fc:	42a0      	cmp	r0, r4
 80234fe:	d007      	beq.n	8023510 <sbrk_aligned+0x38>
 8023500:	1a21      	subs	r1, r4, r0
 8023502:	4628      	mov	r0, r5
 8023504:	f000 fc8c 	bl	8023e20 <_sbrk_r>
 8023508:	3001      	adds	r0, #1
 802350a:	d101      	bne.n	8023510 <sbrk_aligned+0x38>
 802350c:	f04f 34ff 	mov.w	r4, #4294967295
 8023510:	4620      	mov	r0, r4
 8023512:	bd70      	pop	{r4, r5, r6, pc}
 8023514:	200021a0 	.word	0x200021a0

08023518 <_malloc_r>:
 8023518:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802351c:	1ccd      	adds	r5, r1, #3
 802351e:	f025 0503 	bic.w	r5, r5, #3
 8023522:	3508      	adds	r5, #8
 8023524:	2d0c      	cmp	r5, #12
 8023526:	bf38      	it	cc
 8023528:	250c      	movcc	r5, #12
 802352a:	2d00      	cmp	r5, #0
 802352c:	4607      	mov	r7, r0
 802352e:	db01      	blt.n	8023534 <_malloc_r+0x1c>
 8023530:	42a9      	cmp	r1, r5
 8023532:	d905      	bls.n	8023540 <_malloc_r+0x28>
 8023534:	230c      	movs	r3, #12
 8023536:	2600      	movs	r6, #0
 8023538:	603b      	str	r3, [r7, #0]
 802353a:	4630      	mov	r0, r6
 802353c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8023540:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8023614 <_malloc_r+0xfc>
 8023544:	f000 f868 	bl	8023618 <__malloc_lock>
 8023548:	f8d8 3000 	ldr.w	r3, [r8]
 802354c:	461c      	mov	r4, r3
 802354e:	bb5c      	cbnz	r4, 80235a8 <_malloc_r+0x90>
 8023550:	4629      	mov	r1, r5
 8023552:	4638      	mov	r0, r7
 8023554:	f7ff ffc0 	bl	80234d8 <sbrk_aligned>
 8023558:	1c43      	adds	r3, r0, #1
 802355a:	4604      	mov	r4, r0
 802355c:	d155      	bne.n	802360a <_malloc_r+0xf2>
 802355e:	f8d8 4000 	ldr.w	r4, [r8]
 8023562:	4626      	mov	r6, r4
 8023564:	2e00      	cmp	r6, #0
 8023566:	d145      	bne.n	80235f4 <_malloc_r+0xdc>
 8023568:	2c00      	cmp	r4, #0
 802356a:	d048      	beq.n	80235fe <_malloc_r+0xe6>
 802356c:	6823      	ldr	r3, [r4, #0]
 802356e:	4631      	mov	r1, r6
 8023570:	4638      	mov	r0, r7
 8023572:	eb04 0903 	add.w	r9, r4, r3
 8023576:	f000 fc53 	bl	8023e20 <_sbrk_r>
 802357a:	4581      	cmp	r9, r0
 802357c:	d13f      	bne.n	80235fe <_malloc_r+0xe6>
 802357e:	6821      	ldr	r1, [r4, #0]
 8023580:	4638      	mov	r0, r7
 8023582:	1a6d      	subs	r5, r5, r1
 8023584:	4629      	mov	r1, r5
 8023586:	f7ff ffa7 	bl	80234d8 <sbrk_aligned>
 802358a:	3001      	adds	r0, #1
 802358c:	d037      	beq.n	80235fe <_malloc_r+0xe6>
 802358e:	6823      	ldr	r3, [r4, #0]
 8023590:	442b      	add	r3, r5
 8023592:	6023      	str	r3, [r4, #0]
 8023594:	f8d8 3000 	ldr.w	r3, [r8]
 8023598:	2b00      	cmp	r3, #0
 802359a:	d038      	beq.n	802360e <_malloc_r+0xf6>
 802359c:	685a      	ldr	r2, [r3, #4]
 802359e:	42a2      	cmp	r2, r4
 80235a0:	d12b      	bne.n	80235fa <_malloc_r+0xe2>
 80235a2:	2200      	movs	r2, #0
 80235a4:	605a      	str	r2, [r3, #4]
 80235a6:	e00f      	b.n	80235c8 <_malloc_r+0xb0>
 80235a8:	6822      	ldr	r2, [r4, #0]
 80235aa:	1b52      	subs	r2, r2, r5
 80235ac:	d41f      	bmi.n	80235ee <_malloc_r+0xd6>
 80235ae:	2a0b      	cmp	r2, #11
 80235b0:	d917      	bls.n	80235e2 <_malloc_r+0xca>
 80235b2:	1961      	adds	r1, r4, r5
 80235b4:	42a3      	cmp	r3, r4
 80235b6:	6025      	str	r5, [r4, #0]
 80235b8:	bf18      	it	ne
 80235ba:	6059      	strne	r1, [r3, #4]
 80235bc:	6863      	ldr	r3, [r4, #4]
 80235be:	bf08      	it	eq
 80235c0:	f8c8 1000 	streq.w	r1, [r8]
 80235c4:	5162      	str	r2, [r4, r5]
 80235c6:	604b      	str	r3, [r1, #4]
 80235c8:	4638      	mov	r0, r7
 80235ca:	f104 060b 	add.w	r6, r4, #11
 80235ce:	f000 f829 	bl	8023624 <__malloc_unlock>
 80235d2:	f026 0607 	bic.w	r6, r6, #7
 80235d6:	1d23      	adds	r3, r4, #4
 80235d8:	1af2      	subs	r2, r6, r3
 80235da:	d0ae      	beq.n	802353a <_malloc_r+0x22>
 80235dc:	1b9b      	subs	r3, r3, r6
 80235de:	50a3      	str	r3, [r4, r2]
 80235e0:	e7ab      	b.n	802353a <_malloc_r+0x22>
 80235e2:	42a3      	cmp	r3, r4
 80235e4:	6862      	ldr	r2, [r4, #4]
 80235e6:	d1dd      	bne.n	80235a4 <_malloc_r+0x8c>
 80235e8:	f8c8 2000 	str.w	r2, [r8]
 80235ec:	e7ec      	b.n	80235c8 <_malloc_r+0xb0>
 80235ee:	4623      	mov	r3, r4
 80235f0:	6864      	ldr	r4, [r4, #4]
 80235f2:	e7ac      	b.n	802354e <_malloc_r+0x36>
 80235f4:	4634      	mov	r4, r6
 80235f6:	6876      	ldr	r6, [r6, #4]
 80235f8:	e7b4      	b.n	8023564 <_malloc_r+0x4c>
 80235fa:	4613      	mov	r3, r2
 80235fc:	e7cc      	b.n	8023598 <_malloc_r+0x80>
 80235fe:	230c      	movs	r3, #12
 8023600:	4638      	mov	r0, r7
 8023602:	603b      	str	r3, [r7, #0]
 8023604:	f000 f80e 	bl	8023624 <__malloc_unlock>
 8023608:	e797      	b.n	802353a <_malloc_r+0x22>
 802360a:	6025      	str	r5, [r4, #0]
 802360c:	e7dc      	b.n	80235c8 <_malloc_r+0xb0>
 802360e:	605b      	str	r3, [r3, #4]
 8023610:	deff      	udf	#255	; 0xff
 8023612:	bf00      	nop
 8023614:	2000219c 	.word	0x2000219c

08023618 <__malloc_lock>:
 8023618:	4801      	ldr	r0, [pc, #4]	; (8023620 <__malloc_lock+0x8>)
 802361a:	f000 bc4e 	b.w	8023eba <__retarget_lock_acquire_recursive>
 802361e:	bf00      	nop
 8023620:	200022e4 	.word	0x200022e4

08023624 <__malloc_unlock>:
 8023624:	4801      	ldr	r0, [pc, #4]	; (802362c <__malloc_unlock+0x8>)
 8023626:	f000 bc49 	b.w	8023ebc <__retarget_lock_release_recursive>
 802362a:	bf00      	nop
 802362c:	200022e4 	.word	0x200022e4

08023630 <__utoa>:
 8023630:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023632:	b08b      	sub	sp, #44	; 0x2c
 8023634:	4605      	mov	r5, r0
 8023636:	460b      	mov	r3, r1
 8023638:	466e      	mov	r6, sp
 802363a:	4c1d      	ldr	r4, [pc, #116]	; (80236b0 <__utoa+0x80>)
 802363c:	f104 0c20 	add.w	ip, r4, #32
 8023640:	4637      	mov	r7, r6
 8023642:	6820      	ldr	r0, [r4, #0]
 8023644:	6861      	ldr	r1, [r4, #4]
 8023646:	3408      	adds	r4, #8
 8023648:	c703      	stmia	r7!, {r0, r1}
 802364a:	4564      	cmp	r4, ip
 802364c:	463e      	mov	r6, r7
 802364e:	d1f7      	bne.n	8023640 <__utoa+0x10>
 8023650:	7921      	ldrb	r1, [r4, #4]
 8023652:	6820      	ldr	r0, [r4, #0]
 8023654:	7139      	strb	r1, [r7, #4]
 8023656:	1e91      	subs	r1, r2, #2
 8023658:	2922      	cmp	r1, #34	; 0x22
 802365a:	6038      	str	r0, [r7, #0]
 802365c:	f04f 0100 	mov.w	r1, #0
 8023660:	d904      	bls.n	802366c <__utoa+0x3c>
 8023662:	7019      	strb	r1, [r3, #0]
 8023664:	460b      	mov	r3, r1
 8023666:	4618      	mov	r0, r3
 8023668:	b00b      	add	sp, #44	; 0x2c
 802366a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802366c:	1e58      	subs	r0, r3, #1
 802366e:	4684      	mov	ip, r0
 8023670:	fbb5 f7f2 	udiv	r7, r5, r2
 8023674:	fb02 5617 	mls	r6, r2, r7, r5
 8023678:	3628      	adds	r6, #40	; 0x28
 802367a:	446e      	add	r6, sp
 802367c:	f816 6c28 	ldrb.w	r6, [r6, #-40]
 8023680:	460c      	mov	r4, r1
 8023682:	f80c 6f01 	strb.w	r6, [ip, #1]!
 8023686:	462e      	mov	r6, r5
 8023688:	42b2      	cmp	r2, r6
 802368a:	463d      	mov	r5, r7
 802368c:	f101 0101 	add.w	r1, r1, #1
 8023690:	d9ee      	bls.n	8023670 <__utoa+0x40>
 8023692:	2200      	movs	r2, #0
 8023694:	545a      	strb	r2, [r3, r1]
 8023696:	1919      	adds	r1, r3, r4
 8023698:	1aa5      	subs	r5, r4, r2
 802369a:	42aa      	cmp	r2, r5
 802369c:	dae3      	bge.n	8023666 <__utoa+0x36>
 802369e:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 80236a2:	780e      	ldrb	r6, [r1, #0]
 80236a4:	3201      	adds	r2, #1
 80236a6:	7006      	strb	r6, [r0, #0]
 80236a8:	f801 5901 	strb.w	r5, [r1], #-1
 80236ac:	e7f4      	b.n	8023698 <__utoa+0x68>
 80236ae:	bf00      	nop
 80236b0:	08032e08 	.word	0x08032e08

080236b4 <swapfunc>:
 80236b4:	2b02      	cmp	r3, #2
 80236b6:	b510      	push	{r4, lr}
 80236b8:	d00a      	beq.n	80236d0 <swapfunc+0x1c>
 80236ba:	0892      	lsrs	r2, r2, #2
 80236bc:	6803      	ldr	r3, [r0, #0]
 80236be:	680c      	ldr	r4, [r1, #0]
 80236c0:	3a01      	subs	r2, #1
 80236c2:	2a00      	cmp	r2, #0
 80236c4:	f840 4b04 	str.w	r4, [r0], #4
 80236c8:	f841 3b04 	str.w	r3, [r1], #4
 80236cc:	dcf6      	bgt.n	80236bc <swapfunc+0x8>
 80236ce:	bd10      	pop	{r4, pc}
 80236d0:	4402      	add	r2, r0
 80236d2:	780c      	ldrb	r4, [r1, #0]
 80236d4:	7803      	ldrb	r3, [r0, #0]
 80236d6:	f800 4b01 	strb.w	r4, [r0], #1
 80236da:	f801 3b01 	strb.w	r3, [r1], #1
 80236de:	1a13      	subs	r3, r2, r0
 80236e0:	2b00      	cmp	r3, #0
 80236e2:	dcf6      	bgt.n	80236d2 <swapfunc+0x1e>
 80236e4:	e7f3      	b.n	80236ce <swapfunc+0x1a>

080236e6 <med3.constprop.0>:
 80236e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80236e8:	460c      	mov	r4, r1
 80236ea:	4615      	mov	r5, r2
 80236ec:	4607      	mov	r7, r0
 80236ee:	461e      	mov	r6, r3
 80236f0:	4798      	blx	r3
 80236f2:	2800      	cmp	r0, #0
 80236f4:	4629      	mov	r1, r5
 80236f6:	4620      	mov	r0, r4
 80236f8:	da0a      	bge.n	8023710 <med3.constprop.0+0x2a>
 80236fa:	47b0      	blx	r6
 80236fc:	2800      	cmp	r0, #0
 80236fe:	db05      	blt.n	802370c <med3.constprop.0+0x26>
 8023700:	4629      	mov	r1, r5
 8023702:	4638      	mov	r0, r7
 8023704:	47b0      	blx	r6
 8023706:	2800      	cmp	r0, #0
 8023708:	db0a      	blt.n	8023720 <med3.constprop.0+0x3a>
 802370a:	463c      	mov	r4, r7
 802370c:	4620      	mov	r0, r4
 802370e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023710:	47b0      	blx	r6
 8023712:	2800      	cmp	r0, #0
 8023714:	dcfa      	bgt.n	802370c <med3.constprop.0+0x26>
 8023716:	4629      	mov	r1, r5
 8023718:	4638      	mov	r0, r7
 802371a:	47b0      	blx	r6
 802371c:	2800      	cmp	r0, #0
 802371e:	dbf4      	blt.n	802370a <med3.constprop.0+0x24>
 8023720:	462c      	mov	r4, r5
 8023722:	e7f3      	b.n	802370c <med3.constprop.0+0x26>

08023724 <qsort>:
 8023724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023728:	469a      	mov	sl, r3
 802372a:	ea40 0302 	orr.w	r3, r0, r2
 802372e:	079b      	lsls	r3, r3, #30
 8023730:	4606      	mov	r6, r0
 8023732:	4614      	mov	r4, r2
 8023734:	b097      	sub	sp, #92	; 0x5c
 8023736:	d11a      	bne.n	802376e <qsort+0x4a>
 8023738:	f1b2 0804 	subs.w	r8, r2, #4
 802373c:	bf18      	it	ne
 802373e:	f04f 0801 	movne.w	r8, #1
 8023742:	2300      	movs	r3, #0
 8023744:	9302      	str	r3, [sp, #8]
 8023746:	fb04 f701 	mul.w	r7, r4, r1
 802374a:	1933      	adds	r3, r6, r4
 802374c:	9301      	str	r3, [sp, #4]
 802374e:	2906      	cmp	r1, #6
 8023750:	eb06 0307 	add.w	r3, r6, r7
 8023754:	9303      	str	r3, [sp, #12]
 8023756:	d82a      	bhi.n	80237ae <qsort+0x8a>
 8023758:	9b01      	ldr	r3, [sp, #4]
 802375a:	9a03      	ldr	r2, [sp, #12]
 802375c:	4293      	cmp	r3, r2
 802375e:	d310      	bcc.n	8023782 <qsort+0x5e>
 8023760:	9b02      	ldr	r3, [sp, #8]
 8023762:	2b00      	cmp	r3, #0
 8023764:	f040 811f 	bne.w	80239a6 <qsort+0x282>
 8023768:	b017      	add	sp, #92	; 0x5c
 802376a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802376e:	f04f 0802 	mov.w	r8, #2
 8023772:	e7e6      	b.n	8023742 <qsort+0x1e>
 8023774:	4643      	mov	r3, r8
 8023776:	4622      	mov	r2, r4
 8023778:	4639      	mov	r1, r7
 802377a:	4628      	mov	r0, r5
 802377c:	f7ff ff9a 	bl	80236b4 <swapfunc>
 8023780:	e00e      	b.n	80237a0 <qsort+0x7c>
 8023782:	9d01      	ldr	r5, [sp, #4]
 8023784:	e00d      	b.n	80237a2 <qsort+0x7e>
 8023786:	1b2f      	subs	r7, r5, r4
 8023788:	4629      	mov	r1, r5
 802378a:	4638      	mov	r0, r7
 802378c:	47d0      	blx	sl
 802378e:	2800      	cmp	r0, #0
 8023790:	dd09      	ble.n	80237a6 <qsort+0x82>
 8023792:	f1b8 0f00 	cmp.w	r8, #0
 8023796:	d1ed      	bne.n	8023774 <qsort+0x50>
 8023798:	682b      	ldr	r3, [r5, #0]
 802379a:	683a      	ldr	r2, [r7, #0]
 802379c:	602a      	str	r2, [r5, #0]
 802379e:	603b      	str	r3, [r7, #0]
 80237a0:	463d      	mov	r5, r7
 80237a2:	42ae      	cmp	r6, r5
 80237a4:	d3ef      	bcc.n	8023786 <qsort+0x62>
 80237a6:	9b01      	ldr	r3, [sp, #4]
 80237a8:	4423      	add	r3, r4
 80237aa:	9301      	str	r3, [sp, #4]
 80237ac:	e7d4      	b.n	8023758 <qsort+0x34>
 80237ae:	ea4f 0951 	mov.w	r9, r1, lsr #1
 80237b2:	1b3f      	subs	r7, r7, r4
 80237b4:	2907      	cmp	r1, #7
 80237b6:	fb04 6909 	mla	r9, r4, r9, r6
 80237ba:	4437      	add	r7, r6
 80237bc:	d021      	beq.n	8023802 <qsort+0xde>
 80237be:	2928      	cmp	r1, #40	; 0x28
 80237c0:	d944      	bls.n	802384c <qsort+0x128>
 80237c2:	08cd      	lsrs	r5, r1, #3
 80237c4:	4365      	muls	r5, r4
 80237c6:	4653      	mov	r3, sl
 80237c8:	eb06 0245 	add.w	r2, r6, r5, lsl #1
 80237cc:	1971      	adds	r1, r6, r5
 80237ce:	4630      	mov	r0, r6
 80237d0:	f7ff ff89 	bl	80236e6 <med3.constprop.0>
 80237d4:	4649      	mov	r1, r9
 80237d6:	eb09 0205 	add.w	r2, r9, r5
 80237da:	4653      	mov	r3, sl
 80237dc:	4683      	mov	fp, r0
 80237de:	1b48      	subs	r0, r1, r5
 80237e0:	f7ff ff81 	bl	80236e6 <med3.constprop.0>
 80237e4:	463a      	mov	r2, r7
 80237e6:	4681      	mov	r9, r0
 80237e8:	4653      	mov	r3, sl
 80237ea:	1b79      	subs	r1, r7, r5
 80237ec:	eba7 0045 	sub.w	r0, r7, r5, lsl #1
 80237f0:	f7ff ff79 	bl	80236e6 <med3.constprop.0>
 80237f4:	4602      	mov	r2, r0
 80237f6:	4649      	mov	r1, r9
 80237f8:	4653      	mov	r3, sl
 80237fa:	4658      	mov	r0, fp
 80237fc:	f7ff ff73 	bl	80236e6 <med3.constprop.0>
 8023800:	4681      	mov	r9, r0
 8023802:	f1b8 0f00 	cmp.w	r8, #0
 8023806:	d124      	bne.n	8023852 <qsort+0x12e>
 8023808:	6833      	ldr	r3, [r6, #0]
 802380a:	f8d9 2000 	ldr.w	r2, [r9]
 802380e:	6032      	str	r2, [r6, #0]
 8023810:	f8c9 3000 	str.w	r3, [r9]
 8023814:	eb06 0b04 	add.w	fp, r6, r4
 8023818:	46b9      	mov	r9, r7
 802381a:	465d      	mov	r5, fp
 802381c:	2300      	movs	r3, #0
 802381e:	45bb      	cmp	fp, r7
 8023820:	d835      	bhi.n	802388e <qsort+0x16a>
 8023822:	4631      	mov	r1, r6
 8023824:	4658      	mov	r0, fp
 8023826:	9304      	str	r3, [sp, #16]
 8023828:	47d0      	blx	sl
 802382a:	2800      	cmp	r0, #0
 802382c:	9b04      	ldr	r3, [sp, #16]
 802382e:	dc3e      	bgt.n	80238ae <qsort+0x18a>
 8023830:	d10a      	bne.n	8023848 <qsort+0x124>
 8023832:	f1b8 0f00 	cmp.w	r8, #0
 8023836:	d113      	bne.n	8023860 <qsort+0x13c>
 8023838:	682b      	ldr	r3, [r5, #0]
 802383a:	f8db 2000 	ldr.w	r2, [fp]
 802383e:	602a      	str	r2, [r5, #0]
 8023840:	f8cb 3000 	str.w	r3, [fp]
 8023844:	4425      	add	r5, r4
 8023846:	2301      	movs	r3, #1
 8023848:	44a3      	add	fp, r4
 802384a:	e7e8      	b.n	802381e <qsort+0xfa>
 802384c:	463a      	mov	r2, r7
 802384e:	46b3      	mov	fp, r6
 8023850:	e7d1      	b.n	80237f6 <qsort+0xd2>
 8023852:	4643      	mov	r3, r8
 8023854:	4622      	mov	r2, r4
 8023856:	4649      	mov	r1, r9
 8023858:	4630      	mov	r0, r6
 802385a:	f7ff ff2b 	bl	80236b4 <swapfunc>
 802385e:	e7d9      	b.n	8023814 <qsort+0xf0>
 8023860:	4643      	mov	r3, r8
 8023862:	4622      	mov	r2, r4
 8023864:	4659      	mov	r1, fp
 8023866:	4628      	mov	r0, r5
 8023868:	f7ff ff24 	bl	80236b4 <swapfunc>
 802386c:	e7ea      	b.n	8023844 <qsort+0x120>
 802386e:	d10b      	bne.n	8023888 <qsort+0x164>
 8023870:	f1b8 0f00 	cmp.w	r8, #0
 8023874:	d114      	bne.n	80238a0 <qsort+0x17c>
 8023876:	683b      	ldr	r3, [r7, #0]
 8023878:	f8d9 2000 	ldr.w	r2, [r9]
 802387c:	603a      	str	r2, [r7, #0]
 802387e:	f8c9 3000 	str.w	r3, [r9]
 8023882:	2301      	movs	r3, #1
 8023884:	eba9 0904 	sub.w	r9, r9, r4
 8023888:	9f04      	ldr	r7, [sp, #16]
 802388a:	45bb      	cmp	fp, r7
 802388c:	d90f      	bls.n	80238ae <qsort+0x18a>
 802388e:	2b00      	cmp	r3, #0
 8023890:	d143      	bne.n	802391a <qsort+0x1f6>
 8023892:	9b01      	ldr	r3, [sp, #4]
 8023894:	9a03      	ldr	r2, [sp, #12]
 8023896:	4293      	cmp	r3, r2
 8023898:	f4bf af62 	bcs.w	8023760 <qsort+0x3c>
 802389c:	9d01      	ldr	r5, [sp, #4]
 802389e:	e036      	b.n	802390e <qsort+0x1ea>
 80238a0:	4643      	mov	r3, r8
 80238a2:	4622      	mov	r2, r4
 80238a4:	4649      	mov	r1, r9
 80238a6:	4638      	mov	r0, r7
 80238a8:	f7ff ff04 	bl	80236b4 <swapfunc>
 80238ac:	e7e9      	b.n	8023882 <qsort+0x15e>
 80238ae:	4631      	mov	r1, r6
 80238b0:	4638      	mov	r0, r7
 80238b2:	9305      	str	r3, [sp, #20]
 80238b4:	47d0      	blx	sl
 80238b6:	1b3b      	subs	r3, r7, r4
 80238b8:	2800      	cmp	r0, #0
 80238ba:	9304      	str	r3, [sp, #16]
 80238bc:	9b05      	ldr	r3, [sp, #20]
 80238be:	dad6      	bge.n	802386e <qsort+0x14a>
 80238c0:	f1b8 0f00 	cmp.w	r8, #0
 80238c4:	d006      	beq.n	80238d4 <qsort+0x1b0>
 80238c6:	4643      	mov	r3, r8
 80238c8:	4622      	mov	r2, r4
 80238ca:	4639      	mov	r1, r7
 80238cc:	4658      	mov	r0, fp
 80238ce:	f7ff fef1 	bl	80236b4 <swapfunc>
 80238d2:	e005      	b.n	80238e0 <qsort+0x1bc>
 80238d4:	f8db 3000 	ldr.w	r3, [fp]
 80238d8:	683a      	ldr	r2, [r7, #0]
 80238da:	f8cb 2000 	str.w	r2, [fp]
 80238de:	603b      	str	r3, [r7, #0]
 80238e0:	9f04      	ldr	r7, [sp, #16]
 80238e2:	e7b0      	b.n	8023846 <qsort+0x122>
 80238e4:	4643      	mov	r3, r8
 80238e6:	4622      	mov	r2, r4
 80238e8:	4639      	mov	r1, r7
 80238ea:	4628      	mov	r0, r5
 80238ec:	f7ff fee2 	bl	80236b4 <swapfunc>
 80238f0:	e00c      	b.n	802390c <qsort+0x1e8>
 80238f2:	1b2f      	subs	r7, r5, r4
 80238f4:	4629      	mov	r1, r5
 80238f6:	4638      	mov	r0, r7
 80238f8:	47d0      	blx	sl
 80238fa:	2800      	cmp	r0, #0
 80238fc:	dd09      	ble.n	8023912 <qsort+0x1ee>
 80238fe:	f1b8 0f00 	cmp.w	r8, #0
 8023902:	d1ef      	bne.n	80238e4 <qsort+0x1c0>
 8023904:	682b      	ldr	r3, [r5, #0]
 8023906:	683a      	ldr	r2, [r7, #0]
 8023908:	602a      	str	r2, [r5, #0]
 802390a:	603b      	str	r3, [r7, #0]
 802390c:	463d      	mov	r5, r7
 802390e:	42ae      	cmp	r6, r5
 8023910:	d3ef      	bcc.n	80238f2 <qsort+0x1ce>
 8023912:	9b01      	ldr	r3, [sp, #4]
 8023914:	4423      	add	r3, r4
 8023916:	9301      	str	r3, [sp, #4]
 8023918:	e7bb      	b.n	8023892 <qsort+0x16e>
 802391a:	ebab 0305 	sub.w	r3, fp, r5
 802391e:	1baa      	subs	r2, r5, r6
 8023920:	429a      	cmp	r2, r3
 8023922:	bfa8      	it	ge
 8023924:	461a      	movge	r2, r3
 8023926:	9301      	str	r3, [sp, #4]
 8023928:	b12a      	cbz	r2, 8023936 <qsort+0x212>
 802392a:	4643      	mov	r3, r8
 802392c:	4630      	mov	r0, r6
 802392e:	ebab 0102 	sub.w	r1, fp, r2
 8023932:	f7ff febf 	bl	80236b4 <swapfunc>
 8023936:	9b03      	ldr	r3, [sp, #12]
 8023938:	eba9 0707 	sub.w	r7, r9, r7
 802393c:	eba3 0209 	sub.w	r2, r3, r9
 8023940:	1b12      	subs	r2, r2, r4
 8023942:	42ba      	cmp	r2, r7
 8023944:	bf28      	it	cs
 8023946:	463a      	movcs	r2, r7
 8023948:	b12a      	cbz	r2, 8023956 <qsort+0x232>
 802394a:	9903      	ldr	r1, [sp, #12]
 802394c:	4643      	mov	r3, r8
 802394e:	4658      	mov	r0, fp
 8023950:	1a89      	subs	r1, r1, r2
 8023952:	f7ff feaf 	bl	80236b4 <swapfunc>
 8023956:	f8dd 9004 	ldr.w	r9, [sp, #4]
 802395a:	9b03      	ldr	r3, [sp, #12]
 802395c:	454f      	cmp	r7, r9
 802395e:	eba3 0007 	sub.w	r0, r3, r7
 8023962:	d904      	bls.n	802396e <qsort+0x24a>
 8023964:	4633      	mov	r3, r6
 8023966:	4606      	mov	r6, r0
 8023968:	4618      	mov	r0, r3
 802396a:	46b9      	mov	r9, r7
 802396c:	9f01      	ldr	r7, [sp, #4]
 802396e:	42a7      	cmp	r7, r4
 8023970:	d923      	bls.n	80239ba <qsort+0x296>
 8023972:	9b02      	ldr	r3, [sp, #8]
 8023974:	fbb7 f1f4 	udiv	r1, r7, r4
 8023978:	2b07      	cmp	r3, #7
 802397a:	d80e      	bhi.n	802399a <qsort+0x276>
 802397c:	9a02      	ldr	r2, [sp, #8]
 802397e:	ab16      	add	r3, sp, #88	; 0x58
 8023980:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8023984:	fbb9 f2f4 	udiv	r2, r9, r4
 8023988:	f843 6c40 	str.w	r6, [r3, #-64]
 802398c:	f843 2c3c 	str.w	r2, [r3, #-60]
 8023990:	9b02      	ldr	r3, [sp, #8]
 8023992:	3301      	adds	r3, #1
 8023994:	9302      	str	r3, [sp, #8]
 8023996:	4606      	mov	r6, r0
 8023998:	e6d5      	b.n	8023746 <qsort+0x22>
 802399a:	4653      	mov	r3, sl
 802399c:	4622      	mov	r2, r4
 802399e:	f7ff fec1 	bl	8023724 <qsort>
 80239a2:	45a1      	cmp	r9, r4
 80239a4:	d80c      	bhi.n	80239c0 <qsort+0x29c>
 80239a6:	9b02      	ldr	r3, [sp, #8]
 80239a8:	3b01      	subs	r3, #1
 80239aa:	9302      	str	r3, [sp, #8]
 80239ac:	9a02      	ldr	r2, [sp, #8]
 80239ae:	ab16      	add	r3, sp, #88	; 0x58
 80239b0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80239b4:	e953 0110 	ldrd	r0, r1, [r3, #-64]	; 0x40
 80239b8:	e7ed      	b.n	8023996 <qsort+0x272>
 80239ba:	45a1      	cmp	r9, r4
 80239bc:	f67f aed0 	bls.w	8023760 <qsort+0x3c>
 80239c0:	fbb9 f1f4 	udiv	r1, r9, r4
 80239c4:	4630      	mov	r0, r6
 80239c6:	e7e6      	b.n	8023996 <qsort+0x272>

080239c8 <std>:
 80239c8:	2300      	movs	r3, #0
 80239ca:	b510      	push	{r4, lr}
 80239cc:	4604      	mov	r4, r0
 80239ce:	e9c0 3300 	strd	r3, r3, [r0]
 80239d2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80239d6:	6083      	str	r3, [r0, #8]
 80239d8:	8181      	strh	r1, [r0, #12]
 80239da:	6643      	str	r3, [r0, #100]	; 0x64
 80239dc:	81c2      	strh	r2, [r0, #14]
 80239de:	6183      	str	r3, [r0, #24]
 80239e0:	4619      	mov	r1, r3
 80239e2:	2208      	movs	r2, #8
 80239e4:	305c      	adds	r0, #92	; 0x5c
 80239e6:	f000 f916 	bl	8023c16 <memset>
 80239ea:	4b0d      	ldr	r3, [pc, #52]	; (8023a20 <std+0x58>)
 80239ec:	6224      	str	r4, [r4, #32]
 80239ee:	6263      	str	r3, [r4, #36]	; 0x24
 80239f0:	4b0c      	ldr	r3, [pc, #48]	; (8023a24 <std+0x5c>)
 80239f2:	62a3      	str	r3, [r4, #40]	; 0x28
 80239f4:	4b0c      	ldr	r3, [pc, #48]	; (8023a28 <std+0x60>)
 80239f6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80239f8:	4b0c      	ldr	r3, [pc, #48]	; (8023a2c <std+0x64>)
 80239fa:	6323      	str	r3, [r4, #48]	; 0x30
 80239fc:	4b0c      	ldr	r3, [pc, #48]	; (8023a30 <std+0x68>)
 80239fe:	429c      	cmp	r4, r3
 8023a00:	d006      	beq.n	8023a10 <std+0x48>
 8023a02:	f103 0268 	add.w	r2, r3, #104	; 0x68
 8023a06:	4294      	cmp	r4, r2
 8023a08:	d002      	beq.n	8023a10 <std+0x48>
 8023a0a:	33d0      	adds	r3, #208	; 0xd0
 8023a0c:	429c      	cmp	r4, r3
 8023a0e:	d105      	bne.n	8023a1c <std+0x54>
 8023a10:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8023a14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023a18:	f000 ba4e 	b.w	8023eb8 <__retarget_lock_init_recursive>
 8023a1c:	bd10      	pop	{r4, pc}
 8023a1e:	bf00      	nop
 8023a20:	08023b71 	.word	0x08023b71
 8023a24:	08023b93 	.word	0x08023b93
 8023a28:	08023bcb 	.word	0x08023bcb
 8023a2c:	08023bef 	.word	0x08023bef
 8023a30:	200021a4 	.word	0x200021a4

08023a34 <stdio_exit_handler>:
 8023a34:	4a02      	ldr	r2, [pc, #8]	; (8023a40 <stdio_exit_handler+0xc>)
 8023a36:	4903      	ldr	r1, [pc, #12]	; (8023a44 <stdio_exit_handler+0x10>)
 8023a38:	4803      	ldr	r0, [pc, #12]	; (8023a48 <stdio_exit_handler+0x14>)
 8023a3a:	f000 b87b 	b.w	8023b34 <_fwalk_sglue>
 8023a3e:	bf00      	nop
 8023a40:	200003e8 	.word	0x200003e8
 8023a44:	08024639 	.word	0x08024639
 8023a48:	200003f4 	.word	0x200003f4

08023a4c <cleanup_stdio>:
 8023a4c:	6841      	ldr	r1, [r0, #4]
 8023a4e:	4b0c      	ldr	r3, [pc, #48]	; (8023a80 <cleanup_stdio+0x34>)
 8023a50:	b510      	push	{r4, lr}
 8023a52:	4299      	cmp	r1, r3
 8023a54:	4604      	mov	r4, r0
 8023a56:	d001      	beq.n	8023a5c <cleanup_stdio+0x10>
 8023a58:	f000 fdee 	bl	8024638 <_fflush_r>
 8023a5c:	68a1      	ldr	r1, [r4, #8]
 8023a5e:	4b09      	ldr	r3, [pc, #36]	; (8023a84 <cleanup_stdio+0x38>)
 8023a60:	4299      	cmp	r1, r3
 8023a62:	d002      	beq.n	8023a6a <cleanup_stdio+0x1e>
 8023a64:	4620      	mov	r0, r4
 8023a66:	f000 fde7 	bl	8024638 <_fflush_r>
 8023a6a:	68e1      	ldr	r1, [r4, #12]
 8023a6c:	4b06      	ldr	r3, [pc, #24]	; (8023a88 <cleanup_stdio+0x3c>)
 8023a6e:	4299      	cmp	r1, r3
 8023a70:	d004      	beq.n	8023a7c <cleanup_stdio+0x30>
 8023a72:	4620      	mov	r0, r4
 8023a74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023a78:	f000 bdde 	b.w	8024638 <_fflush_r>
 8023a7c:	bd10      	pop	{r4, pc}
 8023a7e:	bf00      	nop
 8023a80:	200021a4 	.word	0x200021a4
 8023a84:	2000220c 	.word	0x2000220c
 8023a88:	20002274 	.word	0x20002274

08023a8c <global_stdio_init.part.0>:
 8023a8c:	b510      	push	{r4, lr}
 8023a8e:	4b0b      	ldr	r3, [pc, #44]	; (8023abc <global_stdio_init.part.0+0x30>)
 8023a90:	4c0b      	ldr	r4, [pc, #44]	; (8023ac0 <global_stdio_init.part.0+0x34>)
 8023a92:	4a0c      	ldr	r2, [pc, #48]	; (8023ac4 <global_stdio_init.part.0+0x38>)
 8023a94:	4620      	mov	r0, r4
 8023a96:	601a      	str	r2, [r3, #0]
 8023a98:	2104      	movs	r1, #4
 8023a9a:	2200      	movs	r2, #0
 8023a9c:	f7ff ff94 	bl	80239c8 <std>
 8023aa0:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8023aa4:	2201      	movs	r2, #1
 8023aa6:	2109      	movs	r1, #9
 8023aa8:	f7ff ff8e 	bl	80239c8 <std>
 8023aac:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8023ab0:	2202      	movs	r2, #2
 8023ab2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023ab6:	2112      	movs	r1, #18
 8023ab8:	f7ff bf86 	b.w	80239c8 <std>
 8023abc:	200022dc 	.word	0x200022dc
 8023ac0:	200021a4 	.word	0x200021a4
 8023ac4:	08023a35 	.word	0x08023a35

08023ac8 <__sfp_lock_acquire>:
 8023ac8:	4801      	ldr	r0, [pc, #4]	; (8023ad0 <__sfp_lock_acquire+0x8>)
 8023aca:	f000 b9f6 	b.w	8023eba <__retarget_lock_acquire_recursive>
 8023ace:	bf00      	nop
 8023ad0:	200022e5 	.word	0x200022e5

08023ad4 <__sfp_lock_release>:
 8023ad4:	4801      	ldr	r0, [pc, #4]	; (8023adc <__sfp_lock_release+0x8>)
 8023ad6:	f000 b9f1 	b.w	8023ebc <__retarget_lock_release_recursive>
 8023ada:	bf00      	nop
 8023adc:	200022e5 	.word	0x200022e5

08023ae0 <__sinit>:
 8023ae0:	b510      	push	{r4, lr}
 8023ae2:	4604      	mov	r4, r0
 8023ae4:	f7ff fff0 	bl	8023ac8 <__sfp_lock_acquire>
 8023ae8:	6a23      	ldr	r3, [r4, #32]
 8023aea:	b11b      	cbz	r3, 8023af4 <__sinit+0x14>
 8023aec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8023af0:	f7ff bff0 	b.w	8023ad4 <__sfp_lock_release>
 8023af4:	4b04      	ldr	r3, [pc, #16]	; (8023b08 <__sinit+0x28>)
 8023af6:	6223      	str	r3, [r4, #32]
 8023af8:	4b04      	ldr	r3, [pc, #16]	; (8023b0c <__sinit+0x2c>)
 8023afa:	681b      	ldr	r3, [r3, #0]
 8023afc:	2b00      	cmp	r3, #0
 8023afe:	d1f5      	bne.n	8023aec <__sinit+0xc>
 8023b00:	f7ff ffc4 	bl	8023a8c <global_stdio_init.part.0>
 8023b04:	e7f2      	b.n	8023aec <__sinit+0xc>
 8023b06:	bf00      	nop
 8023b08:	08023a4d 	.word	0x08023a4d
 8023b0c:	200022dc 	.word	0x200022dc

08023b10 <fiprintf>:
 8023b10:	b40e      	push	{r1, r2, r3}
 8023b12:	b503      	push	{r0, r1, lr}
 8023b14:	4601      	mov	r1, r0
 8023b16:	ab03      	add	r3, sp, #12
 8023b18:	4805      	ldr	r0, [pc, #20]	; (8023b30 <fiprintf+0x20>)
 8023b1a:	f853 2b04 	ldr.w	r2, [r3], #4
 8023b1e:	6800      	ldr	r0, [r0, #0]
 8023b20:	9301      	str	r3, [sp, #4]
 8023b22:	f000 fa59 	bl	8023fd8 <_vfiprintf_r>
 8023b26:	b002      	add	sp, #8
 8023b28:	f85d eb04 	ldr.w	lr, [sp], #4
 8023b2c:	b003      	add	sp, #12
 8023b2e:	4770      	bx	lr
 8023b30:	20000440 	.word	0x20000440

08023b34 <_fwalk_sglue>:
 8023b34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8023b38:	4607      	mov	r7, r0
 8023b3a:	4688      	mov	r8, r1
 8023b3c:	4614      	mov	r4, r2
 8023b3e:	2600      	movs	r6, #0
 8023b40:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8023b44:	f1b9 0901 	subs.w	r9, r9, #1
 8023b48:	d505      	bpl.n	8023b56 <_fwalk_sglue+0x22>
 8023b4a:	6824      	ldr	r4, [r4, #0]
 8023b4c:	2c00      	cmp	r4, #0
 8023b4e:	d1f7      	bne.n	8023b40 <_fwalk_sglue+0xc>
 8023b50:	4630      	mov	r0, r6
 8023b52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8023b56:	89ab      	ldrh	r3, [r5, #12]
 8023b58:	2b01      	cmp	r3, #1
 8023b5a:	d907      	bls.n	8023b6c <_fwalk_sglue+0x38>
 8023b5c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8023b60:	3301      	adds	r3, #1
 8023b62:	d003      	beq.n	8023b6c <_fwalk_sglue+0x38>
 8023b64:	4629      	mov	r1, r5
 8023b66:	4638      	mov	r0, r7
 8023b68:	47c0      	blx	r8
 8023b6a:	4306      	orrs	r6, r0
 8023b6c:	3568      	adds	r5, #104	; 0x68
 8023b6e:	e7e9      	b.n	8023b44 <_fwalk_sglue+0x10>

08023b70 <__sread>:
 8023b70:	b510      	push	{r4, lr}
 8023b72:	460c      	mov	r4, r1
 8023b74:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023b78:	f000 f940 	bl	8023dfc <_read_r>
 8023b7c:	2800      	cmp	r0, #0
 8023b7e:	bfab      	itete	ge
 8023b80:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8023b82:	89a3      	ldrhlt	r3, [r4, #12]
 8023b84:	181b      	addge	r3, r3, r0
 8023b86:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8023b8a:	bfac      	ite	ge
 8023b8c:	6563      	strge	r3, [r4, #84]	; 0x54
 8023b8e:	81a3      	strhlt	r3, [r4, #12]
 8023b90:	bd10      	pop	{r4, pc}

08023b92 <__swrite>:
 8023b92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023b96:	461f      	mov	r7, r3
 8023b98:	898b      	ldrh	r3, [r1, #12]
 8023b9a:	4605      	mov	r5, r0
 8023b9c:	05db      	lsls	r3, r3, #23
 8023b9e:	460c      	mov	r4, r1
 8023ba0:	4616      	mov	r6, r2
 8023ba2:	d505      	bpl.n	8023bb0 <__swrite+0x1e>
 8023ba4:	2302      	movs	r3, #2
 8023ba6:	2200      	movs	r2, #0
 8023ba8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023bac:	f000 f914 	bl	8023dd8 <_lseek_r>
 8023bb0:	89a3      	ldrh	r3, [r4, #12]
 8023bb2:	4632      	mov	r2, r6
 8023bb4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8023bb8:	81a3      	strh	r3, [r4, #12]
 8023bba:	4628      	mov	r0, r5
 8023bbc:	463b      	mov	r3, r7
 8023bbe:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023bc2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8023bc6:	f000 b93b 	b.w	8023e40 <_write_r>

08023bca <__sseek>:
 8023bca:	b510      	push	{r4, lr}
 8023bcc:	460c      	mov	r4, r1
 8023bce:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023bd2:	f000 f901 	bl	8023dd8 <_lseek_r>
 8023bd6:	1c43      	adds	r3, r0, #1
 8023bd8:	89a3      	ldrh	r3, [r4, #12]
 8023bda:	bf15      	itete	ne
 8023bdc:	6560      	strne	r0, [r4, #84]	; 0x54
 8023bde:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8023be2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8023be6:	81a3      	strheq	r3, [r4, #12]
 8023be8:	bf18      	it	ne
 8023bea:	81a3      	strhne	r3, [r4, #12]
 8023bec:	bd10      	pop	{r4, pc}

08023bee <__sclose>:
 8023bee:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023bf2:	f000 b8e1 	b.w	8023db8 <_close_r>

08023bf6 <memcmp>:
 8023bf6:	b510      	push	{r4, lr}
 8023bf8:	3901      	subs	r1, #1
 8023bfa:	4402      	add	r2, r0
 8023bfc:	4290      	cmp	r0, r2
 8023bfe:	d101      	bne.n	8023c04 <memcmp+0xe>
 8023c00:	2000      	movs	r0, #0
 8023c02:	e005      	b.n	8023c10 <memcmp+0x1a>
 8023c04:	7803      	ldrb	r3, [r0, #0]
 8023c06:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023c0a:	42a3      	cmp	r3, r4
 8023c0c:	d001      	beq.n	8023c12 <memcmp+0x1c>
 8023c0e:	1b18      	subs	r0, r3, r4
 8023c10:	bd10      	pop	{r4, pc}
 8023c12:	3001      	adds	r0, #1
 8023c14:	e7f2      	b.n	8023bfc <memcmp+0x6>

08023c16 <memset>:
 8023c16:	4603      	mov	r3, r0
 8023c18:	4402      	add	r2, r0
 8023c1a:	4293      	cmp	r3, r2
 8023c1c:	d100      	bne.n	8023c20 <memset+0xa>
 8023c1e:	4770      	bx	lr
 8023c20:	f803 1b01 	strb.w	r1, [r3], #1
 8023c24:	e7f9      	b.n	8023c1a <memset+0x4>

08023c26 <strcat>:
 8023c26:	4602      	mov	r2, r0
 8023c28:	b510      	push	{r4, lr}
 8023c2a:	7814      	ldrb	r4, [r2, #0]
 8023c2c:	4613      	mov	r3, r2
 8023c2e:	3201      	adds	r2, #1
 8023c30:	2c00      	cmp	r4, #0
 8023c32:	d1fa      	bne.n	8023c2a <strcat+0x4>
 8023c34:	3b01      	subs	r3, #1
 8023c36:	f811 2b01 	ldrb.w	r2, [r1], #1
 8023c3a:	f803 2f01 	strb.w	r2, [r3, #1]!
 8023c3e:	2a00      	cmp	r2, #0
 8023c40:	d1f9      	bne.n	8023c36 <strcat+0x10>
 8023c42:	bd10      	pop	{r4, pc}

08023c44 <strchr>:
 8023c44:	4603      	mov	r3, r0
 8023c46:	b2c9      	uxtb	r1, r1
 8023c48:	4618      	mov	r0, r3
 8023c4a:	f813 2b01 	ldrb.w	r2, [r3], #1
 8023c4e:	b112      	cbz	r2, 8023c56 <strchr+0x12>
 8023c50:	428a      	cmp	r2, r1
 8023c52:	d1f9      	bne.n	8023c48 <strchr+0x4>
 8023c54:	4770      	bx	lr
 8023c56:	2900      	cmp	r1, #0
 8023c58:	bf18      	it	ne
 8023c5a:	2000      	movne	r0, #0
 8023c5c:	4770      	bx	lr

08023c5e <strncmp>:
 8023c5e:	b510      	push	{r4, lr}
 8023c60:	b16a      	cbz	r2, 8023c7e <strncmp+0x20>
 8023c62:	3901      	subs	r1, #1
 8023c64:	1884      	adds	r4, r0, r2
 8023c66:	f810 2b01 	ldrb.w	r2, [r0], #1
 8023c6a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8023c6e:	429a      	cmp	r2, r3
 8023c70:	d103      	bne.n	8023c7a <strncmp+0x1c>
 8023c72:	42a0      	cmp	r0, r4
 8023c74:	d001      	beq.n	8023c7a <strncmp+0x1c>
 8023c76:	2a00      	cmp	r2, #0
 8023c78:	d1f5      	bne.n	8023c66 <strncmp+0x8>
 8023c7a:	1ad0      	subs	r0, r2, r3
 8023c7c:	bd10      	pop	{r4, pc}
 8023c7e:	4610      	mov	r0, r2
 8023c80:	e7fc      	b.n	8023c7c <strncmp+0x1e>

08023c82 <strncpy>:
 8023c82:	4603      	mov	r3, r0
 8023c84:	b510      	push	{r4, lr}
 8023c86:	3901      	subs	r1, #1
 8023c88:	b132      	cbz	r2, 8023c98 <strncpy+0x16>
 8023c8a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023c8e:	3a01      	subs	r2, #1
 8023c90:	f803 4b01 	strb.w	r4, [r3], #1
 8023c94:	2c00      	cmp	r4, #0
 8023c96:	d1f7      	bne.n	8023c88 <strncpy+0x6>
 8023c98:	2100      	movs	r1, #0
 8023c9a:	441a      	add	r2, r3
 8023c9c:	4293      	cmp	r3, r2
 8023c9e:	d100      	bne.n	8023ca2 <strncpy+0x20>
 8023ca0:	bd10      	pop	{r4, pc}
 8023ca2:	f803 1b01 	strb.w	r1, [r3], #1
 8023ca6:	e7f9      	b.n	8023c9c <strncpy+0x1a>

08023ca8 <strrchr>:
 8023ca8:	b538      	push	{r3, r4, r5, lr}
 8023caa:	f011 04ff 	ands.w	r4, r1, #255	; 0xff
 8023cae:	4603      	mov	r3, r0
 8023cb0:	d10e      	bne.n	8023cd0 <strrchr+0x28>
 8023cb2:	4621      	mov	r1, r4
 8023cb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8023cb8:	f7ff bfc4 	b.w	8023c44 <strchr>
 8023cbc:	4605      	mov	r5, r0
 8023cbe:	1c43      	adds	r3, r0, #1
 8023cc0:	4621      	mov	r1, r4
 8023cc2:	4618      	mov	r0, r3
 8023cc4:	f7ff ffbe 	bl	8023c44 <strchr>
 8023cc8:	2800      	cmp	r0, #0
 8023cca:	d1f7      	bne.n	8023cbc <strrchr+0x14>
 8023ccc:	4628      	mov	r0, r5
 8023cce:	bd38      	pop	{r3, r4, r5, pc}
 8023cd0:	2500      	movs	r5, #0
 8023cd2:	e7f5      	b.n	8023cc0 <strrchr+0x18>

08023cd4 <strtok>:
 8023cd4:	4b16      	ldr	r3, [pc, #88]	; (8023d30 <strtok+0x5c>)
 8023cd6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023cda:	681f      	ldr	r7, [r3, #0]
 8023cdc:	4605      	mov	r5, r0
 8023cde:	6c7c      	ldr	r4, [r7, #68]	; 0x44
 8023ce0:	460e      	mov	r6, r1
 8023ce2:	b9ec      	cbnz	r4, 8023d20 <strtok+0x4c>
 8023ce4:	2050      	movs	r0, #80	; 0x50
 8023ce6:	f7ff fbe7 	bl	80234b8 <malloc>
 8023cea:	4602      	mov	r2, r0
 8023cec:	6478      	str	r0, [r7, #68]	; 0x44
 8023cee:	b920      	cbnz	r0, 8023cfa <strtok+0x26>
 8023cf0:	215b      	movs	r1, #91	; 0x5b
 8023cf2:	4b10      	ldr	r3, [pc, #64]	; (8023d34 <strtok+0x60>)
 8023cf4:	4810      	ldr	r0, [pc, #64]	; (8023d38 <strtok+0x64>)
 8023cf6:	f7ff fb8b 	bl	8023410 <__assert_func>
 8023cfa:	e9c0 4400 	strd	r4, r4, [r0]
 8023cfe:	e9c0 4402 	strd	r4, r4, [r0, #8]
 8023d02:	e9c0 4404 	strd	r4, r4, [r0, #16]
 8023d06:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
 8023d0a:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
 8023d0e:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
 8023d12:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
 8023d16:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
 8023d1a:	6184      	str	r4, [r0, #24]
 8023d1c:	7704      	strb	r4, [r0, #28]
 8023d1e:	6244      	str	r4, [r0, #36]	; 0x24
 8023d20:	4631      	mov	r1, r6
 8023d22:	4628      	mov	r0, r5
 8023d24:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8023d26:	2301      	movs	r3, #1
 8023d28:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8023d2c:	f000 b806 	b.w	8023d3c <__strtok_r>
 8023d30:	20000440 	.word	0x20000440
 8023d34:	08032f2e 	.word	0x08032f2e
 8023d38:	08032f45 	.word	0x08032f45

08023d3c <__strtok_r>:
 8023d3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023d3e:	b908      	cbnz	r0, 8023d44 <__strtok_r+0x8>
 8023d40:	6810      	ldr	r0, [r2, #0]
 8023d42:	b188      	cbz	r0, 8023d68 <__strtok_r+0x2c>
 8023d44:	4604      	mov	r4, r0
 8023d46:	460f      	mov	r7, r1
 8023d48:	4620      	mov	r0, r4
 8023d4a:	f814 5b01 	ldrb.w	r5, [r4], #1
 8023d4e:	f817 6b01 	ldrb.w	r6, [r7], #1
 8023d52:	b91e      	cbnz	r6, 8023d5c <__strtok_r+0x20>
 8023d54:	b965      	cbnz	r5, 8023d70 <__strtok_r+0x34>
 8023d56:	4628      	mov	r0, r5
 8023d58:	6015      	str	r5, [r2, #0]
 8023d5a:	e005      	b.n	8023d68 <__strtok_r+0x2c>
 8023d5c:	42b5      	cmp	r5, r6
 8023d5e:	d1f6      	bne.n	8023d4e <__strtok_r+0x12>
 8023d60:	2b00      	cmp	r3, #0
 8023d62:	d1f0      	bne.n	8023d46 <__strtok_r+0xa>
 8023d64:	6014      	str	r4, [r2, #0]
 8023d66:	7003      	strb	r3, [r0, #0]
 8023d68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023d6a:	461c      	mov	r4, r3
 8023d6c:	e00c      	b.n	8023d88 <__strtok_r+0x4c>
 8023d6e:	b915      	cbnz	r5, 8023d76 <__strtok_r+0x3a>
 8023d70:	460e      	mov	r6, r1
 8023d72:	f814 3b01 	ldrb.w	r3, [r4], #1
 8023d76:	f816 5b01 	ldrb.w	r5, [r6], #1
 8023d7a:	42ab      	cmp	r3, r5
 8023d7c:	d1f7      	bne.n	8023d6e <__strtok_r+0x32>
 8023d7e:	2b00      	cmp	r3, #0
 8023d80:	d0f3      	beq.n	8023d6a <__strtok_r+0x2e>
 8023d82:	2300      	movs	r3, #0
 8023d84:	f804 3c01 	strb.w	r3, [r4, #-1]
 8023d88:	6014      	str	r4, [r2, #0]
 8023d8a:	e7ed      	b.n	8023d68 <__strtok_r+0x2c>

08023d8c <strstr>:
 8023d8c:	780a      	ldrb	r2, [r1, #0]
 8023d8e:	b570      	push	{r4, r5, r6, lr}
 8023d90:	b96a      	cbnz	r2, 8023dae <strstr+0x22>
 8023d92:	bd70      	pop	{r4, r5, r6, pc}
 8023d94:	429a      	cmp	r2, r3
 8023d96:	d109      	bne.n	8023dac <strstr+0x20>
 8023d98:	460c      	mov	r4, r1
 8023d9a:	4605      	mov	r5, r0
 8023d9c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8023da0:	2b00      	cmp	r3, #0
 8023da2:	d0f6      	beq.n	8023d92 <strstr+0x6>
 8023da4:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 8023da8:	429e      	cmp	r6, r3
 8023daa:	d0f7      	beq.n	8023d9c <strstr+0x10>
 8023dac:	3001      	adds	r0, #1
 8023dae:	7803      	ldrb	r3, [r0, #0]
 8023db0:	2b00      	cmp	r3, #0
 8023db2:	d1ef      	bne.n	8023d94 <strstr+0x8>
 8023db4:	4618      	mov	r0, r3
 8023db6:	e7ec      	b.n	8023d92 <strstr+0x6>

08023db8 <_close_r>:
 8023db8:	b538      	push	{r3, r4, r5, lr}
 8023dba:	2300      	movs	r3, #0
 8023dbc:	4d05      	ldr	r5, [pc, #20]	; (8023dd4 <_close_r+0x1c>)
 8023dbe:	4604      	mov	r4, r0
 8023dc0:	4608      	mov	r0, r1
 8023dc2:	602b      	str	r3, [r5, #0]
 8023dc4:	f7dd fc1d 	bl	8001602 <_close>
 8023dc8:	1c43      	adds	r3, r0, #1
 8023dca:	d102      	bne.n	8023dd2 <_close_r+0x1a>
 8023dcc:	682b      	ldr	r3, [r5, #0]
 8023dce:	b103      	cbz	r3, 8023dd2 <_close_r+0x1a>
 8023dd0:	6023      	str	r3, [r4, #0]
 8023dd2:	bd38      	pop	{r3, r4, r5, pc}
 8023dd4:	200022e0 	.word	0x200022e0

08023dd8 <_lseek_r>:
 8023dd8:	b538      	push	{r3, r4, r5, lr}
 8023dda:	4604      	mov	r4, r0
 8023ddc:	4608      	mov	r0, r1
 8023dde:	4611      	mov	r1, r2
 8023de0:	2200      	movs	r2, #0
 8023de2:	4d05      	ldr	r5, [pc, #20]	; (8023df8 <_lseek_r+0x20>)
 8023de4:	602a      	str	r2, [r5, #0]
 8023de6:	461a      	mov	r2, r3
 8023de8:	f7dd fc2f 	bl	800164a <_lseek>
 8023dec:	1c43      	adds	r3, r0, #1
 8023dee:	d102      	bne.n	8023df6 <_lseek_r+0x1e>
 8023df0:	682b      	ldr	r3, [r5, #0]
 8023df2:	b103      	cbz	r3, 8023df6 <_lseek_r+0x1e>
 8023df4:	6023      	str	r3, [r4, #0]
 8023df6:	bd38      	pop	{r3, r4, r5, pc}
 8023df8:	200022e0 	.word	0x200022e0

08023dfc <_read_r>:
 8023dfc:	b538      	push	{r3, r4, r5, lr}
 8023dfe:	4604      	mov	r4, r0
 8023e00:	4608      	mov	r0, r1
 8023e02:	4611      	mov	r1, r2
 8023e04:	2200      	movs	r2, #0
 8023e06:	4d05      	ldr	r5, [pc, #20]	; (8023e1c <_read_r+0x20>)
 8023e08:	602a      	str	r2, [r5, #0]
 8023e0a:	461a      	mov	r2, r3
 8023e0c:	f7dd fbc0 	bl	8001590 <_read>
 8023e10:	1c43      	adds	r3, r0, #1
 8023e12:	d102      	bne.n	8023e1a <_read_r+0x1e>
 8023e14:	682b      	ldr	r3, [r5, #0]
 8023e16:	b103      	cbz	r3, 8023e1a <_read_r+0x1e>
 8023e18:	6023      	str	r3, [r4, #0]
 8023e1a:	bd38      	pop	{r3, r4, r5, pc}
 8023e1c:	200022e0 	.word	0x200022e0

08023e20 <_sbrk_r>:
 8023e20:	b538      	push	{r3, r4, r5, lr}
 8023e22:	2300      	movs	r3, #0
 8023e24:	4d05      	ldr	r5, [pc, #20]	; (8023e3c <_sbrk_r+0x1c>)
 8023e26:	4604      	mov	r4, r0
 8023e28:	4608      	mov	r0, r1
 8023e2a:	602b      	str	r3, [r5, #0]
 8023e2c:	f7dd fc1a 	bl	8001664 <_sbrk>
 8023e30:	1c43      	adds	r3, r0, #1
 8023e32:	d102      	bne.n	8023e3a <_sbrk_r+0x1a>
 8023e34:	682b      	ldr	r3, [r5, #0]
 8023e36:	b103      	cbz	r3, 8023e3a <_sbrk_r+0x1a>
 8023e38:	6023      	str	r3, [r4, #0]
 8023e3a:	bd38      	pop	{r3, r4, r5, pc}
 8023e3c:	200022e0 	.word	0x200022e0

08023e40 <_write_r>:
 8023e40:	b538      	push	{r3, r4, r5, lr}
 8023e42:	4604      	mov	r4, r0
 8023e44:	4608      	mov	r0, r1
 8023e46:	4611      	mov	r1, r2
 8023e48:	2200      	movs	r2, #0
 8023e4a:	4d05      	ldr	r5, [pc, #20]	; (8023e60 <_write_r+0x20>)
 8023e4c:	602a      	str	r2, [r5, #0]
 8023e4e:	461a      	mov	r2, r3
 8023e50:	f7dd fbbb 	bl	80015ca <_write>
 8023e54:	1c43      	adds	r3, r0, #1
 8023e56:	d102      	bne.n	8023e5e <_write_r+0x1e>
 8023e58:	682b      	ldr	r3, [r5, #0]
 8023e5a:	b103      	cbz	r3, 8023e5e <_write_r+0x1e>
 8023e5c:	6023      	str	r3, [r4, #0]
 8023e5e:	bd38      	pop	{r3, r4, r5, pc}
 8023e60:	200022e0 	.word	0x200022e0

08023e64 <__errno>:
 8023e64:	4b01      	ldr	r3, [pc, #4]	; (8023e6c <__errno+0x8>)
 8023e66:	6818      	ldr	r0, [r3, #0]
 8023e68:	4770      	bx	lr
 8023e6a:	bf00      	nop
 8023e6c:	20000440 	.word	0x20000440

08023e70 <__libc_init_array>:
 8023e70:	b570      	push	{r4, r5, r6, lr}
 8023e72:	2600      	movs	r6, #0
 8023e74:	4d0c      	ldr	r5, [pc, #48]	; (8023ea8 <__libc_init_array+0x38>)
 8023e76:	4c0d      	ldr	r4, [pc, #52]	; (8023eac <__libc_init_array+0x3c>)
 8023e78:	1b64      	subs	r4, r4, r5
 8023e7a:	10a4      	asrs	r4, r4, #2
 8023e7c:	42a6      	cmp	r6, r4
 8023e7e:	d109      	bne.n	8023e94 <__libc_init_array+0x24>
 8023e80:	f002 fc38 	bl	80266f4 <_init>
 8023e84:	2600      	movs	r6, #0
 8023e86:	4d0a      	ldr	r5, [pc, #40]	; (8023eb0 <__libc_init_array+0x40>)
 8023e88:	4c0a      	ldr	r4, [pc, #40]	; (8023eb4 <__libc_init_array+0x44>)
 8023e8a:	1b64      	subs	r4, r4, r5
 8023e8c:	10a4      	asrs	r4, r4, #2
 8023e8e:	42a6      	cmp	r6, r4
 8023e90:	d105      	bne.n	8023e9e <__libc_init_array+0x2e>
 8023e92:	bd70      	pop	{r4, r5, r6, pc}
 8023e94:	f855 3b04 	ldr.w	r3, [r5], #4
 8023e98:	4798      	blx	r3
 8023e9a:	3601      	adds	r6, #1
 8023e9c:	e7ee      	b.n	8023e7c <__libc_init_array+0xc>
 8023e9e:	f855 3b04 	ldr.w	r3, [r5], #4
 8023ea2:	4798      	blx	r3
 8023ea4:	3601      	adds	r6, #1
 8023ea6:	e7f2      	b.n	8023e8e <__libc_init_array+0x1e>
 8023ea8:	08033430 	.word	0x08033430
 8023eac:	08033430 	.word	0x08033430
 8023eb0:	08033430 	.word	0x08033430
 8023eb4:	08033434 	.word	0x08033434

08023eb8 <__retarget_lock_init_recursive>:
 8023eb8:	4770      	bx	lr

08023eba <__retarget_lock_acquire_recursive>:
 8023eba:	4770      	bx	lr

08023ebc <__retarget_lock_release_recursive>:
 8023ebc:	4770      	bx	lr

08023ebe <strcpy>:
 8023ebe:	4603      	mov	r3, r0
 8023ec0:	f811 2b01 	ldrb.w	r2, [r1], #1
 8023ec4:	f803 2b01 	strb.w	r2, [r3], #1
 8023ec8:	2a00      	cmp	r2, #0
 8023eca:	d1f9      	bne.n	8023ec0 <strcpy+0x2>
 8023ecc:	4770      	bx	lr

08023ece <memcpy>:
 8023ece:	440a      	add	r2, r1
 8023ed0:	4291      	cmp	r1, r2
 8023ed2:	f100 33ff 	add.w	r3, r0, #4294967295
 8023ed6:	d100      	bne.n	8023eda <memcpy+0xc>
 8023ed8:	4770      	bx	lr
 8023eda:	b510      	push	{r4, lr}
 8023edc:	f811 4b01 	ldrb.w	r4, [r1], #1
 8023ee0:	4291      	cmp	r1, r2
 8023ee2:	f803 4f01 	strb.w	r4, [r3, #1]!
 8023ee6:	d1f9      	bne.n	8023edc <memcpy+0xe>
 8023ee8:	bd10      	pop	{r4, pc}

08023eea <abort>:
 8023eea:	2006      	movs	r0, #6
 8023eec:	b508      	push	{r3, lr}
 8023eee:	f000 fc89 	bl	8024804 <raise>
 8023ef2:	2001      	movs	r0, #1
 8023ef4:	f7dd fb42 	bl	800157c <_exit>

08023ef8 <_free_r>:
 8023ef8:	b538      	push	{r3, r4, r5, lr}
 8023efa:	4605      	mov	r5, r0
 8023efc:	2900      	cmp	r1, #0
 8023efe:	d040      	beq.n	8023f82 <_free_r+0x8a>
 8023f00:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8023f04:	1f0c      	subs	r4, r1, #4
 8023f06:	2b00      	cmp	r3, #0
 8023f08:	bfb8      	it	lt
 8023f0a:	18e4      	addlt	r4, r4, r3
 8023f0c:	f7ff fb84 	bl	8023618 <__malloc_lock>
 8023f10:	4a1c      	ldr	r2, [pc, #112]	; (8023f84 <_free_r+0x8c>)
 8023f12:	6813      	ldr	r3, [r2, #0]
 8023f14:	b933      	cbnz	r3, 8023f24 <_free_r+0x2c>
 8023f16:	6063      	str	r3, [r4, #4]
 8023f18:	6014      	str	r4, [r2, #0]
 8023f1a:	4628      	mov	r0, r5
 8023f1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8023f20:	f7ff bb80 	b.w	8023624 <__malloc_unlock>
 8023f24:	42a3      	cmp	r3, r4
 8023f26:	d908      	bls.n	8023f3a <_free_r+0x42>
 8023f28:	6820      	ldr	r0, [r4, #0]
 8023f2a:	1821      	adds	r1, r4, r0
 8023f2c:	428b      	cmp	r3, r1
 8023f2e:	bf01      	itttt	eq
 8023f30:	6819      	ldreq	r1, [r3, #0]
 8023f32:	685b      	ldreq	r3, [r3, #4]
 8023f34:	1809      	addeq	r1, r1, r0
 8023f36:	6021      	streq	r1, [r4, #0]
 8023f38:	e7ed      	b.n	8023f16 <_free_r+0x1e>
 8023f3a:	461a      	mov	r2, r3
 8023f3c:	685b      	ldr	r3, [r3, #4]
 8023f3e:	b10b      	cbz	r3, 8023f44 <_free_r+0x4c>
 8023f40:	42a3      	cmp	r3, r4
 8023f42:	d9fa      	bls.n	8023f3a <_free_r+0x42>
 8023f44:	6811      	ldr	r1, [r2, #0]
 8023f46:	1850      	adds	r0, r2, r1
 8023f48:	42a0      	cmp	r0, r4
 8023f4a:	d10b      	bne.n	8023f64 <_free_r+0x6c>
 8023f4c:	6820      	ldr	r0, [r4, #0]
 8023f4e:	4401      	add	r1, r0
 8023f50:	1850      	adds	r0, r2, r1
 8023f52:	4283      	cmp	r3, r0
 8023f54:	6011      	str	r1, [r2, #0]
 8023f56:	d1e0      	bne.n	8023f1a <_free_r+0x22>
 8023f58:	6818      	ldr	r0, [r3, #0]
 8023f5a:	685b      	ldr	r3, [r3, #4]
 8023f5c:	4408      	add	r0, r1
 8023f5e:	6010      	str	r0, [r2, #0]
 8023f60:	6053      	str	r3, [r2, #4]
 8023f62:	e7da      	b.n	8023f1a <_free_r+0x22>
 8023f64:	d902      	bls.n	8023f6c <_free_r+0x74>
 8023f66:	230c      	movs	r3, #12
 8023f68:	602b      	str	r3, [r5, #0]
 8023f6a:	e7d6      	b.n	8023f1a <_free_r+0x22>
 8023f6c:	6820      	ldr	r0, [r4, #0]
 8023f6e:	1821      	adds	r1, r4, r0
 8023f70:	428b      	cmp	r3, r1
 8023f72:	bf01      	itttt	eq
 8023f74:	6819      	ldreq	r1, [r3, #0]
 8023f76:	685b      	ldreq	r3, [r3, #4]
 8023f78:	1809      	addeq	r1, r1, r0
 8023f7a:	6021      	streq	r1, [r4, #0]
 8023f7c:	6063      	str	r3, [r4, #4]
 8023f7e:	6054      	str	r4, [r2, #4]
 8023f80:	e7cb      	b.n	8023f1a <_free_r+0x22>
 8023f82:	bd38      	pop	{r3, r4, r5, pc}
 8023f84:	2000219c 	.word	0x2000219c

08023f88 <__sfputc_r>:
 8023f88:	6893      	ldr	r3, [r2, #8]
 8023f8a:	b410      	push	{r4}
 8023f8c:	3b01      	subs	r3, #1
 8023f8e:	2b00      	cmp	r3, #0
 8023f90:	6093      	str	r3, [r2, #8]
 8023f92:	da07      	bge.n	8023fa4 <__sfputc_r+0x1c>
 8023f94:	6994      	ldr	r4, [r2, #24]
 8023f96:	42a3      	cmp	r3, r4
 8023f98:	db01      	blt.n	8023f9e <__sfputc_r+0x16>
 8023f9a:	290a      	cmp	r1, #10
 8023f9c:	d102      	bne.n	8023fa4 <__sfputc_r+0x1c>
 8023f9e:	bc10      	pop	{r4}
 8023fa0:	f000 bb72 	b.w	8024688 <__swbuf_r>
 8023fa4:	6813      	ldr	r3, [r2, #0]
 8023fa6:	1c58      	adds	r0, r3, #1
 8023fa8:	6010      	str	r0, [r2, #0]
 8023faa:	7019      	strb	r1, [r3, #0]
 8023fac:	4608      	mov	r0, r1
 8023fae:	bc10      	pop	{r4}
 8023fb0:	4770      	bx	lr

08023fb2 <__sfputs_r>:
 8023fb2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023fb4:	4606      	mov	r6, r0
 8023fb6:	460f      	mov	r7, r1
 8023fb8:	4614      	mov	r4, r2
 8023fba:	18d5      	adds	r5, r2, r3
 8023fbc:	42ac      	cmp	r4, r5
 8023fbe:	d101      	bne.n	8023fc4 <__sfputs_r+0x12>
 8023fc0:	2000      	movs	r0, #0
 8023fc2:	e007      	b.n	8023fd4 <__sfputs_r+0x22>
 8023fc4:	463a      	mov	r2, r7
 8023fc6:	4630      	mov	r0, r6
 8023fc8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8023fcc:	f7ff ffdc 	bl	8023f88 <__sfputc_r>
 8023fd0:	1c43      	adds	r3, r0, #1
 8023fd2:	d1f3      	bne.n	8023fbc <__sfputs_r+0xa>
 8023fd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08023fd8 <_vfiprintf_r>:
 8023fd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023fdc:	460d      	mov	r5, r1
 8023fde:	4614      	mov	r4, r2
 8023fe0:	4698      	mov	r8, r3
 8023fe2:	4606      	mov	r6, r0
 8023fe4:	b09d      	sub	sp, #116	; 0x74
 8023fe6:	b118      	cbz	r0, 8023ff0 <_vfiprintf_r+0x18>
 8023fe8:	6a03      	ldr	r3, [r0, #32]
 8023fea:	b90b      	cbnz	r3, 8023ff0 <_vfiprintf_r+0x18>
 8023fec:	f7ff fd78 	bl	8023ae0 <__sinit>
 8023ff0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8023ff2:	07d9      	lsls	r1, r3, #31
 8023ff4:	d405      	bmi.n	8024002 <_vfiprintf_r+0x2a>
 8023ff6:	89ab      	ldrh	r3, [r5, #12]
 8023ff8:	059a      	lsls	r2, r3, #22
 8023ffa:	d402      	bmi.n	8024002 <_vfiprintf_r+0x2a>
 8023ffc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8023ffe:	f7ff ff5c 	bl	8023eba <__retarget_lock_acquire_recursive>
 8024002:	89ab      	ldrh	r3, [r5, #12]
 8024004:	071b      	lsls	r3, r3, #28
 8024006:	d501      	bpl.n	802400c <_vfiprintf_r+0x34>
 8024008:	692b      	ldr	r3, [r5, #16]
 802400a:	b99b      	cbnz	r3, 8024034 <_vfiprintf_r+0x5c>
 802400c:	4629      	mov	r1, r5
 802400e:	4630      	mov	r0, r6
 8024010:	f000 fb78 	bl	8024704 <__swsetup_r>
 8024014:	b170      	cbz	r0, 8024034 <_vfiprintf_r+0x5c>
 8024016:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8024018:	07dc      	lsls	r4, r3, #31
 802401a:	d504      	bpl.n	8024026 <_vfiprintf_r+0x4e>
 802401c:	f04f 30ff 	mov.w	r0, #4294967295
 8024020:	b01d      	add	sp, #116	; 0x74
 8024022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024026:	89ab      	ldrh	r3, [r5, #12]
 8024028:	0598      	lsls	r0, r3, #22
 802402a:	d4f7      	bmi.n	802401c <_vfiprintf_r+0x44>
 802402c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 802402e:	f7ff ff45 	bl	8023ebc <__retarget_lock_release_recursive>
 8024032:	e7f3      	b.n	802401c <_vfiprintf_r+0x44>
 8024034:	2300      	movs	r3, #0
 8024036:	9309      	str	r3, [sp, #36]	; 0x24
 8024038:	2320      	movs	r3, #32
 802403a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802403e:	2330      	movs	r3, #48	; 0x30
 8024040:	f04f 0901 	mov.w	r9, #1
 8024044:	f8cd 800c 	str.w	r8, [sp, #12]
 8024048:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 80241f8 <_vfiprintf_r+0x220>
 802404c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8024050:	4623      	mov	r3, r4
 8024052:	469a      	mov	sl, r3
 8024054:	f813 2b01 	ldrb.w	r2, [r3], #1
 8024058:	b10a      	cbz	r2, 802405e <_vfiprintf_r+0x86>
 802405a:	2a25      	cmp	r2, #37	; 0x25
 802405c:	d1f9      	bne.n	8024052 <_vfiprintf_r+0x7a>
 802405e:	ebba 0b04 	subs.w	fp, sl, r4
 8024062:	d00b      	beq.n	802407c <_vfiprintf_r+0xa4>
 8024064:	465b      	mov	r3, fp
 8024066:	4622      	mov	r2, r4
 8024068:	4629      	mov	r1, r5
 802406a:	4630      	mov	r0, r6
 802406c:	f7ff ffa1 	bl	8023fb2 <__sfputs_r>
 8024070:	3001      	adds	r0, #1
 8024072:	f000 80a9 	beq.w	80241c8 <_vfiprintf_r+0x1f0>
 8024076:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024078:	445a      	add	r2, fp
 802407a:	9209      	str	r2, [sp, #36]	; 0x24
 802407c:	f89a 3000 	ldrb.w	r3, [sl]
 8024080:	2b00      	cmp	r3, #0
 8024082:	f000 80a1 	beq.w	80241c8 <_vfiprintf_r+0x1f0>
 8024086:	2300      	movs	r3, #0
 8024088:	f04f 32ff 	mov.w	r2, #4294967295
 802408c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8024090:	f10a 0a01 	add.w	sl, sl, #1
 8024094:	9304      	str	r3, [sp, #16]
 8024096:	9307      	str	r3, [sp, #28]
 8024098:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 802409c:	931a      	str	r3, [sp, #104]	; 0x68
 802409e:	4654      	mov	r4, sl
 80240a0:	2205      	movs	r2, #5
 80240a2:	f814 1b01 	ldrb.w	r1, [r4], #1
 80240a6:	4854      	ldr	r0, [pc, #336]	; (80241f8 <_vfiprintf_r+0x220>)
 80240a8:	f000 fbc8 	bl	802483c <memchr>
 80240ac:	9a04      	ldr	r2, [sp, #16]
 80240ae:	b9d8      	cbnz	r0, 80240e8 <_vfiprintf_r+0x110>
 80240b0:	06d1      	lsls	r1, r2, #27
 80240b2:	bf44      	itt	mi
 80240b4:	2320      	movmi	r3, #32
 80240b6:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80240ba:	0713      	lsls	r3, r2, #28
 80240bc:	bf44      	itt	mi
 80240be:	232b      	movmi	r3, #43	; 0x2b
 80240c0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80240c4:	f89a 3000 	ldrb.w	r3, [sl]
 80240c8:	2b2a      	cmp	r3, #42	; 0x2a
 80240ca:	d015      	beq.n	80240f8 <_vfiprintf_r+0x120>
 80240cc:	4654      	mov	r4, sl
 80240ce:	2000      	movs	r0, #0
 80240d0:	f04f 0c0a 	mov.w	ip, #10
 80240d4:	9a07      	ldr	r2, [sp, #28]
 80240d6:	4621      	mov	r1, r4
 80240d8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80240dc:	3b30      	subs	r3, #48	; 0x30
 80240de:	2b09      	cmp	r3, #9
 80240e0:	d94d      	bls.n	802417e <_vfiprintf_r+0x1a6>
 80240e2:	b1b0      	cbz	r0, 8024112 <_vfiprintf_r+0x13a>
 80240e4:	9207      	str	r2, [sp, #28]
 80240e6:	e014      	b.n	8024112 <_vfiprintf_r+0x13a>
 80240e8:	eba0 0308 	sub.w	r3, r0, r8
 80240ec:	fa09 f303 	lsl.w	r3, r9, r3
 80240f0:	4313      	orrs	r3, r2
 80240f2:	46a2      	mov	sl, r4
 80240f4:	9304      	str	r3, [sp, #16]
 80240f6:	e7d2      	b.n	802409e <_vfiprintf_r+0xc6>
 80240f8:	9b03      	ldr	r3, [sp, #12]
 80240fa:	1d19      	adds	r1, r3, #4
 80240fc:	681b      	ldr	r3, [r3, #0]
 80240fe:	9103      	str	r1, [sp, #12]
 8024100:	2b00      	cmp	r3, #0
 8024102:	bfbb      	ittet	lt
 8024104:	425b      	neglt	r3, r3
 8024106:	f042 0202 	orrlt.w	r2, r2, #2
 802410a:	9307      	strge	r3, [sp, #28]
 802410c:	9307      	strlt	r3, [sp, #28]
 802410e:	bfb8      	it	lt
 8024110:	9204      	strlt	r2, [sp, #16]
 8024112:	7823      	ldrb	r3, [r4, #0]
 8024114:	2b2e      	cmp	r3, #46	; 0x2e
 8024116:	d10c      	bne.n	8024132 <_vfiprintf_r+0x15a>
 8024118:	7863      	ldrb	r3, [r4, #1]
 802411a:	2b2a      	cmp	r3, #42	; 0x2a
 802411c:	d134      	bne.n	8024188 <_vfiprintf_r+0x1b0>
 802411e:	9b03      	ldr	r3, [sp, #12]
 8024120:	3402      	adds	r4, #2
 8024122:	1d1a      	adds	r2, r3, #4
 8024124:	681b      	ldr	r3, [r3, #0]
 8024126:	9203      	str	r2, [sp, #12]
 8024128:	2b00      	cmp	r3, #0
 802412a:	bfb8      	it	lt
 802412c:	f04f 33ff 	movlt.w	r3, #4294967295
 8024130:	9305      	str	r3, [sp, #20]
 8024132:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 80241fc <_vfiprintf_r+0x224>
 8024136:	2203      	movs	r2, #3
 8024138:	4650      	mov	r0, sl
 802413a:	7821      	ldrb	r1, [r4, #0]
 802413c:	f000 fb7e 	bl	802483c <memchr>
 8024140:	b138      	cbz	r0, 8024152 <_vfiprintf_r+0x17a>
 8024142:	2240      	movs	r2, #64	; 0x40
 8024144:	9b04      	ldr	r3, [sp, #16]
 8024146:	eba0 000a 	sub.w	r0, r0, sl
 802414a:	4082      	lsls	r2, r0
 802414c:	4313      	orrs	r3, r2
 802414e:	3401      	adds	r4, #1
 8024150:	9304      	str	r3, [sp, #16]
 8024152:	f814 1b01 	ldrb.w	r1, [r4], #1
 8024156:	2206      	movs	r2, #6
 8024158:	4829      	ldr	r0, [pc, #164]	; (8024200 <_vfiprintf_r+0x228>)
 802415a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802415e:	f000 fb6d 	bl	802483c <memchr>
 8024162:	2800      	cmp	r0, #0
 8024164:	d03f      	beq.n	80241e6 <_vfiprintf_r+0x20e>
 8024166:	4b27      	ldr	r3, [pc, #156]	; (8024204 <_vfiprintf_r+0x22c>)
 8024168:	bb1b      	cbnz	r3, 80241b2 <_vfiprintf_r+0x1da>
 802416a:	9b03      	ldr	r3, [sp, #12]
 802416c:	3307      	adds	r3, #7
 802416e:	f023 0307 	bic.w	r3, r3, #7
 8024172:	3308      	adds	r3, #8
 8024174:	9303      	str	r3, [sp, #12]
 8024176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024178:	443b      	add	r3, r7
 802417a:	9309      	str	r3, [sp, #36]	; 0x24
 802417c:	e768      	b.n	8024050 <_vfiprintf_r+0x78>
 802417e:	460c      	mov	r4, r1
 8024180:	2001      	movs	r0, #1
 8024182:	fb0c 3202 	mla	r2, ip, r2, r3
 8024186:	e7a6      	b.n	80240d6 <_vfiprintf_r+0xfe>
 8024188:	2300      	movs	r3, #0
 802418a:	f04f 0c0a 	mov.w	ip, #10
 802418e:	4619      	mov	r1, r3
 8024190:	3401      	adds	r4, #1
 8024192:	9305      	str	r3, [sp, #20]
 8024194:	4620      	mov	r0, r4
 8024196:	f810 2b01 	ldrb.w	r2, [r0], #1
 802419a:	3a30      	subs	r2, #48	; 0x30
 802419c:	2a09      	cmp	r2, #9
 802419e:	d903      	bls.n	80241a8 <_vfiprintf_r+0x1d0>
 80241a0:	2b00      	cmp	r3, #0
 80241a2:	d0c6      	beq.n	8024132 <_vfiprintf_r+0x15a>
 80241a4:	9105      	str	r1, [sp, #20]
 80241a6:	e7c4      	b.n	8024132 <_vfiprintf_r+0x15a>
 80241a8:	4604      	mov	r4, r0
 80241aa:	2301      	movs	r3, #1
 80241ac:	fb0c 2101 	mla	r1, ip, r1, r2
 80241b0:	e7f0      	b.n	8024194 <_vfiprintf_r+0x1bc>
 80241b2:	ab03      	add	r3, sp, #12
 80241b4:	9300      	str	r3, [sp, #0]
 80241b6:	462a      	mov	r2, r5
 80241b8:	4630      	mov	r0, r6
 80241ba:	4b13      	ldr	r3, [pc, #76]	; (8024208 <_vfiprintf_r+0x230>)
 80241bc:	a904      	add	r1, sp, #16
 80241be:	f3af 8000 	nop.w
 80241c2:	4607      	mov	r7, r0
 80241c4:	1c78      	adds	r0, r7, #1
 80241c6:	d1d6      	bne.n	8024176 <_vfiprintf_r+0x19e>
 80241c8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80241ca:	07d9      	lsls	r1, r3, #31
 80241cc:	d405      	bmi.n	80241da <_vfiprintf_r+0x202>
 80241ce:	89ab      	ldrh	r3, [r5, #12]
 80241d0:	059a      	lsls	r2, r3, #22
 80241d2:	d402      	bmi.n	80241da <_vfiprintf_r+0x202>
 80241d4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80241d6:	f7ff fe71 	bl	8023ebc <__retarget_lock_release_recursive>
 80241da:	89ab      	ldrh	r3, [r5, #12]
 80241dc:	065b      	lsls	r3, r3, #25
 80241de:	f53f af1d 	bmi.w	802401c <_vfiprintf_r+0x44>
 80241e2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80241e4:	e71c      	b.n	8024020 <_vfiprintf_r+0x48>
 80241e6:	ab03      	add	r3, sp, #12
 80241e8:	9300      	str	r3, [sp, #0]
 80241ea:	462a      	mov	r2, r5
 80241ec:	4630      	mov	r0, r6
 80241ee:	4b06      	ldr	r3, [pc, #24]	; (8024208 <_vfiprintf_r+0x230>)
 80241f0:	a904      	add	r1, sp, #16
 80241f2:	f000 f87d 	bl	80242f0 <_printf_i>
 80241f6:	e7e4      	b.n	80241c2 <_vfiprintf_r+0x1ea>
 80241f8:	08032f9f 	.word	0x08032f9f
 80241fc:	08032fa5 	.word	0x08032fa5
 8024200:	08032fa9 	.word	0x08032fa9
 8024204:	00000000 	.word	0x00000000
 8024208:	08023fb3 	.word	0x08023fb3

0802420c <_printf_common>:
 802420c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024210:	4616      	mov	r6, r2
 8024212:	4699      	mov	r9, r3
 8024214:	688a      	ldr	r2, [r1, #8]
 8024216:	690b      	ldr	r3, [r1, #16]
 8024218:	4607      	mov	r7, r0
 802421a:	4293      	cmp	r3, r2
 802421c:	bfb8      	it	lt
 802421e:	4613      	movlt	r3, r2
 8024220:	6033      	str	r3, [r6, #0]
 8024222:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8024226:	460c      	mov	r4, r1
 8024228:	f8dd 8020 	ldr.w	r8, [sp, #32]
 802422c:	b10a      	cbz	r2, 8024232 <_printf_common+0x26>
 802422e:	3301      	adds	r3, #1
 8024230:	6033      	str	r3, [r6, #0]
 8024232:	6823      	ldr	r3, [r4, #0]
 8024234:	0699      	lsls	r1, r3, #26
 8024236:	bf42      	ittt	mi
 8024238:	6833      	ldrmi	r3, [r6, #0]
 802423a:	3302      	addmi	r3, #2
 802423c:	6033      	strmi	r3, [r6, #0]
 802423e:	6825      	ldr	r5, [r4, #0]
 8024240:	f015 0506 	ands.w	r5, r5, #6
 8024244:	d106      	bne.n	8024254 <_printf_common+0x48>
 8024246:	f104 0a19 	add.w	sl, r4, #25
 802424a:	68e3      	ldr	r3, [r4, #12]
 802424c:	6832      	ldr	r2, [r6, #0]
 802424e:	1a9b      	subs	r3, r3, r2
 8024250:	42ab      	cmp	r3, r5
 8024252:	dc2b      	bgt.n	80242ac <_printf_common+0xa0>
 8024254:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8024258:	1e13      	subs	r3, r2, #0
 802425a:	6822      	ldr	r2, [r4, #0]
 802425c:	bf18      	it	ne
 802425e:	2301      	movne	r3, #1
 8024260:	0692      	lsls	r2, r2, #26
 8024262:	d430      	bmi.n	80242c6 <_printf_common+0xba>
 8024264:	4649      	mov	r1, r9
 8024266:	4638      	mov	r0, r7
 8024268:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802426c:	47c0      	blx	r8
 802426e:	3001      	adds	r0, #1
 8024270:	d023      	beq.n	80242ba <_printf_common+0xae>
 8024272:	6823      	ldr	r3, [r4, #0]
 8024274:	6922      	ldr	r2, [r4, #16]
 8024276:	f003 0306 	and.w	r3, r3, #6
 802427a:	2b04      	cmp	r3, #4
 802427c:	bf14      	ite	ne
 802427e:	2500      	movne	r5, #0
 8024280:	6833      	ldreq	r3, [r6, #0]
 8024282:	f04f 0600 	mov.w	r6, #0
 8024286:	bf08      	it	eq
 8024288:	68e5      	ldreq	r5, [r4, #12]
 802428a:	f104 041a 	add.w	r4, r4, #26
 802428e:	bf08      	it	eq
 8024290:	1aed      	subeq	r5, r5, r3
 8024292:	f854 3c12 	ldr.w	r3, [r4, #-18]
 8024296:	bf08      	it	eq
 8024298:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802429c:	4293      	cmp	r3, r2
 802429e:	bfc4      	itt	gt
 80242a0:	1a9b      	subgt	r3, r3, r2
 80242a2:	18ed      	addgt	r5, r5, r3
 80242a4:	42b5      	cmp	r5, r6
 80242a6:	d11a      	bne.n	80242de <_printf_common+0xd2>
 80242a8:	2000      	movs	r0, #0
 80242aa:	e008      	b.n	80242be <_printf_common+0xb2>
 80242ac:	2301      	movs	r3, #1
 80242ae:	4652      	mov	r2, sl
 80242b0:	4649      	mov	r1, r9
 80242b2:	4638      	mov	r0, r7
 80242b4:	47c0      	blx	r8
 80242b6:	3001      	adds	r0, #1
 80242b8:	d103      	bne.n	80242c2 <_printf_common+0xb6>
 80242ba:	f04f 30ff 	mov.w	r0, #4294967295
 80242be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80242c2:	3501      	adds	r5, #1
 80242c4:	e7c1      	b.n	802424a <_printf_common+0x3e>
 80242c6:	2030      	movs	r0, #48	; 0x30
 80242c8:	18e1      	adds	r1, r4, r3
 80242ca:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80242ce:	1c5a      	adds	r2, r3, #1
 80242d0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80242d4:	4422      	add	r2, r4
 80242d6:	3302      	adds	r3, #2
 80242d8:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80242dc:	e7c2      	b.n	8024264 <_printf_common+0x58>
 80242de:	2301      	movs	r3, #1
 80242e0:	4622      	mov	r2, r4
 80242e2:	4649      	mov	r1, r9
 80242e4:	4638      	mov	r0, r7
 80242e6:	47c0      	blx	r8
 80242e8:	3001      	adds	r0, #1
 80242ea:	d0e6      	beq.n	80242ba <_printf_common+0xae>
 80242ec:	3601      	adds	r6, #1
 80242ee:	e7d9      	b.n	80242a4 <_printf_common+0x98>

080242f0 <_printf_i>:
 80242f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80242f4:	7e0f      	ldrb	r7, [r1, #24]
 80242f6:	4691      	mov	r9, r2
 80242f8:	2f78      	cmp	r7, #120	; 0x78
 80242fa:	4680      	mov	r8, r0
 80242fc:	460c      	mov	r4, r1
 80242fe:	469a      	mov	sl, r3
 8024300:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8024302:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8024306:	d807      	bhi.n	8024318 <_printf_i+0x28>
 8024308:	2f62      	cmp	r7, #98	; 0x62
 802430a:	d80a      	bhi.n	8024322 <_printf_i+0x32>
 802430c:	2f00      	cmp	r7, #0
 802430e:	f000 80d5 	beq.w	80244bc <_printf_i+0x1cc>
 8024312:	2f58      	cmp	r7, #88	; 0x58
 8024314:	f000 80c1 	beq.w	802449a <_printf_i+0x1aa>
 8024318:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802431c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8024320:	e03a      	b.n	8024398 <_printf_i+0xa8>
 8024322:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8024326:	2b15      	cmp	r3, #21
 8024328:	d8f6      	bhi.n	8024318 <_printf_i+0x28>
 802432a:	a101      	add	r1, pc, #4	; (adr r1, 8024330 <_printf_i+0x40>)
 802432c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8024330:	08024389 	.word	0x08024389
 8024334:	0802439d 	.word	0x0802439d
 8024338:	08024319 	.word	0x08024319
 802433c:	08024319 	.word	0x08024319
 8024340:	08024319 	.word	0x08024319
 8024344:	08024319 	.word	0x08024319
 8024348:	0802439d 	.word	0x0802439d
 802434c:	08024319 	.word	0x08024319
 8024350:	08024319 	.word	0x08024319
 8024354:	08024319 	.word	0x08024319
 8024358:	08024319 	.word	0x08024319
 802435c:	080244a3 	.word	0x080244a3
 8024360:	080243c9 	.word	0x080243c9
 8024364:	0802445d 	.word	0x0802445d
 8024368:	08024319 	.word	0x08024319
 802436c:	08024319 	.word	0x08024319
 8024370:	080244c5 	.word	0x080244c5
 8024374:	08024319 	.word	0x08024319
 8024378:	080243c9 	.word	0x080243c9
 802437c:	08024319 	.word	0x08024319
 8024380:	08024319 	.word	0x08024319
 8024384:	08024465 	.word	0x08024465
 8024388:	682b      	ldr	r3, [r5, #0]
 802438a:	1d1a      	adds	r2, r3, #4
 802438c:	681b      	ldr	r3, [r3, #0]
 802438e:	602a      	str	r2, [r5, #0]
 8024390:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8024394:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8024398:	2301      	movs	r3, #1
 802439a:	e0a0      	b.n	80244de <_printf_i+0x1ee>
 802439c:	6820      	ldr	r0, [r4, #0]
 802439e:	682b      	ldr	r3, [r5, #0]
 80243a0:	0607      	lsls	r7, r0, #24
 80243a2:	f103 0104 	add.w	r1, r3, #4
 80243a6:	6029      	str	r1, [r5, #0]
 80243a8:	d501      	bpl.n	80243ae <_printf_i+0xbe>
 80243aa:	681e      	ldr	r6, [r3, #0]
 80243ac:	e003      	b.n	80243b6 <_printf_i+0xc6>
 80243ae:	0646      	lsls	r6, r0, #25
 80243b0:	d5fb      	bpl.n	80243aa <_printf_i+0xba>
 80243b2:	f9b3 6000 	ldrsh.w	r6, [r3]
 80243b6:	2e00      	cmp	r6, #0
 80243b8:	da03      	bge.n	80243c2 <_printf_i+0xd2>
 80243ba:	232d      	movs	r3, #45	; 0x2d
 80243bc:	4276      	negs	r6, r6
 80243be:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80243c2:	230a      	movs	r3, #10
 80243c4:	4859      	ldr	r0, [pc, #356]	; (802452c <_printf_i+0x23c>)
 80243c6:	e012      	b.n	80243ee <_printf_i+0xfe>
 80243c8:	682b      	ldr	r3, [r5, #0]
 80243ca:	6820      	ldr	r0, [r4, #0]
 80243cc:	1d19      	adds	r1, r3, #4
 80243ce:	6029      	str	r1, [r5, #0]
 80243d0:	0605      	lsls	r5, r0, #24
 80243d2:	d501      	bpl.n	80243d8 <_printf_i+0xe8>
 80243d4:	681e      	ldr	r6, [r3, #0]
 80243d6:	e002      	b.n	80243de <_printf_i+0xee>
 80243d8:	0641      	lsls	r1, r0, #25
 80243da:	d5fb      	bpl.n	80243d4 <_printf_i+0xe4>
 80243dc:	881e      	ldrh	r6, [r3, #0]
 80243de:	2f6f      	cmp	r7, #111	; 0x6f
 80243e0:	bf0c      	ite	eq
 80243e2:	2308      	moveq	r3, #8
 80243e4:	230a      	movne	r3, #10
 80243e6:	4851      	ldr	r0, [pc, #324]	; (802452c <_printf_i+0x23c>)
 80243e8:	2100      	movs	r1, #0
 80243ea:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80243ee:	6865      	ldr	r5, [r4, #4]
 80243f0:	2d00      	cmp	r5, #0
 80243f2:	bfa8      	it	ge
 80243f4:	6821      	ldrge	r1, [r4, #0]
 80243f6:	60a5      	str	r5, [r4, #8]
 80243f8:	bfa4      	itt	ge
 80243fa:	f021 0104 	bicge.w	r1, r1, #4
 80243fe:	6021      	strge	r1, [r4, #0]
 8024400:	b90e      	cbnz	r6, 8024406 <_printf_i+0x116>
 8024402:	2d00      	cmp	r5, #0
 8024404:	d04b      	beq.n	802449e <_printf_i+0x1ae>
 8024406:	4615      	mov	r5, r2
 8024408:	fbb6 f1f3 	udiv	r1, r6, r3
 802440c:	fb03 6711 	mls	r7, r3, r1, r6
 8024410:	5dc7      	ldrb	r7, [r0, r7]
 8024412:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8024416:	4637      	mov	r7, r6
 8024418:	42bb      	cmp	r3, r7
 802441a:	460e      	mov	r6, r1
 802441c:	d9f4      	bls.n	8024408 <_printf_i+0x118>
 802441e:	2b08      	cmp	r3, #8
 8024420:	d10b      	bne.n	802443a <_printf_i+0x14a>
 8024422:	6823      	ldr	r3, [r4, #0]
 8024424:	07de      	lsls	r6, r3, #31
 8024426:	d508      	bpl.n	802443a <_printf_i+0x14a>
 8024428:	6923      	ldr	r3, [r4, #16]
 802442a:	6861      	ldr	r1, [r4, #4]
 802442c:	4299      	cmp	r1, r3
 802442e:	bfde      	ittt	le
 8024430:	2330      	movle	r3, #48	; 0x30
 8024432:	f805 3c01 	strble.w	r3, [r5, #-1]
 8024436:	f105 35ff 	addle.w	r5, r5, #4294967295
 802443a:	1b52      	subs	r2, r2, r5
 802443c:	6122      	str	r2, [r4, #16]
 802443e:	464b      	mov	r3, r9
 8024440:	4621      	mov	r1, r4
 8024442:	4640      	mov	r0, r8
 8024444:	f8cd a000 	str.w	sl, [sp]
 8024448:	aa03      	add	r2, sp, #12
 802444a:	f7ff fedf 	bl	802420c <_printf_common>
 802444e:	3001      	adds	r0, #1
 8024450:	d14a      	bne.n	80244e8 <_printf_i+0x1f8>
 8024452:	f04f 30ff 	mov.w	r0, #4294967295
 8024456:	b004      	add	sp, #16
 8024458:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802445c:	6823      	ldr	r3, [r4, #0]
 802445e:	f043 0320 	orr.w	r3, r3, #32
 8024462:	6023      	str	r3, [r4, #0]
 8024464:	2778      	movs	r7, #120	; 0x78
 8024466:	4832      	ldr	r0, [pc, #200]	; (8024530 <_printf_i+0x240>)
 8024468:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 802446c:	6823      	ldr	r3, [r4, #0]
 802446e:	6829      	ldr	r1, [r5, #0]
 8024470:	061f      	lsls	r7, r3, #24
 8024472:	f851 6b04 	ldr.w	r6, [r1], #4
 8024476:	d402      	bmi.n	802447e <_printf_i+0x18e>
 8024478:	065f      	lsls	r7, r3, #25
 802447a:	bf48      	it	mi
 802447c:	b2b6      	uxthmi	r6, r6
 802447e:	07df      	lsls	r7, r3, #31
 8024480:	bf48      	it	mi
 8024482:	f043 0320 	orrmi.w	r3, r3, #32
 8024486:	6029      	str	r1, [r5, #0]
 8024488:	bf48      	it	mi
 802448a:	6023      	strmi	r3, [r4, #0]
 802448c:	b91e      	cbnz	r6, 8024496 <_printf_i+0x1a6>
 802448e:	6823      	ldr	r3, [r4, #0]
 8024490:	f023 0320 	bic.w	r3, r3, #32
 8024494:	6023      	str	r3, [r4, #0]
 8024496:	2310      	movs	r3, #16
 8024498:	e7a6      	b.n	80243e8 <_printf_i+0xf8>
 802449a:	4824      	ldr	r0, [pc, #144]	; (802452c <_printf_i+0x23c>)
 802449c:	e7e4      	b.n	8024468 <_printf_i+0x178>
 802449e:	4615      	mov	r5, r2
 80244a0:	e7bd      	b.n	802441e <_printf_i+0x12e>
 80244a2:	682b      	ldr	r3, [r5, #0]
 80244a4:	6826      	ldr	r6, [r4, #0]
 80244a6:	1d18      	adds	r0, r3, #4
 80244a8:	6961      	ldr	r1, [r4, #20]
 80244aa:	6028      	str	r0, [r5, #0]
 80244ac:	0635      	lsls	r5, r6, #24
 80244ae:	681b      	ldr	r3, [r3, #0]
 80244b0:	d501      	bpl.n	80244b6 <_printf_i+0x1c6>
 80244b2:	6019      	str	r1, [r3, #0]
 80244b4:	e002      	b.n	80244bc <_printf_i+0x1cc>
 80244b6:	0670      	lsls	r0, r6, #25
 80244b8:	d5fb      	bpl.n	80244b2 <_printf_i+0x1c2>
 80244ba:	8019      	strh	r1, [r3, #0]
 80244bc:	2300      	movs	r3, #0
 80244be:	4615      	mov	r5, r2
 80244c0:	6123      	str	r3, [r4, #16]
 80244c2:	e7bc      	b.n	802443e <_printf_i+0x14e>
 80244c4:	682b      	ldr	r3, [r5, #0]
 80244c6:	2100      	movs	r1, #0
 80244c8:	1d1a      	adds	r2, r3, #4
 80244ca:	602a      	str	r2, [r5, #0]
 80244cc:	681d      	ldr	r5, [r3, #0]
 80244ce:	6862      	ldr	r2, [r4, #4]
 80244d0:	4628      	mov	r0, r5
 80244d2:	f000 f9b3 	bl	802483c <memchr>
 80244d6:	b108      	cbz	r0, 80244dc <_printf_i+0x1ec>
 80244d8:	1b40      	subs	r0, r0, r5
 80244da:	6060      	str	r0, [r4, #4]
 80244dc:	6863      	ldr	r3, [r4, #4]
 80244de:	6123      	str	r3, [r4, #16]
 80244e0:	2300      	movs	r3, #0
 80244e2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80244e6:	e7aa      	b.n	802443e <_printf_i+0x14e>
 80244e8:	462a      	mov	r2, r5
 80244ea:	4649      	mov	r1, r9
 80244ec:	4640      	mov	r0, r8
 80244ee:	6923      	ldr	r3, [r4, #16]
 80244f0:	47d0      	blx	sl
 80244f2:	3001      	adds	r0, #1
 80244f4:	d0ad      	beq.n	8024452 <_printf_i+0x162>
 80244f6:	6823      	ldr	r3, [r4, #0]
 80244f8:	079b      	lsls	r3, r3, #30
 80244fa:	d413      	bmi.n	8024524 <_printf_i+0x234>
 80244fc:	68e0      	ldr	r0, [r4, #12]
 80244fe:	9b03      	ldr	r3, [sp, #12]
 8024500:	4298      	cmp	r0, r3
 8024502:	bfb8      	it	lt
 8024504:	4618      	movlt	r0, r3
 8024506:	e7a6      	b.n	8024456 <_printf_i+0x166>
 8024508:	2301      	movs	r3, #1
 802450a:	4632      	mov	r2, r6
 802450c:	4649      	mov	r1, r9
 802450e:	4640      	mov	r0, r8
 8024510:	47d0      	blx	sl
 8024512:	3001      	adds	r0, #1
 8024514:	d09d      	beq.n	8024452 <_printf_i+0x162>
 8024516:	3501      	adds	r5, #1
 8024518:	68e3      	ldr	r3, [r4, #12]
 802451a:	9903      	ldr	r1, [sp, #12]
 802451c:	1a5b      	subs	r3, r3, r1
 802451e:	42ab      	cmp	r3, r5
 8024520:	dcf2      	bgt.n	8024508 <_printf_i+0x218>
 8024522:	e7eb      	b.n	80244fc <_printf_i+0x20c>
 8024524:	2500      	movs	r5, #0
 8024526:	f104 0619 	add.w	r6, r4, #25
 802452a:	e7f5      	b.n	8024518 <_printf_i+0x228>
 802452c:	08032fb0 	.word	0x08032fb0
 8024530:	08032fc1 	.word	0x08032fc1

08024534 <__sflush_r>:
 8024534:	898a      	ldrh	r2, [r1, #12]
 8024536:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024538:	4605      	mov	r5, r0
 802453a:	0710      	lsls	r0, r2, #28
 802453c:	460c      	mov	r4, r1
 802453e:	d457      	bmi.n	80245f0 <__sflush_r+0xbc>
 8024540:	684b      	ldr	r3, [r1, #4]
 8024542:	2b00      	cmp	r3, #0
 8024544:	dc04      	bgt.n	8024550 <__sflush_r+0x1c>
 8024546:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8024548:	2b00      	cmp	r3, #0
 802454a:	dc01      	bgt.n	8024550 <__sflush_r+0x1c>
 802454c:	2000      	movs	r0, #0
 802454e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024550:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8024552:	2e00      	cmp	r6, #0
 8024554:	d0fa      	beq.n	802454c <__sflush_r+0x18>
 8024556:	2300      	movs	r3, #0
 8024558:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 802455c:	682f      	ldr	r7, [r5, #0]
 802455e:	6a21      	ldr	r1, [r4, #32]
 8024560:	602b      	str	r3, [r5, #0]
 8024562:	d032      	beq.n	80245ca <__sflush_r+0x96>
 8024564:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8024566:	89a3      	ldrh	r3, [r4, #12]
 8024568:	075a      	lsls	r2, r3, #29
 802456a:	d505      	bpl.n	8024578 <__sflush_r+0x44>
 802456c:	6863      	ldr	r3, [r4, #4]
 802456e:	1ac0      	subs	r0, r0, r3
 8024570:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8024572:	b10b      	cbz	r3, 8024578 <__sflush_r+0x44>
 8024574:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8024576:	1ac0      	subs	r0, r0, r3
 8024578:	2300      	movs	r3, #0
 802457a:	4602      	mov	r2, r0
 802457c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802457e:	4628      	mov	r0, r5
 8024580:	6a21      	ldr	r1, [r4, #32]
 8024582:	47b0      	blx	r6
 8024584:	1c43      	adds	r3, r0, #1
 8024586:	89a3      	ldrh	r3, [r4, #12]
 8024588:	d106      	bne.n	8024598 <__sflush_r+0x64>
 802458a:	6829      	ldr	r1, [r5, #0]
 802458c:	291d      	cmp	r1, #29
 802458e:	d82b      	bhi.n	80245e8 <__sflush_r+0xb4>
 8024590:	4a28      	ldr	r2, [pc, #160]	; (8024634 <__sflush_r+0x100>)
 8024592:	410a      	asrs	r2, r1
 8024594:	07d6      	lsls	r6, r2, #31
 8024596:	d427      	bmi.n	80245e8 <__sflush_r+0xb4>
 8024598:	2200      	movs	r2, #0
 802459a:	6062      	str	r2, [r4, #4]
 802459c:	6922      	ldr	r2, [r4, #16]
 802459e:	04d9      	lsls	r1, r3, #19
 80245a0:	6022      	str	r2, [r4, #0]
 80245a2:	d504      	bpl.n	80245ae <__sflush_r+0x7a>
 80245a4:	1c42      	adds	r2, r0, #1
 80245a6:	d101      	bne.n	80245ac <__sflush_r+0x78>
 80245a8:	682b      	ldr	r3, [r5, #0]
 80245aa:	b903      	cbnz	r3, 80245ae <__sflush_r+0x7a>
 80245ac:	6560      	str	r0, [r4, #84]	; 0x54
 80245ae:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80245b0:	602f      	str	r7, [r5, #0]
 80245b2:	2900      	cmp	r1, #0
 80245b4:	d0ca      	beq.n	802454c <__sflush_r+0x18>
 80245b6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80245ba:	4299      	cmp	r1, r3
 80245bc:	d002      	beq.n	80245c4 <__sflush_r+0x90>
 80245be:	4628      	mov	r0, r5
 80245c0:	f7ff fc9a 	bl	8023ef8 <_free_r>
 80245c4:	2000      	movs	r0, #0
 80245c6:	6360      	str	r0, [r4, #52]	; 0x34
 80245c8:	e7c1      	b.n	802454e <__sflush_r+0x1a>
 80245ca:	2301      	movs	r3, #1
 80245cc:	4628      	mov	r0, r5
 80245ce:	47b0      	blx	r6
 80245d0:	1c41      	adds	r1, r0, #1
 80245d2:	d1c8      	bne.n	8024566 <__sflush_r+0x32>
 80245d4:	682b      	ldr	r3, [r5, #0]
 80245d6:	2b00      	cmp	r3, #0
 80245d8:	d0c5      	beq.n	8024566 <__sflush_r+0x32>
 80245da:	2b1d      	cmp	r3, #29
 80245dc:	d001      	beq.n	80245e2 <__sflush_r+0xae>
 80245de:	2b16      	cmp	r3, #22
 80245e0:	d101      	bne.n	80245e6 <__sflush_r+0xb2>
 80245e2:	602f      	str	r7, [r5, #0]
 80245e4:	e7b2      	b.n	802454c <__sflush_r+0x18>
 80245e6:	89a3      	ldrh	r3, [r4, #12]
 80245e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80245ec:	81a3      	strh	r3, [r4, #12]
 80245ee:	e7ae      	b.n	802454e <__sflush_r+0x1a>
 80245f0:	690f      	ldr	r7, [r1, #16]
 80245f2:	2f00      	cmp	r7, #0
 80245f4:	d0aa      	beq.n	802454c <__sflush_r+0x18>
 80245f6:	0793      	lsls	r3, r2, #30
 80245f8:	bf18      	it	ne
 80245fa:	2300      	movne	r3, #0
 80245fc:	680e      	ldr	r6, [r1, #0]
 80245fe:	bf08      	it	eq
 8024600:	694b      	ldreq	r3, [r1, #20]
 8024602:	1bf6      	subs	r6, r6, r7
 8024604:	600f      	str	r7, [r1, #0]
 8024606:	608b      	str	r3, [r1, #8]
 8024608:	2e00      	cmp	r6, #0
 802460a:	dd9f      	ble.n	802454c <__sflush_r+0x18>
 802460c:	4633      	mov	r3, r6
 802460e:	463a      	mov	r2, r7
 8024610:	4628      	mov	r0, r5
 8024612:	6a21      	ldr	r1, [r4, #32]
 8024614:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
 8024618:	47e0      	blx	ip
 802461a:	2800      	cmp	r0, #0
 802461c:	dc06      	bgt.n	802462c <__sflush_r+0xf8>
 802461e:	89a3      	ldrh	r3, [r4, #12]
 8024620:	f04f 30ff 	mov.w	r0, #4294967295
 8024624:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8024628:	81a3      	strh	r3, [r4, #12]
 802462a:	e790      	b.n	802454e <__sflush_r+0x1a>
 802462c:	4407      	add	r7, r0
 802462e:	1a36      	subs	r6, r6, r0
 8024630:	e7ea      	b.n	8024608 <__sflush_r+0xd4>
 8024632:	bf00      	nop
 8024634:	dfbffffe 	.word	0xdfbffffe

08024638 <_fflush_r>:
 8024638:	b538      	push	{r3, r4, r5, lr}
 802463a:	690b      	ldr	r3, [r1, #16]
 802463c:	4605      	mov	r5, r0
 802463e:	460c      	mov	r4, r1
 8024640:	b913      	cbnz	r3, 8024648 <_fflush_r+0x10>
 8024642:	2500      	movs	r5, #0
 8024644:	4628      	mov	r0, r5
 8024646:	bd38      	pop	{r3, r4, r5, pc}
 8024648:	b118      	cbz	r0, 8024652 <_fflush_r+0x1a>
 802464a:	6a03      	ldr	r3, [r0, #32]
 802464c:	b90b      	cbnz	r3, 8024652 <_fflush_r+0x1a>
 802464e:	f7ff fa47 	bl	8023ae0 <__sinit>
 8024652:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8024656:	2b00      	cmp	r3, #0
 8024658:	d0f3      	beq.n	8024642 <_fflush_r+0xa>
 802465a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 802465c:	07d0      	lsls	r0, r2, #31
 802465e:	d404      	bmi.n	802466a <_fflush_r+0x32>
 8024660:	0599      	lsls	r1, r3, #22
 8024662:	d402      	bmi.n	802466a <_fflush_r+0x32>
 8024664:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8024666:	f7ff fc28 	bl	8023eba <__retarget_lock_acquire_recursive>
 802466a:	4628      	mov	r0, r5
 802466c:	4621      	mov	r1, r4
 802466e:	f7ff ff61 	bl	8024534 <__sflush_r>
 8024672:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8024674:	4605      	mov	r5, r0
 8024676:	07da      	lsls	r2, r3, #31
 8024678:	d4e4      	bmi.n	8024644 <_fflush_r+0xc>
 802467a:	89a3      	ldrh	r3, [r4, #12]
 802467c:	059b      	lsls	r3, r3, #22
 802467e:	d4e1      	bmi.n	8024644 <_fflush_r+0xc>
 8024680:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8024682:	f7ff fc1b 	bl	8023ebc <__retarget_lock_release_recursive>
 8024686:	e7dd      	b.n	8024644 <_fflush_r+0xc>

08024688 <__swbuf_r>:
 8024688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802468a:	460e      	mov	r6, r1
 802468c:	4614      	mov	r4, r2
 802468e:	4605      	mov	r5, r0
 8024690:	b118      	cbz	r0, 802469a <__swbuf_r+0x12>
 8024692:	6a03      	ldr	r3, [r0, #32]
 8024694:	b90b      	cbnz	r3, 802469a <__swbuf_r+0x12>
 8024696:	f7ff fa23 	bl	8023ae0 <__sinit>
 802469a:	69a3      	ldr	r3, [r4, #24]
 802469c:	60a3      	str	r3, [r4, #8]
 802469e:	89a3      	ldrh	r3, [r4, #12]
 80246a0:	071a      	lsls	r2, r3, #28
 80246a2:	d525      	bpl.n	80246f0 <__swbuf_r+0x68>
 80246a4:	6923      	ldr	r3, [r4, #16]
 80246a6:	b31b      	cbz	r3, 80246f0 <__swbuf_r+0x68>
 80246a8:	6823      	ldr	r3, [r4, #0]
 80246aa:	6922      	ldr	r2, [r4, #16]
 80246ac:	b2f6      	uxtb	r6, r6
 80246ae:	1a98      	subs	r0, r3, r2
 80246b0:	6963      	ldr	r3, [r4, #20]
 80246b2:	4637      	mov	r7, r6
 80246b4:	4283      	cmp	r3, r0
 80246b6:	dc04      	bgt.n	80246c2 <__swbuf_r+0x3a>
 80246b8:	4621      	mov	r1, r4
 80246ba:	4628      	mov	r0, r5
 80246bc:	f7ff ffbc 	bl	8024638 <_fflush_r>
 80246c0:	b9e0      	cbnz	r0, 80246fc <__swbuf_r+0x74>
 80246c2:	68a3      	ldr	r3, [r4, #8]
 80246c4:	3b01      	subs	r3, #1
 80246c6:	60a3      	str	r3, [r4, #8]
 80246c8:	6823      	ldr	r3, [r4, #0]
 80246ca:	1c5a      	adds	r2, r3, #1
 80246cc:	6022      	str	r2, [r4, #0]
 80246ce:	701e      	strb	r6, [r3, #0]
 80246d0:	6962      	ldr	r2, [r4, #20]
 80246d2:	1c43      	adds	r3, r0, #1
 80246d4:	429a      	cmp	r2, r3
 80246d6:	d004      	beq.n	80246e2 <__swbuf_r+0x5a>
 80246d8:	89a3      	ldrh	r3, [r4, #12]
 80246da:	07db      	lsls	r3, r3, #31
 80246dc:	d506      	bpl.n	80246ec <__swbuf_r+0x64>
 80246de:	2e0a      	cmp	r6, #10
 80246e0:	d104      	bne.n	80246ec <__swbuf_r+0x64>
 80246e2:	4621      	mov	r1, r4
 80246e4:	4628      	mov	r0, r5
 80246e6:	f7ff ffa7 	bl	8024638 <_fflush_r>
 80246ea:	b938      	cbnz	r0, 80246fc <__swbuf_r+0x74>
 80246ec:	4638      	mov	r0, r7
 80246ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80246f0:	4621      	mov	r1, r4
 80246f2:	4628      	mov	r0, r5
 80246f4:	f000 f806 	bl	8024704 <__swsetup_r>
 80246f8:	2800      	cmp	r0, #0
 80246fa:	d0d5      	beq.n	80246a8 <__swbuf_r+0x20>
 80246fc:	f04f 37ff 	mov.w	r7, #4294967295
 8024700:	e7f4      	b.n	80246ec <__swbuf_r+0x64>
	...

08024704 <__swsetup_r>:
 8024704:	b538      	push	{r3, r4, r5, lr}
 8024706:	4b2a      	ldr	r3, [pc, #168]	; (80247b0 <__swsetup_r+0xac>)
 8024708:	4605      	mov	r5, r0
 802470a:	6818      	ldr	r0, [r3, #0]
 802470c:	460c      	mov	r4, r1
 802470e:	b118      	cbz	r0, 8024718 <__swsetup_r+0x14>
 8024710:	6a03      	ldr	r3, [r0, #32]
 8024712:	b90b      	cbnz	r3, 8024718 <__swsetup_r+0x14>
 8024714:	f7ff f9e4 	bl	8023ae0 <__sinit>
 8024718:	89a3      	ldrh	r3, [r4, #12]
 802471a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802471e:	0718      	lsls	r0, r3, #28
 8024720:	d422      	bmi.n	8024768 <__swsetup_r+0x64>
 8024722:	06d9      	lsls	r1, r3, #27
 8024724:	d407      	bmi.n	8024736 <__swsetup_r+0x32>
 8024726:	2309      	movs	r3, #9
 8024728:	602b      	str	r3, [r5, #0]
 802472a:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 802472e:	f04f 30ff 	mov.w	r0, #4294967295
 8024732:	81a3      	strh	r3, [r4, #12]
 8024734:	e034      	b.n	80247a0 <__swsetup_r+0x9c>
 8024736:	0758      	lsls	r0, r3, #29
 8024738:	d512      	bpl.n	8024760 <__swsetup_r+0x5c>
 802473a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802473c:	b141      	cbz	r1, 8024750 <__swsetup_r+0x4c>
 802473e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8024742:	4299      	cmp	r1, r3
 8024744:	d002      	beq.n	802474c <__swsetup_r+0x48>
 8024746:	4628      	mov	r0, r5
 8024748:	f7ff fbd6 	bl	8023ef8 <_free_r>
 802474c:	2300      	movs	r3, #0
 802474e:	6363      	str	r3, [r4, #52]	; 0x34
 8024750:	89a3      	ldrh	r3, [r4, #12]
 8024752:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8024756:	81a3      	strh	r3, [r4, #12]
 8024758:	2300      	movs	r3, #0
 802475a:	6063      	str	r3, [r4, #4]
 802475c:	6923      	ldr	r3, [r4, #16]
 802475e:	6023      	str	r3, [r4, #0]
 8024760:	89a3      	ldrh	r3, [r4, #12]
 8024762:	f043 0308 	orr.w	r3, r3, #8
 8024766:	81a3      	strh	r3, [r4, #12]
 8024768:	6923      	ldr	r3, [r4, #16]
 802476a:	b94b      	cbnz	r3, 8024780 <__swsetup_r+0x7c>
 802476c:	89a3      	ldrh	r3, [r4, #12]
 802476e:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8024772:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8024776:	d003      	beq.n	8024780 <__swsetup_r+0x7c>
 8024778:	4621      	mov	r1, r4
 802477a:	4628      	mov	r0, r5
 802477c:	f000 f891 	bl	80248a2 <__smakebuf_r>
 8024780:	89a0      	ldrh	r0, [r4, #12]
 8024782:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8024786:	f010 0301 	ands.w	r3, r0, #1
 802478a:	d00a      	beq.n	80247a2 <__swsetup_r+0x9e>
 802478c:	2300      	movs	r3, #0
 802478e:	60a3      	str	r3, [r4, #8]
 8024790:	6963      	ldr	r3, [r4, #20]
 8024792:	425b      	negs	r3, r3
 8024794:	61a3      	str	r3, [r4, #24]
 8024796:	6923      	ldr	r3, [r4, #16]
 8024798:	b943      	cbnz	r3, 80247ac <__swsetup_r+0xa8>
 802479a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 802479e:	d1c4      	bne.n	802472a <__swsetup_r+0x26>
 80247a0:	bd38      	pop	{r3, r4, r5, pc}
 80247a2:	0781      	lsls	r1, r0, #30
 80247a4:	bf58      	it	pl
 80247a6:	6963      	ldrpl	r3, [r4, #20]
 80247a8:	60a3      	str	r3, [r4, #8]
 80247aa:	e7f4      	b.n	8024796 <__swsetup_r+0x92>
 80247ac:	2000      	movs	r0, #0
 80247ae:	e7f7      	b.n	80247a0 <__swsetup_r+0x9c>
 80247b0:	20000440 	.word	0x20000440

080247b4 <_raise_r>:
 80247b4:	291f      	cmp	r1, #31
 80247b6:	b538      	push	{r3, r4, r5, lr}
 80247b8:	4604      	mov	r4, r0
 80247ba:	460d      	mov	r5, r1
 80247bc:	d904      	bls.n	80247c8 <_raise_r+0x14>
 80247be:	2316      	movs	r3, #22
 80247c0:	6003      	str	r3, [r0, #0]
 80247c2:	f04f 30ff 	mov.w	r0, #4294967295
 80247c6:	bd38      	pop	{r3, r4, r5, pc}
 80247c8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80247ca:	b112      	cbz	r2, 80247d2 <_raise_r+0x1e>
 80247cc:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80247d0:	b94b      	cbnz	r3, 80247e6 <_raise_r+0x32>
 80247d2:	4620      	mov	r0, r4
 80247d4:	f000 f830 	bl	8024838 <_getpid_r>
 80247d8:	462a      	mov	r2, r5
 80247da:	4601      	mov	r1, r0
 80247dc:	4620      	mov	r0, r4
 80247de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80247e2:	f000 b817 	b.w	8024814 <_kill_r>
 80247e6:	2b01      	cmp	r3, #1
 80247e8:	d00a      	beq.n	8024800 <_raise_r+0x4c>
 80247ea:	1c59      	adds	r1, r3, #1
 80247ec:	d103      	bne.n	80247f6 <_raise_r+0x42>
 80247ee:	2316      	movs	r3, #22
 80247f0:	6003      	str	r3, [r0, #0]
 80247f2:	2001      	movs	r0, #1
 80247f4:	e7e7      	b.n	80247c6 <_raise_r+0x12>
 80247f6:	2400      	movs	r4, #0
 80247f8:	4628      	mov	r0, r5
 80247fa:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 80247fe:	4798      	blx	r3
 8024800:	2000      	movs	r0, #0
 8024802:	e7e0      	b.n	80247c6 <_raise_r+0x12>

08024804 <raise>:
 8024804:	4b02      	ldr	r3, [pc, #8]	; (8024810 <raise+0xc>)
 8024806:	4601      	mov	r1, r0
 8024808:	6818      	ldr	r0, [r3, #0]
 802480a:	f7ff bfd3 	b.w	80247b4 <_raise_r>
 802480e:	bf00      	nop
 8024810:	20000440 	.word	0x20000440

08024814 <_kill_r>:
 8024814:	b538      	push	{r3, r4, r5, lr}
 8024816:	2300      	movs	r3, #0
 8024818:	4d06      	ldr	r5, [pc, #24]	; (8024834 <_kill_r+0x20>)
 802481a:	4604      	mov	r4, r0
 802481c:	4608      	mov	r0, r1
 802481e:	4611      	mov	r1, r2
 8024820:	602b      	str	r3, [r5, #0]
 8024822:	f7dc fe9b 	bl	800155c <_kill>
 8024826:	1c43      	adds	r3, r0, #1
 8024828:	d102      	bne.n	8024830 <_kill_r+0x1c>
 802482a:	682b      	ldr	r3, [r5, #0]
 802482c:	b103      	cbz	r3, 8024830 <_kill_r+0x1c>
 802482e:	6023      	str	r3, [r4, #0]
 8024830:	bd38      	pop	{r3, r4, r5, pc}
 8024832:	bf00      	nop
 8024834:	200022e0 	.word	0x200022e0

08024838 <_getpid_r>:
 8024838:	f7dc be89 	b.w	800154e <_getpid>

0802483c <memchr>:
 802483c:	4603      	mov	r3, r0
 802483e:	b510      	push	{r4, lr}
 8024840:	b2c9      	uxtb	r1, r1
 8024842:	4402      	add	r2, r0
 8024844:	4293      	cmp	r3, r2
 8024846:	4618      	mov	r0, r3
 8024848:	d101      	bne.n	802484e <memchr+0x12>
 802484a:	2000      	movs	r0, #0
 802484c:	e003      	b.n	8024856 <memchr+0x1a>
 802484e:	7804      	ldrb	r4, [r0, #0]
 8024850:	3301      	adds	r3, #1
 8024852:	428c      	cmp	r4, r1
 8024854:	d1f6      	bne.n	8024844 <memchr+0x8>
 8024856:	bd10      	pop	{r4, pc}

08024858 <__swhatbuf_r>:
 8024858:	b570      	push	{r4, r5, r6, lr}
 802485a:	460c      	mov	r4, r1
 802485c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8024860:	4615      	mov	r5, r2
 8024862:	2900      	cmp	r1, #0
 8024864:	461e      	mov	r6, r3
 8024866:	b096      	sub	sp, #88	; 0x58
 8024868:	da0c      	bge.n	8024884 <__swhatbuf_r+0x2c>
 802486a:	89a3      	ldrh	r3, [r4, #12]
 802486c:	2100      	movs	r1, #0
 802486e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8024872:	bf0c      	ite	eq
 8024874:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 8024878:	2340      	movne	r3, #64	; 0x40
 802487a:	2000      	movs	r0, #0
 802487c:	6031      	str	r1, [r6, #0]
 802487e:	602b      	str	r3, [r5, #0]
 8024880:	b016      	add	sp, #88	; 0x58
 8024882:	bd70      	pop	{r4, r5, r6, pc}
 8024884:	466a      	mov	r2, sp
 8024886:	f000 f849 	bl	802491c <_fstat_r>
 802488a:	2800      	cmp	r0, #0
 802488c:	dbed      	blt.n	802486a <__swhatbuf_r+0x12>
 802488e:	9901      	ldr	r1, [sp, #4]
 8024890:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 8024894:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 8024898:	4259      	negs	r1, r3
 802489a:	4159      	adcs	r1, r3
 802489c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80248a0:	e7eb      	b.n	802487a <__swhatbuf_r+0x22>

080248a2 <__smakebuf_r>:
 80248a2:	898b      	ldrh	r3, [r1, #12]
 80248a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80248a6:	079d      	lsls	r5, r3, #30
 80248a8:	4606      	mov	r6, r0
 80248aa:	460c      	mov	r4, r1
 80248ac:	d507      	bpl.n	80248be <__smakebuf_r+0x1c>
 80248ae:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80248b2:	6023      	str	r3, [r4, #0]
 80248b4:	6123      	str	r3, [r4, #16]
 80248b6:	2301      	movs	r3, #1
 80248b8:	6163      	str	r3, [r4, #20]
 80248ba:	b002      	add	sp, #8
 80248bc:	bd70      	pop	{r4, r5, r6, pc}
 80248be:	466a      	mov	r2, sp
 80248c0:	ab01      	add	r3, sp, #4
 80248c2:	f7ff ffc9 	bl	8024858 <__swhatbuf_r>
 80248c6:	9900      	ldr	r1, [sp, #0]
 80248c8:	4605      	mov	r5, r0
 80248ca:	4630      	mov	r0, r6
 80248cc:	f7fe fe24 	bl	8023518 <_malloc_r>
 80248d0:	b948      	cbnz	r0, 80248e6 <__smakebuf_r+0x44>
 80248d2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80248d6:	059a      	lsls	r2, r3, #22
 80248d8:	d4ef      	bmi.n	80248ba <__smakebuf_r+0x18>
 80248da:	f023 0303 	bic.w	r3, r3, #3
 80248de:	f043 0302 	orr.w	r3, r3, #2
 80248e2:	81a3      	strh	r3, [r4, #12]
 80248e4:	e7e3      	b.n	80248ae <__smakebuf_r+0xc>
 80248e6:	89a3      	ldrh	r3, [r4, #12]
 80248e8:	6020      	str	r0, [r4, #0]
 80248ea:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80248ee:	81a3      	strh	r3, [r4, #12]
 80248f0:	9b00      	ldr	r3, [sp, #0]
 80248f2:	6120      	str	r0, [r4, #16]
 80248f4:	6163      	str	r3, [r4, #20]
 80248f6:	9b01      	ldr	r3, [sp, #4]
 80248f8:	b15b      	cbz	r3, 8024912 <__smakebuf_r+0x70>
 80248fa:	4630      	mov	r0, r6
 80248fc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8024900:	f000 f81e 	bl	8024940 <_isatty_r>
 8024904:	b128      	cbz	r0, 8024912 <__smakebuf_r+0x70>
 8024906:	89a3      	ldrh	r3, [r4, #12]
 8024908:	f023 0303 	bic.w	r3, r3, #3
 802490c:	f043 0301 	orr.w	r3, r3, #1
 8024910:	81a3      	strh	r3, [r4, #12]
 8024912:	89a3      	ldrh	r3, [r4, #12]
 8024914:	431d      	orrs	r5, r3
 8024916:	81a5      	strh	r5, [r4, #12]
 8024918:	e7cf      	b.n	80248ba <__smakebuf_r+0x18>
	...

0802491c <_fstat_r>:
 802491c:	b538      	push	{r3, r4, r5, lr}
 802491e:	2300      	movs	r3, #0
 8024920:	4d06      	ldr	r5, [pc, #24]	; (802493c <_fstat_r+0x20>)
 8024922:	4604      	mov	r4, r0
 8024924:	4608      	mov	r0, r1
 8024926:	4611      	mov	r1, r2
 8024928:	602b      	str	r3, [r5, #0]
 802492a:	f7dc fe75 	bl	8001618 <_fstat>
 802492e:	1c43      	adds	r3, r0, #1
 8024930:	d102      	bne.n	8024938 <_fstat_r+0x1c>
 8024932:	682b      	ldr	r3, [r5, #0]
 8024934:	b103      	cbz	r3, 8024938 <_fstat_r+0x1c>
 8024936:	6023      	str	r3, [r4, #0]
 8024938:	bd38      	pop	{r3, r4, r5, pc}
 802493a:	bf00      	nop
 802493c:	200022e0 	.word	0x200022e0

08024940 <_isatty_r>:
 8024940:	b538      	push	{r3, r4, r5, lr}
 8024942:	2300      	movs	r3, #0
 8024944:	4d05      	ldr	r5, [pc, #20]	; (802495c <_isatty_r+0x1c>)
 8024946:	4604      	mov	r4, r0
 8024948:	4608      	mov	r0, r1
 802494a:	602b      	str	r3, [r5, #0]
 802494c:	f7dc fe73 	bl	8001636 <_isatty>
 8024950:	1c43      	adds	r3, r0, #1
 8024952:	d102      	bne.n	802495a <_isatty_r+0x1a>
 8024954:	682b      	ldr	r3, [r5, #0]
 8024956:	b103      	cbz	r3, 802495a <_isatty_r+0x1a>
 8024958:	6023      	str	r3, [r4, #0]
 802495a:	bd38      	pop	{r3, r4, r5, pc}
 802495c:	200022e0 	.word	0x200022e0

08024960 <atan2>:
 8024960:	f000 ba62 	b.w	8024e28 <__ieee754_atan2>

08024964 <powf>:
 8024964:	b570      	push	{r4, r5, r6, lr}
 8024966:	460c      	mov	r4, r1
 8024968:	4606      	mov	r6, r0
 802496a:	f000 fedd 	bl	8025728 <__ieee754_powf>
 802496e:	4621      	mov	r1, r4
 8024970:	4605      	mov	r5, r0
 8024972:	4620      	mov	r0, r4
 8024974:	f7dc fbe4 	bl	8001140 <__aeabi_fcmpun>
 8024978:	bb68      	cbnz	r0, 80249d6 <powf+0x72>
 802497a:	2100      	movs	r1, #0
 802497c:	4630      	mov	r0, r6
 802497e:	f7dc fbad 	bl	80010dc <__aeabi_fcmpeq>
 8024982:	b190      	cbz	r0, 80249aa <powf+0x46>
 8024984:	2100      	movs	r1, #0
 8024986:	4620      	mov	r0, r4
 8024988:	f7dc fba8 	bl	80010dc <__aeabi_fcmpeq>
 802498c:	2800      	cmp	r0, #0
 802498e:	d133      	bne.n	80249f8 <powf+0x94>
 8024990:	4620      	mov	r0, r4
 8024992:	f000 f8e7 	bl	8024b64 <finitef>
 8024996:	b1f0      	cbz	r0, 80249d6 <powf+0x72>
 8024998:	2100      	movs	r1, #0
 802499a:	4620      	mov	r0, r4
 802499c:	f7dc fba8 	bl	80010f0 <__aeabi_fcmplt>
 80249a0:	b1c8      	cbz	r0, 80249d6 <powf+0x72>
 80249a2:	f7ff fa5f 	bl	8023e64 <__errno>
 80249a6:	2322      	movs	r3, #34	; 0x22
 80249a8:	e014      	b.n	80249d4 <powf+0x70>
 80249aa:	4628      	mov	r0, r5
 80249ac:	f000 f8da 	bl	8024b64 <finitef>
 80249b0:	b998      	cbnz	r0, 80249da <powf+0x76>
 80249b2:	4630      	mov	r0, r6
 80249b4:	f000 f8d6 	bl	8024b64 <finitef>
 80249b8:	b178      	cbz	r0, 80249da <powf+0x76>
 80249ba:	4620      	mov	r0, r4
 80249bc:	f000 f8d2 	bl	8024b64 <finitef>
 80249c0:	b158      	cbz	r0, 80249da <powf+0x76>
 80249c2:	4629      	mov	r1, r5
 80249c4:	4628      	mov	r0, r5
 80249c6:	f7dc fbbb 	bl	8001140 <__aeabi_fcmpun>
 80249ca:	2800      	cmp	r0, #0
 80249cc:	d0e9      	beq.n	80249a2 <powf+0x3e>
 80249ce:	f7ff fa49 	bl	8023e64 <__errno>
 80249d2:	2321      	movs	r3, #33	; 0x21
 80249d4:	6003      	str	r3, [r0, #0]
 80249d6:	4628      	mov	r0, r5
 80249d8:	bd70      	pop	{r4, r5, r6, pc}
 80249da:	2100      	movs	r1, #0
 80249dc:	4628      	mov	r0, r5
 80249de:	f7dc fb7d 	bl	80010dc <__aeabi_fcmpeq>
 80249e2:	2800      	cmp	r0, #0
 80249e4:	d0f7      	beq.n	80249d6 <powf+0x72>
 80249e6:	4630      	mov	r0, r6
 80249e8:	f000 f8bc 	bl	8024b64 <finitef>
 80249ec:	2800      	cmp	r0, #0
 80249ee:	d0f2      	beq.n	80249d6 <powf+0x72>
 80249f0:	4620      	mov	r0, r4
 80249f2:	f000 f8b7 	bl	8024b64 <finitef>
 80249f6:	e7d3      	b.n	80249a0 <powf+0x3c>
 80249f8:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
 80249fc:	e7eb      	b.n	80249d6 <powf+0x72>

080249fe <sqrtf>:
 80249fe:	b538      	push	{r3, r4, r5, lr}
 8024a00:	4605      	mov	r5, r0
 8024a02:	f000 f8e3 	bl	8024bcc <__ieee754_sqrtf>
 8024a06:	4629      	mov	r1, r5
 8024a08:	4604      	mov	r4, r0
 8024a0a:	4628      	mov	r0, r5
 8024a0c:	f7dc fb98 	bl	8001140 <__aeabi_fcmpun>
 8024a10:	b968      	cbnz	r0, 8024a2e <sqrtf+0x30>
 8024a12:	2100      	movs	r1, #0
 8024a14:	4628      	mov	r0, r5
 8024a16:	f7dc fb6b 	bl	80010f0 <__aeabi_fcmplt>
 8024a1a:	b140      	cbz	r0, 8024a2e <sqrtf+0x30>
 8024a1c:	f7ff fa22 	bl	8023e64 <__errno>
 8024a20:	2321      	movs	r3, #33	; 0x21
 8024a22:	2100      	movs	r1, #0
 8024a24:	6003      	str	r3, [r0, #0]
 8024a26:	4608      	mov	r0, r1
 8024a28:	f7dc fa78 	bl	8000f1c <__aeabi_fdiv>
 8024a2c:	4604      	mov	r4, r0
 8024a2e:	4620      	mov	r0, r4
 8024a30:	bd38      	pop	{r3, r4, r5, pc}
	...

08024a34 <cosf>:
 8024a34:	b507      	push	{r0, r1, r2, lr}
 8024a36:	4a1a      	ldr	r2, [pc, #104]	; (8024aa0 <cosf+0x6c>)
 8024a38:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8024a3c:	4293      	cmp	r3, r2
 8024a3e:	4601      	mov	r1, r0
 8024a40:	dc05      	bgt.n	8024a4e <cosf+0x1a>
 8024a42:	2100      	movs	r1, #0
 8024a44:	b003      	add	sp, #12
 8024a46:	f85d eb04 	ldr.w	lr, [sp], #4
 8024a4a:	f000 bc4b 	b.w	80252e4 <__kernel_cosf>
 8024a4e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024a52:	db04      	blt.n	8024a5e <cosf+0x2a>
 8024a54:	f7dc f8a4 	bl	8000ba0 <__aeabi_fsub>
 8024a58:	b003      	add	sp, #12
 8024a5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8024a5e:	4669      	mov	r1, sp
 8024a60:	f001 f9c8 	bl	8025df4 <__ieee754_rem_pio2f>
 8024a64:	f000 0203 	and.w	r2, r0, #3
 8024a68:	2a01      	cmp	r2, #1
 8024a6a:	d007      	beq.n	8024a7c <cosf+0x48>
 8024a6c:	2a02      	cmp	r2, #2
 8024a6e:	d00c      	beq.n	8024a8a <cosf+0x56>
 8024a70:	b982      	cbnz	r2, 8024a94 <cosf+0x60>
 8024a72:	9901      	ldr	r1, [sp, #4]
 8024a74:	9800      	ldr	r0, [sp, #0]
 8024a76:	f000 fc35 	bl	80252e4 <__kernel_cosf>
 8024a7a:	e7ed      	b.n	8024a58 <cosf+0x24>
 8024a7c:	9901      	ldr	r1, [sp, #4]
 8024a7e:	9800      	ldr	r0, [sp, #0]
 8024a80:	f000 fcb0 	bl	80253e4 <__kernel_sinf>
 8024a84:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8024a88:	e7e6      	b.n	8024a58 <cosf+0x24>
 8024a8a:	9901      	ldr	r1, [sp, #4]
 8024a8c:	9800      	ldr	r0, [sp, #0]
 8024a8e:	f000 fc29 	bl	80252e4 <__kernel_cosf>
 8024a92:	e7f7      	b.n	8024a84 <cosf+0x50>
 8024a94:	2201      	movs	r2, #1
 8024a96:	9901      	ldr	r1, [sp, #4]
 8024a98:	9800      	ldr	r0, [sp, #0]
 8024a9a:	f000 fca3 	bl	80253e4 <__kernel_sinf>
 8024a9e:	e7db      	b.n	8024a58 <cosf+0x24>
 8024aa0:	3f490fd8 	.word	0x3f490fd8

08024aa4 <sinf>:
 8024aa4:	b507      	push	{r0, r1, r2, lr}
 8024aa6:	4a1b      	ldr	r2, [pc, #108]	; (8024b14 <sinf+0x70>)
 8024aa8:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8024aac:	4293      	cmp	r3, r2
 8024aae:	4601      	mov	r1, r0
 8024ab0:	dc06      	bgt.n	8024ac0 <sinf+0x1c>
 8024ab2:	2200      	movs	r2, #0
 8024ab4:	2100      	movs	r1, #0
 8024ab6:	b003      	add	sp, #12
 8024ab8:	f85d eb04 	ldr.w	lr, [sp], #4
 8024abc:	f000 bc92 	b.w	80253e4 <__kernel_sinf>
 8024ac0:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024ac4:	db04      	blt.n	8024ad0 <sinf+0x2c>
 8024ac6:	f7dc f86b 	bl	8000ba0 <__aeabi_fsub>
 8024aca:	b003      	add	sp, #12
 8024acc:	f85d fb04 	ldr.w	pc, [sp], #4
 8024ad0:	4669      	mov	r1, sp
 8024ad2:	f001 f98f 	bl	8025df4 <__ieee754_rem_pio2f>
 8024ad6:	f000 0003 	and.w	r0, r0, #3
 8024ada:	2801      	cmp	r0, #1
 8024adc:	d008      	beq.n	8024af0 <sinf+0x4c>
 8024ade:	2802      	cmp	r0, #2
 8024ae0:	d00b      	beq.n	8024afa <sinf+0x56>
 8024ae2:	b990      	cbnz	r0, 8024b0a <sinf+0x66>
 8024ae4:	2201      	movs	r2, #1
 8024ae6:	9901      	ldr	r1, [sp, #4]
 8024ae8:	9800      	ldr	r0, [sp, #0]
 8024aea:	f000 fc7b 	bl	80253e4 <__kernel_sinf>
 8024aee:	e7ec      	b.n	8024aca <sinf+0x26>
 8024af0:	9901      	ldr	r1, [sp, #4]
 8024af2:	9800      	ldr	r0, [sp, #0]
 8024af4:	f000 fbf6 	bl	80252e4 <__kernel_cosf>
 8024af8:	e7e7      	b.n	8024aca <sinf+0x26>
 8024afa:	2201      	movs	r2, #1
 8024afc:	9901      	ldr	r1, [sp, #4]
 8024afe:	9800      	ldr	r0, [sp, #0]
 8024b00:	f000 fc70 	bl	80253e4 <__kernel_sinf>
 8024b04:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8024b08:	e7df      	b.n	8024aca <sinf+0x26>
 8024b0a:	9901      	ldr	r1, [sp, #4]
 8024b0c:	9800      	ldr	r0, [sp, #0]
 8024b0e:	f000 fbe9 	bl	80252e4 <__kernel_cosf>
 8024b12:	e7f7      	b.n	8024b04 <sinf+0x60>
 8024b14:	3f490fd8 	.word	0x3f490fd8

08024b18 <tanf>:
 8024b18:	b507      	push	{r0, r1, r2, lr}
 8024b1a:	4a11      	ldr	r2, [pc, #68]	; (8024b60 <tanf+0x48>)
 8024b1c:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8024b20:	4293      	cmp	r3, r2
 8024b22:	4601      	mov	r1, r0
 8024b24:	dc06      	bgt.n	8024b34 <tanf+0x1c>
 8024b26:	2201      	movs	r2, #1
 8024b28:	2100      	movs	r1, #0
 8024b2a:	b003      	add	sp, #12
 8024b2c:	f85d eb04 	ldr.w	lr, [sp], #4
 8024b30:	f000 bcce 	b.w	80254d0 <__kernel_tanf>
 8024b34:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8024b38:	db04      	blt.n	8024b44 <tanf+0x2c>
 8024b3a:	f7dc f831 	bl	8000ba0 <__aeabi_fsub>
 8024b3e:	b003      	add	sp, #12
 8024b40:	f85d fb04 	ldr.w	pc, [sp], #4
 8024b44:	4669      	mov	r1, sp
 8024b46:	f001 f955 	bl	8025df4 <__ieee754_rem_pio2f>
 8024b4a:	0042      	lsls	r2, r0, #1
 8024b4c:	f002 0202 	and.w	r2, r2, #2
 8024b50:	9901      	ldr	r1, [sp, #4]
 8024b52:	9800      	ldr	r0, [sp, #0]
 8024b54:	f1c2 0201 	rsb	r2, r2, #1
 8024b58:	f000 fcba 	bl	80254d0 <__kernel_tanf>
 8024b5c:	e7ef      	b.n	8024b3e <tanf+0x26>
 8024b5e:	bf00      	nop
 8024b60:	3f490fda 	.word	0x3f490fda

08024b64 <finitef>:
 8024b64:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8024b68:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8024b6c:	bfac      	ite	ge
 8024b6e:	2000      	movge	r0, #0
 8024b70:	2001      	movlt	r0, #1
 8024b72:	4770      	bx	lr

08024b74 <lroundf>:
 8024b74:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8024b78:	2800      	cmp	r0, #0
 8024b7a:	b510      	push	{r4, lr}
 8024b7c:	f1a3 047f 	sub.w	r4, r3, #127	; 0x7f
 8024b80:	bfb4      	ite	lt
 8024b82:	f04f 31ff 	movlt.w	r1, #4294967295
 8024b86:	2101      	movge	r1, #1
 8024b88:	2c1e      	cmp	r4, #30
 8024b8a:	dc1b      	bgt.n	8024bc4 <lroundf+0x50>
 8024b8c:	2c00      	cmp	r4, #0
 8024b8e:	da04      	bge.n	8024b9a <lroundf+0x26>
 8024b90:	3401      	adds	r4, #1
 8024b92:	bf18      	it	ne
 8024b94:	2100      	movne	r1, #0
 8024b96:	4608      	mov	r0, r1
 8024b98:	bd10      	pop	{r4, pc}
 8024b9a:	2c16      	cmp	r4, #22
 8024b9c:	bfd8      	it	le
 8024b9e:	f44f 0380 	movle.w	r3, #4194304	; 0x400000
 8024ba2:	f3c0 0216 	ubfx	r2, r0, #0, #23
 8024ba6:	bfd8      	it	le
 8024ba8:	4123      	asrle	r3, r4
 8024baa:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8024bae:	bfcd      	iteet	gt
 8024bb0:	3b96      	subgt	r3, #150	; 0x96
 8024bb2:	189b      	addle	r3, r3, r2
 8024bb4:	f1c4 0417 	rsble	r4, r4, #23
 8024bb8:	fa02 f303 	lslgt.w	r3, r2, r3
 8024bbc:	bfd8      	it	le
 8024bbe:	40e3      	lsrle	r3, r4
 8024bc0:	4359      	muls	r1, r3
 8024bc2:	e7e8      	b.n	8024b96 <lroundf+0x22>
 8024bc4:	f7dc fad2 	bl	800116c <__aeabi_f2iz>
 8024bc8:	4601      	mov	r1, r0
 8024bca:	e7e4      	b.n	8024b96 <lroundf+0x22>

08024bcc <__ieee754_sqrtf>:
 8024bcc:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8024bd0:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8024bd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8024bd8:	4603      	mov	r3, r0
 8024bda:	4604      	mov	r4, r0
 8024bdc:	d30a      	bcc.n	8024bf4 <__ieee754_sqrtf+0x28>
 8024bde:	4601      	mov	r1, r0
 8024be0:	f7dc f8e8 	bl	8000db4 <__aeabi_fmul>
 8024be4:	4601      	mov	r1, r0
 8024be6:	4620      	mov	r0, r4
 8024be8:	f7db ffdc 	bl	8000ba4 <__addsf3>
 8024bec:	4604      	mov	r4, r0
 8024bee:	4620      	mov	r0, r4
 8024bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8024bf4:	2a00      	cmp	r2, #0
 8024bf6:	d0fa      	beq.n	8024bee <__ieee754_sqrtf+0x22>
 8024bf8:	2800      	cmp	r0, #0
 8024bfa:	da06      	bge.n	8024c0a <__ieee754_sqrtf+0x3e>
 8024bfc:	4601      	mov	r1, r0
 8024bfe:	f7db ffcf 	bl	8000ba0 <__aeabi_fsub>
 8024c02:	4601      	mov	r1, r0
 8024c04:	f7dc f98a 	bl	8000f1c <__aeabi_fdiv>
 8024c08:	e7f0      	b.n	8024bec <__ieee754_sqrtf+0x20>
 8024c0a:	f010 42ff 	ands.w	r2, r0, #2139095040	; 0x7f800000
 8024c0e:	ea4f 51e0 	mov.w	r1, r0, asr #23
 8024c12:	d03e      	beq.n	8024c92 <__ieee754_sqrtf+0xc6>
 8024c14:	2400      	movs	r4, #0
 8024c16:	f1a1 057f 	sub.w	r5, r1, #127	; 0x7f
 8024c1a:	07ca      	lsls	r2, r1, #31
 8024c1c:	f04f 0019 	mov.w	r0, #25
 8024c20:	4626      	mov	r6, r4
 8024c22:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8024c26:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8024c2a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8024c2e:	bf58      	it	pl
 8024c30:	005b      	lslpl	r3, r3, #1
 8024c32:	106d      	asrs	r5, r5, #1
 8024c34:	005b      	lsls	r3, r3, #1
 8024c36:	1872      	adds	r2, r6, r1
 8024c38:	429a      	cmp	r2, r3
 8024c3a:	bfcf      	iteee	gt
 8024c3c:	461a      	movgt	r2, r3
 8024c3e:	1856      	addle	r6, r2, r1
 8024c40:	1864      	addle	r4, r4, r1
 8024c42:	1a9a      	suble	r2, r3, r2
 8024c44:	3801      	subs	r0, #1
 8024c46:	ea4f 0342 	mov.w	r3, r2, lsl #1
 8024c4a:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8024c4e:	d1f2      	bne.n	8024c36 <__ieee754_sqrtf+0x6a>
 8024c50:	b1ba      	cbz	r2, 8024c82 <__ieee754_sqrtf+0xb6>
 8024c52:	4e14      	ldr	r6, [pc, #80]	; (8024ca4 <__ieee754_sqrtf+0xd8>)
 8024c54:	4f14      	ldr	r7, [pc, #80]	; (8024ca8 <__ieee754_sqrtf+0xdc>)
 8024c56:	6830      	ldr	r0, [r6, #0]
 8024c58:	6839      	ldr	r1, [r7, #0]
 8024c5a:	f7db ffa1 	bl	8000ba0 <__aeabi_fsub>
 8024c5e:	f8d6 8000 	ldr.w	r8, [r6]
 8024c62:	4601      	mov	r1, r0
 8024c64:	4640      	mov	r0, r8
 8024c66:	f7dc fa4d 	bl	8001104 <__aeabi_fcmple>
 8024c6a:	b150      	cbz	r0, 8024c82 <__ieee754_sqrtf+0xb6>
 8024c6c:	6830      	ldr	r0, [r6, #0]
 8024c6e:	6839      	ldr	r1, [r7, #0]
 8024c70:	f7db ff98 	bl	8000ba4 <__addsf3>
 8024c74:	6836      	ldr	r6, [r6, #0]
 8024c76:	4601      	mov	r1, r0
 8024c78:	4630      	mov	r0, r6
 8024c7a:	f7dc fa39 	bl	80010f0 <__aeabi_fcmplt>
 8024c7e:	b168      	cbz	r0, 8024c9c <__ieee754_sqrtf+0xd0>
 8024c80:	3402      	adds	r4, #2
 8024c82:	1064      	asrs	r4, r4, #1
 8024c84:	f104 547c 	add.w	r4, r4, #1056964608	; 0x3f000000
 8024c88:	eb04 54c5 	add.w	r4, r4, r5, lsl #23
 8024c8c:	e7af      	b.n	8024bee <__ieee754_sqrtf+0x22>
 8024c8e:	005b      	lsls	r3, r3, #1
 8024c90:	3201      	adds	r2, #1
 8024c92:	0218      	lsls	r0, r3, #8
 8024c94:	d5fb      	bpl.n	8024c8e <__ieee754_sqrtf+0xc2>
 8024c96:	3a01      	subs	r2, #1
 8024c98:	1a89      	subs	r1, r1, r2
 8024c9a:	e7bb      	b.n	8024c14 <__ieee754_sqrtf+0x48>
 8024c9c:	3401      	adds	r4, #1
 8024c9e:	f024 0401 	bic.w	r4, r4, #1
 8024ca2:	e7ee      	b.n	8024c82 <__ieee754_sqrtf+0xb6>
 8024ca4:	20000444 	.word	0x20000444
 8024ca8:	20000448 	.word	0x20000448

08024cac <ceilf>:
 8024cac:	b570      	push	{r4, r5, r6, lr}
 8024cae:	f3c0 55c7 	ubfx	r5, r0, #23, #8
 8024cb2:	3d7f      	subs	r5, #127	; 0x7f
 8024cb4:	2d16      	cmp	r5, #22
 8024cb6:	4601      	mov	r1, r0
 8024cb8:	4604      	mov	r4, r0
 8024cba:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8024cbe:	dc25      	bgt.n	8024d0c <ceilf+0x60>
 8024cc0:	2d00      	cmp	r5, #0
 8024cc2:	da0e      	bge.n	8024ce2 <ceilf+0x36>
 8024cc4:	4917      	ldr	r1, [pc, #92]	; (8024d24 <ceilf+0x78>)
 8024cc6:	f7db ff6d 	bl	8000ba4 <__addsf3>
 8024cca:	2100      	movs	r1, #0
 8024ccc:	f7dc fa2e 	bl	800112c <__aeabi_fcmpgt>
 8024cd0:	b128      	cbz	r0, 8024cde <ceilf+0x32>
 8024cd2:	2c00      	cmp	r4, #0
 8024cd4:	db22      	blt.n	8024d1c <ceilf+0x70>
 8024cd6:	2e00      	cmp	r6, #0
 8024cd8:	bf18      	it	ne
 8024cda:	f04f 547e 	movne.w	r4, #1065353216	; 0x3f800000
 8024cde:	4621      	mov	r1, r4
 8024ce0:	e01a      	b.n	8024d18 <ceilf+0x6c>
 8024ce2:	4e11      	ldr	r6, [pc, #68]	; (8024d28 <ceilf+0x7c>)
 8024ce4:	412e      	asrs	r6, r5
 8024ce6:	4230      	tst	r0, r6
 8024ce8:	d016      	beq.n	8024d18 <ceilf+0x6c>
 8024cea:	490e      	ldr	r1, [pc, #56]	; (8024d24 <ceilf+0x78>)
 8024cec:	f7db ff5a 	bl	8000ba4 <__addsf3>
 8024cf0:	2100      	movs	r1, #0
 8024cf2:	f7dc fa1b 	bl	800112c <__aeabi_fcmpgt>
 8024cf6:	2800      	cmp	r0, #0
 8024cf8:	d0f1      	beq.n	8024cde <ceilf+0x32>
 8024cfa:	2c00      	cmp	r4, #0
 8024cfc:	bfc2      	ittt	gt
 8024cfe:	f44f 0300 	movgt.w	r3, #8388608	; 0x800000
 8024d02:	412b      	asrgt	r3, r5
 8024d04:	18e4      	addgt	r4, r4, r3
 8024d06:	ea24 0406 	bic.w	r4, r4, r6
 8024d0a:	e7e8      	b.n	8024cde <ceilf+0x32>
 8024d0c:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8024d10:	d302      	bcc.n	8024d18 <ceilf+0x6c>
 8024d12:	f7db ff47 	bl	8000ba4 <__addsf3>
 8024d16:	4601      	mov	r1, r0
 8024d18:	4608      	mov	r0, r1
 8024d1a:	bd70      	pop	{r4, r5, r6, pc}
 8024d1c:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8024d20:	e7dd      	b.n	8024cde <ceilf+0x32>
 8024d22:	bf00      	nop
 8024d24:	7149f2ca 	.word	0x7149f2ca
 8024d28:	007fffff 	.word	0x007fffff

08024d2c <floorf>:
 8024d2c:	b570      	push	{r4, r5, r6, lr}
 8024d2e:	f3c0 55c7 	ubfx	r5, r0, #23, #8
 8024d32:	3d7f      	subs	r5, #127	; 0x7f
 8024d34:	2d16      	cmp	r5, #22
 8024d36:	4601      	mov	r1, r0
 8024d38:	4604      	mov	r4, r0
 8024d3a:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8024d3e:	dc25      	bgt.n	8024d8c <floorf+0x60>
 8024d40:	2d00      	cmp	r5, #0
 8024d42:	da0e      	bge.n	8024d62 <floorf+0x36>
 8024d44:	4916      	ldr	r1, [pc, #88]	; (8024da0 <floorf+0x74>)
 8024d46:	f7db ff2d 	bl	8000ba4 <__addsf3>
 8024d4a:	2100      	movs	r1, #0
 8024d4c:	f7dc f9ee 	bl	800112c <__aeabi_fcmpgt>
 8024d50:	b128      	cbz	r0, 8024d5e <floorf+0x32>
 8024d52:	2c00      	cmp	r4, #0
 8024d54:	da22      	bge.n	8024d9c <floorf+0x70>
 8024d56:	4b13      	ldr	r3, [pc, #76]	; (8024da4 <floorf+0x78>)
 8024d58:	2e00      	cmp	r6, #0
 8024d5a:	bf18      	it	ne
 8024d5c:	461c      	movne	r4, r3
 8024d5e:	4621      	mov	r1, r4
 8024d60:	e01a      	b.n	8024d98 <floorf+0x6c>
 8024d62:	4e11      	ldr	r6, [pc, #68]	; (8024da8 <floorf+0x7c>)
 8024d64:	412e      	asrs	r6, r5
 8024d66:	4230      	tst	r0, r6
 8024d68:	d016      	beq.n	8024d98 <floorf+0x6c>
 8024d6a:	490d      	ldr	r1, [pc, #52]	; (8024da0 <floorf+0x74>)
 8024d6c:	f7db ff1a 	bl	8000ba4 <__addsf3>
 8024d70:	2100      	movs	r1, #0
 8024d72:	f7dc f9db 	bl	800112c <__aeabi_fcmpgt>
 8024d76:	2800      	cmp	r0, #0
 8024d78:	d0f1      	beq.n	8024d5e <floorf+0x32>
 8024d7a:	2c00      	cmp	r4, #0
 8024d7c:	bfbe      	ittt	lt
 8024d7e:	f44f 0300 	movlt.w	r3, #8388608	; 0x800000
 8024d82:	412b      	asrlt	r3, r5
 8024d84:	18e4      	addlt	r4, r4, r3
 8024d86:	ea24 0406 	bic.w	r4, r4, r6
 8024d8a:	e7e8      	b.n	8024d5e <floorf+0x32>
 8024d8c:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8024d90:	d302      	bcc.n	8024d98 <floorf+0x6c>
 8024d92:	f7db ff07 	bl	8000ba4 <__addsf3>
 8024d96:	4601      	mov	r1, r0
 8024d98:	4608      	mov	r0, r1
 8024d9a:	bd70      	pop	{r4, r5, r6, pc}
 8024d9c:	2400      	movs	r4, #0
 8024d9e:	e7de      	b.n	8024d5e <floorf+0x32>
 8024da0:	7149f2ca 	.word	0x7149f2ca
 8024da4:	bf800000 	.word	0xbf800000
 8024da8:	007fffff 	.word	0x007fffff

08024dac <roundf>:
 8024dac:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8024db0:	3b7f      	subs	r3, #127	; 0x7f
 8024db2:	2b16      	cmp	r3, #22
 8024db4:	4601      	mov	r1, r0
 8024db6:	b510      	push	{r4, lr}
 8024db8:	dc14      	bgt.n	8024de4 <roundf+0x38>
 8024dba:	2b00      	cmp	r3, #0
 8024dbc:	da07      	bge.n	8024dce <roundf+0x22>
 8024dbe:	3301      	adds	r3, #1
 8024dc0:	f000 4100 	and.w	r1, r0, #2147483648	; 0x80000000
 8024dc4:	d101      	bne.n	8024dca <roundf+0x1e>
 8024dc6:	f041 517e 	orr.w	r1, r1, #1065353216	; 0x3f800000
 8024dca:	4608      	mov	r0, r1
 8024dcc:	bd10      	pop	{r4, pc}
 8024dce:	4a08      	ldr	r2, [pc, #32]	; (8024df0 <roundf+0x44>)
 8024dd0:	411a      	asrs	r2, r3
 8024dd2:	4210      	tst	r0, r2
 8024dd4:	d0f9      	beq.n	8024dca <roundf+0x1e>
 8024dd6:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8024dda:	4119      	asrs	r1, r3
 8024ddc:	4401      	add	r1, r0
 8024dde:	ea21 0102 	bic.w	r1, r1, r2
 8024de2:	e7f2      	b.n	8024dca <roundf+0x1e>
 8024de4:	2b80      	cmp	r3, #128	; 0x80
 8024de6:	d1f0      	bne.n	8024dca <roundf+0x1e>
 8024de8:	f7db fedc 	bl	8000ba4 <__addsf3>
 8024dec:	4601      	mov	r1, r0
 8024dee:	e7ec      	b.n	8024dca <roundf+0x1e>
 8024df0:	007fffff 	.word	0x007fffff

08024df4 <truncf>:
 8024df4:	b508      	push	{r3, lr}
 8024df6:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8024dfa:	3b7f      	subs	r3, #127	; 0x7f
 8024dfc:	2b16      	cmp	r3, #22
 8024dfe:	4601      	mov	r1, r0
 8024e00:	dc08      	bgt.n	8024e14 <truncf+0x20>
 8024e02:	2b00      	cmp	r3, #0
 8024e04:	bfa9      	itett	ge
 8024e06:	4906      	ldrge	r1, [pc, #24]	; (8024e20 <truncf+0x2c>)
 8024e08:	f000 4100 	andlt.w	r1, r0, #2147483648	; 0x80000000
 8024e0c:	4119      	asrge	r1, r3
 8024e0e:	4001      	andge	r1, r0
 8024e10:	4608      	mov	r0, r1
 8024e12:	bd08      	pop	{r3, pc}
 8024e14:	2b80      	cmp	r3, #128	; 0x80
 8024e16:	d1fb      	bne.n	8024e10 <truncf+0x1c>
 8024e18:	f7db fec4 	bl	8000ba4 <__addsf3>
 8024e1c:	4601      	mov	r1, r0
 8024e1e:	e7f7      	b.n	8024e10 <truncf+0x1c>
 8024e20:	ff800000 	.word	0xff800000
 8024e24:	00000000 	.word	0x00000000

08024e28 <__ieee754_atan2>:
 8024e28:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024e2c:	4617      	mov	r7, r2
 8024e2e:	4692      	mov	sl, r2
 8024e30:	4699      	mov	r9, r3
 8024e32:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8024e36:	427b      	negs	r3, r7
 8024e38:	f8df 817c 	ldr.w	r8, [pc, #380]	; 8024fb8 <__ieee754_atan2+0x190>
 8024e3c:	433b      	orrs	r3, r7
 8024e3e:	ea42 73d3 	orr.w	r3, r2, r3, lsr #31
 8024e42:	4543      	cmp	r3, r8
 8024e44:	4604      	mov	r4, r0
 8024e46:	460d      	mov	r5, r1
 8024e48:	d809      	bhi.n	8024e5e <__ieee754_atan2+0x36>
 8024e4a:	4246      	negs	r6, r0
 8024e4c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8024e50:	4306      	orrs	r6, r0
 8024e52:	ea43 76d6 	orr.w	r6, r3, r6, lsr #31
 8024e56:	4546      	cmp	r6, r8
 8024e58:	468e      	mov	lr, r1
 8024e5a:	4683      	mov	fp, r0
 8024e5c:	d908      	bls.n	8024e70 <__ieee754_atan2+0x48>
 8024e5e:	4652      	mov	r2, sl
 8024e60:	464b      	mov	r3, r9
 8024e62:	4620      	mov	r0, r4
 8024e64:	4629      	mov	r1, r5
 8024e66:	f7db f9f7 	bl	8000258 <__adddf3>
 8024e6a:	4604      	mov	r4, r0
 8024e6c:	460d      	mov	r5, r1
 8024e6e:	e019      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024e70:	f109 4640 	add.w	r6, r9, #3221225472	; 0xc0000000
 8024e74:	f506 1680 	add.w	r6, r6, #1048576	; 0x100000
 8024e78:	433e      	orrs	r6, r7
 8024e7a:	d103      	bne.n	8024e84 <__ieee754_atan2+0x5c>
 8024e7c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024e80:	f000 b8a2 	b.w	8024fc8 <atan>
 8024e84:	ea4f 76a9 	mov.w	r6, r9, asr #30
 8024e88:	f006 0602 	and.w	r6, r6, #2
 8024e8c:	ea53 0b0b 	orrs.w	fp, r3, fp
 8024e90:	ea46 76d1 	orr.w	r6, r6, r1, lsr #31
 8024e94:	d10a      	bne.n	8024eac <__ieee754_atan2+0x84>
 8024e96:	2e02      	cmp	r6, #2
 8024e98:	d067      	beq.n	8024f6a <__ieee754_atan2+0x142>
 8024e9a:	2e03      	cmp	r6, #3
 8024e9c:	d102      	bne.n	8024ea4 <__ieee754_atan2+0x7c>
 8024e9e:	a53a      	add	r5, pc, #232	; (adr r5, 8024f88 <__ieee754_atan2+0x160>)
 8024ea0:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024ea4:	4620      	mov	r0, r4
 8024ea6:	4629      	mov	r1, r5
 8024ea8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024eac:	4317      	orrs	r7, r2
 8024eae:	d106      	bne.n	8024ebe <__ieee754_atan2+0x96>
 8024eb0:	f1be 0f00 	cmp.w	lr, #0
 8024eb4:	da64      	bge.n	8024f80 <__ieee754_atan2+0x158>
 8024eb6:	a536      	add	r5, pc, #216	; (adr r5, 8024f90 <__ieee754_atan2+0x168>)
 8024eb8:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024ebc:	e7f2      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024ebe:	4542      	cmp	r2, r8
 8024ec0:	d10f      	bne.n	8024ee2 <__ieee754_atan2+0xba>
 8024ec2:	4293      	cmp	r3, r2
 8024ec4:	f106 36ff 	add.w	r6, r6, #4294967295
 8024ec8:	d107      	bne.n	8024eda <__ieee754_atan2+0xb2>
 8024eca:	2e02      	cmp	r6, #2
 8024ecc:	d851      	bhi.n	8024f72 <__ieee754_atan2+0x14a>
 8024ece:	4b3b      	ldr	r3, [pc, #236]	; (8024fbc <__ieee754_atan2+0x194>)
 8024ed0:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8024ed4:	e9d3 4500 	ldrd	r4, r5, [r3]
 8024ed8:	e7e4      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024eda:	2e02      	cmp	r6, #2
 8024edc:	d84d      	bhi.n	8024f7a <__ieee754_atan2+0x152>
 8024ede:	4b38      	ldr	r3, [pc, #224]	; (8024fc0 <__ieee754_atan2+0x198>)
 8024ee0:	e7f6      	b.n	8024ed0 <__ieee754_atan2+0xa8>
 8024ee2:	4543      	cmp	r3, r8
 8024ee4:	d0e4      	beq.n	8024eb0 <__ieee754_atan2+0x88>
 8024ee6:	1a9b      	subs	r3, r3, r2
 8024ee8:	f1b3 7f74 	cmp.w	r3, #63963136	; 0x3d00000
 8024eec:	ea4f 5223 	mov.w	r2, r3, asr #20
 8024ef0:	da21      	bge.n	8024f36 <__ieee754_atan2+0x10e>
 8024ef2:	f1b9 0f00 	cmp.w	r9, #0
 8024ef6:	da01      	bge.n	8024efc <__ieee754_atan2+0xd4>
 8024ef8:	323c      	adds	r2, #60	; 0x3c
 8024efa:	db20      	blt.n	8024f3e <__ieee754_atan2+0x116>
 8024efc:	4652      	mov	r2, sl
 8024efe:	464b      	mov	r3, r9
 8024f00:	4620      	mov	r0, r4
 8024f02:	4629      	mov	r1, r5
 8024f04:	f7db fc88 	bl	8000818 <__aeabi_ddiv>
 8024f08:	f000 f9e8 	bl	80252dc <fabs>
 8024f0c:	f000 f85c 	bl	8024fc8 <atan>
 8024f10:	4604      	mov	r4, r0
 8024f12:	460d      	mov	r5, r1
 8024f14:	2e01      	cmp	r6, #1
 8024f16:	d015      	beq.n	8024f44 <__ieee754_atan2+0x11c>
 8024f18:	2e02      	cmp	r6, #2
 8024f1a:	d017      	beq.n	8024f4c <__ieee754_atan2+0x124>
 8024f1c:	2e00      	cmp	r6, #0
 8024f1e:	d0c1      	beq.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f20:	a31d      	add	r3, pc, #116	; (adr r3, 8024f98 <__ieee754_atan2+0x170>)
 8024f22:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024f26:	4620      	mov	r0, r4
 8024f28:	4629      	mov	r1, r5
 8024f2a:	f7db f993 	bl	8000254 <__aeabi_dsub>
 8024f2e:	a31c      	add	r3, pc, #112	; (adr r3, 8024fa0 <__ieee754_atan2+0x178>)
 8024f30:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024f34:	e016      	b.n	8024f64 <__ieee754_atan2+0x13c>
 8024f36:	a51c      	add	r5, pc, #112	; (adr r5, 8024fa8 <__ieee754_atan2+0x180>)
 8024f38:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024f3c:	e7ea      	b.n	8024f14 <__ieee754_atan2+0xec>
 8024f3e:	2400      	movs	r4, #0
 8024f40:	2500      	movs	r5, #0
 8024f42:	e7e7      	b.n	8024f14 <__ieee754_atan2+0xec>
 8024f44:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 8024f48:	461d      	mov	r5, r3
 8024f4a:	e7ab      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f4c:	a312      	add	r3, pc, #72	; (adr r3, 8024f98 <__ieee754_atan2+0x170>)
 8024f4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8024f52:	4620      	mov	r0, r4
 8024f54:	4629      	mov	r1, r5
 8024f56:	f7db f97d 	bl	8000254 <__aeabi_dsub>
 8024f5a:	4602      	mov	r2, r0
 8024f5c:	460b      	mov	r3, r1
 8024f5e:	a110      	add	r1, pc, #64	; (adr r1, 8024fa0 <__ieee754_atan2+0x178>)
 8024f60:	e9d1 0100 	ldrd	r0, r1, [r1]
 8024f64:	f7db f976 	bl	8000254 <__aeabi_dsub>
 8024f68:	e77f      	b.n	8024e6a <__ieee754_atan2+0x42>
 8024f6a:	a50d      	add	r5, pc, #52	; (adr r5, 8024fa0 <__ieee754_atan2+0x178>)
 8024f6c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024f70:	e798      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f72:	a50f      	add	r5, pc, #60	; (adr r5, 8024fb0 <__ieee754_atan2+0x188>)
 8024f74:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024f78:	e794      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f7a:	2400      	movs	r4, #0
 8024f7c:	2500      	movs	r5, #0
 8024f7e:	e791      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f80:	a509      	add	r5, pc, #36	; (adr r5, 8024fa8 <__ieee754_atan2+0x180>)
 8024f82:	e9d5 4500 	ldrd	r4, r5, [r5]
 8024f86:	e78d      	b.n	8024ea4 <__ieee754_atan2+0x7c>
 8024f88:	54442d18 	.word	0x54442d18
 8024f8c:	c00921fb 	.word	0xc00921fb
 8024f90:	54442d18 	.word	0x54442d18
 8024f94:	bff921fb 	.word	0xbff921fb
 8024f98:	33145c07 	.word	0x33145c07
 8024f9c:	3ca1a626 	.word	0x3ca1a626
 8024fa0:	54442d18 	.word	0x54442d18
 8024fa4:	400921fb 	.word	0x400921fb
 8024fa8:	54442d18 	.word	0x54442d18
 8024fac:	3ff921fb 	.word	0x3ff921fb
 8024fb0:	54442d18 	.word	0x54442d18
 8024fb4:	3fe921fb 	.word	0x3fe921fb
 8024fb8:	7ff00000 	.word	0x7ff00000
 8024fbc:	08032fd8 	.word	0x08032fd8
 8024fc0:	08032ff0 	.word	0x08032ff0
 8024fc4:	00000000 	.word	0x00000000

08024fc8 <atan>:
 8024fc8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024fcc:	4bb6      	ldr	r3, [pc, #728]	; (80252a8 <atan+0x2e0>)
 8024fce:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 8024fd2:	429e      	cmp	r6, r3
 8024fd4:	4604      	mov	r4, r0
 8024fd6:	460d      	mov	r5, r1
 8024fd8:	468b      	mov	fp, r1
 8024fda:	dd17      	ble.n	802500c <atan+0x44>
 8024fdc:	4bb3      	ldr	r3, [pc, #716]	; (80252ac <atan+0x2e4>)
 8024fde:	429e      	cmp	r6, r3
 8024fe0:	dc01      	bgt.n	8024fe6 <atan+0x1e>
 8024fe2:	d109      	bne.n	8024ff8 <atan+0x30>
 8024fe4:	b140      	cbz	r0, 8024ff8 <atan+0x30>
 8024fe6:	4622      	mov	r2, r4
 8024fe8:	462b      	mov	r3, r5
 8024fea:	4620      	mov	r0, r4
 8024fec:	4629      	mov	r1, r5
 8024fee:	f7db f933 	bl	8000258 <__adddf3>
 8024ff2:	4604      	mov	r4, r0
 8024ff4:	460d      	mov	r5, r1
 8024ff6:	e005      	b.n	8025004 <atan+0x3c>
 8024ff8:	f1bb 0f00 	cmp.w	fp, #0
 8024ffc:	4cac      	ldr	r4, [pc, #688]	; (80252b0 <atan+0x2e8>)
 8024ffe:	f300 8121 	bgt.w	8025244 <atan+0x27c>
 8025002:	4dac      	ldr	r5, [pc, #688]	; (80252b4 <atan+0x2ec>)
 8025004:	4620      	mov	r0, r4
 8025006:	4629      	mov	r1, r5
 8025008:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802500c:	4baa      	ldr	r3, [pc, #680]	; (80252b8 <atan+0x2f0>)
 802500e:	429e      	cmp	r6, r3
 8025010:	dc11      	bgt.n	8025036 <atan+0x6e>
 8025012:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
 8025016:	429e      	cmp	r6, r3
 8025018:	dc0a      	bgt.n	8025030 <atan+0x68>
 802501a:	a38b      	add	r3, pc, #556	; (adr r3, 8025248 <atan+0x280>)
 802501c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025020:	f7db f91a 	bl	8000258 <__adddf3>
 8025024:	2200      	movs	r2, #0
 8025026:	4ba5      	ldr	r3, [pc, #660]	; (80252bc <atan+0x2f4>)
 8025028:	f7db fd5c 	bl	8000ae4 <__aeabi_dcmpgt>
 802502c:	2800      	cmp	r0, #0
 802502e:	d1e9      	bne.n	8025004 <atan+0x3c>
 8025030:	f04f 3aff 	mov.w	sl, #4294967295
 8025034:	e027      	b.n	8025086 <atan+0xbe>
 8025036:	f000 f951 	bl	80252dc <fabs>
 802503a:	4ba1      	ldr	r3, [pc, #644]	; (80252c0 <atan+0x2f8>)
 802503c:	4604      	mov	r4, r0
 802503e:	429e      	cmp	r6, r3
 8025040:	460d      	mov	r5, r1
 8025042:	f300 80b8 	bgt.w	80251b6 <atan+0x1ee>
 8025046:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
 802504a:	429e      	cmp	r6, r3
 802504c:	f300 809c 	bgt.w	8025188 <atan+0x1c0>
 8025050:	4602      	mov	r2, r0
 8025052:	460b      	mov	r3, r1
 8025054:	f7db f900 	bl	8000258 <__adddf3>
 8025058:	2200      	movs	r2, #0
 802505a:	4b98      	ldr	r3, [pc, #608]	; (80252bc <atan+0x2f4>)
 802505c:	f7db f8fa 	bl	8000254 <__aeabi_dsub>
 8025060:	2200      	movs	r2, #0
 8025062:	4606      	mov	r6, r0
 8025064:	460f      	mov	r7, r1
 8025066:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802506a:	4620      	mov	r0, r4
 802506c:	4629      	mov	r1, r5
 802506e:	f7db f8f3 	bl	8000258 <__adddf3>
 8025072:	4602      	mov	r2, r0
 8025074:	460b      	mov	r3, r1
 8025076:	4630      	mov	r0, r6
 8025078:	4639      	mov	r1, r7
 802507a:	f7db fbcd 	bl	8000818 <__aeabi_ddiv>
 802507e:	f04f 0a00 	mov.w	sl, #0
 8025082:	4604      	mov	r4, r0
 8025084:	460d      	mov	r5, r1
 8025086:	4622      	mov	r2, r4
 8025088:	462b      	mov	r3, r5
 802508a:	4620      	mov	r0, r4
 802508c:	4629      	mov	r1, r5
 802508e:	f7db fa99 	bl	80005c4 <__aeabi_dmul>
 8025092:	4602      	mov	r2, r0
 8025094:	460b      	mov	r3, r1
 8025096:	4680      	mov	r8, r0
 8025098:	4689      	mov	r9, r1
 802509a:	f7db fa93 	bl	80005c4 <__aeabi_dmul>
 802509e:	a36c      	add	r3, pc, #432	; (adr r3, 8025250 <atan+0x288>)
 80250a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250a4:	4606      	mov	r6, r0
 80250a6:	460f      	mov	r7, r1
 80250a8:	f7db fa8c 	bl	80005c4 <__aeabi_dmul>
 80250ac:	a36a      	add	r3, pc, #424	; (adr r3, 8025258 <atan+0x290>)
 80250ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250b2:	f7db f8d1 	bl	8000258 <__adddf3>
 80250b6:	4632      	mov	r2, r6
 80250b8:	463b      	mov	r3, r7
 80250ba:	f7db fa83 	bl	80005c4 <__aeabi_dmul>
 80250be:	a368      	add	r3, pc, #416	; (adr r3, 8025260 <atan+0x298>)
 80250c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250c4:	f7db f8c8 	bl	8000258 <__adddf3>
 80250c8:	4632      	mov	r2, r6
 80250ca:	463b      	mov	r3, r7
 80250cc:	f7db fa7a 	bl	80005c4 <__aeabi_dmul>
 80250d0:	a365      	add	r3, pc, #404	; (adr r3, 8025268 <atan+0x2a0>)
 80250d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250d6:	f7db f8bf 	bl	8000258 <__adddf3>
 80250da:	4632      	mov	r2, r6
 80250dc:	463b      	mov	r3, r7
 80250de:	f7db fa71 	bl	80005c4 <__aeabi_dmul>
 80250e2:	a363      	add	r3, pc, #396	; (adr r3, 8025270 <atan+0x2a8>)
 80250e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250e8:	f7db f8b6 	bl	8000258 <__adddf3>
 80250ec:	4632      	mov	r2, r6
 80250ee:	463b      	mov	r3, r7
 80250f0:	f7db fa68 	bl	80005c4 <__aeabi_dmul>
 80250f4:	a360      	add	r3, pc, #384	; (adr r3, 8025278 <atan+0x2b0>)
 80250f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80250fa:	f7db f8ad 	bl	8000258 <__adddf3>
 80250fe:	4642      	mov	r2, r8
 8025100:	464b      	mov	r3, r9
 8025102:	f7db fa5f 	bl	80005c4 <__aeabi_dmul>
 8025106:	a35e      	add	r3, pc, #376	; (adr r3, 8025280 <atan+0x2b8>)
 8025108:	e9d3 2300 	ldrd	r2, r3, [r3]
 802510c:	4680      	mov	r8, r0
 802510e:	4689      	mov	r9, r1
 8025110:	4630      	mov	r0, r6
 8025112:	4639      	mov	r1, r7
 8025114:	f7db fa56 	bl	80005c4 <__aeabi_dmul>
 8025118:	a35b      	add	r3, pc, #364	; (adr r3, 8025288 <atan+0x2c0>)
 802511a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802511e:	f7db f899 	bl	8000254 <__aeabi_dsub>
 8025122:	4632      	mov	r2, r6
 8025124:	463b      	mov	r3, r7
 8025126:	f7db fa4d 	bl	80005c4 <__aeabi_dmul>
 802512a:	a359      	add	r3, pc, #356	; (adr r3, 8025290 <atan+0x2c8>)
 802512c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025130:	f7db f890 	bl	8000254 <__aeabi_dsub>
 8025134:	4632      	mov	r2, r6
 8025136:	463b      	mov	r3, r7
 8025138:	f7db fa44 	bl	80005c4 <__aeabi_dmul>
 802513c:	a356      	add	r3, pc, #344	; (adr r3, 8025298 <atan+0x2d0>)
 802513e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025142:	f7db f887 	bl	8000254 <__aeabi_dsub>
 8025146:	4632      	mov	r2, r6
 8025148:	463b      	mov	r3, r7
 802514a:	f7db fa3b 	bl	80005c4 <__aeabi_dmul>
 802514e:	a354      	add	r3, pc, #336	; (adr r3, 80252a0 <atan+0x2d8>)
 8025150:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025154:	f7db f87e 	bl	8000254 <__aeabi_dsub>
 8025158:	4632      	mov	r2, r6
 802515a:	463b      	mov	r3, r7
 802515c:	f7db fa32 	bl	80005c4 <__aeabi_dmul>
 8025160:	4602      	mov	r2, r0
 8025162:	460b      	mov	r3, r1
 8025164:	4640      	mov	r0, r8
 8025166:	4649      	mov	r1, r9
 8025168:	f7db f876 	bl	8000258 <__adddf3>
 802516c:	4622      	mov	r2, r4
 802516e:	462b      	mov	r3, r5
 8025170:	f7db fa28 	bl	80005c4 <__aeabi_dmul>
 8025174:	f1ba 3fff 	cmp.w	sl, #4294967295
 8025178:	4602      	mov	r2, r0
 802517a:	460b      	mov	r3, r1
 802517c:	d144      	bne.n	8025208 <atan+0x240>
 802517e:	4620      	mov	r0, r4
 8025180:	4629      	mov	r1, r5
 8025182:	f7db f867 	bl	8000254 <__aeabi_dsub>
 8025186:	e734      	b.n	8024ff2 <atan+0x2a>
 8025188:	2200      	movs	r2, #0
 802518a:	4b4c      	ldr	r3, [pc, #304]	; (80252bc <atan+0x2f4>)
 802518c:	f7db f862 	bl	8000254 <__aeabi_dsub>
 8025190:	2200      	movs	r2, #0
 8025192:	4606      	mov	r6, r0
 8025194:	460f      	mov	r7, r1
 8025196:	4620      	mov	r0, r4
 8025198:	4629      	mov	r1, r5
 802519a:	4b48      	ldr	r3, [pc, #288]	; (80252bc <atan+0x2f4>)
 802519c:	f7db f85c 	bl	8000258 <__adddf3>
 80251a0:	4602      	mov	r2, r0
 80251a2:	460b      	mov	r3, r1
 80251a4:	4630      	mov	r0, r6
 80251a6:	4639      	mov	r1, r7
 80251a8:	f7db fb36 	bl	8000818 <__aeabi_ddiv>
 80251ac:	f04f 0a01 	mov.w	sl, #1
 80251b0:	4604      	mov	r4, r0
 80251b2:	460d      	mov	r5, r1
 80251b4:	e767      	b.n	8025086 <atan+0xbe>
 80251b6:	4b43      	ldr	r3, [pc, #268]	; (80252c4 <atan+0x2fc>)
 80251b8:	429e      	cmp	r6, r3
 80251ba:	da1a      	bge.n	80251f2 <atan+0x22a>
 80251bc:	2200      	movs	r2, #0
 80251be:	4b42      	ldr	r3, [pc, #264]	; (80252c8 <atan+0x300>)
 80251c0:	f7db f848 	bl	8000254 <__aeabi_dsub>
 80251c4:	2200      	movs	r2, #0
 80251c6:	4606      	mov	r6, r0
 80251c8:	460f      	mov	r7, r1
 80251ca:	4620      	mov	r0, r4
 80251cc:	4629      	mov	r1, r5
 80251ce:	4b3e      	ldr	r3, [pc, #248]	; (80252c8 <atan+0x300>)
 80251d0:	f7db f9f8 	bl	80005c4 <__aeabi_dmul>
 80251d4:	2200      	movs	r2, #0
 80251d6:	4b39      	ldr	r3, [pc, #228]	; (80252bc <atan+0x2f4>)
 80251d8:	f7db f83e 	bl	8000258 <__adddf3>
 80251dc:	4602      	mov	r2, r0
 80251de:	460b      	mov	r3, r1
 80251e0:	4630      	mov	r0, r6
 80251e2:	4639      	mov	r1, r7
 80251e4:	f7db fb18 	bl	8000818 <__aeabi_ddiv>
 80251e8:	f04f 0a02 	mov.w	sl, #2
 80251ec:	4604      	mov	r4, r0
 80251ee:	460d      	mov	r5, r1
 80251f0:	e749      	b.n	8025086 <atan+0xbe>
 80251f2:	4602      	mov	r2, r0
 80251f4:	460b      	mov	r3, r1
 80251f6:	2000      	movs	r0, #0
 80251f8:	4934      	ldr	r1, [pc, #208]	; (80252cc <atan+0x304>)
 80251fa:	f7db fb0d 	bl	8000818 <__aeabi_ddiv>
 80251fe:	f04f 0a03 	mov.w	sl, #3
 8025202:	4604      	mov	r4, r0
 8025204:	460d      	mov	r5, r1
 8025206:	e73e      	b.n	8025086 <atan+0xbe>
 8025208:	4b31      	ldr	r3, [pc, #196]	; (80252d0 <atan+0x308>)
 802520a:	4e32      	ldr	r6, [pc, #200]	; (80252d4 <atan+0x30c>)
 802520c:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8025210:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025214:	f7db f81e 	bl	8000254 <__aeabi_dsub>
 8025218:	4622      	mov	r2, r4
 802521a:	462b      	mov	r3, r5
 802521c:	f7db f81a 	bl	8000254 <__aeabi_dsub>
 8025220:	eb06 06ca 	add.w	r6, r6, sl, lsl #3
 8025224:	4602      	mov	r2, r0
 8025226:	460b      	mov	r3, r1
 8025228:	e9d6 0100 	ldrd	r0, r1, [r6]
 802522c:	f7db f812 	bl	8000254 <__aeabi_dsub>
 8025230:	f1bb 0f00 	cmp.w	fp, #0
 8025234:	4604      	mov	r4, r0
 8025236:	460d      	mov	r5, r1
 8025238:	f6bf aee4 	bge.w	8025004 <atan+0x3c>
 802523c:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8025240:	461d      	mov	r5, r3
 8025242:	e6df      	b.n	8025004 <atan+0x3c>
 8025244:	4d24      	ldr	r5, [pc, #144]	; (80252d8 <atan+0x310>)
 8025246:	e6dd      	b.n	8025004 <atan+0x3c>
 8025248:	8800759c 	.word	0x8800759c
 802524c:	7e37e43c 	.word	0x7e37e43c
 8025250:	e322da11 	.word	0xe322da11
 8025254:	3f90ad3a 	.word	0x3f90ad3a
 8025258:	24760deb 	.word	0x24760deb
 802525c:	3fa97b4b 	.word	0x3fa97b4b
 8025260:	a0d03d51 	.word	0xa0d03d51
 8025264:	3fb10d66 	.word	0x3fb10d66
 8025268:	c54c206e 	.word	0xc54c206e
 802526c:	3fb745cd 	.word	0x3fb745cd
 8025270:	920083ff 	.word	0x920083ff
 8025274:	3fc24924 	.word	0x3fc24924
 8025278:	5555550d 	.word	0x5555550d
 802527c:	3fd55555 	.word	0x3fd55555
 8025280:	2c6a6c2f 	.word	0x2c6a6c2f
 8025284:	bfa2b444 	.word	0xbfa2b444
 8025288:	52defd9a 	.word	0x52defd9a
 802528c:	3fadde2d 	.word	0x3fadde2d
 8025290:	af749a6d 	.word	0xaf749a6d
 8025294:	3fb3b0f2 	.word	0x3fb3b0f2
 8025298:	fe231671 	.word	0xfe231671
 802529c:	3fbc71c6 	.word	0x3fbc71c6
 80252a0:	9998ebc4 	.word	0x9998ebc4
 80252a4:	3fc99999 	.word	0x3fc99999
 80252a8:	440fffff 	.word	0x440fffff
 80252ac:	7ff00000 	.word	0x7ff00000
 80252b0:	54442d18 	.word	0x54442d18
 80252b4:	bff921fb 	.word	0xbff921fb
 80252b8:	3fdbffff 	.word	0x3fdbffff
 80252bc:	3ff00000 	.word	0x3ff00000
 80252c0:	3ff2ffff 	.word	0x3ff2ffff
 80252c4:	40038000 	.word	0x40038000
 80252c8:	3ff80000 	.word	0x3ff80000
 80252cc:	bff00000 	.word	0xbff00000
 80252d0:	08033028 	.word	0x08033028
 80252d4:	08033008 	.word	0x08033008
 80252d8:	3ff921fb 	.word	0x3ff921fb

080252dc <fabs>:
 80252dc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 80252e0:	4619      	mov	r1, r3
 80252e2:	4770      	bx	lr

080252e4 <__kernel_cosf>:
 80252e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80252e8:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 80252ec:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 80252f0:	4606      	mov	r6, r0
 80252f2:	4688      	mov	r8, r1
 80252f4:	da03      	bge.n	80252fe <__kernel_cosf+0x1a>
 80252f6:	f7db ff39 	bl	800116c <__aeabi_f2iz>
 80252fa:	2800      	cmp	r0, #0
 80252fc:	d05c      	beq.n	80253b8 <__kernel_cosf+0xd4>
 80252fe:	4631      	mov	r1, r6
 8025300:	4630      	mov	r0, r6
 8025302:	f7db fd57 	bl	8000db4 <__aeabi_fmul>
 8025306:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 802530a:	4605      	mov	r5, r0
 802530c:	f7db fd52 	bl	8000db4 <__aeabi_fmul>
 8025310:	492b      	ldr	r1, [pc, #172]	; (80253c0 <__kernel_cosf+0xdc>)
 8025312:	4607      	mov	r7, r0
 8025314:	4628      	mov	r0, r5
 8025316:	f7db fd4d 	bl	8000db4 <__aeabi_fmul>
 802531a:	492a      	ldr	r1, [pc, #168]	; (80253c4 <__kernel_cosf+0xe0>)
 802531c:	f7db fc42 	bl	8000ba4 <__addsf3>
 8025320:	4629      	mov	r1, r5
 8025322:	f7db fd47 	bl	8000db4 <__aeabi_fmul>
 8025326:	4928      	ldr	r1, [pc, #160]	; (80253c8 <__kernel_cosf+0xe4>)
 8025328:	f7db fc3a 	bl	8000ba0 <__aeabi_fsub>
 802532c:	4629      	mov	r1, r5
 802532e:	f7db fd41 	bl	8000db4 <__aeabi_fmul>
 8025332:	4926      	ldr	r1, [pc, #152]	; (80253cc <__kernel_cosf+0xe8>)
 8025334:	f7db fc36 	bl	8000ba4 <__addsf3>
 8025338:	4629      	mov	r1, r5
 802533a:	f7db fd3b 	bl	8000db4 <__aeabi_fmul>
 802533e:	4924      	ldr	r1, [pc, #144]	; (80253d0 <__kernel_cosf+0xec>)
 8025340:	f7db fc2e 	bl	8000ba0 <__aeabi_fsub>
 8025344:	4629      	mov	r1, r5
 8025346:	f7db fd35 	bl	8000db4 <__aeabi_fmul>
 802534a:	4922      	ldr	r1, [pc, #136]	; (80253d4 <__kernel_cosf+0xf0>)
 802534c:	f7db fc2a 	bl	8000ba4 <__addsf3>
 8025350:	4629      	mov	r1, r5
 8025352:	f7db fd2f 	bl	8000db4 <__aeabi_fmul>
 8025356:	4629      	mov	r1, r5
 8025358:	f7db fd2c 	bl	8000db4 <__aeabi_fmul>
 802535c:	4641      	mov	r1, r8
 802535e:	4605      	mov	r5, r0
 8025360:	4630      	mov	r0, r6
 8025362:	f7db fd27 	bl	8000db4 <__aeabi_fmul>
 8025366:	4601      	mov	r1, r0
 8025368:	4628      	mov	r0, r5
 802536a:	f7db fc19 	bl	8000ba0 <__aeabi_fsub>
 802536e:	4b1a      	ldr	r3, [pc, #104]	; (80253d8 <__kernel_cosf+0xf4>)
 8025370:	4605      	mov	r5, r0
 8025372:	429c      	cmp	r4, r3
 8025374:	dc0a      	bgt.n	802538c <__kernel_cosf+0xa8>
 8025376:	4601      	mov	r1, r0
 8025378:	4638      	mov	r0, r7
 802537a:	f7db fc11 	bl	8000ba0 <__aeabi_fsub>
 802537e:	4601      	mov	r1, r0
 8025380:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025384:	f7db fc0c 	bl	8000ba0 <__aeabi_fsub>
 8025388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802538c:	4b13      	ldr	r3, [pc, #76]	; (80253dc <__kernel_cosf+0xf8>)
 802538e:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025392:	429c      	cmp	r4, r3
 8025394:	bfcc      	ite	gt
 8025396:	4c12      	ldrgt	r4, [pc, #72]	; (80253e0 <__kernel_cosf+0xfc>)
 8025398:	f104 447f 	addle.w	r4, r4, #4278190080	; 0xff000000
 802539c:	4621      	mov	r1, r4
 802539e:	f7db fbff 	bl	8000ba0 <__aeabi_fsub>
 80253a2:	4621      	mov	r1, r4
 80253a4:	4606      	mov	r6, r0
 80253a6:	4638      	mov	r0, r7
 80253a8:	f7db fbfa 	bl	8000ba0 <__aeabi_fsub>
 80253ac:	4629      	mov	r1, r5
 80253ae:	f7db fbf7 	bl	8000ba0 <__aeabi_fsub>
 80253b2:	4601      	mov	r1, r0
 80253b4:	4630      	mov	r0, r6
 80253b6:	e7e5      	b.n	8025384 <__kernel_cosf+0xa0>
 80253b8:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80253bc:	e7e4      	b.n	8025388 <__kernel_cosf+0xa4>
 80253be:	bf00      	nop
 80253c0:	ad47d74e 	.word	0xad47d74e
 80253c4:	310f74f6 	.word	0x310f74f6
 80253c8:	3493f27c 	.word	0x3493f27c
 80253cc:	37d00d01 	.word	0x37d00d01
 80253d0:	3ab60b61 	.word	0x3ab60b61
 80253d4:	3d2aaaab 	.word	0x3d2aaaab
 80253d8:	3e999999 	.word	0x3e999999
 80253dc:	3f480000 	.word	0x3f480000
 80253e0:	3e900000 	.word	0x3e900000

080253e4 <__kernel_sinf>:
 80253e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80253e8:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 80253ec:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80253f0:	4604      	mov	r4, r0
 80253f2:	460f      	mov	r7, r1
 80253f4:	4691      	mov	r9, r2
 80253f6:	da03      	bge.n	8025400 <__kernel_sinf+0x1c>
 80253f8:	f7db feb8 	bl	800116c <__aeabi_f2iz>
 80253fc:	2800      	cmp	r0, #0
 80253fe:	d035      	beq.n	802546c <__kernel_sinf+0x88>
 8025400:	4621      	mov	r1, r4
 8025402:	4620      	mov	r0, r4
 8025404:	f7db fcd6 	bl	8000db4 <__aeabi_fmul>
 8025408:	4605      	mov	r5, r0
 802540a:	4601      	mov	r1, r0
 802540c:	4620      	mov	r0, r4
 802540e:	f7db fcd1 	bl	8000db4 <__aeabi_fmul>
 8025412:	4929      	ldr	r1, [pc, #164]	; (80254b8 <__kernel_sinf+0xd4>)
 8025414:	4606      	mov	r6, r0
 8025416:	4628      	mov	r0, r5
 8025418:	f7db fccc 	bl	8000db4 <__aeabi_fmul>
 802541c:	4927      	ldr	r1, [pc, #156]	; (80254bc <__kernel_sinf+0xd8>)
 802541e:	f7db fbbf 	bl	8000ba0 <__aeabi_fsub>
 8025422:	4629      	mov	r1, r5
 8025424:	f7db fcc6 	bl	8000db4 <__aeabi_fmul>
 8025428:	4925      	ldr	r1, [pc, #148]	; (80254c0 <__kernel_sinf+0xdc>)
 802542a:	f7db fbbb 	bl	8000ba4 <__addsf3>
 802542e:	4629      	mov	r1, r5
 8025430:	f7db fcc0 	bl	8000db4 <__aeabi_fmul>
 8025434:	4923      	ldr	r1, [pc, #140]	; (80254c4 <__kernel_sinf+0xe0>)
 8025436:	f7db fbb3 	bl	8000ba0 <__aeabi_fsub>
 802543a:	4629      	mov	r1, r5
 802543c:	f7db fcba 	bl	8000db4 <__aeabi_fmul>
 8025440:	4921      	ldr	r1, [pc, #132]	; (80254c8 <__kernel_sinf+0xe4>)
 8025442:	f7db fbaf 	bl	8000ba4 <__addsf3>
 8025446:	4680      	mov	r8, r0
 8025448:	f1b9 0f00 	cmp.w	r9, #0
 802544c:	d111      	bne.n	8025472 <__kernel_sinf+0x8e>
 802544e:	4601      	mov	r1, r0
 8025450:	4628      	mov	r0, r5
 8025452:	f7db fcaf 	bl	8000db4 <__aeabi_fmul>
 8025456:	491d      	ldr	r1, [pc, #116]	; (80254cc <__kernel_sinf+0xe8>)
 8025458:	f7db fba2 	bl	8000ba0 <__aeabi_fsub>
 802545c:	4631      	mov	r1, r6
 802545e:	f7db fca9 	bl	8000db4 <__aeabi_fmul>
 8025462:	4601      	mov	r1, r0
 8025464:	4620      	mov	r0, r4
 8025466:	f7db fb9d 	bl	8000ba4 <__addsf3>
 802546a:	4604      	mov	r4, r0
 802546c:	4620      	mov	r0, r4
 802546e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025472:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8025476:	4638      	mov	r0, r7
 8025478:	f7db fc9c 	bl	8000db4 <__aeabi_fmul>
 802547c:	4641      	mov	r1, r8
 802547e:	4681      	mov	r9, r0
 8025480:	4630      	mov	r0, r6
 8025482:	f7db fc97 	bl	8000db4 <__aeabi_fmul>
 8025486:	4601      	mov	r1, r0
 8025488:	4648      	mov	r0, r9
 802548a:	f7db fb89 	bl	8000ba0 <__aeabi_fsub>
 802548e:	4629      	mov	r1, r5
 8025490:	f7db fc90 	bl	8000db4 <__aeabi_fmul>
 8025494:	4639      	mov	r1, r7
 8025496:	f7db fb83 	bl	8000ba0 <__aeabi_fsub>
 802549a:	490c      	ldr	r1, [pc, #48]	; (80254cc <__kernel_sinf+0xe8>)
 802549c:	4605      	mov	r5, r0
 802549e:	4630      	mov	r0, r6
 80254a0:	f7db fc88 	bl	8000db4 <__aeabi_fmul>
 80254a4:	4601      	mov	r1, r0
 80254a6:	4628      	mov	r0, r5
 80254a8:	f7db fb7c 	bl	8000ba4 <__addsf3>
 80254ac:	4601      	mov	r1, r0
 80254ae:	4620      	mov	r0, r4
 80254b0:	f7db fb76 	bl	8000ba0 <__aeabi_fsub>
 80254b4:	e7d9      	b.n	802546a <__kernel_sinf+0x86>
 80254b6:	bf00      	nop
 80254b8:	2f2ec9d3 	.word	0x2f2ec9d3
 80254bc:	32d72f34 	.word	0x32d72f34
 80254c0:	3638ef1b 	.word	0x3638ef1b
 80254c4:	39500d01 	.word	0x39500d01
 80254c8:	3c088889 	.word	0x3c088889
 80254cc:	3e2aaaab 	.word	0x3e2aaaab

080254d0 <__kernel_tanf>:
 80254d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80254d4:	f020 4a00 	bic.w	sl, r0, #2147483648	; 0x80000000
 80254d8:	f1ba 5f46 	cmp.w	sl, #830472192	; 0x31800000
 80254dc:	4604      	mov	r4, r0
 80254de:	460e      	mov	r6, r1
 80254e0:	4690      	mov	r8, r2
 80254e2:	4607      	mov	r7, r0
 80254e4:	da1a      	bge.n	802551c <__kernel_tanf+0x4c>
 80254e6:	f7db fe41 	bl	800116c <__aeabi_f2iz>
 80254ea:	bb70      	cbnz	r0, 802554a <__kernel_tanf+0x7a>
 80254ec:	f108 0301 	add.w	r3, r8, #1
 80254f0:	ea53 030a 	orrs.w	r3, r3, sl
 80254f4:	d10c      	bne.n	8025510 <__kernel_tanf+0x40>
 80254f6:	4620      	mov	r0, r4
 80254f8:	f000 fdda 	bl	80260b0 <fabsf>
 80254fc:	4601      	mov	r1, r0
 80254fe:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025502:	f7db fd0b 	bl	8000f1c <__aeabi_fdiv>
 8025506:	4604      	mov	r4, r0
 8025508:	4620      	mov	r0, r4
 802550a:	b003      	add	sp, #12
 802550c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025510:	f1b8 0f01 	cmp.w	r8, #1
 8025514:	d0f8      	beq.n	8025508 <__kernel_tanf+0x38>
 8025516:	4621      	mov	r1, r4
 8025518:	4871      	ldr	r0, [pc, #452]	; (80256e0 <__kernel_tanf+0x210>)
 802551a:	e7f2      	b.n	8025502 <__kernel_tanf+0x32>
 802551c:	4b71      	ldr	r3, [pc, #452]	; (80256e4 <__kernel_tanf+0x214>)
 802551e:	459a      	cmp	sl, r3
 8025520:	db13      	blt.n	802554a <__kernel_tanf+0x7a>
 8025522:	2800      	cmp	r0, #0
 8025524:	bfbc      	itt	lt
 8025526:	f100 4400 	addlt.w	r4, r0, #2147483648	; 0x80000000
 802552a:	f101 4600 	addlt.w	r6, r1, #2147483648	; 0x80000000
 802552e:	486e      	ldr	r0, [pc, #440]	; (80256e8 <__kernel_tanf+0x218>)
 8025530:	4621      	mov	r1, r4
 8025532:	f7db fb35 	bl	8000ba0 <__aeabi_fsub>
 8025536:	4604      	mov	r4, r0
 8025538:	4631      	mov	r1, r6
 802553a:	486c      	ldr	r0, [pc, #432]	; (80256ec <__kernel_tanf+0x21c>)
 802553c:	f7db fb30 	bl	8000ba0 <__aeabi_fsub>
 8025540:	4621      	mov	r1, r4
 8025542:	f7db fb2f 	bl	8000ba4 <__addsf3>
 8025546:	2600      	movs	r6, #0
 8025548:	4604      	mov	r4, r0
 802554a:	4621      	mov	r1, r4
 802554c:	4620      	mov	r0, r4
 802554e:	f7db fc31 	bl	8000db4 <__aeabi_fmul>
 8025552:	4601      	mov	r1, r0
 8025554:	4681      	mov	r9, r0
 8025556:	f7db fc2d 	bl	8000db4 <__aeabi_fmul>
 802555a:	4649      	mov	r1, r9
 802555c:	4605      	mov	r5, r0
 802555e:	4620      	mov	r0, r4
 8025560:	f7db fc28 	bl	8000db4 <__aeabi_fmul>
 8025564:	4962      	ldr	r1, [pc, #392]	; (80256f0 <__kernel_tanf+0x220>)
 8025566:	4683      	mov	fp, r0
 8025568:	4628      	mov	r0, r5
 802556a:	f7db fc23 	bl	8000db4 <__aeabi_fmul>
 802556e:	4961      	ldr	r1, [pc, #388]	; (80256f4 <__kernel_tanf+0x224>)
 8025570:	f7db fb18 	bl	8000ba4 <__addsf3>
 8025574:	4629      	mov	r1, r5
 8025576:	f7db fc1d 	bl	8000db4 <__aeabi_fmul>
 802557a:	495f      	ldr	r1, [pc, #380]	; (80256f8 <__kernel_tanf+0x228>)
 802557c:	f7db fb12 	bl	8000ba4 <__addsf3>
 8025580:	4629      	mov	r1, r5
 8025582:	f7db fc17 	bl	8000db4 <__aeabi_fmul>
 8025586:	495d      	ldr	r1, [pc, #372]	; (80256fc <__kernel_tanf+0x22c>)
 8025588:	f7db fb0c 	bl	8000ba4 <__addsf3>
 802558c:	4629      	mov	r1, r5
 802558e:	f7db fc11 	bl	8000db4 <__aeabi_fmul>
 8025592:	495b      	ldr	r1, [pc, #364]	; (8025700 <__kernel_tanf+0x230>)
 8025594:	f7db fb06 	bl	8000ba4 <__addsf3>
 8025598:	4629      	mov	r1, r5
 802559a:	f7db fc0b 	bl	8000db4 <__aeabi_fmul>
 802559e:	4959      	ldr	r1, [pc, #356]	; (8025704 <__kernel_tanf+0x234>)
 80255a0:	f7db fb00 	bl	8000ba4 <__addsf3>
 80255a4:	4649      	mov	r1, r9
 80255a6:	f7db fc05 	bl	8000db4 <__aeabi_fmul>
 80255aa:	4957      	ldr	r1, [pc, #348]	; (8025708 <__kernel_tanf+0x238>)
 80255ac:	9001      	str	r0, [sp, #4]
 80255ae:	4628      	mov	r0, r5
 80255b0:	f7db fc00 	bl	8000db4 <__aeabi_fmul>
 80255b4:	4955      	ldr	r1, [pc, #340]	; (802570c <__kernel_tanf+0x23c>)
 80255b6:	f7db faf5 	bl	8000ba4 <__addsf3>
 80255ba:	4629      	mov	r1, r5
 80255bc:	f7db fbfa 	bl	8000db4 <__aeabi_fmul>
 80255c0:	4953      	ldr	r1, [pc, #332]	; (8025710 <__kernel_tanf+0x240>)
 80255c2:	f7db faef 	bl	8000ba4 <__addsf3>
 80255c6:	4629      	mov	r1, r5
 80255c8:	f7db fbf4 	bl	8000db4 <__aeabi_fmul>
 80255cc:	4951      	ldr	r1, [pc, #324]	; (8025714 <__kernel_tanf+0x244>)
 80255ce:	f7db fae9 	bl	8000ba4 <__addsf3>
 80255d2:	4629      	mov	r1, r5
 80255d4:	f7db fbee 	bl	8000db4 <__aeabi_fmul>
 80255d8:	494f      	ldr	r1, [pc, #316]	; (8025718 <__kernel_tanf+0x248>)
 80255da:	f7db fae3 	bl	8000ba4 <__addsf3>
 80255de:	4629      	mov	r1, r5
 80255e0:	f7db fbe8 	bl	8000db4 <__aeabi_fmul>
 80255e4:	494d      	ldr	r1, [pc, #308]	; (802571c <__kernel_tanf+0x24c>)
 80255e6:	f7db fadd 	bl	8000ba4 <__addsf3>
 80255ea:	9b01      	ldr	r3, [sp, #4]
 80255ec:	4601      	mov	r1, r0
 80255ee:	4618      	mov	r0, r3
 80255f0:	f7db fad8 	bl	8000ba4 <__addsf3>
 80255f4:	4659      	mov	r1, fp
 80255f6:	f7db fbdd 	bl	8000db4 <__aeabi_fmul>
 80255fa:	4631      	mov	r1, r6
 80255fc:	f7db fad2 	bl	8000ba4 <__addsf3>
 8025600:	4649      	mov	r1, r9
 8025602:	f7db fbd7 	bl	8000db4 <__aeabi_fmul>
 8025606:	4631      	mov	r1, r6
 8025608:	f7db facc 	bl	8000ba4 <__addsf3>
 802560c:	4605      	mov	r5, r0
 802560e:	4944      	ldr	r1, [pc, #272]	; (8025720 <__kernel_tanf+0x250>)
 8025610:	4658      	mov	r0, fp
 8025612:	f7db fbcf 	bl	8000db4 <__aeabi_fmul>
 8025616:	4629      	mov	r1, r5
 8025618:	f7db fac4 	bl	8000ba4 <__addsf3>
 802561c:	4601      	mov	r1, r0
 802561e:	4681      	mov	r9, r0
 8025620:	4620      	mov	r0, r4
 8025622:	f7db fabf 	bl	8000ba4 <__addsf3>
 8025626:	4b2f      	ldr	r3, [pc, #188]	; (80256e4 <__kernel_tanf+0x214>)
 8025628:	4605      	mov	r5, r0
 802562a:	459a      	cmp	sl, r3
 802562c:	db2b      	blt.n	8025686 <__kernel_tanf+0x1b6>
 802562e:	4640      	mov	r0, r8
 8025630:	f7db fb6c 	bl	8000d0c <__aeabi_i2f>
 8025634:	4629      	mov	r1, r5
 8025636:	4606      	mov	r6, r0
 8025638:	4628      	mov	r0, r5
 802563a:	f7db fbbb 	bl	8000db4 <__aeabi_fmul>
 802563e:	4631      	mov	r1, r6
 8025640:	4680      	mov	r8, r0
 8025642:	4628      	mov	r0, r5
 8025644:	f7db faae 	bl	8000ba4 <__addsf3>
 8025648:	4601      	mov	r1, r0
 802564a:	4640      	mov	r0, r8
 802564c:	f7db fc66 	bl	8000f1c <__aeabi_fdiv>
 8025650:	4649      	mov	r1, r9
 8025652:	f7db faa5 	bl	8000ba0 <__aeabi_fsub>
 8025656:	4601      	mov	r1, r0
 8025658:	4620      	mov	r0, r4
 802565a:	f7db faa1 	bl	8000ba0 <__aeabi_fsub>
 802565e:	4601      	mov	r1, r0
 8025660:	f7db faa0 	bl	8000ba4 <__addsf3>
 8025664:	4601      	mov	r1, r0
 8025666:	4630      	mov	r0, r6
 8025668:	f7db fa9a 	bl	8000ba0 <__aeabi_fsub>
 802566c:	17bf      	asrs	r7, r7, #30
 802566e:	f007 0702 	and.w	r7, r7, #2
 8025672:	4604      	mov	r4, r0
 8025674:	f1c7 0001 	rsb	r0, r7, #1
 8025678:	f7db fb48 	bl	8000d0c <__aeabi_i2f>
 802567c:	4601      	mov	r1, r0
 802567e:	4620      	mov	r0, r4
 8025680:	f7db fb98 	bl	8000db4 <__aeabi_fmul>
 8025684:	e73f      	b.n	8025506 <__kernel_tanf+0x36>
 8025686:	f1b8 0f01 	cmp.w	r8, #1
 802568a:	d027      	beq.n	80256dc <__kernel_tanf+0x20c>
 802568c:	4e25      	ldr	r6, [pc, #148]	; (8025724 <__kernel_tanf+0x254>)
 802568e:	4601      	mov	r1, r0
 8025690:	ea06 0800 	and.w	r8, r6, r0
 8025694:	4812      	ldr	r0, [pc, #72]	; (80256e0 <__kernel_tanf+0x210>)
 8025696:	f7db fc41 	bl	8000f1c <__aeabi_fdiv>
 802569a:	4621      	mov	r1, r4
 802569c:	4006      	ands	r6, r0
 802569e:	4607      	mov	r7, r0
 80256a0:	4640      	mov	r0, r8
 80256a2:	f7db fa7d 	bl	8000ba0 <__aeabi_fsub>
 80256a6:	4601      	mov	r1, r0
 80256a8:	4648      	mov	r0, r9
 80256aa:	f7db fa79 	bl	8000ba0 <__aeabi_fsub>
 80256ae:	4631      	mov	r1, r6
 80256b0:	f7db fb80 	bl	8000db4 <__aeabi_fmul>
 80256b4:	4631      	mov	r1, r6
 80256b6:	4604      	mov	r4, r0
 80256b8:	4640      	mov	r0, r8
 80256ba:	f7db fb7b 	bl	8000db4 <__aeabi_fmul>
 80256be:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80256c2:	f7db fa6f 	bl	8000ba4 <__addsf3>
 80256c6:	4601      	mov	r1, r0
 80256c8:	4620      	mov	r0, r4
 80256ca:	f7db fa6b 	bl	8000ba4 <__addsf3>
 80256ce:	4639      	mov	r1, r7
 80256d0:	f7db fb70 	bl	8000db4 <__aeabi_fmul>
 80256d4:	4631      	mov	r1, r6
 80256d6:	f7db fa65 	bl	8000ba4 <__addsf3>
 80256da:	e714      	b.n	8025506 <__kernel_tanf+0x36>
 80256dc:	4604      	mov	r4, r0
 80256de:	e713      	b.n	8025508 <__kernel_tanf+0x38>
 80256e0:	bf800000 	.word	0xbf800000
 80256e4:	3f2ca140 	.word	0x3f2ca140
 80256e8:	3f490fda 	.word	0x3f490fda
 80256ec:	33222168 	.word	0x33222168
 80256f0:	37d95384 	.word	0x37d95384
 80256f4:	3895c07a 	.word	0x3895c07a
 80256f8:	398137b9 	.word	0x398137b9
 80256fc:	3abede48 	.word	0x3abede48
 8025700:	3c11371f 	.word	0x3c11371f
 8025704:	3d5d0dd1 	.word	0x3d5d0dd1
 8025708:	b79bae5f 	.word	0xb79bae5f
 802570c:	38a3f445 	.word	0x38a3f445
 8025710:	3a1a26c8 	.word	0x3a1a26c8
 8025714:	3b6b6916 	.word	0x3b6b6916
 8025718:	3cb327a4 	.word	0x3cb327a4
 802571c:	3e088889 	.word	0x3e088889
 8025720:	3eaaaaab 	.word	0x3eaaaaab
 8025724:	fffff000 	.word	0xfffff000

08025728 <__ieee754_powf>:
 8025728:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802572c:	f031 4a00 	bics.w	sl, r1, #2147483648	; 0x80000000
 8025730:	4681      	mov	r9, r0
 8025732:	460f      	mov	r7, r1
 8025734:	4680      	mov	r8, r0
 8025736:	460c      	mov	r4, r1
 8025738:	b087      	sub	sp, #28
 802573a:	d10d      	bne.n	8025758 <__ieee754_powf+0x30>
 802573c:	f480 0880 	eor.w	r8, r0, #4194304	; 0x400000
 8025740:	ea4f 0848 	mov.w	r8, r8, lsl #1
 8025744:	f518 0f00 	cmn.w	r8, #8388608	; 0x800000
 8025748:	f240 8336 	bls.w	8025db8 <__ieee754_powf+0x690>
 802574c:	4639      	mov	r1, r7
 802574e:	4648      	mov	r0, r9
 8025750:	f7db fa28 	bl	8000ba4 <__addsf3>
 8025754:	4601      	mov	r1, r0
 8025756:	e040      	b.n	80257da <__ieee754_powf+0xb2>
 8025758:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 802575c:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8025760:	dcf4      	bgt.n	802574c <__ieee754_powf+0x24>
 8025762:	f1ba 4fff 	cmp.w	sl, #2139095040	; 0x7f800000
 8025766:	dd08      	ble.n	802577a <__ieee754_powf+0x52>
 8025768:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 802576c:	d1ee      	bne.n	802574c <__ieee754_powf+0x24>
 802576e:	f481 0480 	eor.w	r4, r1, #4194304	; 0x400000
 8025772:	0064      	lsls	r4, r4, #1
 8025774:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 8025778:	e7e6      	b.n	8025748 <__ieee754_powf+0x20>
 802577a:	2800      	cmp	r0, #0
 802577c:	da20      	bge.n	80257c0 <__ieee754_powf+0x98>
 802577e:	f1ba 4f97 	cmp.w	sl, #1266679808	; 0x4b800000
 8025782:	da2e      	bge.n	80257e2 <__ieee754_powf+0xba>
 8025784:	f1ba 5f7e 	cmp.w	sl, #1065353216	; 0x3f800000
 8025788:	f2c0 831b 	blt.w	8025dc2 <__ieee754_powf+0x69a>
 802578c:	ea4f 53ea 	mov.w	r3, sl, asr #23
 8025790:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 8025794:	fa4a f503 	asr.w	r5, sl, r3
 8025798:	fa05 f303 	lsl.w	r3, r5, r3
 802579c:	4553      	cmp	r3, sl
 802579e:	f040 8310 	bne.w	8025dc2 <__ieee754_powf+0x69a>
 80257a2:	f005 0501 	and.w	r5, r5, #1
 80257a6:	f1c5 0502 	rsb	r5, r5, #2
 80257aa:	f1ba 5f7e 	cmp.w	sl, #1065353216	; 0x3f800000
 80257ae:	d120      	bne.n	80257f2 <__ieee754_powf+0xca>
 80257b0:	2c00      	cmp	r4, #0
 80257b2:	4649      	mov	r1, r9
 80257b4:	da11      	bge.n	80257da <__ieee754_powf+0xb2>
 80257b6:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80257ba:	f7db fbaf 	bl	8000f1c <__aeabi_fdiv>
 80257be:	e7c9      	b.n	8025754 <__ieee754_powf+0x2c>
 80257c0:	2500      	movs	r5, #0
 80257c2:	f1ba 4fff 	cmp.w	sl, #2139095040	; 0x7f800000
 80257c6:	d1f0      	bne.n	80257aa <__ieee754_powf+0x82>
 80257c8:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 80257cc:	f000 82f4 	beq.w	8025db8 <__ieee754_powf+0x690>
 80257d0:	dd09      	ble.n	80257e6 <__ieee754_powf+0xbe>
 80257d2:	2c00      	cmp	r4, #0
 80257d4:	f2c0 82f3 	blt.w	8025dbe <__ieee754_powf+0x696>
 80257d8:	4639      	mov	r1, r7
 80257da:	4608      	mov	r0, r1
 80257dc:	b007      	add	sp, #28
 80257de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80257e2:	2502      	movs	r5, #2
 80257e4:	e7ed      	b.n	80257c2 <__ieee754_powf+0x9a>
 80257e6:	2c00      	cmp	r4, #0
 80257e8:	f280 82e9 	bge.w	8025dbe <__ieee754_powf+0x696>
 80257ec:	f107 4100 	add.w	r1, r7, #2147483648	; 0x80000000
 80257f0:	e7f3      	b.n	80257da <__ieee754_powf+0xb2>
 80257f2:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 80257f6:	d104      	bne.n	8025802 <__ieee754_powf+0xda>
 80257f8:	4649      	mov	r1, r9
 80257fa:	4648      	mov	r0, r9
 80257fc:	f7db fada 	bl	8000db4 <__aeabi_fmul>
 8025800:	e7a8      	b.n	8025754 <__ieee754_powf+0x2c>
 8025802:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 8025806:	4648      	mov	r0, r9
 8025808:	d107      	bne.n	802581a <__ieee754_powf+0xf2>
 802580a:	f1b8 0f00 	cmp.w	r8, #0
 802580e:	db04      	blt.n	802581a <__ieee754_powf+0xf2>
 8025810:	b007      	add	sp, #28
 8025812:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025816:	f7ff b9d9 	b.w	8024bcc <__ieee754_sqrtf>
 802581a:	f000 fc49 	bl	80260b0 <fabsf>
 802581e:	4601      	mov	r1, r0
 8025820:	b126      	cbz	r6, 802582c <__ieee754_powf+0x104>
 8025822:	f028 4340 	bic.w	r3, r8, #3221225472	; 0xc0000000
 8025826:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802582a:	d117      	bne.n	802585c <__ieee754_powf+0x134>
 802582c:	2c00      	cmp	r4, #0
 802582e:	da04      	bge.n	802583a <__ieee754_powf+0x112>
 8025830:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025834:	f7db fb72 	bl	8000f1c <__aeabi_fdiv>
 8025838:	4601      	mov	r1, r0
 802583a:	f1b8 0f00 	cmp.w	r8, #0
 802583e:	dacc      	bge.n	80257da <__ieee754_powf+0xb2>
 8025840:	f1a6 567e 	sub.w	r6, r6, #1065353216	; 0x3f800000
 8025844:	432e      	orrs	r6, r5
 8025846:	d104      	bne.n	8025852 <__ieee754_powf+0x12a>
 8025848:	4608      	mov	r0, r1
 802584a:	f7db f9a9 	bl	8000ba0 <__aeabi_fsub>
 802584e:	4601      	mov	r1, r0
 8025850:	e7b3      	b.n	80257ba <__ieee754_powf+0x92>
 8025852:	2d01      	cmp	r5, #1
 8025854:	d1c1      	bne.n	80257da <__ieee754_powf+0xb2>
 8025856:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 802585a:	e77b      	b.n	8025754 <__ieee754_powf+0x2c>
 802585c:	ea4f 73d8 	mov.w	r3, r8, lsr #31
 8025860:	3b01      	subs	r3, #1
 8025862:	9302      	str	r3, [sp, #8]
 8025864:	432b      	orrs	r3, r5
 8025866:	d101      	bne.n	802586c <__ieee754_powf+0x144>
 8025868:	4649      	mov	r1, r9
 802586a:	e7ed      	b.n	8025848 <__ieee754_powf+0x120>
 802586c:	f1ba 4f9a 	cmp.w	sl, #1291845632	; 0x4d000000
 8025870:	f340 809e 	ble.w	80259b0 <__ieee754_powf+0x288>
 8025874:	4b47      	ldr	r3, [pc, #284]	; (8025994 <__ieee754_powf+0x26c>)
 8025876:	429e      	cmp	r6, r3
 8025878:	dc07      	bgt.n	802588a <__ieee754_powf+0x162>
 802587a:	2c00      	cmp	r4, #0
 802587c:	da0a      	bge.n	8025894 <__ieee754_powf+0x16c>
 802587e:	2000      	movs	r0, #0
 8025880:	b007      	add	sp, #28
 8025882:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025886:	f000 bc7c 	b.w	8026182 <__math_oflowf>
 802588a:	4b43      	ldr	r3, [pc, #268]	; (8025998 <__ieee754_powf+0x270>)
 802588c:	429e      	cmp	r6, r3
 802588e:	dd07      	ble.n	80258a0 <__ieee754_powf+0x178>
 8025890:	2c00      	cmp	r4, #0
 8025892:	dcf4      	bgt.n	802587e <__ieee754_powf+0x156>
 8025894:	2000      	movs	r0, #0
 8025896:	b007      	add	sp, #28
 8025898:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802589c:	f000 bc6d 	b.w	802617a <__math_uflowf>
 80258a0:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80258a4:	f7db f97c 	bl	8000ba0 <__aeabi_fsub>
 80258a8:	493c      	ldr	r1, [pc, #240]	; (802599c <__ieee754_powf+0x274>)
 80258aa:	4606      	mov	r6, r0
 80258ac:	f7db fa82 	bl	8000db4 <__aeabi_fmul>
 80258b0:	493b      	ldr	r1, [pc, #236]	; (80259a0 <__ieee754_powf+0x278>)
 80258b2:	4680      	mov	r8, r0
 80258b4:	4630      	mov	r0, r6
 80258b6:	f7db fa7d 	bl	8000db4 <__aeabi_fmul>
 80258ba:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
 80258be:	4681      	mov	r9, r0
 80258c0:	4630      	mov	r0, r6
 80258c2:	f7db fa77 	bl	8000db4 <__aeabi_fmul>
 80258c6:	4601      	mov	r1, r0
 80258c8:	4836      	ldr	r0, [pc, #216]	; (80259a4 <__ieee754_powf+0x27c>)
 80258ca:	f7db f969 	bl	8000ba0 <__aeabi_fsub>
 80258ce:	4631      	mov	r1, r6
 80258d0:	f7db fa70 	bl	8000db4 <__aeabi_fmul>
 80258d4:	4601      	mov	r1, r0
 80258d6:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
 80258da:	f7db f961 	bl	8000ba0 <__aeabi_fsub>
 80258de:	4631      	mov	r1, r6
 80258e0:	4682      	mov	sl, r0
 80258e2:	4630      	mov	r0, r6
 80258e4:	f7db fa66 	bl	8000db4 <__aeabi_fmul>
 80258e8:	4601      	mov	r1, r0
 80258ea:	4650      	mov	r0, sl
 80258ec:	f7db fa62 	bl	8000db4 <__aeabi_fmul>
 80258f0:	492d      	ldr	r1, [pc, #180]	; (80259a8 <__ieee754_powf+0x280>)
 80258f2:	f7db fa5f 	bl	8000db4 <__aeabi_fmul>
 80258f6:	4601      	mov	r1, r0
 80258f8:	4648      	mov	r0, r9
 80258fa:	f7db f951 	bl	8000ba0 <__aeabi_fsub>
 80258fe:	4601      	mov	r1, r0
 8025900:	4606      	mov	r6, r0
 8025902:	4640      	mov	r0, r8
 8025904:	f7db f94e 	bl	8000ba4 <__addsf3>
 8025908:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 802590c:	f029 090f 	bic.w	r9, r9, #15
 8025910:	4641      	mov	r1, r8
 8025912:	4648      	mov	r0, r9
 8025914:	f7db f944 	bl	8000ba0 <__aeabi_fsub>
 8025918:	4601      	mov	r1, r0
 802591a:	4630      	mov	r0, r6
 802591c:	f7db f940 	bl	8000ba0 <__aeabi_fsub>
 8025920:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 8025924:	9b02      	ldr	r3, [sp, #8]
 8025926:	3d01      	subs	r5, #1
 8025928:	f024 040f 	bic.w	r4, r4, #15
 802592c:	431d      	orrs	r5, r3
 802592e:	4606      	mov	r6, r0
 8025930:	4621      	mov	r1, r4
 8025932:	4638      	mov	r0, r7
 8025934:	bf14      	ite	ne
 8025936:	f04f 557e 	movne.w	r5, #1065353216	; 0x3f800000
 802593a:	4d1c      	ldreq	r5, [pc, #112]	; (80259ac <__ieee754_powf+0x284>)
 802593c:	f7db f930 	bl	8000ba0 <__aeabi_fsub>
 8025940:	4649      	mov	r1, r9
 8025942:	f7db fa37 	bl	8000db4 <__aeabi_fmul>
 8025946:	4639      	mov	r1, r7
 8025948:	4680      	mov	r8, r0
 802594a:	4630      	mov	r0, r6
 802594c:	f7db fa32 	bl	8000db4 <__aeabi_fmul>
 8025950:	4601      	mov	r1, r0
 8025952:	4640      	mov	r0, r8
 8025954:	f7db f926 	bl	8000ba4 <__addsf3>
 8025958:	4621      	mov	r1, r4
 802595a:	4606      	mov	r6, r0
 802595c:	4648      	mov	r0, r9
 802595e:	f7db fa29 	bl	8000db4 <__aeabi_fmul>
 8025962:	4601      	mov	r1, r0
 8025964:	4607      	mov	r7, r0
 8025966:	4681      	mov	r9, r0
 8025968:	4630      	mov	r0, r6
 802596a:	f7db f91b 	bl	8000ba4 <__addsf3>
 802596e:	2800      	cmp	r0, #0
 8025970:	4682      	mov	sl, r0
 8025972:	4680      	mov	r8, r0
 8025974:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8025978:	f340 8200 	ble.w	8025d7c <__ieee754_powf+0x654>
 802597c:	f1b4 4f86 	cmp.w	r4, #1124073472	; 0x43000000
 8025980:	f340 814e 	ble.w	8025c20 <__ieee754_powf+0x4f8>
 8025984:	2100      	movs	r1, #0
 8025986:	4628      	mov	r0, r5
 8025988:	f7db fbb2 	bl	80010f0 <__aeabi_fcmplt>
 802598c:	3800      	subs	r0, #0
 802598e:	bf18      	it	ne
 8025990:	2001      	movne	r0, #1
 8025992:	e775      	b.n	8025880 <__ieee754_powf+0x158>
 8025994:	3f7ffff3 	.word	0x3f7ffff3
 8025998:	3f800007 	.word	0x3f800007
 802599c:	3fb8aa00 	.word	0x3fb8aa00
 80259a0:	36eca570 	.word	0x36eca570
 80259a4:	3eaaaaab 	.word	0x3eaaaaab
 80259a8:	3fb8aa3b 	.word	0x3fb8aa3b
 80259ac:	bf800000 	.word	0xbf800000
 80259b0:	f018 4fff 	tst.w	r8, #2139095040	; 0x7f800000
 80259b4:	f040 8111 	bne.w	8025bda <__ieee754_powf+0x4b2>
 80259b8:	f04f 4197 	mov.w	r1, #1266679808	; 0x4b800000
 80259bc:	f7db f9fa 	bl	8000db4 <__aeabi_fmul>
 80259c0:	f06f 0217 	mvn.w	r2, #23
 80259c4:	4606      	mov	r6, r0
 80259c6:	15f3      	asrs	r3, r6, #23
 80259c8:	3b7f      	subs	r3, #127	; 0x7f
 80259ca:	4413      	add	r3, r2
 80259cc:	4a85      	ldr	r2, [pc, #532]	; (8025be4 <__ieee754_powf+0x4bc>)
 80259ce:	9301      	str	r3, [sp, #4]
 80259d0:	f3c6 0316 	ubfx	r3, r6, #0, #23
 80259d4:	4293      	cmp	r3, r2
 80259d6:	f043 567e 	orr.w	r6, r3, #1065353216	; 0x3f800000
 80259da:	dd08      	ble.n	80259ee <__ieee754_powf+0x2c6>
 80259dc:	4a82      	ldr	r2, [pc, #520]	; (8025be8 <__ieee754_powf+0x4c0>)
 80259de:	4293      	cmp	r3, r2
 80259e0:	f340 80fd 	ble.w	8025bde <__ieee754_powf+0x4b6>
 80259e4:	9b01      	ldr	r3, [sp, #4]
 80259e6:	f5a6 0600 	sub.w	r6, r6, #8388608	; 0x800000
 80259ea:	3301      	adds	r3, #1
 80259ec:	9301      	str	r3, [sp, #4]
 80259ee:	2300      	movs	r3, #0
 80259f0:	9300      	str	r3, [sp, #0]
 80259f2:	9900      	ldr	r1, [sp, #0]
 80259f4:	4a7d      	ldr	r2, [pc, #500]	; (8025bec <__ieee754_powf+0x4c4>)
 80259f6:	4630      	mov	r0, r6
 80259f8:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80259fc:	9603      	str	r6, [sp, #12]
 80259fe:	4611      	mov	r1, r2
 8025a00:	9205      	str	r2, [sp, #20]
 8025a02:	f7db f8cd 	bl	8000ba0 <__aeabi_fsub>
 8025a06:	9a05      	ldr	r2, [sp, #20]
 8025a08:	9b03      	ldr	r3, [sp, #12]
 8025a0a:	4683      	mov	fp, r0
 8025a0c:	4619      	mov	r1, r3
 8025a0e:	4610      	mov	r0, r2
 8025a10:	9203      	str	r2, [sp, #12]
 8025a12:	9304      	str	r3, [sp, #16]
 8025a14:	f7db f8c6 	bl	8000ba4 <__addsf3>
 8025a18:	4601      	mov	r1, r0
 8025a1a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025a1e:	f7db fa7d 	bl	8000f1c <__aeabi_fdiv>
 8025a22:	4682      	mov	sl, r0
 8025a24:	4601      	mov	r1, r0
 8025a26:	4658      	mov	r0, fp
 8025a28:	f7db f9c4 	bl	8000db4 <__aeabi_fmul>
 8025a2c:	1076      	asrs	r6, r6, #1
 8025a2e:	9b00      	ldr	r3, [sp, #0]
 8025a30:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
 8025a34:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 8025a38:	f506 2680 	add.w	r6, r6, #262144	; 0x40000
 8025a3c:	f029 090f 	bic.w	r9, r9, #15
 8025a40:	eb06 5643 	add.w	r6, r6, r3, lsl #21
 8025a44:	4680      	mov	r8, r0
 8025a46:	4631      	mov	r1, r6
 8025a48:	4648      	mov	r0, r9
 8025a4a:	f7db f9b3 	bl	8000db4 <__aeabi_fmul>
 8025a4e:	4601      	mov	r1, r0
 8025a50:	4658      	mov	r0, fp
 8025a52:	f7db f8a5 	bl	8000ba0 <__aeabi_fsub>
 8025a56:	9a03      	ldr	r2, [sp, #12]
 8025a58:	4683      	mov	fp, r0
 8025a5a:	4611      	mov	r1, r2
 8025a5c:	4630      	mov	r0, r6
 8025a5e:	f7db f89f 	bl	8000ba0 <__aeabi_fsub>
 8025a62:	9b04      	ldr	r3, [sp, #16]
 8025a64:	4601      	mov	r1, r0
 8025a66:	4618      	mov	r0, r3
 8025a68:	f7db f89a 	bl	8000ba0 <__aeabi_fsub>
 8025a6c:	4649      	mov	r1, r9
 8025a6e:	f7db f9a1 	bl	8000db4 <__aeabi_fmul>
 8025a72:	4601      	mov	r1, r0
 8025a74:	4658      	mov	r0, fp
 8025a76:	f7db f893 	bl	8000ba0 <__aeabi_fsub>
 8025a7a:	4651      	mov	r1, sl
 8025a7c:	f7db f99a 	bl	8000db4 <__aeabi_fmul>
 8025a80:	4641      	mov	r1, r8
 8025a82:	4682      	mov	sl, r0
 8025a84:	4640      	mov	r0, r8
 8025a86:	f7db f995 	bl	8000db4 <__aeabi_fmul>
 8025a8a:	4606      	mov	r6, r0
 8025a8c:	4958      	ldr	r1, [pc, #352]	; (8025bf0 <__ieee754_powf+0x4c8>)
 8025a8e:	f7db f991 	bl	8000db4 <__aeabi_fmul>
 8025a92:	4958      	ldr	r1, [pc, #352]	; (8025bf4 <__ieee754_powf+0x4cc>)
 8025a94:	f7db f886 	bl	8000ba4 <__addsf3>
 8025a98:	4631      	mov	r1, r6
 8025a9a:	f7db f98b 	bl	8000db4 <__aeabi_fmul>
 8025a9e:	4956      	ldr	r1, [pc, #344]	; (8025bf8 <__ieee754_powf+0x4d0>)
 8025aa0:	f7db f880 	bl	8000ba4 <__addsf3>
 8025aa4:	4631      	mov	r1, r6
 8025aa6:	f7db f985 	bl	8000db4 <__aeabi_fmul>
 8025aaa:	4954      	ldr	r1, [pc, #336]	; (8025bfc <__ieee754_powf+0x4d4>)
 8025aac:	f7db f87a 	bl	8000ba4 <__addsf3>
 8025ab0:	4631      	mov	r1, r6
 8025ab2:	f7db f97f 	bl	8000db4 <__aeabi_fmul>
 8025ab6:	4952      	ldr	r1, [pc, #328]	; (8025c00 <__ieee754_powf+0x4d8>)
 8025ab8:	f7db f874 	bl	8000ba4 <__addsf3>
 8025abc:	4631      	mov	r1, r6
 8025abe:	f7db f979 	bl	8000db4 <__aeabi_fmul>
 8025ac2:	4950      	ldr	r1, [pc, #320]	; (8025c04 <__ieee754_powf+0x4dc>)
 8025ac4:	f7db f86e 	bl	8000ba4 <__addsf3>
 8025ac8:	4631      	mov	r1, r6
 8025aca:	4683      	mov	fp, r0
 8025acc:	4630      	mov	r0, r6
 8025ace:	f7db f971 	bl	8000db4 <__aeabi_fmul>
 8025ad2:	4601      	mov	r1, r0
 8025ad4:	4658      	mov	r0, fp
 8025ad6:	f7db f96d 	bl	8000db4 <__aeabi_fmul>
 8025ada:	4606      	mov	r6, r0
 8025adc:	4649      	mov	r1, r9
 8025ade:	4640      	mov	r0, r8
 8025ae0:	f7db f860 	bl	8000ba4 <__addsf3>
 8025ae4:	4651      	mov	r1, sl
 8025ae6:	f7db f965 	bl	8000db4 <__aeabi_fmul>
 8025aea:	4631      	mov	r1, r6
 8025aec:	f7db f85a 	bl	8000ba4 <__addsf3>
 8025af0:	4649      	mov	r1, r9
 8025af2:	4683      	mov	fp, r0
 8025af4:	4648      	mov	r0, r9
 8025af6:	f7db f95d 	bl	8000db4 <__aeabi_fmul>
 8025afa:	4943      	ldr	r1, [pc, #268]	; (8025c08 <__ieee754_powf+0x4e0>)
 8025afc:	9003      	str	r0, [sp, #12]
 8025afe:	f7db f851 	bl	8000ba4 <__addsf3>
 8025b02:	4659      	mov	r1, fp
 8025b04:	f7db f84e 	bl	8000ba4 <__addsf3>
 8025b08:	f420 667f 	bic.w	r6, r0, #4080	; 0xff0
 8025b0c:	f026 060f 	bic.w	r6, r6, #15
 8025b10:	4631      	mov	r1, r6
 8025b12:	4648      	mov	r0, r9
 8025b14:	f7db f94e 	bl	8000db4 <__aeabi_fmul>
 8025b18:	493b      	ldr	r1, [pc, #236]	; (8025c08 <__ieee754_powf+0x4e0>)
 8025b1a:	4681      	mov	r9, r0
 8025b1c:	4630      	mov	r0, r6
 8025b1e:	f7db f83f 	bl	8000ba0 <__aeabi_fsub>
 8025b22:	9b03      	ldr	r3, [sp, #12]
 8025b24:	4619      	mov	r1, r3
 8025b26:	f7db f83b 	bl	8000ba0 <__aeabi_fsub>
 8025b2a:	4601      	mov	r1, r0
 8025b2c:	4658      	mov	r0, fp
 8025b2e:	f7db f837 	bl	8000ba0 <__aeabi_fsub>
 8025b32:	4641      	mov	r1, r8
 8025b34:	f7db f93e 	bl	8000db4 <__aeabi_fmul>
 8025b38:	4631      	mov	r1, r6
 8025b3a:	4680      	mov	r8, r0
 8025b3c:	4650      	mov	r0, sl
 8025b3e:	f7db f939 	bl	8000db4 <__aeabi_fmul>
 8025b42:	4601      	mov	r1, r0
 8025b44:	4640      	mov	r0, r8
 8025b46:	f7db f82d 	bl	8000ba4 <__addsf3>
 8025b4a:	4682      	mov	sl, r0
 8025b4c:	4601      	mov	r1, r0
 8025b4e:	4648      	mov	r0, r9
 8025b50:	f7db f828 	bl	8000ba4 <__addsf3>
 8025b54:	f420 667f 	bic.w	r6, r0, #4080	; 0xff0
 8025b58:	f026 060f 	bic.w	r6, r6, #15
 8025b5c:	4630      	mov	r0, r6
 8025b5e:	492b      	ldr	r1, [pc, #172]	; (8025c0c <__ieee754_powf+0x4e4>)
 8025b60:	f7db f928 	bl	8000db4 <__aeabi_fmul>
 8025b64:	4649      	mov	r1, r9
 8025b66:	4680      	mov	r8, r0
 8025b68:	4630      	mov	r0, r6
 8025b6a:	f7db f819 	bl	8000ba0 <__aeabi_fsub>
 8025b6e:	4601      	mov	r1, r0
 8025b70:	4650      	mov	r0, sl
 8025b72:	f7db f815 	bl	8000ba0 <__aeabi_fsub>
 8025b76:	4926      	ldr	r1, [pc, #152]	; (8025c10 <__ieee754_powf+0x4e8>)
 8025b78:	f7db f91c 	bl	8000db4 <__aeabi_fmul>
 8025b7c:	4925      	ldr	r1, [pc, #148]	; (8025c14 <__ieee754_powf+0x4ec>)
 8025b7e:	4681      	mov	r9, r0
 8025b80:	4630      	mov	r0, r6
 8025b82:	f7db f917 	bl	8000db4 <__aeabi_fmul>
 8025b86:	4601      	mov	r1, r0
 8025b88:	4648      	mov	r0, r9
 8025b8a:	f7db f80b 	bl	8000ba4 <__addsf3>
 8025b8e:	4b22      	ldr	r3, [pc, #136]	; (8025c18 <__ieee754_powf+0x4f0>)
 8025b90:	9a00      	ldr	r2, [sp, #0]
 8025b92:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8025b96:	f7db f805 	bl	8000ba4 <__addsf3>
 8025b9a:	4606      	mov	r6, r0
 8025b9c:	9801      	ldr	r0, [sp, #4]
 8025b9e:	f7db f8b5 	bl	8000d0c <__aeabi_i2f>
 8025ba2:	4682      	mov	sl, r0
 8025ba4:	4b1d      	ldr	r3, [pc, #116]	; (8025c1c <__ieee754_powf+0x4f4>)
 8025ba6:	9a00      	ldr	r2, [sp, #0]
 8025ba8:	4631      	mov	r1, r6
 8025baa:	f853 b022 	ldr.w	fp, [r3, r2, lsl #2]
 8025bae:	4640      	mov	r0, r8
 8025bb0:	f7da fff8 	bl	8000ba4 <__addsf3>
 8025bb4:	4659      	mov	r1, fp
 8025bb6:	f7da fff5 	bl	8000ba4 <__addsf3>
 8025bba:	4651      	mov	r1, sl
 8025bbc:	f7da fff2 	bl	8000ba4 <__addsf3>
 8025bc0:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 8025bc4:	f029 090f 	bic.w	r9, r9, #15
 8025bc8:	4651      	mov	r1, sl
 8025bca:	4648      	mov	r0, r9
 8025bcc:	f7da ffe8 	bl	8000ba0 <__aeabi_fsub>
 8025bd0:	4659      	mov	r1, fp
 8025bd2:	f7da ffe5 	bl	8000ba0 <__aeabi_fsub>
 8025bd6:	4641      	mov	r1, r8
 8025bd8:	e69c      	b.n	8025914 <__ieee754_powf+0x1ec>
 8025bda:	2200      	movs	r2, #0
 8025bdc:	e6f3      	b.n	80259c6 <__ieee754_powf+0x29e>
 8025bde:	2301      	movs	r3, #1
 8025be0:	e706      	b.n	80259f0 <__ieee754_powf+0x2c8>
 8025be2:	bf00      	nop
 8025be4:	001cc471 	.word	0x001cc471
 8025be8:	005db3d6 	.word	0x005db3d6
 8025bec:	08033048 	.word	0x08033048
 8025bf0:	3e53f142 	.word	0x3e53f142
 8025bf4:	3e6c3255 	.word	0x3e6c3255
 8025bf8:	3e8ba305 	.word	0x3e8ba305
 8025bfc:	3eaaaaab 	.word	0x3eaaaaab
 8025c00:	3edb6db7 	.word	0x3edb6db7
 8025c04:	3f19999a 	.word	0x3f19999a
 8025c08:	40400000 	.word	0x40400000
 8025c0c:	3f763800 	.word	0x3f763800
 8025c10:	3f76384f 	.word	0x3f76384f
 8025c14:	369dc3a0 	.word	0x369dc3a0
 8025c18:	08033058 	.word	0x08033058
 8025c1c:	08033050 	.word	0x08033050
 8025c20:	f040 80c2 	bne.w	8025da8 <__ieee754_powf+0x680>
 8025c24:	4968      	ldr	r1, [pc, #416]	; (8025dc8 <__ieee754_powf+0x6a0>)
 8025c26:	4630      	mov	r0, r6
 8025c28:	f7da ffbc 	bl	8000ba4 <__addsf3>
 8025c2c:	4639      	mov	r1, r7
 8025c2e:	4681      	mov	r9, r0
 8025c30:	4650      	mov	r0, sl
 8025c32:	f7da ffb5 	bl	8000ba0 <__aeabi_fsub>
 8025c36:	4601      	mov	r1, r0
 8025c38:	4648      	mov	r0, r9
 8025c3a:	f7db fa77 	bl	800112c <__aeabi_fcmpgt>
 8025c3e:	2800      	cmp	r0, #0
 8025c40:	f47f aea0 	bne.w	8025984 <__ieee754_powf+0x25c>
 8025c44:	15e4      	asrs	r4, r4, #23
 8025c46:	f1a4 037e 	sub.w	r3, r4, #126	; 0x7e
 8025c4a:	f44f 0400 	mov.w	r4, #8388608	; 0x800000
 8025c4e:	411c      	asrs	r4, r3
 8025c50:	4444      	add	r4, r8
 8025c52:	f3c4 53c7 	ubfx	r3, r4, #23, #8
 8025c56:	495d      	ldr	r1, [pc, #372]	; (8025dcc <__ieee754_powf+0x6a4>)
 8025c58:	3b7f      	subs	r3, #127	; 0x7f
 8025c5a:	4119      	asrs	r1, r3
 8025c5c:	4021      	ands	r1, r4
 8025c5e:	f3c4 0416 	ubfx	r4, r4, #0, #23
 8025c62:	f1c3 0317 	rsb	r3, r3, #23
 8025c66:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
 8025c6a:	411c      	asrs	r4, r3
 8025c6c:	f1b8 0f00 	cmp.w	r8, #0
 8025c70:	4638      	mov	r0, r7
 8025c72:	bfb8      	it	lt
 8025c74:	4264      	neglt	r4, r4
 8025c76:	f7da ff93 	bl	8000ba0 <__aeabi_fsub>
 8025c7a:	4681      	mov	r9, r0
 8025c7c:	4631      	mov	r1, r6
 8025c7e:	4648      	mov	r0, r9
 8025c80:	f7da ff90 	bl	8000ba4 <__addsf3>
 8025c84:	f420 677f 	bic.w	r7, r0, #4080	; 0xff0
 8025c88:	f027 070f 	bic.w	r7, r7, #15
 8025c8c:	4638      	mov	r0, r7
 8025c8e:	4950      	ldr	r1, [pc, #320]	; (8025dd0 <__ieee754_powf+0x6a8>)
 8025c90:	f7db f890 	bl	8000db4 <__aeabi_fmul>
 8025c94:	4649      	mov	r1, r9
 8025c96:	4680      	mov	r8, r0
 8025c98:	4638      	mov	r0, r7
 8025c9a:	f7da ff81 	bl	8000ba0 <__aeabi_fsub>
 8025c9e:	4601      	mov	r1, r0
 8025ca0:	4630      	mov	r0, r6
 8025ca2:	f7da ff7d 	bl	8000ba0 <__aeabi_fsub>
 8025ca6:	494b      	ldr	r1, [pc, #300]	; (8025dd4 <__ieee754_powf+0x6ac>)
 8025ca8:	f7db f884 	bl	8000db4 <__aeabi_fmul>
 8025cac:	494a      	ldr	r1, [pc, #296]	; (8025dd8 <__ieee754_powf+0x6b0>)
 8025cae:	4606      	mov	r6, r0
 8025cb0:	4638      	mov	r0, r7
 8025cb2:	f7db f87f 	bl	8000db4 <__aeabi_fmul>
 8025cb6:	4601      	mov	r1, r0
 8025cb8:	4630      	mov	r0, r6
 8025cba:	f7da ff73 	bl	8000ba4 <__addsf3>
 8025cbe:	4607      	mov	r7, r0
 8025cc0:	4601      	mov	r1, r0
 8025cc2:	4640      	mov	r0, r8
 8025cc4:	f7da ff6e 	bl	8000ba4 <__addsf3>
 8025cc8:	4641      	mov	r1, r8
 8025cca:	4606      	mov	r6, r0
 8025ccc:	f7da ff68 	bl	8000ba0 <__aeabi_fsub>
 8025cd0:	4601      	mov	r1, r0
 8025cd2:	4638      	mov	r0, r7
 8025cd4:	f7da ff64 	bl	8000ba0 <__aeabi_fsub>
 8025cd8:	4631      	mov	r1, r6
 8025cda:	4680      	mov	r8, r0
 8025cdc:	4630      	mov	r0, r6
 8025cde:	f7db f869 	bl	8000db4 <__aeabi_fmul>
 8025ce2:	4607      	mov	r7, r0
 8025ce4:	493d      	ldr	r1, [pc, #244]	; (8025ddc <__ieee754_powf+0x6b4>)
 8025ce6:	f7db f865 	bl	8000db4 <__aeabi_fmul>
 8025cea:	493d      	ldr	r1, [pc, #244]	; (8025de0 <__ieee754_powf+0x6b8>)
 8025cec:	f7da ff58 	bl	8000ba0 <__aeabi_fsub>
 8025cf0:	4639      	mov	r1, r7
 8025cf2:	f7db f85f 	bl	8000db4 <__aeabi_fmul>
 8025cf6:	493b      	ldr	r1, [pc, #236]	; (8025de4 <__ieee754_powf+0x6bc>)
 8025cf8:	f7da ff54 	bl	8000ba4 <__addsf3>
 8025cfc:	4639      	mov	r1, r7
 8025cfe:	f7db f859 	bl	8000db4 <__aeabi_fmul>
 8025d02:	4939      	ldr	r1, [pc, #228]	; (8025de8 <__ieee754_powf+0x6c0>)
 8025d04:	f7da ff4c 	bl	8000ba0 <__aeabi_fsub>
 8025d08:	4639      	mov	r1, r7
 8025d0a:	f7db f853 	bl	8000db4 <__aeabi_fmul>
 8025d0e:	4937      	ldr	r1, [pc, #220]	; (8025dec <__ieee754_powf+0x6c4>)
 8025d10:	f7da ff48 	bl	8000ba4 <__addsf3>
 8025d14:	4639      	mov	r1, r7
 8025d16:	f7db f84d 	bl	8000db4 <__aeabi_fmul>
 8025d1a:	4601      	mov	r1, r0
 8025d1c:	4630      	mov	r0, r6
 8025d1e:	f7da ff3f 	bl	8000ba0 <__aeabi_fsub>
 8025d22:	4607      	mov	r7, r0
 8025d24:	4601      	mov	r1, r0
 8025d26:	4630      	mov	r0, r6
 8025d28:	f7db f844 	bl	8000db4 <__aeabi_fmul>
 8025d2c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8025d30:	4681      	mov	r9, r0
 8025d32:	4638      	mov	r0, r7
 8025d34:	f7da ff34 	bl	8000ba0 <__aeabi_fsub>
 8025d38:	4601      	mov	r1, r0
 8025d3a:	4648      	mov	r0, r9
 8025d3c:	f7db f8ee 	bl	8000f1c <__aeabi_fdiv>
 8025d40:	4641      	mov	r1, r8
 8025d42:	4607      	mov	r7, r0
 8025d44:	4630      	mov	r0, r6
 8025d46:	f7db f835 	bl	8000db4 <__aeabi_fmul>
 8025d4a:	4641      	mov	r1, r8
 8025d4c:	f7da ff2a 	bl	8000ba4 <__addsf3>
 8025d50:	4601      	mov	r1, r0
 8025d52:	4638      	mov	r0, r7
 8025d54:	f7da ff24 	bl	8000ba0 <__aeabi_fsub>
 8025d58:	4631      	mov	r1, r6
 8025d5a:	f7da ff21 	bl	8000ba0 <__aeabi_fsub>
 8025d5e:	4601      	mov	r1, r0
 8025d60:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8025d64:	f7da ff1c 	bl	8000ba0 <__aeabi_fsub>
 8025d68:	eb00 53c4 	add.w	r3, r0, r4, lsl #23
 8025d6c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8025d70:	da20      	bge.n	8025db4 <__ieee754_powf+0x68c>
 8025d72:	4621      	mov	r1, r4
 8025d74:	f000 f9a0 	bl	80260b8 <scalbnf>
 8025d78:	4629      	mov	r1, r5
 8025d7a:	e53f      	b.n	80257fc <__ieee754_powf+0xd4>
 8025d7c:	4b1c      	ldr	r3, [pc, #112]	; (8025df0 <__ieee754_powf+0x6c8>)
 8025d7e:	429c      	cmp	r4, r3
 8025d80:	dd07      	ble.n	8025d92 <__ieee754_powf+0x66a>
 8025d82:	2100      	movs	r1, #0
 8025d84:	4628      	mov	r0, r5
 8025d86:	f7db f9b3 	bl	80010f0 <__aeabi_fcmplt>
 8025d8a:	3800      	subs	r0, #0
 8025d8c:	bf18      	it	ne
 8025d8e:	2001      	movne	r0, #1
 8025d90:	e581      	b.n	8025896 <__ieee754_powf+0x16e>
 8025d92:	d109      	bne.n	8025da8 <__ieee754_powf+0x680>
 8025d94:	4639      	mov	r1, r7
 8025d96:	f7da ff03 	bl	8000ba0 <__aeabi_fsub>
 8025d9a:	4631      	mov	r1, r6
 8025d9c:	f7db f9bc 	bl	8001118 <__aeabi_fcmpge>
 8025da0:	2800      	cmp	r0, #0
 8025da2:	f43f af4f 	beq.w	8025c44 <__ieee754_powf+0x51c>
 8025da6:	e7ec      	b.n	8025d82 <__ieee754_powf+0x65a>
 8025da8:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 8025dac:	f73f af4a 	bgt.w	8025c44 <__ieee754_powf+0x51c>
 8025db0:	2400      	movs	r4, #0
 8025db2:	e763      	b.n	8025c7c <__ieee754_powf+0x554>
 8025db4:	4618      	mov	r0, r3
 8025db6:	e7df      	b.n	8025d78 <__ieee754_powf+0x650>
 8025db8:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8025dbc:	e50d      	b.n	80257da <__ieee754_powf+0xb2>
 8025dbe:	2100      	movs	r1, #0
 8025dc0:	e50b      	b.n	80257da <__ieee754_powf+0xb2>
 8025dc2:	2500      	movs	r5, #0
 8025dc4:	e4f1      	b.n	80257aa <__ieee754_powf+0x82>
 8025dc6:	bf00      	nop
 8025dc8:	3338aa3c 	.word	0x3338aa3c
 8025dcc:	ff800000 	.word	0xff800000
 8025dd0:	3f317200 	.word	0x3f317200
 8025dd4:	3f317218 	.word	0x3f317218
 8025dd8:	35bfbe8c 	.word	0x35bfbe8c
 8025ddc:	3331bb4c 	.word	0x3331bb4c
 8025de0:	35ddea0e 	.word	0x35ddea0e
 8025de4:	388ab355 	.word	0x388ab355
 8025de8:	3b360b61 	.word	0x3b360b61
 8025dec:	3e2aaaab 	.word	0x3e2aaaab
 8025df0:	43160000 	.word	0x43160000

08025df4 <__ieee754_rem_pio2f>:
 8025df4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025df8:	4aa0      	ldr	r2, [pc, #640]	; (802607c <__ieee754_rem_pio2f+0x288>)
 8025dfa:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8025dfe:	4296      	cmp	r6, r2
 8025e00:	460c      	mov	r4, r1
 8025e02:	4682      	mov	sl, r0
 8025e04:	b087      	sub	sp, #28
 8025e06:	dc04      	bgt.n	8025e12 <__ieee754_rem_pio2f+0x1e>
 8025e08:	2300      	movs	r3, #0
 8025e0a:	6008      	str	r0, [r1, #0]
 8025e0c:	604b      	str	r3, [r1, #4]
 8025e0e:	2500      	movs	r5, #0
 8025e10:	e01a      	b.n	8025e48 <__ieee754_rem_pio2f+0x54>
 8025e12:	4a9b      	ldr	r2, [pc, #620]	; (8026080 <__ieee754_rem_pio2f+0x28c>)
 8025e14:	4296      	cmp	r6, r2
 8025e16:	dc4b      	bgt.n	8025eb0 <__ieee754_rem_pio2f+0xbc>
 8025e18:	2800      	cmp	r0, #0
 8025e1a:	499a      	ldr	r1, [pc, #616]	; (8026084 <__ieee754_rem_pio2f+0x290>)
 8025e1c:	4f9a      	ldr	r7, [pc, #616]	; (8026088 <__ieee754_rem_pio2f+0x294>)
 8025e1e:	f026 060f 	bic.w	r6, r6, #15
 8025e22:	dd23      	ble.n	8025e6c <__ieee754_rem_pio2f+0x78>
 8025e24:	f7da febc 	bl	8000ba0 <__aeabi_fsub>
 8025e28:	42be      	cmp	r6, r7
 8025e2a:	4605      	mov	r5, r0
 8025e2c:	d010      	beq.n	8025e50 <__ieee754_rem_pio2f+0x5c>
 8025e2e:	4997      	ldr	r1, [pc, #604]	; (802608c <__ieee754_rem_pio2f+0x298>)
 8025e30:	f7da feb6 	bl	8000ba0 <__aeabi_fsub>
 8025e34:	4601      	mov	r1, r0
 8025e36:	6020      	str	r0, [r4, #0]
 8025e38:	4628      	mov	r0, r5
 8025e3a:	f7da feb1 	bl	8000ba0 <__aeabi_fsub>
 8025e3e:	4993      	ldr	r1, [pc, #588]	; (802608c <__ieee754_rem_pio2f+0x298>)
 8025e40:	f7da feae 	bl	8000ba0 <__aeabi_fsub>
 8025e44:	2501      	movs	r5, #1
 8025e46:	6060      	str	r0, [r4, #4]
 8025e48:	4628      	mov	r0, r5
 8025e4a:	b007      	add	sp, #28
 8025e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025e50:	498f      	ldr	r1, [pc, #572]	; (8026090 <__ieee754_rem_pio2f+0x29c>)
 8025e52:	f7da fea5 	bl	8000ba0 <__aeabi_fsub>
 8025e56:	498f      	ldr	r1, [pc, #572]	; (8026094 <__ieee754_rem_pio2f+0x2a0>)
 8025e58:	4605      	mov	r5, r0
 8025e5a:	f7da fea1 	bl	8000ba0 <__aeabi_fsub>
 8025e5e:	4601      	mov	r1, r0
 8025e60:	6020      	str	r0, [r4, #0]
 8025e62:	4628      	mov	r0, r5
 8025e64:	f7da fe9c 	bl	8000ba0 <__aeabi_fsub>
 8025e68:	498a      	ldr	r1, [pc, #552]	; (8026094 <__ieee754_rem_pio2f+0x2a0>)
 8025e6a:	e7e9      	b.n	8025e40 <__ieee754_rem_pio2f+0x4c>
 8025e6c:	f7da fe9a 	bl	8000ba4 <__addsf3>
 8025e70:	42be      	cmp	r6, r7
 8025e72:	4605      	mov	r5, r0
 8025e74:	d00e      	beq.n	8025e94 <__ieee754_rem_pio2f+0xa0>
 8025e76:	4985      	ldr	r1, [pc, #532]	; (802608c <__ieee754_rem_pio2f+0x298>)
 8025e78:	f7da fe94 	bl	8000ba4 <__addsf3>
 8025e7c:	4601      	mov	r1, r0
 8025e7e:	6020      	str	r0, [r4, #0]
 8025e80:	4628      	mov	r0, r5
 8025e82:	f7da fe8d 	bl	8000ba0 <__aeabi_fsub>
 8025e86:	4981      	ldr	r1, [pc, #516]	; (802608c <__ieee754_rem_pio2f+0x298>)
 8025e88:	f7da fe8c 	bl	8000ba4 <__addsf3>
 8025e8c:	f04f 35ff 	mov.w	r5, #4294967295
 8025e90:	6060      	str	r0, [r4, #4]
 8025e92:	e7d9      	b.n	8025e48 <__ieee754_rem_pio2f+0x54>
 8025e94:	497e      	ldr	r1, [pc, #504]	; (8026090 <__ieee754_rem_pio2f+0x29c>)
 8025e96:	f7da fe85 	bl	8000ba4 <__addsf3>
 8025e9a:	497e      	ldr	r1, [pc, #504]	; (8026094 <__ieee754_rem_pio2f+0x2a0>)
 8025e9c:	4605      	mov	r5, r0
 8025e9e:	f7da fe81 	bl	8000ba4 <__addsf3>
 8025ea2:	4601      	mov	r1, r0
 8025ea4:	6020      	str	r0, [r4, #0]
 8025ea6:	4628      	mov	r0, r5
 8025ea8:	f7da fe7a 	bl	8000ba0 <__aeabi_fsub>
 8025eac:	4979      	ldr	r1, [pc, #484]	; (8026094 <__ieee754_rem_pio2f+0x2a0>)
 8025eae:	e7eb      	b.n	8025e88 <__ieee754_rem_pio2f+0x94>
 8025eb0:	4a79      	ldr	r2, [pc, #484]	; (8026098 <__ieee754_rem_pio2f+0x2a4>)
 8025eb2:	4296      	cmp	r6, r2
 8025eb4:	f300 8091 	bgt.w	8025fda <__ieee754_rem_pio2f+0x1e6>
 8025eb8:	f000 f8fa 	bl	80260b0 <fabsf>
 8025ebc:	4977      	ldr	r1, [pc, #476]	; (802609c <__ieee754_rem_pio2f+0x2a8>)
 8025ebe:	4607      	mov	r7, r0
 8025ec0:	f7da ff78 	bl	8000db4 <__aeabi_fmul>
 8025ec4:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8025ec8:	f7da fe6c 	bl	8000ba4 <__addsf3>
 8025ecc:	f7db f94e 	bl	800116c <__aeabi_f2iz>
 8025ed0:	4605      	mov	r5, r0
 8025ed2:	f7da ff1b 	bl	8000d0c <__aeabi_i2f>
 8025ed6:	496b      	ldr	r1, [pc, #428]	; (8026084 <__ieee754_rem_pio2f+0x290>)
 8025ed8:	4681      	mov	r9, r0
 8025eda:	f7da ff6b 	bl	8000db4 <__aeabi_fmul>
 8025ede:	4601      	mov	r1, r0
 8025ee0:	4638      	mov	r0, r7
 8025ee2:	f7da fe5d 	bl	8000ba0 <__aeabi_fsub>
 8025ee6:	4969      	ldr	r1, [pc, #420]	; (802608c <__ieee754_rem_pio2f+0x298>)
 8025ee8:	4680      	mov	r8, r0
 8025eea:	4648      	mov	r0, r9
 8025eec:	f7da ff62 	bl	8000db4 <__aeabi_fmul>
 8025ef0:	2d1f      	cmp	r5, #31
 8025ef2:	4607      	mov	r7, r0
 8025ef4:	dc0c      	bgt.n	8025f10 <__ieee754_rem_pio2f+0x11c>
 8025ef6:	4a6a      	ldr	r2, [pc, #424]	; (80260a0 <__ieee754_rem_pio2f+0x2ac>)
 8025ef8:	1e69      	subs	r1, r5, #1
 8025efa:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8025efe:	f026 03ff 	bic.w	r3, r6, #255	; 0xff
 8025f02:	4293      	cmp	r3, r2
 8025f04:	d004      	beq.n	8025f10 <__ieee754_rem_pio2f+0x11c>
 8025f06:	4639      	mov	r1, r7
 8025f08:	4640      	mov	r0, r8
 8025f0a:	f7da fe49 	bl	8000ba0 <__aeabi_fsub>
 8025f0e:	e00b      	b.n	8025f28 <__ieee754_rem_pio2f+0x134>
 8025f10:	4639      	mov	r1, r7
 8025f12:	4640      	mov	r0, r8
 8025f14:	f7da fe44 	bl	8000ba0 <__aeabi_fsub>
 8025f18:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8025f1c:	ebc3 53d6 	rsb	r3, r3, r6, lsr #23
 8025f20:	2b08      	cmp	r3, #8
 8025f22:	ea4f 5be6 	mov.w	fp, r6, asr #23
 8025f26:	dc01      	bgt.n	8025f2c <__ieee754_rem_pio2f+0x138>
 8025f28:	6020      	str	r0, [r4, #0]
 8025f2a:	e026      	b.n	8025f7a <__ieee754_rem_pio2f+0x186>
 8025f2c:	4958      	ldr	r1, [pc, #352]	; (8026090 <__ieee754_rem_pio2f+0x29c>)
 8025f2e:	4648      	mov	r0, r9
 8025f30:	f7da ff40 	bl	8000db4 <__aeabi_fmul>
 8025f34:	4607      	mov	r7, r0
 8025f36:	4601      	mov	r1, r0
 8025f38:	4640      	mov	r0, r8
 8025f3a:	f7da fe31 	bl	8000ba0 <__aeabi_fsub>
 8025f3e:	4601      	mov	r1, r0
 8025f40:	4606      	mov	r6, r0
 8025f42:	4640      	mov	r0, r8
 8025f44:	f7da fe2c 	bl	8000ba0 <__aeabi_fsub>
 8025f48:	4639      	mov	r1, r7
 8025f4a:	f7da fe29 	bl	8000ba0 <__aeabi_fsub>
 8025f4e:	4607      	mov	r7, r0
 8025f50:	4950      	ldr	r1, [pc, #320]	; (8026094 <__ieee754_rem_pio2f+0x2a0>)
 8025f52:	4648      	mov	r0, r9
 8025f54:	f7da ff2e 	bl	8000db4 <__aeabi_fmul>
 8025f58:	4639      	mov	r1, r7
 8025f5a:	f7da fe21 	bl	8000ba0 <__aeabi_fsub>
 8025f5e:	4601      	mov	r1, r0
 8025f60:	4607      	mov	r7, r0
 8025f62:	4630      	mov	r0, r6
 8025f64:	f7da fe1c 	bl	8000ba0 <__aeabi_fsub>
 8025f68:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8025f6c:	ebab 0b03 	sub.w	fp, fp, r3
 8025f70:	f1bb 0f19 	cmp.w	fp, #25
 8025f74:	dc16      	bgt.n	8025fa4 <__ieee754_rem_pio2f+0x1b0>
 8025f76:	46b0      	mov	r8, r6
 8025f78:	6020      	str	r0, [r4, #0]
 8025f7a:	6826      	ldr	r6, [r4, #0]
 8025f7c:	4640      	mov	r0, r8
 8025f7e:	4631      	mov	r1, r6
 8025f80:	f7da fe0e 	bl	8000ba0 <__aeabi_fsub>
 8025f84:	4639      	mov	r1, r7
 8025f86:	f7da fe0b 	bl	8000ba0 <__aeabi_fsub>
 8025f8a:	f1ba 0f00 	cmp.w	sl, #0
 8025f8e:	6060      	str	r0, [r4, #4]
 8025f90:	f6bf af5a 	bge.w	8025e48 <__ieee754_rem_pio2f+0x54>
 8025f94:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
 8025f98:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8025f9c:	6026      	str	r6, [r4, #0]
 8025f9e:	6060      	str	r0, [r4, #4]
 8025fa0:	426d      	negs	r5, r5
 8025fa2:	e751      	b.n	8025e48 <__ieee754_rem_pio2f+0x54>
 8025fa4:	493f      	ldr	r1, [pc, #252]	; (80260a4 <__ieee754_rem_pio2f+0x2b0>)
 8025fa6:	4648      	mov	r0, r9
 8025fa8:	f7da ff04 	bl	8000db4 <__aeabi_fmul>
 8025fac:	4607      	mov	r7, r0
 8025fae:	4601      	mov	r1, r0
 8025fb0:	4630      	mov	r0, r6
 8025fb2:	f7da fdf5 	bl	8000ba0 <__aeabi_fsub>
 8025fb6:	4601      	mov	r1, r0
 8025fb8:	4680      	mov	r8, r0
 8025fba:	4630      	mov	r0, r6
 8025fbc:	f7da fdf0 	bl	8000ba0 <__aeabi_fsub>
 8025fc0:	4639      	mov	r1, r7
 8025fc2:	f7da fded 	bl	8000ba0 <__aeabi_fsub>
 8025fc6:	4606      	mov	r6, r0
 8025fc8:	4937      	ldr	r1, [pc, #220]	; (80260a8 <__ieee754_rem_pio2f+0x2b4>)
 8025fca:	4648      	mov	r0, r9
 8025fcc:	f7da fef2 	bl	8000db4 <__aeabi_fmul>
 8025fd0:	4631      	mov	r1, r6
 8025fd2:	f7da fde5 	bl	8000ba0 <__aeabi_fsub>
 8025fd6:	4607      	mov	r7, r0
 8025fd8:	e795      	b.n	8025f06 <__ieee754_rem_pio2f+0x112>
 8025fda:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8025fde:	db05      	blt.n	8025fec <__ieee754_rem_pio2f+0x1f8>
 8025fe0:	4601      	mov	r1, r0
 8025fe2:	f7da fddd 	bl	8000ba0 <__aeabi_fsub>
 8025fe6:	6060      	str	r0, [r4, #4]
 8025fe8:	6020      	str	r0, [r4, #0]
 8025fea:	e710      	b.n	8025e0e <__ieee754_rem_pio2f+0x1a>
 8025fec:	15f7      	asrs	r7, r6, #23
 8025fee:	3f86      	subs	r7, #134	; 0x86
 8025ff0:	eba6 56c7 	sub.w	r6, r6, r7, lsl #23
 8025ff4:	4630      	mov	r0, r6
 8025ff6:	f7db f8b9 	bl	800116c <__aeabi_f2iz>
 8025ffa:	f7da fe87 	bl	8000d0c <__aeabi_i2f>
 8025ffe:	4601      	mov	r1, r0
 8026000:	9003      	str	r0, [sp, #12]
 8026002:	4630      	mov	r0, r6
 8026004:	f7da fdcc 	bl	8000ba0 <__aeabi_fsub>
 8026008:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 802600c:	f7da fed2 	bl	8000db4 <__aeabi_fmul>
 8026010:	4606      	mov	r6, r0
 8026012:	f7db f8ab 	bl	800116c <__aeabi_f2iz>
 8026016:	f7da fe79 	bl	8000d0c <__aeabi_i2f>
 802601a:	4601      	mov	r1, r0
 802601c:	9004      	str	r0, [sp, #16]
 802601e:	4605      	mov	r5, r0
 8026020:	4630      	mov	r0, r6
 8026022:	f7da fdbd 	bl	8000ba0 <__aeabi_fsub>
 8026026:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 802602a:	f7da fec3 	bl	8000db4 <__aeabi_fmul>
 802602e:	2100      	movs	r1, #0
 8026030:	9005      	str	r0, [sp, #20]
 8026032:	f7db f853 	bl	80010dc <__aeabi_fcmpeq>
 8026036:	b1f0      	cbz	r0, 8026076 <__ieee754_rem_pio2f+0x282>
 8026038:	2100      	movs	r1, #0
 802603a:	4628      	mov	r0, r5
 802603c:	f7db f84e 	bl	80010dc <__aeabi_fcmpeq>
 8026040:	2800      	cmp	r0, #0
 8026042:	bf14      	ite	ne
 8026044:	2301      	movne	r3, #1
 8026046:	2302      	moveq	r3, #2
 8026048:	4a18      	ldr	r2, [pc, #96]	; (80260ac <__ieee754_rem_pio2f+0x2b8>)
 802604a:	4621      	mov	r1, r4
 802604c:	9201      	str	r2, [sp, #4]
 802604e:	2202      	movs	r2, #2
 8026050:	a803      	add	r0, sp, #12
 8026052:	9200      	str	r2, [sp, #0]
 8026054:	463a      	mov	r2, r7
 8026056:	f000 f899 	bl	802618c <__kernel_rem_pio2f>
 802605a:	f1ba 0f00 	cmp.w	sl, #0
 802605e:	4605      	mov	r5, r0
 8026060:	f6bf aef2 	bge.w	8025e48 <__ieee754_rem_pio2f+0x54>
 8026064:	6823      	ldr	r3, [r4, #0]
 8026066:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 802606a:	6023      	str	r3, [r4, #0]
 802606c:	6863      	ldr	r3, [r4, #4]
 802606e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8026072:	6063      	str	r3, [r4, #4]
 8026074:	e794      	b.n	8025fa0 <__ieee754_rem_pio2f+0x1ac>
 8026076:	2303      	movs	r3, #3
 8026078:	e7e6      	b.n	8026048 <__ieee754_rem_pio2f+0x254>
 802607a:	bf00      	nop
 802607c:	3f490fd8 	.word	0x3f490fd8
 8026080:	4016cbe3 	.word	0x4016cbe3
 8026084:	3fc90f80 	.word	0x3fc90f80
 8026088:	3fc90fd0 	.word	0x3fc90fd0
 802608c:	37354443 	.word	0x37354443
 8026090:	37354400 	.word	0x37354400
 8026094:	2e85a308 	.word	0x2e85a308
 8026098:	43490f80 	.word	0x43490f80
 802609c:	3f22f984 	.word	0x3f22f984
 80260a0:	08033060 	.word	0x08033060
 80260a4:	2e85a300 	.word	0x2e85a300
 80260a8:	248d3132 	.word	0x248d3132
 80260ac:	080330e0 	.word	0x080330e0

080260b0 <fabsf>:
 80260b0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80260b4:	4770      	bx	lr
	...

080260b8 <scalbnf>:
 80260b8:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80260bc:	b538      	push	{r3, r4, r5, lr}
 80260be:	4603      	mov	r3, r0
 80260c0:	460d      	mov	r5, r1
 80260c2:	4604      	mov	r4, r0
 80260c4:	d02e      	beq.n	8026124 <scalbnf+0x6c>
 80260c6:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80260ca:	d304      	bcc.n	80260d6 <scalbnf+0x1e>
 80260cc:	4601      	mov	r1, r0
 80260ce:	f7da fd69 	bl	8000ba4 <__addsf3>
 80260d2:	4603      	mov	r3, r0
 80260d4:	e026      	b.n	8026124 <scalbnf+0x6c>
 80260d6:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
 80260da:	d118      	bne.n	802610e <scalbnf+0x56>
 80260dc:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 80260e0:	f7da fe68 	bl	8000db4 <__aeabi_fmul>
 80260e4:	4a17      	ldr	r2, [pc, #92]	; (8026144 <scalbnf+0x8c>)
 80260e6:	4603      	mov	r3, r0
 80260e8:	4295      	cmp	r5, r2
 80260ea:	db0c      	blt.n	8026106 <scalbnf+0x4e>
 80260ec:	4604      	mov	r4, r0
 80260ee:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 80260f2:	3a19      	subs	r2, #25
 80260f4:	f24c 3150 	movw	r1, #50000	; 0xc350
 80260f8:	428d      	cmp	r5, r1
 80260fa:	dd0a      	ble.n	8026112 <scalbnf+0x5a>
 80260fc:	4912      	ldr	r1, [pc, #72]	; (8026148 <scalbnf+0x90>)
 80260fe:	4618      	mov	r0, r3
 8026100:	f361 001e 	bfi	r0, r1, #0, #31
 8026104:	e000      	b.n	8026108 <scalbnf+0x50>
 8026106:	4911      	ldr	r1, [pc, #68]	; (802614c <scalbnf+0x94>)
 8026108:	f7da fe54 	bl	8000db4 <__aeabi_fmul>
 802610c:	e7e1      	b.n	80260d2 <scalbnf+0x1a>
 802610e:	0dd2      	lsrs	r2, r2, #23
 8026110:	e7f0      	b.n	80260f4 <scalbnf+0x3c>
 8026112:	1951      	adds	r1, r2, r5
 8026114:	29fe      	cmp	r1, #254	; 0xfe
 8026116:	dcf1      	bgt.n	80260fc <scalbnf+0x44>
 8026118:	2900      	cmp	r1, #0
 802611a:	dd05      	ble.n	8026128 <scalbnf+0x70>
 802611c:	f024 44ff 	bic.w	r4, r4, #2139095040	; 0x7f800000
 8026120:	ea44 53c1 	orr.w	r3, r4, r1, lsl #23
 8026124:	4618      	mov	r0, r3
 8026126:	bd38      	pop	{r3, r4, r5, pc}
 8026128:	f111 0f16 	cmn.w	r1, #22
 802612c:	da01      	bge.n	8026132 <scalbnf+0x7a>
 802612e:	4907      	ldr	r1, [pc, #28]	; (802614c <scalbnf+0x94>)
 8026130:	e7e5      	b.n	80260fe <scalbnf+0x46>
 8026132:	f101 0019 	add.w	r0, r1, #25
 8026136:	f024 44ff 	bic.w	r4, r4, #2139095040	; 0x7f800000
 802613a:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
 802613e:	ea44 50c0 	orr.w	r0, r4, r0, lsl #23
 8026142:	e7e1      	b.n	8026108 <scalbnf+0x50>
 8026144:	ffff3cb0 	.word	0xffff3cb0
 8026148:	7149f2ca 	.word	0x7149f2ca
 802614c:	0da24260 	.word	0x0da24260

08026150 <with_errnof>:
 8026150:	b538      	push	{r3, r4, r5, lr}
 8026152:	4604      	mov	r4, r0
 8026154:	460d      	mov	r5, r1
 8026156:	f7fd fe85 	bl	8023e64 <__errno>
 802615a:	6005      	str	r5, [r0, #0]
 802615c:	4620      	mov	r0, r4
 802615e:	bd38      	pop	{r3, r4, r5, pc}

08026160 <xflowf>:
 8026160:	b508      	push	{r3, lr}
 8026162:	b140      	cbz	r0, 8026176 <xflowf+0x16>
 8026164:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 8026168:	f7da fe24 	bl	8000db4 <__aeabi_fmul>
 802616c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8026170:	2122      	movs	r1, #34	; 0x22
 8026172:	f7ff bfed 	b.w	8026150 <with_errnof>
 8026176:	4608      	mov	r0, r1
 8026178:	e7f6      	b.n	8026168 <xflowf+0x8>

0802617a <__math_uflowf>:
 802617a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
 802617e:	f7ff bfef 	b.w	8026160 <xflowf>

08026182 <__math_oflowf>:
 8026182:	f04f 41e0 	mov.w	r1, #1879048192	; 0x70000000
 8026186:	f7ff bfeb 	b.w	8026160 <xflowf>
	...

0802618c <__kernel_rem_pio2f>:
 802618c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026190:	b0db      	sub	sp, #364	; 0x16c
 8026192:	9202      	str	r2, [sp, #8]
 8026194:	9304      	str	r3, [sp, #16]
 8026196:	9a64      	ldr	r2, [sp, #400]	; 0x190
 8026198:	4bbb      	ldr	r3, [pc, #748]	; (8026488 <__kernel_rem_pio2f+0x2fc>)
 802619a:	9005      	str	r0, [sp, #20]
 802619c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80261a0:	9100      	str	r1, [sp, #0]
 80261a2:	9301      	str	r3, [sp, #4]
 80261a4:	9b04      	ldr	r3, [sp, #16]
 80261a6:	3b01      	subs	r3, #1
 80261a8:	9303      	str	r3, [sp, #12]
 80261aa:	9b02      	ldr	r3, [sp, #8]
 80261ac:	1d1a      	adds	r2, r3, #4
 80261ae:	f2c0 809b 	blt.w	80262e8 <__kernel_rem_pio2f+0x15c>
 80261b2:	1edc      	subs	r4, r3, #3
 80261b4:	bf48      	it	mi
 80261b6:	1d1c      	addmi	r4, r3, #4
 80261b8:	10e4      	asrs	r4, r4, #3
 80261ba:	2500      	movs	r5, #0
 80261bc:	f04f 0b00 	mov.w	fp, #0
 80261c0:	1c67      	adds	r7, r4, #1
 80261c2:	00fb      	lsls	r3, r7, #3
 80261c4:	9306      	str	r3, [sp, #24]
 80261c6:	9b02      	ldr	r3, [sp, #8]
 80261c8:	9a03      	ldr	r2, [sp, #12]
 80261ca:	eba3 07c7 	sub.w	r7, r3, r7, lsl #3
 80261ce:	9b01      	ldr	r3, [sp, #4]
 80261d0:	eba4 0802 	sub.w	r8, r4, r2
 80261d4:	eb03 0902 	add.w	r9, r3, r2
 80261d8:	9b65      	ldr	r3, [sp, #404]	; 0x194
 80261da:	ae1e      	add	r6, sp, #120	; 0x78
 80261dc:	eb03 0a88 	add.w	sl, r3, r8, lsl #2
 80261e0:	454d      	cmp	r5, r9
 80261e2:	f340 8083 	ble.w	80262ec <__kernel_rem_pio2f+0x160>
 80261e6:	9a04      	ldr	r2, [sp, #16]
 80261e8:	ab1e      	add	r3, sp, #120	; 0x78
 80261ea:	eb03 0582 	add.w	r5, r3, r2, lsl #2
 80261ee:	f04f 0900 	mov.w	r9, #0
 80261f2:	2300      	movs	r3, #0
 80261f4:	f50d 7b8c 	add.w	fp, sp, #280	; 0x118
 80261f8:	9a01      	ldr	r2, [sp, #4]
 80261fa:	4591      	cmp	r9, r2
 80261fc:	f340 809e 	ble.w	802633c <__kernel_rem_pio2f+0x1b0>
 8026200:	4613      	mov	r3, r2
 8026202:	aa0a      	add	r2, sp, #40	; 0x28
 8026204:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8026208:	9308      	str	r3, [sp, #32]
 802620a:	9b65      	ldr	r3, [sp, #404]	; 0x194
 802620c:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8026210:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8026214:	9307      	str	r3, [sp, #28]
 8026216:	ac0a      	add	r4, sp, #40	; 0x28
 8026218:	4626      	mov	r6, r4
 802621a:	46c3      	mov	fp, r8
 802621c:	f04f 4987 	mov.w	r9, #1132462080	; 0x43800000
 8026220:	ab5a      	add	r3, sp, #360	; 0x168
 8026222:	eb03 0388 	add.w	r3, r3, r8, lsl #2
 8026226:	f853 5c50 	ldr.w	r5, [r3, #-80]
 802622a:	f50d 7a8c 	add.w	sl, sp, #280	; 0x118
 802622e:	f1bb 0f00 	cmp.w	fp, #0
 8026232:	f300 8088 	bgt.w	8026346 <__kernel_rem_pio2f+0x1ba>
 8026236:	4639      	mov	r1, r7
 8026238:	4628      	mov	r0, r5
 802623a:	f7ff ff3d 	bl	80260b8 <scalbnf>
 802623e:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
 8026242:	4605      	mov	r5, r0
 8026244:	f7da fdb6 	bl	8000db4 <__aeabi_fmul>
 8026248:	f7fe fd70 	bl	8024d2c <floorf>
 802624c:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
 8026250:	f7da fdb0 	bl	8000db4 <__aeabi_fmul>
 8026254:	4601      	mov	r1, r0
 8026256:	4628      	mov	r0, r5
 8026258:	f7da fca2 	bl	8000ba0 <__aeabi_fsub>
 802625c:	4605      	mov	r5, r0
 802625e:	f7da ff85 	bl	800116c <__aeabi_f2iz>
 8026262:	4606      	mov	r6, r0
 8026264:	f7da fd52 	bl	8000d0c <__aeabi_i2f>
 8026268:	4601      	mov	r1, r0
 802626a:	4628      	mov	r0, r5
 802626c:	f7da fc98 	bl	8000ba0 <__aeabi_fsub>
 8026270:	2f00      	cmp	r7, #0
 8026272:	4681      	mov	r9, r0
 8026274:	f340 8086 	ble.w	8026384 <__kernel_rem_pio2f+0x1f8>
 8026278:	f108 32ff 	add.w	r2, r8, #4294967295
 802627c:	ab0a      	add	r3, sp, #40	; 0x28
 802627e:	f853 5022 	ldr.w	r5, [r3, r2, lsl #2]
 8026282:	f1c7 0108 	rsb	r1, r7, #8
 8026286:	fa45 f301 	asr.w	r3, r5, r1
 802628a:	441e      	add	r6, r3
 802628c:	408b      	lsls	r3, r1
 802628e:	1aed      	subs	r5, r5, r3
 8026290:	ab0a      	add	r3, sp, #40	; 0x28
 8026292:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 8026296:	f1c7 0307 	rsb	r3, r7, #7
 802629a:	411d      	asrs	r5, r3
 802629c:	2d00      	cmp	r5, #0
 802629e:	dd7f      	ble.n	80263a0 <__kernel_rem_pio2f+0x214>
 80262a0:	2200      	movs	r2, #0
 80262a2:	4692      	mov	sl, r2
 80262a4:	3601      	adds	r6, #1
 80262a6:	4590      	cmp	r8, r2
 80262a8:	f300 80b0 	bgt.w	802640c <__kernel_rem_pio2f+0x280>
 80262ac:	2f00      	cmp	r7, #0
 80262ae:	dd05      	ble.n	80262bc <__kernel_rem_pio2f+0x130>
 80262b0:	2f01      	cmp	r7, #1
 80262b2:	f000 80bd 	beq.w	8026430 <__kernel_rem_pio2f+0x2a4>
 80262b6:	2f02      	cmp	r7, #2
 80262b8:	f000 80c5 	beq.w	8026446 <__kernel_rem_pio2f+0x2ba>
 80262bc:	2d02      	cmp	r5, #2
 80262be:	d16f      	bne.n	80263a0 <__kernel_rem_pio2f+0x214>
 80262c0:	4649      	mov	r1, r9
 80262c2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80262c6:	f7da fc6b 	bl	8000ba0 <__aeabi_fsub>
 80262ca:	4681      	mov	r9, r0
 80262cc:	f1ba 0f00 	cmp.w	sl, #0
 80262d0:	d066      	beq.n	80263a0 <__kernel_rem_pio2f+0x214>
 80262d2:	4639      	mov	r1, r7
 80262d4:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80262d8:	f7ff feee 	bl	80260b8 <scalbnf>
 80262dc:	4601      	mov	r1, r0
 80262de:	4648      	mov	r0, r9
 80262e0:	f7da fc5e 	bl	8000ba0 <__aeabi_fsub>
 80262e4:	4681      	mov	r9, r0
 80262e6:	e05b      	b.n	80263a0 <__kernel_rem_pio2f+0x214>
 80262e8:	2400      	movs	r4, #0
 80262ea:	e766      	b.n	80261ba <__kernel_rem_pio2f+0x2e>
 80262ec:	eb18 0f05 	cmn.w	r8, r5
 80262f0:	d407      	bmi.n	8026302 <__kernel_rem_pio2f+0x176>
 80262f2:	f85a 0025 	ldr.w	r0, [sl, r5, lsl #2]
 80262f6:	f7da fd09 	bl	8000d0c <__aeabi_i2f>
 80262fa:	f846 0b04 	str.w	r0, [r6], #4
 80262fe:	3501      	adds	r5, #1
 8026300:	e76e      	b.n	80261e0 <__kernel_rem_pio2f+0x54>
 8026302:	4658      	mov	r0, fp
 8026304:	e7f9      	b.n	80262fa <__kernel_rem_pio2f+0x16e>
 8026306:	9307      	str	r3, [sp, #28]
 8026308:	9b05      	ldr	r3, [sp, #20]
 802630a:	f8da 1000 	ldr.w	r1, [sl]
 802630e:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
 8026312:	f7da fd4f 	bl	8000db4 <__aeabi_fmul>
 8026316:	4601      	mov	r1, r0
 8026318:	4630      	mov	r0, r6
 802631a:	f7da fc43 	bl	8000ba4 <__addsf3>
 802631e:	4606      	mov	r6, r0
 8026320:	9b07      	ldr	r3, [sp, #28]
 8026322:	f108 0801 	add.w	r8, r8, #1
 8026326:	9a03      	ldr	r2, [sp, #12]
 8026328:	f1aa 0a04 	sub.w	sl, sl, #4
 802632c:	4590      	cmp	r8, r2
 802632e:	ddea      	ble.n	8026306 <__kernel_rem_pio2f+0x17a>
 8026330:	f84b 6b04 	str.w	r6, [fp], #4
 8026334:	f109 0901 	add.w	r9, r9, #1
 8026338:	3504      	adds	r5, #4
 802633a:	e75d      	b.n	80261f8 <__kernel_rem_pio2f+0x6c>
 802633c:	46aa      	mov	sl, r5
 802633e:	461e      	mov	r6, r3
 8026340:	f04f 0800 	mov.w	r8, #0
 8026344:	e7ef      	b.n	8026326 <__kernel_rem_pio2f+0x19a>
 8026346:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 802634a:	4628      	mov	r0, r5
 802634c:	f7da fd32 	bl	8000db4 <__aeabi_fmul>
 8026350:	f7da ff0c 	bl	800116c <__aeabi_f2iz>
 8026354:	f7da fcda 	bl	8000d0c <__aeabi_i2f>
 8026358:	4649      	mov	r1, r9
 802635a:	9009      	str	r0, [sp, #36]	; 0x24
 802635c:	f7da fd2a 	bl	8000db4 <__aeabi_fmul>
 8026360:	4601      	mov	r1, r0
 8026362:	4628      	mov	r0, r5
 8026364:	f7da fc1c 	bl	8000ba0 <__aeabi_fsub>
 8026368:	f7da ff00 	bl	800116c <__aeabi_f2iz>
 802636c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802636e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8026372:	f846 0b04 	str.w	r0, [r6], #4
 8026376:	f85a 102b 	ldr.w	r1, [sl, fp, lsl #2]
 802637a:	4618      	mov	r0, r3
 802637c:	f7da fc12 	bl	8000ba4 <__addsf3>
 8026380:	4605      	mov	r5, r0
 8026382:	e754      	b.n	802622e <__kernel_rem_pio2f+0xa2>
 8026384:	d106      	bne.n	8026394 <__kernel_rem_pio2f+0x208>
 8026386:	f108 33ff 	add.w	r3, r8, #4294967295
 802638a:	aa0a      	add	r2, sp, #40	; 0x28
 802638c:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
 8026390:	11ed      	asrs	r5, r5, #7
 8026392:	e783      	b.n	802629c <__kernel_rem_pio2f+0x110>
 8026394:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8026398:	f7da febe 	bl	8001118 <__aeabi_fcmpge>
 802639c:	4605      	mov	r5, r0
 802639e:	bb98      	cbnz	r0, 8026408 <__kernel_rem_pio2f+0x27c>
 80263a0:	2100      	movs	r1, #0
 80263a2:	4648      	mov	r0, r9
 80263a4:	f7da fe9a 	bl	80010dc <__aeabi_fcmpeq>
 80263a8:	2800      	cmp	r0, #0
 80263aa:	f000 8098 	beq.w	80264de <__kernel_rem_pio2f+0x352>
 80263ae:	f108 34ff 	add.w	r4, r8, #4294967295
 80263b2:	4623      	mov	r3, r4
 80263b4:	2200      	movs	r2, #0
 80263b6:	9901      	ldr	r1, [sp, #4]
 80263b8:	428b      	cmp	r3, r1
 80263ba:	da4c      	bge.n	8026456 <__kernel_rem_pio2f+0x2ca>
 80263bc:	2a00      	cmp	r2, #0
 80263be:	d067      	beq.n	8026490 <__kernel_rem_pio2f+0x304>
 80263c0:	ab0a      	add	r3, sp, #40	; 0x28
 80263c2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80263c6:	3f08      	subs	r7, #8
 80263c8:	2b00      	cmp	r3, #0
 80263ca:	f000 8086 	beq.w	80264da <__kernel_rem_pio2f+0x34e>
 80263ce:	4639      	mov	r1, r7
 80263d0:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80263d4:	f7ff fe70 	bl	80260b8 <scalbnf>
 80263d8:	46a2      	mov	sl, r4
 80263da:	4681      	mov	r9, r0
 80263dc:	f04f 586e 	mov.w	r8, #998244352	; 0x3b800000
 80263e0:	af46      	add	r7, sp, #280	; 0x118
 80263e2:	f1ba 0f00 	cmp.w	sl, #0
 80263e6:	f280 80af 	bge.w	8026548 <__kernel_rem_pio2f+0x3bc>
 80263ea:	4627      	mov	r7, r4
 80263ec:	2200      	movs	r2, #0
 80263ee:	2f00      	cmp	r7, #0
 80263f0:	f2c0 80d9 	blt.w	80265a6 <__kernel_rem_pio2f+0x41a>
 80263f4:	a946      	add	r1, sp, #280	; 0x118
 80263f6:	4690      	mov	r8, r2
 80263f8:	f04f 0a00 	mov.w	sl, #0
 80263fc:	4b23      	ldr	r3, [pc, #140]	; (802648c <__kernel_rem_pio2f+0x300>)
 80263fe:	eb01 0b87 	add.w	fp, r1, r7, lsl #2
 8026402:	eba4 0907 	sub.w	r9, r4, r7
 8026406:	e0c2      	b.n	802658e <__kernel_rem_pio2f+0x402>
 8026408:	2502      	movs	r5, #2
 802640a:	e749      	b.n	80262a0 <__kernel_rem_pio2f+0x114>
 802640c:	6823      	ldr	r3, [r4, #0]
 802640e:	f1ba 0f00 	cmp.w	sl, #0
 8026412:	d108      	bne.n	8026426 <__kernel_rem_pio2f+0x29a>
 8026414:	b11b      	cbz	r3, 802641e <__kernel_rem_pio2f+0x292>
 8026416:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 802641a:	6023      	str	r3, [r4, #0]
 802641c:	2301      	movs	r3, #1
 802641e:	469a      	mov	sl, r3
 8026420:	3201      	adds	r2, #1
 8026422:	3404      	adds	r4, #4
 8026424:	e73f      	b.n	80262a6 <__kernel_rem_pio2f+0x11a>
 8026426:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 802642a:	6023      	str	r3, [r4, #0]
 802642c:	4653      	mov	r3, sl
 802642e:	e7f6      	b.n	802641e <__kernel_rem_pio2f+0x292>
 8026430:	f108 32ff 	add.w	r2, r8, #4294967295
 8026434:	ab0a      	add	r3, sp, #40	; 0x28
 8026436:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802643a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802643e:	a90a      	add	r1, sp, #40	; 0x28
 8026440:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8026444:	e73a      	b.n	80262bc <__kernel_rem_pio2f+0x130>
 8026446:	f108 32ff 	add.w	r2, r8, #4294967295
 802644a:	ab0a      	add	r3, sp, #40	; 0x28
 802644c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8026450:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8026454:	e7f3      	b.n	802643e <__kernel_rem_pio2f+0x2b2>
 8026456:	a90a      	add	r1, sp, #40	; 0x28
 8026458:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 802645c:	3b01      	subs	r3, #1
 802645e:	430a      	orrs	r2, r1
 8026460:	e7a9      	b.n	80263b6 <__kernel_rem_pio2f+0x22a>
 8026462:	3401      	adds	r4, #1
 8026464:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8026468:	2a00      	cmp	r2, #0
 802646a:	d0fa      	beq.n	8026462 <__kernel_rem_pio2f+0x2d6>
 802646c:	9b04      	ldr	r3, [sp, #16]
 802646e:	aa1e      	add	r2, sp, #120	; 0x78
 8026470:	4443      	add	r3, r8
 8026472:	f108 0601 	add.w	r6, r8, #1
 8026476:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 802647a:	4444      	add	r4, r8
 802647c:	f50d 798c 	add.w	r9, sp, #280	; 0x118
 8026480:	42b4      	cmp	r4, r6
 8026482:	da08      	bge.n	8026496 <__kernel_rem_pio2f+0x30a>
 8026484:	46a0      	mov	r8, r4
 8026486:	e6c6      	b.n	8026216 <__kernel_rem_pio2f+0x8a>
 8026488:	08033424 	.word	0x08033424
 802648c:	080333f8 	.word	0x080333f8
 8026490:	2401      	movs	r4, #1
 8026492:	9b08      	ldr	r3, [sp, #32]
 8026494:	e7e6      	b.n	8026464 <__kernel_rem_pio2f+0x2d8>
 8026496:	9b07      	ldr	r3, [sp, #28]
 8026498:	46ab      	mov	fp, r5
 802649a:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 802649e:	f7da fc35 	bl	8000d0c <__aeabi_i2f>
 80264a2:	f04f 0a00 	mov.w	sl, #0
 80264a6:	f04f 0800 	mov.w	r8, #0
 80264aa:	6028      	str	r0, [r5, #0]
 80264ac:	9b03      	ldr	r3, [sp, #12]
 80264ae:	459a      	cmp	sl, r3
 80264b0:	dd04      	ble.n	80264bc <__kernel_rem_pio2f+0x330>
 80264b2:	f849 8026 	str.w	r8, [r9, r6, lsl #2]
 80264b6:	3504      	adds	r5, #4
 80264b8:	3601      	adds	r6, #1
 80264ba:	e7e1      	b.n	8026480 <__kernel_rem_pio2f+0x2f4>
 80264bc:	9b05      	ldr	r3, [sp, #20]
 80264be:	f85b 0904 	ldr.w	r0, [fp], #-4
 80264c2:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
 80264c6:	f7da fc75 	bl	8000db4 <__aeabi_fmul>
 80264ca:	4601      	mov	r1, r0
 80264cc:	4640      	mov	r0, r8
 80264ce:	f7da fb69 	bl	8000ba4 <__addsf3>
 80264d2:	f10a 0a01 	add.w	sl, sl, #1
 80264d6:	4680      	mov	r8, r0
 80264d8:	e7e8      	b.n	80264ac <__kernel_rem_pio2f+0x320>
 80264da:	3c01      	subs	r4, #1
 80264dc:	e770      	b.n	80263c0 <__kernel_rem_pio2f+0x234>
 80264de:	9b06      	ldr	r3, [sp, #24]
 80264e0:	9a02      	ldr	r2, [sp, #8]
 80264e2:	4648      	mov	r0, r9
 80264e4:	1a99      	subs	r1, r3, r2
 80264e6:	f7ff fde7 	bl	80260b8 <scalbnf>
 80264ea:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 80264ee:	4604      	mov	r4, r0
 80264f0:	f7da fe12 	bl	8001118 <__aeabi_fcmpge>
 80264f4:	b300      	cbz	r0, 8026538 <__kernel_rem_pio2f+0x3ac>
 80264f6:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 80264fa:	4620      	mov	r0, r4
 80264fc:	f7da fc5a 	bl	8000db4 <__aeabi_fmul>
 8026500:	f7da fe34 	bl	800116c <__aeabi_f2iz>
 8026504:	f7da fc02 	bl	8000d0c <__aeabi_i2f>
 8026508:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 802650c:	4681      	mov	r9, r0
 802650e:	f7da fc51 	bl	8000db4 <__aeabi_fmul>
 8026512:	4601      	mov	r1, r0
 8026514:	4620      	mov	r0, r4
 8026516:	f7da fb43 	bl	8000ba0 <__aeabi_fsub>
 802651a:	f7da fe27 	bl	800116c <__aeabi_f2iz>
 802651e:	ab0a      	add	r3, sp, #40	; 0x28
 8026520:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8026524:	4648      	mov	r0, r9
 8026526:	f7da fe21 	bl	800116c <__aeabi_f2iz>
 802652a:	f108 0401 	add.w	r4, r8, #1
 802652e:	ab0a      	add	r3, sp, #40	; 0x28
 8026530:	3708      	adds	r7, #8
 8026532:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 8026536:	e74a      	b.n	80263ce <__kernel_rem_pio2f+0x242>
 8026538:	4620      	mov	r0, r4
 802653a:	f7da fe17 	bl	800116c <__aeabi_f2iz>
 802653e:	ab0a      	add	r3, sp, #40	; 0x28
 8026540:	4644      	mov	r4, r8
 8026542:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8026546:	e742      	b.n	80263ce <__kernel_rem_pio2f+0x242>
 8026548:	ab0a      	add	r3, sp, #40	; 0x28
 802654a:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
 802654e:	f7da fbdd 	bl	8000d0c <__aeabi_i2f>
 8026552:	4649      	mov	r1, r9
 8026554:	f7da fc2e 	bl	8000db4 <__aeabi_fmul>
 8026558:	4641      	mov	r1, r8
 802655a:	f847 002a 	str.w	r0, [r7, sl, lsl #2]
 802655e:	4648      	mov	r0, r9
 8026560:	f7da fc28 	bl	8000db4 <__aeabi_fmul>
 8026564:	f10a 3aff 	add.w	sl, sl, #4294967295
 8026568:	4681      	mov	r9, r0
 802656a:	e73a      	b.n	80263e2 <__kernel_rem_pio2f+0x256>
 802656c:	f853 0b04 	ldr.w	r0, [r3], #4
 8026570:	f85b 1b04 	ldr.w	r1, [fp], #4
 8026574:	9203      	str	r2, [sp, #12]
 8026576:	9302      	str	r3, [sp, #8]
 8026578:	f7da fc1c 	bl	8000db4 <__aeabi_fmul>
 802657c:	4601      	mov	r1, r0
 802657e:	4640      	mov	r0, r8
 8026580:	f7da fb10 	bl	8000ba4 <__addsf3>
 8026584:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8026588:	4680      	mov	r8, r0
 802658a:	f10a 0a01 	add.w	sl, sl, #1
 802658e:	9901      	ldr	r1, [sp, #4]
 8026590:	458a      	cmp	sl, r1
 8026592:	dc01      	bgt.n	8026598 <__kernel_rem_pio2f+0x40c>
 8026594:	45ca      	cmp	sl, r9
 8026596:	dde9      	ble.n	802656c <__kernel_rem_pio2f+0x3e0>
 8026598:	ab5a      	add	r3, sp, #360	; 0x168
 802659a:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 802659e:	f849 8ca0 	str.w	r8, [r9, #-160]
 80265a2:	3f01      	subs	r7, #1
 80265a4:	e723      	b.n	80263ee <__kernel_rem_pio2f+0x262>
 80265a6:	9b64      	ldr	r3, [sp, #400]	; 0x190
 80265a8:	2b02      	cmp	r3, #2
 80265aa:	dc07      	bgt.n	80265bc <__kernel_rem_pio2f+0x430>
 80265ac:	2b00      	cmp	r3, #0
 80265ae:	dc4e      	bgt.n	802664e <__kernel_rem_pio2f+0x4c2>
 80265b0:	d02e      	beq.n	8026610 <__kernel_rem_pio2f+0x484>
 80265b2:	f006 0007 	and.w	r0, r6, #7
 80265b6:	b05b      	add	sp, #364	; 0x16c
 80265b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80265bc:	9b64      	ldr	r3, [sp, #400]	; 0x190
 80265be:	2b03      	cmp	r3, #3
 80265c0:	d1f7      	bne.n	80265b2 <__kernel_rem_pio2f+0x426>
 80265c2:	f10d 0bc8 	add.w	fp, sp, #200	; 0xc8
 80265c6:	eb0b 0784 	add.w	r7, fp, r4, lsl #2
 80265ca:	46b8      	mov	r8, r7
 80265cc:	46a2      	mov	sl, r4
 80265ce:	f1ba 0f00 	cmp.w	sl, #0
 80265d2:	dc49      	bgt.n	8026668 <__kernel_rem_pio2f+0x4dc>
 80265d4:	46a1      	mov	r9, r4
 80265d6:	f1b9 0f01 	cmp.w	r9, #1
 80265da:	dc60      	bgt.n	802669e <__kernel_rem_pio2f+0x512>
 80265dc:	2000      	movs	r0, #0
 80265de:	2c01      	cmp	r4, #1
 80265e0:	dc76      	bgt.n	80266d0 <__kernel_rem_pio2f+0x544>
 80265e2:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 80265e4:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 80265e6:	2d00      	cmp	r5, #0
 80265e8:	d178      	bne.n	80266dc <__kernel_rem_pio2f+0x550>
 80265ea:	9900      	ldr	r1, [sp, #0]
 80265ec:	600a      	str	r2, [r1, #0]
 80265ee:	460a      	mov	r2, r1
 80265f0:	604b      	str	r3, [r1, #4]
 80265f2:	6090      	str	r0, [r2, #8]
 80265f4:	e7dd      	b.n	80265b2 <__kernel_rem_pio2f+0x426>
 80265f6:	f857 1024 	ldr.w	r1, [r7, r4, lsl #2]
 80265fa:	f7da fad3 	bl	8000ba4 <__addsf3>
 80265fe:	3c01      	subs	r4, #1
 8026600:	2c00      	cmp	r4, #0
 8026602:	daf8      	bge.n	80265f6 <__kernel_rem_pio2f+0x46a>
 8026604:	b10d      	cbz	r5, 802660a <__kernel_rem_pio2f+0x47e>
 8026606:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 802660a:	9b00      	ldr	r3, [sp, #0]
 802660c:	6018      	str	r0, [r3, #0]
 802660e:	e7d0      	b.n	80265b2 <__kernel_rem_pio2f+0x426>
 8026610:	2000      	movs	r0, #0
 8026612:	af32      	add	r7, sp, #200	; 0xc8
 8026614:	e7f4      	b.n	8026600 <__kernel_rem_pio2f+0x474>
 8026616:	f857 1028 	ldr.w	r1, [r7, r8, lsl #2]
 802661a:	f7da fac3 	bl	8000ba4 <__addsf3>
 802661e:	f108 38ff 	add.w	r8, r8, #4294967295
 8026622:	f1b8 0f00 	cmp.w	r8, #0
 8026626:	daf6      	bge.n	8026616 <__kernel_rem_pio2f+0x48a>
 8026628:	b1ad      	cbz	r5, 8026656 <__kernel_rem_pio2f+0x4ca>
 802662a:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
 802662e:	9a00      	ldr	r2, [sp, #0]
 8026630:	4601      	mov	r1, r0
 8026632:	6013      	str	r3, [r2, #0]
 8026634:	9832      	ldr	r0, [sp, #200]	; 0xc8
 8026636:	f7da fab3 	bl	8000ba0 <__aeabi_fsub>
 802663a:	f04f 0801 	mov.w	r8, #1
 802663e:	4544      	cmp	r4, r8
 8026640:	da0b      	bge.n	802665a <__kernel_rem_pio2f+0x4ce>
 8026642:	b10d      	cbz	r5, 8026648 <__kernel_rem_pio2f+0x4bc>
 8026644:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8026648:	9b00      	ldr	r3, [sp, #0]
 802664a:	6058      	str	r0, [r3, #4]
 802664c:	e7b1      	b.n	80265b2 <__kernel_rem_pio2f+0x426>
 802664e:	46a0      	mov	r8, r4
 8026650:	2000      	movs	r0, #0
 8026652:	af32      	add	r7, sp, #200	; 0xc8
 8026654:	e7e5      	b.n	8026622 <__kernel_rem_pio2f+0x496>
 8026656:	4603      	mov	r3, r0
 8026658:	e7e9      	b.n	802662e <__kernel_rem_pio2f+0x4a2>
 802665a:	f857 1f04 	ldr.w	r1, [r7, #4]!
 802665e:	f7da faa1 	bl	8000ba4 <__addsf3>
 8026662:	f108 0801 	add.w	r8, r8, #1
 8026666:	e7ea      	b.n	802663e <__kernel_rem_pio2f+0x4b2>
 8026668:	f8d8 3000 	ldr.w	r3, [r8]
 802666c:	f858 2c04 	ldr.w	r2, [r8, #-4]
 8026670:	4619      	mov	r1, r3
 8026672:	4610      	mov	r0, r2
 8026674:	9302      	str	r3, [sp, #8]
 8026676:	9201      	str	r2, [sp, #4]
 8026678:	f7da fa94 	bl	8000ba4 <__addsf3>
 802667c:	9a01      	ldr	r2, [sp, #4]
 802667e:	4601      	mov	r1, r0
 8026680:	4681      	mov	r9, r0
 8026682:	4610      	mov	r0, r2
 8026684:	f7da fa8c 	bl	8000ba0 <__aeabi_fsub>
 8026688:	9b02      	ldr	r3, [sp, #8]
 802668a:	f10a 3aff 	add.w	sl, sl, #4294967295
 802668e:	4619      	mov	r1, r3
 8026690:	f7da fa88 	bl	8000ba4 <__addsf3>
 8026694:	f848 0904 	str.w	r0, [r8], #-4
 8026698:	f8c8 9000 	str.w	r9, [r8]
 802669c:	e797      	b.n	80265ce <__kernel_rem_pio2f+0x442>
 802669e:	f857 3c04 	ldr.w	r3, [r7, #-4]
 80266a2:	f8d7 a000 	ldr.w	sl, [r7]
 80266a6:	4618      	mov	r0, r3
 80266a8:	4651      	mov	r1, sl
 80266aa:	9301      	str	r3, [sp, #4]
 80266ac:	f7da fa7a 	bl	8000ba4 <__addsf3>
 80266b0:	9b01      	ldr	r3, [sp, #4]
 80266b2:	4601      	mov	r1, r0
 80266b4:	4680      	mov	r8, r0
 80266b6:	4618      	mov	r0, r3
 80266b8:	f7da fa72 	bl	8000ba0 <__aeabi_fsub>
 80266bc:	4651      	mov	r1, sl
 80266be:	f7da fa71 	bl	8000ba4 <__addsf3>
 80266c2:	f847 0904 	str.w	r0, [r7], #-4
 80266c6:	f109 39ff 	add.w	r9, r9, #4294967295
 80266ca:	f8c7 8000 	str.w	r8, [r7]
 80266ce:	e782      	b.n	80265d6 <__kernel_rem_pio2f+0x44a>
 80266d0:	f85b 1024 	ldr.w	r1, [fp, r4, lsl #2]
 80266d4:	f7da fa66 	bl	8000ba4 <__addsf3>
 80266d8:	3c01      	subs	r4, #1
 80266da:	e780      	b.n	80265de <__kernel_rem_pio2f+0x452>
 80266dc:	9900      	ldr	r1, [sp, #0]
 80266de:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 80266e2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80266e6:	600a      	str	r2, [r1, #0]
 80266e8:	604b      	str	r3, [r1, #4]
 80266ea:	460a      	mov	r2, r1
 80266ec:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80266f0:	e77f      	b.n	80265f2 <__kernel_rem_pio2f+0x466>
 80266f2:	bf00      	nop

080266f4 <_init>:
 80266f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80266f6:	bf00      	nop
 80266f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80266fa:	bc08      	pop	{r3}
 80266fc:	469e      	mov	lr, r3
 80266fe:	4770      	bx	lr

08026700 <_fini>:
 8026700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026702:	bf00      	nop
 8026704:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8026706:	bc08      	pop	{r3}
 8026708:	469e      	mov	lr, r3
 802670a:	4770      	bx	lr
